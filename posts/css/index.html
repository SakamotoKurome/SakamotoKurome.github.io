<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>CSS教程 | Sakamoto Kurome</title><meta name=keywords content="CSS,Frontend"><meta name=description content="Cascading Style Sheet。 概述 简介 CSS 用于定义网页的样式，比如每个网页元素的位置、大小、颜色等等。 CSS 随着网页的诞生而诞生。1996年12月，CSS 1.0 标准"><meta name=author content="Sakamoto Kurome"><link rel=canonical href=https://sakamotokurome.github.io/posts/css/><link crossorigin=anonymous href=/assets/css/stylesheet.min.06402d745029223a9231706eea1dd82e107754f4ad625acbe7fd336a5e59566c.css integrity="sha256-BkAtdFApIjqSMXBu6h3YLhB3VPStYlrL5/0zal5ZVmw=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://sakamotokurome.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sakamotokurome.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sakamotokurome.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://sakamotokurome.github.io/apple-touch-icon.png><link rel=mask-icon href=https://sakamotokurome.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.111.3"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=https://sakamotokurome.github.io/custom.css><meta name=google-site-verification content="i2r403EffR8m-KBf7EHi6AYg7tfnMshaXTAynoYPnpE"><script async src="https://www.googletagmanager.com/gtag/js?id=G-K2Y212LPQ2"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-K2Y212LPQ2",{anonymize_ip:!1})}</script><meta property="og:title" content="CSS教程"><meta property="og:description" content="Cascading Style Sheet。 概述 简介 CSS 用于定义网页的样式，比如每个网页元素的位置、大小、颜色等等。 CSS 随着网页的诞生而诞生。1996年12月，CSS 1.0 标准"><meta property="og:type" content="article"><meta property="og:url" content="https://sakamotokurome.github.io/posts/css/"><meta property="og:image" content="https://sakamotokurome.github.io/Covers/w3_css-ar21.svg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-02-20T01:15:17+08:00"><meta property="article:modified_time" content="2023-02-20T01:15:17+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sakamotokurome.github.io/Covers/w3_css-ar21.svg"><meta name=twitter:title content="CSS教程"><meta name=twitter:description content="Cascading Style Sheet。 概述 简介 CSS 用于定义网页的样式，比如每个网页元素的位置、大小、颜色等等。 CSS 随着网页的诞生而诞生。1996年12月，CSS 1.0 标准"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sakamotokurome.github.io/posts/"},{"@type":"ListItem","position":2,"name":"CSS教程","item":"https://sakamotokurome.github.io/posts/css/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"CSS教程","name":"CSS教程","description":"Cascading Style Sheet。 概述 简介 CSS 用于定义网页的样式，比如每个网页元素的位置、大小、颜色等等。 CSS 随着网页的诞生而诞生。1996年12月，CSS 1.0 标准","keywords":["CSS","Frontend"],"articleBody":"Cascading Style Sheet。\n概述 简介 CSS 用于定义网页的样式，比如每个网页元素的位置、大小、颜色等等。\nCSS 随着网页的诞生而诞生。1996年12月，CSS 1.0 标准问世，目前广泛使用的是2000年4月发布的 CSS 3 标准。\nCSS 3 采用模块化结构，每个模块都是独立定义的，定义完成以后，再加入 CSS 标准。截止2017年，CSS 共有88个模块，下面是其中一次主要模块。\nDisplay Box alignment Flexible box CSS Grid Inline Layout Position Layout CSS Shapes CSS Transforms CSS 样式表就是一个文本文件，定义每个网页元素的样式规则。\nCSS 优点：\n使数据和显示分开。 降低网络流量。 使整个网站视觉效果一致。 使开发效率提高了。耦合性降低，一个人负责写 html，一个人负责写 css。 样式表嵌入网页的方法 行内样式：在某个特定的标签里采用 style 属性。范围只针对此标签。\n\u003cp style=\"color: white; background-color: red;\"\u003e\u003c/p\u003e 内嵌样式表：在页面的 head 里采用 ","wordCount":"73367","inLanguage":"en","image":"https://sakamotokurome.github.io/Covers/w3_css-ar21.svg","datePublished":"2023-02-20T01:15:17+08:00","dateModified":"2023-02-20T01:15:17+08:00","author":{"@type":"Person","name":"Sakamoto Kurome"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sakamotokurome.github.io/posts/css/"},"publisher":{"@type":"Organization","name":"Sakamoto Kurome","logo":{"@type":"ImageObject","url":"https://sakamotokurome.github.io/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://sakamotokurome.github.io/ accesskey=h title="Sakamoto Kurome (Alt + H)">Sakamoto Kurome</a>
<span class=logo-switches></span></div><ul id=menu><li><a href=https://sakamotokurome.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://sakamotokurome.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://sakamotokurome.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>CSS教程</h1><div class=post-meta><span title='2023-02-20 01:15:17 +0800 +0800'>February 20, 2023</span>&nbsp;·&nbsp;147 min&nbsp;·&nbsp;Sakamoto Kurome</div></header><figure class=entry-cover><img loading=lazy src=https://sakamotokurome.github.io/Covers/w3_css-ar21.svg alt="CSS教程 cover"><p>CSS教程</p></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e6%a6%82%e8%bf%b0 aria-label=概述>概述</a><ul><li><a href=#%e7%ae%80%e4%bb%8b aria-label=简介>简介</a></li><li><a href=#%e6%a0%b7%e5%bc%8f%e8%a1%a8%e5%b5%8c%e5%85%a5%e7%bd%91%e9%a1%b5%e7%9a%84%e6%96%b9%e6%b3%95 aria-label=样式表嵌入网页的方法>样式表嵌入网页的方法</a></li><li><a href=#css-%e8%af%ad%e6%b3%95 aria-label="CSS 语法">CSS 语法</a></li><li><a href=#css-%e6%b3%a8%e9%87%8a aria-label="CSS 注释">CSS 注释</a></li><li><a href=#css-%e5%b1%9e%e6%80%a7%e5%80%bc%e5%ae%9a%e4%b9%89%e8%af%ad%e6%b3%95httpsdevelopermozillaorgzh-cndocswebcssvalue_definition_syntax aria-label="CSS 属性值定义语法"><a href=https://developer.mozilla.org/zh-CN/docs/Web/CSS/Value_definition_syntax>CSS 属性值定义语法</a></a></li><li><a href=#%e8%a7%84%e5%88%99 aria-label=@规则>@规则</a><ul><li><a href=#media aria-label=@media>@media</a></li><li><a href=#charset aria-label=@charset>@charset</a></li><li><a href=#importhttpsdevelopermozillaorgzh-cndocswebcssimport aria-label=@import><a href=https://developer.mozilla.org/zh-CN/docs/Web/CSS/@import>@import</a></a></li><li><a href=#supports aria-label=@supports>@supports</a></li><li><a href=#property aria-label=@property>@property</a></li><li><a href=#container aria-label=@container>@container</a></li><li><a href=#scope aria-label=@scope>@scope</a></li><li><a href=#layer aria-label=@layer>@layer</a></li><li><a href=#%e6%89%93%e5%8d%b0%e6%a0%b7%e5%bc%8f aria-label=打印样式>打印样式</a></li><li><a href=#%e5%b5%8c%e5%a5%97 aria-label=嵌套>嵌套</a></li></ul></li><li><a href=#%e5%80%bc%e5%92%8c%e5%8d%95%e4%bd%8d aria-label=值和单位>值和单位</a><ul><li><a href=#px aria-label=px>px</a></li><li><a href=#em aria-label=em>em</a></li><li><a href=#rem aria-label=rem>rem</a></li><li><a href=#vwvh aria-label=vw/vh>vw/vh</a></li><li><a href=#ch aria-label=ch>ch</a></li><li><a href=#calc aria-label=calc()>calc()</a></li><li><a href=#attr aria-label=attr()>attr()</a></li><li><a href=#min-%e5%92%8c-maxhttpsjuejincnpost6974239153269506084heading-6 aria-label="min() 和 max()"><a href=https://juejin.cn/post/6974239153269506084#heading-6>min() 和 max()</a></a></li><li><a href=#clamp aria-label=clamp()>clamp()</a></li></ul></li><li><a href=#%e9%a2%9c%e8%89%b2%e4%bd%93%e7%b3%bb aria-label=颜色体系>颜色体系</a><ul><li><a href=#%e9%a2%9c%e8%89%b2%e5%85%b3%e9%94%ae%e5%ad%97 aria-label=颜色关键字>颜色关键字</a></li><li><a href=#rgba-%e9%a2%9c%e8%89%b2 aria-label="RGB[A] 颜色">RGB[A] 颜色</a></li><li><a href=#hsla-%e9%a2%9c%e8%89%b2 aria-label="HSL[A] 颜色">HSL[A] 颜色</a></li><li><a href=#%e9%85%8d%e8%89%b2%e6%96%b9%e6%a1%88 aria-label=配色方案>配色方案</a></li><li><a href=#%e9%a2%9c%e8%89%b2%e5%87%bd%e6%95%b0 aria-label=颜色函数>颜色函数</a></li><li><a href=#css-%e6%b7%b7%e5%90%88%e6%a8%a1%e5%bc%8f aria-label="CSS 混合模式">CSS 混合模式</a></li></ul></li><li><a href=#css-%e5%8f%98%e9%87%8f aria-label="CSS 变量">CSS 变量</a></li><li><a href=#%e5%ba%94%e7%94%a8%e6%97%a0%e9%9a%9c%e7%a2%8d aria-label=应用无障碍>应用无障碍</a></li></ul></li><li><a href=#%e6%b5%81 aria-label=流>流</a></li><li><a href=#%e7%9b%92%e6%a8%a1%e5%9e%8b aria-label=盒模型>盒模型</a><ul><li><a href=#%e8%a7%86%e8%a7%89%e6%a0%bc%e5%bc%8f%e5%8c%96%e6%a8%a1%e5%9e%8b aria-label=视觉格式化模型>视觉格式化模型</a><ul><li><a href=#outer-display-type aria-label="outer display type">outer display type</a></li><li><a href=#inner-display-type aria-label="inner display type">inner display type</a></li></ul></li><li><a href=#%e5%86%85%e8%81%94%e7%9b%92%e6%a8%a1%e5%9e%8b aria-label=内联盒模型>内联盒模型</a></li><li><a href=#%e6%9b%bf%e6%8d%a2%e5%85%83%e7%b4%a0 aria-label=替换元素>替换元素</a></li><li><a href=#widthheight-%e5%b1%9e%e6%80%a7 aria-label="width/height 属性">width/height 属性</a></li><li><a href=#content-%e5%b1%9e%e6%80%a7 aria-label="content 属性">content 属性</a></li><li><a href=#padding-%e5%b1%9e%e6%80%a7 aria-label="padding 属性">padding 属性</a></li><li><a href=#border-%e5%b1%9e%e6%80%a7 aria-label="border 属性">border 属性</a></li><li><a href=#margin-%e5%b1%9e%e6%80%a7 aria-label="margin 属性">margin 属性</a><ul><li><a href=#margin-%e4%b8%ba%e8%b4%9f%e5%80%bchttpswwwcnblogscomxiaohuochaip5314289html aria-label="margin 为负值"><a href=https://www.cnblogs.com/xiaohuochai/p/5314289.html>margin 为负值</a></a></li></ul></li><li><a href=#box-sizing-%e5%b1%9e%e6%80%a7 aria-label="box-sizing 属性">box-sizing 属性</a></li><li><a href=#display-%e5%b1%9e%e6%80%a7 aria-label="display 属性">display 属性</a></li><li><a href=#overflow-%e5%b1%9e%e6%80%a7 aria-label="overflow 属性">overflow 属性</a></li><li><a href=#%e6%bb%9a%e5%8a%a8%e6%8d%95%e6%8d%89 aria-label=滚动捕捉>滚动捕捉</a></li><li><a href=#cliphttpswwwzhangxinxucomwordpress201104css-clip-rect aria-label=clip><a href=https://www.zhangxinxu.com/wordpress/2011/04/css-clip-rect/>clip</a></a></li><li><a href=#%e8%92%99%e5%b1%82%e5%92%8c%e5%89%aa%e5%88%87 aria-label=蒙层和剪切>蒙层和剪切</a><ul><li><a href=#mask-%e5%b1%9e%e6%80%a7 aria-label="mask 属性">mask 属性</a></li><li><a href=#clip-path-%e5%b1%9e%e6%80%a7 aria-label="clip-path 属性">clip-path 属性</a></li></ul></li><li><a href=#opacity aria-label=opacity>opacity</a></li><li><a href=#object-fit aria-label=object-fit>object-fit</a></li><li><a href=#object-position aria-label=object-position>object-position</a></li><li><a href=#outline aria-label=outline>outline</a></li><li><a href=#%e7%ad%89%e6%af%94%e7%bc%a9%e6%94%behttpscodepenioairenfullexwjezr aria-label=等比缩放><a href=https://codepen.io/airen/full/ExWjeZr>等比缩放</a></a></li><li><a href=#%e9%80%bb%e8%be%91%e5%b1%9e%e6%80%a7httpsjuejincnpost6974239153269506084heading-3 aria-label=逻辑属性><a href=https://juejin.cn/post/6974239153269506084#heading-3>逻辑属性</a></a></li><li><a href=#%e5%86%85%e5%ae%b9%e5%8f%af%e8%a7%81%e6%80%a7 aria-label=内容可见性>内容可见性</a></li><li><a href=#%e5%86%85%e5%9c%a8%e5%b0%ba%e5%af%b8 aria-label=内在尺寸>内在尺寸</a></li></ul></li><li><a href=#%e6%a0%bc%e5%bc%8f%e5%8c%96%e4%b8%8a%e4%b8%8b%e6%96%87 aria-label=格式化上下文>格式化上下文</a><ul><li><a href=#bfc aria-label=BFC>BFC</a><ul><li><a href=#bfc-%e6%b8%b2%e6%9f%93%e8%a7%84%e5%88%99 aria-label="BFC 渲染规则">BFC 渲染规则</a></li><li><a href=#%e5%88%9b%e5%bb%ba-bfc aria-label="创建 BFC">创建 BFC</a></li><li><a href=#bfc-%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af aria-label="BFC 应用场景">BFC 应用场景</a></li></ul></li><li><a href=#ifc aria-label=IFC>IFC</a><ul><li><a href=#ifc-%e6%b8%b2%e6%9f%93%e8%a7%84%e5%88%99 aria-label="IFC 渲染规则">IFC 渲染规则</a></li><li><a href=#ifc-%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af aria-label="IFC 应用场景">IFC 应用场景</a></li></ul></li></ul></li><li><a href=#%e6%b5%81%e7%9a%84%e7%a0%b4%e5%9d%8f aria-label=流的破坏>流的破坏</a><ul><li><a href=#float-%e5%b1%9e%e6%80%a7 aria-label="float 属性">float 属性</a></li><li><a href=#position-%e5%b1%9e%e6%80%a7 aria-label="position 属性">position 属性</a><ul><li><a href=#static-%e5%ae%9a%e4%bd%8d aria-label="static 定位">static 定位</a></li><li><a href=#%e7%9b%b8%e5%af%b9%e5%ae%9a%e4%bd%8d aria-label=相对定位>相对定位</a></li><li><a href=#%e7%bb%9d%e5%af%b9%e5%ae%9a%e4%bd%8d aria-label=绝对定位>绝对定位</a></li><li><a href=#%e5%9b%ba%e5%ae%9a%e5%ae%9a%e4%bd%8d aria-label=固定定位>固定定位</a></li><li><a href=#%e7%b2%98%e6%80%a7%e5%ae%9a%e4%bd%8d aria-label=粘性定位>粘性定位</a></li><li><a href=#z-index-%e5%b1%9e%e6%80%a7 aria-label="z-index 属性">z-index 属性</a></li></ul></li></ul></li><li><a href=#%e5%b1%82%e5%8f%a0%e4%b8%8a%e4%b8%8b%e6%96%87 aria-label=层叠上下文>层叠上下文</a><ul><li><a href=#%e5%88%9b%e5%bb%ba%e5%b1%82%e5%8f%a0%e4%b8%8a%e4%b8%8b%e6%96%87 aria-label=创建层叠上下文>创建层叠上下文</a></li><li><a href=#%e5%b1%82%e5%8f%a0%e7%ad%89%e7%ba%a7 aria-label=层叠等级>层叠等级</a></li><li><a href=#%e5%b1%82%e5%8f%a0%e9%a1%ba%e5%ba%8f aria-label=层叠顺序>层叠顺序</a></li></ul></li><li><a href=#%e6%b8%90%e8%bf%9b%e5%a2%9e%e5%bc%ba%e5%92%8c%e4%bc%98%e9%9b%85%e9%99%8d%e7%ba%a7 aria-label=渐进增强和优雅降级>渐进增强和优雅降级</a><ul><li><a href=#%e6%b8%90%e8%bf%9b%e5%a2%9e%e5%bc%ba aria-label=渐进增强>渐进增强</a></li><li><a href=#%e4%bc%98%e9%9b%85%e9%99%8d%e7%ba%a7 aria-label=优雅降级>优雅降级</a></li><li><a href=#%e4%ba%8c%e8%80%85%e5%8c%ba%e5%88%ab aria-label=二者区别>二者区别</a></li></ul></li><li><a href=#%e9%80%89%e6%8b%a9%e5%99%a8 aria-label=选择器>选择器</a><ul><li><a href=#%e5%9f%ba%e6%9c%ac%e9%80%89%e6%8b%a9%e5%99%a8 aria-label=基本选择器>基本选择器</a><ul><li><a href=#%e9%80%9a%e7%94%a8%e5%85%83%e7%b4%a0%e9%80%89%e6%8b%a9%e5%99%a8 aria-label=通用元素选择器>通用元素选择器</a></li><li><a href=#%e6%a0%87%e7%ad%be%e9%80%89%e6%8b%a9%e5%99%a8 aria-label=标签选择器>标签选择器</a></li><li><a href=#%e7%b1%bb%e9%80%89%e6%8b%a9%e5%99%a8 aria-label=类选择器>类选择器</a><ul><li><a href=#bem%e5%91%bd%e5%90%8d%e6%b3%95 aria-label=BEM命名法>BEM命名法</a></li></ul></li><li><a href=#id-%e9%80%89%e6%8b%a9%e5%99%a8 aria-label="ID 选择器">ID 选择器</a></li><li><a href=#%e5%b1%9e%e6%80%a7%e9%80%89%e6%8b%a9%e5%99%a8 aria-label=属性选择器>属性选择器</a></li></ul></li><li><a href=#%e5%88%86%e7%bb%84%e9%80%89%e6%8b%a9%e5%99%a8 aria-label=分组选择器>分组选择器</a><ul><li><a href=#%e4%ba%a4%e9%9b%86%e9%80%89%e6%8b%a9%e5%99%a8 aria-label=交集选择器>交集选择器</a></li><li><a href=#%e5%a4%9a%e5%85%83%e7%b4%a0%e9%80%89%e6%8b%a9%e5%99%a8 aria-label=多元素选择器>多元素选择器</a><ul><li><a href=#matches aria-label=:matches()>:matches()</a></li></ul></li></ul></li><li><a href=#%e7%bb%84%e5%90%88%e5%99%a8 aria-label=组合器>组合器</a><ul><li><a href=#%e5%90%8e%e4%bb%a3%e5%85%83%e7%b4%a0%e9%80%89%e6%8b%a9%e5%99%a8 aria-label=后代元素选择器>后代元素选择器</a></li><li><a href=#%e5%ad%90%e5%85%83%e7%b4%a0%e9%80%89%e6%8b%a9%e5%99%a8 aria-label=子元素选择器>子元素选择器</a></li><li><a href=#%e4%b8%80%e8%88%ac%e5%85%84%e5%bc%9f%e7%bb%84%e5%90%88%e5%99%a8 aria-label=一般兄弟组合器>一般兄弟组合器</a></li><li><a href=#%e6%af%97%e9%82%bb%e5%85%83%e7%b4%a0%e9%80%89%e6%8b%a9%e5%99%a8 aria-label=毗邻元素选择器>毗邻元素选择器</a></li></ul></li><li><a href=#%e4%bc%aa%e9%80%89%e6%8b%a9%e5%99%a8 aria-label=伪选择器>伪选择器</a><ul><li><a href=#%e4%bc%aa%e7%b1%bb%e9%80%89%e6%8b%a9%e5%99%a8 aria-label=伪类选择器>伪类选择器</a></li><li><a href=#%e4%bc%aa%e5%85%83%e7%b4%a0%e9%80%89%e6%8b%a9%e5%99%a8 aria-label=伪元素选择器>伪元素选择器</a></li></ul></li></ul></li><li><a href=#%e7%bb%a7%e6%89%bf%e6%80%a7%e5%92%8c%e5%b1%82%e5%8f%a0%e6%80%a7 aria-label=继承性和层叠性>继承性和层叠性</a><ul><li><a href=#%e7%bb%a7%e6%89%bf%e6%80%a7 aria-label=继承性>继承性</a><ul><li><a href=#%e9%bb%98%e8%ae%a4%e7%bb%a7%e6%89%bf%e7%9a%84-inherited-yes-%e7%9a%84%e5%b1%9e%e6%80%a7 aria-label="默认继承的 (&amp;ldquo;Inherited: Yes&amp;rdquo;) 的属性">默认继承的 (&ldquo;Inherited: Yes&rdquo;) 的属性</a></li><li><a href=#%e5%9b%9b%e4%b8%aa%e9%80%9a%e7%94%a8%e5%b1%9e%e6%80%a7%e5%80%bc aria-label=四个通用属性值>四个通用属性值</a><ul><li><a href=#inherit aria-label=inherit>inherit</a></li><li><a href=#initial aria-label=initial>initial</a></li><li><a href=#unset aria-label=unset>unset</a></li><li><a href=#revert aria-label=revert>revert</a></li></ul></li></ul></li><li><a href=#%e5%b1%82%e5%8f%a0%e6%80%a7 aria-label=层叠性>层叠性</a><ul><li><a href=#%e6%9d%83%e9%87%8d aria-label=权重>权重</a></li><li><a href=#important aria-label=!important>!important</a></li></ul></li></ul></li><li><a href=#web-%e5%ad%97%e4%bd%93 aria-label="Web 字体">Web 字体</a><ul><li><a href=#%e5%ad%97%e4%bd%93%e6%97%8f aria-label=字体族>字体族</a></li><li><a href=#%e5%ad%97%e4%bd%93%e6%a0%bc%e5%bc%8f aria-label=字体格式>字体格式</a></li><li><a href=#svg-%e5%9b%be%e5%83%8f aria-label="SVG 图像">SVG 图像</a></li><li><a href=#%e5%ad%97%e4%bd%93%e5%9b%be%e6%a0%87 aria-label=字体图标>字体图标</a></li><li><a href=#%e5%85%8d%e8%b4%b9%e5%8f%af%e5%95%86%e7%94%a8%e5%ad%97%e4%bd%93 aria-label=免费可商用字体>免费可商用字体</a></li><li><a href=#%e5%ad%97%e4%bd%93%e5%b1%9e%e6%80%a7 aria-label=字体属性>字体属性</a><ul><li><a href=#font-weight aria-label=font-weight>font-weight</a></li><li><a href=#font-size aria-label=font-size>font-size</a></li><li><a href=#font-smoothing aria-label=font-smoothing>font-smoothing</a></li><li><a href=#font-display aria-label=font-display>font-display</a></li><li><a href=#line-height aria-label=line-height>line-height</a></li><li><a href=#vertical-align aria-label=vertical-align>vertical-align</a></li><li><a href=#font-family aria-label=font-family>font-family</a></li></ul></li></ul></li><li><a href=#%e6%96%87%e6%9c%ac%e5%b1%9e%e6%80%a7 aria-label=文本属性>文本属性</a><ul><li><a href=#%e7%a9%ba%e6%a0%bc aria-label=空格>空格</a><ul><li><a href=#%e5%9f%ba%e6%9c%ac%e8%a7%84%e5%88%99 aria-label=基本规则>基本规则</a></li><li><a href=#%e7%a9%ba%e6%a0%bc%e5%ad%97%e7%ac%a6 aria-label=空格字符>空格字符</a></li><li><a href=#white-space aria-label=white-space>white-space</a></li></ul></li><li><a href=#direction aria-label=direction>direction</a></li><li><a href=#text-align aria-label=text-align>text-align</a></li><li><a href=#vertical-align-1 aria-label=Vertical-align>Vertical-align</a></li><li><a href=#tab-size aria-label=Tab-size>Tab-size</a></li><li><a href=#word-wrap aria-label=word-wrap>word-wrap</a></li><li><a href=#word-break aria-label=word-break>word-break</a></li><li><a href=#hyphens aria-label=hyphens>hyphens</a></li><li><a href=#letter-spacing aria-label=letter-spacing>letter-spacing</a></li><li><a href=#word-spacing aria-label=word-spacing>word-spacing</a></li><li><a href=#text-decoration aria-label=text-decoration>text-decoration</a></li><li><a href=#color aria-label=color>color</a></li><li><a href=#text-transform aria-label=text-transform>text-transform</a></li><li><a href=#text-shadow aria-label=text-shadow>text-shadow</a></li><li><a href=#text-indent aria-label=text-indent>text-indent</a></li><li><a href=#text-overflow aria-label=text-overflow>text-overflow</a></li><li><a href=#initial-letter aria-label=initial-letter>initial-letter</a></li><li><a href=#user-select aria-label=user-select>user-select</a></li><li><a href=#cursor aria-label=cursor>cursor</a></li><li><a href=#pointer-events aria-label=pointer-events>pointer-events</a></li></ul></li><li><a href=#%e5%88%97%e8%a1%a8%e5%b1%9e%e6%80%a7 aria-label=列表属性>列表属性</a><ul><li><a href=#list-style-image aria-label=list-style-image>list-style-image</a></li><li><a href=#list-style-type aria-label=list-style-type>list-style-type</a></li><li><a href=#list-style-position aria-label=list-style-position>list-style-position</a></li></ul></li><li><a href=#%e8%83%8c%e6%99%af%e5%b1%9e%e6%80%a7 aria-label=背景属性>背景属性</a><ul><li><a href=#opaque aria-label=opaque>opaque</a></li><li><a href=#background-color aria-label=background-color>background-color</a></li><li><a href=#background-image aria-label=background-image>background-image</a><ul><li><a href=#gradienthttpwwwalloyteamcom201603css-gradient aria-label=Gradient><a href=http://www.alloyteam.com/2016/03/css-gradient/>Gradient</a></a></li></ul></li><li><a href=#background-position aria-label=background-position>background-position</a></li><li><a href=#background-size aria-label=background-size>background-size</a></li><li><a href=#background-repeat aria-label=background-repeat>background-repeat</a></li><li><a href=#background-attachment aria-label=background-attachment>background-attachment</a></li><li><a href=#background-origin aria-label=background-origin>background-origin</a></li><li><a href=#background-clip aria-label=background-clip>background-clip</a></li><li><a href=#backgroundhttpsjuejincnpost6844903463273381901 aria-label=background><a href=https://juejin.cn/post/6844903463273381901>background</a></a></li><li><a href=#background-blend-mode aria-label=background-blend-mode>background-blend-mode</a></li><li><a href=#mix-blend-mode aria-label=mix-blend-mode>mix-blend-mode</a></li></ul></li><li><a href=#filter aria-label=filter>filter</a></li><li><a href=#%e5%8a%a8%e7%94%bb aria-label=动画>动画</a><ul><li><a href=#transitionhttpswwwruanyifengcomblog201402css_transition_and_animationhtml aria-label=transition><a href=https://www.ruanyifeng.com/blog/2014/02/css_transition_and_animation.html>transition</a></a><ul><li><a href=#%e5%9f%ba%e6%9c%ac%e7%94%a8%e6%b3%95 aria-label=基本用法>基本用法</a></li><li><a href=#transition-delay aria-label=transition-delay>transition-delay</a></li><li><a href=#transition-timing-function aria-label=transition-timing-function>transition-timing-function</a></li><li><a href=#transition%e7%9a%84%e5%90%84%e9%a1%b9%e5%b1%9e%e6%80%a7 aria-label=transition的各项属性>transition的各项属性</a></li><li><a href=#transition%e7%9a%84%e4%bd%bf%e7%94%a8%e6%b3%a8%e6%84%8f aria-label=transition的使用注意>transition的使用注意</a></li><li><a href=#transition%e7%9a%84%e5%b1%80%e9%99%90 aria-label=transition的局限>transition的局限</a></li></ul></li><li><a href=#animationhttpswwwruanyifengcomblog201402css_transition_and_animationhtml aria-label=Animation><a href=https://www.ruanyifeng.com/blog/2014/02/css_transition_and_animation.html>Animation</a></a><ul><li><a href=#%e5%9f%ba%e6%9c%ac%e7%94%a8%e6%b3%95-1 aria-label=基本用法>基本用法</a></li><li><a href=#animation-fill-mode aria-label=animation-fill-mode>animation-fill-mode</a></li><li><a href=#animation-direction aria-label=animation-direction>animation-direction</a></li><li><a href=#animation%e7%9a%84%e5%90%84%e9%a1%b9%e5%b1%9e%e6%80%a7 aria-label=animation的各项属性>animation的各项属性</a></li><li><a href=#keyframes%e7%9a%84%e5%86%99%e6%b3%95 aria-label=keyframes的写法>keyframes的写法</a></li><li><a href=#animation-play-state aria-label=animation-play-state>animation-play-state</a></li><li><a href=#%e8%b4%9d%e5%a1%9e%e5%b0%94%e6%9b%b2%e7%ba%bf aria-label=贝塞尔曲线>贝塞尔曲线</a></li></ul></li><li><a href=#transform aria-label=transform>transform</a><ul><li><a href=#2d-%e8%bd%ac%e6%8d%a2 aria-label="2D 转换">2D 转换</a><ul><li><a href=#%e7%bc%a9%e6%94%be aria-label=缩放>缩放</a></li><li><a href=#%e4%bd%8d%e7%a7%bb aria-label=位移>位移</a></li><li><a href=#%e6%97%8b%e8%bd%ac aria-label=旋转>旋转</a></li><li><a href=#%e5%80%be%e6%96%9c aria-label=倾斜>倾斜</a></li></ul></li><li><a href=#3d-%e8%bd%ac%e6%8d%a2 aria-label="3D 转换">3D 转换</a><ul><li><a href=#%e6%97%8b%e8%bd%ac-1 aria-label=旋转>旋转</a></li><li><a href=#%e7%a7%bb%e5%8a%a8 aria-label=移动>移动</a></li><li><a href=#%e9%80%8f%e8%a7%86 aria-label=透视>透视</a></li><li><a href=#3d-%e5%91%88%e7%8e%b0 aria-label="3D 呈现">3D 呈现</a></li></ul></li></ul></li></ul></li><li><a href=#%e5%a4%9a%e6%a0%8f%e5%bc%8f%e5%b8%83%e5%b1%80 aria-label=多栏式布局>多栏式布局</a><ul><li><a href=#%e5%9f%ba%e6%9c%ac%e7%94%a8%e6%b3%95-2 aria-label=基本用法>基本用法</a></li><li><a href=#%e9%97%b4%e9%9a%94 aria-label=间隔>间隔</a></li><li><a href=#column-span aria-label=column-span>column-span</a></li><li><a href=#column-fill aria-label=column-fill>column-fill</a></li><li><a href=#%e5%86%85%e5%ae%b9%e7%9a%84%e6%96%ad%e7%82%b9 aria-label=内容的断点>内容的断点</a></li></ul></li><li><a href=#table-%e5%b8%83%e5%b1%80 aria-label="Table 布局">Table 布局</a></li><li><a href=#flex-%e5%b8%83%e5%b1%80httpswwwruanyifengcomblog201507flex-grammarhtml aria-label="Flex 布局"><a href=https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html>Flex 布局</a></a><ul><li><a href=#flex-%e5%b8%83%e5%b1%80%e7%ae%80%e4%bb%8b aria-label="Flex 布局简介">Flex 布局简介</a></li><li><a href=#%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5 aria-label=基本概念>基本概念</a></li><li><a href=#%e5%ae%b9%e5%99%a8%e7%9a%84%e5%b1%9e%e6%80%a7 aria-label=容器的属性>容器的属性</a><ul><li><a href=#flex-direction aria-label=flex-direction>flex-direction</a></li><li><a href=#flex-wrap aria-label=flex-wrap>flex-wrap</a></li><li><a href=#flex-flow aria-label=flex-flow>flex-flow</a></li><li><a href=#justify-content aria-label=justify-content>justify-content</a></li><li><a href=#align-items aria-label=align-items>align-items</a></li><li><a href=#align-content aria-label=align-content>align-content</a></li></ul></li><li><a href=#%e9%a1%b9%e7%9b%ae%e7%9a%84%e5%b1%9e%e6%80%a7 aria-label=项目的属性>项目的属性</a><ul><li><a href=#order aria-label=order>order</a></li><li><a href=#flex-grow aria-label=flex-grow>flex-grow</a></li><li><a href=#flex-shrink aria-label=flex-shrink>flex-shrink</a></li><li><a href=#flex-basis aria-label=flex-basis>flex-basis</a></li><li><a href=#flex aria-label=flex>flex</a></li><li><a href=#align-self aria-label=align-self>align-self</a></li></ul></li></ul></li><li><a href=#grid-%e5%b8%83%e5%b1%80httpswwwruanyifengcomblog201903grid-layout-tutorialhtml aria-label="Grid 布局"><a href=https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html>Grid 布局</a></a><ul><li><a href=#%e6%a6%82%e8%bf%b0-1 aria-label=概述>概述</a></li><li><a href=#%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5-1 aria-label=基本概念>基本概念</a><ul><li><a href=#%e5%ae%b9%e5%99%a8%e5%92%8c%e9%a1%b9%e7%9b%ae aria-label=容器和项目>容器和项目</a></li><li><a href=#%e8%a1%8c%e5%92%8c%e5%88%97 aria-label=行和列>行和列</a></li><li><a href=#%e5%8d%95%e5%85%83%e6%a0%bc%e7%bd%91%e6%a0%bc%e5%8d%95%e5%85%83 aria-label=单元格（网格单元）>单元格（网格单元）</a></li><li><a href=#%e7%bd%91%e6%a0%bc%e7%ba%bf aria-label=网格线>网格线</a></li><li><a href=#%e9%9a%90%e5%bc%8f%e5%92%8c%e6%98%be%e5%bc%8f%e7%bd%91%e6%a0%bc aria-label=隐式和显式网格>隐式和显式网格</a></li></ul></li><li><a href=#%e5%ae%b9%e5%99%a8%e5%b1%9e%e6%80%a7 aria-label=容器属性>容器属性</a><ul><li><a href=#display aria-label=display>display</a></li><li><a href=#grid-template-columnsgrid-template-rows aria-label=grid-template-columns，grid-template-rows>grid-template-columns，grid-template-rows</a></li><li><a href=#row-gapcolumn-gapgap aria-label=row-gap，column-gap，gap>row-gap，column-gap，gap</a></li><li><a href=#grid-template-areas aria-label=grid-template-areas>grid-template-areas</a></li><li><a href=#grid-auto-flow aria-label=grid-auto-flow>grid-auto-flow</a></li><li><a href=#justify-itemsalign-itemsplace-items aria-label=justify-items，align-items，place-items>justify-items，align-items，place-items</a></li><li><a href=#justify-contentalign-contentplace-content aria-label=justify-content，align-content，place-content>justify-content，align-content，place-content</a></li><li><a href=#grid-auto-columnsgrid-auto-rows aria-label=grid-auto-columns，grid-auto-rows>grid-auto-columns，grid-auto-rows</a></li><li><a href=#grid-templategrid aria-label=grid-template，grid>grid-template，grid</a></li></ul></li><li><a href=#%e9%a1%b9%e7%9b%ae%e5%b1%9e%e6%80%a7 aria-label=项目属性>项目属性</a><ul><li><a href=#grid-column-startgrid-column-endgrid-row-startgrid-row-end aria-label=grid-column-start，grid-column-end，grid-row-start，grid-row-end>grid-column-start，grid-column-end，grid-row-start，grid-row-end</a></li><li><a href=#grid-column-grid-row aria-label="grid-column， grid-row">grid-column， grid-row</a></li><li><a href=#grid-area aria-label=grid-area>grid-area</a></li><li><a href=#justify-self-align-self-place-self aria-label="justify-self， align-self， place-self">justify-self， align-self， place-self</a></li></ul></li><li><a href=#%e8%a1%a5%e5%85%85 aria-label=补充>补充</a><ul><li><a href=#%e7%bd%91%e6%a0%bc%e5%b8%83%e5%b1%80%e4%b8%ad%e7%9a%84%e7%9b%92%e6%a8%a1%e5%9e%8b%e5%af%b9%e9%bd%90httpsdevelopermozillaorgzh-cndocswebcsscss_grid_layoutbox_alignment_in_css_grid_layout aria-label=网格布局中的盒模型对齐><a href=https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Box_Alignment_in_CSS_Grid_Layout>网格布局中的盒模型对齐</a></a></li><li><a href=#%e4%bd%9c%e4%b8%ba%e5%8c%85%e5%90%ab%e5%9d%97%e7%9a%84%e7%bd%91%e6%a0%bc%e5%ae%b9%e5%99%a8httpsdevelopermozillaorgzh-cndocswebcsscss_grid_layoutrelationship_of_grid_layout%e4%bd%9c%e4%b8%ba%e5%8c%85%e5%90%ab%e5%9d%97%e7%9a%84%e7%bd%91%e6%a0%bc%e5%ae%b9%e5%99%a8 aria-label=作为包含块的网格容器><a href=https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Relationship_of_Grid_Layout#%E4%BD%9C%E4%B8%BA%E5%8C%85%E5%90%AB%E5%9D%97%E7%9A%84%E7%BD%91%E6%A0%BC%E5%AE%B9%E5%99%A8>作为包含块的网格容器</a></a></li><li><a href=#%e7%bd%91%e6%a0%bc%e5%92%8c-display-contentshttpsdevelopermozillaorgzh-cndocswebcsscss_grid_layoutrelationship_of_grid_layout%e7%bd%91%e6%a0%bc%e5%92%8c_display_contents aria-label="网格和 display: contents"><a href=https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Relationship_of_Grid_Layout#%E7%BD%91%E6%A0%BC%E5%92%8C_display_contents>网格和 <code>display: contents</code></a></a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><p>Cascading Style Sheet。</p><h2 id=概述>概述<a hidden class=anchor aria-hidden=true href=#概述>#</a></h2><h3 id=简介>简介<a hidden class=anchor aria-hidden=true href=#简介>#</a></h3><p>CSS 用于定义网页的样式，比如每个网页元素的位置、大小、颜色等等。</p><p>CSS 随着网页的诞生而诞生。1996年12月，CSS 1.0 标准问世，目前广泛使用的是2000年4月发布的 CSS 3 标准。</p><p>CSS 3 采用模块化结构，每个模块都是独立定义的，定义完成以后，再加入 CSS 标准。截止2017年，CSS 共有88个模块，下面是其中一次主要模块。</p><blockquote><ul><li>Display</li><li>Box alignment</li><li>Flexible box</li><li>CSS Grid</li><li>Inline Layout</li><li>Position Layout</li><li>CSS Shapes</li><li>CSS Transforms</li></ul></blockquote><p>CSS 样式表就是一个文本文件，定义每个网页元素的样式规则。</p><p>CSS 优点：</p><ul><li>使数据和显示分开。</li><li>降低网络流量。</li><li>使整个网站视觉效果一致。</li><li>使开发效率提高了。耦合性降低，一个人负责写 html，一个人负责写 css。</li></ul><h3 id=样式表嵌入网页的方法>样式表嵌入网页的方法<a hidden class=anchor aria-hidden=true href=#样式表嵌入网页的方法>#</a></h3><ul><li><p>行内样式：在某个特定的标签里采用 style 属性。范围只针对此标签。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>p</span> <span style=color:#a6e22e>style</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;color: white; background-color: red;&#34;</span>&gt;&lt;/<span style=color:#f92672>p</span>&gt;
</span></span></code></pre></div></li><li><p>内嵌样式表：在页面的 head 里采用 <code>&lt;style> </code>标签。范围针对此页面。需要确保元素的样式定义在开始和结束样式标签之间。 需要确保所有样式规则位于花括号之间，并且每条样式规则都以分号结束。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>style</span> <span style=color:#a6e22e>type</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;text/css&#34;</span>&gt;&lt;/<span style=color:#f92672>style</span>&gt;
</span></span></code></pre></div></li><li><p>引入外部样式表</p><ul><li><p>采用 <code>&lt;link></code> 标签。link是XTHML标签，无兼容问题。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>link</span> <span style=color:#a6e22e>rel</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;stylesheet&#34;</span> <span style=color:#a6e22e>type</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;text/css&#34;</span> <span style=color:#a6e22e>href</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;cssfile.css&#34;</span>&gt;&lt;/<span style=color:#f92672>link</span>&gt;
</span></span></code></pre></div><p>rel 属性还可以是 <code>alternate stylesheet</code>，用户可以选择。</p><p>你可以通过给 <code>&lt;link></code> 加上 media 属性来指定该样式文件只能对什么设备生效，不指定的话默认是 all，即对所有设备都生效：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>link</span> <span style=color:#a6e22e>rel</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;stylesheet&#34;</span> <span style=color:#a6e22e>src</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;styles.css&#34;</span> <span style=color:#a6e22e>media</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;screen&#34;</span> /&gt;
</span></span></code></pre></div></li><li><p>采用 import：必须写在 <code>&lt;style></code> 标签中，并且必须是第一句。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>style</span>&gt;
</span></span><span style=display:flex><span> @<span style=color:#66d9ef>import</span> <span style=color:#f92672>url</span><span style=color:#f92672>(</span><span style=color:#f92672>cssfile</span>.<span style=color:#a6e22e>css</span><span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>style</span>&gt;
</span></span></code></pre></div></li><li><p>区别：外部样式表中不能写 <code>&lt;link></code> 标签，但是可以写 import 语句。link引用css时，页面加载同时加载样式，@import需要页面完全载入以后加载；</p></li></ul></li></ul><p>在 CSS 文件中，除了注释、CSS 规则集以及 @规则 外，定义的一些别的东西都将被浏览器忽略。</p><p>使用 CSS 时可能会遇到浏览器兼容性问题。当浏览器解析页面的 CSS 时，会自动忽视不能识别或者不支持的属性。 此时，浏览器会尝试使用其它值。 但如果没有找到其它值，则会使用默认值。这意味着如果想提供浏览器降级方案，在声明之前提供另一个更宽泛的值即可。 这样老旧的浏览器会降级使用这个方案，新的浏览器会在后面的声明里覆盖降级方案。</p><h3 id=css-语法>CSS 语法<a hidden class=anchor aria-hidden=true href=#css-语法>#</a></h3><p><img loading=lazy src=/CSS/CSS%e8%af%ad%e6%b3%95.png alt></p><ul><li>CSS 的核心功能是将 CSS 属性设定为特定的值。一个属性与值的键值对被称为<strong>声明</strong>（declaration）。CSS 允许重复声明某个样式，这时最后声明的键值对会覆盖前面的键值对。</li><li>而如果将一个或者多个声明用 <code>{}</code> 包裹起来后，那就组成了一个<strong>声明块</strong>（declaration block）。多个声明的顺序并不重要。声明块可以写成多行，也可以写成一行。缩进和换行只是为了增加可读性，CSS 引擎会忽略它们。</li><li>声明块如果需要作用到对应的 HTML 元素，那还需要加上<strong>选择器</strong>。选择器和声明块组成了<strong>CSS 规则集</strong>（CSS ruleset），常简称为 CSS 规则。</li><li>规则集中最后一条声明可以省略分号，但是并不建议这么做，因为容易出错。</li><li>如果一个属性有多个值的话，那么多个值用空格隔开。</li></ul><h3 id=css-注释>CSS 注释<a hidden class=anchor aria-hidden=true href=#css-注释>#</a></h3><p>CSS 使用<code>/* ... */</code>表示注释，可以是单行，也可以是多行。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>h1</span> { <span style=color:#75715e>/* 这是单行注释 */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>color</span>: <span style=color:#66d9ef>red</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 这是多行注释
</span></span></span><span style=display:flex><span><span style=color:#75715e>h1 {
</span></span></span><span style=display:flex><span><span style=color:#75715e>  color: red;
</span></span></span><span style=display:flex><span><span style=color:#75715e>}
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span></code></pre></div><p>注意：注释不能嵌套。</p><h3 id=css-属性值定义语法httpsdevelopermozillaorgzh-cndocswebcssvalue_definition_syntax><a href=https://developer.mozilla.org/zh-CN/docs/Web/CSS/Value_definition_syntax>CSS 属性值定义语法</a><a hidden class=anchor aria-hidden=true href=#css-属性值定义语法httpsdevelopermozillaorgzh-cndocswebcssvalue_definition_syntax>#</a></h3><table><thead><tr><th style=text-align:left>符号</th><th style=text-align:left>名称</th><th style=text-align:left>描述</th><th style=text-align:left>示例</th></tr></thead><tbody><tr><td style=text-align:left>组合符号</td><td style=text-align:left></td><td style=text-align:left></td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>并置</td><td style=text-align:left>各部分必须出现且按顺序出现</td><td style=text-align:left><code>solid &lt;length></code></td></tr><tr><td style=text-align:left><code>&&</code></td><td style=text-align:left>“与”组合符</td><td style=text-align:left>各部分必须出现，但可以不按顺序</td><td style=text-align:left><code>&lt;length> && &lt;string></code></td></tr><tr><td style=text-align:left>`</td><td style=text-align:left></td><td style=text-align:left>`</td><td style=text-align:left>“或”组合符</td></tr><tr><td style=text-align:left>`</td><td style=text-align:left>`</td><td style=text-align:left>“互斥”组合符</td><td style=text-align:left>各部分恰好出现一个</td></tr><tr><td style=text-align:left><code>[ ]</code></td><td style=text-align:left>方括号</td><td style=text-align:left>强调优先级</td><td style=text-align:left><code>bold [ thin && &lt;length> ]</code></td></tr><tr><td style=text-align:left>数量符号</td><td style=text-align:left></td><td style=text-align:left></td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>无数量符号</td><td style=text-align:left>恰好一次</td><td style=text-align:left><code>solid</code></td></tr><tr><td style=text-align:left><code>*</code></td><td style=text-align:left>星号</td><td style=text-align:left>零次、一次或多次</td><td style=text-align:left><code>bold smaller*</code></td></tr><tr><td style=text-align:left><code>+</code></td><td style=text-align:left>加号</td><td style=text-align:left>一次或多次</td><td style=text-align:left><code>bold smaller+</code></td></tr><tr><td style=text-align:left><code>?</code></td><td style=text-align:left>问号</td><td style=text-align:left>零次或一次（即可选）</td><td style=text-align:left><code>bold smaller?</code></td></tr><tr><td style=text-align:left><code>{A,B}</code></td><td style=text-align:left>大括号</td><td style=text-align:left>至少<code>A</code>次，至多<code>B</code>次</td><td style=text-align:left><code>bold smaller{1,3}</code></td></tr><tr><td style=text-align:left><code>#</code></td><td style=text-align:left>井号</td><td style=text-align:left>一次或多次，但多次出现必须以逗号分隔</td><td style=text-align:left><code>bold smaller#</code></td></tr><tr><td style=text-align:left><code>!</code></td><td style=text-align:left>叹号</td><td style=text-align:left>组必须产生一个值</td><td style=text-align:left><code>[ bold? smaller? ]!</code></td></tr></tbody></table><h3 id=规则>@规则<a hidden class=anchor aria-hidden=true href=#规则>#</a></h3><p>CSS 规则是样式表的主体，通常样式表会包括大量的规则列表。但有时候也需要在样式表中包括其他的一些信息，比如字符集，导入其它的外部样式表，字体等，这些需要专门的语句表示。</p><p>而 @规则 就是这样的语句。CSS 里包含了以下 @规则：</p><ul><li>@namespace 告诉 CSS 引擎必须考虑XML命名空间。</li><li>@page, 描述打印文档时布局的变化.</li><li>@font-face, 描述将下载的外部的字体。</li><li>@keyframes, 描述 CSS 动画的关键帧。</li><li>@document, 如果文档样式表满足给定条件则条件规则组里的规则生效。</li></ul><h4 id=media>@media<a hidden class=anchor aria-hidden=true href=#media>#</a></h4><p>响应式布局（responsive）的含义是，网页会根据不同的媒介，自动采用不同的 CSS 规则。它主要通过 media 命令实现。</p><p>@media CSS @规则 可用于基于一个或多个媒体查询的结果来应用样式表的一部分。 使用它，您可以指定一个媒体查询和一个CSS块，当且仅当该媒体查询与正在使用其内容的设备匹配时，该CSS块才能应用于该文档。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>@<span style=color:#66d9ef>media</span> <span style=color:#f92672>media-type</span> <span style=color:#f92672>and</span> <span style=color:#f92672>(</span><span style=color:#f92672>media-feature-rule</span><span style=color:#f92672>)</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* CSS rules go here */</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>@media 规则可置于您代码的顶层或位于其它任何@条件规则组内。</p><p>媒体查询由媒体类型组成，如果媒体类型与展示网页的设备类型匹配，则应用对应的样式。媒体类型之前，还可以使用<code>not</code>和<code>only</code>关键字。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>@<span style=color:#66d9ef>media</span> <span style=color:#f92672>not</span> <span style=color:#f92672>screen</span> {
</span></span><span style=display:flex><span>   <span style=color:#960050;background-color:#1e0010>…</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@<span style=color:#66d9ef>media</span> <span style=color:#f92672>only</span> <span style=color:#f92672>screen</span> {
</span></span><span style=display:flex><span>   <span style=color:#960050;background-color:#1e0010>…</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>@media</code>允许使用表达式，指定 CSS 生效的条件。表达式可以放在圆括号之中。</p><p>下面是一个媒体查询的例子，当设备宽度小于或等于 100px 时返回内容：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>@<span style=color:#66d9ef>media</span> <span style=color:#f92672>(</span><span style=color:#f92672>max-width</span><span style=color:#f92672>:</span> <span style=color:#f92672>100px</span><span style=color:#f92672>)</span> { <span style=color:#75715e>/* CSS Rules */</span> }
</span></span></code></pre></div><p>以下定义的媒体查询，是当设备高度大于或等于 350px 时返回内容：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>@<span style=color:#66d9ef>media</span> <span style=color:#f92672>(</span><span style=color:#f92672>min-height</span><span style=color:#f92672>:</span> <span style=color:#f92672>350px</span><span style=color:#f92672>)</span> { <span style=color:#75715e>/* CSS Rules */</span> }
</span></span></code></pre></div><p>如果同时需要满足多个条件，可以使用<code>and</code>关键字。下面的例子是为不同的设备指定不同的背景图片。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#75715e>/* default is desktop image */</span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>someElement</span> { <span style=color:#66d9ef>background-image</span>: url(<span style=color:#e6db74>sunset.jpg</span>); }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@<span style=color:#66d9ef>media</span> <span style=color:#f92672>only</span> <span style=color:#f92672>screen</span> <span style=color:#f92672>and</span> <span style=color:#f92672>(</span><span style=color:#f92672>max-width</span> <span style=color:#f92672>:</span> <span style=color:#f92672>1024px</span><span style=color:#f92672>)</span> {
</span></span><span style=display:flex><span>  .<span style=color:#a6e22e>someElement</span> { <span style=color:#66d9ef>background-image</span>: url(<span style=color:#e6db74>sunset-small.jpg</span>); }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>media type</strong></p><p><img loading=lazy src=/CSS/media-type.png alt></p><ul><li>all：适用于所有设备；</li><li>print：适用于在打印预览模式下在屏幕上查看的分页材料和文档；</li><li>screen：主要用于屏幕；</li><li>speech：主要用于语音合成器。</li></ul><p>需要注意的是：通过 media 指定的资源尽管不匹配它的设备类型，但是浏览器依然会加载它。如果要覆盖某个样式，最好放在要覆盖样式之后，可以认为 @media 是一个 if 语句。</p><p><strong>逻辑操作符</strong></p><ul><li>and：查询条件都满足的时候才生效；</li><li>not：查询条件取反；</li><li>only：整个查询匹配的时候才生效，常用语兼容旧浏览器，使用时候必须指定媒体类型；</li><li>逗号或者 or：查询条件满足一项即可匹配；</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#75715e>/* 用户设备的最小高度为680px或为纵向模式的屏幕设备 */</span>
</span></span><span style=display:flex><span>@<span style=color:#66d9ef>media</span> <span style=color:#f92672>(</span><span style=color:#f92672>min-height</span><span style=color:#f92672>:</span> <span style=color:#f92672>680px</span><span style=color:#f92672>),</span> <span style=color:#f92672>screen</span> <span style=color:#f92672>and</span> <span style=color:#f92672>(</span><span style=color:#f92672>orientation</span><span style=color:#f92672>:</span> <span style=color:#f92672>portrait</span><span style=color:#f92672>)</span> {}
</span></span></code></pre></div><p><strong>max-height，min-height，height一起使用时，优先级问题</strong></p><p>实际效果：</p><ul><li>当 height 和 max-height一起使用时，谁小听谁的<ul><li>max-height &lt; height 元素高度： max-height</li><li>height &lt; max-height 元素高度： height</li></ul></li><li>当 height,max-height,min-height一起使用时<ul><li>height > max-height > min-height 元素高度：max-height</li><li>height > min-height > max-height 元素高度：min-height</li><li>min-height > height > max-height 元素高度：min-height</li></ul></li></ul><p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fdrafts.csswg.org%2Fmediaqueries-5%2F%23at-ruledef-custom-media"><strong>Level 5 新的媒体查询特性</strong></a></p><p>可以查询到用户在设备上的喜好设置。比如：</p><ul><li><code>prefers-reduced-motion</code></li><li><code>prefers-contrast</code></li><li><code>prefers-reduced-transparency</code></li><li><code>prefers-color-scheme</code></li><li><code>inverted-colors</code></li></ul><p>使用的方式和以往我们熟悉的 <code>@media</code> 是相似。比如 <code>prefers-color-scheme</code> 实现暗黑查式的皮肤切换效果：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>//</span> <span style=color:#960050;background-color:#1e0010>代码源于：</span> <span style=color:#f92672>https</span><span style=color:#f92672>://</span><span style=color:#f92672>codepen</span>.<span style=color:#a6e22e>io</span><span style=color:#f92672>/</span><span style=color:#f92672>airen</span><span style=color:#f92672>/</span><span style=color:#f92672>full</span><span style=color:#f92672>/</span><span style=color:#f92672>ProgLL</span>
</span></span><span style=display:flex><span><span style=color:#f92672>//</span> <span style=color:#f92672>dark</span> <span style=color:#f92672>&amp;</span> <span style=color:#f92672>light</span> <span style=color:#f92672>mode</span>
</span></span><span style=display:flex><span>:<span style=color:#a6e22e>root</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* Light theme */</span>
</span></span><span style=display:flex><span>  --c-text: <span style=color:#ae81ff>#333</span>;
</span></span><span style=display:flex><span>  --c-background: <span style=color:#ae81ff>#fff</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>body</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>color</span>: <span style=color:#a6e22e>var</span>(<span style=color:#f92672>--</span>c<span style=color:#f92672>-</span><span style=color:#66d9ef>text</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>background-color</span>: <span style=color:#a6e22e>var</span>(<span style=color:#f92672>--</span>c<span style=color:#f92672>-</span>background);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@<span style=color:#66d9ef>media</span> <span style=color:#f92672>(</span><span style=color:#f92672>prefers-color-scheme</span><span style=color:#f92672>:</span> <span style=color:#f92672>dark</span><span style=color:#f92672>)</span> {
</span></span><span style=display:flex><span>  :<span style=color:#a6e22e>root</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Dark theme */</span>
</span></span><span style=display:flex><span>    --c-text: <span style=color:#ae81ff>#fff</span>;
</span></span><span style=display:flex><span>    --c-background: <span style=color:#ae81ff>#333</span>;
</span></span><span style=display:flex><span>  } 
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=charset>@charset<a hidden class=anchor aria-hidden=true href=#charset>#</a></h4><p>@charset 用于定义样式表使用的字符集。它必须是样式表中的第一个元素。如果有多个 @charset 被声明，只有第一个会被使用，而且不能在HTML元素或HTML页面的 <code>&lt;style></code> 元素内使用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>@<span style=color:#66d9ef>charset</span> <span style=color:#e6db74>&#34;UTF-8&#34;</span>;
</span></span></code></pre></div><p>某个样式表文件到底用的是什么字符编码，浏览器有一套识别顺序（优先级由高到低）：</p><ul><li><p>文件开头的 Byte order mark 字符值，不过一般编辑器并不能看到文件头里的 BOM 值；</p></li><li><p>HTTP 响应头里的 content-type 字段包含的 charset 所指定的值，比如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>Content-Type: text/css; charset=utf-8
</span></span></span></code></pre></div></li><li><p>CSS 文件头里定义的 @charset 规则里指定的字符编码；</p></li><li><p><code>&lt;link></code> 标签里的 charset 属性，该条已在 HTML5 中废除；</p></li><li><p>默认是 UTF-8。</p></li></ul><h4 id=importhttpsdevelopermozillaorgzh-cndocswebcssimport><a href=https://developer.mozilla.org/zh-CN/docs/Web/CSS/@import>@import</a><a hidden class=anchor aria-hidden=true href=#importhttpsdevelopermozillaorgzh-cndocswebcssimport>#</a></h4><p>@import CSS@规则，用于从其他样式表导入样式规则。这些规则必须先于所有其他类型的规则，@charset 规则除外; 因为它不是一个嵌套语句，@import不能在条件组的规则中使用。</p><p>因此，用户代理可以避免为不支持的媒体类型检索资源，作者可以指定依赖媒体的@import规则。这些条件导入在URI之后指定逗号分隔的媒体查询。在没有任何媒体查询的情况下，导入是无条件的。指定所有的媒体具有相同的效果。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>@<span style=color:#66d9ef>import</span> <span style=color:#f92672>url</span>;
</span></span><span style=display:flex><span>@<span style=color:#66d9ef>import</span> <span style=color:#f92672>url</span> <span style=color:#f92672>list-of-media-queries</span>;
</span></span></code></pre></div><p>url 是一个表示要引入资源位置的 <code>&lt;string></code> 或者 <code>url(url)</code>。 这个 URL 可以是绝对路径或者相对路径。 要注意的是这个 URL 不需要指明一个文件； 可以只指明包名，然后合适的文件会被自动选择 (e.g. chrome://communicator/skin/).</p><p>link 和 @import 都能导入一个样式文件，<a href=https://blog.csdn.net/weixin_40013817/article/details/102698219>它们有什么区别嘛？</a></p><ul><li>从属关系区别：link 是 HTML 标签，除了能导入 CSS 外，还能导入别的资源，比如图片、脚本和字体等；而 @import 是 CSS 的语法，只能用来导入 CSS；</li><li>加载顺序区别：link 导入的样式会在页面加载时同时加载，@import 导入的样式需等页面加载完成后再加载；</li><li>兼容性区别：link 没有兼容性问题，@import 不兼容 ie5 以下；</li><li>DOM可控性区别：link 可以通过 JS 操作 DOM 动态引入样式表改变样式，而@import不可以。</li><li>权重区别：<code>link</code>引入的样式权重大于<code>@import</code>引入的样式。<code>link</code>可以通过<code>rel="alternate stylesheet"</code>指定候选样式</li></ul><h4 id=supports>@supports<a hidden class=anchor aria-hidden=true href=#supports>#</a></h4><p>@supports 命令用来判断浏览器是否支持某项CSS功能，可以结合 not、and 和 or 操作符进行后续的操作。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>@<span style=color:#66d9ef>supports</span> <span style=color:#f92672>not</span> <span style=color:#f92672>(</span><span style=color:#f92672>display</span><span style=color:#f92672>:</span> <span style=color:#f92672>grid</span><span style=color:#f92672>)</span> {
</span></span><span style=display:flex><span>  <span style=color:#f92672>//</span> <span style=color:#960050;background-color:#1e0010>不支持网格布局</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>//</span> <span style=color:#960050;background-color:#1e0010>老式浏览器代码</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>@<span style=color:#66d9ef>supports</span> <span style=color:#f92672>(</span><span style=color:#f92672>display</span><span style=color:#f92672>:</span> <span style=color:#f92672>grid</span><span style=color:#f92672>)</span> {
</span></span><span style=display:flex><span>  <span style=color:#f92672>//</span> <span style=color:#960050;background-color:#1e0010>支持网格布局</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>//</span> <span style=color:#960050;background-color:#1e0010>新式浏览器代码</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>另一个例子。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>@<span style=color:#66d9ef>supports</span> <span style=color:#f92672>(</span><span style=color:#f92672>object-fit</span><span style=color:#f92672>:</span> <span style=color:#f92672>cover</span><span style=color:#f92672>)</span> {
</span></span><span style=display:flex><span>  <span style=color:#f92672>img</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>object-fit</span>: <span style=color:#66d9ef>cover</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#f92672>div</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>width</span>: <span style=color:#66d9ef>auto</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>background</span>: <span style=color:#66d9ef>green</span>;
</span></span><span style=display:flex><span>   <span style=color:#960050;background-color:#1e0010>//</span> <span style=color:#960050;background-color:#1e0010>some</span> <span style=color:#960050;background-color:#1e0010>other</span> <span style=color:#960050;background-color:#1e0010>complex</span> <span style=color:#960050;background-color:#1e0010>code</span> <span style=color:#960050;background-color:#1e0010>for</span> <span style=color:#960050;background-color:#1e0010>the</span> <span style=color:#960050;background-color:#1e0010>fancy</span> <span style=color:#960050;background-color:#1e0010>new</span> <span style=color:#960050;background-color:#1e0010>layout</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=property>@property<a hidden class=anchor aria-hidden=true href=#property>#</a></h4><p><code>@property</code> 是用来注册一个变量的，该变量是一个 CSS Houdini 中的变量，但它的使用和 CSS 中的自定义属性（CSS变量）是一样的，不同的是注册方式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>//</span> <span style=color:#f92672>Chrome</span> <span style=color:#f92672>78</span><span style=color:#f92672>+</span>
</span></span><span style=display:flex><span><span style=color:#f92672>//</span> <span style=color:#960050;background-color:#1e0010>需要在</span> <span style=color:#f92672>JavaScript</span><span style=color:#960050;background-color:#1e0010>脚本中注册</span>
</span></span><span style=display:flex><span><span style=color:#f92672>CSS</span>.<span style=color:#a6e22e>registerProperty</span><span style=color:#f92672>(</span>{
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>&#39;name&#39;:</span> <span style=color:#960050;background-color:#1e0010>&#39;--custom-property-name&#39;,</span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>&#39;syntax&#39;:</span> <span style=color:#960050;background-color:#1e0010>&#39;&lt;color&gt;&#39;,</span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>&#39;initialValue&#39;:</span> <span style=color:#960050;background-color:#1e0010>&#39;black&#39;,</span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>&#39;inherits&#39;:</span> <span style=color:#960050;background-color:#1e0010>false</span>
</span></span><span style=display:flex><span>}<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>//</span> <span style=color:#f92672>Chrome</span> <span style=color:#f92672>85</span><span style=color:#f92672>+</span>
</span></span><span style=display:flex><span><span style=color:#f92672>//</span> <span style=color:#960050;background-color:#1e0010>在</span><span style=color:#f92672>CSS</span><span style=color:#960050;background-color:#1e0010>文件中注册</span>
</span></span><span style=display:flex><span>@<span style=color:#66d9ef>property</span> <span style=color:#f92672>--custom-property-name</span> {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;syntax&#39;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;&lt;color&gt;&#39;</span><span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;initialValue&#39;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;black&#39;</span><span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;inherits&#39;</span><span style=color:#f92672>:</span> <span style=color:#f92672>false</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>他的最大特色之一就是可以指定已注册的 CSS 变量的类型、初始值，是否可继承。</p><h4 id=container>@container<a hidden class=anchor aria-hidden=true href=#container>#</a></h4><p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fweb.dev%2Fnew-responsive%2F">Una Kravets 在 Google I/O 开发大会上就分享了容器查询</a> <code>@container</code> ，她把它称为新的响式布局所需特性之一：</p><p><img loading=lazy src=/CSS/containerQueries.png alt></p><h4 id=scope>@scope<a hidden class=anchor aria-hidden=true href=#scope>#</a></h4><h4 id=layer>@layer<a hidden class=anchor aria-hidden=true href=#layer>#</a></h4><h4 id=打印样式>打印样式<a hidden class=anchor aria-hidden=true href=#打印样式>#</a></h4><p><strong>基本用法</strong></p><p><code>@media print</code>命令可以设置打印样式，即用户选择打印当前网页时，生效的 CSS 规则。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>@<span style=color:#66d9ef>media</span> <span style=color:#f92672>print</span> {
</span></span><span style=display:flex><span>  <span style=color:#f92672>h1</span> { <span style=color:#66d9ef>font-size</span>: <span style=color:#ae81ff>16</span><span style=color:#66d9ef>pt</span>; }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面代码设置的<code>h1</code>样式，对屏幕浏览不产生效果，只有用户打印网页时才会生效。</p><p><code>@media print</code>命令可以与正常样式规则混合使用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>p</span> { <span style=color:#66d9ef>margin</span>: <span style=color:#ae81ff>1</span><span style=color:#66d9ef>em</span> <span style=color:#ae81ff>0</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@<span style=color:#66d9ef>media</span> <span style=color:#f92672>print</span> {
</span></span><span style=display:flex><span>  .<span style=color:#a6e22e>related-articles</span> { <span style=color:#66d9ef>display</span>: <span style=color:#66d9ef>none</span>; }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面代码中，<code>p</code>元素的样式对屏幕浏览和打印都有效，<code>.related-articles</code>的样式只对打印有效。</p><p>如果要设置某些规则只对屏幕浏览有效，可以像下面这样写。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>@<span style=color:#66d9ef>media</span> <span style=color:#f92672>screen</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* 只对屏幕浏览有效 */</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@<span style=color:#66d9ef>media</span> <span style=color:#f92672>print</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* 只对打印有效 */</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>分页符</strong></p><p>分页符属性用来设置页面的分页（即另起一页），共有三个相关属性。</p><ul><li>page-break-before：元素之前分页</li><li>page-break-after：元素之后分页</li><li>page-break-inside：元素内部分页</li></ul><p>这三个属性的值都是两个：<code>always</code>（生效）和<code>avoid</code>（避免）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>h1</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* 总是在 h1 元素之前分页 */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>page-break-before</span>: <span style=color:#66d9ef>always</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>section</span>.<span style=color:#a6e22e>city-map</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* 在元素之前和之后分页，即该元素单独占据一页 */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>page-break-before</span>: <span style=color:#66d9ef>always</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>page-break-after</span>: <span style=color:#66d9ef>always</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>table</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* 表格尽可能不要分页 */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>page-break-inside</span>: <span style=color:#66d9ef>avoid</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>orphans，widow</strong></p><p><code>orphans</code>属性和<code>widow</code>属性设置某个元素如何跨页拆分。</p><p><code>orphans</code>属性设置跨页前的行数少于多少行时，所有行都移到下一页打印。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>p</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>orphans</span>: <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面代码设置，如果某个段落出现在上一页的结尾少于3行（比如只有两行），那么该段落全部移到下一页显示。</p><p><code>widow</code>属性设置出现在新页面的行数，最少应该有几行。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>p</span> {
</span></span><span style=display:flex><span>  widow: <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面代码设置，如果某个段落出现在新页面的开头少于两行（比如只有一行），那么该段落全部移到上一页显示。</p><p><strong>@page</strong></p><p><code>@page</code>命令主要用来定义页面距。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>@<span style=color:#66d9ef>page</span> {
</span></span><span style=display:flex><span>  <span style=color:#f92672>margin</span><span style=color:#f92672>:</span> <span style=color:#f92672>2cm</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>此外，还可以用<code>:first</code>、<code>:last</code>、<code>:left</code>、<code>:right</code>和<code>:blank</code>选择器，选中特殊页面。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>@<span style=color:#66d9ef>page</span>:<span style=color:#a6e22e>first</span> {
</span></span><span style=display:flex><span>  <span style=color:#f92672>margin</span><span style=color:#f92672>:</span> <span style=color:#f92672>0</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面代码设置第一页的页边距为<code>0</code>。</p><p><strong>技巧</strong></p><p>（1）重复表格的表头</p><p>如果希望打印表格的时候，每一页都出现表头，只需要使用<code>&lt;thead></code>元素定义表头，<code>&lt;tbody></code>元素定义表的数据部分即可。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>table</span>&gt;
</span></span><span style=display:flex><span>  &lt;<span style=color:#f92672>thead</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>tr</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>th</span>&gt;City&lt;/<span style=color:#f92672>th</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>th</span>&gt;Population&lt;/<span style=color:#f92672>th</span>&gt;
</span></span><span style=display:flex><span>  &lt;/<span style=color:#f92672>thead</span>&gt;
</span></span><span style=display:flex><span>  &lt;<span style=color:#f92672>tbody</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>tr</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>td</span>&gt;Sydney&lt;/<span style=color:#f92672>td</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>td</span>&gt;4.627 million (2018)&lt;/<span style=color:#f92672>td</span>&gt;
</span></span><span style=display:flex><span>    &lt;/<span style=color:#f92672>tr</span>&gt;
</span></span><span style=display:flex><span>  &lt;/<span style=color:#f92672>tbody</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>table</span>&gt;
</span></span></code></pre></div><p>上面代码中，如果表格跨页，表头的<code>City</code>和<code>Population</code>字段会在每一页都打印出来。</p><p>（2）打印链接的网址</p><p>如果希望打印出链接的网址，可以使用<code>:after</code>伪元素。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>@<span style=color:#66d9ef>media</span> <span style=color:#f92672>print</span> {
</span></span><span style=display:flex><span>  <span style=color:#f92672>a</span><span style=color:#f92672>[</span><span style=color:#f92672>href</span><span style=color:#f92672>]</span>:<span style=color:#a6e22e>after</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>content</span>: <span style=color:#e6db74>&#34;(&#34;</span> attr(href) <span style=color:#e6db74>&#34;)&#34;</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=嵌套>嵌套<a hidden class=anchor aria-hidden=true href=#嵌套>#</a></h4><p>使用过 CSS 处理器的同学，应该用过嵌套来组织自己的代码，庆幸的是，<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdrafts.csswg.org%2Fcss-nesting-1%2F%23nest-selector">W3C 也在讨论和定义CSS中的嵌套规则</a>。目前两种规则：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>foo</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>color</span>: <span style=color:#66d9ef>red</span>;
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>@nest</span> <span style=color:#960050;background-color:#1e0010>bar</span> <span style=color:#960050;background-color:#1e0010>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>color</span>: <span style=color:#66d9ef>green</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>//</span> <span style=color:#960050;background-color:#1e0010>或者</span> 
</span></span><span style=display:flex><span><span style=color:#f92672>foo</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>color</span>: <span style=color:#66d9ef>red</span>;
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>&amp;</span> <span style=color:#960050;background-color:#1e0010>bar</span> <span style=color:#960050;background-color:#1e0010>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>color</span>: <span style=color:#66d9ef>green</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>//</span> <span style=color:#960050;background-color:#1e0010>都等同于</span>
</span></span><span style=display:flex><span><span style=color:#f92672>foo</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>color</span>: <span style=color:#66d9ef>red</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#f92672>foo</span> <span style=color:#f92672>bar</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>color</span>: <span style=color:#66d9ef>green</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>也可以和媒体查询 <code>@media</code> 相互嵌套：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>article</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>color</span>: <span style=color:#66d9ef>darkgray</span>;
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>&amp;</span> <span style=color:#960050;background-color:#1e0010>&gt;</span> <span style=color:#960050;background-color:#1e0010>a</span> <span style=color:#960050;background-color:#1e0010>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>color</span>: <span style=color:#a6e22e>var</span>(<span style=color:#f92672>--</span>link<span style=color:#f92672>-</span><span style=color:#66d9ef>color</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>code</span> <span style=color:#f92672>&gt;</span> <span style=color:#f92672>pre</span> {
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>@media</span> <span style=color:#960050;background-color:#1e0010>(hover)</span> <span style=color:#960050;background-color:#1e0010>{</span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>&amp;:hover</span> <span style=color:#960050;background-color:#1e0010>{</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>color</span>: <span style=color:#66d9ef>hotpink</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>}</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>code</span> <span style=color:#f92672>&gt;</span> <span style=color:#f92672>pre</span> {
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>@media</span> <span style=color:#960050;background-color:#1e0010>(hover)</span> <span style=color:#960050;background-color:#1e0010>{</span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>@nest</span> <span style=color:#960050;background-color:#1e0010>&amp;:hover</span> <span style=color:#960050;background-color:#1e0010>{</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>color</span>: <span style=color:#66d9ef>hotpink</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>}</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>article</span> {
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>@nest</span> section:focus-within <span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span> <span style=color:#960050;background-color:#1e0010>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>color</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>hotpink</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>main</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>padding</span>: <span style=color:#a6e22e>var</span>(<span style=color:#f92672>--</span><span style=color:#66d9ef>space</span><span style=color:#f92672>-</span>sm);
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>@media</span> <span style=color:#960050;background-color:#1e0010>(width</span> <span style=color:#960050;background-color:#1e0010>&gt;=</span> <span style=color:#960050;background-color:#1e0010>540px)</span> <span style=color:#960050;background-color:#1e0010>{</span> <span style=color:#960050;background-color:#1e0010>&amp;</span> <span style=color:#960050;background-color:#1e0010>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>padding</span>: <span style=color:#a6e22e>var</span>(<span style=color:#f92672>--</span><span style=color:#66d9ef>space</span><span style=color:#f92672>-</span>lg);
</span></span><span style=display:flex><span>  }<span style=color:#960050;background-color:#1e0010>}</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>}</span>
</span></span></code></pre></div><p>除了 <code>@nest</code> 之外还有 <code>@apply</code> 。你可能在一些前端的框架或构建器中看到过 <code>@apply</code>。它有点类似于 SCSS 中的混合宏 <code>@mixin</code> 和 <code>@extend</code> :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>:<span style=color:#a6e22e>root</span> {
</span></span><span style=display:flex><span>    --brand-color: <span style=color:#66d9ef>red</span>;
</span></span><span style=display:flex><span>    --heading-style: <span style=color:#960050;background-color:#1e0010>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>color</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>var</span>(<span style=color:#f92672>--</span>brand<span style=color:#f92672>-</span><span style=color:#66d9ef>color</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>font-family</span>: <span style=color:#66d9ef>cursive</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>font-weight</span>: <span style=color:#ae81ff>700</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>h1</span> {
</span></span><span style=display:flex><span>    --brand-color: <span style=color:#66d9ef>green</span>;
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>@apply</span> <span style=color:#960050;background-color:#1e0010>--heading-style</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=值和单位>值和单位<a hidden class=anchor aria-hidden=true href=#值和单位>#</a></h3><p>CSS 的声明是由属性和值组成的，而值的类型有许多种：</p><ul><li>数值：长度值 ，用于指定例如元素 width、border-width、font-size 等属性的值；</li><li>百分比：可以用于指定尺寸或长度，例如取决于父容器的 width、height 或默认的 font-size；</li><li>颜色：用于指定 background-color、color 等；</li><li>坐标位置：以屏幕的左上角为坐标原点定位元素的位置，比如常见的 background-position、top、right、bottom 和 left 等属性；</li><li>函数：用于指定资源路径或背景图片的渐变，比如 url()、linear-gradient() 等；</li></ul><p>而还有些值是需要带单位的，比如 width: 100px，这里的 px 就是表示长度的单位，长度单位除了 px 外，比较常用的还有 em、rem、vw/vh 等。</p><h4 id=px>px<a hidden class=anchor aria-hidden=true href=#px>#</a></h4><p>px 表示的是 CSS 中的像素，在 CSS 中它是绝对的长度单位，也是最基础的单位，其他长度单位会自动被浏览器换算成 px。但是对于设备而言，它其实又是相对的长度单位，比如宽高都为 2px，在正常的屏幕下，其实就是 4 个像素点，而在设备像素比(devicePixelRatio) 为 2 的 Retina 屏幕下，它就有 16 个像素点。所以屏幕尺寸一致的情况下，屏幕分辨率越高，显示效果就越细腻。</p><p><strong>设备像素（Device pixels）</strong></p><p>设备屏幕的物理像素，表示的是屏幕的横纵有多少像素点；和屏幕分辨率是差不多的意思。比如分辨率 1920×1080 意味着水平方向含有 1920 个像素数，垂直方向含有 1080 个像素数。</p><p><strong>设备像素比（DPR）</strong></p><p>设备像素比表示 1 个 CSS 像素等于几个物理像素。</p><p>计算公式：DPR = 物理像素数 / 逻辑像素数；</p><p>在浏览器中可以通过 window.devicePixelRatio 来获取当前屏幕的 DPR。</p><p><strong>像素密度（DPI/PPI）</strong></p><p>像素密度也叫显示密度或者屏幕密度，缩写为 DPI(Dots Per Inch) 或者 PPI(Pixel Per Inch)。从技术角度说，PPI 只存在于计算机显示领域，而 DPI 只出现于打印或印刷领域。</p><p>计算公式：像素密度 = 屏幕对角线的像素尺寸 / 物理尺寸</p><p><strong>设备独立像素（DIP）</strong></p><p>DIP 是特别针对 Android设备而衍生出来的，原因是安卓屏幕的尺寸繁多，因此为了显示能尽量和设备无关，而提出的这个概念。它是基于屏幕密度而计算的，认为当屏幕密度是 160 的时候，px = DIP。</p><p>计算公式：dip = px * 160 / dpi</p><h4 id=em>em<a hidden class=anchor aria-hidden=true href=#em>#</a></h4><p>em 是 CSS 中的相对长度单位中的一个。它有 2 层意思：</p><ul><li><p>在 font-size 中使用是相对于父元素的 font-size 大小，比如父元素 font-size: 16px，当给子元素指定 font-size: 2em 的时候，经过计算后它的字体大小会是 32px。</p></li><li><p>在其他属性中使用是相对于自身的字体大小，如 width/height/padding/margin 等；这里比较混淆的是，如果<code>font-size</code>也使用<code>em</code>，两者的计算基点是不一样的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>h1</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>font-size</span>: <span style=color:#ae81ff>2</span><span style=color:#66d9ef>em</span>; <span style=color:#75715e>/* 1em = 16px */</span>
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>padding：</span> <span style=color:#960050;background-color:#1e0010>1em</span>;  <span style=color:#75715e>/* 1em = 32px */</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面代码中，<code>font-size</code>是基于父元素计算的，如果父元素的字体大小是<code>16px</code>，那么<code>font-size</code>就是<code>32px</code>；<code>padding</code>是基于<code>font-size</code>计算的，由于<code>h1</code>的<code>font-size</code>是<code>32px</code>，所以<code>padding</code>就是<code>32px</code>。</p></li></ul><p>我们都知道每个浏览器都会给 HTML 根元素 html 设置一个默认的 font-size，而这个值通常是 16px。这也就是为什么 1em = 16px 的原因所在。</p><p>em 在计算的时候是会层层计算的，比如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>&lt;</span><span style=color:#f92672>div</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;</span><span style=color:#f92672>p</span><span style=color:#f92672>&gt;&lt;/</span><span style=color:#f92672>p</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/</span><span style=color:#f92672>div</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>div</span> { <span style=color:#66d9ef>font-size</span>: <span style=color:#ae81ff>2</span><span style=color:#66d9ef>em</span>; }
</span></span><span style=display:flex><span><span style=color:#f92672>p</span> { <span style=color:#66d9ef>font-size</span>: <span style=color:#ae81ff>2</span><span style=color:#66d9ef>em</span>; }
</span></span></code></pre></div><p>对于如上一个结构的 HTML，由于根元素 html 的字体大小是 16px，所以 p 标签最终计算出来后的字体大小会是 16 * 2 * 2 = 64px。</p><h4 id=rem>rem<a hidden class=anchor aria-hidden=true href=#rem>#</a></h4><p><code>rem</code>单位与<code>em</code>几乎完全一致，只有一个差异，它总是等于根元素<code>&lt;html></code>的<code>font-size</code>大小，与当前元素或父元素的设置无关，这就避免了<code>em</code>的缺陷。</p><p>那么，何时使用<code>rem</code>，何时使用<code>em</code>呢？一个<a href=https://zellwk.com/blog/rem-vs-em/>规则</a>是字体大小<code>font-size</code>属性使用<code>rem</code>，其他必须等比例缩放的属性使用<code>em</code>。下面是一个例子。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>button</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>font-size</span>: <span style=color:#ae81ff>0.875</span><span style=color:#66d9ef>rem</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>padding</span>: <span style=color:#ae81ff>.5</span><span style=color:#66d9ef>em</span> <span style=color:#ae81ff>1</span><span style=color:#66d9ef>em</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>border</span>: <span style=color:#ae81ff>.125</span><span style=color:#66d9ef>em</span> <span style=color:#66d9ef>solid</span> <span style=color:#ae81ff>#e3e3e3</span>;
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>@media</span> <span style=color:#960050;background-color:#1e0010>(</span><span style=color:#66d9ef>min-width</span>: <span style=color:#ae81ff>48</span><span style=color:#66d9ef>rem</span>)<span style=color:#960050;background-color:#1e0010>{</span> <span style=color:#75715e>/* min-width: 768px */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>font-size</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>1.125</span><span style=color:#66d9ef>rem</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  @<span style=color:#66d9ef>media</span> <span style=color:#f92672>(</span><span style=color:#f92672>min-width</span><span style=color:#f92672>:</span> <span style=color:#f92672>62rem</span><span style=color:#f92672>)</span>{ <span style=color:#75715e>/* min-width: 992px */</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>font-size</span><span style=color:#f92672>:</span> <span style=color:#f92672>1</span>.<span style=color:#a6e22e>375rem</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>}</span>
</span></span></code></pre></div><p>上面代码中，随着屏幕宽度的变化，字体大小会跟着改变，<code>padding</code>和<code>border</code>会始终保持比例关系。</p><h4 id=vwvh>vw/vh<a hidden class=anchor aria-hidden=true href=#vwvh>#</a></h4><p><code>vh</code>表示百分之一的浏览器视口高度，<code>vw</code>表示百分之一的浏览器视口宽度。每当视口的高度和宽度发生变化，它们就会自动重新计算。</p><p><code>vmin</code>表示<code>vh</code>与<code>vw</code>之中较短的那个单位，<code>vmax</code>则表示较长的那个单位。</p><p>一般来说，PC的屏幕是屏宽大于屏高，手机的屏幕是屏高大于屏宽。所以，很可能会出现，某一个区域在PC屏幕中宽度较小，在手机屏幕中宽度较大。这时，这两个单位就可以派上用处了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>h1</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>font-size</span>: <span style=color:#ae81ff>20</span><span style=color:#66d9ef>vmin</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>注意，上面的<code>h1</code>使用<code>vmin</code>单位时，当宽屏设备的视口宽度缩小时，它的字体大小是不变的，因为视口的高度没有改变。</p><p>在 JS 中 100vw = window.innerWidth，100vh = window.innerHeight。</p><h4 id=ch>ch<a hidden class=anchor aria-hidden=true href=#ch>#</a></h4><p><code>ch</code>表示多少个字符。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>width</span><span style=color:#f92672>:</span> <span style=color:#f92672>40ch</span><span style=color:#f92672>;</span>
</span></span></code></pre></div><p>上面代码表示宽度为40个字符。</p><h4 id=calc>calc()<a hidden class=anchor aria-hidden=true href=#calc>#</a></h4><p>calc方法用于计算值，常用于两种不同的单位之间的计算（比如百分比和绝对长度）。</p><p>实例1。每行放置4张图片，可以采用如下的代码。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>img</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>float</span>: <span style=color:#66d9ef>left</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>width</span>: calc(<span style=color:#ae81ff>25</span><span style=color:#66d9ef>%</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>20</span><span style=color:#66d9ef>px</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>margin</span>: <span style=color:#ae81ff>10</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=attr>attr()<a hidden class=anchor aria-hidden=true href=#attr>#</a></h4><p>attr()用于读取网页元素的属性值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>div</span><span style=color:#f92672>[</span><span style=color:#f92672>data-line</span><span style=color:#f92672>]</span>:<span style=color:#a6e22e>after</span> { 
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>content</span>: <span style=color:#e6db74>&#34;[line &#34;</span> attr(data<span style=color:#f92672>-</span>line) <span style=color:#e6db74>&#34;]&#34;</span>; 
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=min-和-maxhttpsjuejincnpost6974239153269506084heading-6><a href=https://juejin.cn/post/6974239153269506084#heading-6>min() 和 max()</a><a hidden class=anchor aria-hidden=true href=#min-和-maxhttpsjuejincnpost6974239153269506084heading-6>#</a></h4><ul><li><code>min()</code> 函数会从多个参数（或表达式）中返回一个最小值作为CSS属性的值，即 使用 <code>min()</code> 设置最大值，等同于 <code>max-width</code></li><li><code>max()</code> 函数会从多个参数（或表达式）中返回一个最大值作为CSS属性的值，即 使用<code>max()</code>设置最小值，等同于 <code>min-width</code></li></ul><h4 id=clamp>clamp()<a hidden class=anchor aria-hidden=true href=#clamp>#</a></h4><p><code>clamp()</code> 和 <code>min()</code> 以及 <code>max()</code>略有不同，它将返回一个区间值，即 在定义的最小值和最大值之间的数值范围内的一个中间值。该函数接受三个参数：</p><ul><li>最小值（<code>MIN</code>）</li><li>中间值（<code>VAL</code>），也称首选值</li><li>最大值（<code>MAX</code>）</li></ul><p><code>clamp(MIN, VAL, MAX)</code>，这三个值之间的关系（或者说取值的方式）：</p><ul><li>如果 <code>VAL</code> 在 <code>MIN</code> 和 <code>MAX</code> 之间，则使用 <code>VAL</code> 作为函数的返回值</li><li>如果 <code>VAL</code> 大于 <code>MAX</code> ，则使用 <code>MAX</code> 作为函数的返回值</li><li>如果 <code>VAL</code> 小于 <code>MIN</code> ，则使用 <code>MIN</code> 作为函数的返回值</li></ul><p>比如下面这个示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>element</span> { 
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 
</span></span></span><span style=display:flex><span><span style=color:#75715e>    * MIN = 100px 
</span></span></span><span style=display:flex><span><span style=color:#75715e>    * VAL = 50vw ➜ 根据视窗的宽度计算 
</span></span></span><span style=display:flex><span><span style=color:#75715e>    * MAX = 500px 
</span></span></span><span style=display:flex><span><span style=color:#75715e>    **/</span> 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>width</span>: <span style=color:#a6e22e>clamp</span>(<span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span>, <span style=color:#ae81ff>50</span><span style=color:#66d9ef>vw</span>, <span style=color:#ae81ff>500</span><span style=color:#66d9ef>px</span>); 
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>就这个示例而言，<code>clamp()</code> 函数的计算会经历以下几个步骤：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>element</span> { 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>width</span>: <span style=color:#a6e22e>clamp</span>(<span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span>, <span style=color:#ae81ff>50</span><span style=color:#66d9ef>vw</span>, <span style=color:#ae81ff>500</span><span style=color:#66d9ef>px</span>); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* 50vw相当于视窗宽度的一半，如果视窗宽度是760px的话，那么50vw相当等于380px*/</span> 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>width</span>: <span style=color:#a6e22e>clamp</span>(<span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span>, <span style=color:#ae81ff>380</span><span style=color:#66d9ef>px</span>, <span style=color:#ae81ff>500</span><span style=color:#66d9ef>px</span>); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* 用min()和max()描述*/</span> 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>width</span>: <span style=color:#a6e22e>max</span>(<span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span>, <span style=color:#a6e22e>min</span>(<span style=color:#ae81ff>380</span><span style=color:#66d9ef>px</span>, <span style=color:#ae81ff>500</span><span style=color:#66d9ef>px</span>)) 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/*min(380px, 500px)返回的值是380px*/</span> 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>width</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>max</span>(<span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span>, <span style=color:#ae81ff>380</span><span style=color:#66d9ef>px</span>) 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/*max(100px, 380px)返回的值是380px*/</span> 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>width</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>380</span><span style=color:#66d9ef>px</span>; 
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=颜色体系>颜色体系<a hidden class=anchor aria-hidden=true href=#颜色体系>#</a></h3><p>我们现在描述颜色都是在<code>sRBG</code> 色值空间，而颜色色值空间是一个复杂的体系，除了 <code>sRGB</code> 之外还有其他的色值空间，比如说 <code>LCH</code>：</p><p><img loading=lazy src=/CSS/sRGB_LCH.image alt></p><p>正如上图所示，<code>LCH</code> 颜色空间的颜色数量要比 <code>sRGB</code> 颜色空间的多，而且描述的颜色更为细腻。</p><p>可以在<code>color()</code> 函数中指定颜色空间：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>#color-function {
</span></span><span style=display:flex><span>  --rad-pink: <span style=color:#a6e22e>color</span>(display<span style=color:#f92672>-</span>p3 <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>  --rad-pink: <span style=color:#a6e22e>color</span>(lab <span style=color:#ae81ff>50</span><span style=color:#66d9ef>%</span> <span style=color:#ae81ff>150</span> <span style=color:#ae81ff>-50</span>);
</span></span><span style=display:flex><span>  --rad-pink: <span style=color:#a6e22e>color</span>(srgb <span style=color:#ae81ff>100</span><span style=color:#66d9ef>%</span> <span style=color:#ae81ff>0</span><span style=color:#66d9ef>%</span> <span style=color:#ae81ff>50</span><span style=color:#66d9ef>%</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>注意，使用了<code>color()</code> 函数指定颜色空间除了要考虑该函数支持度（浏览器的兼容性）还需要考虑硬件设备对颜色空间的支持度。</p><p>在 CSS 中可以借助媒体查询 <code>@media</code> 来做相应的判断，比如下面的示例，如果终端设备支持的话，就会采用指定颜色空间的色值：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>@<span style=color:#66d9ef>media</span> <span style=color:#f92672>(</span><span style=color:#f92672>dynamic-range</span><span style=color:#f92672>:</span> <span style=color:#f92672>high</span><span style=color:#f92672>)</span> {
</span></span><span style=display:flex><span>  .<span style=color:#a6e22e>neon-pink</span> {
</span></span><span style=display:flex><span>    --neon-glow: <span style=color:#a6e22e>color</span>(display<span style=color:#f92672>-</span>p3 <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  .<span style=color:#a6e22e>neon-green</span> {
</span></span><span style=display:flex><span>  	--neon-grow: <span style=color:#a6e22e>color</span>(display<span style=color:#f92672>-</span>p3 <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=颜色关键字>颜色关键字<a hidden class=anchor aria-hidden=true href=#颜色关键字>#</a></h4><p>颜色关键字（color keywords）是不区分大小写的标识符，它表示一个具体的颜色，比如 white（白），黑（black）等；需要注意的是如果声明的时候的颜色关键字是错误的，浏览器会忽略它。</p><p>CSS2.1 设置了16个基本的颜色，CSS 3 又增加了131个。</p><p><strong>transparent 关键字</strong></p><p>transparent 关键字表示一个完全透明的颜色，即该颜色看上去将是背景色。从技术上说，它是带有 alpha 通道为最小值的黑色，是 rgba(0,0,0,0) 的简写。</p><p><strong>currentColor 关键字</strong></p><p>currentColor 会取当前元素继承父级元素的文本颜色值或声明的文本颜色值，即 computed 后的 color 值。</p><h4 id=rgba-颜色>RGB[A] 颜色<a hidden class=anchor aria-hidden=true href=#rgba-颜色>#</a></h4><p>RGB[A] 颜色是由 R(red)-G(green)-B(blue)-A(alpha) 组成的色彩空间。</p><p><img loading=lazy src=/CSS/RGBA.png alt></p><p><strong>十六进制符号</strong></p><p>日常生活中，我们使用的计数方法一般是 decimals，或十进制，即使用数字 0 到 9 来表示。 而 Hexadecimals（或 hex）基于 16 位数字， 它包括 16 种不同字符。 像十进制一样，0-9 的符号代表 0 到 9 的值。 然后，A、B、C、D、E、F 代表 10 至 15 的值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>button</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>color</span>: <span style=color:#ae81ff>#ff0000</span>aa;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>color</span>: <span style=color:#ae81ff>#f00a</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>RGB 中的每种颜色的值范围是 00~ff，值越大表示颜色越深。所以一个颜色正常是 6 个十六进制字符加上 # 组成，比如红色就是 #ff0000。</p><p>如果 RGB 颜色需要加上不透明度，那就需要加上 alpha 通道的值，它的范围也是 00~ff，比如一个带透明度为 67% 的红色可以这样写 #ff0000aa。</p><p>使用十六进制符号表示颜色的时候，都是用 2 个十六进制表示一个颜色，如果这 2 个字符相同，还可以缩减成只写 1 个，比如，红色 #f00；带 67% 不透明度的红色 #f00a。</p><p><strong>函数符</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>button</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>color</span>: rgba(<span style=color:#ae81ff>255</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0.67</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>color</span>: rgb(<span style=color:#ae81ff>100</span><span style=color:#66d9ef>%</span> <span style=color:#ae81ff>0</span><span style=color:#66d9ef>%</span> <span style=color:#ae81ff>0</span><span style=color:#66d9ef>%</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>67</span><span style=color:#66d9ef>%</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>当 RGB 用函数表示的时候，每个值的范围是 0~255 或者 0%~100%，所以红色是 rgb(255, 0, 0)， 或者 rgb(100%, 0, 0)。</p><p>如果需要使用函数来表示带不透明度的颜色值，值的范围是 0~1 及其之间的小数或者 0%~100%，比如带 67% 不透明度的红色是 rgba(255, 0, 0, 0.67) 或者 rgba(100%, 0%, 0%, 67%)，其中 0 代表完全透明，1 代表完全不透明。</p><p>需要注意的是 RGB 这 3 个颜色值需要保持一致的写法，要嘛用数字要嘛用百分比，而不透明度的值的可以不用和 RGB 保持一致写法。比如 rgb(100%, 0, 0) 这个写法是无效的；而 rgb(100%, 0%, 0%, 0.67) 是有效的。</p><p>在第 4 代 CSS 颜色标准中，新增了一种新的函数写法，即可以把 RGB 中值的分隔逗号改成空格，而把 RGB 和 alpha 中的逗号改成 /，比如带 67% 不透明度的红色可以这样写 rgba(255 0 0 / 0.67)。另外还把 rgba 的写法合并到 rgb 函数中了，即 rgb 可以直接写带不透明度的颜色。</p><h4 id=hsla-颜色>HSL[A] 颜色<a hidden class=anchor aria-hidden=true href=#hsla-颜色>#</a></h4><p>HSL[A] 颜色是由色相(hue)-饱和度(saturation)-亮度(lightness)-不透明度组成的颜色体系。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>button</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>color</span>: hsla(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>100</span><span style=color:#66d9ef>%</span>, <span style=color:#ae81ff>50</span><span style=color:#66d9ef>%</span>, <span style=color:#ae81ff>67</span><span style=color:#66d9ef>%</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>color</span>: hsl(<span style=color:#ae81ff>0</span><span style=color:#66d9ef>deg</span> <span style=color:#ae81ff>100</span><span style=color:#66d9ef>%</span> <span style=color:#ae81ff>50</span><span style=color:#66d9ef>%</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>67</span><span style=color:#66d9ef>%</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img loading=lazy src=/CSS/HALA.png alt></p><ul><li>色相（H）是色彩的基本属性，就是平常所说的颜色名称，如红色、黄色等。 以颜色光谱为例，光谱左边从红色开始，移动到中间的绿色，一直到右边的蓝色，色相值就是沿着这条线的取值。 在 hsl() 里面，色相用色环来代替光谱，色相值就是色环里面的颜色对应的从 0 到 360 度的角度值。</li><li>饱和度（S）是指色彩的纯度，也就是颜色里灰色的占比。 饱和度越高则灰色占比越少，色彩也就越纯；反之则完全是灰色。饱和度的取值范围是表示灰色所占百分比的 0 至 100。</li><li>亮度（L）决定颜色的明暗程度，也就是颜色里白色或者黑色的占比。 其中，100% 的亮度表示纯白色， 0% 的亮度则表示纯黑色；而 50% 的亮度就表示在色相中选取的颜色。</li><li>不透明度（A），取 0 或 1及之间的小数；</li></ul><p>写法上可以参考 RGB 的写法，只是参数的值不一样。</p><p>小提示：在 Chrome DevTools 中可以按住 shift + 鼠标左键可以切换颜色的表示方式。</p><p><img loading=lazy src=/CSS/%e5%88%87%e6%8d%a2%e9%a2%9c%e8%89%b2%e7%9a%84%e8%a1%a8%e7%a4%ba%e6%96%b9%e5%bc%8f.gif alt></p><h4 id=配色方案>配色方案<a hidden class=anchor aria-hidden=true href=#配色方案>#</a></h4><p>颜色理论研究的都是颜色的本质，至于颜色搭配，最终靠的还是个人感觉。说到底，Choosing colors is art, not science。</p><p><strong><a href=https://flatuicolors.com/>Flat UI 色表</a></strong></p><p>最简单的方法是，从一个给定的色表选择颜色。</p><p><img loading=lazy src=/CSS/FlatUI%e8%89%b2%e8%a1%a8.gif alt></p><p><strong><a href=https://docs.sendwithses.com/random-stuff/easy-to-remember-color-guide-for-non-designers>配色的经验法则</a></strong></p><p><img loading=lazy src=/CSS/%e9%85%8d%e8%89%b2%e7%9a%84%e7%bb%8f%e9%aa%8c%e6%b3%95%e5%88%99.png alt></p><p><strong><a href=https://github.com/chriskempson/base16>base16</a></strong></p><p>An architecture for building themes</p><p><img loading=lazy src=/CSS/base16.png alt></p><p><strong><a href=https://color.adobe.com/create/color-wheel/>Adobe Color CC</a></strong></p><p>选一个颜色，推荐对应的配色。</p><p><strong>互补色</strong></p><p>在网站设计里，颜色能让内容更醒目，能调动情绪，从而创造舒适的视觉体验。 不同的颜色组合对网站的视觉效果影响很大，精妙的设计都需要适宜的颜色来美化页面内容。</p><p>色环是我们认识颜色关系的好工具。它是一个近色相邻、异色相离的圆环。 当两个颜色恰好在色环的两端时，这两个颜色就互为补色。 两个互为补色的颜色会在混合后变成灰色。 然而，补色搭配能形成强烈的视觉对比效果。</p><p>颜色搭配是提起用户兴趣或吸引用户注意的重要方式之一。 但我们不应让颜色作为传达重要信息的唯一方式，因为视觉障碍用户可能无法像其他人一样看出其中的含义。</p><p><strong>三次色</strong></p><p>电脑显示器和各类屏幕都是基于颜色叠加的模型：将红（R）、绿（G）、蓝（B）三原色的色光以不同的比例相加，就可以产生各种色彩光。 这在现代色彩理论中叫作三原色光模式（RGB Color Model）。 红色（R）、绿色（G）和蓝色（B）叫作三原色。 如果把两种原色相加，就可以产生二次色：蓝绿（G+B）、品红（R+B）和黄色（R+G）。这些二次色恰好是在合成它们时未使用的原色的补色，即在色环中位于两端。 例如，品红色是红色和蓝色相加产生，它是绿色的补色。</p><p>三次色是由原色和二次色相加产生的颜色， 例如，在 RGB 颜色模型中，红色（原色）和黄色（二次色）相加产生橙色（三次色）。 将这六种颜色中相邻的颜色相加，便产生了十二色色环。</p><p>设计里面有很多种颜色搭配方法。 涉及到三次色的一种配色方法是分裂补色搭配法。 选定主色之后，在色环上选择与它的补色相邻的两种颜色与之搭配。 此种搭配既有对比，又不失和谐。</p><h4 id=颜色函数>颜色函数<a hidden class=anchor aria-hidden=true href=#颜色函数>#</a></h4><p>更为强大的是 <a href=https://www.w3.org/TR/css-color-5/><strong>CSS 颜色模块 Level 5 版本</strong></a>，对颜色函数能力做了进一步的扩展。比如，可以在 <code>rgb()</code>、<code>hsl()</code> 、<code>hwb()</code> 、<code>lab()</code> 和 <code>lch()</code> 函数基础上添加 <code>from</code> 关键词，实现基于一个颜色的基础上，只对某个参数做调整：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>rgb</span><span style=color:#f92672>()</span> <span style=color:#f92672>=</span> <span style=color:#f92672>rgb</span><span style=color:#f92672>([</span><span style=color:#f92672>from</span> <span style=color:#f92672>&lt;</span><span style=color:#f92672>color</span><span style=color:#f92672>&gt;]?</span> <span style=color:#f92672>&lt;</span><span style=color:#f92672>percentage</span><span style=color:#f92672>&gt;</span>{<span style=color:#960050;background-color:#1e0010>3</span>} <span style=color:#f92672>[</span> <span style=color:#f92672>/</span> <span style=color:#f92672>&lt;</span><span style=color:#f92672>alpha-value</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>]?</span> <span style=color:#f92672>)</span> <span style=color:#f92672>|</span> <span style=color:#f92672>rgb</span><span style=color:#f92672>([</span><span style=color:#f92672>from</span> <span style=color:#f92672>&lt;</span><span style=color:#f92672>color</span><span style=color:#f92672>&gt;]?</span> <span style=color:#f92672>&lt;</span><span style=color:#f92672>number</span><span style=color:#f92672>&gt;</span>{<span style=color:#960050;background-color:#1e0010>3</span>} <span style=color:#f92672>[</span> <span style=color:#f92672>/</span> <span style=color:#f92672>&lt;</span><span style=color:#f92672>alpha-value</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>]?</span> <span style=color:#f92672>)</span> 
</span></span><span style=display:flex><span><span style=color:#f92672>hsl</span><span style=color:#f92672>()</span> <span style=color:#f92672>=</span> <span style=color:#f92672>hsl</span><span style=color:#f92672>([</span><span style=color:#f92672>from</span> <span style=color:#f92672>&lt;</span><span style=color:#f92672>color</span><span style=color:#f92672>&gt;]?</span> <span style=color:#f92672>&lt;</span><span style=color:#f92672>hue</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&lt;</span><span style=color:#f92672>percentage</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&lt;</span><span style=color:#f92672>percentage</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>[</span> <span style=color:#f92672>/</span> <span style=color:#f92672>&lt;</span><span style=color:#f92672>alpha-value</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>]?</span> <span style=color:#f92672>)</span> 
</span></span><span style=display:flex><span><span style=color:#f92672>hwb</span><span style=color:#f92672>()</span> <span style=color:#f92672>=</span> <span style=color:#f92672>hwb</span><span style=color:#f92672>([</span><span style=color:#f92672>from</span> <span style=color:#f92672>&lt;</span><span style=color:#f92672>color</span><span style=color:#f92672>&gt;]?</span> <span style=color:#f92672>&lt;</span><span style=color:#f92672>hue</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&lt;</span><span style=color:#f92672>percentage</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&lt;</span><span style=color:#f92672>percentage</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>[</span> <span style=color:#f92672>/</span> <span style=color:#f92672>&lt;</span><span style=color:#f92672>alpha-value</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>]?</span> <span style=color:#f92672>)</span> 
</span></span><span style=display:flex><span><span style=color:#f92672>lab</span><span style=color:#f92672>()</span> <span style=color:#f92672>=</span> <span style=color:#f92672>lab</span><span style=color:#f92672>([</span><span style=color:#f92672>from</span> <span style=color:#f92672>&lt;</span><span style=color:#f92672>color</span><span style=color:#f92672>&gt;]?</span> <span style=color:#f92672>&lt;</span><span style=color:#f92672>percentage</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&lt;</span><span style=color:#f92672>number</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&lt;</span><span style=color:#f92672>number</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>[</span> <span style=color:#f92672>/</span> <span style=color:#f92672>&lt;</span><span style=color:#f92672>alpha-value</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>]?</span> <span style=color:#f92672>)</span> 
</span></span><span style=display:flex><span><span style=color:#f92672>lch</span><span style=color:#f92672>()</span> <span style=color:#f92672>=</span> <span style=color:#f92672>lch</span><span style=color:#f92672>([</span><span style=color:#f92672>from</span> <span style=color:#f92672>&lt;</span><span style=color:#f92672>color</span><span style=color:#f92672>&gt;]?</span> <span style=color:#f92672>&lt;</span><span style=color:#f92672>percentage</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&lt;</span><span style=color:#f92672>number</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&lt;</span><span style=color:#f92672>hue</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>[</span> <span style=color:#f92672>/</span> <span style=color:#f92672>&lt;</span><span style=color:#f92672>alpha-value</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>]?</span> <span style=color:#f92672>)</span>
</span></span></code></pre></div><p>来看一个 <code>hsl()</code> 的示例：</p><p><img loading=lazy src=/CSS/hsl_from.image alt=img></p><p>上图展示的是，基于 <code>--theme-primary</code> （原色，即 <code>hsl(274, 61%, 50%)</code>）颜色只对<code>l</code> 参数做调整，从 <code>50%</code> 调整到 <code>30%</code> ，从而获得一个新的颜色，即 <code>hsl(274, 61%, 30%)</code> 。使用这样的方式，我们就可以很轻易的获取基于某个颜色参数改变得来的颜色面板：</p><p><img loading=lazy src=/CSS/hsl_from_many.image alt=img></p><p>除此之外， 颜色模块 Level 5 版本还新增了一些新的函数用来描述颜色，比如 <code>color-mix()</code> 、<code>color-contrast()</code> 、<code>color-adjust()</code> 等：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>color-mix</span> {
</span></span><span style=display:flex><span>  --pink: <span style=color:#a6e22e>color-mix</span>(<span style=color:#66d9ef>red</span>, <span style=color:#66d9ef>white</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  --brand: <span style=color:#ae81ff>#0af</span>;
</span></span><span style=display:flex><span>  --text1: <span style=color:#a6e22e>color-mix</span>(<span style=color:#a6e22e>var</span>(<span style=color:#f92672>--</span>brand) <span style=color:#ae81ff>25</span><span style=color:#66d9ef>%</span>, <span style=color:#66d9ef>black</span>);
</span></span><span style=display:flex><span>  --text2: <span style=color:#a6e22e>color-mix</span>(<span style=color:#a6e22e>var</span>(<span style=color:#f92672>--</span>brand) <span style=color:#ae81ff>40</span><span style=color:#66d9ef>%</span>, <span style=color:#66d9ef>black</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>color-contrast</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>color</span>: <span style=color:#a6e22e>color-contrast</span>(
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>var</span>(<span style=color:#f92672>--</span>bg)
</span></span><span style=display:flex><span>    vs
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>black</span>, <span style=color:#66d9ef>white</span>
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>--text-on-bg</span><span style=color:#f92672>:</span> <span style=color:#f92672>color-contrast</span><span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>var</span><span style=color:#f92672>(</span><span style=color:#f92672>--bg-blue-1</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>vs</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>var</span><span style=color:#f92672>(</span><span style=color:#f92672>--text-subdued</span><span style=color:#f92672>),</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>var</span><span style=color:#f92672>(</span><span style=color:#f92672>--text-light</span><span style=color:#f92672>),</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>var</span><span style=color:#f92672>(</span><span style=color:#f92672>--text-lightest</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>color-adjust</span> {
</span></span><span style=display:flex><span>  --brand: <span style=color:#ae81ff>#0af</span>;
</span></span><span style=display:flex><span>  --darker: <span style=color:#a6e22e>color-adjust</span>(<span style=color:#a6e22e>var</span>(<span style=color:#f92672>--</span>brand) lightness <span style=color:#ae81ff>-50</span><span style=color:#66d9ef>%</span>);
</span></span><span style=display:flex><span>  --lighter: <span style=color:#a6e22e>color-adjust</span>(<span style=color:#a6e22e>var</span>(<span style=color:#f92672>--</span>brand) lightness <span style=color:#ae81ff>+50</span><span style=color:#66d9ef>%</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>简单介绍一下这几个颜色函数。其中 <code>color-mix()</code> 函数接受两个 <code>&lt;color></code> 值，并在给定的颜色空间中以指定的数量返回它们混合的结果。如果没有特殊说明，否则在 <code>lch()</code> 颜色空间中进行混合。比如下图所展示的就是 在<code>lch()</code> 颜色空间（默认）中将 <code>red</code> 和 <code>yellow</code> 混合，每个 <code>lch</code> 通道的红色值占<code>65%</code>，黄色值占 <code>35%</code>，即 <code>color-mix(red yellow 65%)</code> ：</p><p><img loading=lazy src=/CSS/color-mix.image alt=img></p><p><code>color-contrast()</code> 函数很有意思，它可以帮助我们提高Web可访问性方面的能力。其主要作用是获取一个颜色值，并将其与其他颜色值的列表进行比较，从列表中选择对比度最高的一个。</p><p><img loading=lazy src=/CSS/color-contrast.image alt=img></p><p>比如 <code>color-contrast(white vs red, white, green)</code> ，分别会拿 <code>red</code> 、<code>white</code> 和 <code>green</code> 与 <code>white</code> 对比，其中 <code>green</code> 与 <code>white</code> 对比度最高，最终会取 <code>green</code> 颜色：</p><p><img loading=lazy src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36d799f992ea421f96d7752d913aa8ff~tplv-k3u1fbpfcp-zoom-1.image alt=img></p><p><code>color-adjust()</code> 函数可用来在给定颜色空间中通过指定的变换函数对该颜色进行调整，除非另有规定，否则调整是在 <code>lch()</code> 色彩空间中进行的。比如 <code>color-adjust(#0af lightness +50%)</code> 是颜色 <code>#0af</code> 在 <code>lch</code> 颜色空间中高度增加 <code>50%</code> 。</p><h4 id=css-混合模式>CSS 混合模式<a hidden class=anchor aria-hidden=true href=#css-混合模式>#</a></h4><p>CSS 混合模式是个很有意思的特性，目前主要有 <code>mix-blend-mode</code> 和 <code>background-blend-mode</code> 两个属性，前者是用于多个元素的合成，后者是用于多个背景的合成。使用它们可以实现一些特殊的效果，比如类似 Photoshop 中的滤镜效果：</p><p><img loading=lazy src=/CSS/%e6%b7%b7%e5%90%88%e6%a8%a1%e5%bc%8f.png alt></p><p>采用混合模式特性，我们可以轻易的实现<a href=https://codepen.io/kylewetton/full/OJLmJoV>产品图换色</a>的效果。</p><h3 id=css-变量>CSS 变量<a hidden class=anchor aria-hidden=true href=#css-变量>#</a></h3><p><strong>变量的声明</strong></p><p>CSS 变量（CSS variable）又叫做"CSS 自定义属性"（CSS custom properties）。</p><p>声明变量的时候，变量名前面要加两根连词线（<code>--</code>）。各种值都可以放入 CSS 变量。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>:<span style=color:#a6e22e>root</span>{
</span></span><span style=display:flex><span>  --main-color: <span style=color:#ae81ff>#4d4e53</span>;
</span></span><span style=display:flex><span>  --main-bg: rgb(<span style=color:#ae81ff>255</span>, <span style=color:#ae81ff>255</span>, <span style=color:#ae81ff>255</span>);
</span></span><span style=display:flex><span>  --logo-border-color: <span style=color:#66d9ef>rebeccapurple</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  --header-height: <span style=color:#ae81ff>68</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>  --content-padding: <span style=color:#ae81ff>10</span><span style=color:#66d9ef>px</span> <span style=color:#ae81ff>20</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  --base-line-height: <span style=color:#ae81ff>1.428571429</span>;
</span></span><span style=display:flex><span>  --transition-duration: <span style=color:#ae81ff>.35</span><span style=color:#66d9ef>s</span>;
</span></span><span style=display:flex><span>  --external-link: <span style=color:#e6db74>&#34;external link&#34;</span>;
</span></span><span style=display:flex><span>  --margin-top: calc(<span style=color:#ae81ff>2</span><span style=color:#66d9ef>vh</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>20</span><span style=color:#66d9ef>px</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>变量名大小写敏感，<code>--header-color</code>和<code>--Header-Color</code>是两个不同变量。</p><p>如果变量值是一个字符串，可以与其他字符串拼接。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>--bar</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;hello&#39;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>--foo</span><span style=color:#f92672>:</span> <span style=color:#f92672>var</span><span style=color:#f92672>(</span><span style=color:#f92672>--bar</span><span style=color:#f92672>)</span><span style=color:#e6db74>&#39; world&#39;</span><span style=color:#f92672>;</span>
</span></span></code></pre></div><p>如果变量值是数值，不能与数值单位直接连用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>foo</span> {
</span></span><span style=display:flex><span>  --gap: <span style=color:#ae81ff>20</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>margin-top</span>: <span style=color:#a6e22e>var</span>(<span style=color:#f92672>--</span>gap)px;		<span style=color:#75715e>/* 无效 */</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>必须使用<code>calc()</code>函数，将它们连接。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>foo</span> {
</span></span><span style=display:flex><span>  --gap: <span style=color:#ae81ff>20</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>margin-top</span>: calc(<span style=color:#a6e22e>var</span>(<span style=color:#f92672>--</span>gap) <span style=color:#f92672>*</span> <span style=color:#ae81ff>1</span><span style=color:#66d9ef>px</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果变量值带有单位，就不能写成字符串。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>foo</span> {
</span></span><span style=display:flex><span>  --foo: <span style=color:#e6db74>&#39;20px&#39;</span>;		<span style=color:#75715e>/* 无效 */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>font-size</span>: <span style=color:#a6e22e>var</span>(<span style=color:#f92672>--</span>foo);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>var() 函数</strong></p><p><code>var()</code>函数用于读取变量。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>a</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>color</span>: <span style=color:#a6e22e>var</span>(<span style=color:#f92672>--</span>foo);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>text-decoration-color</span>: <span style=color:#a6e22e>var</span>(<span style=color:#f92672>--</span>bar);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>var()</code>函数还可以使用第二个参数，表示变量的默认值。如果该变量不存在，就会使用这个默认值。第二个参数不处理内部的逗号或空格，都视作参数的一部分。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>someElement</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>color</span>: <span style=color:#a6e22e>var</span>(<span style=color:#f92672>--</span>foo, <span style=color:#ae81ff>#7F583F</span>);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>font-family</span>: <span style=color:#a6e22e>var</span>(<span style=color:#f92672>--</span>main<span style=color:#f92672>-</span>font, <span style=color:#e6db74>&#34;lucida grande&#34;</span> , tahoma, Arial);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面代码中，<code>--main-font</code>的默认值是<code>"lucida grande" , tahoma, Arial</code>。</p><p><code>var()</code>函数还可以用在变量的声明。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>:<span style=color:#a6e22e>root</span> {
</span></span><span style=display:flex><span>  --primary-color: <span style=color:#66d9ef>red</span>;
</span></span><span style=display:flex><span>  --logo-text: <span style=color:#a6e22e>var</span>(<span style=color:#f92672>--</span>primary<span style=color:#f92672>-</span><span style=color:#66d9ef>color</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>注意，变量值只能用作属性值，不能用作属性名。</p><p><code>var()</code>内部还可以使用<code>var()</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>someElement</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>background-color</span>: <span style=color:#a6e22e>var</span>(<span style=color:#f92672>--</span><span style=color:#66d9ef>first</span><span style=color:#f92672>-</span><span style=color:#66d9ef>color</span>, <span style=color:#a6e22e>var</span>(<span style=color:#f92672>--</span>second<span style=color:#f92672>-</span><span style=color:#66d9ef>color</span>, <span style=color:#66d9ef>white</span>));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面代码中，如果没有设置<code>--first-color</code>，默认值<code>var(--second-color, white)</code>就会生效。如果<code>--second-color</code>也没有设置，那么<code>white</code>就会生效。</p><p><strong>作用域</strong></p><p>自定义属性可以是全局的，也可以是局部的。在<code>:root</code>选择器里面定义的，就是全局变量，可以在任何其他选择器里面读取。而在其他选择器里面定义，就是局部变量，只能在该选择器里面读取。这就是说，变量的作用域就是它所在的选择器的有效范围。</p><p>同一个 CSS 变量，可以在多个选择器内声明。读取的时候，优先级最高的声明生效。这与 CSS 的"层叠"（cascade）规则是一致的。</p><p><strong><a href=https://juejin.cn/post/6971617175886888997#heading-12>无效变量</a></strong></p><p>CSS 自定义属性中的<a href=https://www.w3.org/TR/css-variables-1/#invalid-variables>无效变量</a>是很有用的一个特性，它可以实现 <code>1</code> （真）和 <code>0</code> （假）的开关切换效果。</p><p>定义：当一个自定义属性的值是 <strong>initial</strong> 时，<strong>var()</strong> 函数不能使用它进行替换。除非指定了一个有效的回退值，否则会使声明在计算值时无效。</p><p>在 CSS 中注册自定义属性时是使用 <code>--</code> 来注册的，可以给已注册的自定义属性赋值，包括空字符串，但其中有一个细节非常有意思：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>:<span style=color:#a6e22e>root</span> {
</span></span><span style=display:flex><span>    --invalid:; <span style=color:#960050;background-color:#1e0010>//</span> <span style=color:#960050;background-color:#1e0010>注意冒号和分号之间无空格符，也无任何字符</span>
</span></span><span style=display:flex><span>    --valid: ;  <span style=color:#960050;background-color:#1e0010>//</span> <span style=color:#960050;background-color:#1e0010>注意冒号和分号之间只有一个空格符</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>其中，<code>--invalid</code> 自定义属性被称为无效变量，而 <code>--valid</code> 自定义属性是一个有效变量。使用上面这种方式来区分有效和无效变量对于开发者而言，可读性极差，而且有些文本编辑器可能会对代码按自己配置的规格格式化，有可能会造成 <code>--invalid:;</code> 变成 <code>--invalid: ;</code> （有空格）。为此，一般使用关键词 <code>initial</code>来显式声明一个自定义属性为无效变量：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>:<span style=color:#a6e22e>root</span> {
</span></span><span style=display:flex><span>    --invalid: <span style=color:#66d9ef>initial</span>; 		<span style=color:#960050;background-color:#1e0010>//</span> <span style=color:#960050;background-color:#1e0010>无效变量</span>
</span></span><span style=display:flex><span>    --valid: ;					<span style=color:#960050;background-color:#1e0010>//</span> <span style=color:#960050;background-color:#1e0010>有效变量</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果不使用 <code>var()</code> 函数调用已注册的自定义属性的话，那么对于已注册的自定义属性而言，不会起任何作用。而 <code>var()</code> 函数有两个参数，第一个参数就是自定义属性，第二个参数是备用值。当第一个参数是个无效值时，会采用第二个参数。正因如此，对于已注册的无效自定义属性（即无效变量），比如 上面代码中的 <code>--invalid</code> 。那么 <code>var()</code> 没有提供备用值（第二个参数），则会使 CSS 样式规则（声明）在计算值时无效：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>:<span style=color:#a6e22e>root</span> {
</span></span><span style=display:flex><span>    --invalid: <span style=color:#66d9ef>initial</span>; <span style=color:#960050;background-color:#1e0010>//</span> <span style=color:#960050;background-color:#1e0010>无效变量</span>
</span></span><span style=display:flex><span>    --valid: ;          <span style=color:#960050;background-color:#1e0010>//</span> <span style=color:#960050;background-color:#1e0010>有效变量</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>foo</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>background-color</span>: <span style=color:#a6e22e>var</span>(<span style=color:#f92672>--</span>invalid); <span style=color:#960050;background-color:#1e0010>//</span> <span style=color:#960050;background-color:#1e0010>未提供备用值，则background-color</span> <span style=color:#960050;background-color:#1e0010>计算值无效</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>color</span>: <span style=color:#a6e22e>var</span>(<span style=color:#f92672>--</span>invalid, <span style=color:#66d9ef>red</span>)        <span style=color:#f92672>//</span> <span style=color:#960050;background-color:#1e0010>提供了备用值，</span><span style=color:#f92672>--</span>invalid<span style=color:#960050;background-color:#1e0010>是无效变量，则会采用备用值</span> <span style=color:#66d9ef>red</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>为了在使用 CSS 自定义属性中的无效变量让开发者更易于理解，<a href=https://twitter.com/LeaVerou>@Lea Verou</a> 在<a href=https://lea.verou.me/2020/10/the-var-space-hack-to-toggle-multiple-values-with-one-custom-property/>《The &ndash;var: ; hack to toggle multiple values with one custom property》</a>引入了类似于Switch的概念，即：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>:<span style=color:#a6e22e>root</span> {
</span></span><span style=display:flex><span>    --ON: <span style=color:#66d9ef>initial</span>; <span style=color:#960050;background-color:#1e0010>//</span> <span style=color:#960050;background-color:#1e0010>无效变量,相当于开启</span> <span style=color:#960050;background-color:#1e0010>var()的备用值</span>
</span></span><span style=display:flex><span>    --OFF:;        <span style=color:#960050;background-color:#1e0010>//</span> <span style=color:#960050;background-color:#1e0010>有效变量,相当于关闭</span> <span style=color:#960050;background-color:#1e0010>var()的备用值</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这样一来，我们在做 UI 不同状态切换时，就只需要对 <code>--ON</code> 和 <code>--OFF</code> 的切换。比如 @Lea Verou 在文章中提供的<a href=https://codepen.io/airen/full/XWNYRga>示例</a>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>:<span style=color:#a6e22e>root</span> {
</span></span><span style=display:flex><span>    --ON: <span style=color:#66d9ef>initial</span>;
</span></span><span style=display:flex><span>    --OFF: ;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>button</span> {
</span></span><span style=display:flex><span>    --is-raised: <span style=color:#a6e22e>var</span>(<span style=color:#f92672>--</span>OFF);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>border</span>: <span style=color:#ae81ff>1</span><span style=color:#66d9ef>px</span> <span style=color:#66d9ef>solid</span> <span style=color:#a6e22e>var</span>(<span style=color:#f92672>--</span>is<span style=color:#f92672>-</span>raised, rgb(<span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>0.1</span>));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>background</span>: <span style=color:#a6e22e>var</span>(
</span></span><span style=display:flex><span>        <span style=color:#f92672>--</span>is<span style=color:#f92672>-</span>raised,
</span></span><span style=display:flex><span>        linear-gradient(hsl(<span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span><span style=color:#66d9ef>%</span> <span style=color:#ae81ff>100</span><span style=color:#66d9ef>%</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>0.3</span>), <span style=color:#66d9ef>transparent</span>)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>        hsl(<span style=color:#ae81ff>200</span> <span style=color:#ae81ff>100</span><span style=color:#66d9ef>%</span> <span style=color:#ae81ff>50</span><span style=color:#66d9ef>%</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>box-shadow</span>: <span style=color:#a6e22e>var</span>(
</span></span><span style=display:flex><span>        <span style=color:#f92672>--</span>is<span style=color:#f92672>-</span>raised,
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>1</span><span style=color:#66d9ef>px</span> hsl(<span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span><span style=color:#66d9ef>%</span> <span style=color:#ae81ff>100</span><span style=color:#66d9ef>%</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>0.8</span>) <span style=color:#66d9ef>inset</span>,
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0.1</span><span style=color:#66d9ef>em</span> <span style=color:#ae81ff>0.1</span><span style=color:#66d9ef>em</span> <span style=color:#ae81ff>-0.1</span><span style=color:#66d9ef>em</span> rgb(<span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>0.2</span>)
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>text-shadow</span>: <span style=color:#a6e22e>var</span>(<span style=color:#f92672>--</span>is<span style=color:#f92672>-</span>raised, <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>-1</span><span style=color:#66d9ef>px</span> <span style=color:#ae81ff>1</span><span style=color:#66d9ef>px</span> rgb(<span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>0.3</span>));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>button</span>:<span style=color:#a6e22e>hover</span> {
</span></span><span style=display:flex><span>    --is-raised: <span style=color:#a6e22e>var</span>(<span style=color:#f92672>--</span>ON);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>button</span>:<span style=color:#a6e22e>active</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>box-shadow</span>: <span style=color:#a6e22e>var</span>(<span style=color:#f92672>--</span>is<span style=color:#f92672>-</span>raised, <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>1</span><span style=color:#66d9ef>px</span> <span style=color:#ae81ff>0.2</span><span style=color:#66d9ef>em</span> <span style=color:#66d9ef>black</span> <span style=color:#66d9ef>inset</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=应用无障碍>应用无障碍<a hidden class=anchor aria-hidden=true href=#应用无障碍>#</a></h3><p><strong>使用自定义 CSS 让元素仅对屏幕阅读器可见</strong></p><p>如果我们需要在页面中添加一些只对屏幕阅读器可见的内容时，CSS 可以提升页面的可访问性。当信息以可视化形式（如：图表）展示，而屏幕阅读器用户需要一种替代方式（如：表格）来获取信息时，就会出现这种情况。CSS 被用来将这些仅供屏幕阅读器使用的信息定位到浏览器可见区域之外。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>sr-only</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>position</span>: <span style=color:#66d9ef>absolute</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>left</span>: <span style=color:#ae81ff>-10000</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>width</span>: <span style=color:#ae81ff>1</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>height</span>: <span style=color:#ae81ff>1</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>top</span>: <span style=color:#66d9ef>auto</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>overflow</span>: <span style=color:#66d9ef>hidden</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>display: none;</code>或<code>visibility: hidden;</code>会把内容彻底隐藏起来，对于屏幕阅读器也不例外。</p><p>如果把值设置为 0px，如<code>width: 0px; height: 0px;</code>，意味着让元素脱离文档流，这样做也会让元素被屏幕阅读器忽略。</p><p><strong>使用高对比度文本提高可读性</strong></p><p>低对比度的前景色与背景色会使文本难以阅读。足够的对比度可以提高内容的可读性，但是怎样的对比度才算是 “足够” 的？</p><p>Web 内容无障碍指南（WCAG）建议正常文本的对比度至少为 4.5 : 1。对比度是通过比较两种颜色的相对亮度值来计算的，其范围是从相同颜色的 1 : 1（无对比度）到白色与黑色的最高对比度 21 : 1。网上有很多可以帮助你计算对比度的工具。</p><p><strong>通过使用充足的对比度避免色盲问题</strong></p><p>颜色是可视化设计的重要组成部分，但是使用颜色也引入了两个可访问性问题。首先，不能仅仅使用颜色作为传达重要信息的唯一方式，因为屏幕阅读器无法获取这些信息。其次，前景色与背景色需要有足够的对比度，这样色盲用户才可以识别它们。</p><p>我们用文本备用方案解决了第一个问题。我们使用对比度检测工具解决了第二问题。</p><p><strong>通过仔细选择传达信息的颜色来避免色盲问题</strong></p><p>色盲的形式有很多种，它的表现可以从对特定波长光波的感知度较低，到几乎无法看到颜色。最常见的形式是对绿色的低感知度。</p><p>一些在线颜色拾取器有色盲模拟功能，可以模拟颜色在不同形式色盲的视觉中的呈现结果，它们和在线对比度检查器一样，都是很好的工具。</p><p><strong>通过给元素添加 accesskey 属性来让用户可以在链接之间快速导航</strong></p><p>HTML 提供<code>accesskey</code>属性，用于指定激活标签或者使标签获得焦点的快捷键，这可以使键盘用户的导航更加有效。</p><p>HTML5 允许在任何标签上使用这个属性。该属性对于交互类标签（如链接、按钮、表单控件等）十分有用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>button</span> <span style=color:#a6e22e>accesskey</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;b&#34;</span>&gt;Important Button&lt;/<span style=color:#f92672>button</span>&gt;
</span></span></code></pre></div><p><strong>使用 tabindex 将键盘焦点添加到元素中</strong></p><p>HTML 的<code>tabindex</code>属性有三个不同与标签焦点的功能。当它在标签上时，表示标签可以获得焦点。它的值可以是零、负整数及正整数，并决定了标签的行为。</p><p>当用户在页面中使用 tab 键时，有些标签，如：链接、表单控件，可以自动获得焦点。它们获得焦点的顺序与它们出现在文档流中的顺序一致。我们可以通过将<code>tabindex</code>属性值设为 0，来给其他标签赋予相同的功能。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>tabindex</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;0&#34;</span>&gt;I need keyboard focus!&lt;/<span style=color:#f92672>div</span>&gt;
</span></span></code></pre></div><p><code>tabindex</code>属性值为负整数（通常为 -1）的标签也是有焦点的，只是不可以通过 tab 键来获得焦点。</p><p><code>tabindex</code>属性还可以指定标签的 tab 键顺序，将它的值设置为大于或等于 1 就可以实现这个功能。<code>tabindex</code>属性值为 1 的标签将首先获得键盘焦点，然后焦点将按照指定的<code>tabindex</code>的值（如：2，3 等）的顺序进行移动，直到回到默认的或<code>tabindex</code>值为 0 的标签上，如此循环。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>tabindex</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;1&#34;</span>&gt;I get keyboard focus, and I get it first!&lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>tabindex</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;2&#34;</span>&gt;I get keyboard focus, and I get it second!&lt;/<span style=color:#f92672>div</span>&gt;
</span></span></code></pre></div><p>需要注意的是，当按照这种方式设置 tab 键顺序时，将会覆盖默认的顺序（标签在文档流中出现的顺序）。这可能会令那些希望从页面顶部开始导航的用户感到困惑。这个技术在某些情况下可能是必要的，但是对可访问性而言，在应用时要十分小心。</p><h2 id=流>流<a hidden class=anchor aria-hidden=true href=#流>#</a></h2><p>“流”又叫文档流，是css的一种基本定位和布局机制。流是html的一种抽象概念，暗喻这种排列布局方式好像水流一样自然自动。“流体布局”是html默认的布局机制，如你写的html不用css，默认自上而下（块级元素如div）从左到右（内联元素如span）堆砌的布局方式。</p><h2 id=盒模型>盒模型<a hidden class=anchor aria-hidden=true href=#盒模型>#</a></h2><p><img loading=lazy src=/CSS/%e6%a0%87%e5%87%86%e7%9b%92%e6%a8%a1%e5%9e%8b.jpg alt></p><p>w3c标准模型： <code>box-sizing: content-box</code> 此模式下，元素的宽度计算为<code>content</code>的宽度。</p><p>IE模型： <code>box-sizing: border-box</code> 此模式下，元素的宽度计算为<code>border+padding+content</code>的宽度总和。</p><h3 id=视觉格式化模型>视觉格式化模型<a hidden class=anchor aria-hidden=true href=#视觉格式化模型>#</a></h3><p>视觉格式化模型（Visual formatting model）是用来处理和在视觉媒体上显示文档时使用的计算规则。CSS 中一切皆盒子，而视觉格式化模型简单来理解就是规定这些盒子应该怎么样放置到页面中去。</p><p>盒子类型由 display 决定，同时给一个元素设置 display 后，将会决定这个盒子的 2 个显示类型（display type）：</p><ul><li>outer display type（对外显示）（外在盒子）：决定了该元素本身是如何布局的，即参与何种格式化上下文；外在盒子负责结构布局。</li><li>inner display type（对内显示）（内在盒子）：其实就相当于把该元素当成了容器，里面包裹着文本或者其他子元素。规定了其内部子元素是如何布局的、参与何种格式化上下文；内在盒子负责内容显示。</li></ul><h4 id=outer-display-type>outer display type<a hidden class=anchor aria-hidden=true href=#outer-display-type>#</a></h4><p>对外显示方面，盒子类型可以分成 2 类：block-level box（块级盒子） 和 inline-level box（行内级盒子）。</p><ul><li>块级盒子：display 为 block、list-item、table、flex、grid、flow-root 等；</li><li>行内级盒子：display 为 inline、inline-block、inline-table、table-cell 等；</li></ul><p>所有块级盒子都会参与 BFC，呈现垂直排列；而所有行内级盒子都参会 IFC，呈现水平排列。</p><p><strong>block</strong></p><ul><li>占满一行，默认继承父元素的宽度；多个块元素将从上到下进行排列；</li><li>设置 width/height 将会生效；</li><li>设置 padding 和 margin 将会生效；</li></ul><p><strong>inline</strong></p><ul><li>不会占满一行，宽度随着内容而变化；多个 inline 元素将按照从左到右的顺序在一行里排列显示，如果一行显示不下，则自动换行；</li><li>设置 width/height 将不会生效；</li><li>设置竖直方向上的 padding 和 margin 将不会生效；</li></ul><p><strong>inline-block</strong></p><ul><li>是行内块元素，不单独占满一行，可以看成是能够在一行里进行左右排列的块元素；</li><li>设置 width/height 将会生效；</li><li>设置 padding 和 margin 将会生效；</li></ul><h4 id=inner-display-type>inner display type<a hidden class=anchor aria-hidden=true href=#inner-display-type>#</a></h4><p>对内方面，其实就是把元素当成了容器，里面包裹着文本或者其他子元素。container box 的类型依据 display 的值不同，分为 4 种：</p><ul><li>block container：建立 BFC 或者 IFC；</li><li>flex container：建立 FFC；</li><li>grid container：建立 GFC;</li><li>ruby container：接触不多，不做介绍。</li></ul><p>值得一提的是如果把 img 这种替换元素（replaced element）申明为 block 是不会产生 container box 的，因为替换元素比如 img 设计的初衷就仅仅是通过 src 把内容替换成图片，完全没考虑过会把它当成容器。</p><h3 id=内联盒模型>内联盒模型<a hidden class=anchor aria-hidden=true href=#内联盒模型>#</a></h3><p>内联元素是指外在盒子是内联盒子的元素。从表现来说，内联元素的典型特征就是可以和文字在一行显示。文字也是内联元素。图片、按钮、输入框、下拉框等替换元素也是内联元素。内联盒模型是指内联元素包含的几个盒子：</p><ul><li>内容区域：本质上是字符盒子。在浏览器中，文字选中状态的背景色就是内容区域。</li><li>内联盒子：内联盒子就是指元素的外在盒子是内联的，会和其他内联盒子排成一行。</li><li>行框盒子：由内联元素组成的每一行都是一个行框盒子。如果一行里面没有内联元素如一个空的<code>div</code>标签，则不会形成行框盒子。行框盒子由一个个内联盒子组成，如果换行，那就是两个行框盒子。比如一个包含了很多字符的换行的的<code>p</code>标签，每一行都存在一个行框盒子。值得注意的是，如果给元素设置<code>display: inline-block</code>，则创建了一个独立的行框盒子。<code>line-height</code>是作用在行框盒子上的，并最终决定高度。</li><li>包含盒子：就是包含块。多行文字组成一个包含块，一个包含块有若干个行框盒子。</li><li>幽灵空白节点：内联元素的每个行框盒子前面有一个“空白节点”，这个“空白节点”不占据任何宽度，无法选中获取，但是又实实在在存在，表现就如同文本节点一样（用字母x模拟幽灵空白节点）。</li></ul><h3 id=替换元素>替换元素<a hidden class=anchor aria-hidden=true href=#替换元素>#</a></h3><p>替换元素是指内容可以替换的元素，实际上就是<code>content box</code>可以被替换的元素。如存在<code>src=""</code>属性的<code>&lt;img> &lt;audio> &lt;video> &lt;iframe></code>元素和可以输入文本的<code>&lt;input> &lt;select> &lt;textarea></code>元素等。</p><p>所有替换元素都是内联元素，默认<code>display</code>属性是<code>inline</code>或<code>inline-block</code>（除了<code>input[type="hidden"]</code>默认<code>display: none;</code>）。</p><p>替换元素有自己默认的样式、尺寸（根据浏览器不同而不同），而且其<code>vertical-align</code>属性默认是<code>bottom</code>（非替换元素默认值是<code>baseline</code>）。</p><h3 id=widthheight-属性>width/height 属性<a hidden class=anchor aria-hidden=true href=#widthheight-属性>#</a></h3><p>你可以使用 CSS 里的 <code>width</code>/<code>height</code> 属性来指定元素的宽度。 属性值可以是相对单位（比如 <code>em</code>），绝对单位（比如 <code>px</code>），或者包含块（父元素）宽度的百分比。</p><p><code>width</code>、<code>height</code>的默认值都是<code>auto</code>。</p><ul><li>对于块级元素，流体布局之下<code>width: auto</code>自适应撑满父元素宽度。这里的撑满并不同于<code>width: 100%</code>的固定宽度，而是像水一样能够根据<code>margin</code>不同而自适应父元素的宽度。</li><li>对于内联元素，<code>width: auto</code>则呈现出包裹性，即由子元素的宽度决定。</li><li>无论内联元素还是块级元素，<code>height: auto</code>都是呈现包裹性，即高度由子级元素撑开。</li></ul><p>注意父元素<code>height: auto</code>会导致子元素<code>height: 100%</code>百分比失效。</p><p>css的属性非常有意思，正常流下，如果块级元素的<code>width</code>是个固定值，<code>margin</code>是<code>auto</code>，则<code>margin</code>会撑满剩下的空间；如果<code>margin</code>是固定值，<code>width</code>是<code>auto</code>，则<code>width</code>会撑满剩下的空间。这就是流体布局的根本所在。</p><h3 id=content-属性>content 属性<a hidden class=anchor aria-hidden=true href=#content-属性>#</a></h3><p>对于非替换元素如<code>div</code>,其<code>content</code>就是<code>div</code>内部的元素。 而对于替换元素，其<code>content</code>就是可替换部分的内容。</p><p><code>content</code>属性主要用于伪元素<code>:before/:after</code>中。</p><h3 id=padding-属性>padding 属性<a hidden class=anchor aria-hidden=true href=#padding-属性>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>padding</span><span style=color:#f92672>:</span> <span style=color:#f92672>30px</span> <span style=color:#f92672>20px</span> <span style=color:#f92672>40px</span> <span style=color:#f92672>100px</span><span style=color:#f92672>;</span>	<span style=color:#75715e>/* top right bottom left */</span>
</span></span><span style=display:flex><span><span style=color:#f92672>padding</span><span style=color:#f92672>:</span> <span style=color:#f92672>30px</span> <span style=color:#f92672>20px</span> <span style=color:#f92672>40px</span><span style=color:#f92672>;</span>		<span style=color:#75715e>/* 30px 20px 40px 20px */</span>
</span></span><span style=display:flex><span><span style=color:#f92672>padding</span><span style=color:#f92672>:</span> <span style=color:#f92672>30px</span> <span style=color:#f92672>40px</span><span style=color:#f92672>;</span>				<span style=color:#75715e>/* 30px 40px 30px 40px */</span>
</span></span><span style=display:flex><span><span style=color:#f92672>padding</span><span style=color:#f92672>:</span> <span style=color:#f92672>30px</span><span style=color:#f92672>;</span>					<span style=color:#75715e>/* 30px 30px 30px 30px */</span>
</span></span></code></pre></div><p>padding 区域有背景色，且和内容区相同。</p><p>元素真正的内容的宽高只是<code>content box</code>的宽高，而<code>line-height</code>属性是不作用于<code>padding</code>的。</p><p><code>padding</code>不可为负值，但是可以为百分比值。为百分比时水平和垂直方向的<code>padding</code>都是相对于父级元素宽度计算的。</p><p><code>padding</code>配合<code>background-clip</code>属性，可以制作一些特殊形状。</p><h3 id=border-属性>border 属性<a hidden class=anchor aria-hidden=true href=#border-属性>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>border</span><span style=color:#f92672>:</span> <span style=color:#f92672>2px</span> <span style=color:#f92672>solid</span> <span style=color:#f92672>red</span><span style=color:#f92672>;</span>		<span style=color:#75715e>/* border-width border-style border-color */</span>
</span></span></code></pre></div><p><code>border-width</code>属性的默认值是<code>3px</code>，是为了照顾小弟<code>border-style: double</code>，你懂的。值得注意的是，<code>border-color</code>默认是跟随字体的颜色，相当于默认设置了<code>border-color: currentColor</code>一样。</p><p><strong>border-style 属性</strong></p><p><img loading=lazy src=/CSS/border-style.png alt></p><p><strong>border-image 属性</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#75715e>/* 边框图片的路径 */</span>
</span></span><span style=display:flex><span><span style=color:#f92672>border-image-source</span><span style=color:#f92672>:</span> <span style=color:#f92672>url</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;images/border.png&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 图片边框的裁剪(宽高为27）*/</span>
</span></span><span style=display:flex><span><span style=color:#f92672>border-image-slice</span><span style=color:#f92672>:</span> <span style=color:#f92672>27</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 图片边框的宽度 */</span>
</span></span><span style=display:flex><span><span style=color:#f92672>border-image-width</span><span style=color:#f92672>:</span> <span style=color:#f92672>27px</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 边框图片的平铺 */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* repeat :正常平铺 但是可能会显示不完整 */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* round: 平铺 但是保证 图片完整 */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* stretch: 拉伸显示 */</span>
</span></span><span style=display:flex><span><span style=color:#f92672>border-image-repeat</span><span style=color:#f92672>:</span> <span style=color:#f92672>stretch</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 综合属性 */</span>
</span></span><span style=display:flex><span><span style=color:#f92672>border-image</span><span style=color:#f92672>:</span> <span style=color:#f92672>url</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;images/border.png&#34;</span><span style=color:#f92672>)</span> <span style=color:#f92672>27</span><span style=color:#f92672>/</span><span style=color:#f92672>20px</span> <span style=color:#f92672>round</span><span style=color:#f92672>;</span>
</span></span></code></pre></div><p><strong>border-radius 属性</strong></p><p>CSS 属性 border-radius 允许你设置元素的外边框圆角。当使用一个半径时确定一个圆形，当使用两个半径时确定一个椭圆。这个(椭)圆与边框的交集形成圆角效果。</p><p><img loading=lazy src=/CSS/border-radius-sh.png alt></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>border-radius</span><span style=color:#f92672>:</span> <span style=color:#f92672>60px</span><span style=color:#f92672>/</span><span style=color:#f92672>120px</span><span style=color:#f92672>;</span>		<span style=color:#75715e>/* 水平半径/垂直半径 */</span>
</span></span><span style=display:flex><span><span style=color:#f92672>border-radius</span><span style=color:#f92672>:</span> <span style=color:#f92672>20px</span> <span style=color:#f92672>60px</span> <span style=color:#f92672>100px</span> <span style=color:#f92672>140px</span><span style=color:#f92672>;</span>	<span style=color:#75715e>/* 从左上开始，顺时针赋值。如果当前角没有值，取对角的值 */</span>
</span></span><span style=display:flex><span><span style=color:#f92672>border-radius</span><span style=color:#f92672>:</span> <span style=color:#f92672>60px</span><span style=color:#f92672>;</span>
</span></span></code></pre></div><p>该属性是一个 简写属性，是为了将这四个属性 border-top-left-radius、border-top-right-radius、border-bottom-right-radius，和 border-bottom-left-radius 简写为一个属性。</p><ul><li>length：定义圆形半径或椭圆的半长轴，半短轴。负值无效。</li><li>percentage：使用百分数定义圆形半径或椭圆的半长轴，半短轴。水平半轴相对于盒模型的宽度；垂直半轴相对于盒模型的高度。负值无效。</li></ul><p><a href=https://juejin.cn/post/6844903847509377037><strong>box-shadow 属性</strong></a></p><p><code>box-shadow</code> 属性用来给元素添加阴影，设置边框阴影不会改变盒子的大小，即不会影响其兄弟元素的布局，但阴影可能会覆盖其他元素。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>box-shadow</span><span style=color:#f92672>:</span> <span style=color:#f92672>inset</span> <span style=color:#f92672>15px</span> <span style=color:#f92672>21px</span> <span style=color:#f92672>48px</span> <span style=color:#f92672>-2px</span> #666<span style=color:#f92672>;</span>
</span></span></code></pre></div><p><code>box-shadow</code> 属性的阴影依次由下面这些值描述：</p><ul><li><p><code>offset-x</code> & <code>offset-y</code></p><ul><li><p>非inset：</p><ul><li>正负：阴影移动的方向。正值向右，负值向左；正值向下，负值向上。</li><li>大小：阴影的水平与垂直偏移量，即将阴影从原位置移动距离。</li></ul></li><li><p>inset：默认阴影在边框外，即阴影向外扩散。使用 <code>inset</code> 关键字会使得阴影落在盒子内部，这样看起来就像是内容被压低了。 此时阴影会在边框之内 (即使是透明边框）、背景之上、内容之下。</p><ul><li>正负：表示从哪条边出现阴影。正：左上，负：右下</li><li>大小：表示阴影在某一侧的长度。spread-radius和 inset offset 值配合起来的最大值也不能超出元素的尺寸，因为如果超出元素，那么设置这个元素就没有意义了，因为它已经看不见了</li></ul></li></ul></li><li><p><code>blur-radius</code> 模糊半径。值越大，模糊面积越大，阴影就越大越淡。 不能为负值。默认为0，此时阴影边缘锐利。例子：设置了一个20px的模糊半径，此时就会以四个方向的阴影边缘线为中心，左右扩展10px的区域，并对这部分进行高斯模糊，共同组成模糊的半径，即 20px，这样四个方向都会产生模糊效果。这里需要注意的是，阴影本质是在元素上方的，经过移动与模糊后，并且最终被裁剪掉。</p></li><li><p><code>spread-radius</code> 阴影扩展半径，可选。取正值时，阴影扩大；取负值时，阴影收缩。默认为0，此时阴影与元素同样大。扩展二字就很能说明问题了，其实它就是扩展的阴影面积的大小。一开始，阴影的面积是等于元素的尺寸的，我们的模糊半径也只能从这个阴影的边缘两侧开启高斯模糊，当我们想修改这个阴影的面积时，就用到了spread-radius属性。spread-radius表示四个方向增大或者减小的尺寸，每一侧增加的扩展半径的值。</p></li><li><p><code>color</code>：这个值可设可不设，但是因为用户代理不同，阴影的颜色的默认值也会不同，所以建议统一设置</p></li></ul><p>可以通过逗号分隔每个 <code>box-shadow</code> 元素的属性来添加多个 box-shadow。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>box-shadow</span><span style=color:#f92672>:</span> <span style=color:#f92672>0</span> <span style=color:#f92672>10px</span> <span style=color:#f92672>20px</span> <span style=color:#f92672>rgba</span><span style=color:#f92672>(</span><span style=color:#f92672>0</span><span style=color:#f92672>,</span><span style=color:#f92672>0</span><span style=color:#f92672>,</span><span style=color:#f92672>0</span><span style=color:#f92672>,</span><span style=color:#f92672>0</span>.<span style=color:#a6e22e>19</span><span style=color:#f92672>),</span> <span style=color:#f92672>0</span> <span style=color:#f92672>6px</span> <span style=color:#f92672>6px</span> <span style=color:#f92672>rgba</span><span style=color:#f92672>(</span><span style=color:#f92672>0</span><span style=color:#f92672>,</span><span style=color:#f92672>0</span><span style=color:#f92672>,</span><span style=color:#f92672>0</span><span style=color:#f92672>,</span><span style=color:#f92672>0</span>.<span style=color:#a6e22e>23</span><span style=color:#f92672>);</span>
</span></span></code></pre></div><p>为什么叫box-shadow：</p><ul><li>表明这只是对盒子的阴影，跟盒子里面的内容没有关系，并不是真正意义的单侧光源阴影，从上面阴影的生成过程就已经就可以了解到，第一步就是生成等同box的阴影，并不会考虑盒子内部是否透明，内部透明是否也能产生阴影，因为阴影会根据盒子裁剪重合的部分。 这也就是它和drop-shadow的区别，后面的应用会具体比较描述。</li><li>阴影的大小依据，是根据border-box的。对于inset，阴影也是从border内边缘扩展。</li></ul><h3 id=margin-属性>margin 属性<a hidden class=anchor aria-hidden=true href=#margin-属性>#</a></h3><p>块级元素的垂直方向会发生margin合并，存在以下三种场景：</p><ul><li>相邻兄弟元素之间<code>margin</code>合并；</li><li>父元素<code>margin-top</code>和子元素<code>margin-top</code>，父元素<code>margin-bottom</code>和子元素<code>margin-bottom</code>；</li><li>空块级元素自身的<code>margin-top</code>和<code>margin-botom</code>合并</li></ul><p>要阻止父元素和子元素<code>margin</code>合并，可以：</p><ol><li>把元素放到<code>bfc</code>中；</li><li>设置<code>border</code>或<code>padding</code>阻隔<code>margin</code>；</li><li>用内联元素（如文字）阻隔；</li><li>给父元素设定高度。</li></ol><p><code>margin</code>的百分比值跟<code>padding</code>一样，垂直方向的<code>margin</code>和水平方向上的一样都是相对于父元素宽度计算的。</p><p><code>margin: auto</code>能在块级元素设定宽高之后自动填充剩余宽高。<code>margin: auto</code>自动填充触发的前提条件是元素在对应的水平或垂直方向具有自动填充特性，显然默认情况下块级元素的高度是不具备这个条件的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>display</span><span style=color:#f92672>:</span> <span style=color:#f92672>block</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>width</span><span style=color:#f92672>:</span> <span style=color:#f92672>200px</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>margin</span><span style=color:#f92672>:</span> <span style=color:#f92672>0</span> <span style=color:#f92672>auto</span><span style=color:#f92672>;</span>
</span></span></code></pre></div><p><code>auto</code>的特性是，如果两侧都是<code>auto</code>，则两侧均分剩余宽度；如果一侧<code>margin</code>是固定的，另一侧是<code>auto</code>，则这一侧<code>auto</code>为剩余宽度。</p><p>垂直方向的<code>margin</code>也能实现垂直居中，但是需要元素在垂直方向具有自动填充特性，而这个特性可以利用<code>position</code>实现：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>position</span><span style=color:#f92672>:</span> <span style=color:#f92672>absolute</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>left</span><span style=color:#f92672>:</span> <span style=color:#f92672>0</span><span style=color:#f92672>;</span> <span style=color:#f92672>right</span><span style=color:#f92672>:</span> <span style=color:#f92672>0</span><span style=color:#f92672>;</span> <span style=color:#f92672>top</span><span style=color:#f92672>:</span> <span style=color:#f92672>0</span><span style=color:#f92672>;</span> <span style=color:#f92672>bottom</span><span style=color:#f92672>:</span> <span style=color:#f92672>0</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>width</span><span style=color:#f92672>:</span> <span style=color:#f92672>200px</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>height</span><span style=color:#f92672>:</span> <span style=color:#f92672>200px</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>margin</span><span style=color:#f92672>:</span> <span style=color:#f92672>auto</span><span style=color:#f92672>;</span>
</span></span></code></pre></div><h4 id=margin-为负值httpswwwcnblogscomxiaohuochaip5314289html><a href=https://www.cnblogs.com/xiaohuochai/p/5314289.html>margin 为负值</a><a hidden class=anchor aria-hidden=true href=#margin-为负值httpswwwcnblogscomxiaohuochaip5314289html>#</a></h4><p><strong>表现</strong></p><p><img loading=lazy src=/CSS/908704-20160312185433163-1825213822.gif alt></p><p>虽然margin可以应用到所有元素，但display属性不同时，表现也不同：</p><ol><li><p><a href=https://www.cnblogs.com/theWayToAce/p/5269721.html>block元素可以使用四个方向的margin值</a></p><ul><li>当static元素的margin-top/margin-left被赋予负值时，元素将被拉进指定的方向。设置margin-bottom/right为负数，元素并不会如你所想的那样向下/右移动，而是将后续的元素拖拉进来，覆盖本来的元素。</li><li>在元素是流布局的时候，即元素<code>width</code>是默认的<code>auto</code>并且可以撑满一行的时候。通过设置<code>margin</code>为负值，能改变元素水平方向的尺寸，值为 width + 2 * |margin| 。原理是css权威指南上面提过的，就是无论你margin，paddding怎么变，最终都要等于父元素的宽高，比如父元素300px，子元素撑满父元素也是300px，此时子元素你设置margin-left: -100px，因为总宽度子元素总宽度要等与父元素300px,此时子元素要多宽加上-100才等于父元素的300px？说明子元素只有变为400px，400+（-100）才能等于父元素宽度</li></ul></li><li><p>inline元素使用上下方向的margin值无效</p></li><li><p>inline-block使用上下方向的margin负值看上去无效</p><p>注意：inline-block使用上下方向的margin负值只是看上去无效，这与其默认的vertical-align:baseline有关系，当垂直对齐的属性值为其他值时，则会显示不同的视觉效果</p></li></ol><p><strong>定位</strong></p><ol><li><p>定位元素(position不为static)覆盖其他元素的背景和内容</p></li><li><p>将relative属性值应用于inline元素，由于无法改变其行内元素的本质，所以其上下margin依然存在问题</p></li></ol><p><strong>重叠</strong></p><p>margin负值并不总是后面元素覆盖前面元素，它与元素display属性有关系</p><ol><li><p>两个block元素重叠时，后面元素可以覆盖前面元素的背景，但无法覆盖其内容</p></li><li><p>当两个inline元素，或两个line-block元素，或inline与inline-block元素重叠时，后面元素可以覆盖前面元素的背景和内容</p></li><li><p>当inline元素(或inline-block元素)与block元素重叠时，inline元素(或inline-block元素)覆盖block元素的背景，而内容的话， 后面的元素覆盖前面的元素</p></li></ol><p>在普通流布局中，浏览器将页面布局分为内容和背景，内容的层叠显示始终高于背景。block元素分为内容和背景，而inline元素或inline-block元素，它本身就是内容(包括其背景等样式设置)</p><p><strong>浮动</strong></p><p>　1. block元素与浮动元素重叠时，其边框和背景在该浮动元素之下显示，而内容在浮动元素之上显示
　1. inline或inline-block元素与浮动元素重叠时，其边框、背景和内容都在该浮动元素之上显示</p><h3 id=box-sizing-属性>box-sizing 属性<a hidden class=anchor aria-hidden=true href=#box-sizing-属性>#</a></h3><p>允许开发人员指定盒子宽度和高度的计算方式。</p><ul><li><p>外加模式：此时设置的 width 和 height 是内容区域的宽高。即标准盒模型。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>box-sizing</span><span style=color:#f92672>:</span> <span style=color:#f92672>content-box</span><span style=color:#f92672>;</span>
</span></span></code></pre></div></li><li><p>内减模式：此时设置的 width 和 height 是包含 border 在内的盒子的总宽高。即 IE 盒模型。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>box-sizing</span><span style=color:#f92672>:</span> <span style=color:#f92672>border-box</span><span style=color:#f92672>;</span>
</span></span></code></pre></div></li></ul><h3 id=display-属性>display 属性<a hidden class=anchor aria-hidden=true href=#display-属性>#</a></h3><ul><li><code>display: none;</code>：<a href=https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/display>表示该元素和它的子元素不会被渲染</a>。会从文档流移除该元素及其子元素，仿佛它们是不存在的。它们占据的空间会释放出来。</li><li><code>display: inline;</code>：产生行内元素，没有自己的高度和宽度，由容器决定，前后不会产生换行。</li><li><code>display: block;</code>：产生块级元素，会占据一行，占满容器的宽度。</li><li><code>display: list-item;</code>：将元素渲染为一个列表项，行首产生一个列表标记，可以用<code>list-style</code>定制样式。</li><li><code>display: inline-block;</code>：产生行内的块级元素，有自己的高和宽，但是前后不会产生换行。</li></ul><p><strong>表格相关的设置</strong></p><ul><li><code>table</code> 对应<code>&lt;table></code>元素</li><li><code>table-header-group</code> 对应<code>&lt;thead></code></li><li><code>table-row</code> 对应<code>&lt;tr></code></li><li><code>table-cell</code> 对应<code>&lt;td></code></li><li><code>table-row-group</code> 对应<code>&lt;tbody></code></li><li><code>table-footer-group</code> 对应<code>&lt;tfoot></code></li><li><code>table-column-group</code> 对应<code>&lt;colgroup></code></li><li><code>table-column</code> 对应<code>&lt;col></code></li><li><code>table-caption</code> 对应<code>&lt;caption></code></li><li><code>inline-table</code> 将一个表格渲染具有<code>inline-block</code>的形式</li></ul><h3 id=overflow-属性>overflow 属性<a hidden class=anchor aria-hidden=true href=#overflow-属性>#</a></h3><p><code>overflow</code>属性指定如果元素的大小超出容器时的行为。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>overflow</span><span style=color:#f92672>:</span> <span style=color:#f92672>visible</span><span style=color:#f92672>;</span>
</span></span></code></pre></div><ul><li><code>visible</code>：默认值。多余的内容不剪切也不添加滚动条，会全部显示出来。</li><li><code>hidden</code>：不显示超过对象尺寸的内容。</li><li><code>auto</code>：如果内容不超出，则不显示滚动条；如果内容超出，则显示滚动条。</li><li><code>scroll</code>：Windows 平台下，无论内容是否超出，总是显示滚动条。Mac 平台下，和 <code>auto</code> 属性相同。</li></ul><h3 id=滚动捕捉>滚动捕捉<a hidden class=anchor aria-hidden=true href=#滚动捕捉>#</a></h3><p>在 Web 布局中，时常会碰到内容溢出容器的现状，如果 <code>overflow</code> 设置为 <code>auto</code> 或 <code>scroll</code> 时容器会出现水平或垂直滚动条。</p><p>为了给用户提供更好的滚动体验，CSS 提供了一些优化滚动体验的 CSS 特性，其中滚动捕捉就是其中之一。CSS 的滚动捕捉有点类似于 Flexbox 和 Grid 布局的特性，分类为用于滚动容器的属性和滚动项目（定位子项，滚动容器子元素）的属性：</p><table><tr><td rowspan=3>滚动容器</td><td><a href=https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-snap-type>scroll-snap-type</a></td></tr><tr><td>scroll-padding</td></tr><tr><td>scroll-snap-stop</td></tr><tr><td rowspan=2>滚动项目</td><td>scroll-margin</td></tr><tr><td>scroll-snap-align</td></tr></table><p>有了滚动捕捉特性，我们不需要依赖任何 JavaScript 库或脚本，就可以实现<a href=https://codepen.io/airen/full/mdRpboo>横向滚动海报时，图片的中心位置和容器中心位置对齐</a>。</p><p>关键代码就下面这几行：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>container</span> {
</span></span><span style=display:flex><span>  scroll-behavior: <span style=color:#66d9ef>smooth</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>overflow-x</span>: <span style=color:#66d9ef>auto</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>-webkit-</span>overflow-scrolling: touch;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>scroll-snap-type</span>: x <span style=color:#66d9ef>mandatory</span>;
</span></span><span style=display:flex><span>  scroll-padding: <span style=color:#ae81ff>20</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>img</span> {
</span></span><span style=display:flex><span>  scroll-snap-align: <span style=color:#66d9ef>center</span>;
</span></span><span style=display:flex><span>  scroll-snap-stop: <span style=color:#66d9ef>always</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=cliphttpswwwzhangxinxucomwordpress201104css-clip-rect><a href=https://www.zhangxinxu.com/wordpress/2011/04/css-clip-rect/>clip</a><a hidden class=anchor aria-hidden=true href=#cliphttpswwwzhangxinxucomwordpress201104css-clip-rect>#</a></h3><p><code>clip</code>规则指定元素超出容器大小时，具体显示哪个部分。它只对绝对定位（absolute）和固定定位（fixed）的元素有效。<code>top right bottom left</code>分别指最终剪裁可见区域的上边，右边，下边与左边。而所有的数值都表示位置，且是相对于原始元素的左上角而言的。</p><pre tabindex=0><code>rect(top right bottom left)
rect(30px 200px 200px 20px)
</code></pre><p>表示的含义就是：最终剪裁的矩形的上边距离原始元素的上边缘30像素；剪裁矩形的右边缘距离原元素左边缘的距离是200像素；剪裁矩形的下边缘距离原元素顶部的距离为200像素；剪裁矩形的左边缘距离原元素左边缘的距离时20像素。</p><p>该规则已经被废除，但是浏览器还是普遍支持。</p><p><strong>clip:rect矩形剪裁的一些应用介绍</strong></p><p>（1） 可用性隐藏</p><p>根据上面对top right bottom left的释义，如果left >= right或者bottom &lt;= top，则元素会被完全裁掉而不可见，即“隐藏”。通过这种方式隐藏的元素是可以被屏幕阅读器等辅助设备识别的，从而提高了页面的可用性。</p><p>例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span>clip: rect(1px 1px 1px 1px); /*left = right, bottom = top*/
</span></span></code></pre></div><p>（2）img标签下的CSS Sprite定位</p><p>为了节约图片资源，我们经常会把小图片整合到一张图片上，称为图片合并技术，国外称为CSS Sprite，含“精灵”之意。然后利用元素区域外<code>background</code>内容不可见的特性配合<code>background-position</code>定位实现图片的精确显示。</p><p>显然，<code>background-position</code>下的CSS Sprite定位也不可能适用于各种情况。</p><p>（3）图片剪裁的预览效果</p><h3 id=蒙层和剪切>蒙层和剪切<a hidden class=anchor aria-hidden=true href=#蒙层和剪切>#</a></h3><p>如果你对设计或设计软件较为熟悉的话，对于蒙层和剪切不会感到陌生。设计师在做一些设计稿的时候，时常也会用到蒙层和剪切的能力。随着 CSS 的发展，在 CSS 的世界中也有了这两个特性，它们在 W3C 的 《<a href=https://www.w3.org/TR/css-masking-1/><strong>CSS Masking Module Level 1</strong></a>》规范中定义，主要的作用如下图所示：</p><p><img loading=lazy src=/CSS/mask_clip-path.image alt></p><p>蒙层和剪切对应的 CSS 属性就是 <code>mask</code> 和 <code>clip-path</code> 。</p><h4 id=mask-属性>mask 属性<a hidden class=anchor aria-hidden=true href=#mask-属性>#</a></h4><p><code>mask</code> 是一个简写属性，它的使用规则和 <code>background</code> 非常的相似。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>h1</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>mask-image</span>: url(<span style=color:#e6db74>mask.png</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>mask-image</code> 即蒙层图。</p><p>而且我们还可以借助 <code>mask</code> 的合成能力，让多个蒙层做合成运算：</p><p><img loading=lazy src=/CSS/mask.image alt></p><h4 id=clip-path-属性>clip-path 属性<a hidden class=anchor aria-hidden=true href=#clip-path-属性>#</a></h4><p><code>clip-path</code>是<code>clip</code>规则的继承者，用来剪切元素的大小。它对所有定位方式都适用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>clip</span><span style=color:#f92672>:</span> <span style=color:#f92672>rect</span><span style=color:#f92672>(</span><span style=color:#f92672>110px</span><span style=color:#f92672>,</span> <span style=color:#f92672>160px</span><span style=color:#f92672>,</span> <span style=color:#f92672>170px</span><span style=color:#f92672>,</span> <span style=color:#f92672>60px</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 等同于 */</span>
</span></span><span style=display:flex><span><span style=color:#f92672>clip-path</span><span style=color:#f92672>:</span> <span style=color:#f92672>inset</span><span style=color:#f92672>(</span><span style=color:#f92672>10px</span> <span style=color:#f92672>20px</span> <span style=color:#f92672>30px</span> <span style=color:#f92672>40px</span><span style=color:#f92672>);</span>
</span></span></code></pre></div><p><code>clip-path</code>支持多种路径定义方式。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>clip-me</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* referencing path from an inline SVG &lt;clipPath&gt; */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>clip-path</span>: url(<span style=color:#e6db74>#c1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* referencing path from external SVG */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>clip-path</span>: url(<span style=color:#e6db74>path.svg#c1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* polygon */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>clip-path</span>: polygon(<span style=color:#ae81ff>5</span><span style=color:#66d9ef>%</span> <span style=color:#ae81ff>5</span><span style=color:#66d9ef>%</span>, <span style=color:#ae81ff>100</span><span style=color:#66d9ef>%</span> <span style=color:#ae81ff>0</span><span style=color:#66d9ef>%</span>, <span style=color:#ae81ff>100</span><span style=color:#66d9ef>%</span> <span style=color:#ae81ff>75</span><span style=color:#66d9ef>%</span>, <span style=color:#ae81ff>75</span><span style=color:#66d9ef>%</span> <span style=color:#ae81ff>75</span><span style=color:#66d9ef>%</span>, <span style=color:#ae81ff>75</span><span style=color:#66d9ef>%</span> <span style=color:#ae81ff>100</span><span style=color:#66d9ef>%</span>, <span style=color:#ae81ff>50</span><span style=color:#66d9ef>%</span> <span style=color:#ae81ff>75</span><span style=color:#66d9ef>%</span>, <span style=color:#ae81ff>0</span><span style=color:#66d9ef>%</span> <span style=color:#ae81ff>75</span><span style=color:#66d9ef>%</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* circle */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>clip-path</span>: circle(<span style=color:#ae81ff>30</span><span style=color:#66d9ef>px</span> at <span style=color:#ae81ff>35</span><span style=color:#66d9ef>px</span> <span style=color:#ae81ff>35</span><span style=color:#66d9ef>px</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* ellipse */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>clip-path</span>: ellipse(<span style=color:#ae81ff>65</span><span style=color:#66d9ef>px</span> <span style=color:#ae81ff>30</span><span style=color:#66d9ef>px</span> at <span style=color:#ae81ff>125</span><span style=color:#66d9ef>px</span> <span style=color:#ae81ff>40</span><span style=color:#66d9ef>px</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* inset-rectangle() may replace inset() ? */</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* rectangle() coming in SVG 2 */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* rounded corners... not sure if a thing anymore */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>clip-path</span>: inset(<span style=color:#ae81ff>10</span><span style=color:#66d9ef>%</span> <span style=color:#ae81ff>10</span><span style=color:#66d9ef>%</span> <span style=color:#ae81ff>10</span><span style=color:#66d9ef>%</span> <span style=color:#ae81ff>10</span><span style=color:#66d9ef>%</span> <span style=color:#66d9ef>round</span> <span style=color:#ae81ff>20</span><span style=color:#66d9ef>%</span>, <span style=color:#ae81ff>20</span><span style=color:#66d9ef>%</span>);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=opacity>opacity<a hidden class=anchor aria-hidden=true href=#opacity>#</a></h3><p>CSS 里的 <code>opacity</code> 属性用来设置元素的透明度。透明度会应用到元素内的所有内容，不论是图片，还是文本，或是背景色。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>opacity</span><span style=color:#f92672>:</span> <span style=color:#f92672>0</span>.<span style=color:#a6e22e>3</span><span style=color:#f92672>;</span>
</span></span></code></pre></div><ul><li>属性值为 1 代表完全不透明。</li><li>属性值为 0.5 代表半透明。</li><li>属性值为 0 代表完全透明。</li></ul><h3 id=object-fit>object-fit<a hidden class=anchor aria-hidden=true href=#object-fit>#</a></h3><p><code>object-fit</code>命令指定一个元素的大小应该如何适应它的容器，主要用于图像。它可以取以下的值。</p><ul><li>fill：容器的宽度和高度就是元素的宽度和高度，会截去溢出的部分。</li><li>contain：元素会填满容器，不会改变长宽比，可能会有溢出。</li><li>cover：元素会填满容器，可能会改变长宽比，但不会有溢出。</li><li>none：元素不会改变的大小，具体的展示效果由默认算法决定</li><li>scale-down：展示效果会选择<code>none</code>或<code>contain</code>之中，对象尺寸较小的一个</li><li>inherit：使用父元素的值</li><li>initial：使用浏览器的默认值</li><li>unset：这个属性是<code>inherit</code>和<code>initial</code>的结合，如果该元素继承父元素，就采用<code>inherit</code>，否则采用<code>initial</code></li></ul><h3 id=object-position>object-position<a hidden class=anchor aria-hidden=true href=#object-position>#</a></h3><p>object-position设置容器中的对象（通常是图片）的垂直和水平位置，与background-position设置背景图片的写法相同。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>img</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>height</span>: <span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>width</span>: <span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>object-fit</span>: <span style=color:#66d9ef>contain</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>object-position</span>: <span style=color:#66d9ef>top</span> <span style=color:#ae81ff>70</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=outline>outline<a hidden class=anchor aria-hidden=true href=#outline>#</a></h3><p><code>outline</code> 属性是在一条声明中设置 <code>outline-style</code>, <code>outline-width</code> 和 <code>outline-color</code>轮廓属性的简写属性。</p><p>border 和 outline 很类似，但outline不占据空间，绘制于元素内容周围。根据规范，outline通常是矩形，但也可以是非矩形的。</p><h3 id=等比缩放httpscodepenioairenfullexwjezr><a href=https://codepen.io/airen/full/ExWjeZr>等比缩放</a><a hidden class=anchor aria-hidden=true href=#等比缩放httpscodepenioairenfullexwjezr>#</a></h3><p>CSS 等比缩放一般指的是 “容器高度按比例根据宽度改变”，很多时候也称为宽高比或纵宽比。 众所周知，我们开发 Web 页面要面对的终端更复杂的了，而这些终端的宽高比都不一样。常见的比例有：</p><p><img loading=lazy src=/CSS/%e7%bb%88%e7%ab%af%e6%af%94%e4%be%8b.png alt></p><p>CSS 在还没有 <code>_aspect-ratio_</code> 之前，常使用一些 Hacck 手段来实现实类似的效果，即使用 <code>padding-top</code> 或 <code>padding-bottom</code> 来实现：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>aspectratio-container</span>&gt; 
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>aspectratio-content</span>&gt;&lt;/<span style=color:#f92672>aspectratio-content</span>&gt; 
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>aspectratio-container</span>&gt; 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&lt;<span style=color:#f92672>style</span>&gt;
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>aspectratio-container</span> { 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>width</span>: <span style=color:#ae81ff>50</span><span style=color:#66d9ef>vmin</span>; <span style=color:#75715e>/* 用户根据自己需要设置相应的值 */</span> 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* 布局方案可以调整 */</span> 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>display</span>: <span style=color:#66d9ef>flex</span>; 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>justify-content</span>: <span style=color:#66d9ef>center</span>; 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>align-items</span>: <span style=color:#66d9ef>center</span>; 
</span></span><span style=display:flex><span>    } 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* 用来撑开aspectratio-container高度 */</span> 
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>aspectratio-container</span>::<span style=color:#a6e22e>after</span> { 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>content</span>: <span style=color:#e6db74>&#34;&#34;</span>; 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>width</span>: <span style=color:#ae81ff>1</span><span style=color:#66d9ef>px</span>; 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>padding-bottom</span>: <span style=color:#ae81ff>56.25</span><span style=color:#66d9ef>%</span>; 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*元素的宽高比*/</span> 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>margin</span>: <span style=color:#ae81ff>-1</span><span style=color:#66d9ef>px</span>; 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>z-index</span>: <span style=color:#ae81ff>-1</span>; 
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>style</span>&gt;  
</span></span></code></pre></div><p>有了 CSS 自定义属性之后，可以结合 <code>calc()</code> 函数来实现容器等比缩放的效果：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>container</span> {
</span></span><span style=display:flex><span>    --ratio: <span style=color:#ae81ff>16</span><span style=color:#f92672>/</span><span style=color:#ae81ff>9</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>height</span>: calc(<span style=color:#a6e22e>var</span>(<span style=color:#f92672>--</span>width) <span style=color:#f92672>*</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>/</span> (<span style=color:#a6e22e>var</span>(<span style=color:#f92672>--</span>ratio)));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>width</span>: <span style=color:#ae81ff>100</span><span style=color:#66d9ef>%</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>虽然比<code>padding-top</code> 这样的Hack 手段简单，但相比原生的<code>aspect-ratio</code>还是要复杂的多。即:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>container</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>width</span>: <span style=color:#ae81ff>100</span><span style=color:#66d9ef>%</span>;
</span></span><span style=display:flex><span>    aspect-ratio: <span style=color:#ae81ff>16</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>9</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>还可以通过 <code>@media</code> 让元素在不同的终端上按不同的比例进行缩放：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scss data-lang=scss><span style=display:flex><span><span style=color:#a6e22e>.transition-it</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>aspect-ratio</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>/</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>transition</span><span style=color:#f92672>:</span> aspect-ratio <span style=color:#ae81ff>.5</span><span style=color:#66d9ef>s</span> ease;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>@media</span> (<span style=color:#f92672>or</span>ientation<span style=color:#f92672>:</span> landscape) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>&amp;</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>aspect-ratio</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>16</span><span style=color:#f92672>/</span><span style=color:#ae81ff>9</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=逻辑属性httpsjuejincnpost6974239153269506084heading-3><a href=https://juejin.cn/post/6974239153269506084#heading-3>逻辑属性</a><a hidden class=anchor aria-hidden=true href=#逻辑属性httpsjuejincnpost6974239153269506084heading-3>#</a></h3><p>为了让 Web 开发者能更好的针对不同的阅读模式提供不同的排版效果，在CSS新增逻辑属性。有了逻辑属性之后，以前很多概念都有所变化了。比如我们以前熟悉的坐标轴，<code>x</code> 轴和 <code>y</code> 轴就变成了 <code>inline</code> 轴 和 <code>block</code> 轴，而且这两个轴也会随着书写模式做出调整：</p><p><img loading=lazy src=/CSS/%e4%b9%a6%e5%86%99%e6%a8%a1%e5%bc%8f.png alt></p><p>除此之外，我们熟悉的 CSS 盒模型也分物理盒模型和逻辑盒模型：</p><p><img loading=lazy src=/CSS/%e9%80%bb%e8%be%91%e7%9b%92%e6%a8%a1%e5%9e%8b.png alt></p><p>你可能感知到了，只要是以前带有 <code>top</code>、<code>right</code> 、<code>bottom</code> 和 <code>left</code> 方向的物理属性都有了相应的 <code>inline-start</code> 、 <code>inline-end</code> 、<code>block-start</code> 和 <code>block-end</code> 的逻辑属性</p><p><img loading=lazy src=/CSS/%e9%80%bb%e8%be%91%e7%9b%92%e6%a8%a1%e5%9e%8b2.png alt></p><h3 id=内容可见性>内容可见性<a hidden class=anchor aria-hidden=true href=#内容可见性>#</a></h3><p>CSS 内容可见性，说要是指 <code>content-visibilit</code> 和 <code>contain-intrinsic-size</code> 两个属性，目前隶属于 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.w3.org%2FTR%2Fcss-contain-2%2F%23content-visibility"><strong>W3C 的 CSS Containment Module Level 2 模块</strong></a>，主要功能是可以用来提高页面的渲染性能。</p><p>一般来说，大多数Web应用都有复杂的UI元素，而且有的内容会在设备可视区域之外（内容超出了用户浏览器可视区域），比如下图中红色区域就在手机设备屏幕可视区域之外：</p><p><img loading=lazy src=/CSS/%e5%86%85%e5%ae%b9%e5%8f%af%e8%a7%81%e6%80%a7.png alt></p><p>在这种场合下，我们可以使用CSS的 <code>content-visibility</code> 来跳过屏幕外的内容渲染。也就是说，如果你有大量的离屏内容（Off-screen Content），这将会大幅减少页面渲染时间。</p><p>使用了 CSS 的 <code>content-visibility</code> 属性，浏览器的渲染过程就变得更加容易。本质上，这个属性 改变了一个元素的可见性，并管理其渲染状态。</p><p>而 <code>contain-intrinsic-size</code> 属性控制由 <code>content-visibility</code> 指定的元素的自然尺寸。它的意思是，<code>content-visibility</code> 会将分配给它的元素的高度（<code>height</code>）视为 <code>0</code>，浏览器在渲染之前会将这个元素的高度变为 <code>0</code>，从而使我们的页面高度和滚动变得混乱。但如果已经为元素或其子元素显式设置了高度，那这种行为就会被覆盖。如果你的元素中没显式设置高度，并且因为显式设置 <code>height</code>可能会带来一定的副作用而没设置，那么我们可以使用<code>contain-intrinsic-size</code>来确保元素的正确渲染，同时也保留延迟渲染的好处。</p><p>换句话说，<code>contain-intrinsic-size</code> 和 <code>content-visibility</code> 是一般是形影不离的出现：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>section</span> {
</span></span><span style=display:flex><span>  content-visibility: <span style=color:#66d9ef>auto</span>;
</span></span><span style=display:flex><span>  contain-intrinsic-size: <span style=color:#ae81ff>1000</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=内在尺寸>内在尺寸<a hidden class=anchor aria-hidden=true href=#内在尺寸>#</a></h3><p>如果你使用浏览器开发者工具审查代码时，将鼠标放到一个 <code>&lt;img></code> 标签上，你会看到类似下图这样的：</p><p><img loading=lazy src=/CSS/%e5%9b%be%e7%89%87%e5%86%85%e5%9c%a8%e5%b0%ba%e5%af%b8.png alt></p><p><code>&lt;img></code> 的 src 路径上浮出来的图片底下有一行对图像的尺寸的描述，即252 x 158 px (intrinsic: 800 x 533 px) ，其实现这表述图片尺寸中两个重要信息：</p><ul><li>外在尺寸： <code>252 x 158 px</code> ，开发者给 <code>img</code> 设置的尺寸</li><li>内在尺寸： <code>800 x 533 px</code> ，图片原始尺寸</li></ul><p>其实在 CSS 中给一个元素框设置大小时，有的是根据<strong>元素框内在的内容来决定，有的是根据上下文来决定的</strong>。根据该特性，CSS的尺寸也分为内部(内在)尺寸和外部（外在）尺寸。</p><ul><li>内部尺寸：指的是元素根据自身的内容（包括其后代元素）决定大小，而不需要考虑其上下文；而其中 <code>min-content</code> 、 <code>max-content</code> 和 <code>fit-content</code> 能根据元素内容来决定元素大小，因此它们统称为内部尺寸。</li><li>外部尺寸：指的是元素不会考虑自身的内容，而是根据上下文来决定大小。最为典型的案例，就是 <code>width</code> 、<code>min-width</code> 、<code>max-width</code> 等属性使用了 <code>%</code> 单位的值。</li></ul><p>通地一个简单的示例来向大家演示 CSS 内在尺寸的特性，即 <code>min-content</code> 、<code>max-content</code> 和 <code>fit-content</code> 的特性。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>h1</span>&gt;CSS is Awesome&lt;/<span style=color:#f92672>h1</span>&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&lt;<span style=color:#f92672>style</span>&gt;
</span></span><span style=display:flex><span>  <span style=color:#f92672>h1</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>width</span>: <span style=color:#66d9ef>auto</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>style</span>&gt;  
</span></span></code></pre></div><p><img loading=lazy src=/CSS/%e5%86%85%e9%83%a8%e5%b0%ba%e5%af%b8.png alt></p><ul><li>从上图中不难发现，<code>width</code> 取值为 <code>min-content</code> 时，<code>h1</code> 的宽度始终是单词“Awesome”长度（大约是<code>144.52px</code>）。它的宽度和容器宽度变化并无任何关系，但它受排版内相关的属性的影响，比如<code>font-size</code>、<code>font-family</code> 等。</li><li>当<code>h1</code> 的 <code>width</code> 取值为 <code>max-content</code> 时，它的宽度是<code>h1</code> 所在行所有内容的宽度。</li><li>简单地说，<code>fit-content</code> 相当于 <code>min-content</code> 和 <code>max-content</code>，其 取值:<ul><li>如果元素的可用空间(Available)充足，<code>fit-content</code> 将使 用 <code>max-content</code></li><li>如果元素的可用空间(Available)不够充足，比 <code>max-content</code> 小点，那就是用可用空间的值，不会导致内容溢出</li><li>如果元素的可用空间(Available)很小，比 <code>min-content</code>还小,那就使用 <code>min-content</code></li><li><img loading=lazy src=/CSS/fit-content.png alt></li></ul></li></ul><p><code>min-content</code>、<code>max-content</code> 和 <code>fit-content</code> 被称之个内在尺寸，它可以运用于设置容器尺寸的属性上，比如<code>width</code> 、<code>height</code> 以及 <code>inline-size</code> 和 <code>block-size</code> 等。但有些属性上使用的话则会无效：</p><ul><li><code>min-content</code>、<code>max-content</code> 和 <code>fit-content</code> 用于 <code>flex-basis</code> 无效</li><li><code>fit-content</code> 用于设置网格轨道尺寸的属性上无效</li><li>网格项目或Flex项目上显式设置 <code>width:fit-content</code>也无效,因为它们的默认宽度是 <code>min-content</code></li><li>最好不要在 <code>min-width</code> 或 <code>max-width</code> 上使用 <code>fit-content</code>，易造成混乱，建议在 <code>width</code> 上使用 <code>fit-content</code></li></ul><h2 id=格式化上下文>格式化上下文<a hidden class=anchor aria-hidden=true href=#格式化上下文>#</a></h2><p>格式化上下文（Formatting Context）是 CSS2.1 规范中的一个概念，规定了渲染区域内部的子元素是如何排版以及相互作用的。</p><p>不同类型的盒子有不同格式化上下文：</p><ul><li>BFC (Block Formatting Context) 块级格式化上下文；</li><li>IFC (Inline Formatting Context) 行内格式化上下文；</li><li>FFC (Flex Formatting Context) 弹性格式化上下文；</li><li>GFC (Grid Formatting Context) 格栅格式化上下文；</li></ul><h3 id=bfc>BFC<a hidden class=anchor aria-hidden=true href=#bfc>#</a></h3><p>块格式化上下文，它是一个独立的渲染区域，只有块级盒子参与，它规定了内部的块级盒子如何布局，并且与这个区域外部毫不相干。BFC 就好像一个结界，结界里面的东西不能影响外面的布局，也就是说，BFC的子元素再翻江倒海，都不会影响外面的元素。</p><p><img loading=lazy src=/CSS/BFC.png alt></p><h4 id=bfc-渲染规则>BFC 渲染规则<a hidden class=anchor aria-hidden=true href=#bfc-渲染规则>#</a></h4><ul><li>内部的盒子会在垂直方向，一个接一个地放置；</li><li>盒子垂直方向的距离由 margin 决定，属于同一个 BFC 的两个相邻盒子的 margin 会发生重叠；直接子孙元素与该BFC上下边界<code>margin</code>不能折叠，保证了BFC内部的元素不会影响外部的元素。两个上下相邻的BFC之间折不折叠要看具体情况，如<code>display: inline-block</code>和<code>float: left</code>不会折叠，而<code>overflow: hidden</code>则会折叠。</li><li>每个元素的 margin 的左边，与包含块 border 的左边相接触(对于从左往右的格式化，否则相反)，即使存在浮动也是如此；除非子盒子形成了一个新的BFC。<ul><li>包含块未必就是父级元素。对于<code>position: absolute</code>来说，包含块是指第一个<code>positoin</code>不为<code>static</code>的祖先元素。</li><li>BFC中的盒子应该与其自身的包含块相接触，而非与BFC盒子本身相接触。</li><li>BFC中的盒子是与其包含块的 <code>left edge</code> 相接触，而不是包含块的 <code>left-border</code> 相接触。<code>left edge</code> 正确的翻译为左边缘。左边缘可能是<code>content box</code>的左边缘（非绝对定位如<code>position: relative</code> <code>float: left</code>），也可能是<code>padding box</code>的左边缘（如绝对定位<code>position: absolute</code> <code>position: fixed</code>）。</li></ul></li><li>BFC 的区域不会与 float 盒子重叠；</li><li>BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。它规定了BFC子元素无论<code>margin-top: -10000px</code> <code>float: left</code> 等都不会影响到BFC外部的元素的布局。</li><li>计算 BFC 的高度时，浮动元素也参与计算。</li></ul><h4 id=创建-bfc>创建 BFC<a hidden class=anchor aria-hidden=true href=#创建-bfc>#</a></h4><ul><li>根元素：html</li><li>非溢出的可见元素：overflow 值不为 visible 的元素(hidden、auto、scroll)</li><li>设置浮动：float 属性不为 none</li><li>设置定位：position 为 absolute 或 fixed</li><li>定义成块级的非块级元素：display: inline-block/table-cell/table-caption/flex/inline-flex/grid/inline-grid</li><li>display为flex、grid、flow-root的元素(flow-root为专门设置BFC的属性值)</li></ul><p>BFC包含创建该上下文元素的所有子元素，但不包括创建了新BFC的子元素的内部元素。</p><h4 id=bfc-应用场景>BFC 应用场景<a hidden class=anchor aria-hidden=true href=#bfc-应用场景>#</a></h4><p><strong>自适应两栏布局</strong></p><p>应用原理：BFC 的区域不会和浮动区域重叠，所以就可以把侧边栏固定宽度且左浮动，而对右侧内容触发 BFC，使得它的宽度自适应该行剩余宽度。</p><p><strong>清除内部浮动</strong></p><p>浮动造成的问题就是父元素高度坍塌，所以清除浮动需要解决的问题就是让父元素的高度恢复正常。而用 BFC 清除浮动的原理就是：计算 BFC 的高度时，浮动元素也参与计算。只要触发父元素的 BFC 即可。</p><p><strong>防止垂直 margin 合并</strong></p><p>BFC 渲染原理之一：同一个 BFC 下的垂直 margin 会发生合并。所以如果让 2 个元素不在同一个 BFC 中即可阻止垂直 margin 合并。</p><h3 id=ifc>IFC<a hidden class=anchor aria-hidden=true href=#ifc>#</a></h3><p>IFC 的形成条件非常简单，块级元素中仅包含内联级别元素，需要注意的是当IFC中有块级元素插入时，会产生两个匿名块将父元素分割开来，产生两个 IFC。</p><p><img loading=lazy src=/CSS/IFC.png alt></p><h4 id=ifc-渲染规则>IFC 渲染规则<a hidden class=anchor aria-hidden=true href=#ifc-渲染规则>#</a></h4><ul><li>子元素在水平方向上一个接一个排列，在垂直方向上将以容器顶部开始向下排列；</li><li>节点无法声明宽高，其中 margin 和 padding 在水平方向有效在垂直方向无效；</li><li>节点在垂直方向上以不同形式对齐；</li><li>能把在一行上的框都完全包含进去的一个矩形区域，被称为该行的线盒（line box）。线盒的宽度是由包含块（containing box）和与其中的浮动来决定；</li><li>IFC 中的 line box 一般左右边贴紧其包含块，但 float 元素会优先排列。</li><li>IFC 中的 line box 高度由 line-height 计算规则来确定，同个 IFC 下的多个 line box 高度可能会不同；</li><li>当内联级盒子的总宽度少于包含它们的 line box 时，其水平渲染规则由 text-align 属性值来决定；</li><li>当一个内联盒子超过父元素的宽度时，它会被分割成多盒子，这些盒子分布在多个 line box 中。如果子元素未设置强制换行的情况下，inline box 将不可被分割，将会溢出父元素。</li></ul><h4 id=ifc-应用场景>IFC 应用场景<a hidden class=anchor aria-hidden=true href=#ifc-应用场景>#</a></h4><p><strong>水平居中</strong></p><p>当一个块要在环境中水平居中时，设置其为 inline-block 则会在外层产生 IFC，通过 text-align 则可以使其水平居中。</p><p><strong>垂直居中</strong></p><p>创建一个 IFC，用其中一个元素撑开父元素的高度，然后设置其 vertical-align: middle，其他行内元素则可以在此父元素下垂直居中。</p><h2 id=流的破坏>流的破坏<a hidden class=anchor aria-hidden=true href=#流的破坏>#</a></h2><h3 id=float-属性>float 属性<a hidden class=anchor aria-hidden=true href=#float-属性>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>float</span><span style=color:#f92672>:</span> <span style=color:#f92672>left</span><span style=color:#f92672>;</span>
</span></span></code></pre></div><p><strong>特性</strong></p><ul><li>包裹性：即此时元素<code>width</code>会像<code>height</code>一样由子元素决定，而不是默认撑满父元素。</li><li>块状化并格式化上下文：块状是指元素设置<code>float: left</code>之后，其<code>display</code>的计算值就成了<code>block</code>。格式化上下文是指会创建一个BFC。</li><li>没有任何<code>margin</code>合并。它向 <code>left</code> 或 <code>right</code> 浮动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。</li><li>脱离文档流：<code>float</code>设计的初衷就是为了“文字环绕”效果，为了让文字环绕图片，就需要具备两个条件。第一是元素高度坍塌，第二是行框盒子不可与浮动元素重叠。而元素高度坍塌就导致元素后面的非浮动块状元素会和其重叠，于是他就像脱离文档流了。</li></ul><p>原则：永远不是一个东西单独浮动，浮动都是一起浮动，要浮动，大家都浮动。</p><p><strong>clear的作用和不足</strong></p><p><code>clear: both</code>可以清除前面浮动元素的浮动，但实际上，他并不是真的清除了浮动。</p><p><code>clear</code>的定义是：元素盒子的边不能与前面的浮动元素相邻。也就是虽然浮动元素高度坍塌，但是设置了<code>clear: both</code>的元素却将其高度视为仍然占据位置。</p><p><code>clear</code>只能作用于块级元素，并且其并不能解决后面元素可能发生的文字环绕问题。</p><p><strong>清除浮动</strong></p><p>因为浮动元素会脱离正常的文档流，并不会占据文档流的位置，所以如果一个父元素下面都是浮动元素，那么这个父元素就无法被浮动元素所撑开，这样一来父元素就丢失了高度，这就是所谓的浮动造成的父元素高度坍塌问题。</p><p>父元素高度一旦坍塌将对后面的元素布局造成影响，为了解决这个问题，所以需要清除浮动，让父元素恢复高度。</p><p>清除浮动方法：</p><ul><li><p>通过给浮动元素的祖先元素加高度。</p></li><li><p>通过 clear 清除浮动</p><ul><li><p>浮动元素自身拥有<code>clear:both;</code>(针对两个浮动元素之间的影响)</p></li><li><p>隔墙法：在两个浮动元素之间放置一个有 <code>clear:both;</code> 属性的元素。</p></li><li><p>内墙法：放置一个有 <code>clear:both;</code> 属性的元素作为浮动元素的兄弟。这种写法的核心原理就是通过 ::after 伪元素为在父元素的最后一个子元素后面生成一个内容为空的块级元素，然后通过 clear 将这个伪元素移动到所有它之前的浮动元素的后面：</p><p><img loading=lazy src=/CSS/%e5%86%85%e5%a2%99%e6%b3%95.png alt></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>clearfix</span>:<span style=color:#a6e22e>after</span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>visibility</span>:<span style=color:#66d9ef>hidden</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>display</span>:<span style=color:#66d9ef>block</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>font-size</span>:<span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>content</span>:<span style=color:#e6db74>&#34; &#34;</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>clear</span>:<span style=color:#66d9ef>both</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>height</span>:<span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li><li><p>BFC 清除浮动：计算 BFC 高度的时候浮动子元素的高度也将计算在内，利用这条规则就可以清楚浮动。而产生 BFC 的方式很多，我们可以给父元素设置overflow: auto 来简单的实现 BFC 清除浮动，但是为了兼容 IE 最好用 overflow: hidden。通过 overflow: hidden 来清除浮动并不完美，当元素有阴影或存在下拉菜单的时候会被截断，所以该方法使用比较局限。</p></li></ul><h3 id=position-属性>position 属性<a hidden class=anchor aria-hidden=true href=#position-属性>#</a></h3><p><code>position</code>属性用来指定一个元素在网页上的位置。</p><h4 id=static-定位>static 定位<a hidden class=anchor aria-hidden=true href=#static-定位>#</a></h4><p><code>static</code>是<code>position</code>属性的默认值。如果省略<code>position</code>属性，浏览器就认为该元素是<code>static</code>定位。</p><p>这时，浏览器会按照源码的顺序，决定每个元素的位置，这称为"正常的页面流"（normal flow）。每个块级元素占据自己的区块（block），元素与元素之间不产生重叠，这个位置就是元素的默认位置。</p><p>注意，<code>static</code>定位所导致的元素位置，是浏览器自主决定的，所以这时<code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code>这四个属性无效。</p><h4 id=相对定位>相对定位<a hidden class=anchor aria-hidden=true href=#相对定位>#</a></h4><p><code>relative</code>、<code>absolute</code>、<code>fixed</code>这三个属性值有一个共同点，都是相对于某个基点的定位，不同之处仅仅在于基点不同。所以，只要理解了它们的基点是什么，就很容易掌握这三个属性值。</p><p>这三种定位都不会对其他元素的位置产生影响，即不管有没有这个元素，其他元素的位置不变，因此元素之间可能产生重叠。</p><p><code>relative</code>表示，相对于默认位置（即<code>static</code>时的位置）进行偏移，即定位基点是元素的默认位置。相对定位占有原有空间，不脱离标准文档流，也不会对其它元素的位置产生影响。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>position</span><span style=color:#f92672>:</span> <span style=color:#f92672>relative</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>left</span><span style=color:#f92672>:</span> <span style=color:#f92672>50px</span><span style=color:#f92672>;</span>		<span style=color:#75715e>/* 向右偏移 50px */</span>
</span></span><span style=display:flex><span><span style=color:#f92672>top</span><span style=color:#f92672>:</span> <span style=color:#f92672>50px</span><span style=color:#f92672>;</span>		<span style=color:#75715e>/* 向下偏移 50px */</span>
</span></span></code></pre></div><p>控制各个方向偏移量的属性是 <code>left</code>、<code>right</code>、<code>top</code> 和 <code>bottom</code>。 它们代表从原来位置向远离该方向偏移指定的像素、百分比或者 em。 也就是元素将从当前位置向属性相反的方向偏移， 负数表示相同的方向偏移。</p><h4 id=绝对定位>绝对定位<a hidden class=anchor aria-hidden=true href=#绝对定位>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>position</span><span style=color:#f92672>:</span> <span style=color:#f92672>absolute</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>left</span><span style=color:#f92672>:</span> <span style=color:#f92672>10px</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>top</span><span style=color:#f92672>/</span><span style=color:#f92672>bottom</span><span style=color:#f92672>:</span> <span style=color:#f92672>20px</span><span style=color:#f92672>;</span>
</span></span></code></pre></div><p>绝对定位的参考点：</p><ul><li>如果所有祖先元素都是<code>static</code>定位，定位基点就变成整个网页的根元素<code>html</code>。<ul><li>如果用 top 描述，那么参考点就是页面的左上角，而不是浏览器的左上角。横坐标用left表示，纵坐标用top或者bottom表示。</li><li>如果用 bottom 描述，那么参考点就是浏览器首屏窗口尺寸。</li></ul></li><li>一个绝对定位的元素，如果父辈元素中也出现了已定位（非<code>static</code>定位，无论是绝对定位、相对定位，还是固定定位）的元素，那么将以父辈 border 内侧为参考点。即相对于其包含块定位。</li><li>定位点在 left、top 时是左上角，在 left、bottom 是左下角，同理其他。</li></ul><p><strong>定义</strong></p><p>和浮动元素一样，绝对定位也具有块状化、BFC、包裹性、脱离文档流、没有<code>margin</code>合并的特性。</p><p>但和浮动不同的是，绝对定位是完全的脱离文档流。大家还记得浮动产生的目的就是为了实现文字环绕效果，所以浮动元素虽然脱离了文档流，但是后面的文字还是会环绕在浮动元素周围。而绝对定位一但产生，就不会再对周围元素产生任何影响。</p><p>而且两者包含块不同，浮动元素包含块只能是父级元素，绝对定位的包含块则是距离最近的<code>position</code>不为<code>static</code>的祖先元素。</p><p><strong>默认最大宽度为包含块的宽度</strong></p><p>默认最大宽度为包含块的宽度。由于这个特性，如果包含块的宽度很小，会出现一柱擎天的现象。解决方法也很简单，加个<code>white-space: nowrap</code>让文本不换行就行了</p><p><strong>无依赖绝对定位</strong></p><p>无依赖的<code>position: absolute</code>元素定位的位置和其本身无定位属性时候的位置和<code>display</code>的值有关。如果元素在没有<code>position</code>的情况下是内联元素，则和内联元素在同一行显示；如果元素在没有<code>position</code>属性的情况下是块级元素，则换行显示。</p><p><strong>绝对定位和 overflow: hidden</strong></p><p>当<code>overflow: hidden</code>元素在绝对定位元素和其包含块之间的时候，绝对定位元素不会被剪裁。</p><p><strong>position: absolute 的流体特性</strong></p><p>当绝对定位元素的水平方向(<code>left/right</code>)或垂直方向(<code>top/bottom</code>)的两个定位属性同时存在的时候，绝对元素在该方向上便具有了流体特性。此时的<code>width/height</code>属性具有自动撑满的特性，和一个正常流的<code>div</code>元素的<code>width</code>属性别无二致。</p><h4 id=固定定位>固定定位<a hidden class=anchor aria-hidden=true href=#固定定位>#</a></h4><p><code>position: fixed</code> 是相对于屏幕视口的位置来指定元素位置，祖先元素设置 <code>position: relative</code> 并不会对其产生影响。这会导致元素的位置不随页面滚动而变化，好像固定在网页上一样。类似于绝对位置，它与 CSS 偏移属性一起使用，并且也会将元素从当前的文档流里面移除。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>position</span><span style=color:#f92672>:</span> <span style=color:#f92672>fixed</span><span style=color:#f92672>;</span>
</span></span></code></pre></div><p><code>position: fixed</code> 只有一个要注意的点，那就是当元素祖先的 <code>transform</code> 属性非 <code>none</code> 时，容器由视口改为该祖先。</p><h4 id=粘性定位>粘性定位<a hidden class=anchor aria-hidden=true href=#粘性定位>#</a></h4><p><code>sticky</code> 能够形成"动态固定"的效果。</p><p><a href=https://www.cnblogs.com/coco1s/p/6402723.html>生效规则</a>:</p><ul><li>须指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效，浏览器把它当作<code>sticky</code>的生效门槛。否则其行为与相对定位相同。<ul><li><code>top</code> 和 <code>bottom</code> 同时设置时，<code>top</code> 生效的优先级高，<code>left</code> 和 <code>right</code> 同时设置时，<code>left</code> 的优先级高。</li></ul></li><li>设定为 <code>position:sticky</code> 元素的任意父节点的 overflow 属性必须是 visible，否则 <code>position:sticky</code> 不会生效。这里需要解释一下：<ul><li>如果 <code>position:sticky</code> 元素的任意父节点定位设置为 <code>overflow:hidden</code>，则父容器无法进行滚动，所以 <code>position:sticky</code> 元素也不会有滚动然后固定的情况。</li><li>如果 <code>position:sticky</code> 元素的任意父节点定位设置为 <code>position:relative | absolute | fixed</code>，则元素相对父元素进行定位，而不会相对 viewprot 定位。</li></ul></li><li>达到设定的阀值。这个还算好理解，也就是设定了 <code>position:sticky</code> 的元素表现为 <code>relative</code> 还是 <code>fixed</code> 是根据元素是否达到设定了的阈值决定的。</li></ul><p>它的具体规则是，当页面滚动，父元素开始脱离视口时（即部分不可见），只要与<code>sticky</code>元素的距离达到生效门槛，<code>relative</code>定位自动切换为<code>fixed</code>定位；等到父元素完全脱离视口时（即完全不可见），<code>fixed</code>定位自动切换回<code>relative</code>定位。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>#one { <span style=color:#66d9ef>position</span>: <span style=color:#66d9ef>sticky</span>; <span style=color:#66d9ef>top</span>: <span style=color:#ae81ff>10</span><span style=color:#66d9ef>px</span>; }
</span></span></code></pre></div><p>在 viewport 视口滚动到元素 top 距离小于 10px 之前，元素为相对定位。之后，元素将固定在与顶部距离 10px 的位置，直到 viewport 视口回滚到阈值以上。</p><h4 id=z-index-属性>z-index 属性<a hidden class=anchor aria-hidden=true href=#z-index-属性>#</a></h4><p><code>z-index</code>表示元素重叠时的层次关系。这个值越高，对应的元素就在越上层。所有元素的默认<code>z-index</code>是0。</p><p>由于静态布局的元素不会产生重叠，所以该属性对静态元素无效。只有元素是非静态布局（即<code>position</code>属性的值不是<code>static</code>），<code>z-index</code>属性才有意义。如果没有设置<code>z-index</code>，元素重叠时，HTML 代码中越后面出现的元素在越上层。</p><p><code>z-index</code>属性的难点在于，一组设置了<code>z-index</code>属性的元素，它们的堆叠顺序取决于，它们是否处在同一个堆叠上下文（stacking context）。</p><h2 id=层叠上下文>层叠上下文<a hidden class=anchor aria-hidden=true href=#层叠上下文>#</a></h2><p>在电脑显示屏幕上的显示的页面其实是一个三维的空间，水平方向是 X 轴，竖直方向是 Y 轴，而屏幕到眼睛的方向可以看成是 Z 轴。众 HTML 元素依据自己定义的属性的优先级在 Z 轴上按照一定的顺序排开，而这其实就是层叠上下文所要描述的东西。</p><h3 id=创建层叠上下文>创建层叠上下文<a hidden class=anchor aria-hidden=true href=#创建层叠上下文>#</a></h3><ul><li><p>html 文档根元素</p></li><li><p>声明 position: absolute/relative 且 z-index 值不为 auto 的元素；</p></li><li><p>声明 position: fixed/sticky 的元素；</p></li><li><p>flex 容器的子元素，且 z-index 值不为 auto；</p></li><li><p>grid 容器的子元素，且 z-index 值不为 auto；</p></li><li><p>opacity 属性值小于 1 的元素，也就是透明元素；</p></li><li><p>mix-blend-mode 属性值不为 normal 的元素；</p></li><li><p>以下任意属性值不为 none 的元素：</p><ul><li>transform</li><li>filter</li><li>perspective</li><li>clip-path</li><li>mask / mask-image / mask-border</li></ul></li><li><p>isolation 属性值为 isolate 的元素；</p></li><li><p>-webkit-overflow-scrolling 属性值为 touch 的元素；</p></li><li><p>will-change 值设定了任一属性而该属性在 non-initial 值时会创建层叠上下文的元素；即值为<code>opacity/transform/filter/isolation/mix-blend-mode</code>中的一个。</p></li><li><p>contain 属性值为 layout、paint 或包含它们其中之一的合成值（比如 contain: strict、contain: content）的元素。</p></li><li><p>元素的<code>filter</code>值不为<code>none</code>；</p></li></ul><h3 id=层叠等级>层叠等级<a hidden class=anchor aria-hidden=true href=#层叠等级>#</a></h3><p>层叠等级指节点在三维空间 Z 轴上的上下顺序。它分两种情况：</p><ul><li>在同一个层叠上下文中，它描述定义的是该层叠上下文中的层叠上下文元素在 Z 轴上的上下顺序；</li><li>在其他普通元素中，它描述定义的是这些普通元素在 Z 轴上的上下顺序；</li></ul><p>普通节点的层叠等级优先由其所在的层叠上下文决定，层叠等级的比较只有在当前层叠上下文中才有意义，脱离当前层叠上下文的比较就变得无意义了。</p><h3 id=层叠顺序>层叠顺序<a hidden class=anchor aria-hidden=true href=#层叠顺序>#</a></h3><p>在同一个层叠上下文中如果有多个元素，那么他们之间的层叠顺序：</p><p><img loading=lazy src=/CSS/%e5%b1%82%e5%8f%a0%e4%b8%8a%e4%b8%8b%e6%96%87.png alt></p><p>最底层<code>border/background</code>是当前层叠上下文元素的边框和背景色（注意不包括文字，文字相当于内联盒子）。</p><p>普通定位元素层叠水平在普通元素之上。普通定位元素是指<code>z-index</code>为<code>auto</code>的定位元素。</p><p><strong>比较两个元素的层叠等级</strong></p><ul><li>在同一个层叠上下文中，比较两个元素就是按照上图的介绍的层叠顺序进行比较。</li><li>如果不在同一个层叠上下文中的时候，那就需要比较两个元素分别所处的层叠上下文的等级。</li><li>如果两个元素都在同一个层叠上下文，且层叠顺序相同，则在 HTML 中定义越后面的层叠等级越高。</li></ul><h2 id=渐进增强和优雅降级>渐进增强和优雅降级<a hidden class=anchor aria-hidden=true href=#渐进增强和优雅降级>#</a></h2><h3 id=渐进增强>渐进增强<a hidden class=anchor aria-hidden=true href=#渐进增强>#</a></h3><p>一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>transition</span> { <span style=color:#75715e>/*渐进增强写法*/</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>-webkit-</span><span style=color:#66d9ef>transition</span>: <span style=color:#66d9ef>all</span> <span style=color:#ae81ff>.5</span><span style=color:#66d9ef>s</span>;
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>-moz-</span><span style=color:#66d9ef>transition</span>: <span style=color:#66d9ef>all</span> <span style=color:#ae81ff>.5</span><span style=color:#66d9ef>s</span>;
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>-o-</span><span style=color:#66d9ef>transition</span>: <span style=color:#66d9ef>all</span> <span style=color:#ae81ff>.5</span><span style=color:#66d9ef>s</span>;
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>transition</span>: <span style=color:#66d9ef>all</span> <span style=color:#ae81ff>.5</span><span style=color:#66d9ef>s</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>渐进增强的写法，优先考虑老版本浏览器的可用性，最后才考虑新版本的可用性。在前缀CSS3和正常CSS3都可用的情况下，正常CSS3会覆盖前缀CSS3。</p><h3 id=优雅降级>优雅降级<a hidden class=anchor aria-hidden=true href=#优雅降级>#</a></h3><p>一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>transition</span> { <span style=color:#75715e>/*优雅降级写法*/</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>transition</span>: <span style=color:#66d9ef>all</span> <span style=color:#ae81ff>.5</span><span style=color:#66d9ef>s</span>;
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>-o-</span><span style=color:#66d9ef>transition</span>: <span style=color:#66d9ef>all</span> <span style=color:#ae81ff>.5</span><span style=color:#66d9ef>s</span>;
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>-moz-</span><span style=color:#66d9ef>transition</span>: <span style=color:#66d9ef>all</span> <span style=color:#ae81ff>.5</span><span style=color:#66d9ef>s</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>-webkit-</span><span style=color:#66d9ef>transition</span>: <span style=color:#66d9ef>all</span> <span style=color:#ae81ff>.5</span><span style=color:#66d9ef>s</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>优雅降级的写法，优先考虑新版本浏览器的可用性，最后才考虑老版本的可用性。在前缀CSS3和正常CSS3都可用的情况下，前缀CSS3会覆盖正常的CSS3。</p><h3 id=二者区别>二者区别<a hidden class=anchor aria-hidden=true href=#二者区别>#</a></h3><p>其实渐进增强和优雅降级并非什么新概念，只是旧的概念换了一个新的说法。在传统软件开发中，经常会提到向上兼容和向下兼容的概念。渐进增强相当于向上兼容，而优雅降级相当于向下兼容。向下兼容指的是高版本支持低版本的或者说后期开发的版本支持和兼容早期开发的版本，向上兼容的很少。大多数软件都是向下兼容的比如说Office2010能打开Office2007，Office2006，Office2005，Office2003等建的word文件，但是用Office2003就不能打开用Office2007，Office2010等建的word文件！</p><p>优雅降级和渐进增强只是看待同种事物的两种观点。</p><p>优雅降级观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。你可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。</p><p>渐进增强观点则认为应关注于内容本身。请注意其中的差别：我甚至连“浏览器”三个字都没提。内容是我们建立网站的诱因。有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得渐进增强成为一种更为合理的设计范例。这也是它立即被 Yahoo! 所采纳并用以构建其“分级式浏览器支持 (Graded Browser Support)”策略的原因所在。</p><h2 id=选择器>选择器<a hidden class=anchor aria-hidden=true href=#选择器>#</a></h2><p>是元素和其他部分组合起来告诉浏览器哪个HTML元素应当是被选为应用规则中的CSS属性值的方式。选择器所选择的元素，叫做“选择器的对象”。</p><h3 id=基本选择器>基本选择器<a hidden class=anchor aria-hidden=true href=#基本选择器>#</a></h3><h4 id=通用元素选择器>通用元素选择器<a hidden class=anchor aria-hidden=true href=#通用元素选择器>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>*</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>margin-left</span>: <span style=color:#ae81ff>0</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>margin-top</span>: <span style=color:#ae81ff>0</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>通配符<code>*</code>（星号）匹配任何元素。</p><p>因为匹配范围太广，会让浏览器加载页面变慢，因此应该谨慎使用通配符。实际适合使用通配符的情况比较少。</p><h4 id=标签选择器>标签选择器<a hidden class=anchor aria-hidden=true href=#标签选择器>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>p</span> { <span style=color:#66d9ef>font-size</span>:<span style=color:#ae81ff>14</span><span style=color:#66d9ef>px</span>; }
</span></span></code></pre></div><p>匹配所有使用p标签的元素。</p><h4 id=类选择器>类选择器<a hidden class=anchor aria-hidden=true href=#类选择器>#</a></h4><p>通过 CSS class 选择器，多个 HTML 元素可以使用相同的 CSS 样式规则。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>info</span> { <span style=color:#66d9ef>width</span>:<span style=color:#ae81ff>800</span><span style=color:#66d9ef>px</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;</span><span style=color:#f92672>h3</span> <span style=color:#f92672>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;info one two&#34;</span><span style=color:#f92672>&gt;&lt;/</span><span style=color:#f92672>h3</span><span style=color:#f92672>&gt;</span>
</span></span></code></pre></div><ul><li>匹配所有class属性中包含info的元素。注意在 CSS <code>style</code> 元素里，class 名以一个句点开头。 在 HTML 元素的 class 属性中，class 名的开头没有句点。</li><li>任何的标签都可以携带 class 属性。CSS 的 class 具有可重用性，可应用于各种 HTML 元素。同一个标签可以使用多个类选择器，用空格隔开。</li><li>&ldquo;类上样式，id 上行为&rdquo;：<code>class</code>属性交给 css 使用，<code>id</code>属性交给 js 使用。</li><li>应该尽量使用 class 选择器，而不是 ID 选择器。ID 选择器的样式不能在其他元素上复用（记住，在一个页面中，一个id只能出现在一个元素上）。这会导致在其他元素上重复样式，而不是通过class共享样式。ID 选择器的特殊性比class选择器要强得多。这意味着如果要覆盖使用id选择器定义的样式，就要编写特殊性更强的CSS规则。如果数量不多，可能还不难管理。如果处理规模较大的网站，其CSS就会变得比实际所需的更长、更复杂。</li></ul><h5 id=bem命名法>BEM命名法<a hidden class=anchor aria-hidden=true href=#bem命名法>#</a></h5><p>BEM是Block（区块）、Element（元素）、Modifier（修饰符）三者的简称。区块是顶级组件的抽象，元素是组件的组成部分，修饰符是组件或元素的状态。区块与元素之间用两个下划线连接，元素与修饰符之间用两个连词线连接。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#75715e>/* Block component */</span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>btn</span> {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Element that depends upon the block */</span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>btn__price</span> {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Modifier that changes the style of the block */</span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>btn--orange</span> {}
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>btn--big</span> {}
</span></span></code></pre></div><p>对应的HTML代码结构如下。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>&lt;</span><span style=color:#f92672>a</span> <span style=color:#f92672>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;btn btn--big btn--orange&#34;</span> <span style=color:#f92672>href</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;http://css-tricks.com&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;</span><span style=color:#f92672>span</span> <span style=color:#f92672>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;btn__price&#34;</span><span style=color:#f92672>&gt;$</span><span style=color:#f92672>9</span>.<span style=color:#a6e22e>99</span><span style=color:#f92672>&lt;/</span><span style=color:#f92672>span</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;</span><span style=color:#f92672>span</span> <span style=color:#f92672>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;btn__text&#34;</span><span style=color:#f92672>&gt;</span><span style=color:#f92672>Subscribe</span><span style=color:#f92672>&lt;/</span><span style=color:#f92672>span</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/</span><span style=color:#f92672>a</span><span style=color:#f92672>&gt;</span>
</span></span></code></pre></div><p>BEM的重要特点就是CSS是扁平式的，不存在元素嵌套。</p><h4 id=id-选择器>ID 选择器<a hidden class=anchor aria-hidden=true href=#id-选择器>#</a></h4><p>在声明 id 的时候，也必须在名字前插入 <code>#</code> 符号。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>#footer { <span style=color:#66d9ef>border</span>:<span style=color:#ae81ff>3</span><span style=color:#66d9ef>px</span> <span style=color:#66d9ef>dashed</span> <span style=color:#66d9ef>green</span>; }
</span></span></code></pre></div><p>匹配 id 属性等于footer的元素。</p><p>根据规范，<code>id</code> 属性应是唯一的。 尽管浏览器并非必须执行这条规范，但这是广泛认可的最佳实践。 因此，请不要给多个元素设置相同的 <code>id</code>。</p><h4 id=属性选择器>属性选择器<a hidden class=anchor aria-hidden=true href=#属性选择器>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>video</span><span style=color:#f92672>[</span><span style=color:#f92672>autoplay</span><span style=color:#f92672>]</span> {}
</span></span></code></pre></div><p>按照给定的属性，选择所有匹配的元素。</p><ul><li><code>E[att]</code>：匹配所有具有att属性的E元素，不考虑它的值。（注意：E在此处可以省略，比如"[cheacked]"。以下同。）</li><li><code>E[att="abc"]</code>：匹配所有att属性等于"val"的E元素。</li><li><code>E[att~=val]</code>： 匹配所有att属性具有多个空格分隔的值、其中一个值等于"val"的E元素</li><li><code>E[att|=val]</code>：匹配所有att属性具有多个连字号分隔（hyphen-separated）的值、其中一个值以"val"开头的E元素，主要用于lang属性，比如"en"、&ldquo;en-us&rdquo;、&ldquo;en-gb"等等</li><li><code>E[att^="abc"]</code>：选中页面的E元素，并且E需要带有 att 属性,属性值以 abc 开头。</li><li><code>E[att$="abc"]</code>：选中页面的E元素，并且E需要带有 att 属性,属性值以 abc 结尾。</li><li><code>E[att*="abc"]</code>：选中页面的E元素，并且E需要带有 att 属性,属性值任意位置包含abc。</li></ul><p>属性修饰器支持<code>i</code>修饰符，表示不区分大小写。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#f92672>class</span><span style=color:#f92672>=</span><span style=color:#f92672>foo</span> <span style=color:#f92672>i</span><span style=color:#f92672>]</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>color</span>: <span style=color:#66d9ef>red</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面代码中，属性名<code>foo</code>后面的<code>i</code>，表示不区分<code>foo</code>的大小写。</p><p>这个修饰符对于匹配用户的输入，非常有用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * 匹配：
</span></span></span><span style=display:flex><span><span style=color:#75715e> * &lt;input value=&#34;hello world&#34;&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e> * &lt;input value=&#34;hello World&#34;&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e> * &lt;input value=&#34;hElLo WoRlD&#34;&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e> * ...
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#f92672>value</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;hello world&#34;</span> <span style=color:#f92672>i</span><span style=color:#f92672>]</span> { <span style=color:#75715e>/* ... */</span> }
</span></span></code></pre></div><h3 id=分组选择器>分组选择器<a hidden class=anchor aria-hidden=true href=#分组选择器>#</a></h3><h4 id=交集选择器>交集选择器<a hidden class=anchor aria-hidden=true href=#交集选择器>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>h3</span>.<span style=color:#a6e22e>special</span> {<span style=color:#75715e>/* 选中 h3 标签且有 special 类 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>color</span>: <span style=color:#66d9ef>red</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>定义交集选择器的时候，两个选择器之间紧密相连。</p><h4 id=多元素选择器>多元素选择器<a hidden class=anchor aria-hidden=true href=#多元素选择器>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>p</span><span style=color:#f92672>,</span> #id<span style=color:#f92672>,</span> .<span style=color:#a6e22e>one</span> {<span style=color:#75715e>/* 选中 p 或id为 id 或有 one 类 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>color</span>: <span style=color:#66d9ef>red</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>同时匹配所有E元素或F元素即并集，E和F之间用逗号分隔。</p><h5 id=matches>:matches()<a hidden class=anchor aria-hidden=true href=#matches>#</a></h5><p><code>:matches(A, B)</code>选择器表示匹配A或B。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>:<span style=color:#a6e22e>matches</span><span style=color:#f92672>(</span>.<span style=color:#a6e22e>foo</span><span style=color:#f92672>,</span> .<span style=color:#a6e22e>bar</span><span style=color:#f92672>)</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>background-color</span>: <span style=color:#66d9ef>green</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 等同于 */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>foo</span><span style=color:#f92672>,</span> .<span style=color:#a6e22e>bar</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>background-color</span>: <span style=color:#66d9ef>green</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>它可以简化一些选择器的写法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>syntax-highlighted</span> .<span style=color:#a6e22e>css-keyword</span><span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>syntax-highlighted</span> .<span style=color:#a6e22e>css-tag</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>color</span>: rgb(<span style=color:#ae81ff>170</span>, <span style=color:#ae81ff>13</span>, <span style=color:#ae81ff>145</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 等同于 */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>syntax-highlighted</span> :<span style=color:#a6e22e>matches</span><span style=color:#f92672>(</span>.<span style=color:#a6e22e>css-keyword</span><span style=color:#f92672>,</span> .<span style=color:#a6e22e>css-tag</span><span style=color:#f92672>)</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>color</span>: rgb(<span style=color:#ae81ff>170</span>, <span style=color:#ae81ff>13</span>, <span style=color:#ae81ff>145</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=组合器>组合器<a hidden class=anchor aria-hidden=true href=#组合器>#</a></h3><h4 id=后代元素选择器>后代元素选择器<a hidden class=anchor aria-hidden=true href=#后代元素选择器>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>div1</span> <span style=color:#f92672>p</span> {<span style=color:#75715e>/* 选中类 .div1 后代标签 p */</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>color</span>: <span style=color:#66d9ef>red</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>匹配所有属于E元素后代的F元素，E和F之间用空格分隔</p><h4 id=子元素选择器>子元素选择器<a hidden class=anchor aria-hidden=true href=#子元素选择器>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>div</span><span style=color:#f92672>&gt;</span><span style=color:#f92672>p</span> {}
</span></span></code></pre></div><p>匹配所有E元素的子元素F</p><h4 id=一般兄弟组合器>一般兄弟组合器<a hidden class=anchor aria-hidden=true href=#一般兄弟组合器>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>div</span><span style=color:#f92672>~</span><span style=color:#f92672>p</span> {}		<span style=color:#75715e>/* 选中的div后面所有的p	*/</span>
</span></span></code></pre></div><p>匹配任何在E元素之后的同级F元素。<code>~</code> 组合器选择兄弟元素，也就是说，后一个节点在前一个节点后面的任意位置，并且共享同一个父节点。</p><h4 id=毗邻元素选择器>毗邻元素选择器<a hidden class=anchor aria-hidden=true href=#毗邻元素选择器>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>div</span><span style=color:#f92672>+</span><span style=color:#f92672>p</span> {}		<span style=color:#75715e>/* 选中div后面相邻的第一个p */</span>
</span></span></code></pre></div><p><code>+</code> 组合器选择相邻元素，即后一个元素紧跟在前一个之后，并且共享同一个父节点。</p><h3 id=伪选择器>伪选择器<a hidden class=anchor aria-hidden=true href=#伪选择器>#</a></h3><h4 id=伪类选择器>伪类选择器<a hidden class=anchor aria-hidden=true href=#伪类选择器>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>a</span>:<span style=color:#a6e22e>link</span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>color</span>:<span style=color:#66d9ef>red</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>a</span>:<span style=color:#a6e22e>visited</span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>color</span>:<span style=color:#66d9ef>orange</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>a</span>:<span style=color:#a6e22e>hover</span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>color</span>:<span style=color:#66d9ef>green</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>a</span>:<span style=color:#a6e22e>active</span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>color</span>:<span style=color:#66d9ef>black</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>伪类选择标签的不同状态，伪类用冒号来表示。</p><p><strong>条件伪类</strong></p><ul><li><p><code>:lang()</code>：基于元素语言来匹配页面元素；匹配lang属性等于c的E元素</p></li><li><p><code>:dir()</code>：匹配特定文字书写方向的元素；</p></li><li><p><code>:has()</code>：匹配包含指定元素的元素；它可以用来选择父级元素。其中 <code>:not(:has(selector))</code> 匹配不含有 <code>selector</code> 元素的父元素，而 <code>:has(:not(selector))</code> 匹配含有的不是 <code>selector</code> 子元素的元素。两者主要区别在于，<code>:has(:not(selector))</code> 写法必须要含有一个子元素，而 <code>:not(:has())</code> 可以不含有元素也会被匹配。</p></li><li><p><code>:is()</code>、<code>where()</code>：匹配指定选择器列表里的元素；</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>:<span style=color:#a6e22e>is</span><span style=color:#f92672>(</span>.<span style=color:#a6e22e>header</span><span style=color:#f92672>,</span> .<span style=color:#a6e22e>main</span><span style=color:#f92672>)</span> .<span style=color:#a6e22e>p</span> { <span style=color:#75715e>/**020**/</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>color</span>: <span style=color:#66d9ef>purple</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>:<span style=color:#a6e22e>where</span><span style=color:#f92672>(</span>.<span style=color:#a6e22e>header</span><span style=color:#f92672>,</span> .<span style=color:#a6e22e>main</span><span style=color:#f92672>)</span> .<span style=color:#a6e22e>p</span> {	<span style=color:#75715e>/**010**/</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>color</span>: <span style=color:#66d9ef>red</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>等同于</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>header</span> .<span style=color:#a6e22e>p</span><span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>main</span> .<span style=color:#a6e22e>p</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>color</span>: <span style=color:#66d9ef>purple</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>他们唯一不同之处，就是选择器权重不同。<code>:where()</code> 的优先级总是为 <code>0</code> ，但是 <code>:is()</code> 的优先级是由它的选择器列表中优先级最高的选择器决定的。</p><p><code>:is()</code> 和 <code>:where()</code> 伪类选择器的出现，将会让我们的选择器变得更简洁</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>h1</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>font-size</span>: <span style=color:#ae81ff>30</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>section</span> <span style=color:#f92672>h1</span><span style=color:#f92672>,</span> <span style=color:#f92672>article</span> <span style=color:#f92672>h1</span><span style=color:#f92672>,</span> <span style=color:#f92672>aside</span> <span style=color:#f92672>h1</span><span style=color:#f92672>,</span> <span style=color:#f92672>nav</span> <span style=color:#f92672>h1</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>font-size</span>: <span style=color:#ae81ff>25</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>section</span> <span style=color:#f92672>section</span> <span style=color:#f92672>h1</span><span style=color:#f92672>,</span> <span style=color:#f92672>section</span> <span style=color:#f92672>article</span> <span style=color:#f92672>h1</span><span style=color:#f92672>,</span> <span style=color:#f92672>section</span> <span style=color:#f92672>aside</span> <span style=color:#f92672>h1</span><span style=color:#f92672>,</span> <span style=color:#f92672>section</span> <span style=color:#f92672>nav</span> <span style=color:#f92672>h1</span><span style=color:#f92672>,</span>
</span></span><span style=display:flex><span><span style=color:#f92672>article</span> <span style=color:#f92672>section</span> <span style=color:#f92672>h1</span><span style=color:#f92672>,</span> <span style=color:#f92672>article</span> <span style=color:#f92672>article</span> <span style=color:#f92672>h1</span><span style=color:#f92672>,</span> <span style=color:#f92672>article</span> <span style=color:#f92672>aside</span> <span style=color:#f92672>h1</span><span style=color:#f92672>,</span> <span style=color:#f92672>article</span> <span style=color:#f92672>nav</span> <span style=color:#f92672>h1</span><span style=color:#f92672>,</span>
</span></span><span style=display:flex><span><span style=color:#f92672>aside</span> <span style=color:#f92672>section</span> <span style=color:#f92672>h1</span><span style=color:#f92672>,</span> <span style=color:#f92672>aside</span> <span style=color:#f92672>article</span> <span style=color:#f92672>h1</span><span style=color:#f92672>,</span> <span style=color:#f92672>aside</span> <span style=color:#f92672>aside</span> <span style=color:#f92672>h1</span><span style=color:#f92672>,</span> <span style=color:#f92672>aside</span> <span style=color:#f92672>nav</span> <span style=color:#f92672>h1</span><span style=color:#f92672>,</span>
</span></span><span style=display:flex><span><span style=color:#f92672>nav</span> <span style=color:#f92672>section</span> <span style=color:#f92672>h1</span><span style=color:#f92672>,</span> <span style=color:#f92672>nav</span> <span style=color:#f92672>article</span> <span style=color:#f92672>h1</span><span style=color:#f92672>,</span> <span style=color:#f92672>nav</span> <span style=color:#f92672>aside</span> <span style=color:#f92672>h1</span><span style=color:#f92672>,</span> <span style=color:#f92672>nav</span> <span style=color:#f92672>nav</span> <span style=color:#f92672>h1</span><span style=color:#f92672>,</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>font-size</span>: <span style=color:#ae81ff>20</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使用 <code>:is()</code> 可以像下面这样来描述：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>h1</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>font-size</span>: <span style=color:#ae81ff>30</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>:<span style=color:#a6e22e>is</span><span style=color:#f92672>(</span><span style=color:#f92672>section</span><span style=color:#f92672>,</span> <span style=color:#f92672>article</span><span style=color:#f92672>,</span> <span style=color:#f92672>aside</span><span style=color:#f92672>,</span> <span style=color:#f92672>nav</span><span style=color:#f92672>)</span> <span style=color:#f92672>h1</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>font-size</span>: <span style=color:#ae81ff>25</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>:<span style=color:#a6e22e>is</span><span style=color:#f92672>(</span><span style=color:#f92672>section</span><span style=color:#f92672>,</span> <span style=color:#f92672>article</span><span style=color:#f92672>,</span> <span style=color:#f92672>aside</span><span style=color:#f92672>,</span> <span style=color:#f92672>nav</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>:<span style=color:#a6e22e>is</span><span style=color:#f92672>(</span><span style=color:#f92672>section</span><span style=color:#f92672>,</span> <span style=color:#f92672>article</span><span style=color:#f92672>,</span> <span style=color:#f92672>aside</span><span style=color:#f92672>,</span> <span style=color:#f92672>nav</span><span style=color:#f92672>)</span> <span style=color:#f92672>h1</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>font-size</span>: <span style=color:#ae81ff>20</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><code>:not()</code>：匹配不符合当前选择器的任何元素。<code>:not()</code>可以采用链式写法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>:<span style=color:#a6e22e>not</span><span style=color:#f92672>(</span><span style=color:#f92672>i</span><span style=color:#f92672>)</span>:<span style=color:#a6e22e>not</span><span style=color:#f92672>(</span><span style=color:#f92672>em</span><span style=color:#f92672>)</span>
</span></span></code></pre></div><p>等同于</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>:<span style=color:#a6e22e>not</span><span style=color:#f92672>(</span><span style=color:#f92672>i</span><span style=color:#f92672>,</span> <span style=color:#f92672>em</span><span style=color:#f92672>)</span>
</span></span></code></pre></div><p>希望最后一张卡片没有<code>margin-bottom</code> （或第一张卡片没有 <code>margin-top</code>）。针对于这样的场景，<code>:not()</code> 选择器就非常有优势。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>card</span>:<span style=color:#a6e22e>not</span><span style=color:#f92672>(</span>:<span style=color:#a6e22e>last-child</span><span style=color:#f92672>)</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>margin-bottom</span>: <span style=color:#ae81ff>20</span><span style=color:#66d9ef>px</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><p><strong>行为伪类</strong></p><p>针对所有标签都适用的样式。</p><ul><li><code>:hover</code>：鼠标放到标签上时。</li><li><code>:active</code>： 鼠标点击标签，但是不松手时</li></ul><p><strong>状态伪类</strong></p><p>只能用于超链接的样式。</p><ul><li><p><code>:link</code>：超链接点击之前。<code>a{}</code> 和 <code>a:link{}</code> 的区别：</p><ul><li><code>a{}</code>：定义的样式针对所有的超链接</li><li><code>a:link{} </code>：定义的样式针对所有写了 href 属性的超链接</li></ul></li><li><p><code>:visited</code>：链接被访问过之后。</p></li><li><p><code>:target</code>：匹配文档中特定"id"点击后的效果。</p></li><li><p><code>:focus</code>：当用户使用鼠标点击焦点元素或使用键盘的 <code>Tab</code> 键（或快捷键）触发焦点元素焦点环的样式。如果我们要让 <code>:focus</code> 和 <code>:focus-visible</code> 可以有独自的样式，可以借助CSS选择器中的 <code>:not()</code> 来处理：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>button</span>:<span style=color:#a6e22e>focus</span>:<span style=color:#a6e22e>not</span><span style=color:#f92672>(</span>:<span style=color:#a6e22e>focus-visible</span><span style=color:#f92672>)</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>outline</span>: <span style=color:#ae81ff>2</span><span style=color:#66d9ef>px</span> <span style=color:#66d9ef>dotted</span> <span style=color:#ae81ff>#416dea</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>outline-offset</span>: <span style=color:#ae81ff>2</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>box-shadow</span>: <span style=color:#ae81ff>0</span><span style=color:#66d9ef>px</span> <span style=color:#ae81ff>1</span><span style=color:#66d9ef>px</span> <span style=color:#ae81ff>1</span><span style=color:#66d9ef>px</span> <span style=color:#ae81ff>#416dea</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>button</span>:<span style=color:#a6e22e>focus-visible</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>outline</span>: <span style=color:#ae81ff>2</span><span style=color:#66d9ef>px</span> <span style=color:#66d9ef>solid</span> <span style=color:#ae81ff>#416dea</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>outline-offset</span>: <span style=color:#ae81ff>2</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>box-shadow</span>: <span style=color:#ae81ff>0</span><span style=color:#66d9ef>px</span> <span style=color:#ae81ff>1</span><span style=color:#66d9ef>px</span> <span style=color:#ae81ff>1</span><span style=color:#66d9ef>px</span> <span style=color:#ae81ff>#416dea</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><code>:required</code>：输入必填的表单元素；</p></li><li><p><code>:valid</code>：输入合法的表单元素；</p></li><li><p><code>:invalid</code>：输入非法的表单元素；</p></li><li><p><code>:in-range</code>：输入范围以内的表单元素；</p></li><li><p><code>:out-of-range</code>：输入范围以外的表单元素；</p></li><li><p><code>:checked</code>：选项选中的表单元素；匹配表单中被选中的radio（单选框）或checkbox（复选框）元素。</p></li><li><p><code>:optional</code>：选项可选的表单元素；</p></li><li><p><code>:enabled</code>：事件启用的表单元素；匹配表单中激活的元素。</p></li><li><p><code>:disabled</code>：事件禁用的表单元素；匹配表单中禁用的元素。</p></li><li><p><code>:read-only</code>：只读的表单元素；</p></li><li><p><code>:read-write</code>：可读可写的表单元素；</p></li><li><p><code>:blank</code>：<code>:blank</code> 要比 <code>:empty</code> 灵活地多，只要该元素中无任何子元素都能被识别。不过 W3C 规范对该伪类选择器的定义更趋向于作用到表单控件中，比如用户没有在 <code>input</code> 或 <code>textarea</code> 中输入内容时，提交表单能被识别到。有点类似于表单验证的功能。</p></li><li><p><code>:current()</code>：浏览中的元素；</p></li><li><p><code>:past()</code>：已浏览的元素；</p></li><li><p><code>:future()</code>：未浏览的元素；</p></li><li><p><code>:focus-visible</code> ：只有使用键盘的 <code>Tab</code> 键（或快捷键）触发焦点元素焦点环的样式。如果仅使用 <code>:focus-visible</code> 设置焦点环样式的话，那么用户使用鼠标点击焦点元素时不会触发焦点环样式</p></li><li><p><code>:focus-within</code>：表示一个元素获得焦点，或该元素的后代元素获得焦点。这也意味着，它或它的后代获得焦点，都可以触发 <code>:focus-within</code>。更简单的说，它有点类似于 JavaScript 的事件冒泡，从可获得焦点元素开始一直冒泡到HTML的根元素 <code>&lt;html></code> ，都可以接收触发 <code>:focus-within</code> 事件。</p></li></ul><p><code>a:link 、a:visited 、a:hover 、a:active</code> 这四种状态必须按照固定的顺序写。在写 <code>a:link</code>、<code>a:visited</code> 这两个伪类的时候，要么同时写，要么同时不写。</p><p><strong>结构伪类选择器</strong></p><ul><li><code>E:first-child</code>：匹配 E 的父元素的第一个子元素E。</li><li><code>E:last-child</code>：匹配 E 的父元素的最后一个子元素E。等同于:nth-last-child(1)。</li><li><code>E:nth-child(n)</code>：匹配 E 的父元素的第n个子元素E。<code>:nth-child(n)</code>，n从1开始计数。<code>:nth-child(an+b)</code>，n从0开始计数。</li><li><code>E:nth-child(odd)</code>：匹配 E 的父元素奇数子元素。</li><li><code>E:nth-child(even)</code>：匹配 E 的父元素偶数子元素。</li><li><code>E:nth-last-child(n)</code>：匹配 E 的父元素的倒数第n个子元素E。编号是从1开始算起。</li><li><code>:only-child</code>：父元素仅有该元素的元素；等同于:first-child:last-child或 :nth-child(1):nth-last-child(1)。</li><li><code>E:first-of-type</code>：匹配同类型中的第一个同级兄弟元素E。等同于:nth-of-type(1)。</li><li><code>E:last-of-type</code>：匹配同类型中的最后一个同级兄弟元素E。等同于:nth-last-of-type(1)。</li><li><code>E:nth-of-type(n)</code>：匹配同类型中的第n个同级兄弟元素E。</li><li><code>E:nth-last-of-type(n)</code>：匹配同类型中的倒数第n个同级兄弟元素E。</li><li><code>:only-of-type</code>：父元素仅有该标签的标签；等同于:first-of-type:last-of-type或 :nth-of-type(1):nth-last-of-type(1)。</li><li><code>:root</code>：匹配文档的根元素，对于HTML文档，就是HTML元素。</li><li><code>E:empty</code>：<code>:empty</code> 只能选中没有子元素的元素。子元素只可以是元素节点或文本（包括空格）。注释或处理指令都不会产生影响。注意，在空元素上即使使用伪元素 <code>::before</code> 或 <code>::after</code> 创建内容，也能被<code>:empty</code> 识别。</li><li><code>E:target</code>：匹配相关URL指向的E元素。要配合锚点使用。</li></ul><h4 id=伪元素选择器>伪元素选择器<a hidden class=anchor aria-hidden=true href=#伪元素选择器>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>p</span>::<span style=color:#a6e22e>before</span> { <span style=color:#66d9ef>content</span>: <span style=color:#e6db74>&#34;Hello world!&#34;</span>; } 
</span></span></code></pre></div><ul><li><code>E::before</code>：在E元素之前插入生成的伪元素，其将成为匹配选中的元素的第一个子元素。此元素默认为行内元素。</li><li><code>E::after</code>：在E元素之后插入生成的伪元素，作为已选中元素的最后一个子元素。这个虚拟元素默认是行内元素。</li><li><code>E::first-letter</code>：设置元素 E 里面的第一个字符的样式。选中首个字符。</li><li><code>E::first-line</code>：设置元素 E 里面的第一行的样式。</li><li><code>E::selection</code>：设置元素 E 里面被鼠标选中的区域的样式。</li></ul><p><code>::before</code> 和 <code>::after</code> 必须配合 <code>content</code> 来使用。 这个属性通常用来给元素添加内容诸如图片或者文字。 尽管有时 <code>::before</code> 和 <code>::after</code> 是用来实现形状而非文字，但 <code>content</code> 属性仍然是必需的，此时它的值可以是空字符串，没有 <code>content</code> 属性元素就不会显示出来。</p><h2 id=继承性和层叠性>继承性和层叠性<a hidden class=anchor aria-hidden=true href=#继承性和层叠性>#</a></h2><h3 id=继承性>继承性<a hidden class=anchor aria-hidden=true href=#继承性>#</a></h3><blockquote><p>在css中，每个CSS 属性定义的概述都指出了这个属性是默认继承的(&ldquo;Inherited: Yes&rdquo;) 还是默认不继承的(&ldquo;Inherited: No&rdquo;)。这决定了当你没有为元素的属性指定值时该如何计算值。</p><p>—— MDN</p></blockquote><p>初始值是指当属性没有指定值时的默认值，如这些语句的值都是默认值：<code>background-color: transparent</code>、<code>left: auto</code> 、<code>float: none</code>、<code>width: auto</code> 等。部分属性的默认值是会根据元素的 <code>display</code> 属性的值而计算的，比如 <code>vertical-align</code> 属性，如果是 <code>display: inline</code> 元素，则其计算值为基线对齐 <code>vertical-align: baseline</code> ，如果是 <code>display: inline-block</code> 元素，则其计算值为 <code>vertical-align: bottom</code> 。</p><p>css 的继承很简单，分为默认继承的和默认不继承的，但所有属性都可以通过设置 <code>inherit</code> 实现继承。</p><p>当没有指定值时，默认继承的属性取父元素的同属性的计算值（相当于设置了 <code>inherit</code> ），默认不继承的属性取属性的初始值（相当于设置了 <code>initial</code> ）。</p><h4 id=默认继承的-inherited-yes-的属性>默认继承的 (&ldquo;Inherited: Yes&rdquo;) 的属性<a hidden class=anchor aria-hidden=true href=#默认继承的-inherited-yes-的属性>#</a></h4><ul><li>所有元素默认继承：visibility、cursor</li><li>文本属性默认继承：letter-spacing、word-spacing、white-space、line-height、color、font、 font-family、font-size、font-style、font-variant、font-weight、text-indent、text-align、text-shadow、text-transform、direction</li><li>列表元素默认继承：list-style、list-style-type、list-style-position、list-style-image</li><li>表格元素默认继承：border-collapse</li></ul><h4 id=四个通用属性值>四个通用属性值<a hidden class=anchor aria-hidden=true href=#四个通用属性值>#</a></h4><p>属性值分为三种，即 css 规范定义的初始值、浏览器厂商重置的用户代理样式和我们开发人员设置的样式，优先级也是按照这个顺序递增。</p><p>css 为控制继承提供了四个特殊的通用属性值，每个 css 属性都能使用这些值：</p><h5 id=inherit>inherit<a hidden class=anchor aria-hidden=true href=#inherit>#</a></h5><p>设置该属性会使子元素属性和父元素相同。实际上，就是“开启继承”。</p><p>默认不能继承的属性，比如<code>border</code>属性。父元素设置了<code>border</code>以后，子元素如果要有边框，必须重新设一遍。</p><p>CSS 提供了<code>inherit</code>属性值，如果要让子元素继承父元素的属性，可以使用这个属性值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>main-list</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>border</span>: <span style=color:#ae81ff>1</span><span style=color:#66d9ef>rem</span> <span style=color:#66d9ef>solid</span> <span style=color:#ae81ff>#000</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>color</span>: <span style=color:#66d9ef>red</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>font-family</span>: Verdana;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>sub-list</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>border</span>: <span style=color:#66d9ef>inherit</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面代码中，<code>.sub-list</code>的<code>border</code>属性，就继承了<code>.main-list</code>，从而两者的边框都一样。它的好处是，如果要修改边框，只要修改一处即可。</p><h5 id=initial>initial<a hidden class=anchor aria-hidden=true href=#initial>#</a></h5><p>将属性的初始值应用于元素。实际上，就是重置为css规范定义中的默认值（不是浏览器定义的样式表中的样式）。它的主要用处是，让那些默认继承父元素的 CSS 属性不再继承，回到初始值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>berries</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>border</span>: <span style=color:#ae81ff>1</span><span style=color:#66d9ef>rem</span> <span style=color:#66d9ef>solid</span> <span style=color:#ae81ff>#000</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>color</span>: <span style=color:#66d9ef>red</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>font-family</span>: Verdana;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>margin-bottom</span>: <span style=color:#ae81ff>10</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>berries</span> <span style=color:#f92672>h1</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>color</span>: <span style=color:#66d9ef>initial</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面代码中，<code>.berries</code>是<code>h1</code>的父元素，而<code>color</code>属性是可以继承的，如果不设置<code>h1</code>的颜色，<code>h1</code>就会是红色的。现在<code>h1</code>的<code>color</code>设为<code>initial</code>，就不再继承父元素的颜色，而是回到浏览器给予<code>h1</code>的默认颜色，即黑色。</p><h5 id=unset>unset<a hidden class=anchor aria-hidden=true href=#unset>#</a></h5><p><code>unset</code>属性值的作用是，如果存在继承，则继承父元素的值（等同于<code>inherit</code>），如果不存在继承，则重置为初始值（等同于<code>initial</code>）。<code>unset</code>的意思，就是去除当前样式表对该元素的样式设置。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>h1</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>color</span>: <span style=color:#66d9ef>blue</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>div</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>border</span>: <span style=color:#ae81ff>1</span><span style=color:#66d9ef>rem</span> <span style=color:#66d9ef>solid</span> <span style=color:#ae81ff>#000</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>color</span>: <span style=color:#66d9ef>red</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>font-family</span>: Verdana;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>margin-bottom</span>: <span style=color:#ae81ff>10</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>berries</span> <span style=color:#f92672>h1</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>color</span>: <span style=color:#66d9ef>unset</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面代码中，<code>div</code>是<code>h1</code>的父元素，如果不设置<code>.berries h1</code>的<code>color</code>属性，<code>h1</code>会显示为蓝色，设成<code>color: unset</code>以后，<code>h1</code>继承了父元素的<code>color</code>，显示为红色。如果不设置<code>div</code>的<code>color</code>，那么<code>.berries h1</code>将显示为浏览器赋予的默认颜色（黑色）。</p><h5 id=revert>revert<a hidden class=anchor aria-hidden=true href=#revert>#</a></h5><p><code>revert</code>属性值用于消除当前样式表对该元素设置的样式，这也是它名字的含义（<code>还原</code>），基本等同于<code>unset</code>。具体来说，如果存在继承，该元素会显示继承的属性值，如果不存在继承，则分成以下两种情况。</p><ul><li><code>revert</code>用在网站提供的样式表：则显示用户样式表设置的值。如果不存在用户样式表，则浏览器赋予的默认值。</li><li><code>revert</code>用在用户提供的样式表：显示浏览器赋予的默认值。</li></ul><p>我们知道，样式表可以分成三层：用户提供的样式表，可以覆盖网站提供的样式表；网站提供的样式表，又可以覆盖浏览器的默认样式表。<code>revert</code>主要针对的就是多层样式表同时存在的情况，然后用于去除本层样式表对元素的影响。</p><p>大多数情况下，<code>revert</code>与<code>unset</code>是一样的，主要差异是 CSS 属性的初始值与浏览器的默认值可能有差异。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>&lt;</span><span style=color:#f92672>h3</span> <span style=color:#f92672>style</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;font-weight: unset;&#34;</span><span style=color:#f92672>&gt;</span><span style=color:#f92672>hello</span><span style=color:#f92672>&lt;/</span><span style=color:#f92672>h3</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;</span><span style=color:#f92672>h3</span> <span style=color:#f92672>style</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;font-weight: revert;&#34;</span><span style=color:#f92672>&gt;</span><span style=color:#f92672>hello</span><span style=color:#f92672>&lt;/</span><span style=color:#f92672>h3</span><span style=color:#f92672>&gt;</span>
</span></span></code></pre></div><p>上面代码中，<code>font-weight: unset</code>会回到<code>font-weight</code>的初始值，即<code>normal</code>。而<code>&lt;font-weight: revert></code>会回到浏览器对<code>h3</code>的<code>font-weight</code>默认值，一般是粗体。</p><p>如果想要清除当前样式表对该元素的所有设置，可以使用<code>all: revert</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>&lt;</span><span style=color:#f92672>h3</span> <span style=color:#f92672>style</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;all: revert;&#34;</span><span style=color:#f92672>&gt;</span><span style=color:#f92672>hello</span><span style=color:#f92672>&lt;/</span><span style=color:#f92672>h3</span><span style=color:#f92672>&gt;</span>
</span></span></code></pre></div><h3 id=层叠性>层叠性<a hidden class=anchor aria-hidden=true href=#层叠性>#</a></h3><p>用于合并来自多个源的属性值的算法。比如说针对某个 HTML 标签，有许多的 CSS 声明都能作用到的时候，那最后谁应该起作用呢？理解层叠性的时候需要结合 CSS 选择器的优先级以及继承性来理解。（相同的属性，优先级高的覆盖优先级低的，不同属性会合并）</p><p>CSS 采用以下规则，决定样式规则的优先级。</p><ul><li>特殊性（specificity）</li><li>顺序（order）</li><li>重要性（importance）</li></ul><p>特殊性指的是选择器的具体程度，选择器越特殊，规则就越强。遇到冲突时，优先应用特殊性强的规则。特殊性最低的是元素名本身，然后是元素的<code>class</code>属性，特殊性最高的是<code>id</code>属性。建议在样式表中多使用<code>class</code>选择器，避免使用<code>id</code>选择器，这样的灵活性最好。</p><p>顺序指的是，同样特殊性的规则，晚出现的优先级高。</p><p>重要性指的是，特别注明某条规则的重要程度要比其他所有规则高，方法是在声明的末尾加上<code>!important</code>。由于可维护性很差，一旦出现问题，很难排查，除非是殊情况，否则不推荐使用这种方法。</p><h4 id=权重>权重<a hidden class=anchor aria-hidden=true href=#权重>#</a></h4><p><img loading=lazy src=/CSS/%e8%ae%a1%e7%ae%97%e6%9d%83%e9%87%8d.png alt></p><table><thead><tr><th>权重值</th><th>选择器</th></tr></thead><tbody><tr><td>1,0,0,0,0</td><td>!important</td></tr><tr><td>0,1,0,0,0</td><td>内联样式：style=&rdquo;"</td></tr><tr><td>0,0,1,0,0</td><td>ID选择器：<code>#idName{...}</code></td></tr><tr><td>0,0,0,1,0</td><td>类、伪类、属性选择器：<code>.className{...}</code> / <code>:hover{...}</code> / <code>[type="text"] ={...}</code></td></tr><tr><td>0,0,0,0,1</td><td>标签、伪元素选择器：<code>div{...}</code> / <code>:after{...}</code></td></tr><tr><td>0,0,0,0,0</td><td>通用选择器（*）、子选择器（>）、相邻选择器（+）、同胞选择器（~）</td></tr></tbody></table><ul><li>有直接选中了的就不考虑没选中的，这时没选中的权重计算为 0。只有都没选中才考虑没选中。</li><li>并集选择器拆开计算。</li><li>CSS权重进制在IE6为256，后来扩大到了65536，而现代浏览器则采用更大的数量。所以我们可以忽略进制的问题，从高往低比较权重值。</li><li>先从高等级进行比较，高等级相同时，再比较低等级的，以此类推；</li><li>完全相同的话，就采用后者优先原则；</li></ul><h4 id=important>!important<a hidden class=anchor aria-hidden=true href=#important>#</a></h4><pre tabindex=0><code>k:v !important;
</code></pre><ul><li>!important 提升的是一个属性权重，而不是一个选择器。例如 <code>font-family: "Trebuchet MS" , Verdana, Helvetica, Sans-Serif !important;</code> 会覆盖 font-family 属性为 <code>"Trebuchet MS" , Verdana, Helvetica, Sans-Serif</code></li><li>!important 在没选中的前提下，无法提升继承的权重比选中的权重还高。</li><li>!important 在都没选中的前提下，不影响就近原则。</li><li>宽高有例外情况，由于宽高会被<code>max-width</code>/<code>min-width</code>覆盖，所以<code>!important</code>会失效。</li><li>很多时候，你会使用 CSS 库， CSS 库中的样式会意外覆盖你的 CSS 样式。 如果想保证你的 CSS 样式不受影响，你可以使用 <code>!important</code>。</li></ul><h2 id=web-字体>Web 字体<a hidden class=anchor aria-hidden=true href=#web-字体>#</a></h2><h3 id=字体族>字体族<a hidden class=anchor aria-hidden=true href=#字体族>#</a></h3><ul><li>serif：衬线体。</li><li>sans-serif：无衬线体。</li><li>monospace：等宽字体。每一个字母所占的宽度是相同的。写代码的字体尽量用等宽字体。</li><li>cursive：手写字体。比如徐静蕾手写体。</li><li>fantasy：梦幻字体。比如一些艺术字。</li></ul><h3 id=字体格式>字体格式<a hidden class=anchor aria-hidden=true href=#字体格式>#</a></h3><ul><li>内嵌OpenType（Embedded OpenType，.eot）。在使用@font-face时，Internet Explorer 8及之前的版本仅支持内嵌OpenType。内嵌OpenType是Microsoft的一项专有格式，它使用数字版权管理技术防止在未经许可的情况下使用字体。</li><li>TrueType（.ttf）和OpenType（.otf），台式机使用的标准字体文件类型。TrueType和OpenType得到了Mozilla Firefox（3.5及之后的版本）、Opera（10及之后的版本）、Safari（3.1及之后的版本）、Mobile Safari（iOS 4.2及之后的版本）、Google Chrome（4.0及之后的版本）及Internet Explorer（9及之后的版本）的广泛支持。这些格式不使用数字版权管理。</li><li>Web开放字体格式（Web Open Font Format，.woff）。这种较新的标准是专为Web字体设计的。Web开放字体格式的字体是经压缩的TrueType字体或OpenType字体。WOFF格式还允许在文件上附加额外的元数据。字体设计人员或厂商可以利用这些元数据，在原字体信息的基础上，添加额外的许可证或其他信息。这些元数据不会以任何方式影响字体的表现，但经用户请求，这些元数据可以呈现出来。Mozilla Firefox（3.6及之后的版本）、Opera（11.1及之后的版本）、Safari（5.1及之后的版本）、Google Chrome（6.0及之后的版本）及Internet Explorer（9及之后的版本）均支持Web开放字体格式。</li><li>可缩放矢量图形（Scalable Vector Graphics，.svg）。简言之，应避免对Web字体文件使用SVG。它更多地用于早期Web字体，因为它是iOS 4.1上移动Safari唯一支持的格式（还有可能引起一些崩溃的情况）。从iOS 4.2（于2011年初即被广泛使用）起，移动Safari开始支持TrueType。</li></ul><h3 id=svg-图像>SVG 图像<a hidden class=anchor aria-hidden=true href=#svg-图像>#</a></h3><p>SVG 是一种基于 XML 语法的图像格式，全称是可缩放矢量图（Scalable Vector Graphics）。其他图像格式都是基于像素处理的，SVG 则是属于对图像的形状描述，所以它本质上是文本文件，体积较小，且不管放大多少倍都不会失真。</p><ul><li><p>SVG 文件可以直接插入网页，成为 DOM 的一部分，然后用 JavaScript 和 CSS 进行操作。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-svg data-lang=svg><span style=display:flex><span><span style=color:#f92672>&lt;svg</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>id=</span><span style=color:#e6db74>&#34;mysvg&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>xmlns=</span><span style=color:#e6db74>&#34;http://www.w3.org/2000/svg&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>viewBox=</span><span style=color:#e6db74>&#34;0 0 800 600&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>preserveAspectRatio=</span><span style=color:#e6db74>&#34;xMidYMid meet&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;circle</span> <span style=color:#a6e22e>id=</span><span style=color:#e6db74>&#34;mycircle&#34;</span> <span style=color:#a6e22e>cx=</span><span style=color:#e6db74>&#34;400&#34;</span> <span style=color:#a6e22e>cy=</span><span style=color:#e6db74>&#34;300&#34;</span> <span style=color:#a6e22e>r=</span><span style=color:#e6db74>&#34;50&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;svg&gt;</span>
</span></span></code></pre></div></li><li><p>SVG 代码也可以写在一个独立文件中，然后用<code>&lt;img></code>、<code>&lt;object></code>、<code>&lt;embed></code>、<code>&lt;iframe></code>等标签插入网页。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-svg data-lang=svg><span style=display:flex><span><span style=color:#f92672>&lt;img</span> <span style=color:#a6e22e>src=</span><span style=color:#e6db74>&#34;circle.svg&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;object</span> <span style=color:#a6e22e>id=</span><span style=color:#e6db74>&#34;object&#34;</span> <span style=color:#a6e22e>data=</span><span style=color:#e6db74>&#34;circle.svg&#34;</span> <span style=color:#a6e22e>type=</span><span style=color:#e6db74>&#34;image/svg+xml&#34;</span><span style=color:#f92672>&gt;&lt;/object&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;embed</span> <span style=color:#a6e22e>id=</span><span style=color:#e6db74>&#34;embed&#34;</span> <span style=color:#a6e22e>src=</span><span style=color:#e6db74>&#34;icon.svg&#34;</span> <span style=color:#a6e22e>type=</span><span style=color:#e6db74>&#34;image/svg+xml&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;iframe</span> <span style=color:#a6e22e>id=</span><span style=color:#e6db74>&#34;iframe&#34;</span> <span style=color:#a6e22e>src=</span><span style=color:#e6db74>&#34;icon.svg&#34;</span><span style=color:#f92672>&gt;&lt;/iframe&gt;</span>
</span></span></code></pre></div></li><li><p>CSS 也可以使用 SVG 文件。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>logo</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>background</span>: url(<span style=color:#e6db74>icon.svg</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>SVG 文件还可以转为 BASE64 编码，然后作为 Data URI 写入网页。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>&lt;</span><span style=color:#f92672>img</span> <span style=color:#f92672>src</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;data:image/svg+xml;base64,[data]&#34;</span><span style=color:#f92672>&gt;</span>
</span></span></code></pre></div></li></ul><h3 id=字体图标>字体图标<a hidden class=anchor aria-hidden=true href=#字体图标>#</a></h3><p>把网页中一些小的图标，借助工具生成一个字体包，然后就可以像使用文字一样使用图标了。</p><h3 id=免费可商用字体>免费可商用字体<a hidden class=anchor aria-hidden=true href=#免费可商用字体>#</a></h3><ul><li>思源黑体</li><li>思源宋体</li><li>文泉驿系列字体</li><li>Arual</li></ul><h3 id=字体属性>字体属性<a hidden class=anchor aria-hidden=true href=#字体属性>#</a></h3><h4 id=font-weight>font-weight<a hidden class=anchor aria-hidden=true href=#font-weight>#</a></h4><p><code>font-weight</code> 属性用于设置文本中字体的粗细。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>font-weight</span><span style=color:#f92672>:</span> <span style=color:#f92672>normal</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>font-weight</span><span style=color:#f92672>:</span> <span style=color:#f92672>bold</span><span style=color:#f92672>;</span> 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>font-weight</span><span style=color:#f92672>:</span> <span style=color:#f92672>400</span><span style=color:#f92672>;</span>		<span style=color:#75715e>/* = normal */</span>
</span></span><span style=display:flex><span><span style=color:#f92672>font-weight</span><span style=color:#f92672>:</span> <span style=color:#f92672>900</span><span style=color:#f92672>;</span>		<span style=color:#75715e>/* = blod */</span>
</span></span></code></pre></div><p>所有数值关键字浏览器都支持，有时候之所以没有看到粗细的变化，是因为所使用的字体不支持。如“微软雅黑”，它只支持 400 和 700 这两种粗细。</p><h4 id=font-size>font-size<a hidden class=anchor aria-hidden=true href=#font-size>#</a></h4><p><code>font-size</code>属性用于设置网页的字体大小。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>font-size</span><span style=color:#f92672>:</span> <span style=color:#f92672>14px</span><span style=color:#f92672>;</span>
</span></span></code></pre></div><h4 id=font-smoothing>font-smoothing<a hidden class=anchor aria-hidden=true href=#font-smoothing>#</a></h4><p><code>font-smooth</code>属性主要用于控制浏览器对字体的渲染。比如，下面的设置可以减少字体渲染出现锯齿。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>body</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>-webkit-</span>font-smoothing: antialiased;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>-moz-</span>osx-font-smoothing: grayscale;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=font-display>font-display<a hidden class=anchor aria-hidden=true href=#font-display>#</a></h4><p>有时，样式表指定的字体需要下载（称为 web font），<code>font-display</code>属性用于控制浏览器在下载字体时的渲染行为。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>@<span style=color:#66d9ef>font-face</span> {
</span></span><span style=display:flex><span>  <span style=color:#f92672>font-family</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;my-font&#39;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>font-display</span><span style=color:#f92672>:</span> <span style=color:#f92672>optional</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>src</span><span style=color:#f92672>:</span> <span style=color:#f92672>url</span><span style=color:#f92672>(</span><span style=color:#f92672>my-font</span>.<span style=color:#a6e22e>woff2</span><span style=color:#f92672>)</span> <span style=color:#f92672>format</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#39;woff2&#39;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这里需要理解，浏览器对于下载字体的处理过程。</p><p>首先，浏览器发现样式表指定的字体，是一种需要下载的字体，会去检查缓存里面是否存在这种字体，如果不存在就开始从网上下载。这时，网页上使用这种字体的文字，会显示不出来，而展现一片空白。这段时间称为”阻塞期“（block），每种浏览器的”阻塞期“时间长度不尽相同，Chrome、Firefox 和 Safari 都是3秒，即文字会有3秒钟显示不出来，而 IE 是0秒，即没有阻塞期。</p><p>然后，阻塞期结束，如果字体已经下载完成，浏览器就会采用下载的字体进行渲染，文字就会显示出来。如果下载还没有结束，浏览器就会采用替代字体进行渲染，文字也会显示出来，但是与最终状态不一样，这段时间称为”替换期“（swap）。此时，浏览器其实还在下载字体。</p><p>最后，等到字体下载成功，这时浏览器会用下载的字体，替换现有的字体，这时网页会一闪。如果字体下载失败了，这时浏览器就会继续使用现有的字体，因此网页不会发生变化。</p><p><code>font-display</code>可以取以下值。</p><p>（1）<code>font-display: block</code></p><p>这是浏览器的默认行为，即打开阻塞期。</p><p>（2）<code>font-display: swap</code></p><p>这个值会关闭阻塞期，直接进入替换期，即浏览器不会出现文字显示不出来的情况。</p><p>（3）<code>font-display: fallback</code></p><p>这个值设置阻塞期的长度是100毫秒，即文字有100毫秒显示不出来，然后立即进入替换期。等到字体下载结束，再使用下载的字体渲染。</p><p>（4）<code>font-display: optional</code></p><p>这个值设置阻塞期也是100毫秒。然后，等到100毫秒结束，浏览器发现字体已经下载完成，就使用下载的字体渲染，否则就不再下载，永久性使用替代字体渲染。它主要用于网速较慢的环境，不让用户长时间等到字体下载。</p><p>一般来说，正常情况下都推荐使用<code>font-display:optional</code>。如果是图标字体等没有替代字体的情况下，可以使用<code>font-display: block</code>。</p><h4 id=line-height>line-height<a hidden class=anchor aria-hidden=true href=#line-height>#</a></h4><p><code>line-height</code> 属性来设置行间的距离。 行高，顾名思义，可以用来设置每行文字所占据的垂直空间。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>line-height</span><span style=color:#f92672>:</span> <span style=color:#f92672>1</span>.<span style=color:#a6e22e>6</span><span style=color:#f92672>;</span>		<span style=color:#75715e>/* 1.6 * font-size */</span>
</span></span></code></pre></div><p>桌面浏览器默认值为 <code>normal</code>。</p><p><strong>字母 x 的角色</strong></p><p><img loading=lazy src=/CSS/1472057645-5736c358aff11_fix732.webp alt></p><p>在内联元素的垂直方向对齐中，基线是最为重要的概念。<code>line-height</code>的大小定义（等于）的就是两基线之间的距离，<code>vertical-align</code>的默认值就是基线。基线的定义则是字母 x 的下边缘。</p><p>css中有个概念叫<code>x-height</code>，指的是小写字母 x 的高度。<code>vertical-align: middle</code>对齐的就是基线往上1/2<code>x-height</code>高度的地方，可以理解为近似字母 x 的交叉点。</p><p>css中除了<code>px/em/rem</code>等，还有个单位是<code>ex</code>。指的就是小写字母x的高度，即<code>x-height</code>。</p><p><strong>属性值</strong></p><ul><li><code>normal</code>： 默认值<code>normal</code>其实是类型为数值的变量，根据浏览器和字体 font-family 不同而不同，一般约为 1.2 。</li><li>数值和百分比：最终会被计算为带单位的值，具体计算方法就是乘以字体<code>font-size</code>大小。</li><li>长度值：就是<code>100px</code>这样带单位的值。</li><li>这几类值的继承特性不同：<code>line-height</code>是数值的元素的子元素继承的就是这个数值，百分比/长度值继承的都是计算后得出的带单位的值（px）。</li></ul><p><a href=https://segmentfault.com/a/1190000005122321><strong>文本垂直居中原理</strong></a></p><p><code>line-height</code>属性用于设置多行元素的空间量，如多行文本的间距。</p><p>对块级元素来说，<code>line-height</code>决定了行框盒子的最小高度。注意是行框盒子的最小高度，而不是块级元素的实际高度。</p><p>对于非替代的 inline 元素，它用于计算行框盒子的高度。此时内联元素的行框盒子的高度完全由<code>line-height</code>决定，不受其他任何属性的影响。</p><p><img loading=lazy src=/CSS/610855345-5736c34b7dccb_fix732.webp alt></p><p>如果我们把一段文本的<code>line-height</code>设置为父容器的高度就可以实现文本垂直居中了。<code>line-height</code>实现垂直居中的本质——行距。行距是指一行文本和相邻文本之间的距离。<strong>上下行距 = <code>line-height</code> — <code>font-size</code></strong>。行距具有上下等分的机制：意思就是文字上下的行距是一样的，各占一半，这也是<code>line-height</code>能让内联元素垂直居中的原因。如果没有文字而有内联元素，会产生幽灵空白节点，而幽灵空白节点+行高也能撑起<code>div</code>。</p><p>内联元素的大值特性：无论内联元素的<code>line-height</code>如何设置，最终父元素的高度都是数值大的那个<code>line-height</code>决定的。</p><h4 id=vertical-align>vertical-align<a hidden class=anchor aria-hidden=true href=#vertical-align>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>vertical-align</span><span style=color:#f92672>:</span> <span style=color:#f92672>middle</span><span style=color:#f92672>;</span>
</span></span></code></pre></div><p><strong>属性值</strong></p><ul><li>线类： 如<code>baseline（默认值）</code> <code>top</code> <code>middle</code> <code>bottom</code>（<code>baseline</code>使元素的基线与父元素的基线对齐，<code>middle</code>使元素的中部与父元素的基线往上<code>x-height</code>的一半对齐。<code>top</code> <code>bottom</code>使元素及其后代元素的底部与整行或整块的底部对齐。）</li><li>文本类： <code>text-top</code> <code>text-bottom</code>（使元素的顶部与父元素的字体顶部对齐。）</li><li>上标下标： <code>sub</code> <code>super</code>（使元素的基线与父元素的下标基线对齐。）</li><li>数值： <code>20px</code> <code>2em</code> （默认值<code>baseline</code>相当于数值的 0 。使元素的基线对齐到父元素的基线之上的给定长度，数值正值是基线往上偏移，负值是往下偏移，借此可以实现元素垂直方向精确对齐。）</li><li>百分比： <code>20%</code> （使元素的基线对齐到父元素的基线之上的给定百分比，该百分比是line-height属性的百分比。）</li></ul><p><strong>作用前提</strong></p><p>vertical-align属性起作用的前提必须是作用在内联元素上。即<code>display</code>计算值为<code>inline</code> <code>inline-block</code> <code>inline-table</code> <code>table-cell</code>的元素。</p><p><strong>display: inline-block 基线的不同之处</strong></p><p>一个设置了<code>display: inline-block</code>的元素：</p><ul><li>如果元素内部没有内联元素，则该元素基线就是该元素下边缘。</li><li>如果元素设置了<code>overflow</code>为<code>hidden auto scroll</code>，则其基线就是该元素下边缘。</li><li>如果元素内部还有内联元素，则其基线就是内部最后一行内联元素的基线。</li></ul><h4 id=font-family>font-family<a hidden class=anchor aria-hidden=true href=#font-family>#</a></h4><p>通过 <code>font-family</code> 属性，我们可以设置元素里的字体族名。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>font-family</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Times New Roman&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;Microsoft YaHei&#34;</span><span style=color:#f92672>,</span> <span style=color:#f92672>monospace</span><span style=color:#f92672>;</span>
</span></span></code></pre></div><p>简写：</p><pre tabindex=0><code>font: [font-weight] font-size/[line-height] font-family;
</code></pre><p>多字体 fallback 机制：当指定的字体找不到（或者某些文字不支持这个字体）时，那就接着往后找。<code>monospace</code>、<code>serif</code> 和 <code>sans-serif</code> 等通用字体名不区分大小写，同时，也不需要使用引号，因为它们是 CSS 中的关键字。</p><p>在我们的网站上，除了使用系统提供的默认字体以外，我们也可以使用自定义字体。 网络上有很多字体库。 如<a href=https://fonts.google.com/>Google 字体库</a>。</p><p>字体名区分大小写，并且如果字体名含有空格，则在声明时需要用引号包起来。 例如，使用 <code>"Open Sans"</code> 字体需要添加引号，而 <code>Lobster</code> 则不需要。</p><h2 id=文本属性>文本属性<a hidden class=anchor aria-hidden=true href=#文本属性>#</a></h2><h3 id=空格>空格<a hidden class=anchor aria-hidden=true href=#空格>#</a></h3><h4 id=基本规则>基本规则<a hidden class=anchor aria-hidden=true href=#基本规则>#</a></h4><p>HTML 代码的空格通常会被浏览器忽略。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>p</span>&gt;◡◡hello◡◡world◡◡&lt;/<span style=color:#f92672>p</span>&gt;
</span></span></code></pre></div><p>上面是一行 HTML 代码，文字的前部、内部和后部各有两个空格。为了便于识别，这里使用半圆形符号<code>◡</code>表示空格。</p><p>浏览器的输出结果如下。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>hello world
</span></span></code></pre></div><p>可以看到，文字的前部和后部的空格都会忽略，内部的连续空格只会算作一个。这就是浏览器处理空格的基本规则。</p><p>如果希望空格原样输出，可以使用<code>&lt;pre></code>标签。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>pre</span>&gt;◡◡hello◡◡world◡◡&lt;/<span style=color:#f92672>pre</span>&gt;
</span></span></code></pre></div><p>另一种方法是，改用 HTML 实体<code>&amp;nbsp;</code>表示空格。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>p</span>&gt;&amp;nbsp;&amp;nbsp;hello&amp;nbsp;&amp;nbsp;world&amp;nbsp;&amp;nbsp;&lt;/<span style=color:#f92672>p</span>&gt;
</span></span></code></pre></div><h4 id=空格字符>空格字符<a hidden class=anchor aria-hidden=true href=#空格字符>#</a></h4><p>HTML 处理空格的规则，适用于多种字符。除了普通的空格键，还包括制表符（<code>\t</code>）和换行符（<code>\r</code>和<code>\n</code>）。</p><p>浏览器会自动把这些符号转成普通的空格键。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>p</span>&gt;hello
</span></span><span style=display:flex><span>world&lt;/<span style=color:#f92672>p</span>&gt;
</span></span></code></pre></div><p>上面代码中，文本内部包含了一个换行符，浏览器视同为空格，输出结果如下。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>hello world
</span></span></code></pre></div><p>所以，文本内部的换行是无效的（除非文本放在<code>&lt;pre></code>标签内）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>p</span>&gt;hello&lt;<span style=color:#f92672>br</span>&gt;world&lt;/<span style=color:#f92672>p</span>&gt;
</span></span></code></pre></div><p>上面代码使用<code>&lt;br></code>标签显式表示换行。</p><h4 id=white-space>white-space<a hidden class=anchor aria-hidden=true href=#white-space>#</a></h4><p>HTML 语言的空格处理，基本上就是直接过滤。这样的处理过于粗糙，完全忽视了原始文本内部的空格可能是有意义的。</p><p>CSS 提供了一个 white-space 属性，可以提供更精确一点的空格处理方式。该属性共有六个值，除了一个通用的<code>inherit</code>（继承父元素），下面依次介绍剩下的五个值。</p><p><strong>white-space: normal</strong></p><p><code>white-space</code>属性的默认值为<code>normal</code>，表示浏览器以正常方式处理空格。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>p</span>&gt;◡◡hellohellohello◡hello
</span></span><span style=display:flex><span>world
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>p</span>&gt;
</span></span></code></pre></div><p>上面代码中，文本前部有两个空格，内部有一个长单词和一个换行符。</p><p>然后，容器<code>&lt;p></code>指定一个比较小的宽度。为了便于识别，背景色设为红色。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>p</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>width</span>: <span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>background</span>: <span style=color:#66d9ef>red</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>显示效果如下图。</p><p><img loading=lazy src=/CSS/white-space-normal.png alt></p><p>可以看到，文首的空格被忽略。由于容器太窄，第一个单词溢出容器，然后在后面一个空格处换行。文本内部的换行符自动转成了空格。</p><p><strong>white-space: nowrap</strong></p><p><code>white-space</code>属性为<code>nowrap</code>时，不会因为超出容器宽度而发生换行。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>p</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>white-space</span>: <span style=color:#66d9ef>nowrap</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>显示效果如下图。</p><p><img loading=lazy src=/CSS/white-space-nowrap.png alt></p><p>所有文本显示为一行，不会换行。</p><p><strong>white-space: pre</strong></p><p><code>white-space</code>属性为<code>pre</code>时，就按照<code>&lt;pre></code>标签的方式处理。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>p</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>white-space</span>: <span style=color:#66d9ef>pre</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>显示效果如下图。</p><p><img loading=lazy src=/CSS/white-space-pre.png alt></p><p>上面结果与原始文本完全一致，所有空格和换行符都保留了。</p><p><strong>white-space: pre-wrap</strong></p><p><code>white-space</code>属性为<code>pre-wrap</code>时，基本还是按照<code>&lt;pre></code>标签的方式处理，唯一区别是超出容器宽度时，会发生换行。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>p</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>white-space</span>: <span style=color:#66d9ef>pre-wrap</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>显示效果如下图。</p><p><img loading=lazy src=/CSS/white-space-pre-wrap.png alt></p><p>文首的空格、内部的空格和换行符都保留了，超出容器的地方发生了折行。</p><p><strong>white-space: pre-line</strong></p><p><code>white-space</code>属性为<code>pre-line</code>时，意为保留换行符。除了换行符会原样输出，其他都与<code>white-space:normal</code>规则一致。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>p</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>white-space</span>: <span style=color:#66d9ef>pre-line</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>显示效果如下图。</p><p><img loading=lazy src=/CSS/white-space-pre-line.png alt></p><p>除了文本内部的换行符没有转成空格，其他都与<code>normal</code>的处理规则一致。这对于诗歌类型的文本很有用。</p><h3 id=direction>direction<a hidden class=anchor aria-hidden=true href=#direction>#</a></h3><p><code>direction</code>属性设置块级元素内部的文本阅读方向。</p><p>它的默认值是<code>ltr</code>（从左到右），适用于大部分语言。它还可以设成<code>rtl</code>（从右到左）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>blockquote</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>direction</span>: <span style=color:#66d9ef>rtl</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>一般采用 HTML 语言的<code>dir</code>属性控制文本阅读方向，而不是使用这个属性。</p><h3 id=text-align>text-align<a hidden class=anchor aria-hidden=true href=#text-align>#</a></h3><p><code>text-align</code>属性设置块级元素内部的文本对齐方式。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>text-align</span><span style=color:#f92672>:</span> <span style=color:#f92672>center</span><span style=color:#f92672>;</span>
</span></span></code></pre></div><p>它可以取以下值。</p><ul><li>left：默认值，文本向左对齐</li><li>right：右对齐</li><li>center：居中对齐</li><li>justify：两端对齐，除了最后一行是左对齐。即每行的左右两端都紧贴行的边缘。对尾行无效且子元素之间必须有空格或换行符。除了实现文字的两端对齐，还能用来做一些两端对齐的布局。</li><li>inherit：继承父元素的值</li><li>start：<code>direction</code>属性为从左到右时，为左对齐；从右到左时，为右对齐</li><li>end：<code>direction</code>属性为从左到右时，为右对齐；从右到左时，为左对齐</li></ul><h3 id=vertical-align-1>Vertical-align<a hidden class=anchor aria-hidden=true href=#vertical-align-1>#</a></h3><p><code>vertical-align</code>设置一个元素与在同一条水平线上的其他元素如何对齐。这些元素需要都是<code>inline</code>。它可以取以下值。</p><ul><li>baseline：对齐父元素的基线，默认值</li><li>length: 升高或降低特定的长度，可使用负值</li><li>%：升高或降低<code>line-height</code>的百分比，不允许负值</li><li>sub：设为下标</li><li>super：设为上标</li><li>top: 当前元素的顶部对齐最高元素的顶边</li><li>text-top：当前元素的顶部对齐父元素字体的顶部</li><li>middle：元素位于父元素的垂直中部</li><li>bottom：当前元素的底部对齐本行最低元素的底部</li><li>text-bottom：当前元素的底部，对齐父元素字体的底部</li><li>initial：设置为默认值</li><li>inherit：继承父元素的值</li></ul><p>这个属性通常用于同一行的图标与文字的对齐。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>vertical-align</span><span style=color:#f92672>:</span> <span style=color:#f92672>middle</span><span style=color:#f92672>;</span>
</span></span></code></pre></div><p>这个命令对设为<code>display: table-cell</code>的元素也有效，可以控制元素在单元格之中的垂直对齐方式。这时，一般使用<code>top</code>、<code>middle</code>和<code>bottom</code>等值。</p><h3 id=tab-size>Tab-size<a hidden class=anchor aria-hidden=true href=#tab-size>#</a></h3><p><code>tab-size</code>属性设置 Tab 键的宽度，可以设置为整数（表示多少个空格），也可以设置为具体的长度单位。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#75715e>/* 整数植 */</span>
</span></span><span style=display:flex><span><span style=color:#f92672>tab-size</span><span style=color:#f92672>:</span> <span style=color:#f92672>4</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>tab-size</span><span style=color:#f92672>:</span> <span style=color:#f92672>0</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 长度单位 */</span>
</span></span><span style=display:flex><span><span style=color:#f92672>tab-size</span><span style=color:#f92672>:</span> <span style=color:#f92672>10px</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>tab-size</span><span style=color:#f92672>:</span> <span style=color:#f92672>2em</span><span style=color:#f92672>;</span>
</span></span></code></pre></div><p>该属性常用于<code>&lt;pre></code>标签之中。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>pre</span> {<span style=color:#66d9ef>-moz-</span><span style=color:#66d9ef>tab-size</span>: <span style=color:#ae81ff>16</span>;} <span style=color:#75715e>/* Code for Firefox */</span>
</span></span><span style=display:flex><span><span style=color:#f92672>pre</span> {<span style=color:#66d9ef>-o-</span><span style=color:#66d9ef>tab-size</span>: <span style=color:#ae81ff>16</span>;} <span style=color:#75715e>/* Code for Opera 10.6-12.1 */</span>
</span></span><span style=display:flex><span><span style=color:#f92672>pre</span> {<span style=color:#66d9ef>tab-size</span>: <span style=color:#ae81ff>16</span>;}
</span></span></code></pre></div><h3 id=word-wrap>word-wrap<a hidden class=anchor aria-hidden=true href=#word-wrap>#</a></h3><p><code>word-wrap</code>的正式名称是<code>overflow-wrap</code>，用于规定是否可以在一个词内部断行，避免溢出容器。</p><p>它可以取两个值。</p><ul><li>normal：只在可以断行的地方断行。</li><li>break-word：可以在任意点断行，避免某个词过长，发生溢出。</li></ul><h3 id=word-break>word-break<a hidden class=anchor aria-hidden=true href=#word-break>#</a></h3><p><code>word-break</code>用于规定是否可以在词内断行。</p><p>它可以取三个值。</p><ul><li>normal：使用浏览器默认的断行规则</li><li>break-all：对于非 CJK 字符，可以任意字符之间断行。</li><li>keep-all：对于 CJK 字符不允许换行。非 CJK 字符与<code>normal</code>相同。</li></ul><h3 id=hyphens>hyphens<a hidden class=anchor aria-hidden=true href=#hyphens>#</a></h3><p>浏览器打开连字号功能，需要两个步骤。第一个步骤是设置文本的语言。这将告诉浏览器使用哪个连字词典，正确的自动连字需要一个适合文本语言的连字词典。如果浏览器不知道文本的语言，即使打开 CSS 设置也不会自动连词。</p><p>设置网页语言，应该使用<code>&lt;html></code>标签的<code>lang</code>属性。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>&lt;</span><span style=color:#f92672>html</span> <span style=color:#f92672>lang</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;en&#34;</span><span style=color:#f92672>&gt;</span>
</span></span></code></pre></div><p>CSS 里面使用自动连词，要开启<code>hyphens</code>属性。<code>hyphens</code>属性控制块级元素之中，文本是否显示连词线。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>hyphens</span><span style=color:#f92672>:</span> <span style=color:#f92672>auto</span><span style=color:#f92672>;</span>
</span></span></code></pre></div><p><code>hyphens</code>属性可以取以下三个值。</p><p><strong>none</strong></p><p><code>none</code>表示一个词不会在断行处被拆开，即断行处不会有连词线。</p><p><strong>manual</strong></p><p><code>manual</code>表示只有在一个词内部的字符表示可以有连词线时，才会在断行处拆开。断行处，会有连词线。</p><p>两个字符可以表示此处可以断行，并显示连词线，一个是<code>-</code>(U+2010)，表示此处可以有一个可见的断行，即使不在此处断行，这里也会有连词线显示；另一个是<code>U+00AD</code>，表示不可见的断行，HTML 文档里面可以用<code>&amp;shy;</code>插入。</p><p><strong>auto</strong></p><p><code>auto</code>表示浏览器决定一个词是否可以在断行处拆开，以及是否会有连词线。</p><h3 id=letter-spacing>letter-spacing<a hidden class=anchor aria-hidden=true href=#letter-spacing>#</a></h3><p>单个字母之间的间距</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>letter-spacing</span><span style=color:#f92672>:</span> <span style=color:#f92672>1px</span> <span style=color:#f92672>;</span>
</span></span></code></pre></div><ul><li><code>normal</code>：此间距是按照当前字体的正常间距确定的。和 0 不同的是，用户代理根据此属性来确定文字的默认对齐方式。</li><li><code>&lt;length></code>：指定文字间的间距以替代默认间距。可以是负值，但有可能会出现 implementation 限制。用户代理不会在此基础上进一步增加或缩减间距来对齐文字。</li></ul><h3 id=word-spacing>word-spacing<a hidden class=anchor aria-hidden=true href=#word-spacing>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>word-spacing</span><span style=color:#f92672>:</span> <span style=color:#f92672>1px</span><span style=color:#f92672>;</span>
</span></span></code></pre></div><p><code>word-spacing</code>指的是字符“空格”的间隙。如果一段文字中没有空格，则该属性无效。如中文文字下用<code>word-spacing</code> 没有效果的。</p><ul><li><code>normal</code>：正常的单词间距，由当前字体和/或浏览器定义。</li><li><code>&lt;length></code>：通过指定具体的额外间距来增加字体的单词间距。</li><li><code>&lt;percentage></code>：通过指定受影响字符的宽度的百分比的方式来增加的间距。</li></ul><h3 id=text-decoration>text-decoration<a hidden class=anchor aria-hidden=true href=#text-decoration>#</a></h3><p>文本可以附加装饰线（比如下划线），以下属性用来设置装饰线。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>text-decoration</span><span style=color:#f92672>:</span> <span style=color:#f92672>none</span><span style=color:#f92672>;</span>
</span></span></code></pre></div><ul><li>none：没有任何修饰</li><li>underline：下划线，默认线宽<code>1px</code></li><li>overline：上划线，默认线宽<code>1px</code></li><li>line-through：删除线，默认线宽<code>1px</code></li><li>inherit：继承父元素的设置</li></ul><p>多种装饰线可以同时存在。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>multiple</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>text-decoration</span>: <span style=color:#66d9ef>underline</span> <span style=color:#66d9ef>overline</span> <span style=color:#66d9ef>line-through</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>默认情况下，装饰线的颜色与文本的<code>color</code>属性一致。<code>text-decoration-color</code>属性可以修改颜色。</p><p><code>text-decoration</code>属性还可以用作<code>text-decoration-style</code>和<code>text-decoration-color</code>的简写形式。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>fancy-underline</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>text-decoration-line</span>: <span style=color:#66d9ef>underline</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>text-decoration-style</span>: <span style=color:#66d9ef>wavy</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>text-decoration-color</span>: <span style=color:#66d9ef>red</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* 等同于 */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>text-decoration</span>: <span style=color:#66d9ef>underline</span> <span style=color:#66d9ef>wavy</span> <span style=color:#66d9ef>red</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>text-decoration-color</strong></p><p><code>text-decoration-color</code>设置文本的装饰线的颜色。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>a</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>text-decoration-color</span>: <span style=color:#ae81ff>#E18728</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>text-decoration-style</strong></p><p><code>text-decoration-style</code>设置文本的下划线（underline）、上划线（overline）和删除线（line-through）的样式。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>a</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>text-decoration-style</span>: <span style=color:#66d9ef>solid</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>该属性支持以下样式。</p><ul><li>solid：单条直线</li><li>double：双条直线</li><li>dotted：多个点组成的直线</li><li>dashed：多个短划线组成的直线</li><li>wavy：波浪线</li></ul><p><strong>text-decoration-line</strong></p><p><code>text-decoration-line</code>设置文本采用何种装饰线，与<code>text-decoration</code>单个值的写法相同。建议采用后者，因为浏览器的支持度更好。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>p</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>text-decoration-line</span>: <span style=color:#66d9ef>underline</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>它的取值参考<code>text-decoration</code>。</p><p><strong>text-decoration-skip</strong></p><p><code>text-decoration-skip</code>设置文本的装饰线应该在哪里中断，主要用于改善文本被装饰以后的可读性。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>a</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>text-decoration-skip</span>: <span style=color:#66d9ef>ink</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面代码中，下划线遇到英语字母<code>y</code>和<code>p</code>会中断，让它们较长的下划会更清晰地显示出来。</p><p>该属性可以取以下值。</p><ul><li>objects：默认值，装饰线遇到图片或其他<code>inline-block</code>对象时中断。</li><li>none：装饰线不会有任何中断，包括遇到行内对象。</li><li>spaces：装饰线在空格、断词处中断。</li><li>ink：装饰线遇到有笔画下降或上升的字母时中断。</li><li>edges：装饰线在内容开始后和结束前都收缩一点，主要用于多个连续的装饰线，可以看上去连成一条。</li><li>box-decoration：装饰线在继承的 margin、border 和 padding 处中断。</li></ul><h3 id=color>color<a hidden class=anchor aria-hidden=true href=#color>#</a></h3><p>字体颜色</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>color</span>:<span style=color:#a6e22e>red</span><span style=color:#f92672>;</span>
</span></span></code></pre></div><h3 id=text-transform>text-transform<a hidden class=anchor aria-hidden=true href=#text-transform>#</a></h3><p><code>text-transform</code> 属性可以改变英文字母的大小写。 使用这个属性时，我们无需改变 HTML 元素中的文本也可以统一页面里英文的显示。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>text-transform</span><span style=color:#f92672>:</span> <span style=color:#f92672>lowercase</span><span style=color:#f92672>;</span>
</span></span></code></pre></div><table><thead><tr><th>值</th><th>结果</th></tr></thead><tbody><tr><td><code>lowercase</code></td><td>&ldquo;transform me&rdquo;</td></tr><tr><td><code>uppercase</code></td><td>&ldquo;TRANSFORM ME&rdquo;</td></tr><tr><td><code>capitalize</code></td><td>&ldquo;Transform Me&rdquo;</td></tr><tr><td><code>initial</code></td><td>使用默认值</td></tr><tr><td><code>inherit</code></td><td>使用父元素的 <code>text-transform</code> 值。</td></tr><tr><td><code>none</code></td><td>Default:不改变文字。</td></tr></tbody></table><p><strong>应用</strong></p><p>假设有个输入框只能输入大写字母，那么如下设置，输入小写字母出现的却是大写字母，可用于身份证输入框或验证码输入框等：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>input</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>text-transform</span>: <span style=color:#66d9ef>uppercase</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=text-shadow>text-shadow<a hidden class=anchor aria-hidden=true href=#text-shadow>#</a></h3><p>设置文本的阴影。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>text-shadow</span><span style=color:#f92672>:</span> <span style=color:#f92672>20px</span> <span style=color:#f92672>27px</span> <span style=color:#f92672>22px</span> <span style=color:#f92672>pink</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 水平位移 垂直位移 模糊程度 阴影颜色 */</span>
</span></span></code></pre></div><h3 id=text-indent>text-indent<a hidden class=anchor aria-hidden=true href=#text-indent>#</a></h3><p>text-indent 属性能定义一个块元素首行文本内容之前的缩进量。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#75715e>/* &lt;length&gt; 长度值 */</span>
</span></span><span style=display:flex><span><span style=color:#f92672>text-indent</span><span style=color:#f92672>:</span> <span style=color:#f92672>3mm</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>text-indent</span><span style=color:#f92672>:</span> <span style=color:#f92672>40px</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* &lt;percentage&gt;百分比值取决于其包含块（containing block）的宽度*/</span>
</span></span><span style=display:flex><span><span style=color:#f92672>text-indent</span><span style=color:#f92672>:</span> <span style=color:#f92672>15</span><span style=color:#f92672>%;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 关键字 */</span>
</span></span><span style=display:flex><span><span style=color:#f92672>text-indent</span><span style=color:#f92672>:</span> <span style=color:#f92672>5em</span> <span style=color:#f92672>each-line</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>text-indent</span><span style=color:#f92672>:</span> <span style=color:#f92672>5em</span> <span style=color:#f92672>hanging</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>text-indent</span><span style=color:#f92672>:</span> <span style=color:#f92672>5em</span> <span style=color:#f92672>hanging</span> <span style=color:#f92672>each-line</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 全局值 */</span>
</span></span><span style=display:flex><span><span style=color:#f92672>text-indent</span><span style=color:#f92672>:</span> <span style=color:#f92672>inherit</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>text-indent</span><span style=color:#f92672>:</span> <span style=color:#f92672>initial</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>text-indent</span><span style=color:#f92672>:</span> <span style=color:#f92672>unset</span><span style=color:#f92672>;</span>
</span></span></code></pre></div><ul><li>each-line：文本缩进会影响第一行，以及使用<code>&lt;br></code>强制断行后的第一行。</li><li>hanging：该值会对所有的行进行反转缩进：除了第一行之外的所有的行都会被缩进，看起来就像第一行设置了一个负的缩进值。</li></ul><h3 id=text-overflow>text-overflow<a hidden class=anchor aria-hidden=true href=#text-overflow>#</a></h3><p>该属性定义了文本超出容器宽度后，如何处理。如果将多余文字显示成三点的省略号，可以像下面这样设置。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>ellipsis</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>overflow</span>: <span style=color:#66d9ef>hidden</span>; 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>white-space</span>: <span style=color:#66d9ef>nowrap</span>; 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>text-overflow</span>: <span style=color:#66d9ef>ellipsis</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面代码第一行是隐藏溢出，第二行是防止断行，第三行是在行尾加上省略号。</p><h3 id=initial-letter>initial-letter<a hidden class=anchor aria-hidden=true href=#initial-letter>#</a></h3><p><code>initial-letter</code>决定首字母的下沉样式。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#75715e>/* 默认值 */</span>
</span></span><span style=display:flex><span><span style=color:#f92672>initial-letter</span><span style=color:#f92672>:</span> <span style=color:#f92672>normal</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 占据1.5行高度 */</span>
</span></span><span style=display:flex><span><span style=color:#f92672>initial-letter</span><span style=color:#f92672>:</span> <span style=color:#f92672>1</span>.<span style=color:#a6e22e>5</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 占据3行高度 */</span>
</span></span><span style=display:flex><span><span style=color:#f92672>initial-letter</span><span style=color:#f92672>:</span> <span style=color:#f92672>3</span>.<span style=color:#a6e22e>0</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 占据3行高度，下沉2行高度 */</span>
</span></span><span style=display:flex><span><span style=color:#f92672>initial-letter</span><span style=color:#f92672>:</span> <span style=color:#f92672>3</span>.<span style=color:#a6e22e>0</span> <span style=color:#f92672>2</span><span style=color:#f92672>;</span>
</span></span></code></pre></div><h3 id=user-select>user-select<a hidden class=anchor aria-hidden=true href=#user-select>#</a></h3><p><code>user-select</code> 属性控制用户能否选中文本。值为 <code>none</code>，元素及其子元素的文本不可选中。</p><h3 id=cursor>cursor<a hidden class=anchor aria-hidden=true href=#cursor>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>cursor</span><span style=color:#f92672>:</span> <span style=color:#f92672>pointer</span><span style=color:#f92672>;</span>
</span></span></code></pre></div><ul><li>auto：默认值。浏览器根据当前情况自动确定鼠标光标类型。</li><li>pointer：竖起食指的手形光标。</li><li>hand：竖起食指的手形光标。</li><li>all-scroll：上下左右四个箭头，中间有一个圆点的光标。用于标示页面可以向上下左右任何方向滚动。</li><li>col-resize：左右两个箭头，中间由竖线分隔开的光标。用于标示项目或标题栏可以被水平改变尺寸。</li><li>crosshair：简单的十字线光标。</li><li>default：客户端平台的默认光标。通常是一个箭头。</li><li>move ：十字箭头光标。用于标示对象可被移动。</li><li>help： 带有问号标记的箭头。用于标示有帮助信息存在。</li><li>no-drop：带有一个被斜线贯穿的圆圈的手形光标。用于标示被拖起的对象不允许在光标的当前位置被放下。</li><li>not-allowed：禁止标记(一个被斜线贯穿的圆圈)光标。用于标示请求的操作不允许被执行。</li><li>progress：带有沙漏标记的箭头光标。用于标示一个进程正在后台运行。</li><li>row-resize：IE6.0 有上下两个箭头，中间由横线分隔开的光标。用于标示项目或标题栏可以被垂直改变尺寸。</li><li>text ： 用于标示可编辑的水平文本的光标。通常是大写字母 I 的形状。</li><li>vertical-text ：用于标示可编辑的垂直文本的光标。通常是大写字母 I 旋转90度的形状。</li><li>wait：用于标示程序忙用户需要等待的光标。通常是沙漏或手表的形状。</li><li>*-resize：用于标示对象可被改变尺寸方向的箭头光标。（w-resize | s-resize | n-resize | e-resize | ne-resize | sw-resize | se-resize | nw-resize）</li><li>url ( url ) ：用户自定义光标。使用绝对或相对 url 地址指定光标文件。</li></ul><h3 id=pointer-events>pointer-events<a hidden class=anchor aria-hidden=true href=#pointer-events>#</a></h3><p>该属性定义当前图形对象会不会成为鼠标动作的目标。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#75715e>/* 图片将对鼠标行为无反应 */</span>
</span></span><span style=display:flex><span><span style=color:#f92672>img</span> {
</span></span><span style=display:flex><span>  pointer-events: <span style=color:#66d9ef>none</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>a</span><span style=color:#f92672>[</span><span style=color:#f92672>href</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;http://example.com&#34;</span><span style=color:#f92672>]</span> {
</span></span><span style=display:flex><span>  pointer-events: <span style=color:#66d9ef>none</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>一旦pointer-events设为none，就不会触发JavaScript事件。在该元素上点击，任何addEventListener添加的回调函数，都不会触发</p><h2 id=列表属性>列表属性<a hidden class=anchor aria-hidden=true href=#列表属性>#</a></h2><h3 id=list-style-image>list-style-image<a hidden class=anchor aria-hidden=true href=#list-style-image>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>list-style-image</span><span style=color:#f92672>:</span> <span style=color:#f92672>url</span><span style=color:#f92672>(</span><span style=color:#f92672>images</span>.<span style=color:#a6e22e>gif</span><span style=color:#f92672>);</span>
</span></span></code></pre></div><h3 id=list-style-type>list-style-type<a hidden class=anchor aria-hidden=true href=#list-style-type>#</a></h3><p>CSS 属性 list-style-type 可以设置列表元素的 marker（比如圆点、符号、或者自定义计数器样式）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>list-style-type</span><span style=color:#f92672>:</span> <span style=color:#f92672>none</span>
</span></span></code></pre></div><p>不显示列表项的标记。</p><h3 id=list-style-position>list-style-position<a hidden class=anchor aria-hidden=true href=#list-style-position>#</a></h3><p>list-style-position属性指示如何相对于对象的内容绘制列表项标记。</p><p><img loading=lazy src=/CSS/list-style-position.jpg alt=img></p><h2 id=背景属性>背景属性<a hidden class=anchor aria-hidden=true href=#背景属性>#</a></h2><p>如果不定义背景图片或者背景色，一个网页元素的背景就是透明的。</p><h3 id=opaque>opaque<a hidden class=anchor aria-hidden=true href=#opaque>#</a></h3><p><code>opaque</code>的值在0到100之间。默认值是100，表示百分之百不透明，而0表示百分之百透明。</p><h3 id=background-color>background-color<a hidden class=anchor aria-hidden=true href=#background-color>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>background-color</span><span style=color:#f92672>:</span> <span style=color:#f92672>red</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>background-color</span><span style=color:#f92672>:</span> <span style=color:#f92672>rgb</span><span style=color:#f92672>(</span><span style=color:#f92672>255</span><span style=color:#f92672>,</span><span style=color:#f92672>0</span><span style=color:#f92672>,</span><span style=color:#f92672>0</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>background-color</span><span style=color:#f92672>:</span> #ff0000<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>background-color</span><span style=color:#f92672>:</span> <span style=color:#f92672>rgba</span><span style=color:#f92672>(</span><span style=color:#f92672>0</span><span style=color:#f92672>,</span> <span style=color:#f92672>0</span><span style=color:#f92672>,</span> <span style=color:#f92672>255</span><span style=color:#f92672>,</span> <span style=color:#f92672>0</span>.<span style=color:#a6e22e>3</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>background-color</span><span style=color:#f92672>:</span> <span style=color:#f92672>hsla</span><span style=color:#f92672>(</span><span style=color:#f92672>240</span><span style=color:#f92672>,</span><span style=color:#f92672>50</span><span style=color:#f92672>%,</span><span style=color:#f92672>50</span><span style=color:#f92672>%,</span><span style=color:#f92672>0</span>.<span style=color:#a6e22e>4</span><span style=color:#f92672>);</span>
</span></span></code></pre></div><h3 id=background-image>background-image<a hidden class=anchor aria-hidden=true href=#background-image>#</a></h3><p>将图像设置为背景。 图片链接的地址应写在括号内，一般会用引号包起来。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>background-image</span>:<span style=color:#a6e22e>url</span><span style=color:#f92672>(</span><span style=color:#f92672>image</span>.<span style=color:#a6e22e>gif</span><span style=color:#f92672>);</span>
</span></span></code></pre></div><h4 id=gradienthttpwwwalloyteamcom201603css-gradient><a href=http://www.alloyteam.com/2016/03/css-gradient/>Gradient</a><a hidden class=anchor aria-hidden=true href=#gradienthttpwwwalloyteamcom201603css-gradient>#</a></h4><p><strong>前置知识</strong></p><ol><li><p>绘制区域，也就是规范中所谓的 <a href=https://drafts.csswg.org/css-images-3/#gradient-box>gradient box</a>（为了理解无歧义，下文不再翻译该术语），跟所关联 DOM 的实际尺寸有关，比如，设定 background 的话，绘制区域就是 DOM 的 padding box，除非用 backgroud-size 指定大小；如果是设定 list-style-image，绘制区域就是 1em 的正方形。</p></li><li><p>从 <a href=https://drafts.csswg.org/css-images-3/#gradients>W3C</a> 的描述中可以知道，浏览器实际是根据 Gradient 指定的语法来生成对应的图片</p><blockquote><pre><code>A gradient is an image that smoothly fades from one color to another. 
</code></pre></blockquote><p>而且不只 background 可以用，比如</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>background</span><span style=color:#f92672>:</span> <span style=color:#f92672>linear-gradient</span><span style=color:#f92672>(</span><span style=color:#f92672>white</span><span style=color:#f92672>,</span> <span style=color:#f92672>gray</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>list-style-image</span><span style=color:#f92672>:</span> <span style=color:#f92672>radial-gradient</span><span style=color:#f92672>(</span><span style=color:#f92672>circle</span><span style=color:#f92672>,</span> #006<span style=color:#f92672>,</span> #00a <span style=color:#f92672>90</span><span style=color:#f92672>%,</span> #0000af <span style=color:#f92672>100</span><span style=color:#f92672>%,</span> <span style=color:#f92672>white</span> <span style=color:#f92672>100</span><span style=color:#f92672>%);</span>
</span></span></code></pre></div></li><li><p>由于是 image，所以用于 background 时，实际是设置在 background-image 上</p></li></ol><p><strong>线性渐变（linear-gradient）</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>background-image</span><span style=color:#f92672>:</span> <span style=color:#f92672>linear-gradient</span><span style=color:#f92672>(</span><span style=color:#960050;background-color:#1e0010>方向</span><span style=color:#f92672>,</span> <span style=color:#960050;background-color:#1e0010>起始颜色</span><span style=color:#f92672>,</span> <span style=color:#960050;background-color:#1e0010>终止颜色</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>background</span><span style=color:#f92672>:</span> <span style=color:#f92672>linear-gradient</span><span style=color:#f92672>(</span><span style=color:#f92672>90deg</span><span style=color:#f92672>,</span> <span style=color:#f92672>red</span><span style=color:#f92672>,</span> <span style=color:#f92672>yellow</span><span style=color:#f92672>,</span> <span style=color:#f92672>rgb</span><span style=color:#f92672>(</span><span style=color:#f92672>204</span><span style=color:#f92672>,</span> <span style=color:#f92672>204</span><span style=color:#f92672>,</span> <span style=color:#f92672>255</span><span style=color:#f92672>));</span>
</span></span></code></pre></div><p>语法如下：</p><pre tabindex=0><code>linear-gradient() = linear-gradient(
  [ | to ]?,
  &lt;color-stop-list&gt;
)
&lt;side-or-corner&gt; = [left | right] || [top | bottom]
</code></pre><p>第一个参数指明了颜色渐变的方向：</p><ul><li>可以是角度，比如 <code>0deg</code>，表示正上方向，<code>90deg</code> 表示向右（顺时针方向 90°）</li><li>也可以是关键词，比如 <code>to top</code>, <code>to right</code>, <code>to bottom</code>, <code>to left</code> 分别对应了 0deg, 90deg, 180deg, 270deg。当然也可以不指定，默认值是 to bottom</li></ul><p>第二个参数指明了颜色断点（即 <a href=https://drafts.csswg.org/css-images-3/#color-stop>color-stop</a>）。位置可以省略，第一个默认为 0%，最后一个默认为 100%，如果中间的值没有指定，则按颜色数目求均值，比如</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>linear-gradient</span><span style=color:#f92672>(</span><span style=color:#f92672>red</span> <span style=color:#f92672>40</span><span style=color:#f92672>%,</span> <span style=color:#f92672>white</span><span style=color:#f92672>,</span> <span style=color:#f92672>black</span><span style=color:#f92672>,</span> <span style=color:#f92672>blue</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*等价于*/</span>
</span></span><span style=display:flex><span><span style=color:#f92672>linear-gradient</span><span style=color:#f92672>(</span><span style=color:#f92672>red</span> <span style=color:#f92672>40</span><span style=color:#f92672>%,</span> <span style=color:#f92672>white</span> <span style=color:#f92672>60</span><span style=color:#f92672>%,</span> <span style=color:#f92672>black</span> <span style=color:#f92672>80</span><span style=color:#f92672>%,</span> <span style=color:#f92672>blue</span> <span style=color:#f92672>100</span><span style=color:#f92672>%)</span>
</span></span></code></pre></div><p><strong>浏览器是如何绘制渐变线的呢？</strong></p><p>如下图，从 gradient box 的中心（对角线交点）开始以 CSS 中指定的角度向两侧延伸，终点是 gradient box 的一个相近顶点到 gradient line 垂线的垂足，起点也是类似的求法，两点间的距离就是 gradient line 的长度（浓浓的初中几何味~）。</p><p><img loading=lazy src=/CSS/Gradient32.png alt></p><p>所以，gradient line 的长度计算公式是：</p><pre tabindex=0><code>abs(W * sin(A)) + abs(H * cos(A))
A是角度，W是gradient box的宽，H为高
</code></pre><ul><li>栗子一：以下的写法效果其实都一样</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>  <span style=color:#f92672>background-image</span><span style=color:#f92672>:</span> <span style=color:#f92672>linear-gradient</span><span style=color:#f92672>(</span><span style=color:#f92672>yellow</span><span style=color:#f92672>,</span> <span style=color:#f92672>green</span><span style=color:#f92672>);</span> <span style=color:#f92672>//</span> <span style=color:#960050;background-color:#1e0010>默认方向为</span><span style=color:#f92672>to</span> <span style=color:#f92672>bottom</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>background-image</span><span style=color:#f92672>:</span> <span style=color:#f92672>linear-gradient</span><span style=color:#f92672>(</span><span style=color:#f92672>to</span> <span style=color:#f92672>bottom</span><span style=color:#f92672>,</span> <span style=color:#f92672>yellow</span><span style=color:#f92672>,</span> <span style=color:#f92672>green</span><span style=color:#f92672>);</span> <span style=color:#f92672>//</span> <span style=color:#960050;background-color:#1e0010>使用关键字指定方向</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>background-image</span><span style=color:#f92672>:</span> <span style=color:#f92672>linear-gradient</span><span style=color:#f92672>(</span><span style=color:#f92672>180deg</span><span style=color:#f92672>,</span> <span style=color:#f92672>yellow</span><span style=color:#f92672>,</span> <span style=color:#f92672>green</span><span style=color:#f92672>);</span> <span style=color:#f92672>//</span> <span style=color:#960050;background-color:#1e0010>使用角度指定方向</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>background-image</span><span style=color:#f92672>:</span> <span style=color:#f92672>linear-gradient</span><span style=color:#f92672>(</span><span style=color:#f92672>to</span> <span style=color:#f92672>top</span><span style=color:#f92672>,</span> <span style=color:#f92672>green</span><span style=color:#f92672>,</span> <span style=color:#f92672>yellow</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>background-image</span><span style=color:#f92672>:</span> <span style=color:#f92672>linear-gradient</span><span style=color:#f92672>(</span><span style=color:#f92672>to</span> <span style=color:#f92672>bottom</span><span style=color:#f92672>,</span> <span style=color:#f92672>yellow</span> <span style=color:#f92672>0</span><span style=color:#f92672>%,</span> <span style=color:#f92672>green</span> <span style=color:#f92672>100</span><span style=color:#f92672>%);</span> <span style=color:#f92672>//</span> <span style=color:#960050;background-color:#1e0010>指定颜色断点</span>
</span></span></code></pre></div><ul><li>栗子二：当然多个颜色断点也可以</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>background-image</span><span style=color:#f92672>:</span> <span style=color:#f92672>linear-gradient</span><span style=color:#f92672>(</span><span style=color:#f92672>to</span> <span style=color:#f92672>bottom</span><span style=color:#f92672>,</span> #FF0000 <span style=color:#f92672>14</span>.<span style=color:#a6e22e>28</span><span style=color:#f92672>%,</span> #FFA500 <span style=color:#f92672>14</span>.<span style=color:#a6e22e>28</span><span style=color:#f92672>%,</span> #FFA500 <span style=color:#f92672>28</span>.<span style=color:#a6e22e>57</span><span style=color:#f92672>%,</span> #FFFF00 <span style=color:#f92672>28</span>.<span style=color:#a6e22e>57</span><span style=color:#f92672>%,</span> #FFFF00 <span style=color:#f92672>42</span>.<span style=color:#a6e22e>85</span><span style=color:#f92672>%,</span> #008000 <span style=color:#f92672>42</span>.<span style=color:#a6e22e>85</span><span style=color:#f92672>%,</span> #008000 <span style=color:#f92672>57</span>.<span style=color:#a6e22e>14</span><span style=color:#f92672>%,</span> #0000FF <span style=color:#f92672>57</span>.<span style=color:#a6e22e>14</span><span style=color:#f92672>%,</span> #0000FF <span style=color:#f92672>71</span>.<span style=color:#a6e22e>42</span><span style=color:#f92672>%,</span> #4B0082 <span style=color:#f92672>71</span>.<span style=color:#a6e22e>42</span><span style=color:#f92672>%,</span> #4B0082 <span style=color:#f92672>85</span>.<span style=color:#a6e22e>71</span><span style=color:#f92672>%,</span> #800880 <span style=color:#f92672>85</span>.<span style=color:#a6e22e>71</span><span style=color:#f92672>%,</span> #800880 <span style=color:#f92672>100</span><span style=color:#f92672>%);</span>
</span></span></code></pre></div><p><img loading=lazy src=/CSS/Gradient52.png alt></p><p>这个例子还有个小技巧，Gradient 中两个不同颜色间默认是渐变的，但如果我们需要做出图中这种颜色明显变化的效果（锐变），就可以用同一个位置不同颜色的方式实现。</p><ul><li>栗子三：在颜色上设置透明度渐变</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>gradient-1</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>background-image</span>: url(<span style=color:#e6db74>http://a57.foxnews.com/global.fncstatic.com/static/managed/img/fn2/876/493/EmmaWatsonBrown.jpg</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>background-size</span>: <span style=color:#ae81ff>100</span><span style=color:#66d9ef>%</span> <span style=color:#ae81ff>100</span><span style=color:#66d9ef>%</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>gradient-2</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>background</span>: linear-gradient(<span style=color:#66d9ef>to</span> <span style=color:#66d9ef>right</span>, rgba(<span style=color:#ae81ff>255</span>, <span style=color:#ae81ff>255</span>, <span style=color:#ae81ff>255</span>, <span style=color:#ae81ff>0</span>), rgba(<span style=color:#ae81ff>255</span>, <span style=color:#ae81ff>255</span>, <span style=color:#ae81ff>255</span>, <span style=color:#ae81ff>1</span>)), url(<span style=color:#e6db74>http://a57.foxnews.com/global.fncstatic.com/static/managed/img/fn2/876/493/EmmaWatsonBrown.jpg</span>) <span style=color:#66d9ef>no-repeat</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>background-size</span>: <span style=color:#ae81ff>100</span><span style=color:#66d9ef>%</span> <span style=color:#ae81ff>100</span><span style=color:#66d9ef>%</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这个效果其实是利用了 <a href=https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Background_and_Borders/Using_CSS_multiple_backgrounds>CSS3 的多背景语法</a></p><p><strong>径向渐变（radial-gradient）</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>background-image</span><span style=color:#f92672>:</span> <span style=color:#f92672>radial-gradient</span><span style=color:#f92672>(</span><span style=color:#960050;background-color:#1e0010>辐射的半径大小</span> <span style=color:#960050;background-color:#1e0010>中心的位置</span><span style=color:#f92672>,</span> <span style=color:#960050;background-color:#1e0010>起始颜色</span><span style=color:#f92672>,</span> <span style=color:#960050;background-color:#1e0010>终止颜色</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>background-image</span><span style=color:#f92672>:</span> <span style=color:#f92672>radial-gradient</span><span style=color:#f92672>(</span><span style=color:#f92672>100px</span> <span style=color:#f92672>at</span> <span style=color:#f92672>center</span><span style=color:#f92672>,</span> <span style=color:#f92672>yellow</span><span style=color:#f92672>,</span> <span style=color:#f92672>green</span><span style=color:#f92672>);</span>
</span></span></code></pre></div><p>radial gradient 其实就是颜色从一个点以同心圆或者椭圆向外渐变。</p><p><img loading=lazy src=/CSS/Gradient72.png alt></p><p>简化版语法如下：</p><pre tabindex=0><code>radial-gradient() = radial-gradient(
  [ || ]? [ at ]? ,
  &lt;color-stop-list&gt;
)
</code></pre><ul><li><p>position 用来指定渐变圆心的位置，默认为 center，<a href=https://drafts.csswg.org/css-backgrounds-3/#position>赋值规则</a>与 background-positon 的类似；</p></li><li><p>ending-shape 可以是 circle 或者 elipse，如果省略，则默认值与 size 相关，size 指定一个值就是圆形，否则是椭圆；</p></li><li><p>size 可以是具体的值，也可以用关键字指定，默认值是 farthest-corner。如果是具体值，圆形需要一个数值，椭圆需要两个。关键字则包括：</p><ul><li>closest-side 指 gradient box 某一边到盒子中心最近的距离；</li><li>farthest-side 指 gradient box 某一边到盒子中心最远的距离；</li><li>closest-corner 指 gradient box 某一顶点到盒子中心最近的距离；</li><li>farthest-corner 指 gradient box 某一顶点到盒子中心最远的距离；</li></ul></li><li><p>color-stop-list 与 linear-gradient 类似</p></li></ul><p>注意：</p><ul><li>size 的数值不能是负数</li><li>W3C 规范规定，百分比的数值只能用于椭圆，不能用于圆形。</li><li>position 的值可以是负数</li></ul><p>栗子一：以下几种写法是等价的</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>gradient-1</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>background-image</span>: radial-gradient(<span style=color:#66d9ef>yellow</span>, <span style=color:#66d9ef>green</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>gradient-2</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>background-image</span>: radial-gradient(ellipse at <span style=color:#66d9ef>center</span>, <span style=color:#66d9ef>yellow</span> <span style=color:#ae81ff>0</span><span style=color:#66d9ef>%</span>, <span style=color:#66d9ef>green</span> <span style=color:#ae81ff>100</span><span style=color:#66d9ef>%</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>gradient-3</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>background-image</span>: radial-gradient(farthest<span style=color:#f92672>-</span>corner at <span style=color:#ae81ff>50</span><span style=color:#66d9ef>%</span> <span style=color:#ae81ff>50</span><span style=color:#66d9ef>%</span>, <span style=color:#66d9ef>yellow</span>, <span style=color:#66d9ef>green</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>gradient-4</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>background-image</span>: radial-gradient(ellipse farthest<span style=color:#f92672>-</span>corner at <span style=color:#ae81ff>50</span><span style=color:#66d9ef>%</span> <span style=color:#ae81ff>50</span><span style=color:#66d9ef>%</span>, <span style=color:#66d9ef>yellow</span>, <span style=color:#66d9ef>green</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>栗子二：看下 size 各种关键字的效果</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>gradient-1</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>background-image</span>: radial-gradient(<span style=color:#66d9ef>circle</span> closest<span style=color:#f92672>-</span>side at <span style=color:#ae81ff>30</span><span style=color:#66d9ef>%</span> <span style=color:#ae81ff>50</span><span style=color:#66d9ef>%</span>, <span style=color:#66d9ef>yellow</span>, <span style=color:#66d9ef>green</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>gradient-2</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>background-image</span>: radial-gradient(<span style=color:#66d9ef>circle</span> farthest<span style=color:#f92672>-</span>side at <span style=color:#ae81ff>30</span><span style=color:#66d9ef>%</span> <span style=color:#ae81ff>50</span><span style=color:#66d9ef>%</span>, <span style=color:#66d9ef>yellow</span>, <span style=color:#66d9ef>green</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>gradient-3</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>background-image</span>: radial-gradient(<span style=color:#66d9ef>circle</span> closest<span style=color:#f92672>-</span>corner at <span style=color:#ae81ff>30</span><span style=color:#66d9ef>%</span> <span style=color:#ae81ff>50</span><span style=color:#66d9ef>%</span>, <span style=color:#66d9ef>yellow</span>, <span style=color:#66d9ef>green</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>gradient-4</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>background-image</span>: radial-gradient(<span style=color:#66d9ef>circle</span> farthest<span style=color:#f92672>-</span>corner at <span style=color:#ae81ff>30</span><span style=color:#66d9ef>%</span> <span style=color:#ae81ff>50</span><span style=color:#66d9ef>%</span>, <span style=color:#66d9ef>yellow</span>, <span style=color:#66d9ef>green</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>圆心没设置在中心是因为矩形的对角线相等且平分，所以 closest-corner = farthest-corner，就没法比较差异了。</p><p><strong>重复渐变（Repeating Gradients）</strong></p><p>基本语法与上面的线性渐变和径向渐变类似，就是增加了重复的特性。</p><p>重复的规则简单说就是用最后一个颜色断点的位置减去第一个颜色断点位置的距离作为区间长度，不断的重复。比如 repeating-linear-gradient(red 10px, blue 50px) 就相当于 linear-gradient(&mldr;, red -30px, blue 10px, red 10px, blue 50px, red 50px, blue 90px, &mldr;)</p><p>至于首尾颜色距离为 0 等特殊情况，这里就不细说 了，可以到 <a href=https://drafts.csswg.org/css-images-3/#funcdef-repeating-radial-gradient>W3C 规范</a>自行研究。</p><h3 id=background-position>background-position<a hidden class=anchor aria-hidden=true href=#background-position>#</a></h3><p><code>background-position</code> 主要是用来指定背景图片在容器中的位置。大家较为熟悉的是，背景图片左上角（顶点）相对于容器左上角计算</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>background-position</span><span style=color:#f92672>:</span> <span style=color:#f92672>100px</span> <span style=color:#f92672>200px</span><span style=color:#f92672>;</span>		<span style=color:#75715e>/* 向右偏移量 向下偏移量 */</span>
</span></span></code></pre></div><p>不过，有的时候，希望背景图片能相对于容器右侧边缘或底部边缘计算</p><p>要让背景图片距离容器右侧边缘和底部边缘都是 <code>50px</code> 。针对这样的场景，你或许首先会想到使用容器大小和背景图片大小进行计算，得出距离顶部和左侧边缘的距离，然后将计算出来的值运用于 <code>background-position</code> 中。当然，熟悉 CSS 的同学或许会想到使用 <code>calc()</code> 函数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>:<span style=color:#a6e22e>root</span> {
</span></span><span style=display:flex><span>    --xPosition: <span style=color:#ae81ff>50</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>    --yPosition: <span style=color:#ae81ff>50</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>container</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>background-position</span>: calc(<span style=color:#ae81ff>100</span><span style=color:#66d9ef>%</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>var</span>(<span style=color:#f92672>--</span>xPosition)  calc(<span style=color:#ae81ff>100</span><span style=color:#66d9ef>%</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>var</span>(<span style=color:#f92672>--</span>yPosition)))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使用 <code>calc()</code> 动态计算要比通过容器和背景图片尺寸大小计算方便得多。事实上呢？<code>background-position</code> 提供了另一种特性，我们可以通过关键词 <code>top</code> 、<code>right</code> 、<code>bottom</code> 和 <code>left</code> 来指定方向。比如我们熟悉的用法 ：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>background-position</span><span style=color:#f92672>:</span> <span style=color:#f92672>50px</span> <span style=color:#f92672>50px</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>//</span> <span style=color:#960050;background-color:#1e0010>相当于</span>
</span></span><span style=display:flex><span><span style=color:#f92672>background-position</span><span style=color:#f92672>:</span> <span style=color:#f92672>top</span> <span style=color:#f92672>50px</span>  <span style=color:#f92672>left</span> <span style=color:#f92672>50px</span><span style=color:#f92672>;</span>
</span></span></code></pre></div><p>那么，我们要实现上图的效果，就可以使用 <code>right</code> 和 <code>bottom</code> 关键词，让事情变得非常简单：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>:<span style=color:#a6e22e>root</span> {
</span></span><span style=display:flex><span>	--xPosition: <span style=color:#ae81ff>50</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>    --yPosition: <span style=color:#ae81ff>50</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>container</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>background-position</span>: <span style=color:#66d9ef>right</span> <span style=color:#a6e22e>var</span>(<span style=color:#f92672>--</span>xPosition)  <span style=color:#66d9ef>bottom</span> <span style=color:#a6e22e>var</span>(<span style=color:#f92672>--</span>yPosition);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>background-position</code> 使用还有一个小细节需要注意，即 <code>background-position</code> 采用百分比值。因为使用百分比值的 <code>background-position</code> 计算会相对于其他单位值复杂：</p><p>背景图片原始尺寸是 <code>100px x 100px</code> ，容器的尺寸（使用该背景图片的元素）是 <code>410px x 210px</code> ，如果使用 <code>background-position: 75% 50%</code> 时，它的计算如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#75715e>/** background-position的x轴坐标 **/</span>
</span></span><span style=display:flex><span><span style=color:#f92672>x</span> <span style=color:#f92672>=</span> <span style=color:#f92672>(</span><span style=color:#960050;background-color:#1e0010>容器宽度</span> <span style=color:#f92672>-</span> <span style=color:#960050;background-color:#1e0010>背景图片宽度</span><span style=color:#f92672>)</span> <span style=color:#f92672>x</span> <span style=color:#f92672>background-position</span><span style=color:#960050;background-color:#1e0010>的</span><span style=color:#f92672>x</span><span style=color:#960050;background-color:#1e0010>坐标的百分比值</span> <span style=color:#f92672>=</span> <span style=color:#f92672>(</span><span style=color:#f92672>410</span> <span style=color:#f92672>-</span> <span style=color:#f92672>100</span><span style=color:#f92672>)</span> <span style=color:#f92672>x</span> <span style=color:#f92672>75</span><span style=color:#f92672>%</span> <span style=color:#f92672>=</span> <span style=color:#f92672>232</span>.<span style=color:#a6e22e>5px</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/** background-position的y轴坐标 **/</span>
</span></span><span style=display:flex><span><span style=color:#f92672>y</span> <span style=color:#f92672>=</span> <span style=color:#f92672>(</span><span style=color:#960050;background-color:#1e0010>容器高度</span> <span style=color:#f92672>-</span> <span style=color:#960050;background-color:#1e0010>背景图片高度</span><span style=color:#f92672>)</span> <span style=color:#f92672>x</span> <span style=color:#f92672>background-position</span><span style=color:#960050;background-color:#1e0010>的</span><span style=color:#f92672>y</span><span style=color:#960050;background-color:#1e0010>坐标的百分比值</span> <span style=color:#f92672>=</span> <span style=color:#f92672>(</span><span style=color:#f92672>210</span> <span style=color:#f92672>-</span> <span style=color:#f92672>100</span><span style=color:#f92672>)</span> <span style=color:#f92672>x</span> <span style=color:#f92672>50</span><span style=color:#f92672>%</span> <span style=color:#f92672>=</span> <span style=color:#f92672>55px</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>复制代码</span>
</span></span></code></pre></div><p>就该示例而言，<code>background-position: 75% 50%</code> 就相当于 <code>bacckground-position: 232.5px 55px</code>。</p><h3 id=background-size>background-size<a hidden class=anchor aria-hidden=true href=#background-size>#</a></h3><p>设置背景图片的尺寸。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>background-size</span><span style=color:#f92672>:</span> <span style=color:#f92672>500px</span> <span style=color:#f92672>500px</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>background-size</span><span style=color:#f92672>:</span> <span style=color:#f92672>50</span><span style=color:#f92672>%</span> <span style=color:#f92672>50</span><span style=color:#f92672>%;</span>	<span style=color:#75715e>/* 相对于容器的大小 */</span>
</span></span><span style=display:flex><span><span style=color:#f92672>background-size</span><span style=color:#f92672>:</span> <span style=color:#f92672>cover</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>background-size</span><span style=color:#f92672>:</span> <span style=color:#f92672>contain</span><span style=color:#f92672>;</span>
</span></span></code></pre></div><ul><li><code>cover</code>：图片始终填充满容器，且保证长宽比不变。图片如果有超出部分，则超出部分会被隐藏。</li><li><code>contain</code>：将图片完整地显示在容器中，且保证长宽比不变。可能会导致容器的部分区域留白</li></ul><h3 id=background-repeat>background-repeat<a hidden class=anchor aria-hidden=true href=#background-repeat>#</a></h3><p><code>background-repeat</code>指定当背景图片小于容器时的平铺方式。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>background-repeat</span><span style=color:#f92672>:</span> <span style=color:#f92672>no-repeat</span><span style=color:#f92672>;</span>
</span></span></code></pre></div><p>它可以取以下值。</p><ul><li>repeat：背景图片沿容器的X轴和Y轴平铺，将会平铺满整个容器。用 <code>repeat</code> 的时候，有可能会造成背景图片在平铺的时候被裁剪，会造成背景图片显示不全。</li><li>repeat-x： 背景图片沿容器的X轴平铺。</li><li>repeat-y：背景图片沿容器的Y轴平铺。</li><li>no-repeat：背景图片不做任何平铺。</li><li>round：背景图片沿容器的X轴和Y轴平铺，将会铺满整个容器。如果有多余空间，会升缩背景图片适应容器大小，不会造成图片显示不全。</li><li>space：背景图片沿容器的X轴和Y轴平铺，将会铺满整个容器。如果有多余空间，不会改变背景图片的大小，而是平均分配相邻图片之间的空间，不会造成图片显示不全。</li></ul><p><code>background-repeat</code>可以设置两个值，分别表示 X 轴和 Y 轴的重复方式。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>element</span> {
</span></span><span style=display:flex><span><span style=color:#75715e>/* background-repeat: horizontal vertical */</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>background-repeat</span>: <span style=color:#66d9ef>repeat</span> <span style=color:#66d9ef>space</span>;
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>background-repeat</span>: <span style=color:#66d9ef>repeat</span> <span style=color:#66d9ef>repeat</span>;
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>background-repeat</span>: <span style=color:#66d9ef>round</span> <span style=color:#66d9ef>space</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>background-repeat</code>只设置一个值的时候，其实是下面方式的简写。</p><ul><li><code>repeat</code>：相当于<code>repeat repeat</code></li><li><code>repeat-x</code>：相当于<code>repeat-x no-repeat</code></li><li><code>repeat-y</code>：相当于<code>no-repeat repeat</code></li><li><code>no-repeat</code>：相当于<code>no-repeat no-repeat</code></li><li><code>space</code>：相当于<code>space space</code></li><li><code>round</code>：相当于<code>round round</code></li></ul><h3 id=background-attachment>background-attachment<a hidden class=anchor aria-hidden=true href=#background-attachment>#</a></h3><p><code>background-attachment</code>属性设置背景图案的位置，是否在视口里面是固定的，也就是说，是否随着滚动条一起滚动。由于存在两种滚动条——视口的滚动条和区块的滚动条——因此<code>background-attachment</code>的行为有三种模式，对应三个属性值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>background-attachment</span><span style=color:#f92672>:</span> <span style=color:#f92672>scroll</span><span style=color:#f92672>;</span>
</span></span></code></pre></div><ul><li><code>scroll</code>：这个是默认值，表示背景图片绑定区块的内容，会随着视口滚动条滚动，但不会随着区块滚动条滚动。</li><li><code>fixed</code>：背景图片绑定视口，不会随着视口滚动条和区块滚动条滚动。</li><li><code>local</code>：背景图片会随着视口滚动条和区块滚动条滚动。</li></ul><h3 id=background-origin>background-origin<a hidden class=anchor aria-hidden=true href=#background-origin>#</a></h3><p>控制背景从什么地方开始显示。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>background-origin</span><span style=color:#f92672>:</span> <span style=color:#f92672>padding-box</span><span style=color:#f92672>;</span>		<span style=color:#75715e>/* 从 padding-box 开始显示背景图 */</span>
</span></span><span style=display:flex><span><span style=color:#f92672>background-origin</span><span style=color:#f92672>:</span> <span style=color:#f92672>border-box</span><span style=color:#f92672>;</span>		<span style=color:#75715e>/* 从 border-box 开始显示背景图  */</span>
</span></span><span style=display:flex><span><span style=color:#f92672>background-origin</span><span style=color:#f92672>:</span> <span style=color:#f92672>content-box</span><span style=color:#f92672>;</span>		<span style=color:#75715e>/* 从 content-box 区域开始显示背景图  */</span>
</span></span></code></pre></div><h3 id=background-clip>background-clip<a hidden class=anchor aria-hidden=true href=#background-clip>#</a></h3><p>设置元素的背景（背景图片或颜色）是否延伸到边框下面。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>background-clip: content-box;
</span></span></code></pre></div><ul><li><p><code>border-box</code>：超出 border-box 的部分，将裁剪掉</p></li><li><p><code>padding-box</code>：超出 padding-box 的部分，将裁剪掉</p></li><li><p><code>content-box</code>：超出 content-box 的部分，将裁剪掉</p></li></ul><h3 id=backgroundhttpsjuejincnpost6844903463273381901><a href=https://juejin.cn/post/6844903463273381901>background</a><a hidden class=anchor aria-hidden=true href=#backgroundhttpsjuejincnpost6844903463273381901>#</a></h3><p>background简写属性在一个声明中可设置所有的背景属性。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>background</span><span style=color:#f92672>:</span> <span style=color:#f92672>bg-color</span> <span style=color:#f92672>||</span> <span style=color:#f92672>bg-image</span> <span style=color:#f92672>||</span> <span style=color:#f92672>bg-position</span> <span style=color:#f92672>[</span> <span style=color:#f92672>/</span> <span style=color:#f92672>bg-size</span><span style=color:#f92672>]?</span> <span style=color:#f92672>||</span> <span style=color:#f92672>bg-repeat</span> <span style=color:#f92672>||</span> <span style=color:#f92672>bg-attachment</span> <span style=color:#f92672>||</span> <span style=color:#f92672>bg-origin</span> <span style=color:#f92672>||</span> <span style=color:#f92672>bg-clip</span>
</span></span></code></pre></div><p>可设置属性如下:</p><ul><li><code>background-color</code>: 指定背景颜色。</li><li><code>background-image</code>: 设置背景图像, 可以是真实的图片路径, 也可以是创建的渐变背景;</li><li><code>background-position</code>: 设置背景图像的位置;</li><li><code>background-size</code>: 设置背景图像的大小;</li><li><code>background-repeat</code>: 指定背景图像的铺排方式;</li><li><code>background-attachment</code>: 指定背景图像是滚动还是固定;</li><li><code>background-origin</code>: 设置背景图像显示的原点[background-position相对定位的原点];</li><li><code>background-clip</code>: 设置背景图像向外剪裁的区域;</li><li><code>background: transparent;</code> ：可以设置完全透明。</li></ul><p>background是一个复合属性, 可设置多组属性, 每组属性间使用逗号分隔, 其中<strong>背景颜色不能设置多个且只能放在最后一组</strong>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>background</span><span style=color:#f92672>:</span> <span style=color:#f92672>url</span><span style=color:#f92672>(</span><span style=color:#f92672>image1</span>.<span style=color:#a6e22e>jpg</span><span style=color:#f92672>)</span> <span style=color:#f92672>no-repeat</span> <span style=color:#f92672>100px</span> <span style=color:#f92672>100px</span> <span style=color:#f92672>fixed</span><span style=color:#960050;background-color:#1e0010>，</span>
</span></span><span style=display:flex><span>			<span style=color:#f92672>url</span><span style=color:#f92672>(</span><span style=color:#f92672>image2</span>.<span style=color:#a6e22e>png</span><span style=color:#f92672>)</span> <span style=color:#f92672>no-repeat</span> <span style=color:#f92672>right</span> <span style=color:#f92672>top</span><span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>url</span><span style=color:#f92672>(</span><span style=color:#f92672>image3</span>.<span style=color:#a6e22e>png</span><span style=color:#f92672>)</span> <span style=color:#f92672>no-repeat</span> <span style=color:#f92672>right</span> <span style=color:#f92672>bottom</span><span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>url</span><span style=color:#f92672>(</span><span style=color:#f92672>image4</span>.<span style=color:#a6e22e>png</span><span style=color:#f92672>)</span> <span style=color:#f92672>no-repeat</span> <span style=color:#f92672>left</span> <span style=color:#f92672>bottom</span><span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>url</span><span style=color:#f92672>(</span><span style=color:#f92672>image5</span>.<span style=color:#a6e22e>png</span><span style=color:#f92672>)</span> <span style=color:#f92672>no-repeat</span> <span style=color:#f92672>center</span> <span style=color:#f92672>red</span><span style=color:#f92672>;</span>
</span></span></code></pre></div><p>可以给一个盒子同时设置多个背景，用以逗号隔开即可。</p><h3 id=background-blend-mode>background-blend-mode<a hidden class=anchor aria-hidden=true href=#background-blend-mode>#</a></h3><p><code>background-blend-mode</code>用于指定两种颜色混合的方式。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>div</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>background</span>: url(<span style=color:#e6db74>img/pattern.png</span>), url(<span style=color:#e6db74>img/jellyfish.jpg</span>), <span style=color:#ae81ff>#f07e32</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>background-blend-mode</span>: <span style=color:#66d9ef>screen</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=mix-blend-mode>mix-blend-mode<a hidden class=anchor aria-hidden=true href=#mix-blend-mode>#</a></h3><p>mix-blend-mode属性指定前景与背景的颜色混合模式，即前景色与背景色的混合。它的取值同background-blend-mode属性一样，也是16个值。</p><h2 id=filter>filter<a hidden class=anchor aria-hidden=true href=#filter>#</a></h2><p>filter属性在指定元素上应用滤镜。</p><ul><li>none：默认值，没有效果。</li><li>url()：引用定义在SVG文件中的滤镜</li><li>blur(<em>px</em>)：给图像设置高斯模糊，参数为模糊半径，如果没有设定值，则默认是0；这个参数可设置css长度值，但不接受百分比值。</li><li>brightness(<em>%</em>)：给图片应用一种线性乘法，使其看起来更亮或更暗，0%为全黑，100%为原始亮度，值超过100%也是可以的，图像会比原来更亮。如果没有设定值，默认是1。</li><li>contrast(<em>%</em>)：对比度，0%为全黑，100%为原始对比度，值可以超过100%，意味着会运用更低的对比。若没有设置值，默认是1。</li><li>drop-shadow(<em>h-shadow v-shadow blur spread color</em>)：阴影效果，设置同box-shadow接近</li><li>grayscale(<em>%</em>)：将图像转换为灰度图像，0%为原始色彩，100%为完全灰度。若未设置，值默认是0。</li><li>hue-rotate(<em>deg</em>)： 给图像应用色相旋转，0为原始色调，360为色彩轮旋转一周后回到原色调。若值未设置，默认值是0deg。</li><li>invert(<em>%</em>)：色调分离，负片效果，0%为原始效果，100%为完全负片效果。若值未设置，值默认是0。</li><li>opacity(<em>%</em>)：透明度，0%为完全透明，100%为完全不透明。若值未设置，值默认是1。该函数与已有的opacity属性很相似，不同之处在于通过filter，一些浏览器为了提升性能会提供硬件加速。</li><li>saturate(<em>%</em>)：饱和度，0%为完全不饱和，100%为完全饱和。超过100%的值是允许的，则有更高的饱和度。若值未设置，值默认是1。</li><li>sepia(<em>%</em>)：加入褐色色调，作旧效果，0%为原始效果，100%为完全作旧。若未设置，值默认是0。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>filter</span><span style=color:#f92672>:</span> <span style=color:#f92672>url</span><span style=color:#f92672>(</span><span style=color:#f92672>resources</span>.<span style=color:#a6e22e>svg</span>#c1<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>filter</span><span style=color:#f92672>:</span> <span style=color:#f92672>blur</span><span style=color:#f92672>(</span><span style=color:#f92672>5px</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>filter</span><span style=color:#f92672>:</span> <span style=color:#f92672>brightness</span><span style=color:#f92672>(</span><span style=color:#f92672>0</span>.<span style=color:#a6e22e>5</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>filter</span><span style=color:#f92672>:</span> <span style=color:#f92672>contrast</span><span style=color:#f92672>(</span><span style=color:#f92672>200</span><span style=color:#f92672>%);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>filter</span><span style=color:#f92672>:</span> <span style=color:#f92672>drop-shadow</span><span style=color:#f92672>(</span><span style=color:#f92672>16px</span> <span style=color:#f92672>16px</span> <span style=color:#f92672>10px</span> <span style=color:#f92672>black</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>filter</span><span style=color:#f92672>:</span> <span style=color:#f92672>grayscale</span><span style=color:#f92672>(</span><span style=color:#f92672>50</span><span style=color:#f92672>%);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>filter</span><span style=color:#f92672>:</span> <span style=color:#f92672>hue-rotate</span><span style=color:#f92672>(</span><span style=color:#f92672>90deg</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>filter</span><span style=color:#f92672>:</span> <span style=color:#f92672>invert</span><span style=color:#f92672>(</span><span style=color:#f92672>100</span><span style=color:#f92672>%);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>filter</span><span style=color:#f92672>:</span> <span style=color:#f92672>opacity</span><span style=color:#f92672>(</span><span style=color:#f92672>50</span><span style=color:#f92672>%);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>filter</span><span style=color:#f92672>:</span> <span style=color:#f92672>saturate</span><span style=color:#f92672>(</span><span style=color:#f92672>200</span><span style=color:#f92672>%);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>filter</span><span style=color:#f92672>:</span> <span style=color:#f92672>sepia</span><span style=color:#f92672>(</span><span style=color:#f92672>100</span><span style=color:#f92672>%);</span>
</span></span></code></pre></div><p>多个滤镜可以联合使用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>filter</span><span style=color:#f92672>:</span> <span style=color:#f92672>sepia</span><span style=color:#f92672>(</span><span style=color:#f92672>1</span><span style=color:#f92672>)</span> <span style=color:#f92672>brightness</span><span style=color:#f92672>(</span><span style=color:#f92672>150</span><span style=color:#f92672>%)</span> <span style=color:#f92672>contrast</span><span style=color:#f92672>(</span><span style=color:#f92672>0</span>.<span style=color:#a6e22e>5</span><span style=color:#f92672>);</span>
</span></span></code></pre></div><h2 id=动画>动画<a hidden class=anchor aria-hidden=true href=#动画>#</a></h2><h3 id=transitionhttpswwwruanyifengcomblog201402css_transition_and_animationhtml><a href=https://www.ruanyifeng.com/blog/2014/02/css_transition_and_animation.html>transition</a><a hidden class=anchor aria-hidden=true href=#transitionhttpswwwruanyifengcomblog201402css_transition_and_animationhtml>#</a></h3><pre tabindex=0><code>transition: [property] [transition-duration] [transition-timing-function] [transition-delay];
</code></pre><h4 id=基本用法>基本用法<a hidden class=anchor aria-hidden=true href=#基本用法>#</a></h4><p>在CSS 3引入Transition（过渡）这个概念之前，CSS是没有时间轴的。也就是说，所有的状态变化，都是即时完成。</p><p>下面是代码，相当简单。当鼠标放置于缩略图之上，缩略图会迅速变大。注意，缩略图的变大是瞬间实现的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>img</span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>height</span>:<span style=color:#ae81ff>15</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>width</span>:<span style=color:#ae81ff>15</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>img</span>:<span style=color:#a6e22e>hover</span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>height</span>: <span style=color:#ae81ff>450</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>width</span>: <span style=color:#ae81ff>450</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>transition的作用在于，指定状态变化所需要的时间。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>img</span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>transition</span>: <span style=color:#ae81ff>1</span><span style=color:#66d9ef>s</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面代码指定，图片放大的过程需要1秒。</p><p>我们还可以指定transition适用的属性，比如只适用于height。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>img</span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>transition</span>: <span style=color:#ae81ff>1</span><span style=color:#66d9ef>s</span> <span style=color:#66d9ef>height</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这样一来，只有height的变化需要1秒实现，其他变化（主要是width）依然瞬间实现，效果如下。</p><h4 id=transition-delay>transition-delay<a hidden class=anchor aria-hidden=true href=#transition-delay>#</a></h4><p>在同一行transition语句中，可以分别指定多个属性。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>img</span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>transition</span>: <span style=color:#ae81ff>1</span><span style=color:#66d9ef>s</span> <span style=color:#66d9ef>height</span>, <span style=color:#ae81ff>1</span><span style=color:#66d9ef>s</span> <span style=color:#66d9ef>width</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>但是，这样一来，height和width的变化是同时进行的，跟不指定它们没有差别。</p><p>我们希望，让height先发生变化，等结束以后，再让width发生变化。实现这一点很容易，就是为width指定一个delay参数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>img</span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>transition</span>: <span style=color:#ae81ff>1</span><span style=color:#66d9ef>s</span> <span style=color:#66d9ef>height</span>, <span style=color:#ae81ff>1</span><span style=color:#66d9ef>s</span> <span style=color:#ae81ff>1</span><span style=color:#66d9ef>s</span> <span style=color:#66d9ef>width</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面代码指定，width在1秒之后，再开始变化，也就是延迟（delay）1秒。</p><p>delay的真正意义在于，它指定了动画发生的顺序，使得多个不同的transition可以连在一起，形成复杂效果。</p><h4 id=transition-timing-function>transition-timing-function<a hidden class=anchor aria-hidden=true href=#transition-timing-function>#</a></h4><p>transition的状态变化速度（又称timing function），默认不是匀速的，而是逐渐放慢，这叫做ease。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>img</span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>transition</span>: <span style=color:#ae81ff>1</span><span style=color:#66d9ef>s</span> <span style=color:#66d9ef>ease</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>除了ease以外，其他模式还包括</p><p>（1）linear：匀速</p><p>（2）ease-in：加速</p><p>（3）ease-out：减速</p><p>（4）cubic-bezier函数：自定义速度模式</p><p>最后那个cubic-bezier，可以使用<a href=http://cubic-bezier.com/>工具网站</a>来定制。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>img</span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>transition</span>: <span style=color:#ae81ff>1</span><span style=color:#66d9ef>s</span> <span style=color:#66d9ef>height</span> cubic-bezier(<span style=color:#ae81ff>.83</span>,<span style=color:#ae81ff>.97</span>,<span style=color:#ae81ff>.05</span>,<span style=color:#ae81ff>1.44</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面的代码会产生一个最后阶段放大过度、然后回缩的效果。</p><h4 id=transition的各项属性>transition的各项属性<a hidden class=anchor aria-hidden=true href=#transition的各项属性>#</a></h4><p>transition的完整写法如下。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>img</span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>transition</span>: <span style=color:#ae81ff>1</span><span style=color:#66d9ef>s</span> <span style=color:#ae81ff>1</span><span style=color:#66d9ef>s</span> <span style=color:#66d9ef>height</span> <span style=color:#66d9ef>ease</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这其实是一个简写形式，可以单独定义成各个属性。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>img</span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>transition-property</span>: <span style=color:#66d9ef>height</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>transition-duration</span>: <span style=color:#ae81ff>1</span><span style=color:#66d9ef>s</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>transition-delay</span>: <span style=color:#ae81ff>1</span><span style=color:#66d9ef>s</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>transition-timing-function</span>: <span style=color:#66d9ef>ease</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=transition的使用注意>transition的使用注意<a hidden class=anchor aria-hidden=true href=#transition的使用注意>#</a></h4><p>（1）目前，各大浏览器（包括IE 10）都已经支持无前缀的transition，所以transition已经可以很安全地不加浏览器前缀。</p><p>（2）不是所有的CSS属性都支持transition，完整的列表查看<a href=http://oli.jp/2010/css-animatable-properties/>这里</a>，以及具体的<a href=https://leaverou.github.io/animatable/>效果</a>。</p><p>（3）transition需要明确知道，开始状态和结束状态的具体数值，才能计算出中间状态。比如，height从0px变化到100px，transition可以算出中间状态。但是，transition没法算出0px到auto的中间状态，也就是说，如果开始或结束的设置是height: auto，那么就不会产生动画效果。类似的情况还有，display: none到block，background: url(foo.jpg)到url(bar.jpg)等等。</p><h4 id=transition的局限>transition的局限<a hidden class=anchor aria-hidden=true href=#transition的局限>#</a></h4><p>transition的优点在于简单易用，但是它有几个很大的局限。</p><p>（1）transition需要事件触发，所以没法在网页加载时自动发生。</p><p>（2）transition是一次性的，不能重复发生，除非一再触发。</p><p>（3）transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。</p><p>（4）一条transition规则，只能定义一个属性的变化，不能涉及多个属性。</p><p>CSS Animation就是为了解决这些问题而提出的。</p><h3 id=animationhttpswwwruanyifengcomblog201402css_transition_and_animationhtml><a href=https://www.ruanyifeng.com/blog/2014/02/css_transition_and_animation.html>Animation</a><a hidden class=anchor aria-hidden=true href=#animationhttpswwwruanyifengcomblog201402css_transition_and_animationhtml>#</a></h3><pre tabindex=0><code>animation: [animation-name] [animation-duration] [animation-timing-function] [animation-delay] [animation-iteration-count] [animation-direction] [animation-fill-mode] [animation-play-state];
</code></pre><h4 id=基本用法-1>基本用法<a hidden class=anchor aria-hidden=true href=#基本用法-1>#</a></h4><p>首先，CSS Animation需要指定动画一个周期持续的时间(animation-duration)，以及动画效果的名称(animation-name)。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>div</span>:<span style=color:#a6e22e>hover</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>animation</span>: <span style=color:#ae81ff>1</span><span style=color:#66d9ef>s</span> rainbow;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面代码表示，当鼠标悬停在div元素上时，会产生名为rainbow的动画效果，持续时间为1秒。为此，我们还需要用keyframes关键字，定义rainbow效果。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>@<span style=color:#66d9ef>keyframes</span> <span style=color:#f92672>rainbow</span> {
</span></span><span style=display:flex><span>  <span style=color:#f92672>0</span><span style=color:#f92672>%</span> { <span style=color:#66d9ef>background</span>: <span style=color:#ae81ff>#c00</span>; }
</span></span><span style=display:flex><span>  <span style=color:#f92672>50</span><span style=color:#f92672>%</span> { <span style=color:#66d9ef>background</span>: <span style=color:#66d9ef>orange</span>; }
</span></span><span style=display:flex><span>  <span style=color:#f92672>100</span><span style=color:#f92672>%</span> { <span style=color:#66d9ef>background</span>: <span style=color:#66d9ef>yellowgreen</span>; }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面代码表示，rainbow效果一共有三个状态，分别为起始（0%）、中点（50%）和结束（100%）。如果有需要，完全可以插入更多状态。</p><p>默认情况下，动画只播放一次。加入infinite关键字，可以让动画无限次播放。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>div</span>:<span style=color:#a6e22e>hover</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>animation</span>: <span style=color:#ae81ff>1</span><span style=color:#66d9ef>s</span> rainbow <span style=color:#66d9ef>infinite</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>也可以指定动画具体播放的次数，比如3次。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>div</span>:<span style=color:#a6e22e>hover</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>animation</span>: <span style=color:#ae81ff>1</span><span style=color:#66d9ef>s</span> rainbow <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这里还有一个<a href=http://lea.verou.me/css-4d/#heart-demo>心脏跳动</a>的例子，可供参考。源码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>@<span style=color:#66d9ef>keyframes</span> <span style=color:#f92672>pound</span> {
</span></span><span style=display:flex><span>  <span style=color:#f92672>from</span> { <span style=color:#66d9ef>transform</span>: <span style=color:#66d9ef>none</span>; }
</span></span><span style=display:flex><span>  <span style=color:#f92672>to</span> { <span style=color:#66d9ef>transform</span>: scale(<span style=color:#ae81ff>1.2</span>); }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>heart</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>animation</span>: pound <span style=color:#ae81ff>.3</span><span style=color:#66d9ef>s</span> <span style=color:#66d9ef>infinite</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=animation-fill-mode>animation-fill-mode<a hidden class=anchor aria-hidden=true href=#animation-fill-mode>#</a></h4><p>动画结束以后，会立即从结束状态跳回到起始状态。如果想让动画保持在结束状态，需要使用animation-fill-mode属性。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>div</span>:<span style=color:#a6e22e>hover</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>animation</span>: <span style=color:#ae81ff>1</span><span style=color:#66d9ef>s</span> rainbow <span style=color:#66d9ef>forwards</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>forwards表示让动画停留在结束状态。</p><p>animation-fill-mode还可以使用下列值：</p><ul><li>none：默认值，回到动画没开始时的状态。</li><li>backwards：让动画回到第一帧的状态。</li><li>both: 根据animation-direction 轮流应用forwards和backwards规则。</li></ul><h4 id=animation-direction>animation-direction<a hidden class=anchor aria-hidden=true href=#animation-direction>#</a></h4><p>动画循环播放时，每次都是从结束状态跳回到起始状态，再开始播放。animation-direction属性，可以改变这种行为。</p><p>下面看一个例子，来说明如何使用animation-direction。假定有一个动画是这样定义的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>@<span style=color:#66d9ef>keyframes</span> <span style=color:#f92672>rainbow</span> {
</span></span><span style=display:flex><span>  <span style=color:#f92672>0</span><span style=color:#f92672>%</span> { <span style=color:#66d9ef>background-color</span>: <span style=color:#66d9ef>yellow</span>; }
</span></span><span style=display:flex><span>  <span style=color:#f92672>100</span><span style=color:#f92672>%</span> { <span style=color:#66d9ef>background</span>: <span style=color:#66d9ef>blue</span>; }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>默认情况是，animation-direction等于normal。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>div</span>:<span style=color:#a6e22e>hover</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>animation</span>: <span style=color:#ae81ff>1</span><span style=color:#66d9ef>s</span> rainbow <span style=color:#ae81ff>3</span> <span style=color:#66d9ef>normal</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>此外，还可以等于取alternate、reverse、alternate-reverse等值。它们的含义见下图（假定动画连续播放三次）。</p><p><img loading=lazy src=/CSS/bg2014021401.png alt=img></p><p>简单说，animation-direction指定了动画播放的方向，最常用的值是normal和reverse。</p><h4 id=animation的各项属性>animation的各项属性<a hidden class=anchor aria-hidden=true href=#animation的各项属性>#</a></h4><p>同transition一样，animation也是一个简写形式。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>div</span>:<span style=color:#a6e22e>hover</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>animation</span>: <span style=color:#ae81ff>1</span><span style=color:#66d9ef>s</span> <span style=color:#ae81ff>1</span><span style=color:#66d9ef>s</span> rainbow <span style=color:#66d9ef>linear</span> <span style=color:#ae81ff>3</span> <span style=color:#66d9ef>forwards</span> <span style=color:#66d9ef>normal</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这是一个简写形式，可以分解成各个单独的属性。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>div</span>:<span style=color:#a6e22e>hover</span> {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>animation-name</span>: rainbow;
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>animation-duration</span>: <span style=color:#ae81ff>1</span><span style=color:#66d9ef>s</span>;
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>animation-timing-function</span>: <span style=color:#66d9ef>linear</span>;
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>animation-delay</span>: <span style=color:#ae81ff>1</span><span style=color:#66d9ef>s</span>;
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>animation-fill-mode</span>:<span style=color:#66d9ef>forwards</span>;
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>animation-direction</span>: <span style=color:#66d9ef>normal</span>;
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>animation-iteration-count</span>: <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><p>animation-timing-function：定义动画的速度曲线。 速度曲线决定了动画从一套 CSS 样式变为另一套所用的时间。浏览器从一个状态向另一个状态过渡，默认是平滑过渡。</p><ul><li><p>ease：快速加速，然后逐渐减速，CSS 的默认值。</p></li><li><p>ease-out：开始时速度最快，然后逐渐慢下来，适用于进入页面显示的元素。</p></li><li><p>ease-in：逐渐加速，结尾时变快，适用于退出页面显示的元素。</p></li><li><p>ease-in-out：加速然后变慢，与<code>ease</code>相似，但开始时加速较慢，适合那些在页面有着明确开始和结束的动画。</p></li><li><p>linear：线性运行，各个时刻速度都一样。</p></li><li><p>steps()：实现分步过渡。这里有一个非常神奇的<a href=http://dabblet.com/gist/1745856>例子</a>，可以看到steps函数的用处。源码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Typing animation with pure CSS. 
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Works best in browsers supporting the ch unit.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@<span style=color:#66d9ef>keyframes</span> <span style=color:#f92672>typing</span> { <span style=color:#f92672>from</span> { <span style=color:#66d9ef>width</span>: <span style=color:#ae81ff>0</span>; } }
</span></span><span style=display:flex><span>@<span style=color:#66d9ef>keyframes</span> <span style=color:#f92672>blink-caret</span> { <span style=color:#f92672>50</span><span style=color:#f92672>%</span> { <span style=color:#66d9ef>border-color</span>: <span style=color:#66d9ef>transparent</span>; } }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>h1</span> { 
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>font</span>: <span style=color:#66d9ef>bold</span> <span style=color:#ae81ff>200</span><span style=color:#66d9ef>%</span> Consolas, Monaco, <span style=color:#66d9ef>monospace</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>border-right</span>: <span style=color:#ae81ff>.1</span><span style=color:#66d9ef>em</span> <span style=color:#66d9ef>solid</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>width</span>: <span style=color:#ae81ff>16.5</span><span style=color:#66d9ef>em</span>; <span style=color:#75715e>/* fallback */</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>width</span>: <span style=color:#ae81ff>30</span><span style=color:#66d9ef>ch</span>; <span style=color:#75715e>/* # of chars */</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>margin</span>: <span style=color:#ae81ff>2</span><span style=color:#66d9ef>em</span> <span style=color:#ae81ff>1</span><span style=color:#66d9ef>em</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>white-space</span>: <span style=color:#66d9ef>nowrap</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>overflow</span>: <span style=color:#66d9ef>hidden</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>animation</span>: typing <span style=color:#ae81ff>20</span><span style=color:#66d9ef>s</span> steps(<span style=color:#ae81ff>30</span>, <span style=color:#66d9ef>end</span>), <span style=color:#75715e>/* # of steps = # of chars */</span>
</span></span><span style=display:flex><span>	           <span style=color:#66d9ef>blink</span><span style=color:#f92672>-</span><span style=color:#66d9ef>caret</span> <span style=color:#ae81ff>.5</span><span style=color:#66d9ef>s</span> <span style=color:#66d9ef>step-end</span> <span style=color:#66d9ef>infinite</span> <span style=color:#66d9ef>alternate</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li><li><p>animation-delay：动画效果多少秒后开始，默认为<code>0</code>。</p></li><li><p>animation-iteration-count：动画重复的次数，可以指定为一个整数，表示多少次，默认值是<code>infinite</code>关键字，表示无限次。</p></li><li></li></ul><h4 id=keyframes的写法>keyframes的写法<a hidden class=anchor aria-hidden=true href=#keyframes的写法>#</a></h4><p>keyframes关键字用来定义动画的各个状态，它的写法相当自由。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>@<span style=color:#66d9ef>keyframes</span> <span style=color:#f92672>rainbow</span> {
</span></span><span style=display:flex><span>  <span style=color:#f92672>0</span><span style=color:#f92672>%</span> { <span style=color:#66d9ef>background</span>: <span style=color:#ae81ff>#c00</span> }
</span></span><span style=display:flex><span>  <span style=color:#f92672>50</span><span style=color:#f92672>%</span> { <span style=color:#66d9ef>background</span>: <span style=color:#66d9ef>orange</span> }
</span></span><span style=display:flex><span>  <span style=color:#f92672>100</span><span style=color:#f92672>%</span> { <span style=color:#66d9ef>background</span>: <span style=color:#66d9ef>yellowgreen</span> }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>0%可以用from代表，100%可以用to代表，因此上面的代码等同于下面的形式。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>@<span style=color:#66d9ef>keyframes</span> <span style=color:#f92672>rainbow</span> {
</span></span><span style=display:flex><span>  <span style=color:#f92672>from</span> { <span style=color:#66d9ef>background</span>: <span style=color:#ae81ff>#c00</span> }
</span></span><span style=display:flex><span>  <span style=color:#f92672>50</span><span style=color:#f92672>%</span> { <span style=color:#66d9ef>background</span>: <span style=color:#66d9ef>orange</span> }
</span></span><span style=display:flex><span>  <span style=color:#f92672>to</span> { <span style=color:#66d9ef>background</span>: <span style=color:#66d9ef>yellowgreen</span> }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果省略某个状态，浏览器会自动推算中间状态，所以下面都是合法的写法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>@<span style=color:#66d9ef>keyframes</span> <span style=color:#f92672>rainbow</span> {
</span></span><span style=display:flex><span>  <span style=color:#f92672>50</span><span style=color:#f92672>%</span> { <span style=color:#66d9ef>background</span>: <span style=color:#66d9ef>orange</span> }
</span></span><span style=display:flex><span>  <span style=color:#f92672>to</span> { <span style=color:#66d9ef>background</span>: <span style=color:#66d9ef>yellowgreen</span> }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@<span style=color:#66d9ef>keyframes</span> <span style=color:#f92672>rainbow</span> {
</span></span><span style=display:flex><span>  <span style=color:#f92672>to</span> { <span style=color:#66d9ef>background</span>: <span style=color:#66d9ef>yellowgreen</span> }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>甚至，可以把多个状态写在一行。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>@<span style=color:#66d9ef>keyframes</span> <span style=color:#f92672>pound</span> {
</span></span><span style=display:flex><span>  <span style=color:#f92672>from</span><span style=color:#960050;background-color:#1e0010>，</span><span style=color:#f92672>to</span> { <span style=color:#66d9ef>transform</span>: <span style=color:#66d9ef>none</span>; }
</span></span><span style=display:flex><span>  <span style=color:#f92672>50</span><span style=color:#f92672>%</span> { <span style=color:#66d9ef>transform</span>: scale(<span style=color:#ae81ff>1.2</span>); }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=animation-play-state>animation-play-state<a hidden class=anchor aria-hidden=true href=#animation-play-state>#</a></h4><p>有时，动画播放过程中，会突然停止。这时，默认行为是跳回到动画的开始状态。</p><p>如果想让动画保持突然终止时的状态，就要使用animation-play-state属性。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>div</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>animation</span>: spin <span style=color:#ae81ff>1</span><span style=color:#66d9ef>s</span> <span style=color:#66d9ef>linear</span> <span style=color:#66d9ef>infinite</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>animation-play-state</span>: <span style=color:#66d9ef>paused</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>div</span>:<span style=color:#a6e22e>hover</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>animation-play-state</span>: <span style=color:#66d9ef>running</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面的代码指定，没有鼠标没有悬停时，动画状态是暂停；一旦悬停，动画状态改为继续播放。效果如下。</p><h4 id=贝塞尔曲线>贝塞尔曲线<a hidden class=anchor aria-hidden=true href=#贝塞尔曲线>#</a></h4><p><code>animation-timing-function</code> 除了预定义值之外，CSS 还提供了贝塞尔曲线（Bezier curves）来更细致地控制动画的速度曲线。</p><p>可以用 <code>cubic-bezier</code> 来定义贝塞尔曲线。 曲线的形状代表了动画的速度。 曲线在 1 * 1 的坐标系统内， 其中 X 轴代表动画的时间间隔（类似于时间比例尺），Y 轴代表动画的改变。</p><p><code>cubic-bezier</code> 函数包含了 1 * 1 网格里的4个点：<code>p0</code>、<code>p1</code>、<code>p2</code>、<code>p3</code>。 其中 <code>p0</code> 和 <code>p3</code> 是固定值，代表曲线的起始点和结束点，坐标值依次为 (0, 0) 和 (1, 1)。 你只需设置另外两点的 x 值和 y 值，设置的这两点确定了曲线的形状从而确定了动画的速度曲线。 在 CSS 里面通过 <code>(x1, y1, x2, y2)</code> 来确定 <code>p1</code> 和 <code>p2</code>。</p><pre tabindex=0><code>animation-timing-function: cubic-bezier(x1, y1, x2, y2);
</code></pre><p>通俗的讲，将一条直线放在范围只有 1 的坐标轴中，并从中间拿 <code>p1</code> 和 <code>p2</code> 两个点来拉扯（X 轴的取值区间是 [0, 1]，Y 轴任意），最后形成的曲线就是动画的贝塞尔速度曲线。</p><h3 id=transform>transform<a hidden class=anchor aria-hidden=true href=#transform>#</a></h3><p>注意：给 <code>div</code> 元素添加 transform 也会影响这个 div 包裹的子元素。</p><h4 id=2d-转换>2D 转换<a hidden class=anchor aria-hidden=true href=#2d-转换>#</a></h4><p>同时设置多个不同的CSS变换(transform)属性时，中间用空格隔开即可， 执行顺序是从后向前的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>transform</span><span style=color:#f92672>:</span> <span style=color:#f92672>rotate</span><span style=color:#f92672>(</span><span style=color:#f92672>360deg</span><span style=color:#f92672>)</span> <span style=color:#f92672>scale</span><span style=color:#f92672>(</span><span style=color:#f92672>2</span><span style=color:#f92672>,</span><span style=color:#f92672>2</span><span style=color:#f92672>)</span> <span style=color:#f92672>skew</span><span style=color:#f92672>(</span><span style=color:#f92672>10deg</span><span style=color:#f92672>,</span><span style=color:#f92672>5deg</span><span style=color:#f92672>);</span>
</span></span></code></pre></div><h5 id=缩放>缩放<a hidden class=anchor aria-hidden=true href=#缩放>#</a></h5><p><code>transform</code> 里面的 <code>scale()</code> 函数可以用来改变元素的显示比例。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>transform</span><span style=color:#f92672>:</span> <span style=color:#f92672>scale</span><span style=color:#f92672>(</span><span style=color:#f92672>x</span><span style=color:#f92672>,</span> <span style=color:#f92672>y</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>transform</span><span style=color:#f92672>:</span> <span style=color:#f92672>scale</span><span style=color:#f92672>(</span><span style=color:#f92672>2</span><span style=color:#f92672>,</span> <span style=color:#f92672>0</span>.<span style=color:#a6e22e>5</span><span style=color:#f92672>);</span>
</span></span></code></pre></div><p>x 表示水平方向的缩放倍数。y表示垂直方向的缩放倍数。如果只写一个值就是等比例缩放。大于1表示放大，小于1表示缩小。不能为百分比。</p><h5 id=位移>位移<a hidden class=anchor aria-hidden=true href=#位移>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>transform</span><span style=color:#f92672>:</span> <span style=color:#f92672>translate</span><span style=color:#f92672>(</span><span style=color:#960050;background-color:#1e0010>水平位移</span><span style=color:#f92672>,</span> <span style=color:#960050;background-color:#1e0010>垂直位移</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>transform</span><span style=color:#f92672>:</span> <span style=color:#f92672>translate</span><span style=color:#f92672>(</span><span style=color:#f92672>-50</span><span style=color:#f92672>%,</span> <span style=color:#f92672>-50</span><span style=color:#f92672>%);</span>
</span></span></code></pre></div><p>参数为百分比，相对于自身移动，即指的是盒子高度。正值向右和向下，负值向左和向上。如果只写一个值，则表示水平移动。</p><ul><li><code>translateY(ty)</code> 对应 <code>translate(0, ty)</code> 或<code>translate3d(0, ty, 0)</code>。</li><li><code>translateX(tx)</code>等同于 <code>translate(tx, 0)</code> 或者 <code>translate3d(tx, 0, 0)</code>。</li></ul><h5 id=旋转>旋转<a hidden class=anchor aria-hidden=true href=#旋转>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>transform</span><span style=color:#f92672>:</span> <span style=color:#f92672>rotate</span><span style=color:#f92672>(</span><span style=color:#960050;background-color:#1e0010>角度</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>transform</span><span style=color:#f92672>:</span> <span style=color:#f92672>rotate</span><span style=color:#f92672>(</span><span style=color:#f92672>45deg</span><span style=color:#f92672>);</span>
</span></span></code></pre></div><p>正值顺时针，负值逆时针。默认是以盒子的正中心为坐标原点的。如果想改变旋转的坐标原点，可以用<code>transform-origin</code>属性：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>transform-origin</span><span style=color:#f92672>:</span> <span style=color:#960050;background-color:#1e0010>水平坐标</span> <span style=color:#960050;background-color:#1e0010>垂直坐标</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>transform-origin</span><span style=color:#f92672>:</span> <span style=color:#f92672>50px</span> <span style=color:#f92672>50px</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>transform-origin</span><span style=color:#f92672>:</span> <span style=color:#f92672>center</span> <span style=color:#f92672>bottom</span><span style=color:#f92672>;</span>
</span></span></code></pre></div><h5 id=倾斜>倾斜<a hidden class=anchor aria-hidden=true href=#倾斜>#</a></h5><p>skew() 函数定义了一个元素在二维平面上的倾斜转换。</p><p>skew() 函数指定一个或两个参数，它们表示在每个方向上应用的倾斜量。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>skew</span><span style=color:#f92672>(</span><span style=color:#f92672>ax</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>skew</span><span style=color:#f92672>(</span><span style=color:#f92672>ax</span><span style=color:#f92672>,</span> <span style=color:#f92672>ay</span><span style=color:#f92672>)</span>
</span></span></code></pre></div><ul><li>ax 是一个 <code>&lt;angle></code>，表示用于沿横坐标扭曲元素的角度。</li><li>ay 是一个 <code>&lt;angle></code> ，表示用于沿纵坐标扭曲元素的角度。如果未定义，则其默认值为0，导致纯水平倾斜。</li></ul><p><code>transform</code> 属性 <code>skewX()</code>：它使选择的元素沿着 X 轴（横向）倾斜指定的角度。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>p</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>transform</span>: skewX(<span style=color:#ae81ff>-32</span><span style=color:#66d9ef>deg</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img loading=lazy src=/CSS/skewX.gif alt></p><p><code>skewY</code> 属性使指定元素沿 Y 轴（垂直方向）倾斜指定角度。</p><p><img loading=lazy src=/CSS/skewY.gif alt></p><p><a href=https://zhuanlan.zhihu.com/p/22711395>图形变换:详解Transform:skew函数的数学原理</a></p><h4 id=3d-转换>3D 转换<a hidden class=anchor aria-hidden=true href=#3d-转换>#</a></h4><p><img loading=lazy src=/CSS/3D%e5%9d%90%e6%a0%87%e7%b3%bb.png alt></p><ul><li>3D坐标系（左手坐标系）：伸出左手，让拇指和食指成“L”形，大拇指向右，食指向上，中指指向前方。拇指、食指和中指分别代表X、Y、Z轴的正方向，这样我们就建立了一个左手坐标系。浏览器的X轴就是屏幕左到右， Y轴就是屏幕上到下，Z轴就是屏幕到用户。</li><li>旋转的方向（左手法则）：左手握住旋转轴，竖起拇指指向旋转轴的正方向，正向就是其余手指卷曲的方向。</li></ul><h5 id=旋转-1>旋转<a hidden class=anchor aria-hidden=true href=#旋转-1>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>transform</span><span style=color:#f92672>:</span> <span style=color:#f92672>rotate</span><span style=color:#f92672>(</span><span style=color:#f92672>360deg</span><span style=color:#f92672>);</span>		<span style=color:#75715e>/* 绕 Z 轴旋转360度 */</span>
</span></span><span style=display:flex><span><span style=color:#f92672>transform</span><span style=color:#f92672>:</span> <span style=color:#f92672>rotateX</span><span style=color:#f92672>(</span><span style=color:#f92672>360deg</span><span style=color:#f92672>);</span>    <span style=color:#75715e>/* 绕 X 轴旋转360度 */</span>
</span></span><span style=display:flex><span><span style=color:#f92672>transform</span><span style=color:#f92672>:</span> <span style=color:#f92672>rotateY</span><span style=color:#f92672>(</span><span style=color:#f92672>360deg</span><span style=color:#f92672>);</span>    <span style=color:#75715e>/* 绕 Y 轴旋转360度 */</span>
</span></span><span style=display:flex><span><span style=color:#f92672>transform</span><span style=color:#f92672>:</span> <span style=color:#f92672>rotateZ</span><span style=color:#f92672>(</span><span style=color:#f92672>360deg</span><span style=color:#f92672>);</span>    <span style=color:#75715e>/* 绕 Z 轴旋转360度 */</span>
</span></span></code></pre></div><p>要看到 X轴，Y轴旋转效果，须加透视 <code>perspective</code>。</p><h5 id=移动>移动<a hidden class=anchor aria-hidden=true href=#移动>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>transform</span><span style=color:#f92672>:</span> <span style=color:#f92672>translateX</span><span style=color:#f92672>(</span><span style=color:#f92672>100px</span><span style=color:#f92672>);</span>    <span style=color:#75715e>/* 沿着 X 轴移动 */</span>
</span></span><span style=display:flex><span><span style=color:#f92672>transform</span><span style=color:#f92672>:</span> <span style=color:#f92672>translateY</span><span style=color:#f92672>(</span><span style=color:#f92672>360px</span><span style=color:#f92672>);</span>    <span style=color:#75715e>/* 沿着 Y 轴移动 */</span>
</span></span><span style=display:flex><span><span style=color:#f92672>transform</span><span style=color:#f92672>:</span> <span style=color:#f92672>translateZ</span><span style=color:#f92672>(</span><span style=color:#f92672>360px</span><span style=color:#f92672>);</span>    <span style=color:#75715e>/* 沿着 Z 轴移动 */</span>
</span></span></code></pre></div><p>要看 Z轴移动效果须加透视 <code>perspective</code>。</p><h5 id=透视>透视<a hidden class=anchor aria-hidden=true href=#透视>#</a></h5><p>电脑显示屏是一个 2D 平面，图像之所以具有立体感（3D效果），其实只是一种视觉呈现，通过透视可以实现此目的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>perspective</span><span style=color:#f92672>:</span> <span style=color:#f92672>500px</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>transform</span><span style=color:#f92672>:</span> <span style=color:#f92672>perspective</span><span style=color:#f92672>(</span><span style=color:#f92672>0</span><span style=color:#f92672>);</span>
</span></span></code></pre></div><ul><li>作为一个属性，设置给父元素，作用于所有3D转换的子元素</li><li>作为 transform 属性的一个值，做用于元素自身。</li></ul><h5 id=3d-呈现>3D 呈现<a hidden class=anchor aria-hidden=true href=#3d-呈现>#</a></h5><p>3D元素构建是指某个图形是由多个元素构成的，可以给这些元素的父元素设置<code>transform-style: preserve-3d</code>来使其变成一个真正的3D图形。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>transform-style</span><span style=color:#f92672>:</span> <span style=color:#f92672>preserve-3d</span><span style=color:#f92672>;</span>     <span style=color:#75715e>/* 让子盒子位于三维空间里 */</span>
</span></span><span style=display:flex><span><span style=color:#f92672>transform-style</span><span style=color:#f92672>:</span> <span style=color:#f92672>flat</span><span style=color:#f92672>;</span>            <span style=color:#75715e>/* 让子盒子位于此元素所在的平面内（子盒子被扁平化） */</span>
</span></span></code></pre></div><h2 id=多栏式布局>多栏式布局<a hidden class=anchor aria-hidden=true href=#多栏式布局>#</a></h2><p>多栏式布局是 CSS 原生提供的一种内容分栏显示的解决方案。</p><h3 id=基本用法-2>基本用法<a hidden class=anchor aria-hidden=true href=#基本用法-2>#</a></h3><p><code>column-count</code>属性指定<code>div</code>的子元素分成四栏。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>div</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>column-count</span>:<span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>column-width</code>属性指定每一栏的宽度。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>div</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>column-width</span>:<span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面代码中，<code>column-width</code>属性指定每一栏的宽度是100像素。如果<code>div</code>元素的宽度是800像素，那么内容就将分成8栏。</p><p>注意，<code>column-count</code>与<code>column-width</code>不应同时使用，它们之中同时只能有一个属性生效。另外，设定<code>position: fixed</code>和<code>position: absolute</code>子元素，将不纳入多栏式布局的栏计算。</p><h3 id=间隔>间隔<a hidden class=anchor aria-hidden=true href=#间隔>#</a></h3><p>多栏式布局对栏与栏之间的间隔，提供了如下属性。</p><ul><li>column-gap：间隔宽度</li><li>column-rule-color：间隔线的颜色</li><li>column-rule-style：间隔线的样式，比如<code>dashed</code>、<code>dotted</code>等，默认是<code>solid</code></li><li>column-rule-width：间隔线本身的宽度</li><li>column-rule：<code>column-rule-color</code>、<code>column-rule-style</code>、<code>column-rule-width</code>这三个属性的快捷形式。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>div</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>column-gap</span>: <span style=color:#ae81ff>20</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>column-rule</span>: <span style=color:#ae81ff>2</span><span style=color:#66d9ef>px</span> <span style=color:#66d9ef>solid</span> <span style=color:#ae81ff>#33c</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面代码指定栏与栏之间的间隔是<code>20px</code>，间隔线的样式是<code>2px solid #33c</code>。</p><h3 id=column-span>column-span<a hidden class=anchor aria-hidden=true href=#column-span>#</a></h3><p><code>column-span</code>属性指定某个子元素可以占据多栏的宽度，比如标题。它只能设两个值<code>all</code>和<code>none</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>h2</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>column-span</span>: <span style=color:#66d9ef>all</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=column-fill>column-fill<a hidden class=anchor aria-hidden=true href=#column-fill>#</a></h3><p><code>column-fill</code>属性指定内容如何在多栏之间分配。</p><p>默认值<code>balance</code>表示栏与栏是等高的，<code>auto</code>表示只占据内容所需的空间。</p><h3 id=内容的断点>内容的断点<a hidden class=anchor aria-hidden=true href=#内容的断点>#</a></h3><p>浏览器会自己决定，内容在栏与栏之间如何断点。下面的三个属性可以调整这个行为。</p><p><code>break-inside</code>属性决定子元素内部如何断点。它可以取以下值。</p><ul><li>auto：默认值，表示子元素内部可以插入断点</li><li>avoid：避免在子元素内部插入所有类型（page、column、region）的断点</li><li>avoid-column：避免子元素内部插入栏与栏的断点</li></ul><p><code>break-before</code>属性决定子元素前方如何断点。它可以取以下值。</p><ul><li>auto：默认值，子元素前方可以插入断点</li><li>avoid：避免在子元素前方插入所有类型（page、column、region）的断点</li><li>avoid-column：避免在子元素前方插入栏与栏的断点</li><li>column：子元素前方强制插入一个栏断点</li></ul><p><code>break-after</code>属性决定子元素后方如何断点。它可以取以下值。</p><ul><li>auto：默认值，子元素后方可以插入断点</li><li>avoid：避免在子元素后方插入所有类型（page、column、region）的断点</li><li>avoid-column：避免在子元素后方插入栏与栏的断点</li><li>column：子元素后方强制插入一个栏断点</li></ul><h2 id=table-布局>Table 布局<a hidden class=anchor aria-hidden=true href=#table-布局>#</a></h2><p>CSS 可以让 HTML 元素像表格那样排列。</p><p>下面是表格的各个 HTML 标签，所对应的布局模式。</p><table><thead><tr><th>表格标签</th><th>对应的布局模式</th></tr></thead><tbody><tr><td>table</td><td>{ display: table }</td></tr><tr><td>tr</td><td>{ display: table-row }</td></tr><tr><td>thead</td><td>{ display: table-header-group }</td></tr><tr><td>tbody</td><td>{ display: table-row-group }</td></tr><tr><td>tfoot</td><td>{ display: table-footer-group }</td></tr><tr><td>col</td><td>{ display: table-column }</td></tr><tr><td>colgroup</td><td>{ display: table-column-group }</td></tr><tr><td>td, th</td><td>{ display: table-cell }</td></tr><tr><td>caption</td><td>{ display: table-caption }</td></tr></tbody></table><p>表格布局可以很简单地做到垂直居中。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>div</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>height</span>: <span style=color:#ae81ff>200</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>display</span>:<span style=color:#66d9ef>table-cell</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>vertical-align</span>: <span style=color:#66d9ef>middle</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这种写法相比下面的写法，更容易理解。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>div</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>height</span>: <span style=color:#ae81ff>200</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>position</span>: <span style=color:#66d9ef>relative</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>top</span>: <span style=color:#ae81ff>50</span><span style=color:#66d9ef>%</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>transform</span>: translateY(<span style=color:#ae81ff>-50</span><span style=color:#66d9ef>%</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>表格布局的另一个用途是，让页尾总是显示在浏览器的最低部，即使页面高度不足一页。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>  HTML 代码如下
</span></span></span><span style=display:flex><span><span style=color:#75715e>  &lt;body&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>    &lt;div class=&#34;main&#34;&gt;&lt;/div&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>    &lt;div class=&#34;footer&#34;&gt;&lt;/div&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>  &lt;/body&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>body</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>display</span>: <span style=color:#66d9ef>table</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>width</span>: <span style=color:#ae81ff>100</span><span style=color:#66d9ef>%</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>main</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>min-height</span>: <span style=color:#ae81ff>100</span><span style=color:#66d9ef>%</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>footer</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>display</span>: <span style=color:#66d9ef>table-row</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>height</span>:<span style=color:#ae81ff>1</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>基于上面这种底部固定的技巧，可以使用表格布局，完成圣杯布局，即页面从上到下分成页首 + 内容 + 页尾三部分，其中内容部分又分成左边栏和右边栏。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>  HTML 代码如下
</span></span></span><span style=display:flex><span><span style=color:#75715e>&lt;div class=&#34;wrapper&#34;&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>  &lt;div class=&#34;header&#34;&gt;HEADER&lt;/div&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>  &lt;div class=&#34;main&#34;&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>    &lt;div class=&#34;box sidebar&#34;&gt;Left-sidebar&lt;/div&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>    &lt;div class=&#34;box content&#34;&gt;Main Content&lt;/div&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>    &lt;div class=&#34;box sidebar&#34;&gt;Right-sidebar&lt;/div&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>  &lt;/div&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>  &lt;div class=&#34;footer&#34;&gt;FOOTER&lt;/div&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>&lt;/div&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>wrapper</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>min-height</span>: <span style=color:#ae81ff>100</span><span style=color:#66d9ef>%</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>display</span>: <span style=color:#66d9ef>table</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>width</span>: <span style=color:#ae81ff>100</span><span style=color:#66d9ef>%</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>text-align</span>: <span style=color:#66d9ef>center</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>header</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>display</span>: <span style=color:#66d9ef>table-row</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>height</span>: <span style=color:#ae81ff>1</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>main</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>min-height</span>: <span style=color:#ae81ff>100</span><span style=color:#66d9ef>%</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>display</span>: <span style=color:#66d9ef>table</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>width</span>: <span style=color:#ae81ff>100</span><span style=color:#66d9ef>%</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>box</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>display</span>: <span style=color:#66d9ef>table-cell</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>sidebar</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>width</span>: <span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>footer</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>display</span>: <span style=color:#66d9ef>table-row</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>height</span>:<span style=color:#ae81ff>1</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>利用表格的不同性质的行，可以调整行的显示位置。</p><ul><li><code>display:table-caption</code>使得该行显示在表格的最顶部。</li><li><code>display:table-header-group</code>使得该行显示在表格的头部，但是位置低于<code>table-caption</code>的行。</li><li><code>display:table-footer-group</code>使得该行显示在表格的底部。</li></ul><h2 id=flex-布局httpswwwruanyifengcomblog201507flex-grammarhtml><a href=https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html>Flex 布局</a><a hidden class=anchor aria-hidden=true href=#flex-布局httpswwwruanyifengcomblog201507flex-grammarhtml>#</a></h2><p>2009年，W3C 提出了一种新的方案——Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。</p><h3 id=flex-布局简介>Flex 布局简介<a hidden class=anchor aria-hidden=true href=#flex-布局简介>#</a></h3><p>Flex 是 Flexible Box 的缩写，意为"弹性布局"，用来为盒状模型提供最大的灵活性。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>box</span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>display</span>: <span style=color:#66d9ef>flex</span>;		<span style=color:#75715e>/* block */</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>box</span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>display</span>: <span style=color:#66d9ef>inline-flex</span>;		<span style=color:#75715e>/* inline */</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>任何一个容器都可以指定为 Flex 布局。设为 Flex 布局以后，子元素的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性将失效。</p><p>我想，设定 flex 后，父元素的内盒子变为 flex，子元素的外盒子变为 flex，但是父元素的外盒子，子元素的内盒子还是原来的盒子。</p><h3 id=基本概念>基本概念<a hidden class=anchor aria-hidden=true href=#基本概念>#</a></h3><p><img loading=lazy src=/CSS/Flex%e5%ae%b9%e5%99%a8.png alt></p><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称"容器"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称"项目"。</p><p>容器默认存在两根轴：主轴（main axis）和交叉轴（cross axis）。</p><p>如果把 <code>flex-direction</code>属性设为 <code>row</code>，它的子元素会从左到右逐个排列； 如果把 <code>flex-direction</code>属性设为 <code>column</code>，它的子元素会从上到下逐个排列。 子元素排列的方向被称为 main axis（主轴）。 对于 <code>row</code>，主轴水平贯穿每一个项目； 对于<code>column</code>，主轴垂直贯穿每一个项目。主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code> 。</p><p>Flex 容器中，与主轴垂直的叫做 cross axis（交叉轴）。 <code>row</code>的交叉轴是垂直的，<code>column</code>的交叉轴是水平的。交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。</p><p>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p><h3 id=容器的属性>容器的属性<a hidden class=anchor aria-hidden=true href=#容器的属性>#</a></h3><h4 id=flex-direction>flex-direction<a hidden class=anchor aria-hidden=true href=#flex-direction>#</a></h4><p><code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>box</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>flex-direction</span>: <span style=color:#66d9ef>column-reverse</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>column</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>row</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>row-reverse</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img loading=lazy src=/CSS/flex-direction%e5%b1%9e%e6%80%a7.png alt></p><ul><li><code>column-reverse</code>：主轴为垂直方向，起点在下沿。</li><li><code>column</code>：主轴为垂直方向，起点在上沿。</li><li><code>row</code>（默认值）：主轴为水平方向，起点在左端。</li><li><code>row-reverse</code>：主轴为水平方向，起点在右端。</li></ul><h4 id=flex-wrap>flex-wrap<a hidden class=anchor aria-hidden=true href=#flex-wrap>#</a></h4><p>默认情况下，flex 容器会调整项目大小，把它们都塞到一起。 对于<code>row</code>来说，所有项目都会在一条直线上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。这意味着多出来的子元素会被移到新的行或列。 换行发生的断点由子元素和容器的大小决定。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>box</span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>flex-wrap</span>: <span style=color:#66d9ef>nowrap</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>wrap</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>wrap-reverse</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><p><code>nowrap</code>（默认）：不换行。</p><p><img loading=lazy src=/CSS/flex-wrap-nowrap.png alt></p></li><li><p><code>wrap</code>：换行，<code>row</code>从上到下排，<code>column</code>从左到右排。</p><p><img loading=lazy src=/CSS/flex-wrap-wrap.jpg alt></p></li><li><p><code>wrap-reverse</code>：换行，<code>row</code>从下到上排，<code>column</code>从右到左排。</p><p><img loading=lazy src=/CSS/flex-wrap-reverse.jpg alt></p></li></ul><h4 id=flex-flow>flex-flow<a hidden class=anchor aria-hidden=true href=#flex-flow>#</a></h4><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>box</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>flex-flow</span>: <span style=color:#66d9ef>flex</span><span style=color:#f92672>-</span><span style=color:#66d9ef>direction</span> <span style=color:#66d9ef>flex</span><span style=color:#f92672>-</span><span style=color:#66d9ef>wrap</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=justify-content>justify-content<a hidden class=anchor aria-hidden=true href=#justify-content>#</a></h4><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>box</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>justify-content</span>: <span style=color:#66d9ef>flex-start</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>flex-end</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>center</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>space-between</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>space-around</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img loading=lazy src=/CSS/justify-content%e5%b1%9e%e6%80%a7.png alt></p><ul><li>flex-start（默认值）： 对<code>row</code>来说是把项目移至左边， 对于<code>column</code>是把项目移至顶部。</li><li>flex-end：对<code>row</code>来说是把项目移至右边， 对于<code>column</code>是把项目移至底部。</li><li>center： flex 子元素在 flex 容器中居中排列。</li><li>space-between：项目间保留一定间距地沿主轴居中排列。 第一个和最后一个项目被放置在容器边沿。 例如，在行中第一个项目会紧贴着容器左边，最后一个项目会紧贴着容器右边，然后其他项目均匀排布。</li><li>space-around：与<code>space-between</code>相似，但头尾两个项目不会紧贴容器边缘，所有项目之间的空间均匀排布。每个项目两侧的间隔相等，所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul><h4 id=align-items>align-items<a hidden class=anchor aria-hidden=true href=#align-items>#</a></h4><p><code>align-items</code>属性定义项目在交叉轴上如何对齐。 对<code>row</code>来说，定义的是元素的上下对齐方式； 对<code>column</code>来说，是定义元素的左右对齐方式。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>box</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>align-items</span>: <span style=color:#66d9ef>flex-start</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>flex-end</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>center</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>baseline</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>stretch</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img loading=lazy src=/CSS/align-items%e5%b1%9e%e6%80%a7.png alt></p><ul><li>flex-start：对<code>row</code>来说，把项目移至容器顶部； 对<code>column</code>来说，是把项目移至容器左边。</li><li>flex-end：对<code>row</code>来说，把项目移至容器底部； 对<code>column</code>来说，把项目移至容器右边。</li><li>center：对<code>row</code>来说，垂直居中（项目距离顶部和底部的距离相等）； 对<code>column</code>来说，水平居中（项目距离左边和右边的距离相等）。</li><li>baseline: 沿项目的第一行文字的基线对齐。</li><li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li></ul><h4 id=align-content>align-content<a hidden class=anchor aria-hidden=true href=#align-content>#</a></h4><p><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>box</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>align-content</span>: <span style=color:#66d9ef>flex-start</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>flex-end</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>center</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>space-between</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>space-around</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>stretch</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img loading=lazy src=/CSS/align-content%e5%b1%9e%e6%80%a7.png alt></p><ul><li>flex-start：与交叉轴的起点对齐。</li><li>flex-end：与交叉轴的终点对齐。</li><li>center：与交叉轴的中点对齐。</li><li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li><li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li>stretch（默认值）：轴线占满整个交叉轴。</li></ul><h3 id=项目的属性>项目的属性<a hidden class=anchor aria-hidden=true href=#项目的属性>#</a></h3><h4 id=order>order<a hidden class=anchor aria-hidden=true href=#order>#</a></h4><p><code>order</code>属性定义项目的排列顺序。默认情况下，项目排列顺序与源 HTML 文件中顺序相同。 这个属性接受数字作为参数，可以使用负数。数值越小，排列越靠前，默认为0。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>item</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>order</span>: integer;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img loading=lazy src=/CSS/order%e5%b1%9e%e6%80%a7.png alt></p><h4 id=flex-grow>flex-grow<a hidden class=anchor aria-hidden=true href=#flex-grow>#</a></h4><p><code>flex-grow</code> 会在容器太大时对子元素作出调整。默认为<code>0</code>，即如果存在剩余空间，也不放大。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>item</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>flex-grow</span>: number; <span style=color:#75715e>/* default 0 */</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img loading=lazy src=/CSS/flex-grow%e5%b1%9e%e6%80%a7.png alt></p><p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><h4 id=flex-shrink>flex-shrink<a hidden class=anchor aria-hidden=true href=#flex-shrink>#</a></h4><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1。使用之后，如果 flex 容器太小，则子元素会自动缩小。当容器的宽度小于里面所有子元素的宽度之和时，所有子元素都会自动压缩。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>item</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>flex-shrink</span>: number; <span style=color:#75715e>/* default 1 */</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img loading=lazy src=/CSS/flex-shrink%e5%b1%9e%e6%80%a7.jpg alt></p><p>子元素的 <code>flex-shrink</code> 接受数值作为属性值。 数值越大，则该元素与其他元素相比会被压缩得更厉害。</p><p>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。</p><p>负值对该属性无效。</p><h4 id=flex-basis>flex-basis<a hidden class=anchor aria-hidden=true href=#flex-basis>#</a></h4><p><code>flex-basis</code> 属性定义了在使用 CSS 的 <code>flex-shrink</code> 或 <code>flex-grow</code> 属性对元素进行调整前，元素的初始大小。<code>flex-basis</code> 属性的单位与其他表示尺寸的属性的单位一致（<code>px</code>、<code>em</code>、<code>%</code> 等）。 如果值为 <code>auto</code>，则项目的尺寸随内容调整。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>item</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>flex-basis</span>: length <span style=color:#f92672>|</span> <span style=color:#66d9ef>auto</span>; <span style=color:#75715e>/* default auto */</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=flex>flex<a hidden class=anchor aria-hidden=true href=#flex>#</a></h4><p><code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>item</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>flex</span>: <span style=color:#66d9ef>none</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>flex</span><span style=color:#f92672>-</span>grow <span style=color:#66d9ef>flex</span><span style=color:#f92672>-</span>shrink <span style=color:#66d9ef>flex</span><span style=color:#f92672>-</span>basis
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)。</p><h4 id=align-self>align-self<a hidden class=anchor aria-hidden=true href=#align-self>#</a></h4><p><code>align-self</code>属性允许你调整单个子元素自己的对齐方式，而不会影响到全部子元素。 因为 <code>float</code>、<code>clear</code> 和 <code>vertical-align</code> 等调整对齐方式的属性都不能应用于 flex 子元素，所以这个属性显得十分有用。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p><p><code>align-self</code> 可设置的值与 <code>align-items</code> 的一样，并且它会覆盖 <code>align-items</code> 所设置的值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>item</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>align-self</span>: <span style=color:#66d9ef>auto</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>flex-start</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>flex-end</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>center</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>baseline</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>stretch</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img loading=lazy src=/CSS/align-self%e5%b1%9e%e6%80%a7.png alt></p><h2 id=grid-布局httpswwwruanyifengcomblog201903grid-layout-tutorialhtml><a href=https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html>Grid 布局</a><a hidden class=anchor aria-hidden=true href=#grid-布局httpswwwruanyifengcomblog201903grid-layout-tutorialhtml>#</a></h2><h3 id=概述-1>概述<a hidden class=anchor aria-hidden=true href=#概述-1>#</a></h3><p>网格布局（Grid）它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。</p><p>Flex 布局是轴线布局，只能指定"项目"针对轴线的位置，可以看作是一维布局。Grid 布局则是将容器划分成"行"和"列"，产生单元格，然后指定"项目所在"的单元格，可以看作是二维布局。Grid 布局远比 Flex 布局强大。</p><p>相对于 flex 布局，为让元素对齐，你需要一种二维布局的方法，你希望通过行和列来控制对齐。</p><p>除了一维和二维布局之间的区别，还有一种办法决定该使用弹性盒还是网格来布局。弹性盒从内容出发。一个使用弹性盒的理想情形是你有一组元素，希望它们能平均地分布在容器中。你让内容的大小决定每个元素占据多少空间。如果元素换到了新的一行，它们会根据新行的可用空间决定它们自己的大小。</p><p>网格则从布局入手。当使用CSS网格时，你先创建网格，然后再把元素放入网格中，或者让自动放置规则根据把元素按照网格排列。</p><h3 id=基本概念-1>基本概念<a hidden class=anchor aria-hidden=true href=#基本概念-1>#</a></h3><h4 id=容器和项目>容器和项目<a hidden class=anchor aria-hidden=true href=#容器和项目>#</a></h4><p>采用网格布局的区域，称为"容器"（container）。容器内部采用网格定位的子元素，称为"项目"（item）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>  &lt;<span style=color:#f92672>div</span>&gt;&lt;<span style=color:#f92672>p</span>&gt;1&lt;/<span style=color:#f92672>p</span>&gt;&lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>  &lt;<span style=color:#f92672>div</span>&gt;&lt;<span style=color:#f92672>p</span>&gt;2&lt;/<span style=color:#f92672>p</span>&gt;&lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>  &lt;<span style=color:#f92672>div</span>&gt;&lt;<span style=color:#f92672>p</span>&gt;3&lt;/<span style=color:#f92672>p</span>&gt;&lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>div</span>&gt;
</span></span></code></pre></div><p>上面代码中，最外层的<code>&lt;div></code>元素就是容器，内层的三个<code>&lt;div></code>元素就是项目。</p><p>Grid 布局只对项目生效。项目只能是容器的顶层子元素（直接后代元素），不包含项目的子元素，比如上面代码的<code>&lt;p></code>元素就不是项目。我们可以把某个子元素设置为网格，就会得到一个嵌套的网格。</p><p>标准中还提到了匿名网格项目。当有一些字符串或文本被包含在网格容器中，但却没有被其他元素包装，它们就会被创建为匿名网格项目。下面的例子，假设容器的类 <code>grid</code> 设置了 <code>display: grid</code> 属性，那么网格中就有三个网格项目，第一个就是匿名项目，因为它没有用标签分隔，所以会被自动定位规则处理。另2个放在 div 中的项目，它们可以被自动定位，也可以通过网格的定位属性来定位。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;grid&#34;</span>&gt;
</span></span><span style=display:flex><span>    I am a string and will become an anonymous item
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>div</span>&gt;A grid item&lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>div</span>&gt;A grid item&lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>div</span>&gt;
</span></span></code></pre></div><p>匿名项目被自动定位是因为没有办法选定它们。所以如果在网格中有一些因故未被包装的文本，要小心它们可能会出现在网格的不可预期的位置，因为它们的位置完全靠自动定位规则来确定。</p><h4 id=行和列>行和列<a hidden class=anchor aria-hidden=true href=#行和列>#</a></h4><p>容器里面的水平区域称为"行"（row），垂直区域称为"列"（column）。</p><p><img loading=lazy src=/CSS/%e8%a1%8c%e5%92%8c%e5%88%97.png alt></p><p>我们通过 <strong>grid-template-columns</strong> 和 <strong>grid-template-rows</strong> 属性来定义网格中的行和列。这些属性定义了网格的行轨道和列轨道。一个网格轨道就是网格中任意两条线之间的空间。</p><h4 id=单元格网格单元>单元格（网格单元）<a hidden class=anchor aria-hidden=true href=#单元格网格单元>#</a></h4><p>一个网格单元是在一个网格元素中最小的单位， 从概念上来讲其实它和表格的一个单元格很像。</p><p>行和列的交叉区域，称为"单元格"（cell）。</p><p>正常情况下，<code>n</code>行和<code>m</code>列会产生<code>n x m</code>个单元格。比如，3行3列会产生9个单元格。</p><p>多个元素可以放置在网格单元格中，或者区域可以部分地彼此重叠。然后可以CSS中的<strong>z-index</strong>属性来控制重叠区域显示的优先级。</p><h4 id=网格线>网格线<a hidden class=anchor aria-hidden=true href=#网格线>#</a></h4><p>应该注意的是，当我们定义网格时，我们定义的是网格轨道，而不是网格线。Grid 会为我们创建编号的网格线来让我们来定位每一个网格元素。</p><p>网格中，假想的划分网格的水平线和垂直线，称为"网格线"（grid line）。水平网格线划分出行，垂直网格线划分出列。这些线在网格的左上角从 1 开始编号，垂直线向右、水平线向下累加计数。</p><p><img loading=lazy src=/CSS/%e7%bd%91%e6%a0%bc%e7%ba%bf.png alt></p><p>正常情况下，<code>n</code>行有<code>n + 1</code>根水平网格线，<code>m</code>列有<code>m + 1</code>根垂直网格线，比如三行就有四根水平网格线。</p><h4 id=隐式和显式网格>隐式和显式网格<a hidden class=anchor aria-hidden=true href=#隐式和显式网格>#</a></h4><p>当我们创建上文中网格例子的时候，我们用 <code>grid-template-columns</code> 属性定义了自己的列轨道，但是却让网格按所需的内容创建行，这些行会被创建在隐式网格中。显式网格包含了你在 <code>grid-template-columns</code> 和 <code>grid-template-rows</code> 属性中定义的行和列。如果你在网格定义之外又放了一些东西，或者因为内容的数量而需要的更多网格轨道的时候，网格将会在隐式网格中创建行和列。按照默认，这些轨道将自动定义尺寸，所以会根据它里面的内容改变尺寸。</p><p>你也可以在隐式网格中用 <code>grid-auto-rows</code> 和 <code>grid-auto-columns</code> 属性来定义一个设置大小尺寸的轨道。</p><h3 id=容器属性>容器属性<a hidden class=anchor aria-hidden=true href=#容器属性>#</a></h3><h4 id=display>display<a hidden class=anchor aria-hidden=true href=#display>#</a></h4><p><code>display: grid</code>指定一个容器采用网格布局。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>div</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>display</span>: <span style=color:#66d9ef>grid</span>;		<span style=color:#75715e>/* block */</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img loading=lazy src=/CSS/display-grid.png alt></p><p>默认情况下，容器元素都是块级元素，但也可以设成行内元素。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>div</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>display</span>: <span style=color:#66d9ef>inline</span><span style=color:#f92672>-</span><span style=color:#66d9ef>grid</span>;		<span style=color:#75715e>/* inline */</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img loading=lazy src=/CSS/display-inline-grid.png alt></p><p>设为网格布局以后，容器子元素（项目）的<code>float</code>、<code>display: inline-block</code>、<code>display: table-cell</code>、<code>vertical-align</code>和<code>column-*</code>等设置都将失效。</p><h4 id=grid-template-columnsgrid-template-rows>grid-template-columns，grid-template-rows<a hidden class=anchor aria-hidden=true href=#grid-template-columnsgrid-template-rows>#</a></h4><p>容器指定了网格布局以后，接着就要划分行和列，明确网格的结构。<code>grid-template-columns</code>属性定义每一列的列宽，<code>grid-template-rows</code>属性定义每一行的行高。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>container</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>display</span>: <span style=color:#66d9ef>grid</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-template-columns</span>: <span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span> <span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span> <span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-template-rows</span>: <span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span> <span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span> <span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>container</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>display</span>: <span style=color:#66d9ef>grid</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>grid-template-columns</span>: <span style=color:#ae81ff>33.33</span><span style=color:#66d9ef>%</span> <span style=color:#ae81ff>33.33</span><span style=color:#66d9ef>%</span> <span style=color:#ae81ff>33.33</span><span style=color:#66d9ef>%</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>grid-template-rows</span>: <span style=color:#ae81ff>33.33</span><span style=color:#66d9ef>%</span> <span style=color:#ae81ff>33.33</span><span style=color:#66d9ef>%</span> <span style=color:#ae81ff>33.33</span><span style=color:#66d9ef>%</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面代码指定了一个三行三列的网格。</p><p><img loading=lazy src=/CSS/columns-rows.png alt></p><p>在 CSS 网格中，可以使用绝对单位（如 <code>px</code>）或相对单位（如 <code>em</code>）来定义行或列的大小。<code>%</code>将列或行调整为它的容器宽度或高度的百分比，</p><p><strong>fr 关键字</strong></p><p>轨道可以使用任何长度单位进行定义。为了方便表示比例关系，网格布局提供了<code>fr</code>关键字（fraction 的缩写，意为"片段"），用于设置列或行占剩余空间的比例。如果两列的宽度分别为<code>1fr</code>和<code>2fr</code>，就表示后者是前者的两倍。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>container</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>display</span>: <span style=color:#66d9ef>grid</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-template-columns</span>: <span style=color:#ae81ff>150</span><span style=color:#66d9ef>px</span> <span style=color:#ae81ff>1</span>fr <span style=color:#ae81ff>2</span>fr;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面代码表示，第一列的宽度为150像素，第二列占剩余空间的宽度是第三列的一半。</p><p><strong>auto 关键字</strong></p><p><code>auto</code>关键字设置列宽或行高自动等于它的内容的宽度或高度，</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>grid-template-columns</span><span style=color:#f92672>:</span> <span style=color:#f92672>100px</span> <span style=color:#f92672>auto</span> <span style=color:#f92672>100px</span><span style=color:#f92672>;</span>
</span></span></code></pre></div><p><strong>repeat()</strong></p><p>可以使用repeat()函数，简化重复的值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>container</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>display</span>: <span style=color:#66d9ef>grid</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-template-columns</span>: <span style=color:#a6e22e>repeat</span>(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>33.33</span><span style=color:#66d9ef>%</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-template-rows</span>: <span style=color:#a6e22e>repeat</span>(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>33.33</span><span style=color:#66d9ef>%</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>repeat()</code>接受两个参数，第一个参数是重复的次数（上例是3），第二个参数是所要重复的值。</p><p><code>repeat()</code>重复某种模式也是可以的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>grid-template-columns</span><span style=color:#f92672>:</span> <span style=color:#f92672>repeat</span><span style=color:#f92672>(</span><span style=color:#f92672>2</span><span style=color:#f92672>,</span> <span style=color:#f92672>100px</span> <span style=color:#f92672>20px</span> <span style=color:#f92672>80px</span><span style=color:#f92672>);</span>
</span></span></code></pre></div><p>上面代码定义了6列，第一列和第四列的宽度为100px，第二列和第五列为20px，第三列和第六列为80px。</p><p><strong>minmax()</strong></p><p><code>minmax()</code>函数产生一个长度范围，表示长度就在这个范围之中。 它的作用是在网格容器改变大小时限制网格项的大小。它接受两个参数，分别为最小值和最大值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>grid-template-columns</span><span style=color:#f92672>:</span> <span style=color:#f92672>1fr</span> <span style=color:#f92672>1fr</span> <span style=color:#f92672>minmax</span><span style=color:#f92672>(</span><span style=color:#f92672>100px</span><span style=color:#f92672>,</span> <span style=color:#f92672>1fr</span><span style=color:#f92672>);</span>
</span></span></code></pre></div><p>上面代码中，<code>minmax(100px, 1fr)</code>表示列宽不小于<code>100px</code>，不大于<code>1fr</code>。</p><p><strong>auto-fill 关键字</strong></p><p>我们可以通过使用<code>repeat</code>方法，配合<code>auto-fill</code>和<code>auto-fit</code>属性，创建类似弹性盒的效果，同时保证内容严格按照行和列的固定规则排列。</p><p>repeat 方法带有一个名为自动填充（auto-fill）的功能。 它的功能是根据容器的大小，尽可能多地放入指定大小的行或列。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>container</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>display</span>: <span style=color:#66d9ef>grid</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-template-columns</span>: <span style=color:#a6e22e>repeat</span>(<span style=color:#66d9ef>auto</span><span style=color:#f92672>-</span><span style=color:#66d9ef>fill</span>, <span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面代码表示每列宽度100px，然后自动填充，直到容器不能放置更多的列。</p><p>你可以通过结合 <code>auto-fill</code> 和 <code>minmax</code> 来更灵活地布局。如果容器宽度不足以将所有网格项放在同一行，余下的网格项将会移至新的一行。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>repeat</span><span style=color:#f92672>(</span><span style=color:#f92672>auto-fill</span><span style=color:#f92672>,</span> <span style=color:#f92672>minmax</span><span style=color:#f92672>(</span><span style=color:#f92672>60px</span><span style=color:#f92672>,</span> <span style=color:#f92672>1fr</span><span style=color:#f92672>));</span>
</span></span></code></pre></div><p>上面的代码效果是这样：首先，列的宽度会随容器大小改变。其次，只要容器宽度不足以插入一个宽为 60px 的列，当前行的所有列就都会一直拉伸。</p><p><img loading=lazy src=/CSS/auto-fill.gif alt></p><p><strong>auto-fit 关键字</strong></p><p><code>auto-fit</code> 效果几乎和 <code>auto-fill</code> 一样。 不同点仅在于，当容器的大小大于各网格项之和时，<code>auto-fill</code> 会持续地在一端放入空行或空列，这样就会使所有网格项挤到另一边；而 <code>auto-fit</code> 则不会在一端放入空行或空列，而是会将所有网格项拉伸至合适的大小。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>grid-template-columns</span><span style=color:#f92672>:</span> <span style=color:#f92672>repeat</span><span style=color:#f92672>(</span><span style=color:#f92672>auto-fit</span><span style=color:#f92672>,</span> <span style=color:#f92672>minmax</span><span style=color:#f92672>(</span><span style=color:#f92672>60px</span><span style=color:#f92672>,</span> <span style=color:#f92672>1fr</span><span style=color:#f92672>));</span>
</span></span></code></pre></div><p><img loading=lazy src=/CSS/auto-fit.gif alt></p><p><strong>网格线的名称</strong></p><p>在用 <code>grid-template-rows</code> 和 <code>grid-template-columns</code> 属性定义网格时，可以为网格中的部分或全部网格线命名。</p><p>使用方括号，指定每一根网格线的名字，方便以后的引用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>container</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>display</span>: <span style=color:#66d9ef>grid</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-template-columns</span>: [c1] <span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span> [c2] <span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span> [c3] <span style=color:#66d9ef>auto</span> [c4];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-template-rows</span>: [r1] <span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span> [r2] <span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span> [r3] <span style=color:#66d9ef>auto</span> [r4];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面代码指定网格布局为3行 x 3列，因此有4根垂直网格线和4根水平网格线。方括号里面依次是这八根线的名字。</p><p>为线命名的方法对于创建响应式页面特别有用，当需要在媒体查询中重新定义网格时，你就不需要通过修改线序号来改变布局，只要直接使用定义过的线名字就可以了，因为（即使在不同的布局中）线的名字总是相同的。</p><p>你可能想要给一条线命名多个名字。为了实现这个效果，只要把多个名字都写到方括号里，然后用空格分隔就行了：<code>[sidebar-end main-start]</code>。在引用时可以使用其中的任何一个名字。</p><p>在选择名字时，如果把一个区域周围的线都用 <code>-start</code> 和 <code>-end</code> 作为后缀，网格就会为区域创建一个名字，名字就是后缀前的单词。不需要通过 <code>grid-template-areas</code> 来指定区域的位置，因为它已经被命名线约束好了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>wrapper</span> {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>display</span>: <span style=color:#66d9ef>grid</span>;
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>grid-template-columns</span>: [main-start] <span style=color:#ae81ff>1</span>fr [<span style=color:#66d9ef>content</span><span style=color:#f92672>-</span><span style=color:#66d9ef>start</span>] <span style=color:#ae81ff>1</span>fr [<span style=color:#66d9ef>content</span><span style=color:#f92672>-</span><span style=color:#66d9ef>end</span>] <span style=color:#ae81ff>1</span>fr [main-end];
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>grid-template-rows</span>: [main-start] <span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span> [<span style=color:#66d9ef>content</span><span style=color:#f92672>-</span><span style=color:#66d9ef>start</span>] <span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span> [<span style=color:#66d9ef>content</span><span style=color:#f92672>-</span><span style=color:#66d9ef>end</span>] <span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span> [main-end];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>thing</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-area</span>: <span style=color:#66d9ef>content</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;</span><span style=color:#f92672>div</span> <span style=color:#f92672>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;wrapper&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;</span><span style=color:#f92672>div</span> <span style=color:#f92672>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;thing&#34;</span><span style=color:#f92672>&gt;</span><span style=color:#f92672>I</span> <span style=color:#f92672>am</span> <span style=color:#f92672>placed</span> <span style=color:#f92672>in</span> <span style=color:#f92672>an</span> <span style=color:#f92672>area</span> <span style=color:#f92672>named</span> <span style=color:#f92672>content</span><span style=color:#f92672>.&lt;/</span><span style=color:#f92672>div</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/</span><span style=color:#f92672>div</span><span style=color:#f92672>&gt;</span>
</span></span></code></pre></div><p>为了获得由命名的区域隐式创建命名线的能力，和由命名线隐式创建区域的能力，在创建网格布局时花一点时间来设计命名策略是非常值得的。慎重地选择名字对你和你的团队的意义在于，你创建网格的工作会变得容易，对其他使用和维护网格的人也大有益处。</p><p>可用 repeat() 定义相同名字的多条线</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>wrapper</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>display</span>: <span style=color:#66d9ef>grid</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>grid-template-columns</span>: <span style=color:#a6e22e>repeat</span>(<span style=color:#ae81ff>12</span>, <span style=color:#960050;background-color:#1e0010>[</span>col<span style=color:#f92672>-</span><span style=color:#66d9ef>start</span><span style=color:#960050;background-color:#1e0010>]</span> <span style=color:#ae81ff>1</span>fr);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面的例子创建了一个有 12 个等宽列的网格，在定义列轨道尺寸为 1fr 之前，也定义了网格线名字 <code>[col-start]</code>，也就是说最终会创建一个 12 列的网格，每个 <code>1fr</code> 宽的列左侧的线都被命名为 <code>col-start</code>。</p><p>如果要引用其他的同名线，就要加上序号。比如要定位项目从名为 col-start 的第1条线开始，到第5条线结束，应该这样写：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>item1</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-column</span>: col-start <span style=color:#f92672>/</span> col-start <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>此处也可以使用 <code>span</code> 关键字。比如下一个项目的位置从名为 <code>col-start</code> 的第7条线开始，跨越3条线。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>item2</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-column</span>: col-start <span style=color:#ae81ff>7</span> <span style=color:#f92672>/</span> span <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>repeat 语法不仅可用于重复的单一轨道尺寸，也可以用于轨道列表。下面的代码创建了一个 8 个轨道的网格，在一个名为 <code>col1-start</code> 的 <code>1fr</code> 窄轨道之后，跟着是一个名为 <code>col2-start</code> 的 <code>3fr</code> 宽轨道。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>wrapper</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-template-columns</span>: <span style=color:#a6e22e>repeat</span>(<span style=color:#ae81ff>4</span>, <span style=color:#960050;background-color:#1e0010>[</span>col1<span style=color:#f92672>-</span><span style=color:#66d9ef>start</span><span style=color:#960050;background-color:#1e0010>]</span> <span style=color:#ae81ff>1</span>fr <span style=color:#960050;background-color:#1e0010>[</span>col2<span style=color:#f92672>-</span><span style=color:#66d9ef>start</span><span style=color:#960050;background-color:#1e0010>]</span> <span style=color:#ae81ff>3</span>fr);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果 repeat 语法包含相邻的两条网格线，那它们会被合并，结果就像是不用 repeat 语法的创建的，所有的网格线都有多个名字。在下面的定义中，创建了四条 <code>1fr</code> 的轨道，每条轨道都有开始名和结束名。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>wrapper</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-template-columns</span>: <span style=color:#a6e22e>repeat</span>(<span style=color:#ae81ff>4</span>, <span style=color:#960050;background-color:#1e0010>[</span>col<span style=color:#f92672>-</span><span style=color:#66d9ef>start</span><span style=color:#960050;background-color:#1e0010>]</span> <span style=color:#ae81ff>1</span>fr <span style=color:#960050;background-color:#1e0010>[</span>col<span style=color:#f92672>-</span><span style=color:#66d9ef>end</span><span style=color:#960050;background-color:#1e0010>]</span> );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果不用 repeat 语法来定义它们，应该写成这样。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>wrapper</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-template-columns</span>: [col-start] <span style=color:#ae81ff>1</span>fr [col-end col-start] <span style=color:#ae81ff>1</span>fr [col-end col-start] <span style=color:#ae81ff>1</span>fr  [col-end col-start] <span style=color:#ae81ff>1</span>fr [col-end];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果已经定义了一个轨道列表，接下来在使用 span 关键字定位项目时，不仅可以在 span 后面写一个行序数，还可以在 <code>span</code> 后面写一个命名线的行序数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>wrapper</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>display</span>: <span style=color:#66d9ef>grid</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-template-columns</span>: <span style=color:#a6e22e>repeat</span>(<span style=color:#ae81ff>6</span>, <span style=color:#960050;background-color:#1e0010>[</span>col1<span style=color:#f92672>-</span><span style=color:#66d9ef>start</span><span style=color:#960050;background-color:#1e0010>]</span> <span style=color:#ae81ff>1</span>fr <span style=color:#960050;background-color:#1e0010>[</span>col2<span style=color:#f92672>-</span><span style=color:#66d9ef>start</span><span style=color:#960050;background-color:#1e0010>]</span> <span style=color:#ae81ff>3</span>fr);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>item1</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-column</span>: col1-start <span style=color:#f92672>/</span> col2-start <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>item2</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-row</span>: <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-column</span>: col1-start <span style=color:#ae81ff>2</span> <span style=color:#f92672>/</span> span <span style=color:#ae81ff>2</span> col1-start;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=row-gapcolumn-gapgap>row-gap，column-gap，gap<a hidden class=anchor aria-hidden=true href=#row-gapcolumn-gapgap>#</a></h4><p>根据最新标准，上面三个属性名的<code>grid-</code>前缀已经删除，<code>grid-column-gap</code>和<code>grid-row-gap</code>写成<code>column-gap</code>和<code>row-gap</code>，<code>grid-gap</code>写成<code>gap</code>。</p><p><code>row-gap</code>属性设置行与行的间隔（行间距），<code>column-gap</code>属性设置列与列的间隔（列间距）。间距只出现在网格轨道与轨道之间，它们并不会出现在网格容器的四周。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>container</span> {
</span></span><span style=display:flex><span>  row-gap: <span style=color:#ae81ff>20</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>column-gap</span>: <span style=color:#ae81ff>20</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>gap</code>属性是<code>column-gap</code>和<code>row-gap</code>的合并简写形式，语法如下。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>gap</span><span style=color:#f92672>:</span> <span style=color:#f92672>row-gap</span> <span style=color:#f92672>column-gap</span><span style=color:#f92672>;</span>
</span></span></code></pre></div><p>如果 <code>gap</code> 只有一个值，那么这个值表示行与行之间、列与列之间的间距均为这个值。 如果有两个值，那么第一个值表示行间距，第二个值表示列间距。</p><p>间距使用的空间会在使用弹性长度fr的轨道的空间计算前就被留出来，间距的尺寸定义行为和普通轨道一致，但不同的是你不能向其中插入任何内容。</p><p>从基于线定位的角度来说，间距的行为就像是使基线变得特别宽。所有从这条线开始的东西会从间距结束的地方开始，你并不能定位也不能放任何东西到这个间距的空间中。如果你希望得到行为和轨道行为相似的间距，你当然可以定义轨道来作为间距。</p><h4 id=grid-template-areas>grid-template-areas<a hidden class=anchor aria-hidden=true href=#grid-template-areas>#</a></h4><p>网格元素可以向行或着列的方向扩展一个或多个单元，并且会创建一个网格区域。网格区域的形状应该是一个矩形 —— 也就是说你不可能创建出一个类似于“L”形的网格区域。</p><p>网格布局允许指定"区域"（area），并为该区域指定一个自定义名称。 一个区域由单个或多个单元格组成。<code>grid-template-areas</code>属性用于定义区域。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>container</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>display</span>: <span style=color:#66d9ef>grid</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-template-columns</span>: <span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span> <span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span> <span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-template-rows</span>: <span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span> <span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span> <span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-template-areas</span>: <span style=color:#e6db74>&#39;a b c&#39;</span>
</span></span><span style=display:flex><span>                       <span style=color:#e6db74>&#39;d e f&#39;</span>
</span></span><span style=display:flex><span>                       <span style=color:#e6db74>&#39;g h i&#39;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在代码中，每个单词代表一个网格单元格，每对引号代表一行。上面代码先划分出9个单元格，然后将其定名为<code>a</code>到<code>i</code>的九个区域，分别对应这九个单元格。</p><p>多个单元格合并成一个区域的写法如下。你需要要把区域名字在它的区域内重复写多次，中间用空格分隔。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>grid-template-areas</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;a a a&#39;</span>
</span></span><span style=display:flex><span>                     <span style=color:#e6db74>&#39;b b b&#39;</span>
</span></span><span style=display:flex><span>                     <span style=color:#e6db74>&#39;c c c&#39;</span><span style=color:#f92672>;</span>
</span></span></code></pre></div><p>上面代码将9个单元格分成<code>a</code>、<code>b</code>、<code>c</code>三个区域。</p><p>你也可以在 <code>grid-template-areas</code> 中添加额外的空格以便让列对齐。你可以看到我把 <code>hd</code> 和 <code>ft</code> 都跟 <code>main</code> 对齐了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>wrapper</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>display</span>: <span style=color:#66d9ef>grid</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>grid-template-columns</span>: <span style=color:#a6e22e>repeat</span>(<span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>1</span>fr);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>grid-auto-rows</span>: <span style=color:#a6e22e>minmax</span>(<span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span>, <span style=color:#66d9ef>auto</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>grid-template-areas</span>:
</span></span><span style=display:flex><span>      <span style=color:#e6db74>&#34;hd hd hd hd   hd   hd   hd   hd   hd&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#e6db74>&#34;sd sd sd main main main main main main&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#e6db74>&#34;.  .  .  ft   ft   ft   ft   ft   ft&#34;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果某些区域不需要利用，则使用"点"（<code>.</code>）来表示一个空单元格。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>grid-template-areas</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;a . c&#39;</span>
</span></span><span style=display:flex><span>                     <span style=color:#e6db74>&#39;d . f&#39;</span>
</span></span><span style=display:flex><span>                     <span style=color:#e6db74>&#39;g . i&#39;</span><span style=color:#f92672>;</span>
</span></span></code></pre></div><p>为了让布局更整齐，可以使用多个 “<code>.</code>” 符号，如果在多个句点符号之间没有空格，那它们就会被计为一个单元格。用多个句点表示一个单元格的好处是对于复杂的布局来说很容易让行列对齐，这意味着你在 CSS 中看到的，就像是实际布局看起来那样。</p><p>注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为<code>区域名-start</code>，终止网格线自动命名为<code>区域名-end</code>。我们可以先用命名的模块区域来定义命名线，再用命名线定位项目。</p><p>grid-template-areas 的值必须是一个完整的网格，否则无效（即这个属性会被忽略掉），这意味着你应该让每一行都有相同数量的单元格，如果出现句点符就表示这个单元格将被留空。如果创建的区域不是矩形，也是无效的网格。</p><p>用媒体查询重新定义网格</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>header</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>grid-area</span>: hd;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>footer</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>grid-area</span>: ft;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>content</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>grid-area</span>: main;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>sidebar</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>grid-area</span>: sd;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>wrapper</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>display</span>: <span style=color:#66d9ef>grid</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>grid-auto-rows</span>: <span style=color:#a6e22e>minmax</span>(<span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span>, <span style=color:#66d9ef>auto</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>grid-template-columns</span>: <span style=color:#ae81ff>1</span>fr;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>grid-template-areas</span>:
</span></span><span style=display:flex><span>      <span style=color:#e6db74>&#34;hd&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#e6db74>&#34;main&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#e6db74>&#34;sd&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#e6db74>&#34;ft&#34;</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@<span style=color:#66d9ef>media</span> <span style=color:#f92672>(</span><span style=color:#f92672>min-width</span><span style=color:#f92672>:</span> <span style=color:#f92672>500px</span><span style=color:#f92672>)</span> {
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>wrapper</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>grid-template-columns</span>: <span style=color:#a6e22e>repeat</span>(<span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>1</span>fr);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>grid-template-areas</span>:
</span></span><span style=display:flex><span>          <span style=color:#e6db74>&#34;hd hd hd hd   hd   hd   hd   hd   hd&#34;</span>
</span></span><span style=display:flex><span>          <span style=color:#e6db74>&#34;sd sd sd main main main main main main&#34;</span>
</span></span><span style=display:flex><span>          <span style=color:#e6db74>&#34;sd sd sd  ft  ft   ft   ft   ft   ft&#34;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@<span style=color:#66d9ef>media</span> <span style=color:#f92672>(</span><span style=color:#f92672>min-width</span><span style=color:#f92672>:</span> <span style=color:#f92672>700px</span><span style=color:#f92672>)</span> {
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>wrapper</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>grid-template-areas</span>:
</span></span><span style=display:flex><span>          <span style=color:#e6db74>&#34;hd hd hd   hd   hd   hd   hd   hd hd&#34;</span>
</span></span><span style=display:flex><span>          <span style=color:#e6db74>&#34;sd sd main main main main main ft ft&#34;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们可以发现使用网格布局时有非常多不同的方法来定位项目，这乍看起来有些过于复杂了，不过其实你不必把它们都用上。在实践中，我发现使用命名的模块区域是最直截了当的布局方法，它的可视化表示法能让你看到布局的效果，并且也容易在网格上移动项目。</p><h4 id=grid-auto-flow>grid-auto-flow<a hidden class=anchor aria-hidden=true href=#grid-auto-flow>#</a></h4><p>划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是"先行后列"，即先填满第一行，再开始放入第二行，即下图数字的顺序。</p><p><img loading=lazy src=/CSS/columns-rows.png alt></p><p>这个顺序由<code>grid-auto-flow</code>属性决定，默认值是<code>row</code>，即"先行后列"。也可以将它设成<code>column</code>，变成"先列后行"。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>grid-auto-flow</span><span style=color:#f92672>:</span> <span style=color:#f92672>column</span><span style=color:#f92672>;</span>
</span></span></code></pre></div><p>上面代码设置了column以后，放置顺序就变成了下图。</p><p><img loading=lazy src=/CSS/grid-auto-flow-column.png alt></p><p><code>grid-auto-flow</code>属性还可以设成<code>row dense</code>和<code>column dense</code>。默认的<code>grid-auto-flow: row</code>情况下，会产生下面这样的布局。</p><p><img loading=lazy src=/CSS/grid-auto-flow-row.png alt></p><p>这是因为对于自动定位的项目，如果轨道的大小不适合放入一个项目，这个项目就会被移动到下一行，直至它找到了可以容纳它的空间。也就是说除了我们明确定位过的项目，其他项目一般都会被网格自动处理并且保持它们在 DOM 中的顺序，这正是一般情况下我们想要的结果。比如你设计了一个表单，当然不想让标签和别的表单元素因为要填充缺口而使表单变得前后错乱。</p><p>不过有时候要布局的项目并没有逻辑顺序，所以我们希望能够创建一种没有缺口的布局。实现这个效果的方法是在网格容器的 <a href=https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-auto-flow><code>grid-auto-flow</code></a> 属性值中加入 <code>dense</code> 关键字。</p><p><code>grid-auto-flow</code> 设为<code>row dense</code>，表示"先行后列"，并且尽可能紧密填满，尽量不出现空格。</p><p><img loading=lazy src=/CSS/grid-auto-flow-row-dense.png alt></p><p>如果将设置改为<code>column dense</code>，表示"先列后行"，并且尽量填满空格。</p><p><img loading=lazy src=/CSS/grid-auto-flow-column-dense.png alt></p><p>经过以上设置，网格就会回填缺口，以前网格会遗留下缺口，而现在它会为此前的缺口找到适合它的项目，然后把项目从 DOM 中拿出来再放到缺口中去。对于已经重新指定过顺序的网格，这样做不会改变项目之间原有的逻辑顺序，比如对于 Tab 键的顺序仍然与文档的顺序相同。此外你应该意识到，使用这个功能会让 DOM 中看到的顺序与实际显示的顺序不一致，它们两者之间的联系会被打破。</p><h4 id=justify-itemsalign-itemsplace-items>justify-items，align-items，place-items<a hidden class=anchor aria-hidden=true href=#justify-itemsalign-itemsplace-items>#</a></h4><p>网格布局方式下共有两条轴线用于对齐 —— <strong>块方向的列轴</strong>和<strong>文字方向的行轴</strong>。块方向的轴是采用块布局时块的排列方向。假设页面中有两个段落，其中一个显示在另一个下面，所以这个方向的轴被称为块方向的轴。在 CSS 网格布局规范中，它被称为列轴，因为这条轴的方向和列轨道是一致的。</p><p><strong>行方向的轴</strong>与块方向的轴垂直，它的方向和普通文本的方向一致。在 CSS 网格规范中，它有时被称为行轴，因为这条轴的方向和行轨道是一致的。</p><p>我们可以把网格区域中的内容，以及网格轨道整体与这两条轴线对齐。所谓对齐，就是可以使项目在该轴上移动。</p><p><code>justify-items</code>属性设置项目的行轴（左中右）对齐方式， <a href=https://developer.mozilla.org/zh-CN/docs/Web/CSS/align-items><code>align-items</code></a> 用于控制项目在列轴（上中下）对齐方式。它们会将所有网格中所有的项目按所设置的方式对齐，相当于为所有的项目都设置了 <a href=https://developer.mozilla.org/zh-CN/docs/Web/CSS/justify-self><code>justify-self</code></a> 属性和 <code>align-items</code> 属性。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>container</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>justify-items</span>: <span style=color:#66d9ef>start</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>end</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>center</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>stretch</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>align-items</span>: <span style=color:#66d9ef>start</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>end</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>center</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>stretch</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img loading=lazy src=/CSS/place-items.png alt></p><ul><li>start：对齐单元格的起始边缘。</li><li>end：对齐单元格的结束边缘。</li><li>center：单元格内部居中。</li><li>stretch（默认值）：拉伸，占满单元格的整个宽度。</li></ul><p>规范中对 <code>align-self</code> 的默认行为是拉伸（<code>stretch</code>），例外的情况是若项目具有固定宽高比，行为就改为与轴起点对齐（<code>start</code>）。此项例外的原因在于，如果把一个有固定宽高比的项目拉伸，将导致它扭曲变形。</p><p><code>place-items</code>属性是<code>align-items</code>属性和<code>justify-items</code>属性的合并简写形式。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>place-items</span><span style=color:#f92672>:</span> <span style=color:#f92672>align-items</span> <span style=color:#f92672>justify-items</span><span style=color:#f92672>;</span>
</span></span></code></pre></div><p>如果省略第二个值，则浏览器认为与第一个值相等。</p><h4 id=justify-contentalign-contentplace-content>justify-content，align-content，place-content<a hidden class=anchor aria-hidden=true href=#justify-contentalign-contentplace-content>#</a></h4><p>设想这样一种场景，网格轨道整体占据的空间小于网格容器，那么就可以在容器中对齐网格轨道。针对块方向和文本方向的轴线，分别使用 <code>align-content</code> 对齐到块方向的轴线，使用 <code>justify-content</code> 对齐到文本方向的轴线。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>container</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>justify-content</span>: <span style=color:#66d9ef>start</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>end</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>center</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>stretch</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>space-around</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>space-between</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>space</span><span style=color:#f92672>-</span>evenly;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>align-content</span>: <span style=color:#66d9ef>start</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>end</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>center</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>stretch</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>space-around</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>space-between</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>space</span><span style=color:#f92672>-</span>evenly;  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>start - 对齐容器的起始边框。</li><li>end - 对齐容器的结束边框。</li><li>center - 容器内部居中。</li><li>stretch - 项目大小没有指定时，拉伸占据整个网格容器。</li><li>space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。</li><li>space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔。</li><li>space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。</li></ul><p>下面的例子中，网格容器的宽高都是 500 像素，分别定义了行轨道和列轨道各 3 条，轨道尺寸为 100 像素，轨道间隙为 10 像素。可知，网格容器的块方向和文字方向都留有多余的空间。</p><p>属性 <code>align-content</code> 要设置在网格容器上，但它的效果却体现在内部的网格中。网格布局中默认的行为是对齐到起点（<code>start</code>），所以我们看到网格轨道整体居于网格的左上角，紧挨着起始的网格线：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>wrapper</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>display</span>: <span style=color:#66d9ef>grid</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-template-columns</span>: <span style=color:#a6e22e>repeat</span>(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-template-rows</span>: <span style=color:#a6e22e>repeat</span>(<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>height</span>: <span style=color:#ae81ff>500</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>width</span>: <span style=color:#ae81ff>500</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-gap</span>: <span style=color:#ae81ff>10</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-template-areas</span>:
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;a a b&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;a a b&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;c d d&#34;</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>align-content</span>: <span style=color:#66d9ef>space-between</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>item1</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-area</span>: a;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>item2</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-area</span>: b;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>item3</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-area</span>: c;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>item4</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-area</span>: d;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;</span><span style=color:#f92672>div</span> <span style=color:#f92672>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;wrapper&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;</span><span style=color:#f92672>div</span> <span style=color:#f92672>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;item1&#34;</span><span style=color:#f92672>&gt;</span><span style=color:#f92672>Item</span> <span style=color:#f92672>1</span><span style=color:#f92672>&lt;/</span><span style=color:#f92672>div</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;</span><span style=color:#f92672>div</span> <span style=color:#f92672>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;item2&#34;</span><span style=color:#f92672>&gt;</span><span style=color:#f92672>Item</span> <span style=color:#f92672>2</span><span style=color:#f92672>&lt;/</span><span style=color:#f92672>div</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;</span><span style=color:#f92672>div</span> <span style=color:#f92672>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;item3&#34;</span><span style=color:#f92672>&gt;</span><span style=color:#f92672>Item</span> <span style=color:#f92672>3</span><span style=color:#f92672>&lt;/</span><span style=color:#f92672>div</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;</span><span style=color:#f92672>div</span> <span style=color:#f92672>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;item4&#34;</span><span style=color:#f92672>&gt;</span><span style=color:#f92672>Item</span> <span style=color:#f92672>4</span><span style=color:#f92672>&lt;/</span><span style=color:#f92672>div</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/</span><span style=color:#f92672>div</span><span style=color:#f92672>&gt;</span>
</span></span></code></pre></div><p>有必要强调一下，这些与分配空间有关的值会使网格项目变大。如果项目跨越了多于一条轨道，因为轨道的间隙变大了，所以项目也变得更大了。因为精确尺寸的网格较为常用，所以如果你决定使用这些值，一定要确保其中的内容能够适应多出来的空间，或者在使用这些属性值时，把项目的对齐方式设置为对齐到起点（<code>start</code>），可能会比设置为拉伸（<code>stretch</code>）要好。</p><p>下图中的网格使用了 <code>align-content</code> 属性，左侧的值为 <code>start</code>，右侧的值为 <code>space-between</code>。观察 Item 1 和 Item 2，它们都跨越了两条行轨道，右侧的图因为增加了轨道间隙，所以它们占据的空间变大了：</p><p><img loading=lazy src=/CSS//space-between.png alt></p><p>在行轴上使用 justify-content 属性可以获得与在列轴上使用 align-content 相同的对齐效果。设置 justify-content 的值为 space-around，那些占据超过一列的项目将因此获得额外的空间。</p><p><code>place-content</code>属性是<code>align-content</code>属性和<code>justify-content</code>属性的合并简写形式。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>place-content</span><span style=color:#f92672>:</span> <span style=color:#f92672>&lt;</span><span style=color:#f92672>align-content</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&lt;</span><span style=color:#f92672>justify-content</span><span style=color:#f92672>&gt;</span>
</span></span></code></pre></div><p>如果省略第二个值，浏览器就会假定第二个值等于第一个值。</p><h4 id=grid-auto-columnsgrid-auto-rows>grid-auto-columns，grid-auto-rows<a hidden class=anchor aria-hidden=true href=#grid-auto-columnsgrid-auto-rows>#</a></h4><p>为了精确地把项目摆放到网格中，CSS 网格布局规范还包含另外一组规则，用来约定当部分或全部子项目没有被明确指定位置时该如何处理。你会发现针对含有数个项目的网格，实际上最简单的方式就是使用自动定位。如果没有为项目指定位置信息，它们就会把自己摆放在网格中，每个单元格中放一个。</p><p>默认的流向是按行排列项目，网格会首先尝试在第1行的每个单元格中摆放项目。如果已经通过 <code>grid-template-rows</code> 属性创建了其他行，网格就会继续把项目摆放到这些行中。如果在显式的网格中没有足够的行用来摆放所有的项目，隐式的新行就会被创建出来。</p><p>在默认情况下，网格中被自动创建的隐式行的尺寸是自适应大小的，也就是说它们会包含所有属于它们的内容，而不会让内容溢出。</p><p>不过你可以通过 <code>grid-auto-columns</code>属性和<code>grid-auto-rows</code>属性 属性来控制它们的大小。</p><p>浏览器自动创建的隐式行的列宽和行高。它们的写法与<code>grid-template-columns</code>和<code>grid-template-rows</code>完全相同。如果不指定这两个属性，浏览器完全根据项目的大小，决定新增网格的列宽和行高。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>container</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>display</span>: <span style=color:#66d9ef>grid</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-template-columns</span>: <span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span> <span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span> <span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-template-rows</span>: <span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span> <span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span> <span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-auto-rows</span>: <span style=color:#ae81ff>50</span><span style=color:#66d9ef>px</span>; 
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=grid-templategrid>grid-template，grid<a hidden class=anchor aria-hidden=true href=#grid-templategrid>#</a></h4><p><code>grid-template</code>属性是<code>grid-template-columns</code>、<code>grid-template-rows</code>和<code>grid-template-areas</code>这三个属性的合并简写形式。</p><p><code>grid</code>属性是<code>grid-template-rows</code>、<code>grid-template-columns</code>、<code>grid-template-areas</code>、 <code>grid-auto-rows</code>、<code>grid-auto-columns</code>、<code>grid-auto-flow</code>这六个属性的合并简写形式。</p><p>从易读易写的角度考虑，还是建议不要合并属性，所以这里就不详细介绍这两个属性了。</p><h3 id=项目属性>项目属性<a hidden class=anchor aria-hidden=true href=#项目属性>#</a></h3><h4 id=grid-column-startgrid-column-endgrid-row-startgrid-row-end>grid-column-start，grid-column-end，grid-row-start，grid-row-end<a hidden class=anchor aria-hidden=true href=#grid-column-startgrid-column-endgrid-row-startgrid-row-end>#</a></h4><p>项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。</p><ul><li>grid-column-start属性：左边框所在的垂直网格线</li><li>grid-column-end属性：右边框所在的垂直网格线</li><li>grid-row-start属性：上边框所在的水平网格线</li><li>grid-row-end属性：下边框所在的水平网格线</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>item-1</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-column-start</span>: <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-column-end</span>: <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>其他没有指定位置的项目，由浏览器自动布局，这时它们的位置由容器的<code>grid-auto-flow</code>属性决定。</p><p>在逐个定义元素后，注意，我们可以留空一些单元格。网格布局的一个优势是：无需给元素周围加上margin来阻止文档流自动填补空白，就能实现设计中的留白区域。</p><p>使用这四个属性，如果产生了项目的重叠，则使用<code>z-index</code>属性指定项目的重叠顺序。</p><p>这四个属性的值，除了指定为第几个网格线，还可以指定为网格线的名字。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>item-1</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-column-start</span>: header-start;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-column-end</span>: header-end;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这四个属性的值还可以使用<code>span</code>关键字，表示"跨越"，即左右边框（上下边框）之间跨越多少个网格。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>item-1</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-column-start</span>: span <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这个元素就会从1号线开始，跨越3个线，到4号线结束。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>box1</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>grid-column</span>: <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>grid-row</span>: <span style=color:#ae81ff>1</span> <span style=color:#f92672>/</span>  span <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这个元素会从4号线开始，跨越3个线到1号线。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>box1</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>grid-column</span>: <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>grid-row</span>: span <span style=color:#ae81ff>3</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=grid-column-grid-row>grid-column， grid-row<a hidden class=anchor aria-hidden=true href=#grid-column-grid-row>#</a></h4><p><code>grid-column</code>属性是<code>grid-column-start</code>和<code>grid-column-end</code>的合并简写形式，<code>grid-row</code>属性是<code>grid-row-start</code>属性和<code>grid-row-end</code>的合并简写形式。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>item</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-column</span>: <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>start</span><span style=color:#f92672>-</span>line<span style=color:#f92672>&gt;</span> <span style=color:#f92672>/</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>end</span><span style=color:#f92672>-</span>line<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-row</span>: <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>start</span><span style=color:#f92672>-</span>line<span style=color:#f92672>&gt;</span> <span style=color:#f92672>/</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>end</span><span style=color:#f92672>-</span>line<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>item-1</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-column</span>: <span style=color:#ae81ff>1</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-row</span>: <span style=color:#ae81ff>1</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这两个属性之中，也可以使用<code>span</code>关键字，表示跨越多少个网格。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>item-1</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-column</span>: <span style=color:#ae81ff>1</span> <span style=color:#f92672>/</span> span <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-row</span>: <span style=color:#ae81ff>1</span> <span style=color:#f92672>/</span> span <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>斜杠以及后面的部分可以省略，默认跨越一个网格。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>item-1</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-column</span>: <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-row</span>: <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=grid-area>grid-area<a hidden class=anchor aria-hidden=true href=#grid-area>#</a></h4><p>在为网格添加区域模板后，可以通过引用你所定义的区域的名称，将元素放入相应的区域。 <code>grid-area</code>属性指定项目放在哪一个区域。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>item-1</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-area</span>: e;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>grid-area</code>属性还可用作<code>grid-row-start</code>、<code>grid-column-start</code>、<code>grid-row-end</code>、<code>grid-column-end</code>的合并简写形式，直接指定项目的位置。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>item</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-area</span>: <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>row</span><span style=color:#f92672>-</span><span style=color:#66d9ef>start</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>/</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>column</span><span style=color:#f92672>-</span><span style=color:#66d9ef>start</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>/</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>row</span><span style=color:#f92672>-</span><span style=color:#66d9ef>end</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>/</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>column</span><span style=color:#f92672>-</span><span style=color:#66d9ef>end</span><span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>item-1</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-area</span>: <span style=color:#ae81ff>1</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们也可以从行和块结束线开始反方向计数，对于英语来说就是右端的列线和底端的行线。这些线会被记为 <code>-1</code>，然后你可以从这往前数，所以倒数第2条线会被记为 <code>-2</code>。值得注意的是最后一条线是指显式定义网格的最后一条线，即由 <code>grid-template-columns</code> 和 <code>grid-template-rows</code> 定义的网格，并不把隐式定义网格的加入的行和列纳入考虑。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>item</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>grid-column</span>: <span style=color:#ae81ff>1</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>-1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面代码使一个元素跨越整个网格。</p><h4 id=justify-self-align-self-place-self>justify-self， align-self， place-self<a hidden class=anchor aria-hidden=true href=#justify-self-align-self-place-self>#</a></h4><p><code>justify-self</code>属性设置项目的水平位置（左中右）对齐方式，跟<code>justify-items</code>属性的用法完全一致，但只作用于单个项目。</p><p><code>align-self</code>属性设置项目的垂直位置（上中下）对齐方式，跟<code>align-items</code>属性的用法完全一致，也是只作用于单个项目。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>item</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>justify-self</span>: <span style=color:#66d9ef>start</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>end</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>center</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>stretch</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>align-self</span>: <span style=color:#66d9ef>start</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>end</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>center</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>stretch</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>start：对齐单元格的起始边缘。</li><li>end：对齐单元格的结束边缘。</li><li>center：单元格内部居中。</li><li>stretch（默认值）：拉伸，占满单元格的整个宽度。</li></ul><p><code>place-self</code>属性是<code>align-self</code>属性和<code>justify-self</code>属性的合并简写形式。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>place-self</span><span style=color:#f92672>:</span> <span style=color:#f92672>&lt;</span><span style=color:#f92672>align-self</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&lt;</span><span style=color:#f92672>justify-self</span><span style=color:#f92672>&gt;;</span>
</span></span></code></pre></div><p>如果省略第二个值，<code>place-self</code>属性会认为这两个值相等。</p><h3 id=补充>补充<a hidden class=anchor aria-hidden=true href=#补充>#</a></h3><h4 id=网格布局中的盒模型对齐httpsdevelopermozillaorgzh-cndocswebcsscss_grid_layoutbox_alignment_in_css_grid_layout><a href=https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Box_Alignment_in_CSS_Grid_Layout>网格布局中的盒模型对齐</a><a hidden class=anchor aria-hidden=true href=#网格布局中的盒模型对齐httpsdevelopermozillaorgzh-cndocswebcsscss_grid_layoutbox_alignment_in_css_grid_layout>#</a></h4><p><a href=https://stackoverflow.com/questions/48535585/what-is-difference-between-justify-self-justify-items-and-justify-content-in-cs>What is difference between justify-self, justify-items and justify-content in CSS grid? - Stack Overflow</a></p><p>可以这样理解，grid 把容器分成一块一块的单元格，每一块单元格都可以放置一个项目。</p><p>justify-items 对齐的是项目。 justify-content 对齐的是单元格。grid-gap 是单元格之间间距。</p><p>另一个在网格区域内使项目对齐的方法是使用自动外边距。如果你曾经用过把容器的左右外边距都设置为 <code>auto</code> 以让页面布局显示在视口中间的方法的话，你肯定知道自动外边距能够消化掉全部的多余空间。当把两侧的外边距都设置为 <code>auto</code> 时，块元素就会被挤到中间，多余的空间则被留到两侧。</p><p>在下面的例子中，项目 item 1 的左外边距被设置成 <code>auto</code>，可以看到内容被推到了区域右侧，因为在为项目的内容分配了空间之后，自动外边距占据了剩余的空间：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>wrapper</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>display</span>: <span style=color:#66d9ef>grid</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-template-columns</span>: <span style=color:#a6e22e>repeat</span>(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-template-rows</span>: <span style=color:#a6e22e>repeat</span>(<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>height</span>: <span style=color:#ae81ff>500</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>width</span>: <span style=color:#ae81ff>500</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-gap</span>: <span style=color:#ae81ff>10</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-template-areas</span>:
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;a a b&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;a a b&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;c d d&#34;</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>item1</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-area</span>: a;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>margin-left</span>: <span style=color:#66d9ef>auto</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>item2</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-area</span>: b;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>item3</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-area</span>: c;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>item4</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>grid-area</span>: d;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;</span><span style=color:#f92672>div</span> <span style=color:#f92672>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;wrapper&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;</span><span style=color:#f92672>div</span> <span style=color:#f92672>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;item1&#34;</span><span style=color:#f92672>&gt;</span><span style=color:#f92672>Item</span> <span style=color:#f92672>1</span><span style=color:#f92672>&lt;/</span><span style=color:#f92672>div</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;</span><span style=color:#f92672>div</span> <span style=color:#f92672>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;item2&#34;</span><span style=color:#f92672>&gt;</span><span style=color:#f92672>Item</span> <span style=color:#f92672>2</span><span style=color:#f92672>&lt;/</span><span style=color:#f92672>div</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;</span><span style=color:#f92672>div</span> <span style=color:#f92672>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;item3&#34;</span><span style=color:#f92672>&gt;</span><span style=color:#f92672>Item</span> <span style=color:#f92672>3</span><span style=color:#f92672>&lt;/</span><span style=color:#f92672>div</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;</span><span style=color:#f92672>div</span> <span style=color:#f92672>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;item4&#34;</span><span style=color:#f92672>&gt;</span><span style=color:#f92672>Item</span> <span style=color:#f92672>4</span><span style=color:#f92672>&lt;/</span><span style=color:#f92672>div</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/</span><span style=color:#f92672>div</span><span style=color:#f92672>&gt;</span>
</span></span></code></pre></div><p><img loading=lazy src=/CSS/auto_margins.png alt></p><p>可以理解为 <code>justify-items: end;</code> 和 <code>align-items: stretch;</code>。</p><h4 id=作为包含块的网格容器httpsdevelopermozillaorgzh-cndocswebcsscss_grid_layoutrelationship_of_grid_layout作为包含块的网格容器><a href=https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Relationship_of_Grid_Layout#%E4%BD%9C%E4%B8%BA%E5%8C%85%E5%90%AB%E5%9D%97%E7%9A%84%E7%BD%91%E6%A0%BC%E5%AE%B9%E5%99%A8>作为包含块的网格容器</a><a hidden class=anchor aria-hidden=true href=#作为包含块的网格容器httpsdevelopermozillaorgzh-cndocswebcsscss_grid_layoutrelationship_of_grid_layout作为包含块的网格容器>#</a></h4><p>要使网格容器成为一个包含块，需要为容器增加 <code>position</code> 属性，并把它的值设置为 <code>relative</code>，就像为任何其他绝对定位的项目创建一个包含块一样。接下来，如果再把一个网格项目设置为 <code>position: absolute</code>，那么网格容器就成为包含块，或者如果该项目具有网格定位的属性，那么被放置的网格就成为包含块。</p><p>如果具有绝对定位的子元素的父级是网格容器，即使网格容器没有被设置为新的定位上下文（译注：即网格容器没有设置 <code>position: relative</code> 属性），该子元素仍会脱离文档流。定位是基于定位上下文的，和这其他布局方式没有区别。</p><p>此外，该项目不再被视为网格布局的一部分，当网格中其他元素调整尺寸或自动布局时，都与该项目无关。</p><h4 id=网格和-display-contentshttpsdevelopermozillaorgzh-cndocswebcsscss_grid_layoutrelationship_of_grid_layout网格和_display_contents><a href=https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Relationship_of_Grid_Layout#%E7%BD%91%E6%A0%BC%E5%92%8C_display_contents>网格和 <code>display: contents</code></a><a hidden class=anchor aria-hidden=true href=#网格和-display-contentshttpsdevelopermozillaorgzh-cndocswebcsscss_grid_layoutrelationship_of_grid_layout网格和_display_contents>#</a></h4><p>设置 <code>display: contents</code> 元素本身不会生成任何盒子，但其子元素和伪元素仍然会像平常一样生成盒子。为了生成盒子和布局，必须将元素视为已在文档树中被其子元素和伪元素替换。</p><p>如果将项目设置为 <code>display: contents</code>，通常自身的盒子会消失，子元素的盒子仍显示，就像子元素在文档树中上升了一层。这意味着一个网格项目的子元素可以成为网格项目。</p><p>这可以让项目嵌套到网格中，就好像它们是网格的一部分一样，并且可以用它解决 <code>subgrid</code> 值尚未实现时要解决的一些问题。 也可以在 flex 布局中用类似的方法通过 <code>display: contents</code> 使嵌套的项目成为 flex 项目。</p><p>比如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;outer&#34;</span>&gt;
</span></span><span style=display:flex><span>  I&#39;m, some content
</span></span><span style=display:flex><span>  &lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;inner&#34;</span>&gt;I&#39;m some inner content &lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&lt;<span style=color:#f92672>style</span>&gt;
</span></span><span style=display:flex><span>  .<span style=color:#a6e22e>outer</span> {
</span></span><span style=display:flex><span>  	<span style=color:#66d9ef>border</span>: <span style=color:#ae81ff>2</span><span style=color:#66d9ef>px</span> <span style=color:#66d9ef>solid</span> <span style=color:#66d9ef>lightcoral</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>background-color</span>: <span style=color:#66d9ef>lightpink</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>padding</span>: <span style=color:#ae81ff>20</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  .<span style=color:#a6e22e>innter</span> {
</span></span><span style=display:flex><span>  	<span style=color:#66d9ef>background-color</span>: <span style=color:#ae81ff>#ffdb3a</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>padding</span>: <span style=color:#ae81ff>20</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>style</span>&gt;
</span></span></code></pre></div><p>上面这个简单地示例代码，你将看到的效果如下： <img loading=lazy src=/CSS/contents.png alt></p><p>如果我们在<code>.outer</code> 元素上显式设置 <code>display: contents</code> ，该元素本身不会被渲染，但子元素能够正常渲染：</p><p><img loading=lazy src=/CSS/contents2.png alt></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://sakamotokurome.github.io/tags/css/>CSS</a></li><li><a href=https://sakamotokurome.github.io/tags/frontend/>Frontend</a></li></ul><nav class=paginav><a class=next href=https://sakamotokurome.github.io/posts/html/><span class=title>Next Page »</span><br><span>HTML 教程</span></a></nav></footer></article><script src=https://utteranc.es/client.js repo=SakamotoKurome/SakamotoKurome.github.io issue-term=pathname theme=github-dark crossorigin=anonymous async></script></main><footer class=footer><span>&copy; 2023 <a href=https://sakamotokurome.github.io/>Sakamoto Kurome</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>