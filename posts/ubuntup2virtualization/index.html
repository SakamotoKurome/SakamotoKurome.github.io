<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Ubuntu Virtualization | Sakamoto Kurome</title>
<meta name=keywords content="Unix,Linux,Ubuntu">
<meta name=description content="Wine 简介 Wine 是在x86、x86-64容许类Unix操作系统在X Window System运行Microsoft Windows程序的软件。另外，Wine也提供">
<meta name=author content="Sakamoto Kurome">
<link rel=canonical href=https://sakamotokurome.github.io/posts/ubuntup2virtualization/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.06402d745029223a9231706eea1dd82e107754f4ad625acbe7fd336a5e59566c.css integrity="sha256-BkAtdFApIjqSMXBu6h3YLhB3VPStYlrL5/0zal5ZVmw=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://sakamotokurome.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://sakamotokurome.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://sakamotokurome.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://sakamotokurome.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://sakamotokurome.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.90.0">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
</noscript>
<link rel=stylesheet href=https://sakamotokurome.github.io/custom.css>
<meta name=google-site-verification content="i2r403EffR8m-KBf7EHi6AYg7tfnMshaXTAynoYPnpE">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-K2Y212LPQ2"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-K2Y212LPQ2',{anonymize_ip:!1})}</script>
<meta property="og:title" content="Ubuntu Virtualization">
<meta property="og:description" content="Wine 简介 Wine 是在x86、x86-64容许类Unix操作系统在X Window System运行Microsoft Windows程序的软件。另外，Wine也提供">
<meta property="og:type" content="article">
<meta property="og:url" content="https://sakamotokurome.github.io/posts/ubuntup2virtualization/">
<meta property="og:image" content="https://sakamotokurome.github.io/Covers/ubuntu03.jpg.webp"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2022-03-08T15:32:02+08:00">
<meta property="article:modified_time" content="2022-03-08T15:32:02+08:00">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://sakamotokurome.github.io/Covers/ubuntu03.jpg.webp">
<meta name=twitter:title content="Ubuntu Virtualization">
<meta name=twitter:description content="Wine 简介 Wine 是在x86、x86-64容许类Unix操作系统在X Window System运行Microsoft Windows程序的软件。另外，Wine也提供">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sakamotokurome.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Ubuntu Virtualization","item":"https://sakamotokurome.github.io/posts/ubuntup2virtualization/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Ubuntu Virtualization","name":"Ubuntu Virtualization","description":"Wine 简介 Wine 是在x86、x86-64容许类Unix操作系统在X Window System运行Microsoft Windows程序的软件。另外，Wine也提供","keywords":["Unix","Linux","Ubuntu"],"articleBody":"Wine 简介 Wine 是在x86、x86-64容许类Unix操作系统在X Window System运行Microsoft Windows程序的软件。另外，Wine也提供程序运行库（Winelib）来帮助计算机程序设计师将Windows程序移植到类Unix系统；也有不少软件经过Wine测试后发布，比如Picasa、uTorrent、MediaCoder。\nWine通过提供一个兼容层来将Windows的系统调用转换成与POSIX标准的系统调用。它还提供了Windows系统运行库的替代品和一些系统组件的替代品。为了避免著作权问题，Wine主要使用黑箱测试逆向工程来编写。\nWine最早是“Windows Emulator”，即Windows模拟器的缩写，但Wine现在为“Wine Is Not an Emulator”的递归缩写，即Wine不是模拟器。Wine的正确名称是“Wine”，而不是全大写或全小写。\nWine计划在1993年由Bob Amstadt及Eric Youngdale发起，最初目的是为了让16位Windows 3.1程序可以在Linux上执行，但随着电脑和时代的演进，Wine也一路支持到更新的Windows和64位的计算机体系结构。\n由于Windows的DLL为封闭源代码，所以程序员只能由最底层的设计开始，耗费大量的时间来编写和测试，最后达至兼容，这过程是困难且缓慢的。\n在1999年期间，当Corel加入这个计划后，Wine很快便能兼容WordPerfect Office，但Corel不久便停止支持这项计划，所以Wine的发展又逐渐趋缓，一直到2006年Google积极参与这个计划后，Wine的发展才又恢复起色，最后终于在2008年发布首个稳定版，其后便以每两周发布一个新版的速度发展着，除此之外，Google每年所举办的夏日代码大赛活动也对Wine有着不少贡献。\nWine虽然是从Linux开始发展，但现在已经支持多种平台，有BSD、Mac OS X与Solaris-x86，在2013年的自由及开源软件开发者欧洲会议上，Wine的项目领导人Alexandre Julliard（英语：Alexandre Julliard）表示目前将积极支持Android平台。\n在2008年，Wine已经能够完美运行很多知名程序，例如Lotus Notes及Microsoft Office 2007，Photoshop CS2，但其可靠性及稳定性仍有待改善。如果该程序包含本地的微软Windows系统的库，那样Wine便可很顺利运行该程序。\n有些Wine DLLs亦已能完美地取代Windows原来的DLLs，使得有些程序可完美运行。\n最晚到2006年，Wine上面已经可以完全基于Wine DLL完美地运行暴雪发行的多款3D游戏了，如魔兽世界、魔兽争霸等。\n注：以下如果使用zsh，~ 应替换为 $HOME才能正常使用\n安装 Here the difference between the packages:\n winehq-staging: this is the most recent testing wine version. winehq-stable: this is the current stable wine version (probably the one you should install) winehq-devel: this package is used to provide development headers, mostly used by third party software compilation. wine-development: unsure for this one, but probably helps wine developers to debug EXE running with wine with more debug information.  使用 wine 的 tuna mirror 安装最新版本\n如果您之前安装过来自其他仓库的 Wine 安装包，请在尝试安装 WineHQ 安装包之前删除它及依赖它的所有安装包（如：wine-mono、wine-gecko、winetricks），否则可能导致依赖冲突。\n如果您使用的是 64 位系统，请开启 32 bit 架构支持（如果您之前没有开启的话）：\n# Verifying you have 64-bit kernel architecture. $ dpkg --print-architecture # Verifying you have multi-arch support enabled.  $ dpkg --print-foreign-architectures # Enabling multi-arch support. $ sudo dpkg --add-architecture i386 $ sudo apt update 下载添加仓库密钥：\n$ sudo wget -nc -O /usr/share/keyrings/winehq-archive.key https://dl.winehq.org/wine-builds/winehq.key 并添加 Ubuntu 22.04 仓库：\n$ sudo vim /etc/apt/sources.list.d/winehq.list deb [arch=amd64,i386 signed-by=/usr/share/keyrings/winehq-archive.key] https://mirrors.tuna.tsinghua.edu.cn/wine-builds/ubuntu/ jammy main 安装：\n$ sudo apt update $ sudo apt install --install-recommends winehq-stable 配置 配置Wine的方式通常有：\n winecfg是Wine的图形界面配置程序。控制台下调用$ winecfg（或指定系统目录：$ WINEPREFIX=~/.系统目录 winecfg）即可启动 control.exe是Windows控制面板的Wine实现，通过$ wine control命令启动 regedit是Wine的注册表编辑器，比较前两者，该工具能配置更多东西。部分常用键值参见：WineHQ’s article on Useful Registry Keys  初始设置 通过全局菜单，应用程序 - 附件 - 终端 ，输入命令： winecfg 这将在你的家目录中创建一个隐藏文件夹（.wine），其中包含类似于在Windows中的虚拟C：驱动器以及注册表文件。一旦该目录中创建完，wine配置窗口将出现。该窗口将允许您定制wine的各种设置，其中包括Windows版本，DLL替换，显示设置，驱动器映射，以及应用程序的特定设置。单击OK按钮关闭该窗口。\nWINEPREFIX Wine默认将配置文件和安装的Windows程序保存在~/.wine。这样的目录称为一个\"Wine prefix\"或\"Wine bottle\"（下文称“系统目录”）。每次运行Windows程序（包括内置程序，如winecfg）时，系统目录会自动创建（如果缺失）或更新。系统目录中存放有文件夹 ~/.wine/drive_c 相当于Windows下C:\\C盘（更确切的说应是系统盘）。\n通过设置WINEPREFIX环境变量，可以更改Wine系统目录的位置。如果希望让不同的Windows程序使用不同的系统环境或配置，这一变量会非常有用。建议把你安装的不同的Windows程序分给不同的WINEPREFIX，便于打包和隔离。当你要启动这个Windows程序前也记得要设置WINEPREFIX。\n例如，如果您使用 $ env WINEPREFIX=~/.win-a wine-A程序.exe参数来运行一个程序。另一个使用 $ env WINEPREFIX=~/.win-b wine-B程序.exe参数，这两个程序将使用独立的C盘和注册表配置。\n以下命令会建立一个默认的系统目录，且不启动任何Windows程序：\n$ env WINEPREFIX=~/.customprefix wineboot -u WINEARCH 这个WINEARCH 决定了你模拟的Windows是32位或是64位的x86。对应的值为win32及win64，如果你的Unix系统是64位的它就默认是win64。\n发行版所提供的wine一般都有32位及64位两个包，直接对应所模拟的Windows位数，包里面的Unix二进制及运行库也都是对应位数。\n对于64位用户，默认创建的系统目录是64位环境的。若想使用纯32位环境，修改WINEARCH 变量win32为即可： $ WINEARCH=win32 winecfg这样就会生成32位Wine环境。若不设置WINEARCH得到的就是64位环境。\n通过WINEPREFIX变量，在不同的系统目录分别创建32位和64位环境：\n$ WINEARCH=win32 WINEPREFIX=~/win32 winecfg $ WINEPREFIX=~/win64 winecfg 注意： 系统目录创建过程中，64位版本的wine将视全部目录如同64位系统目录，也将不会在已存在的目录中创建任何32位的。创建32位系统目录，您必须让Wine创建指定的WINEPREFIX目录。\nwinetricks也接受WINEPREFIX变量，以安装Steam为例：\n$ WINEARCH=win32 WINEPREFIX=~/.local/share/wineprefixes/steam winetricks steam 编辑 ~/.bashrc，使得 WINEPREFIX 和 WINEARCH 永久生效\nexport WINEPREFIX=$HOME/.config/wine/ export WINEARCH=win32 图形驱动 你需要安装32位的显卡驱动。缺少或未能正确配置驱动的一个标志是 Wine 在终端窗口里报告如下内容：\nDirect rendering is disabled, most likely your OpenGL drivers have not been installed correctly 注意： 在安装对应的库以后，你可能需要重启 X\n声音 Wine程序有可能遇到某些声音问题。首先，确保winecfg中只启用了一种声卡驱动。目前，Wine对Alsa的支持最好。\nMIDI 支持\nMIDI 是九十年代非常流行的游戏声音系统。如果你尝试运行老一点的游戏，音乐无法开箱即用的情况并不罕见。 Wine 拥有非常优秀的 MIDI 支持。但是首先你需要确保 Wine 会使用正确的 MIDI 输出。详细设置参考 Wine Wiki\n中文字体 注意字无法显示和显示为乱码是不同的症状，如果看到乱码，请确保系统语言和运行Wine时的语言环境一致。如果有汉字丢失或显示为方框，请继续字无法显示。\n显示为乱码\n如果安装的系统LANG不为zh-CN，那么wine运行程序的默认语种也不会是中文，这可能导致一部分乱码。解决这个问题，用如下命令运行程序：\n$ env LANG=zh_CN.UTF-8 wine example.exe 字无法显示\n将中文字体copy到对应wine的目录下的drive_c/windows/Fonts/。\n在wine目录下任意位置添加modify_font.reg文件：\nREGEDIT4 [HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\FontLink\\SystemLink] \"Lucida Sans Unicode\"=\"msyh.ttc\" \"Microsoft Sans Serif\"=\"msyh.ttc\" \"MS Sans Serif\"=\"msyh.ttc\" \"Tahoma\"=\"msyh.ttc\" \"Tahoma Bold\"=\"msyh.ttc\" \"msyh\"=\"msyh.ttc\" \"Arial\"=\"msyh.ttc\" \"Arial Black\"=\"msyh.ttc\" 将msyh.ttc改成自己想改的中文字体。\n在wine命令提示符运行：\n$ regedit modify_font.reg 启动器和菜单 Wine不会为内置程序（如winecfg、winebrowser）创建桌面启动器和菜单项。但手动安装的Windows程序通常会自动创建启动器和菜单项。在Windows下，安装程序（如setup.exe）通常会在桌面和开始菜单建立快捷方式，而Wine下会创建遵循freedesktop.org规范的.desktop文件（即启动器，相当于快捷方式）。\n提示： 如果启动器没有自动创建，或者这些文件丢失了，可以尝试使用winemenubuilder修复。\nGnome3 中清理 Wine 菜单启动项\n系统全局的菜单启动器安装在 /usr/share/applications/，清除相应程序的“.desktop”文件即可从整个系统删除该启动器。\n如果这样还是无法解决问题，那么很可能 Wine 的启动器存放在用户级别的 ~/.local/share/applications/wine/Programs/ 目录中。删除相应的“.desktop”文件即可清理对应启动项。删除整个 Programs 文件夹将清理所有 Wine 程序的启动项。\n安装/运行/卸载 Windows 程序 警告： 千万不要以root身份运行Wine！详情参见本文。\n使用wine安装应用程序，可以按照以下步骤：\n 从某个地址下载Windows应用程序.exe（可执行文件）. 把它放在一个方便的目录（例如，桌面或个人文件夹） 打开终端，并且切换到.exe文件所在的目录。 输入命令 wine application-name.exe 。  这将使用Wine启动.EXE。如果它是一个安装程序，它应该像在windows一样的运行。如果应用程序要求目录来安装应用程序，选择把它放在 C:\\Program Files 。\n运行Windows程序格式为 WINEPREFIX=\"wine配置文件存放地\" wine [路径]程序.exe 参数 ，如：\n$ wine notepad.exe c:/abc.txt $ wine notepad.exe ~/.wine/drive_c/abc.txt 路径可以是Unix路径，也可以是（在有WINEPREFIX情况下的）Windows路径，wine会自动判断。\n对wine来说，你Unix系统里的其他文件（即模拟的C盘之外的文件）的Windows路径都以Z盘开头：\n$ wine notepad.exe z:/home/username/.wine/drive_c/abc.txt 内置的msiexec程序可以运行MSI安装包：\n$ [wine] msiexec /i path_to_msi 还可以通过在终端运行 winefile 使用 Wine 文件浏览器。\n在某些情况下，应用程序需要被从一个特定位置上运行。在这种情况下创建命令启动\n$ sh -c \"cd /home/USER/.wine/drive_c/Program Files/APPDIR; wine game.exe\" wine uninstaller 这将打开一个类似于Windows的程序“添加/删除程序”控制面板，让您卸载wine安装的应用程序。通过 wine 直接运行卸载程序也应该正常工作。或者，您也可以简单地删除应用程序的文件夹。\n技巧 提示： 此外您可能会感兴趣以下文章的开始所提供的链接\n Wine程序数据库 (Wine Application Database, AppDB) —— 特定Windows程序的Wine兼容情况（运行时的已知问题、用户评分、指南等等），Rating一列由运行结果好到坏为Platinum、Gold、Silver、Bronze、Garbage，无近期结果或近期仍然Silver以下的就放弃吧。 WineHQ论坛 —— 要是看完上述网页还有问题，可以到这里咨询  OpenGL 模式 很多游戏（比如魔兽争霸啦）都支持OpenGL模式，在Wine下可能比默认DirectX模式性能更好。一般添加-opengl启动程序即可，但不同程序可能有所不同：\n$ wine /path/to/3d_game.exe -opengl 请参考AppDB，了解特定程序的相关信息。\nWine 控制台 有些时候，可能需要运行.exe给游戏打补丁，比如给古董游戏添加宽屏支持。这时直接通过Wine运行可能没有用。那么，打开终端，运行一下命令：\n$ wineconsole cmd 将进入一个和Windows下cmd一样的命令行环境。在该环境下试试也许就可以了。\nwinetricks 使用Winetricks快速脚本，能够方便地安装许多Windows组件，包括DirectX、msxml（被Office 2007、IE浏览器依赖）visual运行库还有其他更多的。\n使用 Ubuntu 仓库版本\n$ sudo apt install winetricks 使用 Github 安装最新版本\n$ cd \"${HOME}/.local/bin\" $ wget https://raw.githubusercontent.com/Winetricks/winetricks/master/src/winetricks $ chmod u+x winetricks 可以用winetricks list-all来看看它支持什么，也可以从该脚本中搜索下载链接 load_packagename\nUsing winetricks\n获得 winetricks 后，您只需在控制台输入sh winetricks即可运行它。如果你先chmod +x winetricks ，你也可以使用./winetricks。如果不带参数运行，winetricks 会显示一个带有可用包列表的 GUI。如果您知道要安装的软件包的名称，可以将它们附加到 winetricks 命令，它将立即开始安装过程。例如，\n$ sh winetricks corefonts vcrun6 将安装 corefonts 和 vcrun6 软件包。\n所有 Wine 命令一样，winetricks 知道 WINEPREFIX 环境变量。\n$ env WINEPREFIX=~/.winetest sh winetricks mfc40 拥有多个 Wine 版本的用户可以指定 winetricks 应该使用哪个版本\n$ env WINE=~/wine-git/wine sh winetricks mfc40 使用 ~/wine-git 目录中的 Wine 安装 mfc40 包。\nMono \u0026 Gecko Mono 是 .NET Framework 的开源和跨平台实现。Wine 可以使用 Windows 构建的 Mono 来运行 .NET 应用程序。\nWine 实现了自己的 Internet Explorer 版本。该实现基于Mozilla 的 Gecko Layout Engine的自定义版本。\n在 USTC MIRROR 分别下载对应的版本，放入~/.cache/wine就可以了，比如 wine 7.0.1 用 wine-mono-7.0.0-x86.msi。\nCrossOver CrossOver是Wine的付费、商业化版本，提供更全面的终端用户支持。它包括脚本、补丁、GUI和可能永远不会被Wine项目接受的第三方软件。这种组合使得那些不太懂技术的人运行Windows程序变得相当容易。\n首先在 CrossOver 下载 .bin 安装包，然后要把 .bin 文件设置成可执行的：chmod u+x crossover.bin，接下来运行该文件：./crossover.bin。\n无限试用\ncrossover 有15天的试用期，crossover的时间验证信息写在每一个winebottle容器中，相互是完全隔离（不是写在全局配置中）。即使一个容器过期了，依然可以创建新的容器，并重新计算试用期，所以不需要重装软件本身。\n即使重装程序，已经过期的容器依旧不能用，不过可以删除该容器，或者删除容器下的.eval文件。\n/usr/bin/rm ~/.cxoffice/**/.eval Tutorials 相对于 wine 而言，CrossOver 更加简洁方便，全程使用 GUI。\n在 Select Application 的时候，即使列表中没有列出你需要安装的 Windows 软件，依旧可以尝试使用默认的 Unlisted application，如一些 roguelike、galgame 游戏是可以直接运行的。\n如果无法运行：\n 确保已安装破解补丁。有的破解组安装程序不会自动或者提供选择框来安装，需要手动覆盖。 如果报错缺少dll，这时就在网上查找一下，比如 sskin.dll，如果教程使用的 winetricks，则可以在 winetricks/files/verbs/all.txt 找到具体的依赖名称，如 Visual C++ 6 SP4 libraries，然后可以在 Select Application 输入依赖名来安装，如果下载慢，也可以通过软件显示的下载链接直接下载。 如果什么错也没报，那么就需要参考 Unsupported Troubleshooting 安装依赖或配置 winecfg，确保在安装游戏的时候没有选择升级依赖（比如 DirectX ）并且之后安装了必要的依赖项。推荐游戏自带的 CommonRedist 或在 WineHQ - Browse Applications、PlayOnLinux、PCGamingWiki 上找依赖，可以但不推荐在虚拟机中运行一下看报错。 如果先是正常运行，之后 wine 报错 page fault 退出，那么可以参考 Gathering debug logs in Crossover Linux 创建 crash log。  凡是依赖解决了，游戏一般是能够运行了，但是运行的好不好，有没有bug就不敢保证了，比如 Skul - The Hero Slayer 是可以直接运行的，但是无法正常显示血量，即使重新安装依赖也是如此。\n以下测试的是运行游戏所必须的依赖：\n  Sekiro Shadows Die Twice\n Microsoft Visual C++ 6.0 (4.2 \u0026 6.0) Redistributable    The Elder Scrolls V Skyrim Special Edition\n DirectX for Modern Games 使用 SkyrimSELauncher.exe 配置，使用 SkyrimSE.exe 启动    Life is Strange - Before the Storm\n 先安装下面两个依赖，如果 FitGirl 报 Getting unarc.dll returned an error code -6，就 try using the set memory limit to 2 gb option；如果是 Miss files，那么就重装。 Microsoft Visual C++ 6.0 (4.2 \u0026 6.0) Redistributable DirectX for Modern Games 游戏需要加载一会儿，这个时候屏幕没反应。    NieR - Automata\n DirectX for Modern Games 如果 unable to input name for profile creation，可以尝试将 CrossOver 升级到最新版本。    Dead Cells\n 参考 [playonlinux/dead cells](playonlinux/dead cells) 的 SourceCode 安装依赖后能够运行 DirectX for Modern Games OpenAL，安装后要在 Wine Configuration  Libraries 中添加 openal32（不加，点击无反应、闪退）（Libraries 中是运行时自动加载进来的库，而需要的 openal32 没有自动加载进来，因此手动添加） Microsoft Visual C++ 6.0 (4.2 \u0026 6.0) Redistributable    The Binding of Isaac Rebirth Repentance\n 要在 Wine Configuration  Libraries 中添加 openal32（不加，点击无反应、闪退） 《以撒的結合：重生》給新玩家的基本攻略    Valiant Hearts The Great War\n Copy over the cracked content from the /Crack directory on the image to your game install directory manually.    DARK SOULS REMASTERED\n 更改语言：In the game installation folder find the “steam_emu.ini”, open it and find the line with language, change it to schinese.（在 font 目录可以找到所有语言）    Braid\n DirectX for Modern Games    Dying Light Platinum Edition\n Microsoft Visual C++ 6.0 (4.2 \u0026 6.0) Redistributable    Hearth Stone\n DXVK    Undertale\n Undertale最新版简体中文汉化指南    Warm Snow\n DirectX for Modern Games    DXVK DXVK provides a Vulkan-based translation layer for DXGI, D3D10 and D3D11, which can be used on Linux with Wine.\n游戏使用 Vulkan 将获取更好的性能，为使用 Vulkan，需启用 DXVK。\n打开 System Information，如果在属性下找到了 “vulkan.present”=“yes”，则表示支持 vulkan 并可以安装 DXVK。\n  使用 CrossOver 安装：\n像安装普通软件那样，在 Select an Application to install 搜索并选择 DXVK (Upstream) 安装——DXVK (Builtin) 可能会导致游戏无法运行。安装后就自动启用了，也可以通过右键一个 BottleSettingsDXVK Vulkan backand for D3D11(Custom) 启用。\n  手动安装：关键在WINEPREFIX环境变量\n$ env LANG=zh_TW.UTF-8 WINEPREFIX=~/.wine-battle.net WINEARCH=win64 ./setup_dxvk.sh install   Esync 注：Some Windows applications will not work correctly which ESync enabled. 例如 My Friend Pedro 开了后闪退，应该先保证正确运行，再考虑提升性能。\nWhat is “wine esync” and how should I set it up?\nthe thing with Far Cry 4, 3 and Primal also Dirt Rally in wine is that it massively loads wineserver and synchronizing all the time, so it is stuck at around 20 fps on ryzen, all those games mentioned. with esync, wineserver is skipped for synchronizing and eventfd is being used, thus increasing performance that much. Games that are CPU bound with wineserver having huge load (wineserver is singlethreaded) benefit the most of this\nWhat is the function of esync? Why most games need it disabled?\nThe function of esync is to provide lightweight thread synchronization facilities (events/semaphores/mutexes) so that game code that uses them heavily will run faster.\nIt does this using a linux-specific facility called eventfd, which is built around file descriptors. These are a limited resource normally not needed in large quantities, and therefore traditionally made available to a process only in moderate quantities. This helps prevent runaway processes and malicious code from consuming so many descriptors that none are left for other processes (a denial of service).\nTherefore, when a game that uses tens of thousands of thread synchronization objects is run with esync, it will fail unless the system’s per-process file descriptor limit is much higher than the traditional default. Some linux distributions have already adopted a high default, while others still default to a thousand or so. That’s why these games run fine with esync on some distributions but fail on others unless the system’s DefaultLimitNOFILE setting is increased.\nEdit: If you’re interested in esync technical issues that are not distribution-specific, check out this comment.\nHowToEsync What is Esync?\nEsync removes wineserver overhead for synchronization objects. This increases performance for a lot of games, especially ones that rely heavily on multithreading.\nA more detailed explanation can be found here.\nHow to check Esync compatibility\nSystems using Systemd 240 and newer are already compatible with Esync.\nIf you’re unsure that your system is compatible, run the ulimit -Hn command. If the value printed is equal to or greater than 524288, then your system is Esync-compatible.\nHow to make your system Esync compatible\nIf your system is not Esync-compatible (ulimit -Hn, which prints the limit for number of opened files for a process, prints a value lower than 524288, like 4096), you have 2 different methods of solving this problem. Which method is preferable depends on the distribution currently in use. Applying both methods should have no negative side effect.\n Modifying Systemd configuration  This method applies to Ubuntu and other systems using systemd. You (with root privileges or sudo) need to edit both /etc/systemd/system.conf and /etc/systemd/user.conf by adding DefaultLimitNOFILE=524288. If DefaultLimitNOFILE= already exists in both system.conf and user.conf, add 524288 after = and make sure to uncomment the line (remove the # in the beginning of the line) to make it functional.\nOnce the files are edited, restart your computer for the changes to take effect. To verify if the limits were applied, run ulimit -Hn to see 524288 being reported.\nIf the value printed still says something like 4096, try the ulimits method below.\nModifying ulimits.conf  On Linux distributions not using Systemd or distributions using pam-limits.conf (Arch Linux, Fedora, Solus,… ), you (with root privileges or sudo) need to edit /etc/security/limits.conf.\nChange username to your actual username. Once the file is edited, reboot for the changes to take effect, and verify by running ulimit -Hn to see the new limit (524288).\nusername hard nofile 524288 语言设置 注：某些游戏会因为语言设置而无法运行。\n修改步骤：打开容器 C:Drive，返回到顶层文件夹（即容器名称），即可找到cxbottle.conf，在文件最后面添加如下内容：\n[EnvironmentVariables] \"LANG\" = \"zh_CN.UTF-8\" 也可以像安装软件那样，在搜索框里搜索 “chinese”，然后选择 “Setting bottle’s language to Simplifiled Chinese”\nThird-party apps Bottles Proton How To Use Steam Proton To Play Windows Games On Linux?\nEnabling the Proton\n  Fire up the Steam app from the app menu.\n  In the top-left corner of the app, click on Steam and then click on Settings.\n  In the sidebar, find and click on Steam Play.\n  Click Enable Steam Play for supported titles and Enable Steam Play for all other title options.\n  Can I Install Non-Steam Games Using Proton?\n Download the official launcher “Add non-Steam game…” - Show all files - Select the launcher executable - Done Setup proton (if not done using global settings)  Navigate: Gear icon - “Settings” - “Compatibility” Check “Force compatibility layer …” Select Proton 5.13 or newer   Update the target. Gear icon - “Settings”:  Target: explorer.exe Execution directory: /path/to/your/gi/installation/ Start options: /desktop=anyname,1920x1080 cmd /c launcher.bat Adjust the screen resolution above, if necessary.    PlayOnLinux Lutris 可以参考其安装脚本。\n实例 HearthStone 如下 wine 7、英文界面、国际服（亚服）直接运行成功：\n$ env WINEPREFIX=\"$HOME/.wine-hearthstone\" wineboot --init $ env WINEPREFIX=\"$HOME/.wine-hearthstone\" winetricks win10 $ env WINEPREFIX=\"$HOME/.wine-hearthstone\" winetricks --force dotnet48 $ env WINEPREFIX=\"$HOME/.wine-hearthstone\" wine Battle.net-Setup.exe Office 2013 Pro 注：在安装前先在 AppDB 中查找要安装的应用，在 Test Results 部分有相关教程，如 Microsoft Office 2013 Test Results\n注：要提高安装成功率，第一，不同 wine 版本安装结果是不同的，AppDB 有相应的信息；第二，winetricks 如果提供安装镜像的话，一定要用该镜像，winetrics 是一个很大的脚本，打开脚本搜索 office2013pro 即可找到官方镜像下载链接；第三，如果第一次安装失败，可以再尝试安装一次。\nI installed office 2013 and I used to get a black window after starting it up. I fixed the black screen by following the solution posted in the [WineHQ-Forum](https://forum.winehq.org/viewtopic.php?f=8\u0026t=28446\u0026p=109296\u0026hilit=office 2013#p109284).\nHere’s what I did:\nInstall Components\n$ sudo apt install winbind cabextract Create Clean 32bit Prefix for Win7\nCrete a clean 32 bit prefix and start up winecfg:\n$ env WINEPREFIX=~/.wine-office2013pro WINEARCH=win32 winecfg In the winecfg applications tab select “Windows version: Windows 7” Close wine config and install winetricks\nInstall Libraries\nThen start winetricks for your prefix\n$ env WINEPREFIX=~/.wine-office2013pro WINEARCH=win32 winetricks accept “select the default wineprefix” with OK. Now, select “Install Windows DLL components” and go and install msxml6（这个时候会下载 msxml6，可以手动下载后移动到~/.cache/winetricks中）\nTo fix the problem in PowerPoint (not enough memory), I added two overrides with winecfg in Library section: “riched20” and “usp10”.\n如果是中文软件需安装中文字体。\n在这里我直接使用 winetrics 成功安装 office2013pro（wine 6）：\n$ env WINEPREFIX=~/.wine-office2013pro WINEARCH=win32 winetricks office2013pro 这样下面步骤不需要了。\nFix Black Window\nIn order to fix the black window that impedes Office 13 to be used, add the HKCU\\Software\\Wine\\Direct3D\\MaxVersionGL new DWORD value 30002 (hexa) to the registry.\nHere’s how to do this: In Winetricks select Run regedit and wait for the Registry Editor window to open. In the folder tree expand HKEY_CURRENT_USER - Software - Wine and create a new key in the Wine folder. To do so, right click, select new–key and name it Direct3D. Now create new–DWORD Value, rename the file to MaxVersionGL and set the value data to 30002 (hexadecimal). Close the Registry Editor window.\nClose the winetricks window and run installer:\nInstall Office 2013\n$ env LANG=zh_CN.UTF-8 WINEPREFIX=~/.wine-office2013pro WINEARCH=win32 wine ~/PathTo/Office2013Setup.x86.exe From here, the install runs and completes 100%.\n安装后可以在 ~/.local/share/applications/wine 下找到 微信、QQ 的 .desktop 文件，右键编辑，将 Exec=env 行改为 Exec=env LANG=zh_CN.utf8\nGenshin Impact GI-on-Linux（已验证可玩）or Play another game. Format: link, caveats (Proton/Wine rating)\n Blue Protocol, unreleased, 2022 (N/A) Tower of Fantasy, unreleased, 2022 (N/A) Wuthering Waves, unreleased, 20?? (N/A) Scarlet Nexus, singleplayer (Platinum) Little Witch Nobeta singleplayer (Gold) Ashen (Platinum) Tower Hunter: Erza’s Trial singleplayer, 2D scroller (Platinum) Haven PEGI 18 (Gold) Valheim no story (Native) Pine no story, singleplayer (Native)  darling Darling is a translation layer that lets you run macOS software on Linux\nAnbox Anbox 简介 Anbox 是 “Android in a box” 的缩写。Anbox 是一个基于容器的方法，可以在普通的 GNU/Linux 系统上启动完整的 Android 系统。\nAnbox 可以让你在 Linux 系统上运行 Android，而没有虚拟化的迟钝，因为核心的 Android 操作系统已经使用 Linux 命名空间（LXE）放置到容器中了。\nAndroid 容器不能直接访问到任何硬件，所有硬件的访问都是通过在主机上的守护进程进行的。\n每个应用程序将在一个单独窗口打开，就像其它本地系统应用程序一样，并且它可以显示在启动器中。\n安装使用 Anbox 也可作为 snap 软件包安装，请确保你已经在你的系统上启用了 snap 支持。\n为使 Anbox 工作，确保需要的内核模块已经安装在你的系统中。对于基于 Ubuntu 的用户，使用下面的 PPA 来安装它。\n$ sudo add-apt-repository ppa:morphis/anbox-support $ sudo apt update $ sudo apt install linux-headers-generic anbox-modules-dkms 在你安装 anbox-modules-dkms 软件包后，你必须手动重新加载内核模块，或需要系统重新启动。\n$ sudo modprobe ashmem_linux $ sudo modprobe binder_linux 安装 anbox。\n$ sudo apt install anbox 如果你已经在你的系统上安装 snap，其它的步骤可以忽略。\n$ sudo snap install --devmode --beta anbox 默认情况下，Anbox 并没有带有 Google Play Store。因此，我们需要手动下载每个应用程序（APK），并使用 Android 调试桥（ADB）安装它。\n$ sudo apt install android-tools-adb 既然我们不能使用 Play Store ，你就得从信得过的网站来下载 APK 软件包，像 APKMirror ，然后手动安装它。\n首先，你需要启动 ADB 服务。为做到这样，运行下面的命令。\n$ adb devices 安装语法格式：\n$ adb install Name-Of-Your-Application.apk QEMU KVM QEMU 的图形前端 与其他的虚拟化程序如 VirtualBox 和 VMware 不同, QEMU不提供管理虚拟机的GUI（运行虚拟机时出现的窗口除外），也不提供创建具有已保存设置的持久虚拟机的方法。除非您已创建自定义脚本以启动虚拟机，否则必须在每次启动时在命令行上指定运行虚拟机的所有参数。\nLibvirt提供了一种管理 QEMU 虚拟机的便捷方式。有关可用的前端，请参阅 libvirt 客户端列表。\n创建新虚拟系统 创建硬盘镜像 除非直接从 CD-ROM 或网络引导（并且不安装系统到本地），运行 QEMU 时都需要硬盘镜像。硬盘镜像是一个文件，存储虚拟机硬盘上的内容。\n一个硬盘镜像可能是 raw镜像, 和客户机器上看到的内容一模一样，并且将始终使用主机上的来宾硬盘驱动器的全部容量。此方法提供的I / O开销最小，但可能会浪费大量空间，因为guest虚拟机上未使用的空间无法在主机上使用。\n另外一种方式是qcow2 格式，仅当客户系统实际写入内容的时候，才会分配镜像空间。对客户机器来说，硬盘大小表现为完整大小，即使它可能仅占用主机系统上的非常小的空间。此映像格式还支持QEMU快照功能。但是，使用此格式而不是 raw 可能会影响性能。\nQEMU 提供 qemu-img命令创建硬盘镜像.例如创建一个 4 GB raw 格式的镜像:\n$ qemu-img create -f raw image_file 4G 您也可以用 -f qcow2 创建一个 qcow2 镜像。\n用 dd 或 fallocate 也可以创建一个 raw 镜像。\n警告： 如果硬盘镜像存储在 Btrfs 系统上，则应在创建任何映像之前考虑禁用该目录的写时复制。\n调整镜像大小 警告： 调整包含NTFS引导文件系统的镜像将无法启动已安装的操作系统，推荐在操作之前进行备份\n执行 qemu-img 带 resize 选项调整硬盘驱动镜像的大小.它适用于 raw 和 qcow2. 例如, 增加镜像 10 GB 大小, 运行:\n$ qemu-img info disk_image $ qemu-img resize disk_image +10G 在磁盘映像扩容后，必须使用虚拟机内部系统的分区工具对该镜像进行分区并格式化后才能真正开始使用新空间。 在收缩磁盘映像时，必须首先使用虚拟机内部系统的分区工具减少分该分区的大小，然后相应地收缩磁盘映像，否则收缩磁盘映像将导致数据丢失！\nPS：用qemu-img调整镜像大小，很简单，问题出在启动系统后，Windows只剩一个一直转圈圈的鼠标与黑屏，一点报错也没有，等了很久（半个小时左右），我直接loadvm加载snapshot，loadvm会回退之前qemu-img resize操作，所以需要再次resize，再次进系统，终于正常了，也看到了多出来的空闲空间。这说明操作是正确的，但是由于各种位置原因导致黑屏，所以重新做一次就好了。这里有一个手把手教程：KVM: How to Expand or Shrink a Virtual Machine Disk Size?\n安装操作系统 这是你第一次需要去启动模拟器的步骤，为了在磁盘镜像上安装操作系统，你必须同时将磁盘镜像与安装介质装载到虚拟机上，从安装介质中启动操作系统。\n以i386的客户机为例，为了从CD-ROM内的把可用于启动的ISO文件安装到磁盘镜像上，你需要：\n$ qemu-system-x86_64 -cdrom iso_image -boot order=d -drive file=disk_image,format=raw 在安装完操作系统后，就可以直接从QEMU镜像内启动了。\n注意： 默认情况下仅分配给虚拟机128MB的内存， 分配的内存大小可以通过 -m 调整， 比如 -m 512M 或 -m 2G。\n提示：\n 相较于指定 -boot order=x ，一部分用户感觉使用 -boot menu=on 启用boot菜单的体验更舒服些，至少在配置和实验时是这样的。 当使用无界面（headless）模式时， 将会默认在本地5900端口启动一个VNC服务器， 可以用 TigerVNC 连接到客户机的系统上: vncviewer :5900 若你在安装过程中需要替换软盘或CD，可以使用QEMU机器监视器（在虚拟机窗口中按Ctrl + Alt + 2）来删除存储设备并将其连接到虚拟机。使用info block查看块设备，然后使用change命令换出设备。按下Ctrl + Alt + 1返回虚拟机。  运行虚拟化的系统 qemu-system-* 程序 (例如 qemu-system-i386 或 qemu-system-x86_64, 取决于客户机架构)用来运行虚拟化的客户机. 用法是:\n$ qemu-system-i386 options disk_image 所有 qemu-system-*的选项是相同的。\n默认 QEMU会在窗口中显示虚拟机的视频输出。有一点要记住：当您单击QEMU窗口,鼠标指针被捕获。要放开，按 Ctrl+Alt+g.\n警告： QEMU 不应以 root 身份运行。如果必须以root身份在某个脚本中运行QEMU，那么你需要使用 -runas 选项让QEMU放弃root权限\n启用 KVM KVM 必须要您处理器和内核支持, 和必要的 kernel modules加载。更多信息参见 KVM。\n要在KVM模式中启动QEMU, 追加 -enable-kvm到启动选项. 要检查是否为正在运行的 VM 启用了 KVM，请使用 Ctrl+Alt+Shift+2 进入 QEMU Monitor，然后键入 info kvm。\n注意：\n -machine 选项中的 accel=kvm 参数与-enable-kvm 或 -accel kvm 选项是等价的。 CPU模型 host 需要 KVM。 如果你使用GUI工具去启动QEMU，但是性能体验极差，那么最好检查一下是否真的开启了KVM支持，因为QEMU可能选择了备用的模拟模式，即软件级模拟。 需要启用KVM才能正常启动windows7和windows8，否则会出现“蓝屏”.  宿主机和虚拟机数据交互 网络 我们可以利用任何支持文件传输的网络协议实现客户机和宿主机之间的数据交互, 例如 NFS, SMB, NBD, HTTP, FTP, 或 SSH, 当然这么做的前提是你已经配置好二者之间的网络，且在系统上启动了相应的服务程序。\n在默认情况下，用户模式的客户机能够通过10.0.2.2这个IP访问到宿主机。任何运行于宿主机上的服务端程序都可以通过这个地址被访问到，比如说我们可以通过这个IP访问到宿主机上的SSH服务器或SMB服务器。因此在这种情况下，客户机能够挂载宿主机通过SMB or NFS暴露出来的目录，也可以访问宿主机上的HTTP服务器等。 通常情况下宿主机无法访问客户机上的服务，不过你也可以通过一些特殊的网络配置达到这个目的 (参阅#Tap 网络)\nQEMU 端口转发 QEMU能够将宿主机的端口转发到客户机上以实现一些功能，例如从宿主机上访问客户机的SSH端口。\n举个例子，将宿主机上的10022端口与客户机上的22 (SSH) 端口进行绑定， 对应的QEMU命令如下：\n$ qemu-system-x86_64 disk_image -nic user,hostfwd=tcp::10022-:22 确认你客户机上的sshd程序正在运行，然后可以通过如下命令连接到客户机的SSH端口\n$ ssh guest-user@localhost -p 10022 你可以用 SSHFS 把客户机的整个文件系统都挂到宿主机上，这样就可以在宿主机上对客户机的文件系统进行读写了。\n想进行多端口转发的话, 只需要在-nic参数中指定多个hostfwd, 以VNC端口为例:\n$ qemu-system-x86_64 disk_image -nic user,hostfwd=tcp::10022-:22,hostfwd=tcp::5900-:5900 QEMU 的内置SMB服务器 QEMU的文档中指出它有一个内置的SMB服务器，但实际上，它只是在宿主机上加载一个自动生成的smb.conf配置文件 (位于/tmp/qemu-smb.random_string)，然后启动宿主机上的Samba，使得客户机能够通过一个IP地址进行访问 (默认的IP地址是10.0.2.4)。这个方法只适用于用户网络，在你不想在宿主机开启通常的Samba服务 (客户机同样能访问这类Samba服务) 时这个方法还挺好用的。\n宿主机上必须安装 Samba。通过如下QEMU命令启用这项特性:\n$ sudo apt install samba $ qemu-system-x86_64 disk_image -net nic -net user,smb=shared_dir_path shared_dir_path 就是你想要在宿主机和客户机之间共享的目录。\n接着，在客户机内，你应该能够通过10.0.2.4访问到名为qemu的共享文件夹。例如在Windows Explorer中前往 \\\\10.0.2.4\\qemu 这个地址。\n注意：\n 如果你像这样多次指定共享选项 -net user,smb=shared_dir_path1 -net user,smb=shared_dir_path2 or -net user,smb=shared_dir_path1,smb=shared_dir_path2 qemu只会共享参数中最后的一个目录。 如果你不能访问共享文件夹且客户机系统为 Windows, 请检查 NetBIOS 协议是否被启用 并确认防火墙没有屏蔽NetBIOS协议的 端口 如果你不能访问共享文件夹且客户机系统为 Windows 10 Enterprise 或 Education 或 Windows Server 2016, 请启用游客访问.  打开 本地组策略编辑器 (gpedit.msc)。 在控制台树中，依次选择“计算机配置”  “管理模板”  “网络”  “Lanman 工作站”。 对于设置，右键单击“启用不安全的来宾登录”，然后选择“编辑”。 选择“启用”，然后选择“确定”。    共享多个文件夹并在运行时增删文件夹的一个方法是：共享一个空目录，然后在其中创建指向其余共享目录的符号链接。可以用下面的脚本修改SMB服务器的配置，这个脚本还能使宿主机上不允许执行的文件在客户机内拥有执行权限。\n#!/bin/bash eval $(ps h -C smbd -o pid,args | grep /tmp/qemu-smb | gawk '{print \"pid=\"$1\";conf=\"$6}') echo \"[global] allow insecure wide links = yes [qemu] follow symlinks = yes wide links = yes acl allow execute always = yes\"  $conf # in case the change is not detected automatically: smbcontrol --configfile=$conf $pid reload-config 仅当客户机第一次访问到网络驱动后，才能将该脚本启用，并作用于qemu启动的SMB服务器。共享多文件的另一个方法是在配置文件里加入额外的共享路径，就像下面这样\n$ echo \"[myshare] path=another_path read only=no guest ok=yes force user=username\"  $conf 这个共享文件夹可以在客户机内通过\\\\10.0.2.4\\myshare访问。\n挂载qcow2镜像内的分区 我们将使用 qemu-nbd 完成这一功能, 同时它也能让我们使用 NBD (network block device) 协议共享该磁盘镜像。\n首先，我们需要加载nbd模块：\n$ sudo modprobe nbd max_part=16 接着，共享该磁盘并创建设备条目：\n$ sudo qemu-nbd -c /dev/nbd0 /path/to/image.qcow2 进行分区发现检测：\n$ sudo partprobe /dev/nbd0 fdisk 可以获取 nbd0 内各分区的相关信息 :\n$ sudo fdisk -l /dev/nbd0 Disk /dev/nbd0: 25.2 GiB, 27074281472 bytes, 52879456 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0xa6a4d542 Device Boot Start End Sectors Size Id Type /dev/nbd0p1 * 2048 1026047 1024000 500M 7 HPFS/NTFS/exFAT /dev/nbd0p2 1026048 52877311 51851264 24.7G 7 HPFS/NTFS/exFAT 接下来可以挂载镜像的任意分区了，比如说我们要挂载分区2：\n$ sudo mount /dev/nbd0p2 mountpoint 完成任务后，切记卸载镜像文件，然后根据之前的操作一步步还原，即分区并断开与nbd设备的连接：\n$ sudo umount mountpoint $ sudo qemu-nbd -d /dev/nbd0 网络 采用TAP设备（tun 与 tap 设备，都是虚拟网络设备，tun 设备用来实现三层隧道（三层 ip 数据报），tap 设备用来实现二层隧道（二层以太网数据帧）。）和网桥（使用网桥可以将多个接口连接到同一网段内，这一功能等同于交换式集线器。）的虚拟网络的性能应该会比使用用户模式网络或VDE要好，原因在于TAP设备和网桥是在内核中实现的。\n此外，虚拟网络的性能可以通过将网络设备直接注册到虚拟机中改善，这比默认情况下模拟e1000 NIC的性能表现要更好，参阅 [安装 virtio 驱动](#安装 virtio 驱动) 获得更多相关信息。\n关于链路层地址的限制 若在QEMU启动中指定了 -net nic 参数，QEMU将会为虚拟机注册一块虚拟网卡，其链路层地址为 52:54:00:12:34:56 。然而，当在多台虚拟机之间搭建桥接网络时，每台虚拟机在tap设备的虚拟机端都需要拥有一个独一无二的链路层地址 (MAC)，否则网桥会因为收到多个不同源却拥有相同MAC地址的数据包而无法正常工作。即使你为多个tap设备配置了不同的MAC地址也依旧会出现这个问题，因为当数据包通过tap设备时，tap设备并不会改写包内的链路层地址。\n因此请确保每个虚拟机拥有自己独一无二的网卡地址, 并且它们都以 52:54: 开头。 可以通过如下命令手动设置虚拟机的MAC地址, 下面的’X’可以替换成任何16进制字符:\n$ qemu-system-x86_64 -net nic,macaddr=52:54:XX:XX:XX:XX -net vde disk_image 用户模式 默认情况下，没有任何-netdev参数，QEMU将使用带有内置DHCP服务器的用户模式网络。当您的虚拟机运行其DHCP客户端时，将为其分配IP地址，它们将能够通过QEMU伪装的IP来访问物理主机的网络。\n警告： 仅适用于TCP和UDP协议，因此ICMP协议（包括ping）将不起作用。 请勿使用ping测试网络连接。\n如果主机已连接Internet，则此默认配置可以使您的虚拟机轻松访问Internet。但是如果您同时启动多个虚拟机，则虚拟机将无法在外部网络上直接看到，虚拟机也将无法相互通信。\nQEMU的用户模式网络可以提供更多功能，例如内置TFTP或SMB服务器，将主机端口重定向到虚拟机（例如，允许SSH连接到虚拟机）或将虚拟机连接到VLAN（vlan 全程 virtual lan，能够用来虚拟分配以太网。归属于不同的 VLAN ID 的设备之间需要一个路由才能够通信，这意味这不同的 VLAN ID 将以太网划分成了不同的分组。），以便它们可以彼此通信。 有关更多详细信息，请参见-net user标志上的QEMU文档。\n但是，用户模式网络在效用和性能上都有局限性。更高级的网络配置需要使用TAP设备或其他方法。\nTap 网络 Tap devices是一个Linux内核特性，允许您创建作为真实网络接口的虚拟网络接口。发送到tap接口的包将被传递到一个用户空间程序(如QEMU)，该程序将自己绑定到该接口。\nQEMU可以为虚拟机使用tap网络，因此发送到tap接口的包将被发送到虚拟机，并显示为来自虚拟机中的网络接口(通常是以太网接口)。相反，虚拟机通过其网络接口发送的所有内容都将出现在tap接口上。\nLinux桥接驱动程 序支持Tap设备，因此可以将Tap设备彼此桥接在一起，也可以连接其他主机接口，如eth0。如果您希望您的虚拟机能够相互通信，或者希望LAN上的其他机器能够与虚拟机通信，那么这是非常理想的方案。\n警告： 如果您将tap设备和一些主机接口桥接在一起，例如eth0，您的虚拟机将直接出现在外部网络上，这将使它们遭受攻击的可能。根据您的虚拟机可以访问的资源，您可能需要采取所有precautions来保护您的虚拟机。如果风险太大,虚拟机没有资源或您设置多个虚拟机,一个更好的解决方案可能是使用host-only networking建立NAT。在这种情况下，您只需要在主机上安装一个防火墙，而不是为每个虚拟机安装多个防火墙。\n正如在用户模式网络部分中指出的，tap设备提供比用户模式具有更高的网络性能。如果虚拟机中的操作系统支持virtio网络驱动程序，那么网络性能也会显著提高。假设使用tap0设备，virtio驱动程序在客户端上使用，并且没有使用脚本来帮助启动/停止网络，使用下面的qemu命令：\n-net nic,model=virtio -net tap,ifname=tap0,script=no,downscript=no 但是，如果已经使用带有virtio网络驱动程序的Tap设备，则甚至可以通过启用vhost来提高网络性能，例如：\n-net nic,model=virtio -net tap,ifname=tap0,script=no,downscript=no,vhost=on 仅主机网络\n如果为网桥提供了IP地址，并且使能发往该网桥的流量允许，但没有实际接口（例如eth0）连接到网桥，则虚拟机与虚拟机间，虚拟机与主机间能够相互通信。但是，如果您没有在物理主机上设置IP掩蔽，则他们将无法与外部网络进行通信。 此配置被其他虚拟化软件（例如VirtualBox）称为“仅主机网络模式”。\n提示：\n  如果你想设置IP掩蔽，例如虚拟机的NAT，请查看Internet sharing#Enable NAT页面。\n  您也许想在网桥接口上运行一个DHCP服务器来服务虚拟网络。例如，使用172.20.0.1/16子网，dnsmasq作为DHCP服务器:\n# ip addr add 172.20.0.1/16 dev br0 # ip link set br0 up # dnsmasq --interface=br0 --bind-interfaces --dhcp-range=172.20.0.2,172.20.255.254   内部网络\n如果您不为网桥提供IP地址并在iptables添加INPUT规则链，将所有流向网桥中的数据丢弃，则虚拟机将能够彼此通信，但无法与物理主机或外部网络通信。此配置被其他虚拟化软件（例如VirtualBox）称为“内部网络”。您将需要为虚拟机分配静态IP地址，或在其中一个虚拟机上运行DHCP服务器。\n在默认情况下，iptables将丢弃桥接网络中的数据包。您可能需要使用这样的iptables规则来允许桥接网络中的数据包:\n# iptables -I FORWARD -m physdev --physdev-is-bridged -j ACCEPT 使用 qemu-bridge-helper 桥接网络\n这种方法不需要启动脚本，并且很容易适应多个tap和多个桥。它使用/usr/lib/qemu/qemu-bridge-helper，允许在现有桥上创建tap设备。\n提示： 参见 Network bridge 获取创建网桥的信息.\n首先，创建一个配置文件，包含QEMU使用的所有网桥的名称:\n/etc/qemu/bridge.conf allow bridge0 allow bridge1 ... 现在启动虚拟机：\n$ qemu-system-i386 -net nic -net bridge,br=bridge0 [...] 在多个TAP设备的情况下，最基本的用法是要为所有NIC指定VLAN：\n$ qemu-system-i386 -net nic -net bridge,br=bridge0 -net nic,vlan=1 -net bridge,vlan=1,br=bridge1 [...] 手工创建网桥\n将虚拟机连接到主机接口，如eth0，这可能是最常见的配置。这种配置使虚拟机看起来直接位于外部网络，与物理主机位于同一以太网段。\n物理设备和Tap设备之间通过iptables进行网络共享\n桥接网络能在有线接口(例如eth0)之间工作，并且很容易设置。但是，如果主机通过无线设备连接到网络，则无法进行桥接。\n解决这个问题的一种方法是，给tap设备设置一个静态IP，使linux自动处理它的路由，然后通过iptables规则转发tap接口和连接到网络的设备之间的通信。\n通过 VDE2 配置网络 VDE全称为Virtual Distributed Ethernet，作为uml_switch的一个扩展，是一个用于管理虚拟网络的工具包\n其基本的思想是创建一个虚拟的开关，就如插座那样，允许虚拟机和物理机通过\"插入\"连接彼此。下面的配置非常简单，然而，VDE的功能远比展示的更强大，其能够接入虚拟开关，在不同的主机上运行它们并监听开关上的通信。\n本方法的优点在于无需sudo特权，普通用户一般没有运行modprobe的权限。\nVDE2 网桥 任何连接到vde上的虚拟机都会暴露给外部。举个例子，每台虚拟机都能直接从ADSL路由器那收到DHCP的配置信息。\n简化配置参数 如果你经常需要以不同的网络配置选项运行QEMU，就会发现时常得输入大量的-netdev和-device选项组合，这些是大量重复性的劳动。可以用-nic选项将二者结合，就如下面这样，底下这些参数：\n-netdev tap,id=network0,ifname=tap0,script=no,downscript=no,vhost=on -device virtio-net-pci,netdev=network0 可简化为:\n-nic tap,script=no,downscript=no,vhost=on,model=virtio-net-pci 要注意的是缺失了网络ID，因此将会以model=创建这些设备。{ic|-nic}}命令的前半部分参数正是-netdev的参数，而后半部分参数（model=之后的部分）则与设备有关，原本设备所提供的参数同样可以在此使用（例如，可以指定smb=）。若要完全禁用网络，可以用-nic none。\n图形 QEMU 可以使用一下几个图形输出：std, cirrus, vmware, qxl, xenfs 和 vnc。使用 vnc 选项，你可以单独运行客户机，并且通过 VNC 连接。\n  std：使用 -vga std 你可以得到最高 2560 x 1600 像素的分辨率。从 QEMU 2.2 开始是默认选项。\n  qxl：QXL是一个支持2D的并行虚拟化图形驱动。需要在客户机中安装驱动并在启动QEMU时设置-vga qxl选项。你可能也会想使用SPICE优化QXL的图形表现。\n在Linux客户机中，需要加载qxl和bochs_drm这两个内核模块，以获得一个比较好的效果。\nQXL设备的默认VGA内存大小为16M，这样的内存大小最高支持QHD (2560x1440)的分辨率，如果想要一个更高的分辨率，请增加vga_memmb。\n  virtio：virtio-vga / virtio-gpu 是一个基于virgl的3D并行虚拟化图形驱动。目前依旧处于开发中，仅支持最近的（= 4.4）的Linux客户机，且需要以gallium-drivers=virgl选项编译mesa (=11.2)。\n若要在客户机上启用3D加速，那么需要用-vga virtio选项选择此vga，并用-display sdl,gl=on或-display gtk,gl=on在显示设备上启用opengl上下文，这两个选项分别适用于sdl输出和gtk输出。如果配置成功了，那么在客户机的kernel log里可以看到：\n# dmesg | grep drm [drm] pci: virtio-vga detected [drm] virgl 3d acceleration enabled   none：这就像一台完全没有VGA卡的PC，无法通过-vnc访问它。另外，这种情况与使用-nographic选项不同，-nographic会让QEMU模拟VGA卡，只是关闭了SDL输出。\n  VNC 可以用-vnc :X选项将QEMU的VGA输出重定向至VNC会话中。将X替换为输出目标的编号（0代表之后监听在5900，1代表监听在5901…）。\n$ qemu-system-x86_64 -vnc :0 警告： 默认的VNC服务器没有使用任何验证手段，用户可以从任何主机上连接到VNC。\n基本的口令验证 可以通过使用password选项很容易地设置访问口令。必须在QEMU Monitor中指定口令，仅当用户提供口令时才有可能连接到VNC。\n$ qemu-system-x86_64 -vnc :0,password -monitor stdio 在QEMU Monitor中设置口令需使用change vnc password命令，然后指定一个口令。\n底下的命令将在启动VNC时直接为其设置口令：\n$ printf \"change vnc password\\n%s\\n\" MYPASSWORD | qemu-system-x86_64 -vnc :0,password -monitor stdio 注意： 口令被限制在8个字符内，可以用暴力破解的方式猜到口令。因此在公网上推荐使用更细致的保护措施。\n音频 -audiodev标识用于设定后端音频驱动及其相关选项。最简单的情况下，你需要选择一个驱动并设置一个id。\n-audiodev pa,id=snd0 使用音频设备 Intel HD Audio\n模拟Intel HD Audio需要添加控制器和编解码器设备。可以用如下命令列出可用的Intel HDA Audio设备：\n$ qemu-system-x86_64 -device help | grep hda 添加音频控制器：\n-device ich9-intel-hda 添加音频编解码器并将其映射到宿主机的音频后端id上。\n-device hda-output,audiodev=snd0 Intel 82801AA AC97\n模拟AC97需要添加声卡设备并将其映射到宿主机的一个音频后端id上。\n-device AC97,audiodev=snd0 无音频设备 通过如下命令获取支持模拟的音频驱动列表：\n$ qemu-system-x86_64 -soundhw help 比如，要在客户机上模拟hda驱动，需要使用-device intel-hda -device hda-duplex选项启动QEMU。\n注意： 客户机的显卡模拟驱动可能也会导致客户机中的音频质量出现问题，需要一个个进行排查。使用qemu-system-x86_64 -h | grep vga列出可用的选项\n安装 virtio 驱动 QEMU为用户提供并行虚拟化块设备和网络设备的能力，其是借助virtio驱动实现的，拥有更好的性能表现以及更低的开销。\nvirtio块设备需要使用-drive指定一个disk image的参数，且需要带上if=virtio参数：\n$ qemu-system-x86_64 -boot order=c -drive file=disk_image,if=virtio 网络配置也是类似的：\n$ qemu-system-x86_64 -nic user,model=virtio-net-pci 注意： 仅有当客户机有virtio设备对应的驱动时该方法才能起效，Linux是有这方面支持的，不过无法保证这些驱动能够兼容其他操作系统。\n以下以windows为例。\n块设备驱动 Windows没有自带virtio驱动，因此需要在安装时加载该驱动。镜像文件可以从Fedora 仓库下载。\n通过ISO加载只对Windows Vista和Windows Server 2008及其之后的版本有效。这个方法的具体操作是在主磁盘设备和Windows安装盘外挂载一个额外的cdrom设备，将系统镜像与virtio驱动一同加载：\n$ qemu-system-x86_64 ... \\ -drive file=windows_disk_image,index=0,media=disk,if=virtio \\ -drive file=windows.iso,index=2,media=cdrom \\ -drive file=virtio.iso,index=3,media=cdrom \\ ... 在安装过程中，Windows Installer会询问你“Where do you want to install Windows?”，其会返回一个警告表示没有找到任何磁盘设备。接下来跟着如下示例中的步骤进行操作（基于Windows Server 2012 R2 with Update）：\n Select the option Load Drivers. Uncheck the box for Hide drivers that are not compatible with this computer’s hardware. Click the browse button and open the CDROM for the virtio iso, usually named “virtio-win-XX”. Now browse to E:\\viostor\\[your-os]\\amd64, select it, and confirm.  现在应该能看到virtio磁盘出现在列表中了，等待着被选中、格式化并安装。\n网络驱动 安装virtio网络驱动程序要容易一些，只需如上所述添加-net参数即可。\n$ qemu-system-i386 -m 4G -vga std -drive file=windows_disk_image,if=virtio -net nic,model=virtio-net-pci -cdrom virtio-win-0.1-185.iso Windows将检测网络适配器并尝试为其找到驱动程序。如果失败，请转到“设备管理器”，找到带有感叹号图标的网络适配器（双击打开），切换到驱动程序并单击“更新驱动程序”，然后选择虚拟CD-ROM。别忘了选中显示要递归搜索目录的复选框。\nBalloon 驱动 如果想要追踪客户机内存状态（比如通过virsh的dommemstat命令）或者在运行时改变客户机内存大小（尽管依然无法改变实际的内存大小，不过可以通过inflating balloon驱动限制内存的使用），那么请在客户机上安装balloon驱动吧。\nQEMU 监视器 QEMU运行时会提供一个监视器console界面以方便用户同虚拟机进行交互。QEMU监视器提供了许多有趣的功能，例如获取当前虚拟机的信息，热插拔设备，创建快照等。在QEMU监视器console中运行help或?命令获得完整的命令列表。\n访问QEMU监视器Console 图形化界面\n当使用默认的std图形选项时，可以通过按下Ctrl+Alt+2组合键或从QEMU窗口上的View  compatmonitor0访问到QEMU监视器。若要返回到虚拟机的图形界面，那么按下Ctrl+Alt+1或者View  VGA就行。\n然而，这种标准的访问方式不够方便，而且并不是在QEMU的所有图形化输出方式中都适用。\nTelnet\n启动QEMU时带上-monitor telnet:127.0.0.1:*port*,server,nowait参数可以启用telnet。虚拟机启动后可以通过telnet访问到监视器：\n$ telnet 127.0.0.1 port 注意： 如果指定 127.0.0.1 作为监听地址，那么只能在运行QEMU的宿主机上连接到该监视器。如果想要远程访问，QEMU需要在0.0.0.0上进行监听：-monitor telnet:0.0.0.0:*port*,server,nowait。还要记住的是，最好对firewall进行配置，该连接是完全不进行认证和加密的，因此需要通过防火墙确保本地网络环境是可信的。\nUNIX socket\n通过-monitor unix:*socketfile*,server,nowait参数运行QEMU，之后就可以通过socat或openbsd-netcat连接到监视器上。\n例如，如果QEMU是通过如下命令启动：\n$ qemu-system-x86_64 [...] -monitor unix:/tmp/monitor.sock,server,nowait [...] 就可以像这样连接到监视器上：\n$ socat - UNIX-CONNECT:/tmp/monitor.sock 或者通过这种方式:\n$ nc -U /tmp/monitor.sock TCP\n可以使用-monitor tcp:127.0.0.1:*port*,server,nowait参数将监视器暴露于TCP端口上，然后用netcat（openbsd-netcat或gnu-netcat都可）进行连接：\n$ nc 127.0.0.1 port 注意： 为了能够从其它设备上通过TCP socket访问到监视器，而不仅仅从运行QEMU的主机上连接，需要像前面Telnet中描述的那样，在0.0.0.0地址上进行监听。\n标准 I/O\n如果以-monitor stdio参数运行QEMU，那么其实是可以在运行QEMU的终端下访问到监视器的。\n在Monitor conosle下向虚拟机发送按键行为 由于在某些配置下，宿主机可能会拦截一些按键组合另作他用，这导致要在虚拟机中触发一些特定按键组合变得有些困难（一个显然的例子就是Ctrl+Alt+F*组合，该组合用于改变当前的tty）。我们采用在monitor console下发送按键组合的方式解决该问题。只需切换到monitor console下，然后使用sendkey命令，即可将按键转发至虚拟机中，例如：\n(qemu) sendkey ctrl-alt-f2 通过 monitor console 创建快照和管理快照 注意： 该特性\"只\"支持qcow2格式的虚拟机磁盘镜像，对于raw是无效的。\n有时候我们很需要将虚拟机的当前状态进行保存，或是将虚拟机重置到之前的快照状态，而且最好是随时能进行这些操作。QEMU monitor console为用户提供了必要的功能，进行快照创建，快照管理，以及快照恢复。\n Use savevm name 用于创建一个名为name的快照。 Use loadvm name 用于将虚拟机状态恢复至快照name。 Use delvm name 用于删除快照name。 Use info snapshots 用于查看保存的快照列表，这些快照由一个自增长的ID和标签名（用户创建快照时赋予）进行标识。  以冻结模式运行虚拟机 QEMU支持以冻结态运行虚拟机（需使用-snapshot参数），换句话说，虚拟机关闭时，对于虚拟机的一切修改都会丢弃。当用户对磁盘镜像写入时，这些变动最终写入的位置是/tmp目录下的一个临时文件，QEMU关机时将会把他们丢弃。\n不过，即使虚拟机运行于冻结状态下，依旧可以通过monitor console将这些变化写入磁盘镜像（如果你想的话）。使用下面的命令：\n(qemu) commit all 另外如果在冻结状态下创建快照，这些快照在QEMU退出时都会被丢弃，除非你显式地commit了他们。\nmonitor console中的开机和暂停命令 在QEMU monitor console下也可以模拟对物理机的一些操作：\n system_powerdown 会向虚拟机发送ACPI关机信号，效果就类似物理机上按下电源按钮。 system_reset 会重置虚拟机，类似物理机上的重置按钮。该操作可能导致数据丢失或文件系统的损坏，这是因为虚拟机并不是\"干净地\"重启的。 stop 会暂停虚拟机。 cont 使暂停的虚拟机恢复运行。  虚拟机截屏 可以在monitor console下运行该命令，获取PPM格式的截屏图片：\n(qemu) screendump file.ppm PCI passthrough via OVMF 笔记本 Optimus MUXless 下的 Intel 和 NVIDIA 虚拟机显卡直通 受到MUXless架构本身的限制，显卡直通有非常大的局限，例如很多游戏无法调用独显、操作麻烦、显示性能仍然较低等。因此，现阶段可以为了折腾而尝试，但不建议用于实用用途。\nOptimus MUXed 笔记本上的 NVIDIA 虚拟机显卡直通 技巧 改善虚拟机的性能表现 底下是一些可以改善虚拟机性能表现的技术，例如：\n  启用#启用 KVM：QEMU的启动命令加上-enable-kvm选项。\n  通过-cpu host选项让QEMU模拟宿主机上的特定CPU，如果没有该选项QEMU尝试模拟的是一个更为通用的CPU。\n  特别的，如果客户机是Windows，启用Hyper-V enlightenments可以改善性能：-cpu host,hv_relaxed,hv_spinlocks=0x1fff,hv_vapic,hv_time.\n  如果宿主机有多个核心，可以用-smp选项为客户机分配更多核心。\n  检查是否为虚拟机分配的足够的内存。默认情况下，QEMU仅仅为每台虚拟机分配128MiB的内存，可以使用-m选项分配更多的内存。例如，-m 1024代表启动一台内存为1024MiB的虚拟机。\n  如果客户机操作系统支持相关的驱动，可以使用virtio创建网络设备或块设备。\n  使用TAP设备代替user-mode网络，参阅#Tap 网络。\n  如果客户机需要进行大量的磁盘写工作，在宿主机文件系统上设置合适的挂载选项可以优化该工作。例如，可以用barrier=0选项挂载一个ext4 file system。在使用这些性能强化选项之前最好阅读相关文档，因为性能上的提升通常伴随着数据完整性下降的代价。\n  如果有一块原始磁盘镜像，你可能会想要禁用cache：\n$ qemu-system-x86_64 -drive file=disk_image,if=virtio,cache=none   使用原生的Linux AIO：\n$ qemu-system-x86_64 -drive file=disk_image,if=virtio,aio=native,cache.direct=on   如果正同时运行多台虚拟机，而它们拥有同样的操作系统，可以通过启用内核页归并节省内存。参阅#开启KSM。\n  在一些情况下，可以在运行时从安装了balloon驱动的客户机上回收内存，这需要QEMU启动该客户机时使用-device virtio-balloon选项。\n  允许使用一个ICH-9 AHCI控制器的仿真层，尽管它并不稳定。AHCI的仿真模拟支持NCQ，因此可以同时处理多个读写请求：\n$ qemu-system-x86_64 -drive id=disk,file=disk_image,if=none -device ich9-ahci,id=ahci -device ide-drive,drive=disk,bus=ahci.0   参阅 https://www.linux-kvm.org/page/Tuning_KVM 获取更多信息\n开机时启动QEMU虚拟机 通过libvirt实现\n如果虚拟机是通过libvirt设置的，可以用virsh autostart将其配置为开机自启，或者通过virt-managerGUI中虚拟机的Boot Options，选择\"Start virtual machine on host boot up\"实现开机自启。\n通过systemd service实现\n可以用如下的systemd unit和config配置开机时启动QEMU VM。\n/etc/systemd/system/qemu@.service [Unit] Description=QEMU virtual machine [Service] Environment=\"haltcmd=kill -INT $MAINPID\" EnvironmentFile=/etc/conf.d/qemu.d/%i ExecStart=/usr/bin/qemu-system-x86_64 -name %i -enable-kvm -m 512 -nographic $args ExecStop=/bin/bash -c ${haltcmd} ExecStop=/bin/bash -c 'while nc localhost 7100; do sleep 1; done' [Install] WantedBy=multi-user.target 注意： 为了方便地结束任务，该service会等待至console端口被释放（这意味着VM已被关闭）。\n接着创建per-VM配置文件，命名为/etc/conf.d/qemu.d/*vm_name*，在其中设置好args和haltcmd变量，配置示例：\n/etc/conf.d/qemu.d/one args=\"-hda /dev/vg0/vm1 -serial telnet:localhost:7000,server,nowait,nodelay \\ -monitor telnet:localhost:7100,server,nowait,nodelay -vnc :0\" haltcmd=\"echo 'system_powerdown' | nc localhost 7100\" # or netcat/ncat /etc/conf.d/qemu.d/two args=\"-hda /srv/kvm/vm2 -serial telnet:localhost:7001,server,nowait,nodelay -vnc :1\" haltcmd=\"ssh powermanager@vm2 sudo poweroff\" 对该变量的描述如下：\n args - 使用的QEMU命令行参数。 haltcmd - 安全关闭虚拟机的命令，在第一个例子中，QEMU monitor是通过-monitor telnet:..选项暴露至telnet，因而关闭虚拟机是通过nc命令在monitor console中发送system_powerdown，完成ACPI关机的工作。在另一个例子里，使用的则是SSH。  若要设置启动时运行哪个虚拟机，enable qemu@*vm_name*.service这个systemd单元\n鼠标整合 添加-usb -device usb-tablet选项以避免点击客户机系统的窗口时鼠标被捕获。该选项代表QEMU能够在不捕获鼠标的情况下，向系统报告鼠标的位置，该选项启用时还会覆盖PS/2鼠标模拟功能。 命令示例：\n$ qemu-system-x86_64 -hda disk_image -m 512 -usb -device usb-tablet 宿主机的USB设备传递至虚拟机 从客户机访问连接到宿主机USB口的设备是可能的，首先需要识别设备连接的位置，可以用lsusb命令找到设备连接位置，例如：\n$ lsusb ... Bus 003 Device 007: ID 0781:5406 SanDisk Corp. Cruzer Micro U3 上面以显示的数字分别用于标识\n 003 host_bus 007 host_addr 0781 vendor_id 5406 product_id  基本的思想是在QEMU中-device usb-ehci,id=ehci或-device qemu-xhci,id=xhci分别对EHCI (USB 2)或XHCI (USB 3)（在win7无法自动安装 USB3 驱动，因此应用 USB2）控制器进行模拟，然后将物理设备通过-device usb-host,..选项进行添加。\n识别出该设备，并将其连接至任一总线以及宿主机上的地址，通用的语法如下：\n-device usb-host,bus=controller_id.0,vendorid=0xvendor_id,productid=0xproduct_id 应用于上面例子中使用的设备，它变成：\n-device usb-ehci,id=ehci -device usb-host,bus=ehci.0,vendorid=0x0781,productid=0x5406 运行QEMU时会遇到 libusb couldn't open USB device Permission denied 权限错误，可以通过 udev 为设备设定合适的权限。\n$ vi /etc/udev/rules.d/50-usbtinyisp.rules SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"0781\", ATTRS{idProduct}==\"5406\", GROUP=\"vane\", MODE=\"0660\" $ ls -al /dve/bus/usb/003/007 crw-rw---- 1 root vane 189, 11 Nov 7 12:37 /dev/bus/usb/003/007 使用SPICE进行USB重定向 使用SPICE时可以将USB设备从客户端重定向至虚拟机中，无需使用QEMU命令。还支持为配置USB重定向插槽数（插槽数将决定可同时重定向的最大设备数）。相比于前面那种使用-usbdevice进行重定向的方法，SPICE方法的优势在于可以在虚拟机启动后USB设备热插拔，移除或添加USB设备时无需停机。这个方法还允许通过网络将客户端的USB设备重定向至服务端。总之，其是在QEMU虚拟机中使用USB设备最灵活的方法。\n开启KSM Kernel Samepage Merging (KSM) 是Linux内核的一个特性，允许应用程序向内核申请同其他申请页归并的进程进行页归并，KSM机制允许客户虚拟机之间进行页共享。当许多客户机运行相似的操作系统时，这个机制可以节省客观的内存。\n多屏支持 Linux的QXL驱动支持默认支持四头（虚拟屏幕），可以通过qxl.heads=N这一内核参数进行变更。\n复制和粘贴 在宿主机和客户机之间共享剪贴板的方法之一是使用SPICE远程桌面协议，通过SPICE客户端访问客户机，你需要遵照SPICE节中描述的步骤，通过该方式运行的客户机将支持与宿主机进行复制粘贴的操作。\nlibvirt Libvirt 是一组软件的汇集，提供了管理虚拟机和其它虚拟化功能（如：存储和网络接口等）的便利途径。这些软件包括：一个长期稳定的 C 语言 API、一个守护进程（libvirtd）和一个命令行工具（virsh）。Libvirt 的主要目标是提供一个单一途径以管理多种不同虚拟化方案以及虚拟化主机，包括：KVM/QEMU，Xen，LXC，OpenVZ 或 VirtualBox hypervisors。\nLibvirt 的一些主要功能如下：\n VM management（虚拟机管理）：各种虚拟机生命周期的操作，如：启动、停止、暂停、保存、恢复和迁移等；多种不同类型设备的热插拔操作，包括磁盘、网络接口、内存、CPU等。 Remote machine support（支持远程连接）：Libvirt 的所有功能都可以在运行着 libvirt 守护进程的机器上执行，包括远程机器。通过最简便且无需额外配置的 SSH 协议，远程连接可支持多种网络连接方式。 Storage management（存储管理）：任何运行 libvirt 守护进程的主机都可以用于管理多种类型的存储：创建多种类型的文件镜像（qcow2，vmdk，raw，…），挂载 NFS 共享，枚举现有 LVM 卷组，创建新的 LVM 卷组和逻辑卷，对裸磁盘设备分区，挂载 iSCSI 共享，以及更多…… Network interface management（网络接口管理）：任何运行 libvirt 守护进程的主机都可以用于管理物理的和逻辑的网络接口，枚举现有接口，配置（和创建）接口、桥接、VLAN、端口绑定。 Virtual NAT and Route based networking（虚拟 NAT 和基于路由的网络）：任何运行 libvirt 守护进程的主机都可以管理和创建虚拟网络。Libvirt 虚拟网络使用防火墙规则实现一个路由器，为虚拟机提供到主机网络的透明访问。  安装 基于守护进程/客户端的架构的 libvirt 只需要安装在需要要实现虚拟化的机器上。注意，服务器和客户端可以是相同的物理机器。\n服务端\n安装 libvirt 以及至少一个虚拟运行环境（hypervisor）：libvirt 的 KVM/QEMU 驱动 是 libvirt 的首选驱动，如果 KVM 功能已启用，则支持全虚拟化和硬件加速的客户机。\n$ sudo apt update $ sudo apt install qemu-kvm libvirt-daemon-system 安装 libvirt-daemon-system 后，需要将用于管理虚拟机的用户添加到libvirt组中。这对于 sudo 组的成员是自动完成的，但对于应该访问系统范围的 libvirt 资源的其他任何人，都需要另外完成。这样做将授予用户访问高级网络选项的权限。\n在终端中输入：\n$ sudo adduser $USER libvirt 如果选择的用户是当前用户，您需要注销并重新登录才能使新的组成员身份生效。\n客户端\n客户端是用于管理和访问虚拟机的用户界面。\n virsh — virsh 是用于管理和配置域（虚拟机）的命令行程序。 Virtual Machine Manager — 使用libvirt对KVM，Xen，LXC进行管理的图形化工具。  配置 对于系统 级别的管理任务（如：全局配置和镜像卷 位置），libvirt 要求至少要设置授权和启动守护进程。\n注意： 对于用户会话 级别的管理任务，守护进程的安装和设置不是 必须的。授权总是仅限本地，前台程序将启动一个 libvirtd 守护进程的本地实例。\n设置授权 自 libvirt：连接授权：Libvirt 守护进程允许管理员分别为客户端连接的每个网络 socket 选择不同授权机制。这主要是通过 libvirt 守护进程的主配置文件 /etc/libvirt/libvirtd.conf 来实现的。每个 libvirt socket 可以有独立的授权机制配置。目前的可选项有 none、polkit 和 sasl。\n由于 libvirt 在安装时将把 polkit 作为依赖一并安装，所以 polkit 通常是 unix_sock_auth 参数的默认值。但基于文件的权限仍然可用。\n使用 polkit\n注意： 为使 polkit 认证工作正常，应该重启一次系统。\nlibvirt 守护进程在 polkit 策略配置文件（/usr/share/polkit-1/actions/org.libvirt.unix.policy）中提供了两种策略：\n org.libvirt.unix.manage 面向完全的管理访问（读写模式后台 socket），以及 org.libvirt.unix.monitor 面向仅监视察看访问（只读 socket）。  默认的面向读写模式后台 socket 的策略将请求认证为管理员。这点类似于 sudo 认证，但它并不要求客户应用最终以 root 身份运行。默认策略下也仍然允许任何应用连接到只读 socket。\n基于文件的权限授权\n为了给 libvirt 组用户定义基于文件的权限以管理虚拟机，取消下列行的注释：\n$ vim /etc/libvirt/libvirtd.conf #unix_sock_group = \"libvirt\" #unix_sock_ro_perms = \"0777\" # set to 0770 to deny non-group libvirt users #unix_sock_rw_perms = \"0770\" #auth_unix_ro = \"none\" #auth_unix_rw = \"none\" 有些资料提到可以通过改变某些特定 libvirt 目录的权限以简化管理。需要记住的是：包更新时，这些变更会丢失。如要修改这些系统目录的权限，需要 root 用户权限。\n守护进程 libvirtd.service 和 virtlogd.service这两个服务单元都要启动。可以把 libvirtd.service 设置为启用，这时系统将同时启用 virtlogd.service 和 virtlockd.socket 两个服务单元，因此后二者不必再设置为启用。\n测试 测试 libvirt 在系统级工作是否正常：\n$ virsh -c qemu:///system 测试 libvirt 在用户会话级工作是否正常：\n$ virsh -c qemu:///session 管理 绝大部分的 libvirt 管理可以通过三个工具实现：virt-manager（图形界面）、virsh 和 guestfish（它是 libguestfs 的一部分）。\nvirsh Visrsh 用于管理客户域（虚拟机），在脚本式虚拟化管理环境中工作良好。由于需要通过通讯管道与虚拟运行环境通讯，绝大部分 virsh 命令需要管理员权限。尽管如此，一些典型的管理操作如域的创建、运行等也可以像VirtualBox 那样以普通用户身份执行。\nVirsh 允许带命令行选项执行。如果不带则进入其内置的交互式终端：virsh。交互式终端支持 tab 键命令补全。\n从命令行执行：\n$ virsh [可选项]  [参数]... 在交互式终端里运行：\nvirsh #  [参数]... 帮助也是可用的：\n$ virsh help [option*] or [group-keyword*] 存储池 存储池是指保存卷的位置。Libvirt 中卷的定义相当于其他系统中虚拟磁盘或虚拟机镜像的概念。存储池应该是一个目录、一个网络文件系统或一个分区（此处包括 LVM）。存储池可以在活动与不活动之间切换，可以为其分配存储空间。\n以下示例为添加存储池、目录和 LVM 卷的方法：\n$ virsh pool-define-as name type [source-host] [source-path] [source-dev] [source-name] [] [--source-format format] $ virsh pool-define-as poolname dir - - - - /home/username/.local/libvirt/images $ virsh pool-define-as poolname fs - - /dev/vg0/images - mntpoint 上述示例仅仅定义了存储池的信息，下面创建它：\n$ virsh pool-build poolname $ virsh pool-start poolname $ virsh pool-autostart poolname 删除它的命令：\n$ virsh pool-undefine poolname 提示： 对于 LVM 存储池而言：\n 最佳实践是仅把一个卷组分配给一个存储池。 请为存储池选择一个与 LVM 卷组不同的名字。否则当存储池被删除时，该卷组也将被删除。  用 virt-manager 新建存储池\n首先，连接到虚拟运行环境（例如QEMU/KVM的系统/用户会话）。然后，右键点击一个连接（例如QEMU/KVM）选择详情，切换到存储选项卡，点击左下角的**+**，按照向导操作。\n存储卷 存储池被创建之后，就可以在存储池中创建存储卷。如果你想新建一个域（虚拟机），那么这一步可以跳过，因为这一步可以在创建域的过程中完成。\n用 virsh 新建卷\n新建卷，列出卷，变更卷大小，删除卷：\n$ virsh vol-create-as poolname volumename 10GiB --format aw|bochs|raw|qcow|qcow2|vmdk $ virsh vol-upload --pool poolname volumename volumepath $ virsh vol-list poolname $ virsh vol-resize --pool poolname volumename 12GiB $ virsh vol-delete --pool poolname volumename $ virsh vol-dumpxml --pool poolname volumename # for details. 域 虚拟机被称作“域”。如果你想在命令行下操作，使用virsh列出，创建，暂停，关闭……域。virt-viewer可以用来查看使用virsh启动的域。域的创建通常以图形化的virt-manager或者命令行下的virt-install完成。 创建新域通常需要安装媒介，例如存储池中的iso文件或是直接从光驱安装。\n列出活动的和不活动的域：\n# virsh list --all 用 virt-install 新建域\n对于很详细的域（虚拟机）配置，可以用 virt-manager 新建域更简单地完成。但是，基础配置同样可以用virt-install完成并且同样运行顺利。至少要配置--name, --memory, 存储(--disk, --filesystem,或--nodisks),和安装方法（通常来说是.iso文件或CD）。查看virt-install(1)得到未列出的选项和更多的详情。\nWindows:\n$ virt-install \\  --name=windows7 \\  --memory 2048 \\  --cdrom /dev/sr0 \\  --os-variant=win7 \\  --disk /mnt/storage/domains/windows7.qcow2,size=20GiB \\  --network network=vm-net \\  --graphics spice 导入现有的卷：\n$ virt-install \\  --name demo \\  --memory 512 \\  --disk /home/user/VMs/mydisk.img \\  --import 用 virt-manager 新建域\n首先，连接到虚拟运行环境（例如 QEMU/KVM system 或用户 session，在连接上右击并选择 新建，然后跟随向导完成。\n 在第四[步中取消选中立即分配全部虚拟磁盘空间会加快创建过程并节省实际虚拟磁盘空间占用；然而，这将导致将来花费额外的磁盘整理时间。 在第五步中打开高级选项并确认虚拟化类型设为 kvm（这通常是首选模式）。如果要求附加的硬件配置，选中安装前定制选项。  管理域\n启动域：\n$ virsh start domain $ virt-viewer --connect qemu:///session domain 正常关闭域；强制关闭域:\n$ virsh shutdown domain $ virsh destroy domain 在libvirtd启动时自动启动域:\n$ virsh autostart domain $ virsh autostart domain --disable 在宿主机关闭时自动关闭域:\n使用libvirt-guests.serviceSystemd服务，运行中的域可以在宿主机关闭时自动挂起/关闭。同时这个服务还可以让挂起/休眠的域在宿主机启动的时候自动恢复。查看/etc/conf.d/libvirt-guests并设置相关选项。\n编辑一个域的XML配置：\n$ virsh edit domain 注意： 直接被QEMU启动的虚拟机不被libvirt管理。\n网络 这里是有关 libvirt 网络的一个正宗的概述。\n默认情况下，当 libvirtd 服务启动后，即创建了一个名为 default 的 NAT 网桥与外部网络联通（仅 IPv4）。对于其他的网络连接需求，可创建下列四种类型的网络以连接到虚拟机：\n bridge — 这是一个虚拟设备，它通过一个物理接口直接共享数据。使用场景为：宿主机有 静态 网络、不需与其它域连接、要占用全部进出流量，并且域运行于 系统 层级。有关如何在现有默认网桥时增加另一个网桥的方法，请参阅 网桥。网桥创建后，需要将它指定到相应客户机的 .xml 配置文件中。 network — 这是一个虚拟网络，它可以与其它虚拟机共用。使用场景为：宿主机有 动态 网络（例如：NetworkManager）或使用无线网络。 macvtap — 直接连接到宿主机的一个物理网络接口。 user — 本地网络，仅用于用户 会话。  绝大多数用户都可以通过 virsh 的各种可选项创建具有各种功能的网络，一般来说比通过 GUI 程序（像 virt-manager 之类）更容易做到。也可以按用 virt-install 新建域 所述实现。\n注意： libvirt 通过 dnsmasq 处理 DHCP 和 DNS 请求，以启动每个虚拟网络的不同实例。也会为特定的路由添加 iptables 规则并启用 ip_forward 内核参数。这也意味着宿主机上已运行的dnsmasq并不是libvirt所必须的（并可能干扰到libvirt的dnsmasq实例）。\nUEFI 支持 Libvirt 可以通过 qemu 和 OVMF 来支持 UEFI 虚拟机。 安装 ovmf 。 添加下面的内容到 /etc/libvirt/qemu.conf 。\n$ vim /etc/libvirt/qemu.conf nvram = [ \"/usr/share/ovmf/x64/OVMF_CODE.fd:/usr/share/ovmf/x64/OVMF_VARS.fd\" ] 重启 libvirtd\n现在你可以创建一个 UEFI 虚拟机了。 你可以通过 virt-manager 来创建。当你进行到向导的最后一步时：\n 勾选在安装前自定义配置，之后点击完成。 在概况屏幕, 将固件改为’UEFI x86_64'。 点击开始安装 在启动屏幕，你需要使用linuxefi命令来启动安装程序，并且你需要在系统中运行efibootmgr验证确实运行在UEFI模式下。  virt-manager: Shared folders with Linux Guest Create a future share folder on your host and set up the permissions (for the purpose of this article I will grand all permissions):\nroot@host# mkdir /share root@host# chmod 777 /share Afterwards shut down the guest if it’s running and attach the new filesystem in virt-manager:\n Switch the view to detail hardware view: View  Details Go to Attach hardware  Filesystem Fill in the name of the source path (/share in our case) and virtual target path (anything you like, I will go with /sharepoint) Switch mode to Mapped if you need to have write access from the guest Confirm and start the VM again  Now you can mount your shared folder from the VM:\nroot@guest# mkdir /share root@guest# mount -t 9p -o trans=virtio /sharepoint /share Or permanently add it to /etc/fstab file:\nroot@guest# cat /etc/fstab ... /sharepoint /share 9p trans=virtio,version=9p2000.L,rw 0 0 virt-manager: Shared folders with Windows Guest You can not add a shared folder in virt-manager like it is described in your article because the filesystem passthrough doesn’t work well with a windows guest.\nTo solve your problem you have several options:\n You can share a folder in the local network at your linux host system via SAMBA and access it over the windows filesystem directly. You can use spice-webdav to share a folder like it is described in this article from Guy Rutenberg. This is not recommend for transferring large files. If you only want to transfer data one or two times instead of having a permanent shared folder you can pack the data in your host system into a .iso file and add it in virt-manager as a disc to access it in the windows guest system.  virt-manager: Change Default Storage Pool Location 在Create a new virtual machine 的 Setp4 of 5 的时候，选择 Selec or create custom sorage 就行。\nQEMU-KVM Win7 环境准备   安装QEMU：sudo apt install qemu-kvm samba\n  下载 Windows virtio driver iso：https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/archive-virtio/virtio-win-0.1.102/，因为要将磁盘挂接为 virtio 磁盘。\n需使用 virtio-win-0.1.102，我使用 latest 的 virtio-win-0.1.208.iso，Windows安装程序会提示驱动没有包含签名错误No signed device drivers were found. Make sure that the installation media contains the correct drivers, and then click OK\n  创建系统盘 qemu-img create -f qcow2 Windows7-VM.img 30G，这将作为Win7的操作系统盘。\n  创建启动脚本\n$ vi start_Windows7_VM.sh #!/bin/bash DISKIMG=$HOME/.vm/Windows7-VM.img exec qemu-system-x86_64 --enable-kvm \\  -cpu host,hv_relaxed,hv_spinlocks=0x1fff,hv_vapic,hv_time \\  -drive file=${DISKIMG},if=virtio \\  -net nic,model=virtio-net-pci -net user,smb=$HOME/Downloads \\  -m 8192 \\  -smp sockets=1,cores=4,threads=2 \\  -monitor stdio \\  -vnc :0 \\  -audiodev pa,id=snd0 -device ich9-intel-hda -device hda-output,audiodev=snd0 \\  -usb -device usb-tablet \\  -rtc base=localtime,clock=host \\  -name 'Windows7 VM' \\  $@ $ chmod u+x start_Windows7_VM.sh   ./start_Windows7_VM.sh -boot d -cdrom $HOME/Downloads/cn_windows_7_ultimate_x64_dvd_x15-66043.iso -drive file=$HOME/Downloads/virtio-win-0.1.102.iso,index=3,media=cdrom\n  smp,socket,cores,threads几个参数的理解\n结合physical server上lscpu命令的输出，对它们的关系梳理了一番\n[root@pqsfc018 ~]# lscpu ... CPU(s): 32 ... Thread(s) per core: 2 Core(s) per socket: 8 Socket(s): 2 ...  socket就是主板上插cpu的槽的数目，也就是可以插入的物理CPU的个数。 core就是我们平时说的“核“，每个物理CPU可以双核，四核等等。 thread就是每个core的硬件线程数，即超线程  具体例子，上面这台服务器的CPU配置是2个socket，每个socket是8个core，每个core是超线程（2），这样，整台机器的对外的core就是282=32\nSMP，对称多处理器（Symmetric Multi-Processors，简称SMP）是指在一个计算机上汇集了一组处理器(多CPU),各CPU之间共享内存子系统以及总线结构。在这种技术的支持下，一个服务器系统可以同时运行多个处理器，并共享内存和其他的主机资源。像双至强，也就是我们所说的二路，这是在对称处理器系统中最常见的一种（至强MP可以支持到四路，AMD Opteron可以支持1-8路）。也有少数是16路的。但是一般来讲，SMP结构的机器可扩展性较差，很难做到100个以上多处理器，常规的一般是8个到16个，不过这对于多数的用户来说已经够用了。在高性能服务器和工作站级主板架构中最为常见，像UNIX服务器可支持最多256个CPU的系统，其实qemu从代码设计上也是最大支持256个virtual cpu。\n安装 Win 7  选择 Custom（advanced）  选择 CD Drive (E:) virtio-win  选择 viostor  安装 Win7 Virtio SCSI Driver  安装好以后，就可以看到安装的目标磁盘了  进入常规的 Win7 安装流程  安装 Virtio 网络驱动 选择 NetKVM\n但是安装失败：\n尝试 device manager 安装：\n[QEMU 的内置SMB服务器](#QEMU 的内置SMB服务器) 宿主机的USB设备传递至虚拟机 Questions 各种缺dll，好烦。\nwin7 64位安装wamp缺失vcruntime140.dll和api-ms-win-crt-runtime-l1-1-0.dll 等\n安装VC redit.exe程序解决，链接：\n https://download.microsoft.com/download/9/3/F/93FCF1E7-E6A4-478B-96E7-D4B285925B00/vc_redist.x86.exe https://download.microsoft.com/download/9/3/F/93FCF1E7-E6A4-478B-96E7-D4B285925B00/vc_redist.x64.exe  Microsoft Visual C++ Install Error 0x80240017\n右键 = 兼容性疑难解答\nwindows7 stop at “starting windows” while intalling on kvm\nsolved!\nLook here:Windows 7 Setup hangs at “Starting Windows” using Proxmox 4.2\nand add this to command line:\n--video cirrus QEMU-KVM WinXP SP3 太太太老了，很多软件都不支持了。\nwindows_xp.sh #!/bin/bash DISKIMG=$HOME/.vm/WindowsXP-VM.img exec qemu-system-x86_64 --enable-kvm \\  -cpu host,hv_relaxed,hv_spinlocks=0x1fff,hv_vapic,hv_time \\  -drive file=${DISKIMG} \\  -net nic,model=rtl8139 -net user,smb=$HOME/Downloads \\  -m 4096 \\  -cpu Nehalem \\  -rtc base=localtime,clock=host \\  -usb -device usb-tablet \\  -monitor stdio \\  -vga std \\  $@ Windows XP cannot connect to samba share You have ‘client min protocol = NT1’ set, there is another similar setting ‘server min protocol’ which from Samba 4.11.0 is set to SMBv2. Your XP is probably only using SMBv1, so it will not be able to see or connect to your Samba server.\nSo you have to edit the [global] section in the /etc/samba/smb.conf and add the server min protocol = NT1 option here. Then restart the Samba service.\n例如：\n$ ps h -C smbd -o pid,args 1707 /usr/sbin/smbd --foreground --no-process-group $ vim /tmp/qemu-smb.SL95F1/smb.conf [global] server min protocol = NT1 $ sudo smbcontrol 1707 reload-config 或者编写如下脚本\n#!/bin/bash echo \"[global] server min protocol = NT1\"  /tmp/**/smb.conf sudo smbcontrol $(ps h -C smbd -o pid) reload-config Windows XP 上网提示：您的时钟快了/慢了 此时，无论你怎么调整日期和时间，都不能解决上网问题。即使把日期从2020年调整到2015年，此时虽然不在提示 “您的时钟快了”，也有证书期限等异常。\n出现这种问题的原因，是因为 Windows XP 确实太老了，Google Chrome、Mozilla Firefox 及其内核的浏览器已经不支持了。\nVirtual Machine Manager 键盘不能输入的问题\n在 Display 中，设定 keymap，比如 en-us\n无网络\n在 NIC 中，将 Device model 设置为 rtl8139\nQEMU-KVM Gentoo Configuration Host To create a disk image for the virtual machine, run:\n$ qemu-img create -f qcow2 Gentoo-VM.img 30G Download a minimal Gentoo LiveCD from here.\nSince QEMU requires a lot of options, it would be a good idea to put them into a shell script, e.g.:\n$ vim start_Gentoo_VM.sh #!/bin/bash DISKIMG=$HOME/VirtualMachine/Gentoo-VM.img exec qemu-system-x86_64 -enable-kvm \\  -bios /usr/share/edk2-ovmf/OVMF_CODE.fd \\  -cpu host \\  -drive file=${DISKIMG},if=virtio \\  -netdev user,id=vmnic,hostname=Gentoo-VM,hostfwd=tcp::10022-:22,smb=$HOME/Downloads \\  -device virtio-net,netdev=vmnic \\  -device virtio-rng-pci \\  -m 4G \\  -smp sockets=1,cores=4,threads=2 \\  -monitor stdio \\  -vnc :0 \\  -audiodev pa,id=snd0 -device ich9-intel-hda -device hda-output,audiodev=snd0 \\  -rtc base=localtime,clock=host \\  -name \"Gentoo VM\" \\  $@ $ chmod u+x start_Gentoo_VM.sh Change the path to your disk image Gentoo-VM.img in the script. You can add more options when calling the script. To boot the disk image, run:\n$ ./start_Gentoo_VM.sh -boot d -cdrom $HOME/Downloads/install-amd64-minimal-20211107T170547Z.iso Install the guest per the Gentoo Handbook. See the guest section for optimum support. After the installation start the script without the additional options.\nUsing UEFI with QEMU UEFI for x86 QEMU/KVM VMs is called OVMF (Open Virtual Machine Firmware). It comes from EDK2 (EFI Development Kit), which is the UEFI reference implementation.\n$ sudo apt-get install ovmf 检查是否安装，命令为：\n$ dpkg -L ovmf | grep OVMF.fd /usr/share/ovmf/ OVMF.fd /usr/share/qemu/ OVMF.fd 要在虚拟机中运行操作系统的映像文件，添加 -bios /usr/share/ovmf/OVMF.fd。该代码调用名为 OVMF.fd 的文件，该文件是 Qemu 的 UEFI 固件。\n$ qemu-system-x86_64 -bios /usr/share/ovmf/OVMF.fd -cdrom ubuntu-21.04-desktop-amd64.iso 这个名为ovmf的包其实就是名为TianoCore的程序。该名称本身代表开放虚拟机固件)。\n“BdsDxe: failed to load Boot0001”\nsolution: Try hitting F2 to enter the OVMF settings during guest boot and manually pick a new boot drive option.\nVirtualBox 执行 .vbs 文件\n$ cscript test.vbs 删除备份\n删除虚拟机备份，当前状态前一个备份删除得快，两个备份之间的备份删除得慢。\n共享文件夹\n固定分配的共享文件夹对于定义共享文件夹的虚拟机是永久存在的；\n临时分配的共享文件夹在虚拟机运行时添加/删除，虚拟机关闭后消失。\n把img系统镜像转为VDI或VMDK格式文件\n$ VBoxManage convertdd *.img *.vdi 在 virtualbox 新建虚拟机时指定 vdi 硬盘文件，就可以安装系统\n启动本地磁盘上的其它系统\n增加现有虚拟机的磁盘大小 下面是你迟早会遇到的情况。\n你在 VirtualBox 中安装了一个或多个操作系统。在创建这些虚拟操作系统的同时，你还在 VirtualBox 中为它们创建了虚拟硬盘。\n你指定了虚拟磁盘的最大大小，比如说 15 或 20GB，但现在使用了一段时间后，你发现你的虚拟机已经没有空间了。\n虽然在 Ubuntu 和其他操作系统上有释放磁盘空间的方法，但更稳健的处理方式是增加 VirtualBox 中创建的虚拟机的磁盘大小。\n是的，你可以在 VirtualBox 中扩大虚拟硬盘，即使在创建之后也可以。虽然这是一个安全且经过测试的过程，但我们强烈建议你在执行这样的操作之前，先创建一个虚拟机的备份。\n我将向你展示如何在 VirtualBox 中以图形和命令行（对于 Linux 极客）方式调整磁盘大小。这两种方法都很简单直接。\n方法 1：在 VirtualBox 中使用虚拟媒体管理器\nVirtualBox 6 增加了一个调整虚拟磁盘大小的图形化选项。你可以在 VirtualBox 主页的文件选项卡中找到它。\n进入 “File - Virtual Media Manager”：\n在列表中选择一个虚拟机，然后使用 “Size” 滑块或输入你需要的大小值。完成后点击 “Apply”。\n请记住，虽然你增加了虚拟磁盘的大小，但如果你的空间是动态分配的，那么实际的分区大小仍然不变。\n方法 2：使用 Linux 命令行增加 VirtualBox 磁盘空间\n如果你使用 Linux 操作系统作为宿主机，在宿主机中打开终端并输入以下命令来调整 VDI 的大小：\nVBoxManage modifymedium \"/path_to_vdi_file\" --resize  在你按下回车执行命令后，调整大小的过程应该马上结束。\n 注意事项\nVirtualBox 早期版本命令中的 *modifyvdi 和 modifyhd 命令也支持，并在内部映射到 modifymedium 命令。\n 如果你不确定虚拟机的保存位置，可以在 VirtualBox 主页面点击 “Files - Preferences” 或使用键盘快捷键 Ctrl+G 找到默认位置。\nSeamless Mode 虚拟机通常在一个窗口中运行来宾操作系统及其程序。但是，VirtualBox和VMware都有一些功能，允许您在主机桌面上运行虚拟化程序，从而将它们从监狱中释放出来。…\n这意味着您可以在不使用虚拟机窗口和来宾操作系统桌面的情况下使用程序。如果使用多个监视器，甚至可以将虚拟机中的不同窗口放置在不同的监视器上。\n工作原理\n所有这些特性都同样工作。启动虚拟机，启动您想要使用的程序，然后启用“无缝模式”或“统一模式”。来宾操作系统的桌面和虚拟机窗口将消失，将来宾操作系统的窗口留在桌面上。它们看起来正在运行，好像它们在您的主机操作系统上运行，但虚拟机仍在后台运行。程序仍然是沙盒，因此它们无法访问主机操作系统的文件——它们似乎正在主机操作系统上运行。\n无论您使用的是Windows、Linux还是Mac，这些技巧都有效。您可以在Linux桌面上无缝运行Windows程序，也可以在Windows桌面上运行Linux软件。\n使用virtualbox的无缝模式\n请注意，VirtualBox只允许您在Windows、Linux和Solaris客户机上使用此功能。如果你设法让MacOSX在VirtualBox虚拟机上运行，或者你正在使用像俳句这样的小众操作系统，你将无法使用这个功能。\n在使用此功能之前，必须在要使用的来宾虚拟机内安装VirtualBox来宾添加软件包。如果您还没有这样做，请启动虚拟机，单击“设备”菜单，然后选择“安装来宾添加”。系统将提示您安装软件。\n要使用此功能，请同时按“主机键”（通常是右Ctrl键，但它显示在虚拟机窗口的右下角）和“L”。也可以单击“视图”菜单，然后选择“切换到无缝模式”。\nVirtualBox将隐藏来宾操作系统的桌面背景，使其看起来好像来宾操作系统的程序正在主机操作系统的桌面上运行。但是，正在运行的应用程序不会出现在操作系统的标准任务栏上。\n要退出无缝模式，只需按主机键，然后再次按L。您还可以在任务栏上方找到VirtualBox菜单，您可以将鼠标悬停在上面查看。单击查看并再次选择切换到无缝模式以禁用无缝模式。\n使用vmware的unity模式\nVMware有一个类似的功能，名为Unity mode。它可以在免费的VMware Player、VMware Workstation和VMware的其他付费应用程序上使用。与VirtualBox一样，VMware的Unity模式适用于Windows和Linux客户机。\nVBox+WinXP SP3 Windows XP; Guest Additions installation stuck; Virtualbox 6.1.18\nDisconnect network. It helps me.\nVS VMWare 工具是用来解决问题的，没必要看到开源就意识形态附体\n虚拟机网络模式 桥接\n桥接网络是指本地物理网卡和虚拟网卡通过VMnet0虚拟交换机进行桥接，物理网卡和虚拟网卡在拓扑图上处于同等地位，那么物理网卡和虚拟网卡就相当于处于同一个网段，虚拟交换机就相当于一台现实网络中的交换机,所以两个网卡的IP地址也要设置为同一网段。\n所以当我们要在局域网使用虚拟机，对局域网其他pc提供服务时，例如提供ftp，提供ssh，提供http服务，那么就要选择桥接模式。\n例如大学宿舍里有一个路由器，宿舍里四个人连接这个路由器，路由器的wanip就不理会了，这个ip是动态获取的，而lanip默认是192.168.1.1,子网掩码是255.255.255.0。而其他四个人是自动获取ip，假设四个人的ip是:\nA:192.168.1.100/255.255.255.0,\nB:192.168.1.101/255.255.255.0\nC:192.168.1.102/255.255.255.0\nD:192.168.1.103/255.255.255.0\n那么虚拟机的ip可以设置的ip地址是192.168.1.2-192.168.1.99,192.168.1.104-192.168.1.254 (即网络地址全0和全1的除外，再除去ABCD四个人的ip地址)\n那么虚拟机的ip地址可以设置为192.168.1.98/255.255.255.0，设置了这个ip地址，ABCD这四个人就可以通过192.168.1.98访问虚拟机了，如果虚拟机需要上外网，那么还需要配置虚拟机的路由地址，就是192.168.1.1了，这样，虚拟机就可以上外网了，但是，上网我们一般是通过域名去访问外网的，所以我们还需要为虚拟机配置一个dns服务器，我们可以简单点，把dns服务器地址配置为google的dns服务器:8.8.8.8,到此，虚拟机就可以上网了。\nNAT\nNAT模式中，就是让虚拟机借助NAT(网络地址转换)功能，通过宿主机器所在的网络来访问公网。\nNAT模式中，虚拟机的网卡和物理网卡的网络，不在同一个网络，虚拟机的网卡，是在vmware提供的一个虚拟网络。\nNAT和桥接的比较:\n NAT模式和桥接模式虚拟机都可以上外网。 由于NAT的网络在vmware提供的一个虚拟网络里，所以局域网其他主机是无法访问虚拟机的，而宿主机可以访问虚拟机，虚拟机可以访问局域网的所有主机，因为真实的局域网相对于NAT的虚拟网络，就是NAT的虚拟网络的外网。 桥接模式下，多个虚拟机之间可以互相访问；NAT模式下，多个虚拟机之间也可以相互访问。  如果你建一个虚拟机，只是给自己用，不需要给局域网其他人用，那么可以选择NAT，毕竟NAT模式下的虚拟系统的TCP/IP配置信息是由VMnet8(NAT)虚拟网络的DHCP服务器提供的，只要虚拟机的网路配置是DHCP，那么你不需要进行任何其他的配置，只需要宿主机器能访问互联网即可，就可以让虚拟机联网了。\n例如你想建多个虚拟机集群，作为测试使用，而宿主机可能是一个笔记本，ip不固定。这种应用场景，我们需要采用nat模式了，但是我们要考虑一个问题，虚拟机之间是需要互访的，默认采用dhcp，虚拟机的ip每次重启，ip都是不固定的，所以我们需要手工设置虚拟机的ip地址。\nHost-Only\n在Host-Only模式下，虚拟网络是一个全封闭的网络，它唯一能够访问的就是主机。其实Host-Only网络和NAT网络很相似，不同的地方就是Host-Only网络没有NAT服务，所以虚拟网络不能连接到Internet。主机和虚拟机之间的通信是通过VMware Network Adepter VMnet1虚拟网卡来实现的。\nHost-Only的宗旨就是建立一个与外界隔绝的内部网络，来提高内网的安全性。这个功能或许对普通用户来说没有多大意义，但大型服务商会常常利用这个功能。\nVMware 用 VMware 的坑：我用普通账户创建虚拟机，然后它安装 vmware tools 需要 root 权限，用 root 权限开启 VMWare 的话，就没有之前的虚拟机了。所以，最好一开始，就用 root 权限运行 VMWare。\nErrors- vmware unable to install all modules vmmon vmnet\nIn case you get Gcc not found and Kernel modules compiling error upon starting the Vmware, then you have to install them. For that, first, close the Vmware Player window and then run the below two commands:\n$ sudo apt install gcc $ sudo apt-get install build-essential After that start the Vmware player again and start installing the modules. If you still have the error then follow the further steps.\n Download the latest vmware-host-modules – VMMON and VMNET  Visit: https://github.com/mkubecek/vmware-host-modules\nThere as per your Vmware Player station, download the module file. For example– while doing this article the version of Workstation was 16.2.3, hence we download the same module file in zip format.\nThe file we download using the browser goes to the Downloads directory. Hence, switch to that.\n$ cd Downloads $ sudo apt install unzip $ unzip vmware-host-modules-w16.2.3-k5.18.zip $ cd vmware-host-modules-w16.2.3-k5.18 $ tar -cf vmmon.tar vmmon-only $ tar -cf vmnet.tar vmnet-only $ sudo cp -v vmmon.tar vmnet.tar /usr/lib/vmware/modules/source/ $ sudo vmware-modconfig --console --install-all Uninstall or Remove Vmware Linux\n$ cd /usr/bin $ sudo ./vmware-installer -u vmware-player 反虚拟机检测 在开发测试中，不少人会选择使用虚拟机环境来进行，以避免对主机产生影响，特别是一些软件类测试，比如病毒分析等VMWare等。在实际测试中会发现，相当一部分软件或代码也在进行反虚拟机来逃避分析，这种技术可以检测自己是否运行在虚拟机中，如果探测到自己在虚拟机中运行，它就会执行与其本身行为不同的行为，这时候就无法达到我们测试的目的了。因此我们可以考虑通过修改配置来达到让虚拟机内运行的软件无法探测到虚拟机环境的目标。\n探测方向 不管是通过 VMware 还是 Oracle VirtualBox 抑或是 Microsoft Hyper-V，只要是虚拟出来的环境，都或多或少会有痕迹存在，目前用来探测的比较多的痕迹有以下几个。\nMAC 地址\n这是最明显的特征。通常 MAC 地址的前三个字节标识一个提供商。以 00:05:69、00:0c:29 和00:50:56 开始的 MAC 地址与 VMware 相对应；以 00:03:ff 开始的 MAC 地址与 virtualpc 对应；以 08:00:27 开始的 MAC 地址与 VirtualBox 对应。\n其他硬件信息\n虚拟机环境中，主板序列号、主机型号、系统盘所在磁盘名称等硬件信息，以及这些硬件采用的驱动，通常都会带有 VMware、VirtualBox、VBOX、Virtual Machine 等字眼。\n特定的进程信息\n为方便使用，比如自动捕获鼠标、分辨率自适应等，我们会安装 VMware Tools 或者 VBoxGuestAdditions 等增强包，这也是虚拟机环境非常明显的一个特征。通过进程快照读取当前进程信息，查找是否存在虚拟机中特有的进程，如 VMware 中的 vmware.exe 和 VirtualBox 中的 VBoxService.exe。\n特定的文件夹或文件信息\n通过查找磁盘中是否存在特定的文件夹或文件，判断当前是否在虚拟机中。VMware 虚拟机中通常会有路径 C:\\Program Files\\VMware\\VMware Tools\\；VirtualBox 虚拟机中通常会有路径 C:\\Program Files\\Oracle\\VirtualBox Guest Additions\\。\n特定的注册表信息\n通过读取主机具有虚拟机特性的注册表位置来判断是否处于虚拟机环境中。针对 VMware 可以判断注册表项 HKEY_CLASSES_ROOT\\Applications\\VMwareHostOpen.exe；针对 VirtualBox 可以判断注册表项 HKEY_LOCAL_MACHINE\\SOFTWARE\\Oracle\\VirtualBox Guest Additions。当然，注册表中能被检测出的位置很多，这里只是举个例子。\n特定的服务名\n通过获取主机当前具有虚拟机特性的服务信息，判断当前主机是否为虚拟机。在 VMware 中通常会存在 VMware 物理磁盘助手服务和VMware Tools服务等；在 VirtualBox 中通常会存在VirtualBox Guest Additions Service服务等。\n时间差\n由于在虚拟机中，代码的运行速度通常不如真实主机。所以通过运行一段特定的代码来比较这段代码在虚拟机和真实主机之中的相对运行时间，以此来判断是否处于虚拟机之中。\n其他\n上面说的几种方法都能够检测虚拟机，但检测的方法却不仅限于此，有兴趣的可以再深入研究。\n反探测 近年来，随着虚拟化技术的使用不断增加，采用反虚拟机技术的软件数量逐渐下降，编写者已经开始意识到，目标主机是虚拟机，也并不意味着它就没有攻击价值，特别在于目前云计算产业正在如火如荼地发展中。\n以 VMware 为例，我们可以通过下面的方法来解决上文探测方向中的大部分痕迹。由于修改信息可能会导致系统激活状态失效，或者修改后配置不生效，故建议在创建虚拟机时就修改好。\n修改软件信息\n VMTools 接口  直接将下面的代码贴到虚拟配置文件 .vmx 中（如果是 EXSi，建议通过 WEB 控制面板来修改配置），屏蔽 VMware 特定信息的探测：\nisolation.tools.getPtrLocation.disable = \"TRUE\" isolation.tools.setPtrLocation.disable = \"TRUE\" isolation.tools.setVersion.disable = \"TRUE\" isolation.tools.getVersion.disable = \"TRUE\" monitor_control.disable_directexec = \"TRUE\" monitor_control.disable_chksimd = \"TRUE\" monitor_control.disable_ntreloc = \"TRUE\" monitor_control.disable_selfmod = \"TRUE\" monitor_control.disable_reloc = \"TRUE\" monitor_control.disable_btinout = \"TRUE\" monitor_control.disable_btmemspace = \"TRUE\" monitor_control.disable_btpriv = \"TRUE\" monitor_control.disable_btseg = \"TRUE\" monitor_control.restrict_backdoor = \"TRUE\" 驱动信息\n主要是显卡，先安装 VMware Tools 装好驱动，备份出显卡驱动，然后修改驱动中的安装文件 *.inf，将 STRING 一节中的相关字眼修改掉，再还原驱动。\nDiskID = \"NVIDIA Windows Driver Library Installation\" CompanyName = \"NVIDIA\" SVGA = \"GeForce GTX 660\" 在这一步中，需要安装 VMware Tools 才会有显卡驱动，但是上面修改了配置，将无法安装 VMware Tools，会提示“只应安装在虚拟机内”。由于安装 VMware Tools 将会是一个非常明显的特征，因此不建议安装。且虚拟机驱动其实都是一样的，因此可以从其他虚拟机中导出来直接使用。\n修改硬件信息\n 主板信息  下面的代码表示延用实体机的主板信息：\nSMBIOS.reflecthost = \"TRUE\" SMBIOS.noOEMStrings = \"TRUE\" SMBIOS.addHostVendor = \"TRUE\" hw.model.reflectHost = \"TRUE\" serialNumber.reflectHost = \"TRUE\" board-id.reflectHost = \"TRUE\" 也可以自己编一个，比如在黑苹果中会用到的：\nsmbios.reflectHost = \"FALSE\" smbios.vendor = \"Apple Computer, Inc.\" smbios.version = \"MBA51.88Z.0055.B08.0610121\" smbios.family =\"MacBook Pro\" smbios.model = \"MacBookPro1.1\" smbios.date =\"10/12/06\" smbios.manufacturer = \"Apple Computer, Inc.\" smbios.systemversion = \"1.0\"  磁盘信息  如果在 scsi0 插槽上有 SCSI 虚拟磁盘作为系统驱动器，可以添加：\nscsi0:0.productID = \"WDC_____WD10EZEX-57WN4D11\" scsi0:0.vendorID = \"WDC\" scsi0:0 表示第一个插槽，其他硬件也可以类似指定 ID。\n 网卡信息  参考实体机 MAC 地址信息，自行编一个：\nethernet0.checkMACAddress = \"FALSE\" ethernet0.address = \"BC:30:5B:DD:D2:E8\" 以上的方法能够解决大部分的虚拟机探测，但是一些使用寄存器值、任务状态段（Task Status Segment, TSS）、I/O 接口等检测方法的软件，仍然骗不过。\n参考文章：\n1、《反虚拟机技术总结》 2、《过虚拟机检测》 3、《解决VMware Tools提示 “只应安装在虚拟机内\"的问题》 4、《VM反虚拟机检测》 5、《那些年病毒用过的损招——反虚拟机技术》\n相关文章：\n1、《VMware Workstation Pro 最新版下载及永久激活 KEY 激活码序列号》 2、《重制：VMware 15 Pro 安装黑苹果 macOS10.13.5 图文教程：流畅、好用！》\nQuestions piix4_smbus Host SMBus controller not enabled\n从内核的说明文档来看，这个 piix4 实际上是 Intel 82371AB 南桥芯片，多功能总线控制器，而在 VMware 里面并没有这个真实的芯片组，但在启动时最会尝试载入这个驱动模块，所以会报错，但对系统没有任何影响。\nOthers 通过 Qemu 安装 Windows 到硬盘 双系统新思路。今天装windows, 在linux上先用虚拟机，把硬盘直通进去，在raw盘上装好，然后更新grub, 再重启就可以直接接进去了。\n这样可以避免装机还要做启动盘，装机过程中的重启也可以避免了。\nwin的安装过程中驱动都是按照虚拟机的配置安装的，但是win10是自动装驱动的，重启进去后过了一会显卡驱动自动都装好了。\nBoot a physical Windows partition with qemu Booting an native, physical Windows 7 partition can be done by this:\n Prepare requisites (Windows 7 installation media, Virtio drivers). Make your hard drive accessible read-only for your current user. Boot it using QEMU in snapshot mode.  This does not change anything on the physical drive (in fact it is read-only). If you want to persist the stuff, remove -snapshot from the QEMU invocation or use commit all within the QEMU console.\nBy the way, this works fine for Windows 10 as well.\n Prepare requisites\n Prepare an ISO or, if you have a drive at hand, the real installation media for Win7. Download Virtio drivers, e.g. for example this drivers from Fedora: https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/latest-virtio/virtio-win.iso  Take care to use the correct installation media matching the installed Windows architecture (32bit vs 64bit). The following commands assume a 64bit architecture.\nMake disk accessible\nThis assumes your hard drive is /dev/sda and has be executed as root:\nchmod g-w /dev/sda chgrp $USER /dev/sda This changes will (probably) be lost at next reboot as udev will usually recreate all device files.\nBooting with QEMU\n  This again assumes your hard drive is /dev/sda. Networking is disabled:\nqemu-system-x86_64 -snapshot -m 3G -enable-kvm -usbdevice tablet \\ -drive file=/dev/sda,if=virtio \\ -drive file= \\ -drive file=,media=cdrom -boot d \\ -net none   Now boot from CD/DVD to start Windows 7 recovery, load the Virtio driver and run the following command in the recovery command prompt. Ensure that you replace the drive letters with the proper ones:\ndism /image:g:\\ /add-driver /driver:e:\\viostor\\w7\\amd64   Drive G: is the drive containing your Windows 7 installation. Drive E: represent the CDROM drive with the Virtio drivers. In order to show some help for this command variant use dism /image:g:\\ /?.\nThe dism command was copied from this Super User answer.\n补充\n I also managed to get the drivers installed with drvload.exe E:\\amd64\\w7\\viostor.inf 获取可用驱动器名称：wmic logicaldisk get name 结果：启动到了 openSUSE 的 grub，选择 Boot Windows 后蓝屏。 另一个教程 Boot Your Windows Partition from Linux using KVM 使用 RAID 虚拟磁盘解决共享 EFI 分区带来的问题。依云姐姐也写了个教程——使用 VirtualBox 启动本地磁盘上的其它系统。  Looking Glass Looking Glass 讓 Linux 可完美玩 Windows 遊戲 超低延遲不掉格\n當用戶安裝了虛擬電腦（VM）實行 Windows，並執行遊戲時，它採用的 KVM frame relay 技術可將 Windows 顯示記憶體，透過 PCI pass-through 直接由 Windows VM 被配置的顯示卡，複製到 Linux 被配置的顯示卡，這樣 Linux 便可在極為低延遲的情況下，接近完美顯示 Windows 遊戲的內容。\n簡單來說，就是一部 Linux 電腦裡面裝有虛擬電腦運行的 Windows，Windows 遊戲實行時，在被配置的顯示卡記憶體資料，在主機板 PCI 通道直接複製到 Linux 被配置的顯示卡。即是說 Windows 遊戲原本畫面，可高速反映到 Liunx 的虛擬電腦軟件上。這樣 Linux 用戶就算不 Dual boot 或使用兩個熒幕，在 Linux 上都可得到接近相同的打機體驗。\nxrdp xrdp 使用 RDP（Microsoft 远程桌面协议）为远程计算机提供图形登录。xrdp 接受来自各种 RDP 客户端的连接：FreeRDP、rdesktop、NeutrinoRDP 和 Microsoft 远程桌面客户端（适用于 Windows、macOS、iOS 和 Android）。\n正如 Windows 到 Windows 远程桌面一样，xrdp 不仅支持图形远程处理，还支持\n 双向剪贴板传输（文本、位图、文件） 音频重定向 驱动器重定向（在远程机器上安装本地客户端驱动器）  RDP 传输默认使用 TLS 加密。\nQEMU/KVM VS Virtualbox Linux 系统上的虚拟化解决方案 – KVM 和 VirtualBox\nKVM 提供了一些 VirtualBox 没有的功能，反之亦然。IT 世界中没有通用工具，因此使用适合您需求的工具非常重要。基本思想是：如果你想安装二进制 Linux 发行版作为来宾，使用 KVM。它速度更快，并且它的驱动程序包含在官方内核树中。如果您的客户涉及大量编译并且需要一些更高级的功能，并且/或者不是 Linux 系统，那么最好使用 VirtualBox。\n技术原因很简单：KVM 更好地与 Linux 集成，它更小更快，虽然你可以在 Linux 以外的其他客户机上使用它，但我们发现体验相当麻烦：BSD 的 I/O 和 Solaris 往往很慢（确切地说，是 OpenIndiana）在引导安装 ISO 后会立即出现恐慌。由于我们使用当前版本的 BSD（并且经常从源代码编译/更新系统）并且还需要 Solaris，我们发现 VirtualBox 是一个更好的选择。Oracle VirtualBox 的另一个优点是它支持挂起，即您可以将机器状态保存在主机的硬盘上并关闭 VirtualBox，当（重新)启动时，系统将从它离开的地方恢复。这就是为什么我们提到源代码编译：如果你有一台嘈杂的机器，你不想一夜之间离开，但你的 Gentoo 虚拟机只是编译一个新的 gcc 版本，暂停机器状态，关闭主机，明天继续。\n桌面虚拟化、KVM 还是 Virtualbox？\n这两者中的哪一个更适合在 Linux 台式机/笔记本电脑上运行 Windows 10 虚拟机？\n  带有virt-manager 的QEMU/KVM应该可以与 Virtualbox 媲美。\nVirtualbox 没问题，特别是如果跨主机操作系统使用相同的虚拟化很重要，但 QEMU/KVM 是更好的投资。QEMU/HAXM 也应该可以在 Mac 和 Windows 上运行，尽管它目前还不够成熟。\n  KVM, obviously. You’re probably going to need to learn how to manage it, but it is a much better system and allows abstraction on completely unexposed CPU hardware so you can easily take your image and put it onto another KVM. Windows doesn’t like to have it’s CPUs exchange on it very often.\n  KVM 与 VirtualBox\n  表现\n这是要考虑的最重要的领域之一，即管理程序的性能将如何影响您的基础架构。KVM 是 1 类管理程序（这些虚拟机管理程序直接运行在宿主机的硬件上来控制硬件和管理客操作系统），而 VirtualBox 是 2 类管理程序（这些虚拟机管理程序运行在传统的操作系统上，就像其他计算机程序那样运行），这意味着 KVM 应该优于 VirtualBox。\n根据SPECvirt_sc2013 基准测试，VirtualBox 通常比 KVM 需要更多时间来创建和启动服务器，而 KVM 以接近本机的速度运行应用程序，比其他行业管理程序更快。尽管对于典型负载，差异可能微不足道。\n  管理程序管理\n这两个给定的应用程序都可以通过 GUI 进行管理。Virtualbox 相对来说有更好的 GUI，但 KVM 的当前 GUI 使其管理比以往任何时候都更容易。”\n如果您更喜欢命令行，那么 KVM 中有各种命令行选项。Virtualbox 也提供了一个命令行界面，但它不如 KVM virsh 全面。您不能直接从 bash 启动 Virtualbox VM。\n  可扩展性\nKVM 继承了 Linux 的性能，如果来宾机器和请求的数量增加，可以扩展以匹配需求负载。KVM 允许对要求最苛刻的应用程序工作负载进行虚拟化，并且是许多企业虚拟化设置的基础，例如数据中心和私有云。\nVirtualBox 可以为每个 VM 提供多达 32 个虚拟 CPU，而不管主机上物理存在多少 CPU 内核。还可以为具有多达 1024 个 CPU 的主机提供支持。\n  安全\nKVM 提供增强的安全性，因为它结合使用 SELinux 和安全虚拟化 (sVirt)。VirtualBox 可以执行虚拟机的安全实时迁移和磁盘映像加密。它还包括远程桌面协议 (RDP) 身份验证和用于创建进一步身份验证要求以帮助提高安全性的 SDK。您可以在此页面上看到 Virtualbox 的安全功能列表。\n  成本和定价\nKVM 是一个开源的免费平台，由 Red Hat 等供应商提供有偿支持。虽然 Virtualbox 在限制范围内是免费的。一旦您超过一定的使用水平，您必须获得产品许可。\n  支持\n对于 KVM，您需要依赖开源社区和您自己的 IT 组织或受支持的供应商（如红帽）的支持。Oracle 正在积极开发 Virtualbox，您可以从他们那里获得任何支持。\n  Android-x86 android x86 是一个自由而开源的项目，将谷歌制作的安卓系统从 ARM 架构移植到了 x86 架构，可以让用户在他们的桌面电脑上运行安卓系统来享受所有的安卓功能和应用程序及游戏。\n首次启动运行该安卓系统，运行：\n$ qemu-img create -f qcow2 Android8-VM.img 30G $ gedit start_Android8_VM.sh #!/bin/bash DISKIMG=/media/kurome/Ventoy/QemuKVM/Android8-VM.img exec qemu-system-x86_64 --enable-kvm \\  -hda ${DISKIMG} \\  -net nic -net user \\  -m 4096 \\  -smp cores=2,threads=4 \\  -monitor stdio \\  -vga std \\  -soundhw es1370 \\  -usb -device usb-tablet \\  -name 'Andriod8 VM' \\  $@ $ chmod u+x start_Android8_VM.sh $ ./start_Android8_VM.sh -boot d -cdrom ~/Downloads/android-x86_64-9.0-r2.iso 在，安卓系统已经完全安装在你的 android.img 文件中，你应该使用下面的 QEMU 命令来启动它，而不是前面的命令：\n$ ./start_Android8_VM.sh Waydroid Waydroid是一个基于lxc容器技术，用以启动完整安卓系统的方案。\nGenymotion Android Virtual Devices for all your development \u0026 testing needs\nLibVF.IO Commodity GPU Multiplexing Driven By VFIO \u0026 YAML.\nOSX-KVM macOS VM in QEMU\n$ git clone --depth 2 --recursive https://github.com/kholia/OSX-KVM.git $ cd OSX-KVM $ echo 1 | sudo tee /sys/module/kvm/parameters/ignore_msrs $ sudo cp kvm.conf /etc/modprobe.d/kvm.conf $ ./fetch-macOS-v2.py $ dmg2img -i BaseSystem.dmg BaseSystem.img $ qemu-img create -f qcow2 mac_hdd_ng.img 128G $  使用 --depth 2，方便 git reset --hard 基本上只需要改 OpenCore-Boot.sh 就行了，比如可以用别人制作好的 iso 镜像，而不用 BaseSystem.dmg（这是个恢复镜像，通过其再下载完整系统）。 不要在设置里改 Resolution，改了之后更差。openSUSE 默认用 vnc，桌面分辨率太高根本显示不全，无法改设置了，vnc 也尝试关闭关不了，烦。 Ventura 选择 APFS 安装后报错 an error occurred preparing the update，选择 non-APFS filesystem 则安装成功了。（20221215）  quickemu Quickly create and run optimised Windows, macOS and Linux desktop virtual machines.\n","wordCount":"37535","inLanguage":"en","image":"https://sakamotokurome.github.io/Covers/ubuntu03.jpg.webp","datePublished":"2022-03-08T15:32:02+08:00","dateModified":"2022-03-08T15:32:02+08:00","author":{"@type":"Person","name":"Sakamoto Kurome"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sakamotokurome.github.io/posts/ubuntup2virtualization/"},"publisher":{"@type":"Organization","name":"Sakamoto Kurome","logo":{"@type":"ImageObject","url":"https://sakamotokurome.github.io/favicon.ico"}}}</script>
</head>
<body class=dark id=top>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://sakamotokurome.github.io/ accesskey=h title="Sakamoto Kurome (Alt + H)">Sakamoto Kurome</a>
<span class=logo-switches>
</span>
</div>
<ul id=menu>
<li>
<a href=https://sakamotokurome.github.io/archives/ title=Archives>
<span>Archives</span>
</a>
</li>
<li>
<a href=https://sakamotokurome.github.io/search/ title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li>
<li>
<a href=https://sakamotokurome.github.io/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
Ubuntu Virtualization
</h1>
<div class=post-meta><span title="2022-03-08 15:32:02 +0800 +0800">March 8, 2022</span>&nbsp;·&nbsp;75 min&nbsp;·&nbsp;Sakamoto Kurome
</div>
</header>
<figure class=entry-cover><img loading=lazy src=https://sakamotokurome.github.io/Covers/ubuntu03.jpg.webp alt="Ubuntu Logo">
<p>Ubuntu Virtualization</p>
</figure><div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#winehttpswikiarchlinuxorgtitlewine_e7ae80e4bd93e4b8ade69687 aria-label=Wine><a href=https://wiki.archlinux.org/title/Wine_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)>Wine</a></a><ul>
<li>
<a href=#%e7%ae%80%e4%bb%8bhttpszhmwikipediaorgwikiwine aria-label=简介><a href=https://zh.m.wikipedia.org/wiki/Wine>简介</a></a></li>
<li>
<a href=#%e5%ae%89%e8%a3%85httpswikiwinehqorgubuntu aria-label=安装><a href=https://wiki.winehq.org/Ubuntu>安装</a></a></li>
<li>
<a href=#%e9%85%8d%e7%bd%ae aria-label=配置>配置</a><ul>
<li>
<a href=#%e5%88%9d%e5%a7%8b%e8%ae%be%e7%bd%aehttpswikiubuntuorgcnubuntuhelpwinezh aria-label=初始设置><a href=https://wiki.ubuntu.org.cn/UbuntuHelp:Wine/zh>初始设置</a></a></li>
<li>
<a href=#wineprefix aria-label=WINEPREFIX>WINEPREFIX</a></li>
<li>
<a href=#winearch aria-label=WINEARCH>WINEARCH</a></li>
<li>
<a href=#%e5%9b%be%e5%bd%a2%e9%a9%b1%e5%8a%a8 aria-label=图形驱动>图形驱动</a></li>
<li>
<a href=#%e5%a3%b0%e9%9f%b3 aria-label=声音>声音</a></li>
<li>
<a href=#%e4%b8%ad%e6%96%87%e5%ad%97%e4%bd%93httplinux-wikicnwikizh-hanswinee79a84e4b8ade69687e698bee7a4bae4b88ee5ad97e4bd93e8aebee7bdae aria-label=中文字体><a href=http://linux-wiki.cn/wiki/zh-hans/Wine%E7%9A%84%E4%B8%AD%E6%96%87%E6%98%BE%E7%A4%BA%E4%B8%8E%E5%AD%97%E4%BD%93%E8%AE%BE%E7%BD%AE>中文字体</a></a></li>
<li>
<a href=#%e5%90%af%e5%8a%a8%e5%99%a8%e5%92%8c%e8%8f%9c%e5%8d%95 aria-label=启动器和菜单>启动器和菜单</a></li></ul>
</li>
<li>
<a href=#%e5%ae%89%e8%a3%85%e8%bf%90%e8%a1%8c%e5%8d%b8%e8%bd%bd-windows-%e7%a8%8b%e5%ba%8f aria-label="安装/运行/卸载 Windows 程序">安装/运行/卸载 Windows 程序</a></li>
<li>
<a href=#%e6%8a%80%e5%b7%a7 aria-label=技巧>技巧</a><ul>
<li>
<a href=#opengl-%e6%a8%a1%e5%bc%8f aria-label="OpenGL 模式">OpenGL 模式</a></li>
<li>
<a href=#wine-%e6%8e%a7%e5%88%b6%e5%8f%b0 aria-label="Wine 控制台">Wine 控制台</a></li>
<li>
<a href=#winetrickshttpswikiwinehqorgwinetricks aria-label=winetricks><a href=https://wiki.winehq.org/Winetricks>winetricks</a></a></li>
<li>
<a href=#monohttpswikiwinehqorgmono--geckohttpswikiwinehqorggecko aria-label="Mono &amp;amp; Gecko"><a href=https://wiki.winehq.org/Mono>Mono</a> & <a href=https://wiki.winehq.org/Gecko>Gecko</a></a></li></ul>
</li>
<li>
<a href=#crossoverhttpswwwcodeweaverscom aria-label=CrossOver><a href=https://www.codeweavers.com>CrossOver</a></a><ul>
<li>
<a href=#tutorialshttpswwwcodeweaverscomsupportwikilinuxlinuxtutorial aria-label=Tutorials><a href=https://www.codeweavers.com/support/wiki/linux/linuxtutorial>Tutorials</a></a></li>
<li>
<a href=#dxvkhttpswwwcodeweaverscomsupportwikilinuxlinuxtutorialdxvk aria-label=DXVK><a href=https://www.codeweavers.com/support/wiki/linux/linuxtutorial/dxvk>DXVK</a></a></li>
<li>
<a href=#esynchttpsgithubcomzfigurawineblobesyncreadmeesync aria-label=Esync><a href=https://github.com/zfigura/wine/blob/esync/README.esync>Esync</a></a><ul>
<li>
<a href=#howtoesynchttpsgithubcomlutrisdocsblobmasterhowtoesyncmd aria-label=HowToEsync><a href=https://github.com/lutris/docs/blob/master/HowToEsync.md>HowToEsync</a></a></li></ul>
</li>
<li>
<a href=#%e8%af%ad%e8%a8%80%e8%ae%be%e7%bd%aehttpsblogcsdnnetqq_35503971articledetails107296647 aria-label=语言设置><a href=https://blog.csdn.net/qq_35503971/article/details/107296647>语言设置</a></a></li></ul>
</li>
<li>
<a href=#third-party-appshttpswikiarchlinuxorgtitlewinethird-party_applications aria-label="Third-party apps"><a href=https://wiki.archlinux.org/title/wine#Third-party_applications>Third-party apps</a></a><ul>
<li>
<a href=#bottleshttpsusebottlescom aria-label=Bottles><a href=https://usebottles.com/>Bottles</a></a></li>
<li>
<a href=#protonhttpsgithubcomvalvesoftwareproton aria-label=Proton><a href=https://github.com/ValveSoftware/Proton>Proton</a></a></li>
<li>
<a href=#playonlinuxhttpswwwplayonlinuxcom aria-label=PlayOnLinux><a href=https://www.playonlinux.com/>PlayOnLinux</a></a></li>
<li>
<a href=#lutrishttpslutrisnet aria-label=Lutris><a href=https://lutris.net/>Lutris</a></a></li></ul>
</li>
<li>
<a href=#%e5%ae%9e%e4%be%8b aria-label=实例>实例</a><ul>
<li>
<a href=#hearthstonehttpsgithubcomborisbabichearthstone_hdt_linux aria-label=HearthStone><a href=https://github.com/borisbabic/hearthstone_hdt_linux>HearthStone</a></a></li>
<li>
<a href=#office-2013-prohttpsaskubuntucomquestions879304wine-2-0-says-it-supports-office-2013-how-do-i-actually-install-it aria-label="Office 2013 Pro"><a href=https://askubuntu.com/questions/879304/wine-2-0-says-it-supports-office-2013-how-do-i-actually-install-it>Office 2013 Pro</a></a></li>
<li>
<a href=#genshin-impact aria-label="Genshin Impact">Genshin Impact</a></li></ul>
</li>
<li>
<a href=#darlinghttpsgithubcomdarlinghqdarling aria-label=darling><a href=https://github.com/darlinghq/darling>darling</a></a></li>
<li>
<a href=#anboxhttpslinuxcnarticle-10843-1html aria-label=Anbox><a href=https://linux.cn/article-10843-1.html>Anbox</a></a><ul>
<li>
<a href=#anbox-%e7%ae%80%e4%bb%8b aria-label="Anbox 简介">Anbox 简介</a></li>
<li>
<a href=#%e5%ae%89%e8%a3%85%e4%bd%bf%e7%94%a8 aria-label=安装使用>安装使用</a></li></ul>
</li></ul>
</li>
<li>
<a href=#qemu-kvmhttpswikiarchlinuxorgtitleqemu_e7ae80e4bd93e4b8ade69687 aria-label="QEMU KVM"><a href=https://wiki.archlinux.org/title/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)>QEMU KVM</a></a><ul>
<li>
<a href=#qemu-%e7%9a%84%e5%9b%be%e5%bd%a2%e5%89%8d%e7%ab%af aria-label="QEMU 的图形前端">QEMU 的图形前端</a></li>
<li>
<a href=#%e5%88%9b%e5%bb%ba%e6%96%b0%e8%99%9a%e6%8b%9f%e7%b3%bb%e7%bb%9f aria-label=创建新虚拟系统>创建新虚拟系统</a><ul>
<li>
<a href=#%e5%88%9b%e5%bb%ba%e7%a1%ac%e7%9b%98%e9%95%9c%e5%83%8f aria-label=创建硬盘镜像>创建硬盘镜像</a><ul>
<li>
<a href=#%e8%b0%83%e6%95%b4%e9%95%9c%e5%83%8f%e5%a4%a7%e5%b0%8f aria-label=调整镜像大小>调整镜像大小</a></li></ul>
</li>
<li>
<a href=#%e5%ae%89%e8%a3%85%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f aria-label=安装操作系统>安装操作系统</a></li></ul>
</li>
<li>
<a href=#%e8%bf%90%e8%a1%8c%e8%99%9a%e6%8b%9f%e5%8c%96%e7%9a%84%e7%b3%bb%e7%bb%9f aria-label=运行虚拟化的系统>运行虚拟化的系统</a><ul>
<li>
<a href=#%e5%90%af%e7%94%a8-kvm aria-label="启用 KVM">启用 KVM</a></li></ul>
</li>
<li>
<a href=#%e5%ae%bf%e4%b8%bb%e6%9c%ba%e5%92%8c%e8%99%9a%e6%8b%9f%e6%9c%ba%e6%95%b0%e6%8d%ae%e4%ba%a4%e4%ba%92 aria-label=宿主机和虚拟机数据交互>宿主机和虚拟机数据交互</a><ul>
<li>
<a href=#%e7%bd%91%e7%bb%9c aria-label=网络>网络</a></li>
<li>
<a href=#qemu-%e7%ab%af%e5%8f%a3%e8%bd%ac%e5%8f%91 aria-label="QEMU 端口转发">QEMU 端口转发</a></li>
<li>
<a href=#qemu-%e7%9a%84%e5%86%85%e7%bd%aesmb%e6%9c%8d%e5%8a%a1%e5%99%a8 aria-label="QEMU 的内置SMB服务器">QEMU 的内置SMB服务器</a></li>
<li>
<a href=#%e6%8c%82%e8%bd%bdqcow2%e9%95%9c%e5%83%8f%e5%86%85%e7%9a%84%e5%88%86%e5%8c%bahttpswikiarchlinuxorgtitleqemu_e7ae80e4bd93e4b8ade69687e68c82e8bdbdqcow2e9959ce5838fe58685e79a84e58886e58cba aria-label=挂载qcow2镜像内的分区><a href=https://wiki.archlinux.org/title/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E6%8C%82%E8%BD%BDqcow2%E9%95%9C%E5%83%8F%E5%86%85%E7%9A%84%E5%88%86%E5%8C%BA>挂载qcow2镜像内的分区</a></a></li></ul>
</li>
<li>
<a href=#%e7%bd%91%e7%bb%9c-1 aria-label=网络>网络</a><ul>
<li>
<a href=#%e5%85%b3%e4%ba%8e%e9%93%be%e8%b7%af%e5%b1%82%e5%9c%b0%e5%9d%80%e7%9a%84%e9%99%90%e5%88%b6 aria-label=关于链路层地址的限制>关于链路层地址的限制</a></li>
<li>
<a href=#%e7%94%a8%e6%88%b7%e6%a8%a1%e5%bc%8f aria-label=用户模式>用户模式</a></li>
<li>
<a href=#tap-%e7%bd%91%e7%bb%9c aria-label="Tap 网络">Tap 网络</a></li>
<li>
<a href=#%e9%80%9a%e8%bf%87-vde2-%e9%85%8d%e7%bd%ae%e7%bd%91%e7%bb%9c aria-label="通过 VDE2 配置网络">通过 VDE2 配置网络</a></li>
<li>
<a href=#vde2-%e7%bd%91%e6%a1%a5 aria-label="VDE2 网桥">VDE2 网桥</a></li>
<li>
<a href=#%e7%ae%80%e5%8c%96%e9%85%8d%e7%bd%ae%e5%8f%82%e6%95%b0 aria-label=简化配置参数>简化配置参数</a></li></ul>
</li>
<li>
<a href=#%e5%9b%be%e5%bd%a2 aria-label=图形>图形</a></li>
<li>
<a href=#vnc aria-label=VNC>VNC</a><ul>
<li>
<a href=#%e5%9f%ba%e6%9c%ac%e7%9a%84%e5%8f%a3%e4%bb%a4%e9%aa%8c%e8%af%81 aria-label=基本的口令验证>基本的口令验证</a></li></ul>
</li>
<li>
<a href=#%e9%9f%b3%e9%a2%91 aria-label=音频>音频</a><ul>
<li>
<a href=#%e4%bd%bf%e7%94%a8%e9%9f%b3%e9%a2%91%e8%ae%be%e5%a4%87 aria-label=使用音频设备>使用音频设备</a></li>
<li>
<a href=#%e6%97%a0%e9%9f%b3%e9%a2%91%e8%ae%be%e5%a4%87 aria-label=无音频设备>无音频设备</a></li></ul>
</li>
<li>
<a href=#%e5%ae%89%e8%a3%85-virtio-%e9%a9%b1%e5%8a%a8 aria-label="安装 virtio 驱动">安装 virtio 驱动</a><ul>
<li>
<a href=#%e5%9d%97%e8%ae%be%e5%a4%87%e9%a9%b1%e5%8a%a8 aria-label=块设备驱动>块设备驱动</a></li>
<li>
<a href=#%e7%bd%91%e7%bb%9c%e9%a9%b1%e5%8a%a8 aria-label=网络驱动>网络驱动</a></li>
<li>
<a href=#balloon-%e9%a9%b1%e5%8a%a8 aria-label="Balloon 驱动">Balloon 驱动</a></li></ul>
</li>
<li>
<a href=#qemu-%e7%9b%91%e8%a7%86%e5%99%a8 aria-label="QEMU 监视器">QEMU 监视器</a><ul>
<li>
<a href=#%e8%ae%bf%e9%97%aeqemu%e7%9b%91%e8%a7%86%e5%99%a8console aria-label=访问QEMU监视器Console>访问QEMU监视器Console</a></li>
<li>
<a href=#%e5%9c%a8monitor-conosle%e4%b8%8b%e5%90%91%e8%99%9a%e6%8b%9f%e6%9c%ba%e5%8f%91%e9%80%81%e6%8c%89%e9%94%ae%e8%a1%8c%e4%b8%ba aria-label="在Monitor conosle下向虚拟机发送按键行为">在Monitor conosle下向虚拟机发送按键行为</a></li>
<li>
<a href=#%e9%80%9a%e8%bf%87-monitor-console-%e5%88%9b%e5%bb%ba%e5%bf%ab%e7%85%a7%e5%92%8c%e7%ae%a1%e7%90%86%e5%bf%ab%e7%85%a7 aria-label="通过 monitor console 创建快照和管理快照">通过 monitor console 创建快照和管理快照</a></li>
<li>
<a href=#%e4%bb%a5%e5%86%bb%e7%bb%93%e6%a8%a1%e5%bc%8f%e8%bf%90%e8%a1%8c%e8%99%9a%e6%8b%9f%e6%9c%ba aria-label=以冻结模式运行虚拟机>以冻结模式运行虚拟机</a></li>
<li>
<a href=#monitor-console%e4%b8%ad%e7%9a%84%e5%bc%80%e6%9c%ba%e5%92%8c%e6%9a%82%e5%81%9c%e5%91%bd%e4%bb%a4 aria-label="monitor console中的开机和暂停命令">monitor console中的开机和暂停命令</a></li>
<li>
<a href=#%e8%99%9a%e6%8b%9f%e6%9c%ba%e6%88%aa%e5%b1%8f aria-label=虚拟机截屏>虚拟机截屏</a></li></ul>
</li>
<li>
<a href=#pci-passthrough-via-ovmfhttpswikiarchlinuxorgtitlepci_passthrough_via_ovmf_e7ae80e4bd93e4b8ade69687 aria-label="PCI passthrough via OVMF"><a href=https://wiki.archlinux.org/title/PCI_passthrough_via_OVMF_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)>PCI passthrough via OVMF</a></a><ul>
<li>
<a href=#%e7%ac%94%e8%ae%b0%e6%9c%ac-optimus-muxless-%e4%b8%8b%e7%9a%84-intel-%e5%92%8c-nvidia-%e8%99%9a%e6%8b%9f%e6%9c%ba%e6%98%be%e5%8d%a1%e7%9b%b4%e9%80%9ahttpslantianpubarticlemodify-computerlaptop-intel-nvidia-optimus-passthroughlantian aria-label="笔记本 Optimus MUXless 下的 Intel 和 NVIDIA 虚拟机显卡直通"><a href=https://lantian.pub/article/modify-computer/laptop-intel-nvidia-optimus-passthrough.lantian>笔记本 Optimus MUXless 下的 Intel 和 NVIDIA 虚拟机显卡直通</a></a></li>
<li>
<a href=#optimus-muxed-%e7%ac%94%e8%ae%b0%e6%9c%ac%e4%b8%8a%e7%9a%84-nvidia-%e8%99%9a%e6%8b%9f%e6%9c%ba%e6%98%be%e5%8d%a1%e7%9b%b4%e9%80%9ahttpslantianpubarticlemodify-computerlaptop-muxed-nvidia-passthroughlantian aria-label="Optimus MUXed 笔记本上的 NVIDIA 虚拟机显卡直通"><a href=https://lantian.pub/article/modify-computer/laptop-muxed-nvidia-passthrough.lantian>Optimus MUXed 笔记本上的 NVIDIA 虚拟机显卡直通</a></a></li></ul>
</li>
<li>
<a href=#%e6%8a%80%e5%b7%a7-1 aria-label=技巧>技巧</a><ul>
<li>
<a href=#%e6%94%b9%e5%96%84%e8%99%9a%e6%8b%9f%e6%9c%ba%e7%9a%84%e6%80%a7%e8%83%bd%e8%a1%a8%e7%8e%b0 aria-label=改善虚拟机的性能表现>改善虚拟机的性能表现</a></li>
<li>
<a href=#%e5%bc%80%e6%9c%ba%e6%97%b6%e5%90%af%e5%8a%a8qemu%e8%99%9a%e6%8b%9f%e6%9c%ba aria-label=开机时启动QEMU虚拟机>开机时启动QEMU虚拟机</a></li>
<li>
<a href=#%e9%bc%a0%e6%a0%87%e6%95%b4%e5%90%88 aria-label=鼠标整合>鼠标整合</a></li>
<li>
<a href=#%e5%ae%bf%e4%b8%bb%e6%9c%ba%e7%9a%84usb%e8%ae%be%e5%a4%87%e4%bc%a0%e9%80%92%e8%87%b3%e8%99%9a%e6%8b%9f%e6%9c%ba aria-label=宿主机的USB设备传递至虚拟机>宿主机的USB设备传递至虚拟机</a></li>
<li>
<a href=#%e4%bd%bf%e7%94%a8spice%e8%bf%9b%e8%a1%8cusb%e9%87%8d%e5%ae%9a%e5%90%91 aria-label=使用SPICE进行USB重定向>使用SPICE进行USB重定向</a></li>
<li>
<a href=#%e5%bc%80%e5%90%afksm aria-label=开启KSM>开启KSM</a></li>
<li>
<a href=#%e5%a4%9a%e5%b1%8f%e6%94%af%e6%8c%81 aria-label=多屏支持>多屏支持</a></li>
<li>
<a href=#%e5%a4%8d%e5%88%b6%e5%92%8c%e7%b2%98%e8%b4%b4 aria-label=复制和粘贴>复制和粘贴</a></li></ul>
</li>
<li>
<a href=#libvirthttpswikiarchlinuxorgtitlelibvirt_e7ae80e4bd93e4b8ade69687 aria-label=libvirt><a href=https://wiki.archlinux.org/title/Libvirt_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)>libvirt</a></a><ul>
<li>
<a href=#%e5%ae%89%e8%a3%85httpsubuntucomserverdocsvirtualization-libvirt aria-label=安装><a href=https://ubuntu.com/server/docs/virtualization-libvirt>安装</a></a></li>
<li>
<a href=#%e9%85%8d%e7%bd%ae-1 aria-label=配置>配置</a><ul>
<li>
<a href=#%e8%ae%be%e7%bd%ae%e6%8e%88%e6%9d%83 aria-label=设置授权>设置授权</a></li>
<li>
<a href=#%e5%ae%88%e6%8a%a4%e8%bf%9b%e7%a8%8b aria-label=守护进程>守护进程</a></li></ul>
</li>
<li>
<a href=#%e6%b5%8b%e8%af%95 aria-label=测试>测试</a></li>
<li>
<a href=#%e7%ae%a1%e7%90%86 aria-label=管理>管理</a><ul>
<li>
<a href=#virsh aria-label=virsh>virsh</a></li>
<li>
<a href=#%e5%ad%98%e5%82%a8%e6%b1%a0 aria-label=存储池>存储池</a></li>
<li>
<a href=#%e5%ad%98%e5%82%a8%e5%8d%b7 aria-label=存储卷>存储卷</a></li>
<li>
<a href=#%e5%9f%9f aria-label=域>域</a></li>
<li>
<a href=#%e7%bd%91%e7%bb%9c-2 aria-label=网络>网络</a></li></ul>
</li>
<li>
<a href=#uefi-%e6%94%af%e6%8c%81 aria-label="UEFI 支持">UEFI 支持</a></li>
<li>
<a href=#virt-manager-shared-folders-with-linux-guesthttpsntsstrzibnynamehow-to-set-up-shared-folders-in-virt-manager aria-label="virt-manager: Shared folders with Linux Guest">virt-manager: <a href=https://nts.strzibny.name/how-to-set-up-shared-folders-in-virt-manager/>Shared folders with Linux Guest</a></a></li>
<li>
<a href=#virt-manager-shared-folders-with-windows-guesthttpsaskubuntucoma1127273 aria-label="virt-manager: Shared folders with Windows Guest">virt-manager: <a href=https://askubuntu.com/a/1127273>Shared folders with Windows Guest</a></a></li>
<li>
<a href=#virt-manager-change-default-storage-pool-locationhttpsostechnixcomhow-to-change-kvm-libvirt-default-storage-pool-location aria-label="virt-manager: Change Default Storage Pool Location">virt-manager: <a href=https://ostechnix.com/how-to-change-kvm-libvirt-default-storage-pool-location/>Change Default Storage Pool Location</a></a></li></ul>
</li>
<li>
<a href=#qemu-kvm-win7httpswwwcnblogscomsammyliup5740129html aria-label="QEMU-KVM Win7"><a href=https://www.cnblogs.com/sammyliu/p/5740129.html>QEMU-KVM Win7</a></a><ul>
<li>
<a href=#%e7%8e%af%e5%a2%83%e5%87%86%e5%a4%87 aria-label=环境准备>环境准备</a></li>
<li>
<a href=#%e5%ae%89%e8%a3%85-win-7 aria-label="安装 Win 7">安装 Win 7</a></li>
<li>
<a href=#%e5%ae%89%e8%a3%85-virtio-%e7%bd%91%e7%bb%9c%e9%a9%b1%e5%8a%a8 aria-label="安装 Virtio 网络驱动">安装 Virtio 网络驱动</a></li>
<li>
<a href=#qemu-%e7%9a%84%e5%86%85%e7%bd%aesmb%e6%9c%8d%e5%8a%a1%e5%99%a8qemu-%e7%9a%84%e5%86%85%e7%bd%aesmb%e6%9c%8d%e5%8a%a1%e5%99%a8 aria-label="[QEMU 的内置SMB服务器](#QEMU 的内置SMB服务器)">[QEMU 的内置SMB服务器](#QEMU 的内置SMB服务器)</a></li>
<li>
<a href=#%e5%ae%bf%e4%b8%bb%e6%9c%ba%e7%9a%84usb%e8%ae%be%e5%a4%87%e4%bc%a0%e9%80%92%e8%87%b3%e8%99%9a%e6%8b%9f%e6%9c%ba%e5%ae%bf%e4%b8%bb%e6%9c%ba%e7%9a%84usb%e8%ae%be%e5%a4%87%e4%bc%a0%e9%80%92%e8%87%b3%e8%99%9a%e6%8b%9f%e6%9c%ba aria-label=宿主机的USB设备传递至虚拟机><a href=#%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%9A%84USB%E8%AE%BE%E5%A4%87%E4%BC%A0%E9%80%92%E8%87%B3%E8%99%9A%E6%8B%9F%E6%9C%BA>宿主机的USB设备传递至虚拟机</a></a></li>
<li>
<a href=#questions aria-label=Questions>Questions</a></li></ul>
</li>
<li>
<a href=#qemu-kvm-winxp-sp3 aria-label="QEMU-KVM WinXP SP3">QEMU-KVM WinXP SP3</a><ul>
<li>
<a href=#windows_xpshhttpsgistgithubcomandrusha1000766 aria-label=windows_xp.sh><a href=https://gist.github.com/andrusha/1000766>windows_xp.sh</a></a><ul>
<li>
<a href=#windows-xp-cannot-connect-to-samba-sharehttpsaskubuntucomquestions1268132windows-xp-cannot-connect-to-samba-share-linux-server-20-04 aria-label="Windows XP cannot connect to samba share"><a href=https://askubuntu.com/questions/1268132/windows-xp-cannot-connect-to-samba-share-linux-server-20-04>Windows XP cannot connect to samba share</a></a></li>
<li>
<a href=#windows-xp-%e4%b8%8a%e7%bd%91%e6%8f%90%e7%a4%ba%e6%82%a8%e7%9a%84%e6%97%b6%e9%92%9f%e5%bf%ab%e4%ba%86%e6%85%a2%e4%ba%86httpsblogcsdnnetjohnnysun2015articledetails104888159 aria-label="Windows XP 上网提示：您的时钟快了/慢了"><a href=https://blog.csdn.net/JohnnySun2015/article/details/104888159>Windows XP 上网提示：您的时钟快了/慢了</a></a></li></ul>
</li>
<li>
<a href=#virtual-machine-manager aria-label="Virtual Machine Manager">Virtual Machine Manager</a></li></ul>
</li>
<li>
<a href=#qemu-kvm-gentoohttpswikigentooorgwikiqemulinux_guest aria-label="QEMU-KVM Gentoo"><a href=https://wiki.gentoo.org/wiki/QEMU/Linux_guest>QEMU-KVM Gentoo</a></a><ul>
<li>
<a href=#configuration aria-label=Configuration>Configuration</a><ul>
<li>
<a href=#host aria-label=Host>Host</a></li>
<li>
<a href=#using-uefi-with-qemuhttpsfedoraprojectorgwikiusing_uefi_with_qemu aria-label="Using UEFI with QEMU"><a href=https://fedoraproject.org/wiki/Using_UEFI_with_QEMU>Using UEFI with QEMU</a></a></li></ul>
</li></ul>
</li>
<li>
<a href=#virtualbox aria-label=VirtualBox>VirtualBox</a><ul>
<li>
<a href=#%e5%a2%9e%e5%8a%a0%e7%8e%b0%e6%9c%89%e8%99%9a%e6%8b%9f%e6%9c%ba%e7%9a%84%e7%a3%81%e7%9b%98%e5%a4%a7%e5%b0%8fhttpslinuxcnarticle-12869-1html aria-label=增加现有虚拟机的磁盘大小><a href=https://linux.cn/article-12869-1.html>增加现有虚拟机的磁盘大小</a></a></li>
<li>
<a href=#seamless-modehttpswwwtl80cnarticle43389 aria-label="Seamless Mode"><a href=https://www.tl80.cn/article/43389>Seamless Mode</a></a></li>
<li>
<a href=#vboxwinxp-sp3 aria-label="VBox+WinXP SP3">VBox+WinXP SP3</a></li>
<li>
<a href=#vs-vmwarehttpswwwzhihucomquestion33701295 aria-label="VS VMWare"><a href=https://www.zhihu.com/question/33701295>VS VMWare</a></a></li>
<li>
<a href=#%e8%99%9a%e6%8b%9f%e6%9c%ba%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%bc%8fhttpswwwcnblogscomggjuchengarchive201208192646007html aria-label=虚拟机网络模式><a href=https://www.cnblogs.com/ggjucheng/archive/2012/08/19/2646007.html>虚拟机网络模式</a></a></li></ul>
</li>
<li>
<a href=#vmware aria-label=VMware>VMware</a><ul>
<li>
<a href=#%e5%8f%8d%e8%99%9a%e6%8b%9f%e6%9c%ba%e6%a3%80%e6%b5%8bhttpsvircloudnetexpanti-vm-detectionhtml aria-label=反虚拟机检测><a href=https://vircloud.net/exp/anti-vm-detection.html>反虚拟机检测</a></a><ul>
<li>
<a href=#%e6%8e%a2%e6%b5%8b%e6%96%b9%e5%90%91 aria-label=探测方向>探测方向</a></li>
<li>
<a href=#%e5%8f%8d%e6%8e%a2%e6%b5%8b aria-label=反探测>反探测</a></li></ul>
</li>
<li>
<a href=#questions-1 aria-label=Questions>Questions</a></li></ul>
</li>
<li>
<a href=#others aria-label=Others>Others</a><ul>
<li>
<a href=#%e9%80%9a%e8%bf%87-qemu-%e5%ae%89%e8%a3%85-windows-%e5%88%b0%e7%a1%ac%e7%9b%98 aria-label="通过 Qemu 安装 Windows 到硬盘">通过 Qemu 安装 Windows 到硬盘</a></li>
<li>
<a href=#boot-a-physical-windows-partition-with-qemuhttpssuperusercoma1204834 aria-label="Boot a physical Windows partition with qemu"><a href=https://superuser.com/a/1204834>Boot a physical Windows partition with qemu</a></a></li>
<li>
<a href=#looking-glasshttpslooking-glassiodocs aria-label="Looking Glass"><a href=https://looking-glass.io/docs>Looking Glass</a></a></li>
<li>
<a href=#xrdphttpsgithubcomneutrinolabsxrdp aria-label=xrdp><a href=https://github.com/neutrinolabs/xrdp>xrdp</a></a></li>
<li>
<a href=#qemukvm-vs-virtualbox aria-label="QEMU/KVM VS Virtualbox">QEMU/KVM VS Virtualbox</a></li>
<li>
<a href=#android-x86httpslinuxcnarticle-11711-1html aria-label=Android-x86><a href=https://linux.cn/article-11711-1.html>Android-x86</a></a></li>
<li>
<a href=#waydroidhttpswaydroid aria-label=Waydroid><a href=https://waydro.id/>Waydroid</a></a></li>
<li>
<a href=#genymotionhttpswwwgenymotioncom aria-label=Genymotion><a href=https://www.genymotion.com/>Genymotion</a></a></li>
<li>
<a href=#libvfiohttpsarccomputecombloglibvfio-commodity-gpu-multiplexing aria-label=LibVF.IO><a href=https://arccompute.com/blog/libvfio-commodity-gpu-multiplexing/>LibVF.IO</a></a></li>
<li>
<a href=#osx-kvmhttpsgithubcomkholiaosx-kvm aria-label=OSX-KVM><a href=https://github.com/kholia/OSX-KVM>OSX-KVM</a></a></li>
<li>
<a href=#quickemuhttpsgithubcomquickemu-projectquickemu aria-label=quickemu><a href=https://github.com/quickemu-project/quickemu>quickemu</a></a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><h2 id=winehttpswikiarchlinuxorgtitlewine_e7ae80e4bd93e4b8ade69687><a href=https://wiki.archlinux.org/title/Wine_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)>Wine</a><a hidden class=anchor aria-hidden=true href=#winehttpswikiarchlinuxorgtitlewine_e7ae80e4bd93e4b8ade69687>#</a></h2>
<h3 id=简介httpszhmwikipediaorgwikiwine><a href=https://zh.m.wikipedia.org/wiki/Wine>简介</a><a hidden class=anchor aria-hidden=true href=#简介httpszhmwikipediaorgwikiwine>#</a></h3>
<p><a href=http://winehq.org/>Wine</a> 是在x86、x86-64容许类Unix操作系统在X Window System运行Microsoft Windows程序的软件。另外，Wine也提供程序运行库（Winelib）来帮助计算机程序设计师将Windows程序移植到类Unix系统；也有不少软件经过Wine测试后发布，比如Picasa、uTorrent、MediaCoder。</p>
<p>Wine通过提供一个兼容层来将Windows的系统调用转换成与POSIX标准的系统调用。它还提供了Windows系统运行库的替代品和一些系统组件的替代品。为了避免著作权问题，Wine主要使用黑箱测试逆向工程来编写。</p>
<p>Wine最早是“Windows Emulator”，即Windows模拟器的缩写，但Wine现在为“Wine Is Not an Emulator”的递归缩写，即Wine不是模拟器。Wine的正确名称是“Wine”，而不是全大写或全小写。</p>
<p>Wine计划在1993年由Bob Amstadt及Eric Youngdale发起，最初目的是为了让16位Windows 3.1程序可以在Linux上执行，但随着电脑和时代的演进，Wine也一路支持到更新的Windows和64位的计算机体系结构。</p>
<p>由于Windows的DLL为封闭源代码，所以程序员只能由最底层的设计开始，耗费大量的时间来编写和测试，最后达至兼容，这过程是困难且缓慢的。</p>
<p>在1999年期间，当Corel加入这个计划后，Wine很快便能兼容WordPerfect Office，但Corel不久便停止支持这项计划，所以Wine的发展又逐渐趋缓，一直到2006年Google积极参与这个计划后，Wine的发展才又恢复起色，最后终于在2008年发布首个稳定版，其后便以每两周发布一个新版的速度发展着，除此之外，Google每年所举办的夏日代码大赛活动也对Wine有着不少贡献。</p>
<p>Wine虽然是从Linux开始发展，但现在已经支持多种平台，有BSD、Mac OS X与Solaris-x86，在2013年的自由及开源软件开发者欧洲会议上，Wine的项目领导人Alexandre Julliard（英语：Alexandre Julliard）表示目前将积极支持Android平台。</p>
<p>在2008年，Wine已经能够完美运行很多知名程序，例如Lotus Notes及Microsoft Office 2007，Photoshop CS2，但其可靠性及稳定性仍有待改善。<strong>如果该程序包含本地的微软Windows系统的库，那样Wine便可很顺利运行该程序。</strong></p>
<p>有些Wine DLLs亦已能完美地取代Windows原来的DLLs，使得有些程序可完美运行。</p>
<p>最晚到2006年，Wine上面已经可以完全基于Wine DLL完美地运行暴雪发行的多款3D游戏了，如魔兽世界、魔兽争霸等。</p>
<p><strong>注</strong>：以下如果使用zsh，<code>~</code> 应替换为 <code>$HOME</code>才能正常使用</p>
<h3 id=安装httpswikiwinehqorgubuntu><a href=https://wiki.winehq.org/Ubuntu>安装</a><a hidden class=anchor aria-hidden=true href=#安装httpswikiwinehqorgubuntu>#</a></h3>
<p><a href=https://askubuntu.com/a/956217>Here the difference between the packages</a>:</p>
<ul>
<li><strong>winehq-staging</strong>: this is the most recent testing wine version.</li>
<li><strong>winehq-stable</strong>: this is the current stable wine version (probably the one you should install)</li>
<li><strong>winehq-devel</strong>: this package is used to provide development headers, mostly used by third party software compilation.</li>
<li><strong>wine-development</strong>: unsure for this one, but probably helps wine developers to debug EXE running with wine with more debug information.</li>
</ul>
<p><strong>使用 <a href=https://mirrors.tuna.tsinghua.edu.cn/help/wine-builds/>wine 的 tuna mirror</a> 安装最新版本</strong></p>
<p>如果您之前安装过来自其他仓库的 Wine 安装包，请在尝试安装 WineHQ 安装包之前删除它及依赖它的所有安装包（如：wine-mono、wine-gecko、winetricks），否则可能导致依赖冲突。</p>
<p>如果您使用的是 64 位系统，请<a href=https://www.unixmen.com/enable-32-bit-support-64-bit-ubuntu-13-10-greater/>开启 32 bit 架构支持</a>（如果您之前没有开启的话）：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># Verifying you have 64-bit kernel architecture.</span>
$ dpkg --print-architecture
<span style=color:#75715e># Verifying you have multi-arch support enabled. </span>
$ dpkg --print-foreign-architectures
<span style=color:#75715e># Enabling multi-arch support.</span>
$ sudo dpkg --add-architecture i386 
$ sudo apt update
</code></pre></div><p>下载添加仓库密钥：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sudo wget -nc -O /usr/share/keyrings/winehq-archive.key https://dl.winehq.org/wine-builds/winehq.key
</code></pre></div><p>并添加 Ubuntu 22.04 仓库：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sudo vim /etc/apt/sources.list.d/winehq.list
deb <span style=color:#f92672>[</span>arch<span style=color:#f92672>=</span>amd64,i386 signed-by<span style=color:#f92672>=</span>/usr/share/keyrings/winehq-archive.key<span style=color:#f92672>]</span> https://mirrors.tuna.tsinghua.edu.cn/wine-builds/ubuntu/ jammy main
</code></pre></div><p>安装：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sudo apt update
$ sudo apt install --install-recommends winehq-stable
</code></pre></div><h3 id=配置>配置<a hidden class=anchor aria-hidden=true href=#配置>#</a></h3>
<p>配置Wine的方式通常有：</p>
<ul>
<li><a href=https://wiki.winehq.org/winecfg>winecfg</a>是Wine的图形界面配置程序。控制台下调用<code>$ winecfg</code>（或指定系统目录：<code>$ WINEPREFIX=~/.系统目录 winecfg</code>）即可启动</li>
<li><a href=https://wiki.winehq.org/control>control.exe</a>是Windows控制面板的Wine实现，通过<code>$ wine control</code>命令启动</li>
<li><a href=https://wiki.winehq.org/regedit>regedit</a>是Wine的注册表编辑器，比较前两者，该工具能配置更多东西。部分常用键值参见：<a href=https://wiki.winehq.org/UsefulRegistryKeys>WineHQ&rsquo;s article on Useful Registry Keys</a></li>
</ul>
<h4 id=初始设置httpswikiubuntuorgcnubuntuhelpwinezh><a href=https://wiki.ubuntu.org.cn/UbuntuHelp:Wine/zh>初始设置</a><a hidden class=anchor aria-hidden=true href=#初始设置httpswikiubuntuorgcnubuntuhelpwinezh>#</a></h4>
<p>通过全局菜单，应用程序 - >附件 - >终端 ，输入命令： <code>winecfg</code> 这将在你的家目录中创建一个隐藏文件夹（.wine），其中包含类似于在Windows中的虚拟C：驱动器以及注册表文件。一旦该目录中创建完，wine配置窗口将出现。该窗口将允许您定制wine的各种设置，其中包括Windows版本，DLL替换，显示设置，驱动器映射，以及应用程序的特定设置。单击OK按钮关闭该窗口。</p>
<h4 id=wineprefix>WINEPREFIX<a hidden class=anchor aria-hidden=true href=#wineprefix>#</a></h4>
<p>Wine默认将配置文件和安装的Windows程序保存在<code>~/.wine</code>。这样的目录称为一个"Wine prefix"或"Wine bottle"（下文称“系统目录”）。每次运行Windows程序（包括内置程序，如<code>winecfg</code>）时，系统目录会自动创建（如果缺失）或更新。系统目录中存放有文件夹 <code>~/.wine/drive_c</code> 相当于Windows下<code>C:\</code>C盘（更确切的说应是系统盘）。</p>
<p>通过设置<code>WINEPREFIX</code>环境变量，可以更改Wine系统目录的位置。如果希望让不同的Windows程序使用不同的系统环境或配置，这一变量会非常有用。建议把你安装的不同的Windows程序分给不同的WINEPREFIX，便于打包和隔离。当你要启动这个Windows程序前也记得要设置WINEPREFIX。</p>
<p>例如，如果您使用 <code>$ env WINEPREFIX=~/.win-a wine-A程序.exe</code>参数来运行一个程序。另一个使用 <code>$ env WINEPREFIX=~/.win-b wine-B程序.exe</code>参数，这两个程序将使用独立的C盘和注册表配置。</p>
<p>以下命令会建立一个默认的系统目录，且不启动任何Windows程序：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ env WINEPREFIX<span style=color:#f92672>=</span>~/.customprefix wineboot -u
</code></pre></div><h4 id=winearch>WINEARCH<a hidden class=anchor aria-hidden=true href=#winearch>#</a></h4>
<p>这个WINEARCH 决定了你模拟的Windows是32位或是64位的x86。对应的值为win32及win64，如果你的Unix系统是64位的它就默认是win64。</p>
<p>发行版所提供的wine一般都有32位及64位两个包，直接对应所模拟的Windows位数，包里面的Unix二进制及运行库也都是对应位数。</p>
<p>对于64位用户，默认创建的系统目录是64位环境的。若想使用纯32位环境，修改<code>WINEARCH</code> 变量win32为即可： <code>$ WINEARCH=win32 winecfg</code>这样就会生成32位Wine环境。若不设置<code>WINEARCH</code>得到的就是64位环境。</p>
<p>通过<code>WINEPREFIX</code>变量，在不同的系统目录分别创建32位和64位环境：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ WINEARCH<span style=color:#f92672>=</span>win32 WINEPREFIX<span style=color:#f92672>=</span>~/win32 winecfg
$ WINEPREFIX<span style=color:#f92672>=</span>~/win64 winecfg
</code></pre></div><p><strong>注意：</strong> 系统目录创建过程中，64位版本的wine将视全部目录如同64位系统目录，也将不会在已存在的目录中创建任何32位的。创建32位系统目录，您必须让Wine创建指定的<code>WINEPREFIX</code>目录。</p>
<p>winetricks也接受<code>WINEPREFIX</code>变量，以安装Steam为例：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ WINEARCH<span style=color:#f92672>=</span>win32 WINEPREFIX<span style=color:#f92672>=</span>~/.local/share/wineprefixes/steam winetricks steam
</code></pre></div><p>编辑 <code>~/.bashrc</code>，使得 WINEPREFIX 和 WINEARCH 永久生效</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>export WINEPREFIX<span style=color:#f92672>=</span>$HOME/.config/wine/
export WINEARCH<span style=color:#f92672>=</span>win32
</code></pre></div><h4 id=图形驱动>图形驱动<a hidden class=anchor aria-hidden=true href=#图形驱动>#</a></h4>
<p>你需要安装32位的显卡驱动。缺少或未能正确配置驱动的一个标志是 Wine 在终端窗口里报告如下内容：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>Direct rendering is disabled, most likely your OpenGL drivers have not been installed correctly
</code></pre></div><p><strong>注意：</strong> 在安装对应的库以后，你可能需要重启 X</p>
<h4 id=声音>声音<a hidden class=anchor aria-hidden=true href=#声音>#</a></h4>
<p>Wine程序有可能遇到某些声音问题。首先，确保<code>winecfg</code>中只启用了一种声卡驱动。目前，Wine对<a href=https://wiki.archlinux.org/title/Alsa_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)>Alsa</a>的支持最好。</p>
<p><strong>MIDI 支持</strong></p>
<p><a href=https://wiki.archlinux.org/title/MIDI>MIDI</a> 是九十年代非常流行的游戏声音系统。如果你尝试运行老一点的游戏，音乐无法开箱即用的情况并不罕见。 Wine 拥有非常优秀的 MIDI 支持。但是首先你需要确保 Wine 会使用正确的 MIDI 输出。详细设置参考 <a href=https://wiki.winehq.org/MIDI>Wine Wiki</a></p>
<h4 id=中文字体httplinux-wikicnwikizh-hanswinee79a84e4b8ade69687e698bee7a4bae4b88ee5ad97e4bd93e8aebee7bdae><a href=http://linux-wiki.cn/wiki/zh-hans/Wine%E7%9A%84%E4%B8%AD%E6%96%87%E6%98%BE%E7%A4%BA%E4%B8%8E%E5%AD%97%E4%BD%93%E8%AE%BE%E7%BD%AE>中文字体</a><a hidden class=anchor aria-hidden=true href=#中文字体httplinux-wikicnwikizh-hanswinee79a84e4b8ade69687e698bee7a4bae4b88ee5ad97e4bd93e8aebee7bdae>#</a></h4>
<p>注意字无法显示和显示为乱码是不同的症状，如果看到乱码，请确保系统语言和运行Wine时的语言环境一致。如果有汉字丢失或显示为方框，请继续字无法显示。</p>
<p><strong>显示为乱码</strong></p>
<p>如果安装的系统LANG不为zh-CN，那么wine运行程序的默认语种也不会是中文，这可能导致一部分乱码。解决这个问题，用如下命令运行程序：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ env LANG<span style=color:#f92672>=</span>zh_CN.UTF-8 wine example.exe
</code></pre></div><p><strong>字无法显示</strong></p>
<p>将中文字体copy到对应wine的目录下的<code>drive_c/windows/Fonts/</code>。</p>
<p>在wine目录下任意位置添加<code>modify_font.reg</code>文件：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=color:#a6e22e>REGEDIT4</span>

<span style=color:#66d9ef>[HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\FontLink\SystemLink]</span>
<span style=color:#a6e22e>&#34;Lucida Sans Unicode&#34;</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;msyh.ttc&#34;</span>
<span style=color:#a6e22e>&#34;Microsoft Sans Serif&#34;</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;msyh.ttc&#34;</span>
<span style=color:#a6e22e>&#34;MS Sans Serif&#34;</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;msyh.ttc&#34;</span>
<span style=color:#a6e22e>&#34;Tahoma&#34;</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;msyh.ttc&#34;</span>
<span style=color:#a6e22e>&#34;Tahoma Bold&#34;</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;msyh.ttc&#34;</span>
<span style=color:#a6e22e>&#34;msyh&#34;</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;msyh.ttc&#34;</span>
<span style=color:#a6e22e>&#34;Arial&#34;</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;msyh.ttc&#34;</span>
<span style=color:#a6e22e>&#34;Arial Black&#34;</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;msyh.ttc&#34;</span>
</code></pre></div><p>将<code>msyh.ttc</code>改成自己想改的中文字体。</p>
<p>在wine命令提示符运行：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ regedit modify_font.reg
</code></pre></div><h4 id=启动器和菜单>启动器和菜单<a hidden class=anchor aria-hidden=true href=#启动器和菜单>#</a></h4>
<p>Wine不会为内置程序（如<code>winecfg</code>、<code>winebrowser</code>）创建桌面启动器和菜单项。但手动安装的Windows程序通常会自动创建启动器和菜单项。在Windows下，安装程序（如<code>setup.exe</code>）通常会在桌面和开始菜单建立快捷方式，而Wine下会创建遵循freedesktop.org规范的.desktop文件（即启动器，相当于快捷方式）。</p>
<p><strong>提示：</strong> 如果启动器<em>没有</em>自动创建，或者这些文件丢失了，可以尝试使用<a href=https://wiki.winehq.org/winemenubuilder>winemenubuilder</a>修复。</p>
<p><strong>Gnome3 中清理 Wine 菜单启动项</strong></p>
<p>系统全局的菜单启动器安装在 <code>/usr/share/applications/</code>，清除相应程序的“.desktop”文件即可从整个系统删除该启动器。</p>
<p>如果这样还是无法解决问题，那么很可能 Wine 的启动器存放在用户级别的 <code>~/.local/share/applications/wine/Programs/</code> 目录中。删除相应的“.desktop”文件即可清理对应启动项。删除整个 Programs 文件夹将清理所有 Wine 程序的启动项。</p>
<h3 id=安装运行卸载-windows-程序>安装/运行/卸载 Windows 程序<a hidden class=anchor aria-hidden=true href=#安装运行卸载-windows-程序>#</a></h3>
<p><strong>警告：</strong> 千万不要以root身份运行Wine！详情参见<a href=https://wiki.winehq.org/FAQ#Should_I_run_Wine_as_root.3F>本文</a>。</p>
<p>使用wine安装应用程序，可以按照以下步骤：</p>
<ol>
<li>从某个地址下载Windows应用程序.exe（可执行文件）.</li>
<li>把它放在一个方便的目录（例如，桌面或个人文件夹）</li>
<li>打开终端，并且切换到.exe文件所在的目录。</li>
<li>输入命令 <code>wine application-name.exe</code> 。</li>
</ol>
<p>这将使用Wine启动.EXE。如果它是一个安装程序，它应该像在windows一样的运行。如果应用程序要求目录来安装应用程序，选择把它放在 C:\Program Files 。</p>
<p>运行Windows程序格式为 <code>WINEPREFIX="wine配置文件存放地" wine [路径]程序.exe 参数</code> ，如：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ wine notepad.exe c:/abc.txt
$ wine notepad.exe ~/.wine/drive_c/abc.txt
</code></pre></div><p>路径可以是Unix路径，也可以是（在有WINEPREFIX情况下的）Windows路径，wine会自动判断。</p>
<p>对wine来说，你Unix系统里的其他文件（即模拟的C盘之外的文件）的Windows路径都以Z盘开头：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ wine notepad.exe z:/home/username/.wine/drive_c/abc.txt
</code></pre></div><p>内置的msiexec程序可以运行MSI安装包：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ <span style=color:#f92672>[</span>wine<span style=color:#f92672>]</span> msiexec /i path_to_msi
</code></pre></div><p>还可以通过在终端运行 winefile 使用 Wine 文件浏览器。</p>
<p>在某些情况下，应用程序需要被从一个特定位置上运行。在这种情况下创建命令启动</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sh -c <span style=color:#e6db74>&#34;cd /home/USER/.wine/drive_c/Program Files/APPDIR; wine game.exe&#34;</span>
</code></pre></div><p><code>wine uninstaller</code> 这将打开一个类似于Windows的程序“添加/删除程序”控制面板，让您卸载wine安装的应用程序。通过 wine 直接运行卸载程序也应该正常工作。或者，您也可以简单地删除应用程序的文件夹。</p>
<h3 id=技巧>技巧<a hidden class=anchor aria-hidden=true href=#技巧>#</a></h3>
<p><strong>提示：</strong> 此外您可能会感兴趣以下文章的开始所提供的链接</p>
<ul>
<li><a href=https://appdb.winehq.org/>Wine程序数据库 (Wine Application Database, AppDB)</a> —— 特定Windows程序的Wine兼容情况（运行时的已知问题、用户评分、指南等等），Rating一列由运行结果好到坏为Platinum、Gold、Silver、Bronze、Garbage，无近期结果或近期仍然Silver以下的就放弃吧。</li>
<li><a href=https://forum.winehq.org/>WineHQ论坛</a> —— 要是看完上述网页还有问题，可以到这里咨询</li>
</ul>
<h4 id=opengl-模式>OpenGL 模式<a hidden class=anchor aria-hidden=true href=#opengl-模式>#</a></h4>
<p>很多游戏（比如魔兽争霸啦）都支持OpenGL模式，在Wine下<em>可能</em>比默认DirectX模式性能更好。一般添加<code>-opengl</code>启动程序即可，但<em>不同程序可能有所不同</em>：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ wine /path/to/3d_game.exe -opengl
</code></pre></div><p>请参考<a href=https://appdb.winehq.org/>AppDB</a>，了解特定程序的相关信息。</p>
<h4 id=wine-控制台>Wine 控制台<a hidden class=anchor aria-hidden=true href=#wine-控制台>#</a></h4>
<p>有些时候，可能需要运行<code>.exe</code>给游戏打补丁，比如给古董游戏添加宽屏支持。这时直接通过Wine运行可能没有用。那么，打开终端，运行一下命令：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ wineconsole cmd
</code></pre></div><p>将进入一个和Windows下cmd一样的命令行环境。在该环境下试试也许就可以了。</p>
<h4 id=winetrickshttpswikiwinehqorgwinetricks><a href=https://wiki.winehq.org/Winetricks>winetricks</a><a hidden class=anchor aria-hidden=true href=#winetrickshttpswikiwinehqorgwinetricks>#</a></h4>
<p>使用<a href=https://github.com/Winetricks/winetricks>Winetricks</a>快速脚本，能够方便地安装许多Windows组件，包括DirectX、msxml（被Office 2007、IE浏览器依赖）visual运行库还有其他更多的。</p>
<p><strong>使用 Ubuntu 仓库版本</strong></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sudo apt install winetricks
</code></pre></div><p><strong>使用 Github 安装最新版本</strong></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ cd <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>HOME<span style=color:#e6db74>}</span><span style=color:#e6db74>/.local/bin&#34;</span>
$ wget  https://raw.githubusercontent.com/Winetricks/winetricks/master/src/winetricks
$ chmod u+x winetricks
</code></pre></div><p>可以用<code>winetricks list-all</code>来看看它支持什么，也可以从该脚本中搜索下载链接 <code>load_packagename</code></p>
<p><strong>Using winetricks</strong></p>
<p>获得 winetricks 后，您只需在控制台输入<code>sh winetricks</code>即可运行它。如果你先<code>chmod +x winetricks</code> ，你也可以使用<code>./winetricks</code>。如果不带参数运行，winetricks 会显示一个带有可用包列表的 GUI。如果您知道要安装的软件包的名称，可以将它们附加到 winetricks 命令，它将立即开始安装过程。例如，</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sh winetricks corefonts vcrun6 
</code></pre></div><p>将安装 corefonts 和 vcrun6 软件包。</p>
<p>所有 Wine 命令一样，winetricks 知道 <code>WINEPREFIX</code> 环境变量。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ env WINEPREFIX<span style=color:#f92672>=</span>~/.winetest sh winetricks mfc40 
</code></pre></div><p>拥有多个 Wine 版本的用户可以指定 winetricks 应该使用哪个版本</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ env WINE<span style=color:#f92672>=</span>~/wine-git/wine sh winetricks mfc40 
</code></pre></div><p>使用 <code>~/wine-git</code> 目录中的 Wine 安装 mfc40 包。</p>
<h4 id=monohttpswikiwinehqorgmono--geckohttpswikiwinehqorggecko><a href=https://wiki.winehq.org/Mono>Mono</a> & <a href=https://wiki.winehq.org/Gecko>Gecko</a><a hidden class=anchor aria-hidden=true href=#monohttpswikiwinehqorgmono--geckohttpswikiwinehqorggecko>#</a></h4>
<p>Mono 是 .NET Framework 的开源和跨平台实现。Wine 可以使用 Windows 构建的 Mono 来运行 .NET 应用程序。</p>
<p>Wine 实现了自己的 Internet Explorer 版本。该实现基于<a href=http://en.wikipedia.org/wiki/Gecko_(layout_engine)>Mozilla 的 Gecko Layout Engine</a>的自定义版本。</p>
<p>在 <a href=http://mirrors.ustc.edu.cn/wine/wine/>USTC MIRROR</a> 分别下载对应的版本，放入<code>~/.cache/wine</code>就可以了，比如 <code>wine 7.0.1</code> 用 <code>wine-mono-7.0.0-x86.msi</code>。</p>
<h3 id=crossoverhttpswwwcodeweaverscom><a href=https://www.codeweavers.com>CrossOver</a><a hidden class=anchor aria-hidden=true href=#crossoverhttpswwwcodeweaverscom>#</a></h3>
<p>CrossOver是Wine的付费、商业化版本，提供更全面的终端用户支持。它包括脚本、补丁、GUI和可能永远不会被Wine项目接受的第三方软件。这种组合使得那些不太懂技术的人运行Windows程序变得相当容易。</p>
<p>首先在 <a href=https://www.codeweavers.com/crossover/download>CrossOver</a> 下载 .bin 安装包，然后要把 .bin 文件设置成可执行的：<code>chmod u+x crossover.bin</code>，接下来运行该文件：<code>./crossover.bin</code>。</p>
<p><strong><a href=https://www.tspweb.com/key/crossover%E6%97%A0%E9%99%90%E8%AF%95%E7%94%A8.html>无限试用</a></strong></p>
<p>crossover 有15天的试用期，crossover的时间验证信息写在每一个winebottle容器中，相互是完全隔离（不是写在全局配置中）。即使一个容器过期了，依然可以创建新的容器，并重新计算试用期，所以不需要重装软件本身。</p>
<p>即使重装程序，已经过期的容器依旧不能用，不过可以删除该容器，或者删除容器下的.eval文件。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>/usr/bin/rm ~/.cxoffice/**/.eval
</code></pre></div><h4 id=tutorialshttpswwwcodeweaverscomsupportwikilinuxlinuxtutorial><a href=https://www.codeweavers.com/support/wiki/linux/linuxtutorial>Tutorials</a><a hidden class=anchor aria-hidden=true href=#tutorialshttpswwwcodeweaverscomsupportwikilinuxlinuxtutorial>#</a></h4>
<p>相对于 wine 而言，CrossOver 更加简洁方便，全程使用 GUI。</p>
<p>在 Select Application 的时候，即使列表中没有列出你需要安装的 Windows 软件，依旧可以尝试使用默认的 Unlisted application，如一些 roguelike、galgame 游戏是可以直接运行的。</p>
<p>如果无法运行：</p>
<ul>
<li>确保已安装破解补丁。有的破解组安装程序不会自动或者提供选择框来安装，需要手动覆盖。</li>
<li>如果报错缺少dll，这时就在网上查找一下，比如 <a href=https://techdot.tech/how-to-fix/wine-runtime-error-cannot-import-dll-isskin-dll/>sskin.dll</a>，如果教程使用的 winetricks，则可以在 <a href=https://github.com/Winetricks/winetricks/blob/master/files/verbs/all.txt>winetricks/files/verbs/all.txt</a> 找到具体的依赖名称，如 Visual C++ 6 SP4 libraries，然后可以在 Select Application 输入依赖名来安装，如果下载慢，也可以通过软件显示的下载链接直接下载。</li>
<li>如果什么错也没报，那么就需要参考 <a href=https://www.codeweavers.com/support/wiki/linux/linuxtutorial/unsupported_deps>Unsupported Troubleshooting</a> 安装依赖或配置 winecfg，确保在安装游戏的时候没有选择升级依赖（比如 DirectX ）并且之后安装了必要的依赖项。推荐游戏自带的 <strong>CommonRedist</strong> 或在 <a href="https://appdb.winehq.org/objectManager.php?sClass=application&sTitle=Browse%20Applications&sOrderBy=appName&bAscending=true">WineHQ - Browse Applications</a>、<a href=https://www.playonlinux.com/en/supported_apps-1-0.html>PlayOnLinux</a>、<a href=https://www.pcgamingwiki.com/wiki/Home>PCGamingWiki</a> 上找依赖，可以但不推荐在虚拟机中运行一下看报错。</li>
<li>如果先是正常运行，之后 wine 报错 page fault 退出，那么可以参考 <a href=https://www.codeweavers.com/support/wiki/linux/linuxtutorial/debug>Gathering debug logs in Crossover Linux</a> 创建 crash log。</li>
</ul>
<p>凡是依赖解决了，游戏一般是能够运行了，但是运行的好不好，有没有bug就不敢保证了，比如 Skul - The Hero Slayer 是可以直接运行的，但是无法正常显示血量，即使重新安装依赖也是如此。</p>
<p>以下测试的是运行游戏所必须的依赖：</p>
<ul>
<li>
<p>Sekiro Shadows Die Twice</p>
<ul>
<li>Microsoft Visual C++ 6.0 (4.2 & 6.0) Redistributable</li>
</ul>
</li>
<li>
<p>The Elder Scrolls V Skyrim Special Edition</p>
<ul>
<li>DirectX for Modern Games</li>
<li>使用 SkyrimSELauncher.exe 配置，使用 SkyrimSE.exe 启动</li>
</ul>
</li>
<li>
<p>Life is Strange - Before the Storm</p>
<ul>
<li>先安装下面两个依赖，如果 FitGirl 报 <a href=https://www.reddit.com/r/CrackSupport/comments/ggamia/getting_unarcdll_returned_an_error_code_6_on/>Getting unarc.dll returned an error code -6</a>，就 try using the set memory limit to 2 gb option；如果是 Miss files，那么就重装。</li>
<li>Microsoft Visual C++ 6.0 (4.2 & 6.0) Redistributable</li>
<li>DirectX for Modern Games</li>
<li>游戏需要加载一会儿，这个时候屏幕没反应。</li>
</ul>
</li>
<li>
<p>NieR - Automata</p>
<ul>
<li>DirectX for Modern Games</li>
<li>如果 <a href="https://www.codeweavers.com/support/forums/general/?t=27;forumc__=;forumthreadcurPos=0;forumcurPos=0;msg=244698">unable to input name for profile creation</a>，可以尝试将 CrossOver 升级到最新版本。</li>
</ul>
</li>
<li>
<p>Dead Cells</p>
<ul>
<li>参考 [playonlinux/dead cells](playonlinux/dead cells) 的 SourceCode 安装依赖后能够运行</li>
<li>DirectX for Modern Games</li>
<li>OpenAL，安装后要在 Wine Configuration > Libraries 中添加 openal32（不加，点击无反应、闪退）（Libraries 中是运行时自动加载进来的库，而需要的 openal32 没有自动加载进来，因此手动添加）</li>
<li>Microsoft Visual C++ 6.0 (4.2 & 6.0) Redistributable</li>
</ul>
</li>
<li>
<p>The Binding of Isaac Rebirth Repentance</p>
<ul>
<li>要在 Wine Configuration > Libraries 中添加 openal32（不加，点击无反应、闪退）</li>
<li><a href="https://steamcommunity.com/sharedfiles/filedetails/?id=1581384665">《以撒的結合：重生》給新玩家的基本攻略</a></li>
</ul>
</li>
<li>
<p>Valiant Hearts The Great War</p>
<ul>
<li>Copy over the cracked content from the /Crack directory on the image to your game install directory manually.</li>
</ul>
</li>
<li>
<p>DARK SOULS REMASTERED</p>
<ul>
<li>更改语言：In the game installation folder find the &ldquo;steam_emu.ini&rdquo;, open it and find the line with language, change it to schinese.（在 font 目录可以找到所有语言）</li>
</ul>
</li>
<li>
<p>Braid</p>
<ul>
<li>DirectX for Modern Games</li>
</ul>
</li>
<li>
<p>Dying Light Platinum Edition</p>
<ul>
<li>Microsoft Visual C++ 6.0 (4.2 & 6.0) Redistributable</li>
</ul>
</li>
<li>
<p>Hearth Stone</p>
<ul>
<li>DXVK</li>
</ul>
</li>
<li>
<p>Undertale</p>
<ul>
<li><a href="https://steamcommunity.com/sharedfiles/filedetails/?id=2744710027">Undertale最新版简体中文汉化指南</a></li>
</ul>
</li>
<li>
<p>Warm Snow</p>
<ul>
<li>DirectX for Modern Games</li>
</ul>
</li>
</ul>
<h4 id=dxvkhttpswwwcodeweaverscomsupportwikilinuxlinuxtutorialdxvk><a href=https://www.codeweavers.com/support/wiki/linux/linuxtutorial/dxvk>DXVK</a><a hidden class=anchor aria-hidden=true href=#dxvkhttpswwwcodeweaverscomsupportwikilinuxlinuxtutorialdxvk>#</a></h4>
<p>DXVK provides a Vulkan-based translation layer for DXGI, D3D10 and D3D11, which can be used on Linux with Wine.</p>
<p>游戏使用 Vulkan 将获取更好的性能，为使用 Vulkan，需启用 <a href=https://github.com/doitsujin/dxvk>DXVK</a>。</p>
<p>打开 System Information，如果在属性下找到了 <strong>&ldquo;vulkan.present&rdquo;=&ldquo;yes&rdquo;</strong>，则表示支持 vulkan 并可以安装 DXVK。</p>
<ul>
<li>
<p>使用 CrossOver 安装：</p>
<p>像安装普通软件那样，在 Select an Application to install 搜索并选择 DXVK (Upstream) 安装——DXVK (Builtin) 可能会导致游戏无法运行。安装后就自动启用了，也可以通过右键一个 Bottle>Settings>DXVK Vulkan backand for D3D11(Custom) 启用。</p>
</li>
<li>
<p>手动安装：关键在<code>WINEPREFIX</code>环境变量</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ env LANG<span style=color:#f92672>=</span>zh_TW.UTF-8 WINEPREFIX<span style=color:#f92672>=</span>~/.wine-battle.net WINEARCH<span style=color:#f92672>=</span>win64 ./setup_dxvk.sh install
</code></pre></div></li>
</ul>
<h4 id=esynchttpsgithubcomzfigurawineblobesyncreadmeesync><a href=https://github.com/zfigura/wine/blob/esync/README.esync>Esync</a><a hidden class=anchor aria-hidden=true href=#esynchttpsgithubcomzfigurawineblobesyncreadmeesync>#</a></h4>
<p>注：Some Windows applications will not work correctly which ESync enabled. 例如 My Friend Pedro 开了后闪退，应该先保证正确运行，再考虑提升性能。</p>
<p><a href=https://www.reddit.com/r/wine_gaming/comments/8vf1ka/what_is_wine_esync_and_how_should_i_set_it_up/><strong>What is &ldquo;wine esync&rdquo; and how should I set it up?</strong></a></p>
<p>the thing with Far Cry 4, 3 and Primal also Dirt Rally in wine is that it massively loads wineserver and synchronizing all the time, so it is stuck at around 20 fps on ryzen, all those games mentioned. with esync, wineserver is skipped for synchronizing and eventfd is being used, thus increasing performance that much. Games that are CPU bound with wineserver having huge load (wineserver is singlethreaded) benefit the most of this</p>
<p><a href=https://www.reddit.com/r/SteamPlay/comments/b66mz2/what_is_the_function_of_esync_why_most_games_need/><strong>What is the function of esync? Why most games need it disabled?</strong></a></p>
<p>The function of esync is to provide lightweight thread synchronization facilities (events/semaphores/mutexes) so that game code that uses them heavily will run faster.</p>
<p>It does this using a linux-specific facility called eventfd, which is built around file descriptors. These are a limited resource normally not needed in large quantities, and therefore traditionally made available to a process only in moderate quantities. This helps prevent runaway processes and malicious code from consuming so many descriptors that none are left for other processes (a denial of service).</p>
<p>Therefore, when a game that uses tens of thousands of thread synchronization objects is run with esync, it will fail unless the system&rsquo;s per-process file descriptor limit is much higher than the traditional default. Some linux distributions have already adopted a high default, while others still default to a thousand or so. That&rsquo;s why these games run fine with esync on some distributions but fail on others unless the system&rsquo;s DefaultLimitNOFILE setting is increased.</p>
<p>Edit: If you&rsquo;re interested in esync technical issues that are not distribution-specific, check out <a href=https://github.com/zfigura/wine/issues/11#issuecomment-483060181>this comment</a>.</p>
<h5 id=howtoesynchttpsgithubcomlutrisdocsblobmasterhowtoesyncmd><a href=https://github.com/lutris/docs/blob/master/HowToEsync.md>HowToEsync</a><a hidden class=anchor aria-hidden=true href=#howtoesynchttpsgithubcomlutrisdocsblobmasterhowtoesyncmd>#</a></h5>
<p><strong>What is Esync?</strong></p>
<p>Esync removes wineserver overhead for synchronization objects. This increases performance for a lot of games, especially ones that rely heavily on multithreading.</p>
<p><a href=https://github.com/zfigura/wine/blob/esync/README.esync>A more detailed explanation can be found here</a>.</p>
<p><strong>How to check Esync compatibility</strong></p>
<p>Systems using Systemd 240 and newer are already compatible with Esync.</p>
<p>If you&rsquo;re unsure that your system is compatible, run the <code>ulimit -Hn</code> command. If the value printed is equal to or greater than 524288, then your system is Esync-compatible.</p>
<p><strong>How to make your system Esync compatible</strong></p>
<p>If your system is not Esync-compatible (<code>ulimit -Hn</code>, which prints the limit for number of opened files for a process, prints a value lower than 524288, like 4096), you have 2 different methods of solving this problem. Which method is preferable depends on the distribution currently in use. Applying both methods should have no negative side effect.</p>
<ol>
<li>Modifying Systemd configuration</li>
</ol>
<p>This method applies to Ubuntu and other systems using systemd. You (with root privileges or <code>sudo</code>) need to edit both <code>/etc/systemd/system.conf</code> and <code>/etc/systemd/user.conf</code> by adding <code>DefaultLimitNOFILE=524288</code>. If <code>DefaultLimitNOFILE=</code> already exists in both <code>system.conf</code> and <code>user.conf</code>, add <code>524288</code> after <code>=</code> and make sure to uncomment the line (remove the <code>#</code> in the beginning of the line) to make it functional.</p>
<p>Once the files are edited, restart your computer for the changes to take effect. To verify if the limits were applied, run <code>ulimit -Hn</code> to see <code>524288</code> being reported.</p>
<p>If the value printed still says something like 4096, try the ulimits method below.</p>
<ol start=2>
<li>Modifying ulimits.conf</li>
</ol>
<p>On Linux distributions not using Systemd or distributions using pam-limits.conf (Arch Linux, Fedora, Solus,&mldr; ), you (with root privileges or <code>sudo</code>) need to edit <code>/etc/security/limits.conf</code>.</p>
<p>Change <code>username</code> to your actual username. Once the file is edited, reboot for the changes to take effect, and verify by running <code>ulimit -Hn</code> to see the new limit (<code>524288</code>).</p>
<pre tabindex=0><code>username hard nofile 524288
</code></pre><h4 id=语言设置httpsblogcsdnnetqq_35503971articledetails107296647><a href=https://blog.csdn.net/qq_35503971/article/details/107296647>语言设置</a><a hidden class=anchor aria-hidden=true href=#语言设置httpsblogcsdnnetqq_35503971articledetails107296647>#</a></h4>
<p><strong>注</strong>：某些游戏会因为语言设置而无法运行。</p>
<p>修改步骤：打开容器 C:Drive，返回到顶层文件夹（即容器名称），即可找到<code>cxbottle.conf</code>，在文件最后面添加如下内容：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#a6e22e>[EnvironmentVariables]</span>
<span style=color:#e6db74>&#34;LANG&#34;</span> = <span style=color:#e6db74>&#34;zh_CN.UTF-8&#34;</span>
</code></pre></div><p>也可以像安装软件那样，在搜索框里搜索 “chinese”，然后选择 “Setting bottle&rsquo;s language to Simplifiled Chinese”</p>
<h3 id=third-party-appshttpswikiarchlinuxorgtitlewinethird-party_applications><a href=https://wiki.archlinux.org/title/wine#Third-party_applications>Third-party apps</a><a hidden class=anchor aria-hidden=true href=#third-party-appshttpswikiarchlinuxorgtitlewinethird-party_applications>#</a></h3>
<h4 id=bottleshttpsusebottlescom><a href=https://usebottles.com/>Bottles</a><a hidden class=anchor aria-hidden=true href=#bottleshttpsusebottlescom>#</a></h4>
<h4 id=protonhttpsgithubcomvalvesoftwareproton><a href=https://github.com/ValveSoftware/Proton>Proton</a><a hidden class=anchor aria-hidden=true href=#protonhttpsgithubcomvalvesoftwareproton>#</a></h4>
<p><a href=https://fossbytes.com/use-steam-proton-to-play-windows-games-on-linux/><strong>How To Use Steam Proton To Play Windows Games On Linux?</strong></a></p>
<p>Enabling the Proton</p>
<ol>
<li>
<p>Fire up the Steam app from the app menu.</p>
</li>
<li>
<p>In the top-left corner of the app, click on <strong>Steam</strong> and then click on <strong>Settings</strong>.</p>
</li>
<li>
<p>In the sidebar, find and click on <strong>Steam Play</strong>.</p>
</li>
<li>
<p>Click Enable Steam Play for supported titles and Enable Steam Play for all other <em>title</em> options.</p>
</li>
</ol>
<p><a href=https://www.reddit.com/r/linux_gaming/comments/be4e46/how_to_play_nonsteam_games_through_proton_this/>Can I Install Non-Steam Games Using Proton?</a></p>
<ol>
<li>Download the official launcher</li>
<li>&ldquo;Add non-Steam game&mldr;&rdquo; -> Show all files -> Select the launcher executable -> Done</li>
<li>Setup proton (if not done using global settings)
<ul>
<li>Navigate: Gear icon -> &ldquo;Settings&rdquo; -> &ldquo;Compatibility&rdquo;</li>
<li>Check &ldquo;Force compatibility layer &mldr;&rdquo;</li>
<li>Select Proton 5.13 or newer</li>
</ul>
</li>
<li>Update the target. Gear icon -> &ldquo;Settings&rdquo;:
<ul>
<li>Target: <code>explorer.exe</code></li>
<li>Execution directory: <code>/path/to/your/gi/installation/</code></li>
<li>Start options: <code>/desktop=anyname,1920x1080 cmd /c launcher.bat</code></li>
<li>Adjust the screen resolution above, if necessary.</li>
</ul>
</li>
</ol>
<h4 id=playonlinuxhttpswwwplayonlinuxcom><a href=https://www.playonlinux.com/>PlayOnLinux</a><a hidden class=anchor aria-hidden=true href=#playonlinuxhttpswwwplayonlinuxcom>#</a></h4>
<h4 id=lutrishttpslutrisnet><a href=https://lutris.net/>Lutris</a><a hidden class=anchor aria-hidden=true href=#lutrishttpslutrisnet>#</a></h4>
<p>可以参考其安装脚本。</p>
<h3 id=实例>实例<a hidden class=anchor aria-hidden=true href=#实例>#</a></h3>
<h4 id=hearthstonehttpsgithubcomborisbabichearthstone_hdt_linux><a href=https://github.com/borisbabic/hearthstone_hdt_linux>HearthStone</a><a hidden class=anchor aria-hidden=true href=#hearthstonehttpsgithubcomborisbabichearthstone_hdt_linux>#</a></h4>
<p>如下 wine 7、英文界面、国际服（亚服）直接运行成功：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ env WINEPREFIX<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span>$HOME<span style=color:#e6db74>/.wine-hearthstone&#34;</span> wineboot --init
$ env WINEPREFIX<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span>$HOME<span style=color:#e6db74>/.wine-hearthstone&#34;</span> winetricks win10
$ env WINEPREFIX<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span>$HOME<span style=color:#e6db74>/.wine-hearthstone&#34;</span> winetricks --force dotnet48
$ env WINEPREFIX<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span>$HOME<span style=color:#e6db74>/.wine-hearthstone&#34;</span> wine Battle.net-Setup.exe
</code></pre></div><h4 id=office-2013-prohttpsaskubuntucomquestions879304wine-2-0-says-it-supports-office-2013-how-do-i-actually-install-it><a href=https://askubuntu.com/questions/879304/wine-2-0-says-it-supports-office-2013-how-do-i-actually-install-it>Office 2013 Pro</a><a hidden class=anchor aria-hidden=true href=#office-2013-prohttpsaskubuntucomquestions879304wine-2-0-says-it-supports-office-2013-how-do-i-actually-install-it>#</a></h4>
<p><strong>注</strong>：在安装前先在 <a href=https://appdb.winehq.org/>AppDB</a> 中查找要安装的应用，在 Test Results 部分有相关教程，如 <a href="https://appdb.winehq.org/objectManager.php?sClass=version&iId=28170#testdata">Microsoft Office 2013 Test Results</a></p>
<p><strong>注</strong>：要提高安装成功率，第一，不同 wine 版本安装结果是不同的，AppDB 有相应的信息；第二，winetricks 如果提供安装镜像的话，一定要用该镜像，winetrics 是一个很大的脚本，打开脚本搜索 office2013pro 即可找到官方镜像下载链接；第三，如果第一次安装失败，可以再尝试安装一次。</p>
<p>I installed office 2013 and I used to get a black window after starting it up. I fixed the black screen by following the solution posted in the [WineHQ-Forum](<a href="https://forum.winehq.org/viewtopic.php?f=8&t=28446&p=109296&hilit=office">https://forum.winehq.org/viewtopic.php?f=8&t=28446&p=109296&hilit=office</a> 2013#p109284).</p>
<p>Here&rsquo;s what I did:</p>
<p><strong>Install Components</strong></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sudo apt install winbind cabextract
</code></pre></div><p><strong>Create Clean 32bit Prefix for Win7</strong></p>
<p>Crete a clean 32 bit prefix and start up winecfg:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ env WINEPREFIX<span style=color:#f92672>=</span>~/.wine-office2013pro WINEARCH<span style=color:#f92672>=</span>win32 winecfg
</code></pre></div><p>In the winecfg applications tab select &ldquo;<strong>Windows version: Windows 7</strong>&rdquo; Close wine config and install winetricks</p>
<p><strong>Install Libraries</strong></p>
<p>Then start winetricks for your prefix</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ env WINEPREFIX<span style=color:#f92672>=</span>~/.wine-office2013pro WINEARCH<span style=color:#f92672>=</span>win32 winetricks
</code></pre></div><p>accept &ldquo;<strong>select the default wineprefix</strong>&rdquo; with OK. Now, select &ldquo;<strong>Install Windows DLL components</strong>&rdquo; and go and install <strong>msxml6</strong>（这个时候会下载 msxml6，可以手动下载后移动到<code>~/.cache/winetricks</code>中）</p>
<p>To fix the problem in PowerPoint (not enough memory), I added two overrides with winecfg in Library section: &ldquo;riched20&rdquo; and &ldquo;usp10&rdquo;.</p>
<p>如果是中文软件需安装中文字体。</p>
<p>在这里我直接使用 winetrics 成功安装 office2013pro（wine 6）：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ env WINEPREFIX<span style=color:#f92672>=</span>~/.wine-office2013pro WINEARCH<span style=color:#f92672>=</span>win32 winetricks office2013pro
</code></pre></div><p>这样下面步骤不需要了。</p>
<p><strong>Fix Black Window</strong></p>
<p>In order to fix the black window that impedes Office 13 to be used, add the HKCU\Software\Wine\Direct3D\MaxVersionGL new DWORD value 30002 (hexa) to the registry.</p>
<p>Here&rsquo;s how to do this: In Winetricks select <strong>Run regedit</strong> and wait for the <em>Registry Editor</em> window to open. In the folder tree expand HKEY_CURRENT_USER - Software - Wine and create a new key in the Wine folder. To do so, right click, select <em>new&ndash;>key</em> and name it <strong>Direct3D</strong>. Now create <em>new&ndash;>DWORD Value</em>, rename the file to <strong>MaxVersionGL</strong> and set the value data to <strong>30002</strong> (hexadecimal). Close the Registry Editor window.</p>
<p>Close the winetricks window and run installer:</p>
<p><strong>Install Office 2013</strong></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ env LANG<span style=color:#f92672>=</span>zh_CN.UTF-8 WINEPREFIX<span style=color:#f92672>=</span>~/.wine-office2013pro WINEARCH<span style=color:#f92672>=</span>win32 wine ~/PathTo/Office2013Setup.x86.exe
</code></pre></div><p>From here, the install runs and completes 100%.</p>
<p>安装后可以在 <code>~/.local/share/applications/wine</code> 下找到 微信、QQ 的 .desktop 文件，右键编辑，将 Exec=env 行改为 Exec=env LANG=zh_CN.utf8</p>
<h4 id=genshin-impact>Genshin Impact<a hidden class=anchor aria-hidden=true href=#genshin-impact>#</a></h4>
<p><a href=https://notabug.org/Krock/dawn>GI-on-Linux</a>（已验证可玩）or Play another game. Format: link, caveats (Proton/Wine rating)</p>
<ul>
<li>Blue Protocol, unreleased, 2022 (N/A)</li>
<li>Tower of Fantasy, unreleased, 2022 (N/A)</li>
<li>Wuthering Waves, unreleased, 20?? (N/A)</li>
<li><a href=https://store.steampowered.com/app/775500/SCARLET_NEXUS/>Scarlet Nexus</a>, singleplayer (Platinum)</li>
<li><a href=https://store.steampowered.com/app/1049890/Little_Witch_Nobeta/>Little Witch Nobeta</a> singleplayer (Gold)</li>
<li><a href=https://store.steampowered.com/app/649950/Ashen/>Ashen</a> (Platinum)</li>
<li><a href=https://store.steampowered.com/app/844850/Tower_Hunter_Erzas_Trial/>Tower Hunter: Erza&rsquo;s Trial</a> singleplayer, 2D scroller (Platinum)</li>
<li><a href=https://www.gog.com/game/haven>Haven</a> PEGI 18 (Gold)</li>
<li><a href=https://store.steampowered.com/app/892970/Valheim/>Valheim</a> no story (Native)</li>
<li><a href=https://www.gog.com/game/pine>Pine</a> no story, singleplayer (Native)</li>
</ul>
<h3 id=darlinghttpsgithubcomdarlinghqdarling><a href=https://github.com/darlinghq/darling>darling</a><a hidden class=anchor aria-hidden=true href=#darlinghttpsgithubcomdarlinghqdarling>#</a></h3>
<p>Darling is a translation layer that lets you run macOS software on Linux</p>
<h3 id=anboxhttpslinuxcnarticle-10843-1html><a href=https://linux.cn/article-10843-1.html>Anbox</a><a hidden class=anchor aria-hidden=true href=#anboxhttpslinuxcnarticle-10843-1html>#</a></h3>
<h4 id=anbox-简介>Anbox 简介<a hidden class=anchor aria-hidden=true href=#anbox-简介>#</a></h4>
<p>Anbox 是 “Android in a box” 的缩写。Anbox 是一个基于容器的方法，可以在普通的 GNU/Linux 系统上启动完整的 Android 系统。</p>
<p>Anbox 可以让你在 Linux 系统上运行 Android，而没有虚拟化的迟钝，因为核心的 Android 操作系统已经使用 Linux 命名空间（LXE）放置到容器中了。</p>
<p>Android 容器不能直接访问到任何硬件，所有硬件的访问都是通过在主机上的守护进程进行的。</p>
<p>每个应用程序将在一个单独窗口打开，就像其它本地系统应用程序一样，并且它可以显示在启动器中。</p>
<h4 id=安装使用>安装使用<a hidden class=anchor aria-hidden=true href=#安装使用>#</a></h4>
<p>Anbox 也可作为 snap 软件包安装，请确保你已经在你的系统上启用了 snap 支持。</p>
<p>为使 Anbox 工作，确保需要的内核模块已经安装在你的系统中。对于基于 Ubuntu 的用户，使用下面的 PPA 来安装它。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sudo add-apt-repository ppa:morphis/anbox-support
$ sudo apt update
$ sudo apt install linux-headers-generic anbox-modules-dkms
</code></pre></div><p>在你安装 <code>anbox-modules-dkms</code> 软件包后，你必须手动重新加载内核模块，或需要系统重新启动。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sudo modprobe ashmem_linux
$ sudo modprobe binder_linux
</code></pre></div><p>安装 anbox。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sudo apt install anbox
</code></pre></div><p>如果你已经在你的系统上安装 snap，其它的步骤可以忽略。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sudo snap install --devmode --beta anbox
</code></pre></div><p>默认情况下，Anbox 并没有带有 Google Play Store。因此，我们需要手动下载每个应用程序（APK），并使用 Android 调试桥（ADB）安装它。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sudo apt install android-tools-adb
</code></pre></div><p>既然我们不能使用 Play Store ，你就得从信得过的网站来下载 APK 软件包，像 <a href=https://www.apkmirror.com/>APKMirror</a> ，然后手动安装它。</p>
<p>首先，你需要启动 ADB 服务。为做到这样，运行下面的命令。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ adb devices
</code></pre></div><p>安装语法格式：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ adb install Name-Of-Your-Application.apk
</code></pre></div><h2 id=qemu-kvmhttpswikiarchlinuxorgtitleqemu_e7ae80e4bd93e4b8ade69687><a href=https://wiki.archlinux.org/title/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)>QEMU KVM</a><a hidden class=anchor aria-hidden=true href=#qemu-kvmhttpswikiarchlinuxorgtitleqemu_e7ae80e4bd93e4b8ade69687>#</a></h2>
<h3 id=qemu-的图形前端>QEMU 的图形前端<a hidden class=anchor aria-hidden=true href=#qemu-的图形前端>#</a></h3>
<p>与其他的虚拟化程序如 VirtualBox 和 VMware 不同, QEMU不提供管理虚拟机的GUI（运行虚拟机时出现的窗口除外），也不提供创建具有已保存设置的持久虚拟机的方法。除非您已创建自定义脚本以启动虚拟机，否则必须在每次启动时在命令行上指定运行虚拟机的所有参数。</p>
<p>Libvirt提供了一种管理 QEMU 虚拟机的便捷方式。有关可用的前端，请参阅 <a href=https://wiki.archlinux.org/title/Libvirt_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#.E5.AE.A2.E6.88.B7.E7.AB.AF>libvirt 客户端列表</a>。</p>
<h3 id=创建新虚拟系统>创建新虚拟系统<a hidden class=anchor aria-hidden=true href=#创建新虚拟系统>#</a></h3>
<h4 id=创建硬盘镜像>创建硬盘镜像<a hidden class=anchor aria-hidden=true href=#创建硬盘镜像>#</a></h4>
<p>除非直接从 CD-ROM 或网络引导（并且不安装系统到本地），运行 QEMU 时都需要硬盘镜像。硬盘镜像是一个文件，存储虚拟机硬盘上的内容。</p>
<p>一个硬盘镜像可能是 <em>raw</em>镜像, 和客户机器上看到的内容一模一样，并且将始终使用主机上的来宾硬盘驱动器的全部容量。此方法提供的I / O开销最小，但可能会浪费大量空间，因为guest虚拟机上未使用的空间无法在主机上使用。</p>
<p>另外一种方式是<em>qcow2</em> 格式，仅当客户系统实际写入内容的时候，才会分配镜像空间。对客户机器来说，硬盘大小表现为完整大小，即使它可能仅占用主机系统上的非常小的空间。此映像格式还支持QEMU快照功能。但是，使用此格式而不是 <em>raw</em> 可能会影响性能。</p>
<p>QEMU 提供 <code>qemu-img</code>命令创建硬盘镜像.例如创建一个 4 GB <em>raw</em> 格式的镜像:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ qemu-img create -f raw image_file 4G
</code></pre></div><p>您也可以用 <code>-f qcow2</code> 创建一个 <em>qcow2</em> 镜像。</p>
<p>用 <code>dd</code> 或 <code>fallocate</code> 也可以创建一个 <em>raw</em> 镜像。</p>
<p><strong>警告：</strong> 如果硬盘镜像存储在 Btrfs 系统上，则应在创建任何映像之前考虑禁用该目录的写时复制。</p>
<h5 id=调整镜像大小>调整镜像大小<a hidden class=anchor aria-hidden=true href=#调整镜像大小>#</a></h5>
<p><strong>警告：</strong> 调整包含NTFS引导文件系统的镜像将无法启动已安装的操作系统，推荐在操作之前进行备份</p>
<p>执行 <code>qemu-img</code> 带 <code>resize</code> 选项调整硬盘驱动镜像的大小.它适用于 <em>raw</em> 和 <em>qcow2</em>. 例如, 增加镜像 10 GB 大小, 运行:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ qemu-img info disk_image
$ qemu-img resize disk_image +10G
</code></pre></div><p>在磁盘映像扩容后，必须使用虚拟机内部系统的分区工具对该镜像进行分区并格式化后才能真正开始使用新空间。 在收缩磁盘映像时，必须首先使用虚拟机内部系统的分区工具减少分该分区的大小，然后相应地收缩磁盘映像，否则收缩磁盘映像将导致数据丢失！</p>
<p>PS：用qemu-img调整镜像大小，很简单，问题出在启动系统后，Windows只剩一个一直转圈圈的鼠标与黑屏，一点报错也没有，等了很久（半个小时左右），我直接loadvm加载snapshot，loadvm会回退之前qemu-img resize操作，所以需要再次resize，再次进系统，终于正常了，也看到了多出来的空闲空间。这说明操作是正确的，但是由于各种位置原因导致黑屏，所以重新做一次就好了。这里有一个手把手教程：<a href=https://woshub.com/kvm-expand-shrink-vm-disk/>KVM: How to Expand or Shrink a Virtual Machine Disk Size?</a></p>
<h4 id=安装操作系统>安装操作系统<a hidden class=anchor aria-hidden=true href=#安装操作系统>#</a></h4>
<p>这是你第一次需要去启动模拟器的步骤，为了在磁盘镜像上安装操作系统，你必须同时将磁盘镜像与安装介质装载到虚拟机上，从安装介质中启动操作系统。</p>
<p>以i386的客户机为例，为了从CD-ROM内的把可用于启动的ISO文件安装到磁盘镜像上，你需要：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ qemu-system-x86_64 -cdrom iso_image -boot order<span style=color:#f92672>=</span>d -drive file<span style=color:#f92672>=</span>disk_image,format<span style=color:#f92672>=</span>raw
</code></pre></div><p>在安装完操作系统后，就可以直接从QEMU镜像内启动了。</p>
<p><strong>注意：</strong> 默认情况下仅分配给虚拟机128MB的内存， 分配的内存大小可以通过 <code>-m</code> 调整， 比如 <code>-m 512M</code> 或 <code>-m 2G</code>。</p>
<p><strong>提示：</strong></p>
<ul>
<li>相较于指定 <code>-boot order=x</code> ，一部分用户感觉使用 <code>-boot menu=on</code> 启用boot菜单的体验更舒服些，至少在配置和实验时是这样的。</li>
<li>当使用无界面（headless）模式时， 将会默认在本地5900端口启动一个VNC服务器， 可以用 <a href=https://wiki.archlinux.org/title/TigerVNC>TigerVNC</a> 连接到客户机的系统上: <code>vncviewer :5900</code></li>
<li>若你在安装过程中需要替换软盘或CD，可以使用QEMU机器监视器（在虚拟机窗口中按<code>Ctrl + Alt + 2</code>）来删除存储设备并将其连接到虚拟机。使用<code>info block</code>查看块设备，然后使用<code>change</code>命令换出设备。按下<code>Ctrl + Alt + 1</code>返回虚拟机。</li>
</ul>
<h3 id=运行虚拟化的系统>运行虚拟化的系统<a hidden class=anchor aria-hidden=true href=#运行虚拟化的系统>#</a></h3>
<p><code>qemu-system-*</code> 程序 (例如 <code>qemu-system-i386</code> 或 <code>qemu-system-x86_64</code>, 取决于客户机架构)用来运行虚拟化的客户机. 用法是:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ qemu-system-i386 options disk_image
</code></pre></div><p>所有 <code>qemu-system-*</code>的选项是相同的。</p>
<p>默认 QEMU会在窗口中显示虚拟机的视频输出。有一点要记住：当您单击QEMU窗口,鼠标指针被捕获。要放开，按 <code>Ctrl+Alt+g</code>.</p>
<p><strong>警告：</strong> QEMU 不应以 root 身份运行。如果必须以root身份在某个脚本中运行QEMU，那么你需要使用 <code>-runas</code> 选项让QEMU放弃root权限</p>
<h4 id=启用-kvm>启用 KVM<a hidden class=anchor aria-hidden=true href=#启用-kvm>#</a></h4>
<p>KVM 必须要您处理器和内核支持, 和必要的 <a href=https://wiki.archlinux.org/title/Kernel_modules>kernel modules</a>加载。更多信息参见 <a href=https://wiki.archlinux.org/title/KVM>KVM</a>。</p>
<p>要在KVM模式中启动QEMU, 追加 <code>-enable-kvm</code>到启动选项. 要检查是否为正在运行的 VM 启用了 KVM，请使用 Ctrl+Alt+Shift+2 进入 QEMU Monitor，然后键入 info kvm。</p>
<p><strong>注意：</strong></p>
<ul>
<li><code>-machine</code> 选项中的 <code>accel=kvm</code> 参数与<code>-enable-kvm</code> 或 <code>-accel kvm</code> 选项是等价的。</li>
<li>CPU模型 <code>host</code> 需要 KVM。</li>
<li>如果你使用GUI工具去启动QEMU，但是性能体验极差，那么最好检查一下是否真的开启了KVM支持，因为QEMU可能选择了备用的模拟模式，即软件级模拟。</li>
<li>需要启用KVM才能正常启动windows7和windows8，否则会出现“蓝屏”.</li>
</ul>
<h3 id=宿主机和虚拟机数据交互>宿主机和虚拟机数据交互<a hidden class=anchor aria-hidden=true href=#宿主机和虚拟机数据交互>#</a></h3>
<h4 id=网络>网络<a hidden class=anchor aria-hidden=true href=#网络>#</a></h4>
<p>我们可以利用任何支持文件传输的网络协议实现客户机和宿主机之间的数据交互, 例如 <a href=https://wiki.archlinux.org/title/NFS>NFS</a>, <a href=https://wiki.archlinux.org/title/SMB>SMB</a>, <a href=https://en.wikipedia.org/wiki/Network_block_device>NBD</a>, HTTP, <a href=https://wiki.archlinux.org/title/Very_Secure_FTP_Daemon>FTP</a>, 或 <a href=https://wiki.archlinux.org/title/SSH>SSH</a>, 当然这么做的前提是你已经配置好二者之间的网络，且在系统上启动了相应的服务程序。</p>
<p>在默认情况下，用户模式的客户机能够通过10.0.2.2这个IP访问到宿主机。任何运行于宿主机上的服务端程序都可以通过这个地址被访问到，比如说我们可以通过这个IP访问到宿主机上的SSH服务器或SMB服务器。因此在这种情况下，客户机能够挂载宿主机通过<a href=https://wiki.archlinux.org/title/SMB>SMB</a> or <a href=https://wiki.archlinux.org/title/NFS>NFS</a>暴露出来的目录，也可以访问宿主机上的HTTP服务器等。 通常情况下宿主机无法访问客户机上的服务，不过你也可以通过一些特殊的网络配置达到这个目的 (参阅<a href=https://wiki.archlinux.org/title/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#Tap_%E7%BD%91%E7%BB%9C>#Tap 网络</a>)</p>
<h4 id=qemu-端口转发>QEMU 端口转发<a hidden class=anchor aria-hidden=true href=#qemu-端口转发>#</a></h4>
<p>QEMU能够将宿主机的端口转发到客户机上以实现一些功能，例如从宿主机上访问客户机的SSH端口。</p>
<p>举个例子，将宿主机上的10022端口与客户机上的22 (SSH) 端口进行绑定， 对应的QEMU命令如下：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ qemu-system-x86_64 disk_image -nic user,hostfwd<span style=color:#f92672>=</span>tcp::10022-:22
</code></pre></div><p>确认你客户机上的sshd程序正在运行，然后可以通过如下命令连接到客户机的SSH端口</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ ssh guest-user@localhost -p <span style=color:#ae81ff>10022</span>
</code></pre></div><p>你可以用 <a href=https://wiki.archlinux.org/title/SSHFS>SSHFS</a> 把客户机的整个文件系统都挂到宿主机上，这样就可以在宿主机上对客户机的文件系统进行读写了。</p>
<p>想进行多端口转发的话, 只需要在<code>-nic</code>参数中指定多个<code>hostfwd</code>, 以VNC端口为例:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ qemu-system-x86_64 disk_image -nic user,hostfwd<span style=color:#f92672>=</span>tcp::10022-:22,hostfwd<span style=color:#f92672>=</span>tcp::5900-:5900
</code></pre></div><h4 id=qemu-的内置smb服务器>QEMU 的内置SMB服务器<a hidden class=anchor aria-hidden=true href=#qemu-的内置smb服务器>#</a></h4>
<p>QEMU的文档中指出它有一个内置的SMB服务器，但实际上，它只是在宿主机上加载一个自动生成的<code>smb.conf</code>配置文件 (位于<code>/tmp/qemu-smb.random_string</code>)，然后启动宿主机上的Samba，使得客户机能够通过一个IP地址进行访问 (默认的IP地址是10.0.2.4)。这个方法只适用于用户网络，在你不想在宿主机开启通常的Samba服务 (客户机同样能访问这类Samba服务) 时这个方法还挺好用的。</p>
<p>宿主机上必须安装 <em>Samba</em>。通过如下QEMU命令启用这项特性:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sudo apt install samba
$ qemu-system-x86_64 disk_image -net nic -net user,smb<span style=color:#f92672>=</span>shared_dir_path
</code></pre></div><p><code>shared_dir_path</code> 就是你想要在宿主机和客户机之间共享的目录。</p>
<p>接着，在客户机内，你应该能够通过10.0.2.4访问到名为qemu的共享文件夹。例如在Windows Explorer中前往 <code>\\10.0.2.4\qemu</code> 这个地址。</p>
<p><strong>注意：</strong></p>
<ul>
<li>如果你像这样多次指定共享选项 <code>-net user,smb=shared_dir_path1 -net user,smb=shared_dir_path2</code> or <code>-net user,smb=shared_dir_path1,smb=shared_dir_path2</code> qemu只会共享参数中最后的一个目录。</li>
<li>如果你不能访问共享文件夹且客户机系统为 Windows, 请检查 <a href=http://ecross.mvps.org/howto/enable-netbios-over-tcp-ip-with-windows.htm>NetBIOS 协议是否被启用</a> 并确认防火墙没有屏蔽NetBIOS协议的 <a href=https://technet.microsoft.com/en-us/library/cc940063.aspx>端口</a></li>
<li>如果你不能访问共享文件夹且客户机系统为 Windows 10 Enterprise 或 Education 或 Windows Server 2016, 请<a href=https://support.microsoft.com/en-us/help/4046019>启用游客访问</a>.
<ol>
<li>打开 本地组策略编辑器 (gpedit.msc)。</li>
<li>在控制台树中，依次选择“计算机配置” > “管理模板” > “网络” > “Lanman 工作站”。</li>
<li>对于设置，右键单击“启用不安全的来宾登录”，然后选择“编辑”。</li>
<li>选择“启用”，然后选择“确定”。</li>
</ol>
</li>
</ul>
<p>共享多个文件夹并在运行时增删文件夹的一个方法是：共享一个空目录，然后在其中创建指向其余共享目录的符号链接。可以用下面的脚本修改SMB服务器的配置，这个脚本还能使宿主机上不允许执行的文件在客户机内拥有执行权限。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e>#!/bin/bash
</span><span style=color:#75715e></span>eval <span style=color:#66d9ef>$(</span>ps h -C smbd -o pid,args | grep /tmp/qemu-smb | gawk <span style=color:#e6db74>&#39;{print &#34;pid=&#34;$1&#34;;conf=&#34;$6}&#39;</span><span style=color:#66d9ef>)</span>
echo <span style=color:#e6db74>&#34;[global]
</span><span style=color:#e6db74>allow insecure wide links = yes
</span><span style=color:#e6db74>[qemu]
</span><span style=color:#e6db74>follow symlinks = yes
</span><span style=color:#e6db74>wide links = yes
</span><span style=color:#e6db74>acl allow execute always = yes&#34;</span> &gt;&gt; $conf
<span style=color:#75715e># in case the change is not detected automatically:</span>
smbcontrol --configfile<span style=color:#f92672>=</span>$conf $pid reload-config
</code></pre></div><p>仅当客户机第一次访问到网络驱动后，才能将该脚本启用，并作用于qemu启动的SMB服务器。共享多文件的另一个方法是在配置文件里加入额外的共享路径，就像下面这样</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ echo <span style=color:#e6db74>&#34;[myshare]
</span><span style=color:#e6db74>path=another_path
</span><span style=color:#e6db74>read only=no
</span><span style=color:#e6db74>guest ok=yes
</span><span style=color:#e6db74>force user=username&#34;</span> &gt;&gt; $conf
</code></pre></div><p>这个共享文件夹可以在客户机内通过<code>\\10.0.2.4\myshare</code>访问。</p>
<h4 id=挂载qcow2镜像内的分区httpswikiarchlinuxorgtitleqemu_e7ae80e4bd93e4b8ade69687e68c82e8bdbdqcow2e9959ce5838fe58685e79a84e58886e58cba><a href=https://wiki.archlinux.org/title/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E6%8C%82%E8%BD%BDqcow2%E9%95%9C%E5%83%8F%E5%86%85%E7%9A%84%E5%88%86%E5%8C%BA>挂载qcow2镜像内的分区</a><a hidden class=anchor aria-hidden=true href=#挂载qcow2镜像内的分区httpswikiarchlinuxorgtitleqemu_e7ae80e4bd93e4b8ade69687e68c82e8bdbdqcow2e9959ce5838fe58685e79a84e58886e58cba>#</a></h4>
<p>我们将使用 <code>qemu-nbd</code> 完成这一功能, 同时它也能让我们使用 NBD (<em>network block device</em>) 协议共享该磁盘镜像。</p>
<p>首先，我们需要加载nbd模块：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sudo modprobe nbd max_part<span style=color:#f92672>=</span><span style=color:#ae81ff>16</span>
</code></pre></div><p>接着，共享该磁盘并创建设备条目：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sudo qemu-nbd -c /dev/nbd0 /path/to/image.qcow2
</code></pre></div><p>进行分区发现检测：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sudo partprobe /dev/nbd0
</code></pre></div><p><em>fdisk</em> 可以获取 <code>nbd0</code> 内各分区的相关信息 :</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sudo fdisk -l /dev/nbd0
Disk /dev/nbd0: 25.2 GiB, <span style=color:#ae81ff>27074281472</span> bytes, <span style=color:#ae81ff>52879456</span> sectors
Units: sectors of <span style=color:#ae81ff>1</span> * 512 <span style=color:#f92672>=</span> <span style=color:#ae81ff>512</span> bytes
Sector size <span style=color:#f92672>(</span>logical/physical<span style=color:#f92672>)</span>: <span style=color:#ae81ff>512</span> bytes / <span style=color:#ae81ff>512</span> bytes
I/O size <span style=color:#f92672>(</span>minimum/optimal<span style=color:#f92672>)</span>: <span style=color:#ae81ff>512</span> bytes / <span style=color:#ae81ff>512</span> bytes
Disklabel type: dos
Disk identifier: 0xa6a4d542

Device      Boot   Start      End  Sectors  Size Id Type
/dev/nbd0p1 *       <span style=color:#ae81ff>2048</span>  <span style=color:#ae81ff>1026047</span>  <span style=color:#ae81ff>1024000</span>  500M  <span style=color:#ae81ff>7</span> HPFS/NTFS/exFAT
/dev/nbd0p2      <span style=color:#ae81ff>1026048</span> <span style=color:#ae81ff>52877311</span> <span style=color:#ae81ff>51851264</span> 24.7G  <span style=color:#ae81ff>7</span> HPFS/NTFS/exFAT
</code></pre></div><p>接下来可以挂载镜像的任意分区了，比如说我们要挂载分区2：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sudo mount /dev/nbd0p2 mountpoint
</code></pre></div><p>完成任务后，切记卸载镜像文件，然后根据之前的操作一步步还原，即分区并断开与nbd设备的连接：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sudo umount mountpoint
$ sudo qemu-nbd -d /dev/nbd0
</code></pre></div><h3 id=网络-1>网络<a hidden class=anchor aria-hidden=true href=#网络-1>#</a></h3>
<p>采用<strong>TAP设备</strong>（<a href=https://www.cxyzjd.com/article/Longyu_wlz/107627564>tun 与 tap 设备</a>，都是虚拟网络设备，tun 设备用来实现三层隧道（三层 ip 数据报），tap 设备用来实现二层隧道（二层以太网数据帧）。）和<strong>网桥</strong>（使用网桥可以将多个接口连接到同一网段内，这一功能等同于交换式集线器。）的虚拟网络的性能应该会比使用用户模式网络或VDE要好，原因在于TAP设备和网桥是在内核中实现的。</p>
<p>此外，虚拟网络的性能可以通过将网络设备直接注册到虚拟机中改善，这比默认情况下模拟e1000 NIC的性能表现要更好，参阅 [安装 virtio 驱动](#安装 virtio 驱动) 获得更多相关信息。</p>
<h4 id=关于链路层地址的限制>关于链路层地址的限制<a hidden class=anchor aria-hidden=true href=#关于链路层地址的限制>#</a></h4>
<p>若在QEMU启动中指定了 <code>-net nic</code> 参数，QEMU将会为虚拟机注册一块虚拟网卡，其链路层地址为 <code>52:54:00:12:34:56</code> 。然而，当在多台虚拟机之间搭建桥接网络时，每台虚拟机在tap设备的虚拟机端都需要拥有一个独一无二的链路层地址 (MAC)，否则网桥会因为收到多个不同源却拥有相同MAC地址的数据包而无法正常工作。即使你为多个tap设备配置了不同的MAC地址也依旧会出现这个问题，因为当数据包通过tap设备时，tap设备并不会改写包内的链路层地址。</p>
<p>因此请确保每个虚拟机拥有自己独一无二的网卡地址, 并且它们都以 <code>52:54:</code> 开头。 可以通过如下命令手动设置虚拟机的MAC地址, 下面的&rsquo;X&rsquo;可以替换成任何16进制字符:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ qemu-system-x86_64 -net nic,macaddr<span style=color:#f92672>=</span>52:54:XX:XX:XX:XX -net vde disk_image
</code></pre></div><h4 id=用户模式>用户模式<a hidden class=anchor aria-hidden=true href=#用户模式>#</a></h4>
<p>默认情况下，没有任何<code>-netdev</code>参数，QEMU将使用带有内置DHCP服务器的用户模式网络。当您的虚拟机运行其DHCP客户端时，将为其分配IP地址，它们将能够通过QEMU伪装的IP来访问物理主机的网络。</p>
<p><strong>警告：</strong> 仅适用于TCP和UDP协议，因此ICMP协议（包括<code>ping</code>）将不起作用。 请勿使用<code>ping</code>测试网络连接。</p>
<p>如果主机已连接Internet，则此默认配置可以使您的虚拟机轻松访问Internet。但是如果您同时启动多个虚拟机，则虚拟机将无法在外部网络上直接看到，虚拟机也将无法相互通信。</p>
<p>QEMU的用户模式网络可以提供更多功能，例如内置TFTP或SMB服务器，将主机端口重定向到虚拟机（例如，允许SSH连接到虚拟机）或将虚拟机连接到VLAN（vlan 全程 virtual lan，能够用来虚拟分配以太网。归属于不同的 VLAN ID 的设备之间需要一个路由才能够通信，这意味这不同的 VLAN ID 将以太网划分成了不同的分组。），以便它们可以彼此通信。 有关更多详细信息，请参见<code>-net user</code>标志上的QEMU文档。</p>
<p>但是，用户模式网络在效用和性能上都有局限性。更高级的网络配置需要使用TAP设备或其他方法。</p>
<h4 id=tap-网络>Tap 网络<a hidden class=anchor aria-hidden=true href=#tap-网络>#</a></h4>
<p><a href=https://en.wikipedia.org/wiki/TUN/TAP>Tap devices</a>是一个Linux内核特性，允许您创建作为真实网络接口的虚拟网络接口。发送到tap接口的包将被传递到一个用户空间程序(如QEMU)，该程序将自己绑定到该接口。</p>
<p>QEMU可以为虚拟机使用tap网络，因此发送到tap接口的包将被发送到虚拟机，并显示为来自虚拟机中的网络接口(通常是以太网接口)。相反，虚拟机通过其网络接口发送的所有内容都将出现在tap接口上。</p>
<p>Linux桥接驱动程 序支持Tap设备，因此可以将Tap设备彼此桥接在一起，也可以连接其他主机接口，如<code>eth0</code>。如果您希望您的虚拟机能够相互通信，或者希望LAN上的其他机器能够与虚拟机通信，那么这是非常理想的方案。</p>
<p><strong>警告：</strong> 如果您将tap设备和一些主机接口桥接在一起，例如<code>eth0</code>，您的虚拟机将直接出现在外部网络上，这将使它们遭受攻击的可能。根据您的虚拟机可以访问的资源，您可能需要采取所有<a href=https://wiki.archlinux.org/title/Firewalls>precautions</a>来保护您的虚拟机。如果风险太大,虚拟机没有资源或您设置多个虚拟机,一个更好的解决方案可能是使用<a href=https://wiki.archlinux.org/title/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E4%BB%85%E4%B8%BB%E6%9C%BA_%E7%BD%91%E7%BB%9C>host-only networking</a>建立NAT。在这种情况下，您只需要在主机上安装一个防火墙，而不是为每个虚拟机安装多个防火墙。</p>
<p>正如在用户模式网络部分中指出的，tap设备提供比用户模式具有更高的网络性能。如果虚拟机中的操作系统支持virtio网络驱动程序，那么网络性能也会显著提高。假设使用tap0设备，virtio驱动程序在客户端上使用，并且没有使用脚本来帮助启动/停止网络，使用下面的qemu命令：</p>
<pre tabindex=0><code>-net nic,model=virtio -net tap,ifname=tap0,script=no,downscript=no
</code></pre><p>但是，如果已经使用带有virtio网络驱动程序的Tap设备，则甚至可以通过启用vhost来提高网络性能，例如：</p>
<pre tabindex=0><code>-net nic,model=virtio -net tap,ifname=tap0,script=no,downscript=no,vhost=on
</code></pre><p><strong>仅主机网络</strong></p>
<p>如果为网桥提供了IP地址，并且使能发往该网桥的流量允许，但没有实际接口（例如<code>eth0</code>）连接到网桥，则虚拟机与虚拟机间，虚拟机与主机间能够相互通信。但是，如果您没有在物理主机上设置IP掩蔽，则他们将无法与外部网络进行通信。 此配置被其他虚拟化软件（例如<a href=https://wiki.archlinux.org/title/VirtualBox>VirtualBox</a>）称为“仅主机网络模式”。</p>
<p><strong>提示：</strong></p>
<ul>
<li>
<p>如果你想设置IP掩蔽，例如虚拟机的NAT，请查看<a href=https://wiki.archlinux.org/title/Internet_sharing#Enable_NAT>Internet sharing#Enable NAT</a>页面。</p>
</li>
<li>
<p>您也许想在网桥接口上运行一个DHCP服务器来服务虚拟网络。例如，使用<code>172.20.0.1/16</code>子网，<a href=https://wiki.archlinux.org/title/Dnsmasq>dnsmasq</a>作为DHCP服务器:</p>
<pre tabindex=0><code># ip addr add 172.20.0.1/16 dev br0
# ip link set br0 up
# dnsmasq --interface=br0 --bind-interfaces --dhcp-range=172.20.0.2,172.20.255.254
</code></pre></li>
</ul>
<p><strong>内部网络</strong></p>
<p>如果您不为网桥提供IP地址并在<a href=https://wiki.archlinux.org/title/Iptables>iptables</a>添加INPUT规则链，将所有流向网桥中的数据丢弃，则虚拟机将能够彼此通信，但无法与物理主机或外部网络通信。此配置被其他虚拟化软件（例如<a href=https://wiki.archlinux.org/title/VirtualBox>VirtualBox</a>）称为“内部网络”。您将需要为虚拟机分配静态IP地址，或在其中一个虚拟机上运行DHCP服务器。</p>
<p>在默认情况下，iptables将丢弃桥接网络中的数据包。您可能需要使用这样的iptables规则来允许桥接网络中的数据包:</p>
<pre tabindex=0><code># iptables -I FORWARD -m physdev --physdev-is-bridged -j ACCEPT
</code></pre><p><strong>使用 qemu-bridge-helper 桥接网络</strong></p>
<p>这种方法不需要启动脚本，并且很容易适应多个tap和多个桥。它使用<code>/usr/lib/qemu/qemu-bridge-helper</code>，允许在现有桥上创建tap设备。</p>
<p><strong>提示：</strong> 参见 <a href=https://wiki.archlinux.org/title/Network_bridge>Network bridge</a> 获取创建网桥的信息.</p>
<p>首先，创建一个配置文件，包含QEMU使用的所有网桥的名称:</p>
<pre tabindex=0><code>/etc/qemu/bridge.conf
allow bridge0
allow bridge1
...
</code></pre><p>现在启动虚拟机：</p>
<pre tabindex=0><code>$ qemu-system-i386 -net nic -net bridge,br=bridge0 [...]
</code></pre><p>在多个TAP设备的情况下，最基本的用法是要为所有NIC指定VLAN：</p>
<pre tabindex=0><code>$ qemu-system-i386 -net nic -net bridge,br=bridge0 -net nic,vlan=1 -net bridge,vlan=1,br=bridge1 [...]
</code></pre><p><strong>手工创建网桥</strong></p>
<p>将虚拟机连接到主机接口，如<code>eth0</code>，这可能是最常见的配置。这种配置使虚拟机看起来直接位于外部网络，与物理主机位于同一以太网段。</p>
<p><strong>物理设备和Tap设备之间通过iptables进行网络共享</strong></p>
<p>桥接网络能在有线接口(例如eth0)之间工作，并且很容易设置。但是，如果主机通过无线设备连接到网络，则无法进行桥接。</p>
<p>解决这个问题的一种方法是，给tap设备设置一个静态IP，使linux自动处理它的路由，然后通过iptables规则转发tap接口和连接到网络的设备之间的通信。</p>
<h4 id=通过-vde2-配置网络>通过 VDE2 配置网络<a hidden class=anchor aria-hidden=true href=#通过-vde2-配置网络>#</a></h4>
<p>VDE全称为Virtual Distributed Ethernet，作为uml_switch的一个扩展，是一个用于管理虚拟网络的工具包</p>
<p>其基本的思想是创建一个虚拟的开关，就如插座那样，允许虚拟机和物理机通过"插入"连接彼此。下面的配置非常简单，然而，VDE的功能远比展示的更强大，其能够接入虚拟开关，在不同的主机上运行它们并监听开关上的通信。</p>
<p>本方法的优点在于无需sudo特权，普通用户一般没有运行modprobe的权限。</p>
<h4 id=vde2-网桥>VDE2 网桥<a hidden class=anchor aria-hidden=true href=#vde2-网桥>#</a></h4>
<p>任何连接到vde上的虚拟机都会暴露给外部。举个例子，每台虚拟机都能直接从ADSL路由器那收到DHCP的配置信息。</p>
<h4 id=简化配置参数>简化配置参数<a hidden class=anchor aria-hidden=true href=#简化配置参数>#</a></h4>
<p>如果你经常需要以不同的网络配置选项运行QEMU，就会发现时常得输入大量的<code>-netdev</code>和<code>-device</code>选项组合，这些是大量重复性的劳动。可以用<code>-nic</code>选项将二者结合，就如下面这样，底下这些参数：</p>
<pre tabindex=0><code>-netdev tap,id=network0,ifname=tap0,script=no,downscript=no,vhost=on -device virtio-net-pci,netdev=network0
</code></pre><p>可简化为:</p>
<pre tabindex=0><code>-nic tap,script=no,downscript=no,vhost=on,model=virtio-net-pci
</code></pre><p>要注意的是缺失了网络ID，因此将会以<code>model=</code>创建这些设备。{ic|-nic}}命令的前半部分参数正是<code>-netdev</code>的参数，而后半部分参数（<code>model=</code>之后的部分）则与设备有关，原本设备所提供的参数同样可以在此使用（例如，可以指定<code>smb=</code>）。若要完全禁用网络，可以用<code>-nic none</code>。</p>
<h3 id=图形>图形<a hidden class=anchor aria-hidden=true href=#图形>#</a></h3>
<p>QEMU 可以使用一下几个图形输出：std, cirrus, vmware, qxl, xenfs 和 vnc。使用 <code>vnc</code> 选项，你可以单独运行客户机，并且通过 VNC 连接。</p>
<ul>
<li>
<p><strong>std</strong>：使用 <code>-vga std</code> 你可以得到最高 2560 x 1600 像素的分辨率。从 QEMU 2.2 开始是默认选项。</p>
</li>
<li>
<p><strong>qxl</strong>：QXL是一个支持2D的并行虚拟化图形驱动。需要在客户机中安装驱动并在启动QEMU时设置<code>-vga qxl</code>选项。你可能也会想使用<a href=https://wiki.archlinux.org/title/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#SPICE>SPICE</a>优化QXL的图形表现。</p>
<p>在Linux客户机中，需要加载<code>qxl</code>和<code>bochs_drm</code>这两个内核模块，以获得一个比较好的效果。</p>
<p>QXL设备的默认VGA内存大小为16M，这样的内存大小最高支持QHD (2560x1440)的分辨率，如果想要一个更高的分辨率，请<a href=https://wiki.archlinux.org/title/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E5%A4%9A%E5%B1%8F%E6%94%AF%E6%8C%81>增加vga_memmb</a>。</p>
</li>
<li>
<p><strong>virtio</strong>：<code>virtio-vga</code> / <code>virtio-gpu</code> 是一个基于<a href=https://virgil3d.github.io/>virgl</a>的3D并行虚拟化图形驱动。目前依旧处于开发中，仅支持最近的（>= 4.4）的Linux客户机，且需要以<code>gallium-drivers=virgl</code>选项编译<a href="https://archlinux.org/packages/?name=mesa">mesa</a> (>=11.2)。</p>
<p>若要在客户机上启用3D加速，那么需要用<code>-vga virtio</code>选项选择此vga，并用<code>-display sdl,gl=on</code>或<code>-display gtk,gl=on</code>在显示设备上启用opengl上下文，这两个选项分别适用于sdl输出和gtk输出。如果配置成功了，那么在客户机的kernel log里可以看到：</p>
<pre tabindex=0><code># dmesg | grep drm 
[drm] pci: virtio-vga detected
[drm] virgl 3d acceleration enabled
</code></pre></li>
<li>
<p><strong>none</strong>：这就像一台完全没有VGA卡的PC，无法通过<code>-vnc</code>访问它。另外，这种情况与使用<code>-nographic</code>选项不同，<code>-nographic</code>会让QEMU模拟VGA卡，只是关闭了SDL输出。</p>
</li>
</ul>
<h3 id=vnc>VNC<a hidden class=anchor aria-hidden=true href=#vnc>#</a></h3>
<p>可以用<code>-vnc :X</code>选项将QEMU的VGA输出重定向至VNC会话中。将<code>X</code>替换为输出目标的编号（0代表之后监听在5900，1代表监听在5901&mldr;）。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ qemu-system-x86_64 -vnc :0
</code></pre></div><p><strong>警告：</strong> 默认的VNC服务器没有使用任何验证手段，用户可以从任何主机上连接到VNC。</p>
<h4 id=基本的口令验证>基本的口令验证<a hidden class=anchor aria-hidden=true href=#基本的口令验证>#</a></h4>
<p>可以通过使用<code>password</code>选项很容易地设置访问口令。必须在QEMU Monitor中指定口令，仅当用户提供口令时才有可能连接到VNC。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ qemu-system-x86_64 -vnc :0,password -monitor stdio
</code></pre></div><p>在QEMU Monitor中设置口令需使用<code>change vnc password</code>命令，然后指定一个口令。</p>
<p>底下的命令将在启动VNC时直接为其设置口令：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ printf <span style=color:#e6db74>&#34;change vnc password\n%s\n&#34;</span> MYPASSWORD | qemu-system-x86_64 -vnc :0,password -monitor stdio
</code></pre></div><p><strong>注意：</strong> 口令被限制在8个字符内，可以用暴力破解的方式猜到口令。因此在公网上推荐使用更细致的保护措施。</p>
<h3 id=音频>音频<a hidden class=anchor aria-hidden=true href=#音频>#</a></h3>
<p><code>-audiodev</code>标识用于设定后端音频驱动及其相关选项。最简单的情况下，你需要选择一个驱动并设置一个id。</p>
<pre tabindex=0><code>-audiodev pa,id=snd0
</code></pre><h4 id=使用音频设备>使用音频设备<a hidden class=anchor aria-hidden=true href=#使用音频设备>#</a></h4>
<p><strong>Intel HD Audio</strong></p>
<p>模拟Intel HD Audio需要添加控制器和编解码器设备。可以用如下命令列出可用的Intel HDA Audio设备：</p>
<pre tabindex=0><code>$ qemu-system-x86_64 -device help | grep hda
</code></pre><p>添加音频控制器：</p>
<pre tabindex=0><code>-device ich9-intel-hda
</code></pre><p>添加音频编解码器并将其映射到宿主机的音频后端id上。</p>
<pre tabindex=0><code>-device hda-output,audiodev=snd0
</code></pre><p><strong>Intel 82801AA AC97</strong></p>
<p>模拟AC97需要添加声卡设备并将其映射到宿主机的一个音频后端id上。</p>
<pre tabindex=0><code>-device AC97,audiodev=snd0
</code></pre><h4 id=无音频设备>无音频设备<a hidden class=anchor aria-hidden=true href=#无音频设备>#</a></h4>
<p>通过如下命令获取支持模拟的音频驱动列表：</p>
<pre tabindex=0><code>$ qemu-system-x86_64 -soundhw help
</code></pre><p>比如，要在客户机上模拟<code>hda</code>驱动，需要使用<code>-device intel-hda -device hda-duplex</code>选项启动QEMU。</p>
<p><strong>注意：</strong> 客户机的显卡模拟驱动可能也会导致客户机中的音频质量出现问题，需要一个个进行排查。使用<code>qemu-system-x86_64 -h | grep vga</code>列出可用的选项</p>
<h3 id=安装-virtio-驱动>安装 virtio 驱动<a hidden class=anchor aria-hidden=true href=#安装-virtio-驱动>#</a></h3>
<p>QEMU为用户提供并行虚拟化块设备和网络设备的能力，其是借助<a href=https://wiki.libvirt.org/page/Virtio>virtio</a>驱动实现的，拥有更好的性能表现以及更低的开销。</p>
<p>virtio块设备需要使用<code>-drive</code>指定一个disk image的参数，且需要带上<code>if=virtio</code>参数：</p>
<pre tabindex=0><code>$ qemu-system-x86_64 -boot order=c -drive file=disk_image,if=virtio
</code></pre><p>网络配置也是类似的：</p>
<pre tabindex=0><code>$ qemu-system-x86_64 -nic user,model=virtio-net-pci
</code></pre><p><strong>注意：</strong> 仅有当客户机有virtio设备对应的驱动时该方法才能起效，Linux是有这方面支持的，不过无法保证这些驱动能够兼容其他操作系统。</p>
<p>以下以windows为例。</p>
<h4 id=块设备驱动>块设备驱动<a hidden class=anchor aria-hidden=true href=#块设备驱动>#</a></h4>
<p>Windows没有自带virtio驱动，因此需要在安装时加载该驱动。镜像文件可以从<a href=https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/stable-virtio/virtio-win.iso>Fedora 仓库</a>下载。</p>
<p>通过ISO加载只对Windows Vista和Windows Server 2008及其之后的版本有效。这个方法的具体操作是在主磁盘设备和Windows安装盘外挂载一个额外的cdrom设备，将系统镜像与virtio驱动一同加载：</p>
<pre tabindex=0><code>$ qemu-system-x86_64 ... \
-drive file=windows_disk_image,index=0,media=disk,if=virtio \
-drive file=windows.iso,index=2,media=cdrom \
-drive file=virtio.iso,index=3,media=cdrom \
...
</code></pre><p>在安装过程中，Windows Installer会询问你“Where do you want to install Windows?”，其会返回一个警告表示没有找到任何磁盘设备。接下来跟着如下示例中的步骤进行操作（基于Windows Server 2012 R2 with Update）：</p>
<ul>
<li>Select the option <em>Load Drivers</em>.</li>
<li>Uncheck the box for <em>Hide drivers that are not compatible with this computer&rsquo;s hardware</em>.</li>
<li>Click the browse button and open the CDROM for the virtio iso, usually named &ldquo;virtio-win-XX&rdquo;.</li>
<li>Now browse to <code>E:\viostor\[your-os]\amd64</code>, select it, and confirm.</li>
</ul>
<p>现在应该能看到virtio磁盘出现在列表中了，等待着被选中、格式化并安装。</p>
<h4 id=网络驱动>网络驱动<a hidden class=anchor aria-hidden=true href=#网络驱动>#</a></h4>
<p>安装virtio网络驱动程序要容易一些，只需如上所述添加<code>-net</code>参数即可。</p>
<pre tabindex=0><code>$ qemu-system-i386 -m 4G -vga std -drive file=windows_disk_image,if=virtio -net nic,model=virtio-net-pci -cdrom virtio-win-0.1-185.iso
</code></pre><p>Windows将检测网络适配器并尝试为其找到驱动程序。如果失败，请转到“设备管理器”，找到带有感叹号图标的网络适配器（双击打开），切换到驱动程序并单击“更新驱动程序”，然后选择虚拟CD-ROM。别忘了选中显示要递归搜索目录的复选框。</p>
<h4 id=balloon-驱动>Balloon 驱动<a hidden class=anchor aria-hidden=true href=#balloon-驱动>#</a></h4>
<p>如果想要追踪客户机内存状态（比如通过virsh的dommemstat命令）或者在运行时改变客户机内存大小（尽管依然无法改变实际的内存大小，不过可以通过inflating balloon驱动限制内存的使用），那么请在客户机上安装balloon驱动吧。</p>
<h3 id=qemu-监视器>QEMU 监视器<a hidden class=anchor aria-hidden=true href=#qemu-监视器>#</a></h3>
<p>QEMU运行时会提供一个监视器console界面以方便用户同虚拟机进行交互。QEMU监视器提供了许多有趣的功能，例如获取当前虚拟机的信息，热插拔设备，创建快照等。在QEMU监视器console中运行<code>help</code>或<code>?</code>命令获得完整的命令列表。</p>
<h4 id=访问qemu监视器console>访问QEMU监视器Console<a hidden class=anchor aria-hidden=true href=#访问qemu监视器console>#</a></h4>
<p><strong>图形化界面</strong></p>
<p>当使用默认的<code>std</code>图形选项时，可以通过按下<code>Ctrl+Alt+2</code>组合键或从QEMU窗口上的<em>View > compatmonitor0</em>访问到QEMU监视器。若要返回到虚拟机的图形界面，那么按下<code>Ctrl+Alt+1</code>或者<em>View > VGA</em>就行。</p>
<p>然而，这种标准的访问方式不够方便，而且并不是在QEMU的所有图形化输出方式中都适用。</p>
<p><strong>Telnet</strong></p>
<p>启动QEMU时带上<code>-monitor telnet:127.0.0.1:*port*,server,nowait</code>参数可以启用<a href=https://wiki.archlinux.org/title/Telnet>telnet</a>。虚拟机启动后可以通过telnet访问到监视器：</p>
<pre tabindex=0><code>$ telnet 127.0.0.1 port
</code></pre><p><strong>注意：</strong> 如果指定 <code>127.0.0.1</code> 作为监听地址，那么只能在运行QEMU的宿主机上连接到该监视器。如果想要远程访问，QEMU需要在<code>0.0.0.0</code>上进行监听：<code>-monitor telnet:0.0.0.0:*port*,server,nowait</code>。还要记住的是，最好对<a href=https://wiki.archlinux.org/title/Firewall>firewall</a>进行配置，该连接是完全不进行认证和加密的，因此需要通过防火墙确保本地网络环境是可信的。</p>
<p><strong>UNIX socket</strong></p>
<p>通过<code>-monitor unix:*socketfile*,server,nowait</code>参数运行QEMU，之后就可以通过<a href="https://archlinux.org/packages/?name=socat">socat</a>或<a href="https://archlinux.org/packages/?name=openbsd-netcat">openbsd-netcat</a>连接到监视器上。</p>
<p>例如，如果QEMU是通过如下命令启动：</p>
<pre tabindex=0><code>$ qemu-system-x86_64 [...] -monitor unix:/tmp/monitor.sock,server,nowait [...]
</code></pre><p>就可以像这样连接到监视器上：</p>
<pre tabindex=0><code>$ socat - UNIX-CONNECT:/tmp/monitor.sock
</code></pre><p>或者通过这种方式:</p>
<pre tabindex=0><code>$ nc -U /tmp/monitor.sock
</code></pre><p><strong>TCP</strong></p>
<p>可以使用<code>-monitor tcp:127.0.0.1:*port*,server,nowait</code>参数将监视器暴露于TCP端口上，然后用netcat（<a href="https://archlinux.org/packages/?name=openbsd-netcat">openbsd-netcat</a>或<a href="https://archlinux.org/packages/?name=gnu-netcat">gnu-netcat</a>都可）进行连接：</p>
<pre tabindex=0><code>$ nc 127.0.0.1 port
</code></pre><p><strong>注意：</strong> 为了能够从其它设备上通过TCP socket访问到监视器，而不仅仅从运行QEMU的主机上连接，需要像前面Telnet中描述的那样，在<code>0.0.0.0</code>地址上进行监听。</p>
<p><strong>标准 I/O</strong></p>
<p>如果以<code>-monitor stdio</code>参数运行QEMU，那么其实是可以在运行QEMU的终端下访问到监视器的。</p>
<h4 id=在monitor-conosle下向虚拟机发送按键行为>在Monitor conosle下向虚拟机发送按键行为<a hidden class=anchor aria-hidden=true href=#在monitor-conosle下向虚拟机发送按键行为>#</a></h4>
<p>由于在某些配置下，宿主机可能会拦截一些按键组合另作他用，这导致要在虚拟机中触发一些特定按键组合变得有些困难（一个显然的例子就是<code>Ctrl+Alt+F*</code>组合，该组合用于改变当前的tty）。我们采用在monitor console下发送按键组合的方式解决该问题。只需切换到monitor console下，然后使用<code>sendkey</code>命令，即可将按键转发至虚拟机中，例如：</p>
<pre tabindex=0><code>(qemu) sendkey ctrl-alt-f2
</code></pre><h4 id=通过-monitor-console-创建快照和管理快照>通过 monitor console 创建快照和管理快照<a hidden class=anchor aria-hidden=true href=#通过-monitor-console-创建快照和管理快照>#</a></h4>
<p><strong>注意：</strong> 该特性"只"支持<em>qcow2</em>格式的虚拟机磁盘镜像，对于<em>raw</em>是无效的。</p>
<p>有时候我们很需要将虚拟机的当前状态进行保存，或是将虚拟机重置到之前的快照状态，而且最好是随时能进行这些操作。QEMU monitor console为用户提供了必要的功能，进行快照创建，快照管理，以及快照恢复。</p>
<ul>
<li>Use <code>savevm name</code> 用于创建一个名为<em>name</em>的快照。</li>
<li>Use <code>loadvm name</code> 用于将虚拟机状态恢复至快照<em>name</em>。</li>
<li>Use <code>delvm name</code> 用于删除快照<em>name</em>。</li>
<li>Use <code>info snapshots</code> 用于查看保存的快照列表，这些快照由一个自增长的ID和标签名（用户创建快照时赋予）进行标识。</li>
</ul>
<h4 id=以冻结模式运行虚拟机>以冻结模式运行虚拟机<a hidden class=anchor aria-hidden=true href=#以冻结模式运行虚拟机>#</a></h4>
<p>QEMU支持以冻结态运行虚拟机（需使用<code>-snapshot</code>参数），换句话说，虚拟机关闭时，对于虚拟机的一切修改都会丢弃。当用户对磁盘镜像写入时，这些变动最终写入的位置是<code>/tmp</code>目录下的一个临时文件，QEMU关机时将会把他们丢弃。</p>
<p>不过，即使虚拟机运行于冻结状态下，依旧可以通过monitor console将这些变化写入磁盘镜像（如果你想的话）。使用下面的命令：</p>
<pre tabindex=0><code>(qemu) commit all
</code></pre><p>另外如果在冻结状态下创建快照，这些快照在QEMU退出时都会被丢弃，除非你显式地commit了他们。</p>
<h4 id=monitor-console中的开机和暂停命令>monitor console中的开机和暂停命令<a hidden class=anchor aria-hidden=true href=#monitor-console中的开机和暂停命令>#</a></h4>
<p>在QEMU monitor console下也可以模拟对物理机的一些操作：</p>
<ul>
<li><code>system_powerdown</code> 会向虚拟机发送ACPI关机信号，效果就类似物理机上按下电源按钮。</li>
<li><code>system_reset</code> 会重置虚拟机，类似物理机上的重置按钮。该操作可能导致数据丢失或文件系统的损坏，这是因为虚拟机并不是"干净地"重启的。</li>
<li><code>stop</code> 会暂停虚拟机。</li>
<li><code>cont</code> 使暂停的虚拟机恢复运行。</li>
</ul>
<h4 id=虚拟机截屏>虚拟机截屏<a hidden class=anchor aria-hidden=true href=#虚拟机截屏>#</a></h4>
<p>可以在monitor console下运行该命令，获取PPM格式的截屏图片：</p>
<pre tabindex=0><code>(qemu) screendump file.ppm
</code></pre><h3 id=pci-passthrough-via-ovmfhttpswikiarchlinuxorgtitlepci_passthrough_via_ovmf_e7ae80e4bd93e4b8ade69687><a href=https://wiki.archlinux.org/title/PCI_passthrough_via_OVMF_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)>PCI passthrough via OVMF</a><a hidden class=anchor aria-hidden=true href=#pci-passthrough-via-ovmfhttpswikiarchlinuxorgtitlepci_passthrough_via_ovmf_e7ae80e4bd93e4b8ade69687>#</a></h3>
<h4 id=笔记本-optimus-muxless-下的-intel-和-nvidia-虚拟机显卡直通httpslantianpubarticlemodify-computerlaptop-intel-nvidia-optimus-passthroughlantian><a href=https://lantian.pub/article/modify-computer/laptop-intel-nvidia-optimus-passthrough.lantian>笔记本 Optimus MUXless 下的 Intel 和 NVIDIA 虚拟机显卡直通</a><a hidden class=anchor aria-hidden=true href=#笔记本-optimus-muxless-下的-intel-和-nvidia-虚拟机显卡直通httpslantianpubarticlemodify-computerlaptop-intel-nvidia-optimus-passthroughlantian>#</a></h4>
<p>受到MUXless架构本身的限制，显卡直通有非常大的局限，例如很多游戏无法调用独显、操作麻烦、显示性能仍然较低等。因此，现阶段可以为了折腾而尝试，但不建议用于实用用途。</p>
<h4 id=optimus-muxed-笔记本上的-nvidia-虚拟机显卡直通httpslantianpubarticlemodify-computerlaptop-muxed-nvidia-passthroughlantian><a href=https://lantian.pub/article/modify-computer/laptop-muxed-nvidia-passthrough.lantian>Optimus MUXed 笔记本上的 NVIDIA 虚拟机显卡直通</a><a hidden class=anchor aria-hidden=true href=#optimus-muxed-笔记本上的-nvidia-虚拟机显卡直通httpslantianpubarticlemodify-computerlaptop-muxed-nvidia-passthroughlantian>#</a></h4>
<h3 id=技巧-1>技巧<a hidden class=anchor aria-hidden=true href=#技巧-1>#</a></h3>
<h4 id=改善虚拟机的性能表现>改善虚拟机的性能表现<a hidden class=anchor aria-hidden=true href=#改善虚拟机的性能表现>#</a></h4>
<p>底下是一些可以改善虚拟机性能表现的技术，例如：</p>
<ul>
<li>
<p>启用<a href=https://wiki.archlinux.org/title/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E5%90%AF%E7%94%A8_KVM>#启用 KVM</a>：QEMU的启动命令加上<code>-enable-kvm</code>选项。</p>
</li>
<li>
<p>通过<code>-cpu host</code>选项让QEMU模拟宿主机上的特定CPU，如果没有该选项QEMU尝试模拟的是一个更为通用的CPU。</p>
</li>
<li>
<p>特别的，如果客户机是Windows，启用<a href=https://blog.wikichoon.com/2014/07/enabling-hyper-v-enlightenments-with-kvm.html>Hyper-V enlightenments</a>可以改善性能：<code>-cpu host,hv_relaxed,hv_spinlocks=0x1fff,hv_vapic,hv_time</code>.</p>
</li>
<li>
<p>如果宿主机有多个核心，可以用<code>-smp</code>选项为客户机分配更多核心。</p>
</li>
<li>
<p>检查是否为虚拟机分配的足够的内存。默认情况下，QEMU仅仅为每台虚拟机分配128MiB的内存，可以使用<code>-m</code>选项分配更多的内存。例如，<code>-m 1024</code>代表启动一台内存为1024MiB的虚拟机。</p>
</li>
<li>
<p>如果客户机操作系统支持相关的驱动，可以使用<a href=https://wiki.libvirt.org/page/Virtio>virtio</a>创建网络设备或块设备。</p>
</li>
<li>
<p>使用TAP设备代替user-mode网络，参阅<a href=https://wiki.archlinux.org/title/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#Tap_%E7%BD%91%E7%BB%9C>#Tap 网络</a>。</p>
</li>
<li>
<p>如果客户机需要进行大量的磁盘写工作，在宿主机文件系统上设置合适的挂载选项可以优化该工作。例如，可以用<code>barrier=0</code>选项挂载一个<a href=https://wiki.archlinux.org/title/Ext4>ext4 file system</a>。在使用这些性能强化选项之前最好阅读相关文档，因为性能上的提升通常伴随着数据完整性下降的代价。</p>
</li>
<li>
<p>如果有一块原始磁盘镜像，你可能会想要禁用cache：</p>
<pre tabindex=0><code>$ qemu-system-x86_64 -drive file=disk_image,if=virtio,cache=none
</code></pre></li>
<li>
<p>使用原生的Linux AIO：</p>
<pre tabindex=0><code>$ qemu-system-x86_64 -drive file=disk_image,if=virtio,aio=native,cache.direct=on
</code></pre></li>
<li>
<p>如果正同时运行多台虚拟机，而它们拥有同样的操作系统，可以通过启用<a href=https://en.wikipedia.org/wiki/Kernel_SamePage_Merging_(KSM)>内核页归并</a>节省内存。参阅<a href=https://wiki.archlinux.org/title/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E5%BC%80%E5%90%AFKSM>#开启KSM</a>。</p>
</li>
<li>
<p>在一些情况下，可以在运行时从安装了balloon驱动的客户机上回收内存，这需要QEMU启动该客户机时使用<code>-device virtio-balloon</code>选项。</p>
</li>
<li>
<p>允许使用一个ICH-9 AHCI控制器的仿真层，尽管它并不稳定。AHCI的仿真模拟支持<a href=https://en.wikipedia.org/wiki/Native_Command_Queuing>NCQ</a>，因此可以同时处理多个读写请求：</p>
<pre tabindex=0><code>$ qemu-system-x86_64 -drive id=disk,file=disk_image,if=none -device ich9-ahci,id=ahci -device ide-drive,drive=disk,bus=ahci.0
</code></pre></li>
</ul>
<p>参阅 <a href=https://www.linux-kvm.org/page/Tuning_KVM>https://www.linux-kvm.org/page/Tuning_KVM</a> 获取更多信息</p>
<h4 id=开机时启动qemu虚拟机>开机时启动QEMU虚拟机<a hidden class=anchor aria-hidden=true href=#开机时启动qemu虚拟机>#</a></h4>
<p><strong>通过libvirt实现</strong></p>
<p>如果虚拟机是通过<a href=https://wiki.archlinux.org/title/Libvirt>libvirt</a>设置的，可以用<code>virsh autostart</code>将其配置为开机自启，或者通过<em>virt-manager</em>GUI中虚拟机的Boot Options，选择"Start virtual machine on host boot up"实现开机自启。</p>
<p><strong>通过systemd service实现</strong></p>
<p>可以用如下的systemd unit和config配置开机时启动QEMU VM。</p>
<pre tabindex=0><code>/etc/systemd/system/qemu@.service
[Unit]
Description=QEMU virtual machine

[Service]
Environment=&quot;haltcmd=kill -INT $MAINPID&quot;
EnvironmentFile=/etc/conf.d/qemu.d/%i
ExecStart=/usr/bin/qemu-system-x86_64 -name %i -enable-kvm -m 512 -nographic $args
ExecStop=/bin/bash -c ${haltcmd}
ExecStop=/bin/bash -c 'while nc localhost 7100; do sleep 1; done'

[Install]
WantedBy=multi-user.target
</code></pre><p><strong>注意：</strong> 为了方便地结束任务，该service会等待至console端口被释放（这意味着VM已被关闭）。</p>
<p>接着创建per-VM配置文件，命名为<code>/etc/conf.d/qemu.d/*vm_name*</code>，在其中设置好<code>args</code>和<code>haltcmd</code>变量，配置示例：</p>
<pre tabindex=0><code>/etc/conf.d/qemu.d/one
args=&quot;-hda /dev/vg0/vm1 -serial telnet:localhost:7000,server,nowait,nodelay \
 -monitor telnet:localhost:7100,server,nowait,nodelay -vnc :0&quot;

haltcmd=&quot;echo 'system_powerdown' | nc localhost 7100&quot; # or netcat/ncat
/etc/conf.d/qemu.d/two
args=&quot;-hda /srv/kvm/vm2 -serial telnet:localhost:7001,server,nowait,nodelay -vnc :1&quot;

haltcmd=&quot;ssh powermanager@vm2 sudo poweroff&quot;
</code></pre><p>对该变量的描述如下：</p>
<ul>
<li><code>args</code> - 使用的QEMU命令行参数。</li>
<li><code>haltcmd</code> - 安全关闭虚拟机的命令，在第一个例子中，QEMU monitor是通过<code>-monitor telnet:..</code>选项暴露至telnet，因而关闭虚拟机是通过<code>nc</code>命令在monitor console中发送<code>system_powerdown</code>，完成ACPI关机的工作。在另一个例子里，使用的则是SSH。</li>
</ul>
<p>若要设置启动时运行哪个虚拟机，enable <code>qemu@*vm_name*.service</code>这个systemd单元</p>
<h4 id=鼠标整合>鼠标整合<a hidden class=anchor aria-hidden=true href=#鼠标整合>#</a></h4>
<p>添加<code>-usb -device usb-tablet</code>选项以避免点击客户机系统的窗口时鼠标被捕获。该选项代表QEMU能够在不捕获鼠标的情况下，向系统报告鼠标的位置，该选项启用时还会覆盖PS/2鼠标模拟功能。 命令示例：</p>
<pre tabindex=0><code>$ qemu-system-x86_64 -hda disk_image -m 512 -usb -device usb-tablet
</code></pre><h4 id=宿主机的usb设备传递至虚拟机>宿主机的USB设备传递至虚拟机<a hidden class=anchor aria-hidden=true href=#宿主机的usb设备传递至虚拟机>#</a></h4>
<p>从客户机访问连接到宿主机USB口的设备是可能的，首先需要识别设备连接的位置，可以用<code>lsusb</code>命令找到设备连接位置，例如：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ lsusb
...
Bus <span style=color:#ae81ff>003</span> Device 007: ID 0781:5406 SanDisk Corp. Cruzer Micro U3
</code></pre></div><p>上面以显示的数字分别用于标识</p>
<ul>
<li>003 host_bus</li>
<li>007 host_addr</li>
<li>0781 vendor_id</li>
<li>5406 product_id</li>
</ul>
<p>基本的思想是在QEMU中<code>-device usb-ehci,id=ehci</code>或<code>-device qemu-xhci,id=xhci</code>分别对EHCI (USB 2)或XHCI (USB 3)（在win7无法自动安装 USB3 驱动，因此应用 USB2）控制器进行模拟，然后将物理设备通过<code>-device usb-host,..</code>选项进行添加。</p>
<p>识别出该设备，并将其连接至任一总线以及宿主机上的地址，通用的语法如下：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>-device usb-host,bus<span style=color:#f92672>=</span>controller_id.0,vendorid<span style=color:#f92672>=</span>0xvendor_id,productid<span style=color:#f92672>=</span>0xproduct_id
</code></pre></div><p>应用于上面例子中使用的设备，它变成：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>-device usb-ehci,id<span style=color:#f92672>=</span>ehci -device usb-host,bus<span style=color:#f92672>=</span>ehci.0,vendorid<span style=color:#f92672>=</span>0x0781,productid<span style=color:#f92672>=</span>0x5406
</code></pre></div><p>运行QEMU时会遇到 <code>libusb couldn't open USB device Permission denied</code> 权限错误，可以通过 <a href=https://wiki.archlinux.org/title/Udev#About_udev_rules>udev</a> 为设备设定合适的权限。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ vi /etc/udev/rules.d/50-usbtinyisp.rules
SUBSYSTEMS<span style=color:#f92672>==</span><span style=color:#e6db74>&#34;usb&#34;</span>, ATTRS<span style=color:#f92672>{</span>idVendor<span style=color:#f92672>}==</span><span style=color:#e6db74>&#34;0781&#34;</span>, ATTRS<span style=color:#f92672>{</span>idProduct<span style=color:#f92672>}==</span><span style=color:#e6db74>&#34;5406&#34;</span>, GROUP<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;vane&#34;</span>, MODE<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;0660&#34;</span>

$ ls -al /dve/bus/usb/003/007
crw-rw---- <span style=color:#ae81ff>1</span> root vane 189, <span style=color:#ae81ff>11</span> Nov  <span style=color:#ae81ff>7</span> 12:37 /dev/bus/usb/003/007
</code></pre></div><h4 id=使用spice进行usb重定向>使用SPICE进行USB重定向<a hidden class=anchor aria-hidden=true href=#使用spice进行usb重定向>#</a></h4>
<p>使用<a href=https://wiki.archlinux.org/title/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#SPICE>SPICE</a>时可以将USB设备从客户端重定向至虚拟机中，无需使用QEMU命令。还支持为配置USB重定向插槽数（插槽数将决定可同时重定向的最大设备数）。相比于前面那种使用<code>-usbdevice</code>进行重定向的方法，SPICE方法的优势在于可以在虚拟机启动后USB设备热插拔，移除或添加USB设备时无需停机。这个方法还允许通过网络将客户端的USB设备重定向至服务端。总之，其是在QEMU虚拟机中使用USB设备最灵活的方法。</p>
<h4 id=开启ksm>开启KSM<a hidden class=anchor aria-hidden=true href=#开启ksm>#</a></h4>
<p>Kernel Samepage Merging (KSM) 是Linux内核的一个特性，允许应用程序向内核申请同其他申请页归并的进程进行页归并，KSM机制允许客户虚拟机之间进行页共享。当许多客户机运行相似的操作系统时，这个机制可以节省客观的内存。</p>
<h4 id=多屏支持>多屏支持<a hidden class=anchor aria-hidden=true href=#多屏支持>#</a></h4>
<p>Linux的QXL驱动支持默认支持四头（虚拟屏幕），可以通过<code>qxl.heads=N</code>这一内核参数进行变更。</p>
<h4 id=复制和粘贴>复制和粘贴<a hidden class=anchor aria-hidden=true href=#复制和粘贴>#</a></h4>
<p>在宿主机和客户机之间共享剪贴板的方法之一是使用SPICE远程桌面协议，通过SPICE客户端访问客户机，你需要遵照<a href=https://wiki.archlinux.org/title/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#SPICE>SPICE</a>节中描述的步骤，通过该方式运行的客户机将支持与宿主机进行复制粘贴的操作。</p>
<h3 id=libvirthttpswikiarchlinuxorgtitlelibvirt_e7ae80e4bd93e4b8ade69687><a href=https://wiki.archlinux.org/title/Libvirt_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)>libvirt</a><a hidden class=anchor aria-hidden=true href=#libvirthttpswikiarchlinuxorgtitlelibvirt_e7ae80e4bd93e4b8ade69687>#</a></h3>
<p>Libvirt 是一组软件的汇集，提供了管理虚拟机和其它虚拟化功能（如：存储和网络接口等）的便利途径。这些软件包括：一个长期稳定的 C 语言 API、一个守护进程（libvirtd）和一个命令行工具（virsh）。Libvirt 的主要目标是提供一个单一途径以管理多种不同虚拟化方案以及虚拟化主机，<a href=https://libvirt.org/drivers.html>包括</a>：KVM/QEMU，Xen，LXC，OpenVZ 或 VirtualBox hypervisors。</p>
<p>Libvirt 的一些主要功能如下：</p>
<ul>
<li><strong>VM management（虚拟机管理）</strong>：各种虚拟机生命周期的操作，如：启动、停止、暂停、保存、恢复和迁移等；多种不同类型设备的热插拔操作，包括磁盘、网络接口、内存、CPU等。</li>
<li><strong>Remote machine support（支持远程连接）</strong>：Libvirt 的所有功能都可以在运行着 libvirt 守护进程的机器上执行，包括远程机器。通过最简便且无需额外配置的 SSH 协议，远程连接可支持多种网络连接方式。</li>
<li><strong>Storage management（存储管理）</strong>：任何运行 libvirt 守护进程的主机都可以用于管理多种类型的存储：创建多种类型的文件镜像（qcow2，vmdk，raw，&mldr;），挂载 NFS 共享，枚举现有 LVM 卷组，创建新的 LVM 卷组和逻辑卷，对裸磁盘设备分区，挂载 iSCSI 共享，以及更多&mldr;&mldr;</li>
<li><strong>Network interface management（网络接口管理）</strong>：任何运行 libvirt 守护进程的主机都可以用于管理物理的和逻辑的网络接口，枚举现有接口，配置（和创建）接口、桥接、VLAN、端口绑定。</li>
<li><strong>Virtual NAT and Route based networking（虚拟 NAT 和基于路由的网络）</strong>：任何运行 libvirt 守护进程的主机都可以管理和创建虚拟网络。Libvirt 虚拟网络使用防火墙规则实现一个路由器，为虚拟机提供到主机网络的透明访问。</li>
</ul>
<h4 id=安装httpsubuntucomserverdocsvirtualization-libvirt><a href=https://ubuntu.com/server/docs/virtualization-libvirt>安装</a><a hidden class=anchor aria-hidden=true href=#安装httpsubuntucomserverdocsvirtualization-libvirt>#</a></h4>
<p>基于守护进程/客户端的架构的 libvirt 只需要安装在需要要实现虚拟化的机器上。注意，服务器和客户端可以是相同的物理机器。</p>
<p><strong>服务端</strong></p>
<p>安装 libvirt 以及至少一个虚拟运行环境（hypervisor）：<a href=https://libvirt.org/drvqemu.html>libvirt 的 KVM/QEMU 驱动</a> 是 <em>libvirt</em> 的首选驱动，如果 KVM 功能已启用，则支持全虚拟化和硬件加速的客户机。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sudo apt update
$ sudo apt install qemu-kvm libvirt-daemon-system
</code></pre></div><p>安装 libvirt-daemon-system 后，需要将用于管理虚拟机的用户添加到<em>libvirt</em>组中。这对于 sudo 组的成员是自动完成的，但对于应该访问系统范围的 libvirt 资源的其他任何人，都需要另外完成。这样做将授予用户访问高级网络选项的权限。</p>
<p>在终端中输入：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sudo adduser $USER libvirt
</code></pre></div><p>如果选择的用户是当前用户，您需要注销并重新登录才能使新的组成员身份生效。</p>
<p><strong>客户端</strong></p>
<p>客户端是用于管理和访问虚拟机的用户界面。</p>
<ul>
<li><strong>virsh</strong> — <em>virsh</em> 是用于管理和配置域（虚拟机）的命令行程序。</li>
<li><strong><a href=https://en.wikipedia.org/wiki/Virtual_Machine_Manager>Virtual Machine Manager</a></strong> — 使用libvirt对KVM，Xen，LXC进行管理的图形化工具。</li>
</ul>
<h4 id=配置-1>配置<a hidden class=anchor aria-hidden=true href=#配置-1>#</a></h4>
<p>对于<em><strong>系统</strong></em> 级别的管理任务（如：全局配置和镜像<em>卷</em> 位置），libvirt 要求至少要设置授权和启动守护进程。</p>
<p><strong>注意：</strong> 对于用户<em><strong>会话</strong></em> 级别的管理任务，守护进程的安装和设置<em>不是</em> 必须的。授权总是仅限本地，前台程序将启动一个 <strong>libvirtd</strong> 守护进程的本地实例。</p>
<h5 id=设置授权>设置授权<a hidden class=anchor aria-hidden=true href=#设置授权>#</a></h5>
<p>自 <a href=https://libvirt.org/auth.html#ACL_server_config>libvirt：连接授权</a>：Libvirt 守护进程允许管理员分别为客户端连接的每个网络 socket 选择不同授权机制。这主要是通过 libvirt 守护进程的主配置文件 <code>/etc/libvirt/libvirtd.conf</code> 来实现的。每个 libvirt socket 可以有独立的授权机制配置。目前的可选项有 <code>none</code>、<code>polkit</code> 和 <code>sasl</code>。</p>
<p>由于 libvirt 在安装时将把 polkit 作为依赖一并安装，所以 polkit 通常是 <code>unix_sock_auth</code> 参数的默认值。但基于文件的权限仍然可用。</p>
<p><strong>使用 polkit</strong></p>
<p><strong>注意：</strong> 为使 <code>polkit</code> 认证工作正常，应该重启一次系统。</p>
<p><em>libvirt</em> 守护进程在 polkit 策略配置文件（<code>/usr/share/polkit-1/actions/org.libvirt.unix.policy</code>）中提供了两种<strong>策略</strong>：</p>
<ul>
<li><code>org.libvirt.unix.manage</code> 面向完全的管理访问（读写模式后台 socket），以及</li>
<li><code>org.libvirt.unix.monitor</code> 面向仅监视察看访问（只读 socket）。</li>
</ul>
<p>默认的面向读写模式后台 socket 的策略将请求认证为管理员。这点类似于 sudo 认证，但它并不要求客户应用最终以 root 身份运行。默认策略下也仍然允许任何应用连接到只读 socket。</p>
<p><strong>基于文件的权限授权</strong></p>
<p>为了给 <em>libvirt</em> 组用户定义基于文件的权限以管理虚拟机，取消下列行的注释：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ vim /etc/libvirt/libvirtd.conf
<span style=color:#75715e>#unix_sock_group = &#34;libvirt&#34;</span>
<span style=color:#75715e>#unix_sock_ro_perms = &#34;0777&#34;  # set to 0770 to deny non-group libvirt users</span>
<span style=color:#75715e>#unix_sock_rw_perms = &#34;0770&#34;</span>
<span style=color:#75715e>#auth_unix_ro = &#34;none&#34;</span>
<span style=color:#75715e>#auth_unix_rw = &#34;none&#34;</span>
</code></pre></div><p>有些资料提到可以通过改变某些特定 libvirt 目录的权限以简化管理。需要记住的是：包更新时，这些变更会丢失。如要修改这些系统目录的权限，需要 root 用户权限。</p>
<h5 id=守护进程>守护进程<a hidden class=anchor aria-hidden=true href=#守护进程>#</a></h5>
<p><code>libvirtd.service</code> 和 <code>virtlogd.service</code>这两个服务单元都要启动。可以把 <code>libvirtd.service</code> 设置为启用，这时系统将同时启用 <code>virtlogd.service</code> 和 <code>virtlockd.socket</code> 两个服务单元，因此后二者不必再设置为<strong>启用</strong>。</p>
<h4 id=测试>测试<a hidden class=anchor aria-hidden=true href=#测试>#</a></h4>
<p>测试 libvirt 在<em>系统</em>级工作是否正常：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ virsh -c qemu:///system
</code></pre></div><p>测试 libvirt 在用户<em>会话</em>级工作是否正常：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ virsh -c qemu:///session
</code></pre></div><h4 id=管理>管理<a hidden class=anchor aria-hidden=true href=#管理>#</a></h4>
<p>绝大部分的 libvirt 管理可以通过三个工具实现：<code>virt-manager</code>（图形界面）、<code>virsh</code> 和 <code>guestfish</code>（它是 <code>libguestfs</code> 的一部分）。</p>
<h5 id=virsh>virsh<a hidden class=anchor aria-hidden=true href=#virsh>#</a></h5>
<p>Visrsh 用于管理客户<em>域</em>（虚拟机），在脚本式虚拟化管理环境中工作良好。由于需要通过通讯管道与虚拟运行环境通讯，绝大部分 virsh 命令需要管理员权限。尽管如此，一些典型的管理操作如域的创建、运行等也可以像VirtualBox 那样以普通用户身份执行。</p>
<p>Virsh 允许带命令行选项执行。如果不带则进入其内置的交互式终端：<code>virsh</code>。交互式终端支持 tab 键命令补全。</p>
<p>从命令行执行：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ virsh <span style=color:#f92672>[</span>可选项<span style=color:#f92672>]</span> &lt;命令&gt; <span style=color:#f92672>[</span>参数<span style=color:#f92672>]</span>...
</code></pre></div><p>在交互式终端里运行：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>virsh <span style=color:#75715e># &lt;命令&gt; [参数]...</span>
</code></pre></div><p>帮助也是可用的：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ virsh help <span style=color:#f92672>[</span>option*<span style=color:#f92672>]</span> or <span style=color:#f92672>[</span>group-keyword*<span style=color:#f92672>]</span>
</code></pre></div><h5 id=存储池>存储池<a hidden class=anchor aria-hidden=true href=#存储池>#</a></h5>
<p>存储池是指保存<em>卷</em>的位置。Libvirt 中<em>卷</em>的定义相当于其他系统中<em>虚拟磁盘</em>或<em>虚拟机镜像</em>的概念。存储池应该是一个目录、一个网络文件系统或一个分区（此处包括 LVM）。存储池可以在活动与不活动之间切换，可以为其分配存储空间。</p>
<p>以下示例为<em>添加</em>存储池、目录和 LVM 卷的方法：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ virsh pool-define-as name type <span style=color:#f92672>[</span>source-host<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>source-path<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>source-dev<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>source-name<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>&lt;target&gt;<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>--source-format format<span style=color:#f92672>]</span>
$ virsh pool-define-as poolname dir - - - - /home/username/.local/libvirt/images
$ virsh pool-define-as poolname fs - -  /dev/vg0/images - mntpoint
</code></pre></div><p>上述示例仅仅定义了存储池的信息，下面创建它：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ virsh pool-build     poolname
$ virsh pool-start     poolname
$ virsh pool-autostart poolname
</code></pre></div><p>删除它的命令：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ virsh pool-undefine  poolname
</code></pre></div><p>提示： 对于 LVM 存储池而言：</p>
<ul>
<li>最佳实践是仅把一个卷组分配给一个存储池。</li>
<li>请为存储池选择一个与 LVM 卷组不同的名字。否则当存储池被删除时，该卷组也将被删除。</li>
</ul>
<p>用 virt-manager 新建存储池</p>
<p>首先，连接到虚拟运行环境（例如QEMU/KVM的系统/用户会话）。然后，右键点击一个连接（例如<strong>QEMU/KVM</strong>）选择<strong>详情</strong>，切换到<strong>存储</strong>选项卡，点击左下角的**+**，按照向导操作。</p>
<h5 id=存储卷>存储卷<a hidden class=anchor aria-hidden=true href=#存储卷>#</a></h5>
<p>存储池被创建之后，就可以在存储池中创建存储卷。如果你想新建一个域（虚拟机），那么这一步可以跳过，因为这一步可以在创建域的过程中完成。</p>
<p>用 virsh 新建卷</p>
<p>新建卷，列出卷，变更卷大小，删除卷：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ virsh vol-create-as      poolname volumename 10GiB --format aw|bochs|raw|qcow|qcow2|vmdk
$ virsh vol-upload  --pool poolname volumename volumepath
$ virsh vol-list           poolname
$ virsh vol-resize  --pool poolname volumename 12GiB
$ virsh vol-delete  --pool poolname volumename
$ virsh vol-dumpxml --pool poolname volumename  <span style=color:#75715e># for details.</span>
</code></pre></div><h5 id=域>域<a hidden class=anchor aria-hidden=true href=#域>#</a></h5>
<p>虚拟机被称作“域”。如果你想在命令行下操作，使用<code>virsh</code>列出，创建，暂停，关闭……域。<code>virt-viewer</code>可以用来查看使用<code>virsh</code>启动的域。域的创建通常以图形化的<code>virt-manager</code>或者命令行下的<code>virt-install</code>完成。 创建新域通常需要安装媒介，例如存储池中的<code>iso</code>文件或是直接从光驱安装。</p>
<p>列出活动的和不活动的域：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># virsh list --all</span>
</code></pre></div><p>用 virt-install 新建域</p>
<p>对于很详细的域（虚拟机）配置，可以用 virt-manager 新建域更简单地完成。但是，基础配置同样可以用<code>virt-install</code>完成并且同样运行顺利。至少要配置<code>--name</code>, <code>--memory</code>, 存储(<code>--disk</code>, <code>--filesystem</code>,或<code>--nodisks</code>),和安装方法（通常来说是<code>.iso</code>文件或CD）。查看<a href=https://man.archlinux.org/man/virt-install.1>virt-install(1)</a>得到未列出的选项和更多的详情。</p>
<p>Windows:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ virt-install <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  --name<span style=color:#f92672>=</span>windows7           <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  --memory <span style=color:#ae81ff>2048</span>             <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  --cdrom /dev/sr0          <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  --os-variant<span style=color:#f92672>=</span>win7         <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  --disk /mnt/storage/domains/windows7.qcow2,size<span style=color:#f92672>=</span>20GiB <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  --network network<span style=color:#f92672>=</span>vm-net  <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  --graphics spice
</code></pre></div><p>导入现有的卷：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ virt-install  <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  --name demo  <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  --memory <span style=color:#ae81ff>512</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  --disk /home/user/VMs/mydisk.img <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  --import
</code></pre></div><p>用 virt-manager 新建域</p>
<p>首先，连接到虚拟运行环境（例如 QEMU/KVM <em>system</em> 或用户 <em>session</em>，在连接上右击并选择 <em>新建</em>，然后跟随向导完成。</p>
<ul>
<li>在第四[步中取消选中<strong>立即分配全部虚拟磁盘空间</strong>会加快创建过程并节省实际虚拟磁盘空间占用；<strong>然而</strong>，这将导致将来花费额外的磁盘整理时间。</li>
<li>在<strong>第五步</strong>中打开<strong>高级选项</strong>并确认<strong>虚拟化类型</strong>设为 <strong>kvm</strong>（这通常是首选模式）。如果要求附加的硬件配置，选中<strong>安装前定制</strong>选项。</li>
</ul>
<p><strong>管理域</strong></p>
<p>启动域：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ virsh start domain
$ virt-viewer --connect qemu:///session domain
</code></pre></div><p>正常关闭域；强制关闭域:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ virsh shutdown domain
$ virsh destroy  domain
</code></pre></div><p>在libvirtd启动时自动启动域:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ virsh autostart domain
$ virsh autostart domain --disable
</code></pre></div><p>在宿主机关闭时自动关闭域:</p>
<p>使用<code>libvirt-guests.service</code>Systemd服务，运行中的域可以在宿主机关闭时自动挂起/关闭。同时这个服务还可以让挂起/休眠的域在宿主机启动的时候自动恢复。查看<code>/etc/conf.d/libvirt-guests</code>并设置相关选项。</p>
<p>编辑一个域的XML配置：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ virsh edit domain
</code></pre></div><p><strong>注意：</strong> 直接被QEMU启动的虚拟机不被libvirt管理。</p>
<h5 id=网络-2>网络<a hidden class=anchor aria-hidden=true href=#网络-2>#</a></h5>
<p><a href=https://jamielinux.com/docs/libvirt-networking-handbook/>这里</a>是有关 libvirt 网络的一个正宗的概述。</p>
<p>默认情况下，当 <code>libvirtd</code> 服务启动后，即创建了一个名为 <em>default</em> 的 NAT 网桥与外部网络联通（仅 IPv4）。对于其他的网络连接需求，可创建下列四种类型的网络以连接到虚拟机：</p>
<ul>
<li>bridge — 这是一个虚拟设备，它通过一个物理接口直接共享数据。使用场景为：宿主机有 <em>静态</em> 网络、不需与其它域连接、要占用全部进出流量，并且域运行于 <em>系统</em> 层级。有关如何在现有默认网桥时增加另一个网桥的方法，请参阅 <a href=https://wiki.archlinux.org/title/%E7%BD%91%E6%A1%A5>网桥</a>。网桥创建后，需要将它指定到相应客户机的 <code>.xml</code> 配置文件中。</li>
<li>network — 这是一个虚拟网络，它可以与其它虚拟机共用。使用场景为：宿主机有 <em>动态</em> 网络（例如：NetworkManager）或使用无线网络。</li>
<li>macvtap — 直接连接到宿主机的一个物理网络接口。</li>
<li>user — 本地网络，仅用于用户 <em>会话</em>。</li>
</ul>
<p>绝大多数用户都可以通过 <code>virsh</code> 的各种可选项创建具有各种功能的网络，一般来说比通过 GUI 程序（像 <code>virt-manager</code> 之类）更容易做到。也可以按用 virt-install 新建域 所述实现。</p>
<p><strong>注意：</strong> libvirt 通过 dnsmasq 处理 DHCP 和 DNS 请求，以启动每个虚拟网络的不同实例。也会为特定的路由添加 iptables 规则并启用 <code>ip_forward</code> 内核参数。这也意味着宿主机上已运行的dnsmasq并不是libvirt所必须的（并可能干扰到libvirt的dnsmasq实例）。</p>
<h4 id=uefi-支持>UEFI 支持<a hidden class=anchor aria-hidden=true href=#uefi-支持>#</a></h4>
<p>Libvirt 可以通过 qemu 和 <a href=https://github.com/tianocore/edk2>OVMF</a> 来支持 UEFI 虚拟机。 安装 ovmf 。 添加下面的内容到 <code>/etc/libvirt/qemu.conf</code> 。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ vim /etc/libvirt/qemu.conf
nvram <span style=color:#f92672>=</span> <span style=color:#f92672>[</span>
    <span style=color:#e6db74>&#34;/usr/share/ovmf/x64/OVMF_CODE.fd:/usr/share/ovmf/x64/OVMF_VARS.fd&#34;</span>
<span style=color:#f92672>]</span>
</code></pre></div><p>重启 <code>libvirtd</code></p>
<p>现在你可以创建一个 UEFI 虚拟机了。 你可以通过 <a href="https://archlinux.org/packages/?name=virt-manager">virt-manager</a> 来创建。当你进行到向导的最后一步时：</p>
<ul>
<li>勾选<strong>在安装前自定义配置</strong>，之后点击<strong>完成</strong>。</li>
<li>在<strong>概况</strong>屏幕, 将固件改为&rsquo;UEFI x86_64'。</li>
<li>点击<strong>开始安装</strong></li>
<li>在启动屏幕，你需要使用linuxefi命令来启动安装程序，并且你需要在系统中运行efibootmgr验证确实运行在UEFI模式下。</li>
</ul>
<h4 id=virt-manager-shared-folders-with-linux-guesthttpsntsstrzibnynamehow-to-set-up-shared-folders-in-virt-manager>virt-manager: <a href=https://nts.strzibny.name/how-to-set-up-shared-folders-in-virt-manager/>Shared folders with Linux Guest</a><a hidden class=anchor aria-hidden=true href=#virt-manager-shared-folders-with-linux-guesthttpsntsstrzibnynamehow-to-set-up-shared-folders-in-virt-manager>#</a></h4>
<p>Create a future share folder on your host and set up the permissions (for the purpose of this article I will grand all permissions):</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>root@host# mkdir /share
root@host# chmod <span style=color:#ae81ff>777</span> /share
</code></pre></div><p>Afterwards shut down the guest if it’s running and attach the new filesystem in virt-manager:</p>
<ol>
<li>Switch the view to detail hardware view: <strong>View > Details</strong></li>
<li>Go to <strong>Attach hardware > Filesystem</strong></li>
<li>Fill in the name of the source path (<strong>/share</strong> in our case) and virtual target path (anything you like, I will go with <strong>/sharepoint</strong>)</li>
<li>Switch <strong>mode to Mapped</strong> if you need to have write access from the guest</li>
<li>Confirm and start the VM again</li>
</ol>
<p>Now you can mount your shared folder from the VM:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>root@guest# mkdir /share
root@guest# mount -t 9p -o trans<span style=color:#f92672>=</span>virtio /sharepoint /share
</code></pre></div><p>Or permanently add it to /etc/fstab file:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>root@guest# cat /etc/fstab
...
/sharepoint   /share    9p  trans<span style=color:#f92672>=</span>virtio,version<span style=color:#f92672>=</span>9p2000.L,rw    <span style=color:#ae81ff>0</span>   <span style=color:#ae81ff>0</span>
</code></pre></div><h4 id=virt-manager-shared-folders-with-windows-guesthttpsaskubuntucoma1127273>virt-manager: <a href=https://askubuntu.com/a/1127273>Shared folders with Windows Guest</a><a hidden class=anchor aria-hidden=true href=#virt-manager-shared-folders-with-windows-guesthttpsaskubuntucoma1127273>#</a></h4>
<p>You can not add a shared folder in virt-manager like it is described in your article because the filesystem passthrough doesn&rsquo;t work well with a windows guest.</p>
<p>To solve your problem you have several options:</p>
<ol>
<li>You can share a folder in the local network at your linux host system via SAMBA and access it over the windows filesystem directly.</li>
<li>You can use <code>spice-webdav</code> to share a folder like it is described in <a href=https://www.guyrutenberg.com/2018/10/25/sharing-a-folder-a-windows-guest-under-virt-manager/>this article from Guy Rutenberg</a>. This is not recommend for transferring large files.</li>
<li>If you only want to transfer data one or two times instead of having a permanent shared folder you can pack the data in your host system into a <code>.iso</code> file and add it in virt-manager as a disc to access it in the windows guest system.</li>
</ol>
<h4 id=virt-manager-change-default-storage-pool-locationhttpsostechnixcomhow-to-change-kvm-libvirt-default-storage-pool-location>virt-manager: <a href=https://ostechnix.com/how-to-change-kvm-libvirt-default-storage-pool-location/>Change Default Storage Pool Location</a><a hidden class=anchor aria-hidden=true href=#virt-manager-change-default-storage-pool-locationhttpsostechnixcomhow-to-change-kvm-libvirt-default-storage-pool-location>#</a></h4>
<p>在Create a new virtual machine 的 Setp4 of 5 的时候，选择 Selec or create custom sorage 就行。</p>
<h3 id=qemu-kvm-win7httpswwwcnblogscomsammyliup5740129html><a href=https://www.cnblogs.com/sammyliu/p/5740129.html>QEMU-KVM Win7</a><a hidden class=anchor aria-hidden=true href=#qemu-kvm-win7httpswwwcnblogscomsammyliup5740129html>#</a></h3>
<h4 id=环境准备>环境准备<a hidden class=anchor aria-hidden=true href=#环境准备>#</a></h4>
<ol>
<li>
<p>安装QEMU：<code>sudo apt install qemu-kvm samba</code></p>
</li>
<li>
<p>下载 Windows virtio driver iso：https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/archive-virtio/virtio-win-0.1.102/，因为要将磁盘挂接为 virtio 磁盘。</p>
<p>需使用 virtio-win-0.1.102，我使用 latest 的 virtio-win-0.1.208.iso，Windows安装程序会提示驱动没有包含签名错误<code>No signed device drivers were found. Make sure that the installation media contains the correct drivers, and then click OK</code></p>
</li>
<li>
<p>创建系统盘 <code>qemu-img create -f qcow2 Windows7-VM.img 30G</code>，这将作为Win7的操作系统盘。</p>
</li>
<li>
<p>创建启动脚本</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ vi start_Windows7_VM.sh
<span style=color:#75715e>#!/bin/bash</span>
DISKIMG<span style=color:#f92672>=</span>$HOME/.vm/Windows7-VM.img
exec qemu-system-x86_64 --enable-kvm <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    -cpu host,hv_relaxed,hv_spinlocks<span style=color:#f92672>=</span>0x1fff,hv_vapic,hv_time <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    -drive file<span style=color:#f92672>=</span><span style=color:#e6db74>${</span>DISKIMG<span style=color:#e6db74>}</span>,if<span style=color:#f92672>=</span>virtio <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    -net nic,model<span style=color:#f92672>=</span>virtio-net-pci -net user,smb<span style=color:#f92672>=</span>$HOME/Downloads <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    -m <span style=color:#ae81ff>8192</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    -smp sockets<span style=color:#f92672>=</span>1,cores<span style=color:#f92672>=</span>4,threads<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    -monitor stdio <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    -vnc :0 <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    -audiodev pa,id<span style=color:#f92672>=</span>snd0 -device ich9-intel-hda -device hda-output,audiodev<span style=color:#f92672>=</span>snd0 <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    -usb -device usb-tablet <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    -rtc base<span style=color:#f92672>=</span>localtime,clock<span style=color:#f92672>=</span>host  <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    -name <span style=color:#e6db74>&#39;Windows7 VM&#39;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    $@

$ chmod u+x start_Windows7_VM.sh
</code></pre></div></li>
<li>
<p><code>./start_Windows7_VM.sh -boot d -cdrom $HOME/Downloads/cn_windows_7_ultimate_x64_dvd_x15-66043.iso -drive file=$HOME/Downloads/virtio-win-0.1.102.iso,index=3,media=cdrom</code></p>
</li>
</ol>
<p><a href=https://www.cnblogs.com/gotopower/p/3298764.html><strong>smp,socket,cores,threads几个参数的理解</strong></a></p>
<p>结合physical server上lscpu命令的输出，对它们的关系梳理了一番</p>
<pre tabindex=0><code>[root@pqsfc018 ~]# lscpu
...
CPU(s):        32
...
Thread(s) per core:  2
Core(s) per socket:  8
Socket(s):       2
...
</code></pre><ul>
<li>socket就是主板上插cpu的槽的数目，也就是可以插入的物理CPU的个数。</li>
<li>core就是我们平时说的“核“，每个物理CPU可以双核，四核等等。</li>
<li>thread就是每个core的硬件线程数，即超线程</li>
</ul>
<p>具体例子，上面这台服务器的CPU配置是2个socket，每个socket是8个core，每个core是超线程（2），这样，整台机器的对外的core就是2<em>8</em>2=32</p>
<p>SMP，对称多处理器（Symmetric Multi-Processors，简称SMP）是指在一个计算机上汇集了一组处理器(多CPU),各CPU之间共享内存子系统以及总线结构。在这种技术的支持下，一个服务器系统可以同时运行多个处理器，并共享内存和其他的主机资源。像双至强，也就是我们所说的二路，这是在对称处理器系统中最常见的一种（至强MP可以支持到四路，AMD Opteron可以支持1-8路）。也有少数是16路的。但是一般来讲，SMP结构的机器可扩展性较差，很难做到100个以上多处理器，常规的一般是8个到16个，不过这对于多数的用户来说已经够用了。在高性能服务器和工作站级主板架构中最为常见，像UNIX服务器可支持最多256个CPU的系统，其实qemu从代码设计上也是最大支持256个virtual cpu。</p>
<h4 id=安装-win-7>安装 Win 7<a hidden class=anchor aria-hidden=true href=#安装-win-7>#</a></h4>
<ol>
<li>选择 Custom（advanced）</li>
</ol>
<p><img loading=lazy src=/Distributions/697113-20160805095506903-82521289.jpg alt=img>
</p>
<ol start=2>
<li>选择 CD Drive (E:) virtio-win</li>
</ol>
<p><img loading=lazy src=/Distributions/697113-20160805095551856-1022452692.jpg alt=img>
</p>
<ol start=3>
<li>选择 viostor</li>
</ol>
<p><img loading=lazy src=/Distributions/697113-20160805095644122-1127564092.jpg alt=img>
</p>
<ol start=4>
<li>安装 Win7 Virtio SCSI Driver</li>
</ol>
<p><img loading=lazy src=/Distributions/697113-20160805095724137-1062705244.jpg alt=img>
</p>
<ol start=5>
<li>安装好以后，就可以看到安装的目标磁盘了</li>
</ol>
<p><img loading=lazy src=/Distributions/697113-20160805095804262-1125252105.jpg alt=img>
</p>
<ol start=6>
<li>进入常规的 Win7 安装流程</li>
</ol>
<p><img loading=lazy src=/Distributions/697113-20160805095838481-127974813.jpg alt=img>
</p>
<h4 id=安装-virtio-网络驱动>安装 Virtio 网络驱动<a hidden class=anchor aria-hidden=true href=#安装-virtio-网络驱动>#</a></h4>
<p>选择 NetKVM</p>
<p><img loading=lazy src=/Distributions/697113-20160805100148122-512197961.jpg alt=img>
</p>
<p>但是安装失败：</p>
<p><img loading=lazy src=/Distributions/697113-20160805100403059-506876837.jpg alt=img>
</p>
<p>尝试 device manager 安装：</p>
<p><img loading=lazy src=/Distributions/697113-20160805100907340-1175076487.jpg alt=img>
</p>
<h4 id=qemu-的内置smb服务器qemu-的内置smb服务器>[QEMU 的内置SMB服务器](#QEMU 的内置SMB服务器)<a hidden class=anchor aria-hidden=true href=#qemu-的内置smb服务器qemu-的内置smb服务器>#</a></h4>
<h4 id=宿主机的usb设备传递至虚拟机宿主机的usb设备传递至虚拟机><a href=#%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%9A%84USB%E8%AE%BE%E5%A4%87%E4%BC%A0%E9%80%92%E8%87%B3%E8%99%9A%E6%8B%9F%E6%9C%BA>宿主机的USB设备传递至虚拟机</a><a hidden class=anchor aria-hidden=true href=#宿主机的usb设备传递至虚拟机宿主机的usb设备传递至虚拟机>#</a></h4>
<h4 id=questions>Questions<a hidden class=anchor aria-hidden=true href=#questions>#</a></h4>
<p>各种缺dll，好烦。</p>
<p><a href=https://www.its203.com/article/qq_31575773/73287513><strong>win7 64位安装wamp缺失vcruntime140.dll和api-ms-win-crt-runtime-l1-1-0.dll 等</strong></a></p>
<p>安装VC redit.exe程序解决，链接：</p>
<ul>
<li><a href=https://download.microsoft.com/download/9/3/F/93FCF1E7-E6A4-478B-96E7-D4B285925B00/vc_redist.x86.exe>https://download.microsoft.com/download/9/3/F/93FCF1E7-E6A4-478B-96E7-D4B285925B00/vc_redist.x86.exe</a></li>
<li><a href=https://download.microsoft.com/download/9/3/F/93FCF1E7-E6A4-478B-96E7-D4B285925B00/vc_redist.x64.exe>https://download.microsoft.com/download/9/3/F/93FCF1E7-E6A4-478B-96E7-D4B285925B00/vc_redist.x64.exe</a></li>
</ul>
<p><a href=https://www.thewindowsclub.com/fix-microsoft-visual-c-install-error-0x80240017><strong>Microsoft Visual C++ Install Error 0x80240017</strong></a></p>
<p>右键 => 兼容性疑难解答</p>
<p><a href=https://stackoverflow.com/questions/37620152/windows7-stop-at-starting-windows-while-intalling-on-kvm><strong>windows7 stop at &ldquo;starting windows&rdquo; while intalling on kvm</strong></a></p>
<p>solved!</p>
<p>Look here:<a href=https://serverfault.com/questions/776406/windows-7-setup-hangs-at-starting-windows-using-proxmox-4-2>Windows 7 Setup hangs at “Starting Windows” using Proxmox 4.2</a></p>
<p>and add this to command line:</p>
<pre tabindex=0><code>--video cirrus
</code></pre><h3 id=qemu-kvm-winxp-sp3>QEMU-KVM WinXP SP3<a hidden class=anchor aria-hidden=true href=#qemu-kvm-winxp-sp3>#</a></h3>
<p>太太太老了，很多软件都不支持了。</p>
<h4 id=windows_xpshhttpsgistgithubcomandrusha1000766><a href=https://gist.github.com/andrusha/1000766>windows_xp.sh</a><a hidden class=anchor aria-hidden=true href=#windows_xpshhttpsgistgithubcomandrusha1000766>#</a></h4>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e>#!/bin/bash
</span><span style=color:#75715e></span>DISKIMG<span style=color:#f92672>=</span>$HOME/.vm/WindowsXP-VM.img
exec qemu-system-x86_64 --enable-kvm <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    -cpu host,hv_relaxed,hv_spinlocks<span style=color:#f92672>=</span>0x1fff,hv_vapic,hv_time <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    -drive file<span style=color:#f92672>=</span><span style=color:#e6db74>${</span>DISKIMG<span style=color:#e6db74>}</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    -net nic,model<span style=color:#f92672>=</span>rtl8139 -net user,smb<span style=color:#f92672>=</span>$HOME/Downloads <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    -m <span style=color:#ae81ff>4096</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    -cpu Nehalem <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    -rtc base<span style=color:#f92672>=</span>localtime,clock<span style=color:#f92672>=</span>host  <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    -usb -device usb-tablet <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    -monitor stdio <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    -vga std <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    $@
</code></pre></div><h5 id=windows-xp-cannot-connect-to-samba-sharehttpsaskubuntucomquestions1268132windows-xp-cannot-connect-to-samba-share-linux-server-20-04><a href=https://askubuntu.com/questions/1268132/windows-xp-cannot-connect-to-samba-share-linux-server-20-04>Windows XP cannot connect to samba share</a><a hidden class=anchor aria-hidden=true href=#windows-xp-cannot-connect-to-samba-sharehttpsaskubuntucomquestions1268132windows-xp-cannot-connect-to-samba-share-linux-server-20-04>#</a></h5>
<p>You have &lsquo;client min protocol = NT1&rsquo; set, there is another similar setting &lsquo;server min protocol&rsquo; which from Samba 4.11.0 is set to SMBv2. Your XP is probably only using SMBv1, so it will not be able to see or connect to your Samba server.</p>
<p>So you have to edit the <code>[global]</code> section in the <code>/etc/samba/smb.conf</code> and add the <code>server min protocol = NT1</code> option here. Then restart the Samba service.</p>
<p>例如：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ ps h -C smbd -o pid,args
<span style=color:#ae81ff>1707</span> /usr/sbin/smbd --foreground --no-process-group
$ vim /tmp/qemu-smb.SL95F1/smb.conf
<span style=color:#f92672>[</span>global<span style=color:#f92672>]</span>
server min protocol <span style=color:#f92672>=</span> NT1
$ sudo smbcontrol <span style=color:#ae81ff>1707</span> reload-config
</code></pre></div><p>或者编写如下脚本</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e>#!/bin/bash
</span><span style=color:#75715e></span>echo <span style=color:#e6db74>&#34;[global]
</span><span style=color:#e6db74>server min protocol = NT1&#34;</span> &gt;&gt; /tmp/**/smb.conf
sudo smbcontrol <span style=color:#66d9ef>$(</span>ps h -C smbd -o pid<span style=color:#66d9ef>)</span> reload-config
</code></pre></div><h5 id=windows-xp-上网提示您的时钟快了慢了httpsblogcsdnnetjohnnysun2015articledetails104888159><a href=https://blog.csdn.net/JohnnySun2015/article/details/104888159>Windows XP 上网提示：您的时钟快了/慢了</a><a hidden class=anchor aria-hidden=true href=#windows-xp-上网提示您的时钟快了慢了httpsblogcsdnnetjohnnysun2015articledetails104888159>#</a></h5>
<p>此时，无论你怎么调整日期和时间，都不能解决上网问题。即使把日期从2020年调整到2015年，此时虽然不在提示 “您的时钟快了”，也有证书期限等异常。</p>
<p>出现这种问题的原因，是因为 Windows XP 确实太老了，Google Chrome、Mozilla Firefox 及其内核的浏览器已经不支持了。</p>
<h4 id=virtual-machine-manager>Virtual Machine Manager<a hidden class=anchor aria-hidden=true href=#virtual-machine-manager>#</a></h4>
<p><a href=https://blog.51cto.com/wsxxsl/1914181><strong>键盘不能输入的问题</strong></a></p>
<p>在 Display 中，设定 keymap，比如 en-us</p>
<p><strong>无网络</strong></p>
<p>在 NIC 中，将 Device model 设置为 rtl8139</p>
<h3 id=qemu-kvm-gentoohttpswikigentooorgwikiqemulinux_guest><a href=https://wiki.gentoo.org/wiki/QEMU/Linux_guest>QEMU-KVM Gentoo</a><a hidden class=anchor aria-hidden=true href=#qemu-kvm-gentoohttpswikigentooorgwikiqemulinux_guest>#</a></h3>
<h4 id=configuration>Configuration<a hidden class=anchor aria-hidden=true href=#configuration>#</a></h4>
<h5 id=host>Host<a hidden class=anchor aria-hidden=true href=#host>#</a></h5>
<p>To create a disk image for the virtual machine, run:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ qemu-img create -f qcow2 Gentoo-VM.img 30G
</code></pre></div><p>Download a minimal Gentoo LiveCD from <a href=https://www.gentoo.org/downloads/>here</a>.</p>
<p>Since QEMU requires a lot of <a href=https://wiki.gentoo.org/wiki/QEMU/Options>options</a>, it would be a good idea to put them into a shell script, e.g.:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ vim start_Gentoo_VM.sh
<span style=color:#75715e>#!/bin/bash</span>
DISKIMG<span style=color:#f92672>=</span>$HOME/VirtualMachine/Gentoo-VM.img
exec qemu-system-x86_64 -enable-kvm <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>        -bios /usr/share/edk2-ovmf/OVMF_CODE.fd <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>        -cpu host <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>        -drive file<span style=color:#f92672>=</span><span style=color:#e6db74>${</span>DISKIMG<span style=color:#e6db74>}</span>,if<span style=color:#f92672>=</span>virtio <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>        -netdev user,id<span style=color:#f92672>=</span>vmnic,hostname<span style=color:#f92672>=</span>Gentoo-VM,hostfwd<span style=color:#f92672>=</span>tcp::10022-:22,smb<span style=color:#f92672>=</span>$HOME/Downloads <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>        -device virtio-net,netdev<span style=color:#f92672>=</span>vmnic <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>        -device virtio-rng-pci <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>        -m 4G <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>        -smp sockets<span style=color:#f92672>=</span>1,cores<span style=color:#f92672>=</span>4,threads<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>        -monitor stdio <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>        -vnc :0 <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>        -audiodev pa,id<span style=color:#f92672>=</span>snd0 -device ich9-intel-hda -device hda-output,audiodev<span style=color:#f92672>=</span>snd0 <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>        
        -rtc base<span style=color:#f92672>=</span>localtime,clock<span style=color:#f92672>=</span>host  <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>        -name <span style=color:#e6db74>&#34;Gentoo VM&#34;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>        $@

$ chmod u+x start_Gentoo_VM.sh
</code></pre></div><p>Change the path to your disk image Gentoo-VM.img in the script. You can add more options when calling the script. To boot the disk image, run:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ ./start_Gentoo_VM.sh -boot d -cdrom $HOME/Downloads/install-amd64-minimal-20211107T170547Z.iso
</code></pre></div><p>Install the guest per the <a href=https://wiki.gentoo.org/wiki/Handbook:Main_Page>Gentoo Handbook</a>. See the <a href=https://wiki.gentoo.org/wiki/QEMU/Linux_guest#Guest>guest section</a> for optimum support. After the installation start the script without the additional options.</p>
<h5 id=using-uefi-with-qemuhttpsfedoraprojectorgwikiusing_uefi_with_qemu><a href=https://fedoraproject.org/wiki/Using_UEFI_with_QEMU>Using UEFI with QEMU</a><a hidden class=anchor aria-hidden=true href=#using-uefi-with-qemuhttpsfedoraprojectorgwikiusing_uefi_with_qemu>#</a></h5>
<p>UEFI for x86 QEMU/KVM VMs is called OVMF (Open Virtual Machine Firmware). It comes from EDK2 (EFI Development Kit), which is the UEFI reference implementation.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sudo apt-get install ovmf 
</code></pre></div><p><a href=https://www.ubuntubuzz.com/2021/04/how-to-boot-uefi-on-qemu.html>检查是否安装</a>，命令为：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ dpkg -L ovmf | grep OVMF.fd 
/usr/share/ovmf/ OVMF.fd
/usr/share/qemu/ OVMF.fd
</code></pre></div><p>要在虚拟机中运行操作系统的映像文件，添加 <code>-bios /usr/share/ovmf/OVMF.fd</code>。该代码调用名为 OVMF.fd 的文件，该文件是 Qemu 的 UEFI 固件。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ qemu-system-x86_64 -bios /usr/share/ovmf/OVMF.fd -cdrom ubuntu-21.04-desktop-amd64.iso
</code></pre></div><p>这个名为<em>ovmf的</em>包其实就是名为TianoCore的程序。该名称本身代表<a href=https://github.com/tianocore/tianocore.github.io/wiki/OVMF-FAQ#what-is-open-virtual-machine-firmware-ovmf>开放虚拟机固件</a>)。</p>
<p><a href=https://github.com/utmapp/UTM/issues/2333><strong>&ldquo;BdsDxe: failed to load Boot0001&rdquo;</strong></a></p>
<p><a href=https://www.reddit.com/r/Proxmox/comments/ckfthg/vm_no_longer_boots_after_creating_windows_10_vm/>solution</a>: Try hitting F2 to enter the OVMF settings during guest boot and manually pick a new boot drive option.</p>
<h3 id=virtualbox>VirtualBox<a hidden class=anchor aria-hidden=true href=#virtualbox>#</a></h3>
<p><strong>执行 .vbs 文件</strong></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ cscript test.vbs
</code></pre></div><p><strong>删除备份</strong></p>
<p>删除虚拟机备份，当前状态前一个备份删除得快，两个备份之间的备份删除得慢。</p>
<p><strong>共享文件夹</strong></p>
<p>固定分配的共享文件夹对于定义共享文件夹的虚拟机是永久存在的；</p>
<p>临时分配的共享文件夹在虚拟机运行时添加/删除，虚拟机关闭后消失。</p>
<p><strong><a href=https://blog.csdn.net/lionwerson/article/details/104976028>把img系统镜像转为VDI或VMDK格式文件</a></strong></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ VBoxManage convertdd *.img  *.vdi
</code></pre></div><p>在 virtualbox 新建虚拟机时指定 vdi 硬盘文件，就可以安装系统</p>
<p><a href=https://blog.lilydjwg.me/2018/2/14/start-local-other-os-in-virtualbox.212161.html><strong>启动本地磁盘上的其它系统</strong></a></p>
<h4 id=增加现有虚拟机的磁盘大小httpslinuxcnarticle-12869-1html><a href=https://linux.cn/article-12869-1.html>增加现有虚拟机的磁盘大小</a><a hidden class=anchor aria-hidden=true href=#增加现有虚拟机的磁盘大小httpslinuxcnarticle-12869-1html>#</a></h4>
<p>下面是你迟早会遇到的情况。</p>
<p>你在 <a href=https://www.virtualbox.org/>VirtualBox</a> 中安装了一个或多个操作系统。在创建这些虚拟操作系统的同时，你还在 VirtualBox 中为它们创建了虚拟硬盘。</p>
<p>你指定了虚拟磁盘的最大大小，比如说 15 或 20GB，但现在使用了一段时间后，你发现你的虚拟机已经没有空间了。</p>
<p>虽然在 Ubuntu 和其他操作系统上有释放磁盘空间的方法，但更稳健的处理方式是增加 VirtualBox 中创建的虚拟机的磁盘大小。</p>
<p>是的，你可以在 VirtualBox 中扩大虚拟硬盘，即使在创建之后也可以。虽然这是一个安全且经过测试的过程，但我们强烈建议你在执行这样的操作之前，先创建一个虚拟机的备份。</p>
<p>我将向你展示如何在 VirtualBox 中以图形和命令行（对于 Linux 极客）方式调整磁盘大小。这两种方法都很简单直接。</p>
<p><strong>方法 1：在 VirtualBox 中使用虚拟媒体管理器</strong></p>
<p>VirtualBox 6 增加了一个调整虚拟磁盘大小的图形化选项。你可以在 VirtualBox 主页的文件选项卡中找到它。</p>
<p>进入 “File -> Virtual Media Manager”：</p>
<p>在列表中选择一个虚拟机，然后使用 “Size” 滑块或输入你需要的大小值。完成后点击 “Apply”。</p>
<p>请记住，虽然你增加了虚拟磁盘的大小，但<strong>如果你的空间是动态分配的，那么实际的分区大小仍然不变</strong>。</p>
<p><strong>方法 2：使用 Linux 命令行增加 VirtualBox 磁盘空间</strong></p>
<p>如果你使用 Linux 操作系统作为宿主机，在宿主机中打开终端并输入以下命令来调整 VDI 的大小：</p>
<pre tabindex=0><code>VBoxManage modifymedium &quot;/path_to_vdi_file&quot; --resize &lt;megabytes&gt;
</code></pre><p>在你按下回车执行命令后，调整大小的过程应该马上结束。</p>
<blockquote>
<p>注意事项</p>
<p>VirtualBox 早期版本命令中的 <code>*modifyvdi</code> 和 <code>modifyhd</code> 命令也支持，并在内部映射到 <code>modifymedium</code> 命令。</p>
</blockquote>
<p>如果你不确定虚拟机的保存位置，可以在 VirtualBox 主页面点击 “Files -> Preferences” 或使用键盘快捷键 <code>Ctrl+G</code> 找到默认位置。</p>
<h4 id=seamless-modehttpswwwtl80cnarticle43389><a href=https://www.tl80.cn/article/43389>Seamless Mode</a><a hidden class=anchor aria-hidden=true href=#seamless-modehttpswwwtl80cnarticle43389>#</a></h4>
<p>虚拟机通常在一个窗口中运行来宾操作系统及其程序。但是，VirtualBox和VMware都有一些功能，允许您在主机桌面上运行虚拟化程序，从而将它们从监狱中释放出来。&mldr;</p>
<p>这意味着您可以在不使用虚拟机窗口和来宾操作系统桌面的情况下使用程序。如果使用多个监视器，甚至可以将虚拟机中的不同窗口放置在不同的监视器上。</p>
<p><strong>工作原理</strong></p>
<p>所有这些特性都同样工作。启动虚拟机，启动您想要使用的程序，然后启用“无缝模式”或“统一模式”。来宾操作系统的桌面和虚拟机窗口将消失，将来宾操作系统的窗口留在桌面上。它们看起来正在运行，好像它们在您的主机操作系统上运行，但虚拟机仍在后台运行。程序仍然是沙盒，因此它们无法访问主机操作系统的文件——它们似乎正在主机操作系统上运行。</p>
<p>无论您使用的是Windows、Linux还是Mac，这些技巧都有效。您可以在Linux桌面上无缝运行Windows程序，也可以在Windows桌面上运行Linux软件。</p>
<p><strong>使用virtualbox的无缝模式</strong></p>
<p>请注意，VirtualBox只允许您在Windows、Linux和Solaris客户机上使用此功能。如果你设法让MacOSX在VirtualBox虚拟机上运行，或者你正在使用像俳句这样的小众操作系统，你将无法使用这个功能。</p>
<p>在使用此功能之前，必须在要使用的来宾虚拟机内安装VirtualBox来宾添加软件包。如果您还没有这样做，请启动虚拟机，单击“设备”菜单，然后选择“安装来宾添加”。系统将提示您安装软件。</p>
<p>要使用此功能，请同时按“主机键”（通常是右Ctrl键，但它显示在虚拟机窗口的右下角）和“L”。也可以单击“视图”菜单，然后选择“切换到无缝模式”。</p>
<p>VirtualBox将隐藏来宾操作系统的桌面背景，使其看起来好像来宾操作系统的程序正在主机操作系统的桌面上运行。但是，正在运行的应用程序不会出现在操作系统的标准任务栏上。</p>
<p>要退出无缝模式，只需按主机键，然后再次按L。您还可以在任务栏上方找到VirtualBox菜单，您可以将鼠标悬停在上面查看。单击查看并再次选择切换到无缝模式以禁用无缝模式。</p>
<p><strong>使用vmware的unity模式</strong></p>
<p>VMware有一个类似的功能，名为Unity mode。它可以在免费的VMware Player、VMware Workstation和VMware的其他付费应用程序上使用。与VirtualBox一样，VMware的Unity模式适用于Windows和Linux客户机。</p>
<h4 id=vboxwinxp-sp3>VBox+WinXP SP3<a hidden class=anchor aria-hidden=true href=#vboxwinxp-sp3>#</a></h4>
<p><strong><a href=https://www.reddit.com/r/virtualbox/comments/l4yvpy/windows_xp_guest_additions_installation_stuck/>Windows XP; Guest Additions installation stuck; Virtualbox 6.1.18</a></strong></p>
<p>Disconnect network. It helps me.</p>
<h4 id=vs-vmwarehttpswwwzhihucomquestion33701295><a href=https://www.zhihu.com/question/33701295>VS VMWare</a><a hidden class=anchor aria-hidden=true href=#vs-vmwarehttpswwwzhihucomquestion33701295>#</a></h4>
<p>工具是用来解决问题的，没必要看到开源就意识形态附体</p>
<h4 id=虚拟机网络模式httpswwwcnblogscomggjuchengarchive201208192646007html><a href=https://www.cnblogs.com/ggjucheng/archive/2012/08/19/2646007.html>虚拟机网络模式</a><a hidden class=anchor aria-hidden=true href=#虚拟机网络模式httpswwwcnblogscomggjuchengarchive201208192646007html>#</a></h4>
<p><img loading=lazy src=/Distributions/v2-82deb4be7068ec65b3ab251df22d5130_r.jpg alt>
</p>
<p><strong>桥接</strong></p>
<p>桥接网络是指本地物理网卡和虚拟网卡通过VMnet0虚拟交换机进行桥接，物理网卡和虚拟网卡在拓扑图上处于同等地位，那么物理网卡和虚拟网卡就相当于处于同一个网段，虚拟交换机就相当于一台现实网络中的交换机,所以两个网卡的IP地址也要设置为同一网段。</p>
<p>所以当我们要在局域网使用虚拟机，对局域网其他pc提供服务时，例如提供ftp，提供ssh，提供http服务，那么就要选择桥接模式。</p>
<p>例如大学宿舍里有一个路由器，宿舍里四个人连接这个路由器，路由器的wanip就不理会了，这个ip是动态获取的，而lanip默认是192.168.1.1,子网掩码是255.255.255.0。而其他四个人是自动获取ip，假设四个人的ip是:</p>
<p>A:192.168.1.100/255.255.255.0,</p>
<p>B:192.168.1.101/255.255.255.0</p>
<p>C:192.168.1.102/255.255.255.0</p>
<p>D:192.168.1.103/255.255.255.0</p>
<p>那么虚拟机的ip可以设置的ip地址是192.168.1.2-192.168.1.99,192.168.1.104-192.168.1.254 (即网络地址全0和全1的除外，再除去ABCD四个人的ip地址)</p>
<p>那么虚拟机的ip地址可以设置为192.168.1.98/255.255.255.0，设置了这个ip地址，ABCD这四个人就可以通过192.168.1.98访问虚拟机了，如果虚拟机需要上外网，那么还需要配置虚拟机的路由地址，就是192.168.1.1了，这样，虚拟机就可以上外网了，但是，上网我们一般是通过域名去访问外网的，所以我们还需要为虚拟机配置一个dns服务器，我们可以简单点，把dns服务器地址配置为google的dns服务器:8.8.8.8,到此，虚拟机就可以上网了。</p>
<p><strong>NAT</strong></p>
<p>NAT模式中，就是让虚拟机借助NAT(网络地址转换)功能，通过宿主机器所在的网络来访问公网。</p>
<p><img loading=lazy src=/Distribuiptables-tproxy-and-home-1.be8351a6.png alt>
</p>
<p>NAT模式中，虚拟机的网卡和物理网卡的网络，不在同一个网络，虚拟机的网卡，是在vmware提供的一个虚拟网络。</p>
<p>NAT和桥接的比较:</p>
<ul>
<li>NAT模式和桥接模式虚拟机都可以上外网。</li>
<li>由于NAT的网络在vmware提供的一个虚拟网络里，所以局域网其他主机是无法访问虚拟机的，而宿主机可以访问虚拟机，虚拟机可以访问局域网的所有主机，因为真实的局域网相对于NAT的虚拟网络，就是NAT的虚拟网络的外网。</li>
<li>桥接模式下，多个虚拟机之间可以互相访问；NAT模式下，多个虚拟机之间也可以相互访问。</li>
</ul>
<p>如果你建一个虚拟机，只是给自己用，不需要给局域网其他人用，那么可以选择NAT，毕竟NAT模式下的虚拟系统的TCP/IP配置信息是由VMnet8(NAT)虚拟网络的DHCP服务器提供的，只要虚拟机的网路配置是DHCP，那么你不需要进行任何其他的配置，只需要宿主机器能访问互联网即可，就可以让虚拟机联网了。</p>
<p>例如你想建多个虚拟机集群，作为测试使用，而宿主机可能是一个笔记本，ip不固定。这种应用场景，我们需要采用nat模式了，但是我们要考虑一个问题，虚拟机之间是需要互访的，默认采用dhcp，虚拟机的ip每次重启，ip都是不固定的，所以我们需要手工设置虚拟机的ip地址。</p>
<p><strong>Host-Only</strong></p>
<p>在Host-Only模式下，虚拟网络是一个全封闭的网络，它唯一能够访问的就是主机。其实Host-Only网络和NAT网络很相似，不同的地方就是Host-Only网络没有NAT服务，所以虚拟网络不能连接到Internet。主机和虚拟机之间的通信是通过VMware Network Adepter VMnet1虚拟网卡来实现的。</p>
<p>Host-Only的宗旨就是建立一个与外界隔绝的内部网络，来提高内网的安全性。这个功能或许对普通用户来说没有多大意义，但大型服务商会常常利用这个功能。</p>
<h3 id=vmware>VMware<a hidden class=anchor aria-hidden=true href=#vmware>#</a></h3>
<p>用 VMware 的坑：我用普通账户创建虚拟机，然后它安装 vmware tools 需要 root 权限，用 root 权限开启 VMWare 的话，就没有之前的虚拟机了。所以，最好一开始，就用 root 权限运行 VMWare。</p>
<p><a href=https://www.how2shout.com/linux/install-vmware-workstation-player-on-ubuntu-22-04-lts/><strong>Errors- vmware unable to install all modules vmmon vmnet</strong></a></p>
<p>In case you get Gcc not found and Kernel modules compiling error upon starting the Vmware, then you have to install them. For that, first, <strong>close</strong> the Vmware Player window and then run the below two commands:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sudo apt install gcc
$ sudo apt-get install build-essential
</code></pre></div><p>After that start the Vmware player again and start installing the modules. If you still have the error then follow the further steps.</p>
<ul>
<li>Download the latest vmware-host-modules – VMMON and VMNET</li>
</ul>
<p>Visit: <a href=https://github.com/mkubecek/vmware-host-modules/tags>https://github.com/mkubecek/vmware-host-modules</a></p>
<p>There as per your Vmware Player station, download the module file. For example– while doing this article the version of Workstation was 16.2.3, hence we download the same module file in zip format.</p>
<p>The file we download using the browser goes to the Downloads directory. Hence, switch to that.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ cd Downloads
$ sudo apt install unzip
$ unzip vmware-host-modules-w16.2.3-k5.18.zip
$ cd vmware-host-modules-w16.2.3-k5.18
$ tar -cf vmmon.tar vmmon-only
$ tar -cf vmnet.tar vmnet-only
$ sudo cp -v vmmon.tar vmnet.tar /usr/lib/vmware/modules/source/
$ sudo vmware-modconfig --console --install-all
</code></pre></div><p><strong>Uninstall or Remove Vmware Linux</strong></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ cd /usr/bin
$ sudo ./vmware-installer -u vmware-player
</code></pre></div><h4 id=反虚拟机检测httpsvircloudnetexpanti-vm-detectionhtml><a href=https://vircloud.net/exp/anti-vm-detection.html>反虚拟机检测</a><a hidden class=anchor aria-hidden=true href=#反虚拟机检测httpsvircloudnetexpanti-vm-detectionhtml>#</a></h4>
<p>在开发测试中，不少人会选择使用虚拟机环境来进行，以避免对主机产生影响，特别是一些软件类测试，比如病毒分析等VMWare等。在实际测试中会发现，相当一部分软件或代码也在进行反虚拟机来逃避分析，这种技术可以检测自己是否运行在虚拟机中，如果探测到自己在虚拟机中运行，它就会执行与其本身行为不同的行为，这时候就无法达到我们测试的目的了。因此我们可以考虑通过修改配置来达到让虚拟机内运行的软件无法探测到虚拟机环境的目标。</p>
<h5 id=探测方向>探测方向<a hidden class=anchor aria-hidden=true href=#探测方向>#</a></h5>
<p>不管是通过 VMware 还是 Oracle VirtualBox 抑或是 Microsoft Hyper-V，只要是虚拟出来的环境，都或多或少会有痕迹存在，目前用来探测的比较多的痕迹有以下几个。</p>
<p><strong>MAC 地址</strong></p>
<p>这是最明显的特征。通常 MAC 地址的前三个字节标识一个提供商。以 00:05:69、00:0c:29 和00:50:56 开始的 MAC 地址与 VMware 相对应；以 00:03:ff 开始的 MAC 地址与 virtualpc 对应；以 08:00:27 开始的 MAC 地址与 VirtualBox 对应。</p>
<p><strong>其他硬件信息</strong></p>
<p>虚拟机环境中，主板序列号、主机型号、系统盘所在磁盘名称等硬件信息，以及这些硬件采用的驱动，通常都会带有 VMware、VirtualBox、VBOX、Virtual Machine 等字眼。</p>
<p><strong>特定的进程信息</strong></p>
<p>为方便使用，比如自动捕获鼠标、分辨率自适应等，我们会安装 VMware Tools 或者 VBoxGuestAdditions 等增强包，这也是虚拟机环境非常明显的一个特征。通过进程快照读取当前进程信息，查找是否存在虚拟机中特有的进程，如 VMware 中的 vmware.exe 和 VirtualBox 中的 VBoxService.exe。</p>
<p><strong>特定的文件夹或文件信息</strong></p>
<p>通过查找磁盘中是否存在特定的文件夹或文件，判断当前是否在虚拟机中。VMware 虚拟机中通常会有路径 C:\Program Files\VMware\VMware Tools\；VirtualBox 虚拟机中通常会有路径 C:\Program Files\Oracle\VirtualBox Guest Additions\。</p>
<p><strong>特定的注册表信息</strong></p>
<p>通过读取主机具有虚拟机特性的注册表位置来判断是否处于虚拟机环境中。针对 VMware 可以判断注册表项 HKEY_CLASSES_ROOT\Applications\VMwareHostOpen.exe；针对 VirtualBox 可以判断注册表项 HKEY_LOCAL_MACHINE\SOFTWARE\Oracle\VirtualBox Guest Additions。当然，注册表中能被检测出的位置很多，这里只是举个例子。</p>
<p><strong>特定的服务名</strong></p>
<p>通过获取主机当前具有虚拟机特性的服务信息，判断当前主机是否为虚拟机。在 VMware 中通常会存在 VMware 物理磁盘助手服务和VMware Tools服务等；在 VirtualBox 中通常会存在VirtualBox Guest Additions Service服务等。</p>
<p><strong>时间差</strong></p>
<p>由于在虚拟机中，代码的运行速度通常不如真实主机。所以通过运行一段特定的代码来比较这段代码在虚拟机和真实主机之中的相对运行时间，以此来判断是否处于虚拟机之中。</p>
<p><strong>其他</strong></p>
<p>上面说的几种方法都能够检测虚拟机，但检测的方法却不仅限于此，有兴趣的可以再深入研究。</p>
<h5 id=反探测>反探测<a hidden class=anchor aria-hidden=true href=#反探测>#</a></h5>
<p>近年来，随着虚拟化技术的使用不断增加，采用反虚拟机技术的软件数量逐渐下降，编写者已经开始意识到，目标主机是虚拟机，也并不意味着它就没有攻击价值，特别在于目前云计算产业正在如火如荼地发展中。</p>
<p>以 VMware 为例，我们可以通过下面的方法来解决上文探测方向中的大部分痕迹。由于修改信息可能会导致系统激活状态失效，或者修改后配置不生效，故建议在创建虚拟机时就修改好。</p>
<p><strong>修改软件信息</strong></p>
<ul>
<li>VMTools 接口</li>
</ul>
<p>直接将下面的代码贴到虚拟配置文件 .vmx 中（如果是 EXSi，建议通过 WEB 控制面板来修改配置），屏蔽 VMware 特定信息的探测：</p>
<pre tabindex=0><code>isolation.tools.getPtrLocation.disable = &quot;TRUE&quot;
isolation.tools.setPtrLocation.disable = &quot;TRUE&quot;
isolation.tools.setVersion.disable = &quot;TRUE&quot;
isolation.tools.getVersion.disable = &quot;TRUE&quot;
monitor_control.disable_directexec = &quot;TRUE&quot;
monitor_control.disable_chksimd = &quot;TRUE&quot;
monitor_control.disable_ntreloc = &quot;TRUE&quot;
monitor_control.disable_selfmod = &quot;TRUE&quot;
monitor_control.disable_reloc = &quot;TRUE&quot;
monitor_control.disable_btinout = &quot;TRUE&quot;
monitor_control.disable_btmemspace = &quot;TRUE&quot;
monitor_control.disable_btpriv = &quot;TRUE&quot;
monitor_control.disable_btseg = &quot;TRUE&quot;
monitor_control.restrict_backdoor = &quot;TRUE&quot;
</code></pre><p><strong>驱动信息</strong></p>
<p>主要是显卡，先安装 VMware Tools 装好驱动，备份出显卡驱动，然后修改驱动中的安装文件 *.inf，将 STRING 一节中的相关字眼修改掉，再还原驱动。</p>
<pre tabindex=0><code>DiskID = &quot;NVIDIA Windows Driver Library Installation&quot;
CompanyName = &quot;NVIDIA&quot;
SVGA = &quot;GeForce GTX 660&quot;
</code></pre><p>在这一步中，需要安装 VMware Tools 才会有显卡驱动，但是上面修改了配置，将无法安装 VMware Tools，会提示“只应安装在虚拟机内”。由于安装 VMware Tools 将会是一个非常明显的特征，因此不建议安装。且虚拟机驱动其实都是一样的，因此可以从其他虚拟机中导出来直接使用。</p>
<p><strong>修改硬件信息</strong></p>
<ul>
<li>主板信息</li>
</ul>
<p>下面的代码表示延用实体机的主板信息：</p>
<pre tabindex=0><code>SMBIOS.reflecthost = &quot;TRUE&quot;
SMBIOS.noOEMStrings = &quot;TRUE&quot;
SMBIOS.addHostVendor = &quot;TRUE&quot;
hw.model.reflectHost = &quot;TRUE&quot;
serialNumber.reflectHost = &quot;TRUE&quot;
board-id.reflectHost = &quot;TRUE&quot;
</code></pre><p>也可以自己编一个，比如在黑苹果中会用到的：</p>
<pre tabindex=0><code>smbios.reflectHost = &quot;FALSE&quot;
smbios.vendor = &quot;Apple Computer, Inc.&quot;
smbios.version = &quot;MBA51.88Z.0055.B08.0610121&quot;
smbios.family =&quot;MacBook Pro&quot;
smbios.model = &quot;MacBookPro1.1&quot;
smbios.date =&quot;10/12/06&quot;
smbios.manufacturer = &quot;Apple Computer, Inc.&quot;
smbios.systemversion = &quot;1.0&quot;
</code></pre><ul>
<li>磁盘信息</li>
</ul>
<p>如果在 scsi0 插槽上有 SCSI 虚拟磁盘作为系统驱动器，可以添加：</p>
<pre tabindex=0><code>scsi0:0.productID = &quot;WDC_____WD10EZEX-57WN4D11&quot;
scsi0:0.vendorID = &quot;WDC&quot;
</code></pre><p>scsi0:0 表示第一个插槽，其他硬件也可以类似指定 ID。</p>
<ul>
<li>网卡信息</li>
</ul>
<p>参考实体机 MAC 地址信息，自行编一个：</p>
<pre tabindex=0><code>ethernet0.checkMACAddress = &quot;FALSE&quot;
ethernet0.address = &quot;BC:30:5B:DD:D2:E8&quot;
</code></pre><p>以上的方法能够解决大部分的虚拟机探测，但是一些使用寄存器值、任务状态段（Task Status Segment, TSS）、I/O 接口等检测方法的软件，仍然骗不过。</p>
<p>参考文章：</p>
<p>1、《<a href=https://bbs.pediy.com/thread-225735.htm>反虚拟机技术总结</a>》
2、《<a href=https://www.cnblogs.com/kuangke/p/11137223.html>过虚拟机检测</a>》
3、《<a href=https://www.bgegao.com/2019/04/1187.html>解决VMware Tools提示 &ldquo;只应安装在虚拟机内"的问题</a>》
4、《<a href=https://gist.github.com/oXnMe/84bf22ece3c6f483b37294ec9267c840>VM反虚拟机检测</a>》
5、《<a href=https://zhuanlan.zhihu.com/p/27823437>那些年病毒用过的损招——反虚拟机技术</a>》</p>
<p>相关文章：</p>
<p>1、《<a href=https://vircloud.net/linux/vmware-key.html>VMware Workstation Pro 最新版下载及永久激活 KEY 激活码序列号</a>》
2、《<a href=https://vircloud.net/operations/vm-ins-macos-new.html>重制：VMware 15 Pro 安装黑苹果 macOS10.13.5 图文教程：流畅、好用！</a>》</p>
<h4 id=questions-1>Questions<a hidden class=anchor aria-hidden=true href=#questions-1>#</a></h4>
<p><a href=https://winotes.net/fixing-piix4-host-smbus-controller-not-enabled-error-for-centos-on-vmware/><strong>piix4_smbus Host SMBus controller not enabled</strong></a></p>
<p>从内核的说明文档来看，这个 piix4 实际上是 Intel 82371AB 南桥芯片，多功能总线控制器，而在 VMware 里面并没有这个真实的芯片组，但在启动时最会尝试载入这个驱动模块，所以会报错，但对系统没有任何影响。</p>
<h3 id=others>Others<a hidden class=anchor aria-hidden=true href=#others>#</a></h3>
<h4 id=通过-qemu-安装-windows-到硬盘>通过 Qemu 安装 Windows 到硬盘<a hidden class=anchor aria-hidden=true href=#通过-qemu-安装-windows-到硬盘>#</a></h4>
<p>双系统新思路。今天装windows, 在linux上先用虚拟机，把硬盘直通进去，在raw盘上装好，然后更新grub, 再重启就可以直接接进去了。</p>
<p>这样可以避免装机还要做启动盘，装机过程中的重启也可以避免了。</p>
<p>win的安装过程中驱动都是按照虚拟机的配置安装的，但是win10是自动装驱动的，重启进去后过了一会显卡驱动自动都装好了。</p>
<h4 id=boot-a-physical-windows-partition-with-qemuhttpssuperusercoma1204834><a href=https://superuser.com/a/1204834>Boot a physical Windows partition with qemu</a><a hidden class=anchor aria-hidden=true href=#boot-a-physical-windows-partition-with-qemuhttpssuperusercoma1204834>#</a></h4>
<p>Booting an native, physical <em>Windows 7</em> partition can be done by this:</p>
<ol>
<li>Prepare requisites (<em>Windows 7</em> installation media, Virtio drivers).</li>
<li>Make your hard drive accessible read-only for your current user.</li>
<li>Boot it using QEMU in snapshot mode.</li>
</ol>
<p>This does not change <em>anything</em> on the physical drive (in fact it is read-only). If you want to persist the stuff, remove <code>-snapshot</code> from the QEMU invocation or use <code>commit all</code> within the QEMU console.</p>
<p>By the way, this works fine for <em>Windows 10</em> as well.</p>
<hr>
<p><strong>Prepare requisites</strong></p>
<ol>
<li>Prepare an ISO or, if you have a drive at hand, the real installation media for Win7.</li>
<li>Download Virtio drivers, e.g. for example this drivers from Fedora:
<a href=https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/latest-virtio/virtio-win.iso>https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/latest-virtio/virtio-win.iso</a></li>
</ol>
<p>Take care to use the correct installation media matching the installed Windows architecture (32bit vs 64bit). The following commands assume a 64bit architecture.</p>
<p><strong>Make disk accessible</strong></p>
<p>This assumes your hard drive is <code>/dev/sda</code> and has be executed as root:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>chmod g-w /dev/sda
chgrp $USER /dev/sda
</code></pre></div><p>This changes will (probably) be lost at next reboot as <em>udev</em> will usually recreate all device files.</p>
<p><strong>Booting with QEMU</strong></p>
<ol>
<li>
<p>This again assumes your hard drive is <code>/dev/sda</code>. Networking is disabled:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>qemu-system-x86_64 -snapshot -m 3G -enable-kvm -usbdevice tablet <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>-drive file<span style=color:#f92672>=</span>/dev/sda,if<span style=color:#f92672>=</span>virtio <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>-drive file<span style=color:#f92672>=</span>&lt;win7-installation-media&gt; <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>-drive file<span style=color:#f92672>=</span>&lt;virtio-driver-media&gt;,media<span style=color:#f92672>=</span>cdrom -boot d <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>-net none
</code></pre></div></li>
<li>
<p>Now boot from CD/DVD to start <em>Windows 7</em> recovery, load the Virtio driver and run the following command in the recovery command prompt. Ensure that you replace the drive letters with the proper ones:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>dism /image:g:<span style=color:#ae81ff>\ </span>/add-driver /driver:e:<span style=color:#ae81ff>\v</span>iostor<span style=color:#ae81ff>\w</span>7<span style=color:#ae81ff>\a</span>md64
</code></pre></div></li>
</ol>
<p>Drive <code>G:</code> is the drive containing your <em>Windows 7</em> installation. Drive <code>E:</code> represent the CDROM drive with the Virtio drivers. In order to show some help for this command variant use <code>dism /image:g:\ /?</code>.</p>
<p>The <code>dism</code> command was copied from <a href=https://superuser.com/a/1177806/384548>this Super User answer</a>.</p>
<p><strong>补充</strong></p>
<ul>
<li>I also managed to get the drivers installed with <code>drvload.exe E:\amd64\w7\viostor.inf</code></li>
<li><a href=https://www.partitionwizard.com/partitionmanager/cmd-list-drives.html>获取可用驱动器名称</a>：<code>wmic logicaldisk get name</code></li>
<li>结果：启动到了 openSUSE 的 grub，选择 Boot Windows 后蓝屏。</li>
<li>另一个教程 <a href=https://jianmin.dev/2020/jul/19/boot-your-windows-partition-from-linux-using-kvm/>Boot Your Windows Partition from Linux using KVM</a> 使用 RAID 虚拟磁盘解决共享 EFI 分区带来的问题。依云姐姐也写了个教程——<a href=https://blog.lilydjwg.me/2018/2/14/start-local-other-os-in-virtualbox.212161.html>使用 VirtualBox 启动本地磁盘上的其它系统</a>。</li>
</ul>
<h4 id=looking-glasshttpslooking-glassiodocs><a href=https://looking-glass.io/docs>Looking Glass</a><a hidden class=anchor aria-hidden=true href=#looking-glasshttpslooking-glassiodocs>#</a></h4>
<p><strong><a href=https://unwire.hk/2017/12/20/lookingglass/game-channel/>Looking Glass 讓 Linux 可完美玩 Windows 遊戲 超低延遲不掉格</a></strong></p>
<p>當用戶安裝了虛擬電腦（VM）實行 Windows，並執行遊戲時，它採用的 KVM frame relay 技術可將 Windows 顯示記憶體，透過 PCI pass-through 直接由 Windows VM 被配置的顯示卡，複製到 Linux 被配置的顯示卡，這樣 Linux 便可在極為低延遲的情況下，接近完美顯示 Windows 遊戲的內容。</p>
<p>簡單來說，就是一部 Linux 電腦裡面裝有虛擬電腦運行的 Windows，Windows 遊戲實行時，在被配置的顯示卡記憶體資料，在主機板 PCI 通道直接複製到 Linux 被配置的顯示卡。即是說 Windows 遊戲原本畫面，可高速反映到 Liunx 的虛擬電腦軟件上。這樣 Linux 用戶就算不 Dual boot 或使用兩個熒幕，在 Linux 上都可得到接近相同的打機體驗。</p>
<h4 id=xrdphttpsgithubcomneutrinolabsxrdp><a href=https://github.com/neutrinolabs/xrdp>xrdp</a><a hidden class=anchor aria-hidden=true href=#xrdphttpsgithubcomneutrinolabsxrdp>#</a></h4>
<p>xrdp 使用 RDP（Microsoft 远程桌面协议）为远程计算机提供图形登录。xrdp 接受来自各种 RDP 客户端的连接：FreeRDP、rdesktop、NeutrinoRDP 和 Microsoft 远程桌面客户端（适用于 Windows、macOS、iOS 和 Android）。</p>
<p>正如 Windows 到 Windows 远程桌面一样，xrdp 不仅支持图形远程处理，还支持</p>
<ul>
<li>双向剪贴板传输（文本、位图、文件）</li>
<li>音频重定向</li>
<li>驱动器重定向（在远程机器上安装本地客户端驱动器）</li>
</ul>
<p>RDP 传输默认使用 TLS 加密。</p>
<h4 id=qemukvm-vs-virtualbox>QEMU/KVM VS Virtualbox<a hidden class=anchor aria-hidden=true href=#qemukvm-vs-virtualbox>#</a></h4>
<p><a href=https://linuxconfig.org/virtualization-solutions-on-linux-systems-kvm-and-virtualbox><strong>Linux 系统上的虚拟化解决方案 – KVM 和 VirtualBox</strong></a></p>
<p>KVM 提供了一些 VirtualBox 没有的功能，反之亦然。IT 世界中没有通用工具，因此使用适合您需求的工具非常重要。基本思想是：如果你想安装二进制 Linux 发行版作为来宾，使用 KVM。它速度更快，并且它的驱动程序包含在官方内核树中。如果您的客户涉及大量编译并且需要一些更高级的功能，并且/或者不是 Linux 系统，那么最好使用 VirtualBox。</p>
<p>技术原因很简单：KVM 更好地与 Linux 集成，它更小更快，虽然你可以在 Linux 以外的其他客户机上使用它，但我们发现体验相当麻烦：BSD 的 I/O 和 Solaris 往往很慢（确切地说，是 OpenIndiana）在引导安装 ISO 后会立即出现恐慌。由于我们使用当前版本的 BSD（并且经常从源代码编译/更新系统）并且还需要 Solaris，我们发现 VirtualBox 是一个更好的选择。Oracle VirtualBox 的另一个优点是它支持挂起，即您可以将机器状态保存在主机的硬盘上并关闭 VirtualBox，当（重新)启动时，系统将从它离开的地方恢复。这就是为什么我们提到源代码编译：如果你有一台嘈杂的机器，你不想一夜之间离开，但你的 Gentoo 虚拟机只是编译一个新的 gcc 版本，暂停机器状态，关闭主机，明天继续。</p>
<p><a href=https://www.reddit.com/r/sysadmin/comments/by9fkb/desktop_virtualization_kvm_or_virtualbox/><strong>桌面虚拟化、KVM 还是 Virtualbox？</strong></a></p>
<p>这两者中的哪一个更适合在 Linux 台式机/笔记本电脑上运行 Windows 10 虚拟机？</p>
<ul>
<li>
<p><a href=https://virt-manager.org/>带有virt-manager 的</a>QEMU/KVM应该可以与 Virtualbox 媲美。</p>
<p>Virtualbox 没问题，特别是如果跨主机操作系统使用相同的虚拟化很重要，但 QEMU/KVM 是更好的投资。QEMU/HAXM 也应该可以在 Mac 和 Windows 上运行，尽管它目前还不够成熟。</p>
</li>
<li>
<p>KVM, obviously. You&rsquo;re probably going to need to learn how to manage it, but it is a much better system and allows abstraction on completely unexposed CPU hardware so you can easily take your image and put it onto another KVM. Windows doesn&rsquo;t like to have it&rsquo;s CPUs exchange on it very often.</p>
</li>
</ul>
<p><a href=https://www.cpqlinux.com/kvm-vs-virtualbox/><strong>KVM 与 VirtualBox</strong></a></p>
<ul>
<li>
<p>表现</p>
<p>这是要考虑的最重要的领域之一，即管理程序的性能将如何影响您的基础架构。KVM 是 1 类管理程序（这些虚拟机管理程序直接运行在宿主机的硬件上来控制硬件和管理客操作系统），而 VirtualBox 是 2 类管理程序（这些虚拟机管理程序运行在传统的操作系统上，就像其他计算机程序那样运行），这意味着 KVM 应该优于 VirtualBox。</p>
<p><a href=https://www.spec.org/virt_sc2013/>根据SPECvirt_sc2013 基准测试</a>，VirtualBox 通常比 KVM 需要更多时间来创建和启动服务器，而 KVM 以接近本机的速度运行应用程序，比其他行业管理程序更快。尽管对于典型负载，差异可能微不足道。</p>
</li>
<li>
<p>管理程序管理</p>
<p>这两个给定的应用程序都可以通过 GUI 进行管理。Virtualbox 相对来说有更好的 GUI，但 KVM 的当前 GUI 使其管理比以往任何时候都更容易。”</p>
<p>如果您更喜欢命令行，那么 KVM 中有各种命令行选项。Virtualbox 也提供了一个命令行界面，但它不如 KVM virsh 全面。您不能直接从 bash 启动 Virtualbox VM。</p>
</li>
<li>
<p>可扩展性</p>
<p>KVM 继承了 Linux 的性能，如果来宾机器和请求的数量增加，可以扩展以匹配需求负载。KVM 允许对要求最苛刻的应用程序工作负载进行虚拟化，并且是许多企业虚拟化设置的基础，例如数据中心和私有云。</p>
<p>VirtualBox 可以为每个 VM 提供多达 32 个虚拟 CPU，而不管主机上物理存在多少 CPU 内核。还可以为具有多达 1024 个 CPU 的主机提供支持。</p>
</li>
<li>
<p>安全</p>
<p>KVM 提供增强的安全性，因为它结合使用 SELinux 和安全虚拟化 (sVirt)。VirtualBox 可以执行虚拟机的安全实时迁移和磁盘映像加密。它还包括远程桌面协议 (RDP) 身份验证和用于创建进一步身份验证要求以帮助提高安全性的 SDK。<a href=https://docs.oracle.com/en/virtualization/virtualbox/6.0/admin/security-features.html>您可以在此页面</a>上看到 Virtualbox 的安全功能列表。</p>
</li>
<li>
<p>成本和定价</p>
<p>KVM 是一个开源的免费平台，由 Red Hat 等供应商提供有偿支持。虽然 Virtualbox 在限制范围内是免费的。一旦您超过一定的使用水平，您必须获得产品许可。</p>
</li>
<li>
<p>支持</p>
<p>对于 KVM，您需要依赖开源社区和您自己的 IT 组织或受支持的供应商（如红帽）的支持。Oracle 正在积极开发 Virtualbox，您可以从他们那里获得任何支持。</p>
</li>
</ul>
<h4 id=android-x86httpslinuxcnarticle-11711-1html><a href=https://linux.cn/article-11711-1.html>Android-x86</a><a hidden class=anchor aria-hidden=true href=#android-x86httpslinuxcnarticle-11711-1html>#</a></h4>
<p><a href=http://www.android-x86.org/>android x86</a> 是一个自由而开源的项目，将谷歌制作的安卓系统从 ARM 架构移植到了 x86 架构，可以让用户在他们的桌面电脑上运行安卓系统来享受所有的安卓功能和应用程序及游戏。</p>
<p>首次启动运行该安卓系统，运行：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ qemu-img create -f qcow2 Android8-VM.img 30G
$ gedit start_Android8_VM.sh
<span style=color:#75715e>#!/bin/bash</span>
DISKIMG<span style=color:#f92672>=</span>/media/kurome/Ventoy/QemuKVM/Android8-VM.img
exec qemu-system-x86_64 --enable-kvm <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  -hda <span style=color:#e6db74>${</span>DISKIMG<span style=color:#e6db74>}</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  -net nic -net user <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  -m <span style=color:#ae81ff>4096</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  -smp cores<span style=color:#f92672>=</span>2,threads<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  -monitor stdio <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  -vga std <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  -soundhw es1370 <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  -usb -device usb-tablet <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  -name <span style=color:#e6db74>&#39;Andriod8 VM&#39;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  $@
$ chmod u+x start_Android8_VM.sh
$ ./start_Android8_VM.sh -boot d -cdrom ~/Downloads/android-x86_64-9.0-r2.iso
</code></pre></div><p>在，安卓系统已经完全安装在你的 <code>android.img</code> 文件中，你应该使用下面的 QEMU 命令来启动它，而不是前面的命令：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ ./start_Android8_VM.sh
</code></pre></div><h4 id=waydroidhttpswaydroid><a href=https://waydro.id/>Waydroid</a><a hidden class=anchor aria-hidden=true href=#waydroidhttpswaydroid>#</a></h4>
<p>Waydroid是一个基于lxc容器技术，用以启动完整安卓系统的方案。</p>
<h4 id=genymotionhttpswwwgenymotioncom><a href=https://www.genymotion.com/>Genymotion</a><a hidden class=anchor aria-hidden=true href=#genymotionhttpswwwgenymotioncom>#</a></h4>
<p>Android Virtual Devices for all your development & testing needs</p>
<h4 id=libvfiohttpsarccomputecombloglibvfio-commodity-gpu-multiplexing><a href=https://arccompute.com/blog/libvfio-commodity-gpu-multiplexing/>LibVF.IO</a><a hidden class=anchor aria-hidden=true href=#libvfiohttpsarccomputecombloglibvfio-commodity-gpu-multiplexing>#</a></h4>
<p>Commodity GPU Multiplexing Driven By VFIO & YAML.</p>
<h4 id=osx-kvmhttpsgithubcomkholiaosx-kvm><a href=https://github.com/kholia/OSX-KVM>OSX-KVM</a><a hidden class=anchor aria-hidden=true href=#osx-kvmhttpsgithubcomkholiaosx-kvm>#</a></h4>
<p>macOS VM in QEMU</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ git clone --depth <span style=color:#ae81ff>2</span> --recursive https://github.com/kholia/OSX-KVM.git
$ cd OSX-KVM
$ echo <span style=color:#ae81ff>1</span> | sudo tee /sys/module/kvm/parameters/ignore_msrs
$ sudo cp kvm.conf /etc/modprobe.d/kvm.conf
$ ./fetch-macOS-v2.py
$ dmg2img -i BaseSystem.dmg BaseSystem.img
$ qemu-img create -f qcow2 mac_hdd_ng.img 128G
$ 
</code></pre></div><ul>
<li>使用 <code>--depth 2</code>，方便 <code>git reset --hard</code></li>
<li>基本上只需要改 OpenCore-Boot.sh 就行了，比如可以用别人制作好的 iso 镜像，而不用 BaseSystem.dmg（这是个恢复镜像，通过其再下载完整系统）。</li>
<li>不要在设置里改 Resolution，改了之后更差。openSUSE 默认用 vnc，桌面分辨率太高根本显示不全，无法改设置了，vnc 也尝试关闭关不了，烦。</li>
<li>Ventura 选择 APFS 安装后报错 <code>an error occurred preparing the update</code>，选择 non-APFS filesystem 则安装成功了。（20221215）</li>
</ul>
<h4 id=quickemuhttpsgithubcomquickemu-projectquickemu><a href=https://github.com/quickemu-project/quickemu>quickemu</a><a hidden class=anchor aria-hidden=true href=#quickemuhttpsgithubcomquickemu-projectquickemu>#</a></h4>
<p>Quickly create and run optimised Windows, macOS and Linux desktop virtual machines.</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://sakamotokurome.github.io/tags/unix/>Unix</a></li>
<li><a href=https://sakamotokurome.github.io/tags/linux/>Linux</a></li>
<li><a href=https://sakamotokurome.github.io/tags/ubuntu/>Ubuntu</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://sakamotokurome.github.io/posts/ubuntup3system/>
<span class=title>« Prev Page</span>
<br>
<span>Ubuntu System</span>
</a>
<a class=next href=https://sakamotokurome.github.io/posts/ubuntup1applications/>
<span class=title>Next Page »</span>
<br>
<span>Ubuntu Applications</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2024 <a href=https://sakamotokurome.github.io/>Sakamoto Kurome</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
</body>
</html>