<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Ubuntu | Sakamoto Kurome</title>
<meta name="keywords" content="Unix, Linux, Ubuntu" />
<meta name="description" content="友邦拓 乌班图 During the first ten years of this HOWTO&rsquo;s life, I reported that from a new user&rsquo;s point of view, all Linux distributions are almost equivalent. But in 2006-2007, an actual best choice emerged: Ubuntu. While other distros have their own areas of strength, Ubuntu is far and away the most accessible to Linux newbies. Beware, though, of the hideous and nigh-unusable &ldquo;Unity&rdquo; desktop interface">
<meta name="author" content="Sakamoto Kurome">
<link rel="canonical" href="https://sakamotokurome.github.io/posts/ubuntu/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css" integrity="sha256-yIlj/i15RiAA/Q&#43;xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://sakamotokurome.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://sakamotokurome.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://sakamotokurome.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://sakamotokurome.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://sakamotokurome.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.90.0" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>

<link rel="stylesheet" href="https://sakamotokurome.github.io/custom.css">
<meta name="google-site-verification" content="i2r403EffR8m-KBf7EHi6AYg7tfnMshaXTAynoYPnpE" />
<script async src="https://www.googletagmanager.com/gtag/js?id=G-K2Y212LPQ2"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-K2Y212LPQ2', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="Ubuntu" />
<meta property="og:description" content="友邦拓 乌班图 During the first ten years of this HOWTO&rsquo;s life, I reported that from a new user&rsquo;s point of view, all Linux distributions are almost equivalent. But in 2006-2007, an actual best choice emerged: Ubuntu. While other distros have their own areas of strength, Ubuntu is far and away the most accessible to Linux newbies. Beware, though, of the hideous and nigh-unusable &ldquo;Unity&rdquo; desktop interface" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://sakamotokurome.github.io/posts/ubuntu/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-12-12T16:52:44&#43;08:00" />
<meta property="article:modified_time" content="2021-12-12T16:52:44&#43;08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Ubuntu"/>
<meta name="twitter:description" content="友邦拓 乌班图 During the first ten years of this HOWTO&rsquo;s life, I reported that from a new user&rsquo;s point of view, all Linux distributions are almost equivalent. But in 2006-2007, an actual best choice emerged: Ubuntu. While other distros have their own areas of strength, Ubuntu is far and away the most accessible to Linux newbies. Beware, though, of the hideous and nigh-unusable &ldquo;Unity&rdquo; desktop interface"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://sakamotokurome.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Ubuntu",
      "item": "https://sakamotokurome.github.io/posts/ubuntu/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Ubuntu",
  "name": "Ubuntu",
  "description": "友邦拓 乌班图 During the first ten years of this HOWTO\u0026rsquo;s life, I reported that from a new user\u0026rsquo;s point of view, all Linux distributions are almost equivalent. But in 2006-2007, an actual best choice emerged: Ubuntu. While other distros have their own areas of strength, Ubuntu is far and away the most accessible to Linux newbies. Beware, though, of the hideous and nigh-unusable \u0026ldquo;Unity\u0026rdquo; desktop interface",
  "keywords": [
    "Unix", "Linux", "Ubuntu"
  ],
  "articleBody": "友邦拓 乌班图\n During the first ten years of this HOWTO’s life, I reported that from a new user’s point of view, all Linux distributions are almost equivalent. But in 2006-2007, an actual best choice emerged: Ubuntu. While other distros have their own areas of strength, Ubuntu is far and away the most accessible to Linux newbies. Beware, though, of the hideous and nigh-unusable “Unity” desktop interface that Ubuntu introduced as a default a few years later; the Xubuntu or Kubuntu variants are better.\nEric Steven Raymond - How To Become A Hacker\n 学习 Linux 几点忠告 不要當“傳教士”\n(這點有一個重大弊端：開放軟體沒有商業軟件那樣的宣傳，如果使用者都如此低調，用戶群不會大幅擴展。)\n很多人在討論區不斷的引起的Linux對比Windows之類的討論，甚至爭的面紅耳赤，這是沒有必要的\n這種爭論是浪費時間而沒有任何用處的。對，你花了一下午，用許多事實“捍衛”了Linux比Windows好這個說法。但是Windows的支持者並不會喜歡上Linux的，他們只是稍微退縮一下，然後找一些新的證據來跟你辯論。\n世界上的人們都在利用Linux的研究最前沿的科學，我們還在這裡討論“要不要用Linux的這種無聊的問題，什麼時候才能趕上時代前進的步伐？\n什麼叫做Window支持者，什麼叫做Linux的支持者？我們為什麼要支持某一個而反對另外一個？你不需要為 Linux的護法，不需要成為 Linux的支持者“或者”GNU的傳教士“ GNU / Linux的已經用事實向世界證明了它們的威力，已經被大多數人接受。你只需要安安靜靜享受的GNU / Linux的給你的樂趣和自由。\n你需要關心的不是你的工具是什麼，而是你用它做了什麼。精通的Linux並不說明任何問題，因為它只是一個工具而已。如果你用的Windows能很好的完成你的任務，那你就沒有必要費時間去熟悉Linux操作系統。直到有一天你發現一項任務只有Linux操作系統才能完成的時候再換也不遲，因為你身邊的的Linux的愛好者一定會很樂意的幫助你。\n如果你在使用Linux操作系統的過程中對它產生了感情，那麼你應該明白那些習慣於使用Windows的人也會對Windows產生依賴。類似的爭論還有很多：微軟 Office Word和TeX，Emacs和Vim，Wolfram Mathematica和Maple，侏儒，fvwm的和KDE的時候，狗派… …和冷靜地對自己說：“我不站在它們任何一邊。”儘管這有些不容易辦到。\n各人的需要不同，生活的環境不同。對你來說好的東西，對別人來說不一定好，我們需要尊重別人的選擇。如果你當面說別人正在用的程序不好，沒有必要。\n不要強迫自己”\n喜歡電腦的人總是有某些心理強迫傾向。有的人說：“鍵盤比滑鼠快。我不要用滑鼠。這樣才有高效率。”所以他在編輯器裡無論什麼時候總是用20W的，大於 10J這樣的命令到達目的點。他甚至覺得圖形界面是多餘的，乾脆都不裝 Xwindow。\n全部用鍵盤看起來的確比讓手離開鍵盤去拿鼠標，再回來“快”多了，但是快的擊鍵頻率不等於工作的高效率，對你的健康更沒有什麼好處。這只能把你變成打鍵盤的機器。\n當你正在檢查你的文章或者程序，思維正在隨著字符的含義流動，突然為 20W，大於 10J這樣的東西出現在你的腦子裡，是不是會打斷思路？不？那說明你當時思考的問題比較簡單，這些干擾還不會起到副作用。\n其實很多人用電腦的時候，思想都受到某種教學的束縛，上面這個只是教多數種類中的一種。某些人創造了很多這種數學，用他的工作方式來要求別人，嘲笑方式跟他不一樣的人。比如有的人嘲笑其它人寫程序不按ç 8字符縮進，嘲笑別人在六裡用方向鍵，嘲笑別人不知道是什麼增值稅，嘲笑其它人用在Java，C＃這種由地方選區回收內存語言 … …\n你不用管各種各樣的教學，電腦只是你的工具，你想怎麼用就怎麼用。沒有人能夠約束你，沒有人可以嘲笑你的工作方式。電腦明天就不再是這個樣子，所以今天你不用完全了解它。你沒有必要知道別人創造的一切，因為你需要留點時間自己創造些東西。只要有樂趣！\n當你下次修改文章的時候，不妨試試悠閒的用滑鼠在你眼睛看到的地方輕輕點一下。\n 如果你發現自己有類似的強迫症，建議去諮詢一下心理醫生。\n 不要“玩”Linux\nLinux的很多人用的時候會感覺很迷茫，該用哪個發行版本呢？是不是我少裝了什麼？怎麼升級這麼快啊！怎麼這麼不穩定！每當遇到新的軟件他就想試用，每當新的版本出現，他就更新，然後用鼠標在新的菜單裡選擇從來沒見過的程序來用用。\n其實你是為了玩Linux而使用Linux操作系統的，而沒有找到正確的理由來利用Linux操作系統。你首先要明確用電腦的目的，你用它是為了解決你的實際問題，而不是為了學習安裝操作系統，不是為了測試哪個版本好用，不是為了“趕上潮流，更不是因為你硬盤太大了，你想多佔點空間。\n如果你啟動了電腦之後不知道應該幹什麼，那麼最好先不要用電腦，因為你可能有更重要的事情需要做。這沒什麼說的。\n不用挑剔發行版本\n很多人剛開始用linux的時候，總是在懷疑別的發行版本是否比自己正在用的這個好，總是懷疑自己以後什麼時候會失去支持，不得不換用別的發行。所以很多人今天是紅帽，明天又換成了Debian的，一會兒又是巴布亞… …甚至有的人在一台機器上裝了兩個版本的Linux操作系統，然後比較哪一個好。\n其實你完全沒有必要這樣做，任何發行，只要你熟悉了，你在上面的工作方式幾乎不會受到任何影響。我以前一直用的紅帽，當我有一天在我的一台新機器上安裝Debian時，我發現使用紅帽的經驗完全沒有浪費。我用了一個下午就配置好了Debian，使它服服貼貼的聽我的話，就跟沒有換發行版本一樣。\nDebian，拓林思，SuSE，紅帽，Gentoo… …任何一個版本都是不錯的。很多人認為自己攢一個 LFS的是高水平黑客的象徵，但是不是每個人都有精力去了解所有細節。\n不要盲目升級\n不知道這是心理作用還是什麼，有的人看到比較大的版本號，就會很想換成那個。很多人的Redhat的本來配置的很舒服了，可是一旦Redhat的發行新的版本，他們就會盡快下載過來，然後選擇升級安裝。結果很多時候把自己原來修改得很好的配置文件給沖掉了。新的軟件又帶來了新的問題，比如有一次我的rxvt的就升級到2.7.8跟miniChinput衝突了，升級到Redhat的8.0，xmms的發現居然缺省不能放了MP3播放，XFree86的是i810的模塊在啟動上有新的漏洞，Mozilla中，會導致突然退出。\n如果你已經配置好了一切，千萬別再整體升級了，這會浪費你很多很多時間的，不值得。有句話說得好：“如果沒有打破，不解決它。”如果你的程序能夠完成你需要做的事情，你何必升級呢？？？？\n 是的，不論是從論壇還是其他的地方反映出來的大部分都是這個問題，要么比较SUSE和Ubuntu的好，要么比Ubuntu或者Mandriva的好等等的言論。很多人還是把Linux操作系統看成了一個表面的東西。並沒有塌下心來學習 Linux系統。\n 不要配置你不需要的東西\n如果你只想做一個像我這樣的普通用戶，主要目的是用的Linux來完成自己的科研任務和日常工作，那就可以不用系統管理員或者網絡管理員的標準來要求自己，因為當一個系統和網絡管理員確實很辛苦。普通用戶學習那些不經常用到的複雜的維護系統的工具，其實是浪費時間，學了不用是會很快忘記的！\n我不是一個合格的網絡管理員，我的服務器都只設置了我自己需要的功能，設置好ssh連接的ftp已經足夠了，那樣可以省去我很多麻煩。我從來不過度考慮“安全，因為 Linux操作系統缺省已經很安全了。我沒有磁帶機，就不用管tar的那些稀奇古怪的參數了，czf，xzf，ztf已經可以滿足我所有的需要。桑達，awk的，…我也只會幾種常用的命令行。\n不要習慣的使用根帳號。在需要的時候才用！\n這是很多剛接觸的UNIX類操作系統的人常見的現象，他們不喜歡在管理系統的時候才用，而是一直用根帳號幹所有事情，配置系統，安裝程序，瀏覽網頁，玩遊戲，編程 … …\n結果有一天，他不小心在某個系統目錄使用了del * …後果不堪設想 … …\n不要用商業的眼光來看待Linux\nLinux不是商業軟件，所以不要用要求Solaris操作系統，視窗那樣的眼光來看 Linux操作系統。自由軟件的作者們從來不拉攏用戶，他們對用戶不負有任何責任。實際上在自由軟件的世界裡，開發者“和”用戶“並沒有明確的界限，大家是朋友。\n自由軟件很可能只是滿足作者和他的朋友的需要，甚至是為了好玩而創造的。自由軟件不是完美的，自由軟件承認自己有缺點，它不會自吹自擂，蒙蔽“用戶”的耳目。這種對作者責任的解脫激發了作者的創造力，他們不用過分考慮“向上兼容，他們往往比背上重重包袱的商業軟件結構更合理，技術更先進。\n所以當你用某個自由軟件遇到困難的時候，不應該埋怨軟件的作者，因為他們對你並沒有義務。你不應該把自己當成一個挑剔的顧客，而要把自己作為這個軟件的顧問和一個和藹的建議者，這樣你才能理解作者寫這個程序時的快樂，在遇到問題時向作者反映，幫助他完善這個軟件，成為一個快樂的參與者。就像你的哥哥送你一個他用舊了的自行車，你應該珍惜這份友情，而不要在車壞了，或者騎車摔了一跤的時候大罵你的哥哥。如果你真的不能使用這種合作的心態，那麼最好不要使用這個軟件。\n這是一種先進的文化，它包含了互相合作，科學創新的精神。理解這一點不是很容易，很多人往往是因為不能理解這種文化而離開自由軟件。這對於作者來說並沒有什麼損失。\n幹你的正事去\n很多人跟我說，你的網頁浪費我好多時間來配置這配置那，一會兒是fvwm的，一會兒是Mutt中… …\n嗯… …那些東西都是我有空的時候一點一點積累的，如果你想一次性搞定所有那些東西，恐怕得花你幾個星期甚至幾個月的時間！並不是一定要搞定所有這些東西你才能正常工作的。除非你真的非得利用某個程序，或者你閒著沒事，否則你可以不管這些東西。\n上面幾條僅供參考\n以上只是個人意見，不一定適合所有人。取捨由你了！\nSettings DNS GUI\n 打开设置窗口 如果你连接到了 WiFi 网络，点击“Wi-FI”标签栏。否则，如果你有一个有线连接，点击『Network』标签栏。 选择你要设置 DNS 的网络连接，并且点击齿轮状的按钮，打开网络管理器。 选择 IPv4 设置标签栏。 禁用自动开关，并且输入 DNS 的 IP 地址，用逗号隔开。我们使用 Google DNS 域名解析服务器。 点击“Apply”按钮，保存修改。  这个修改应该会立即有效，除非那些已经缓存了的 DNS 条目。如果你想切换回旧的设置，打开网络管理器，IPv4 设置，并且启用自动开关。\nCLI\n# 显示当前网络连接 $ nmcli connection show # 修改当前网络连接对应的DNS服务器，这里的网络连接可以用名称或者UUID来标识 $ nmcli con mod ens160 ipv4.dns \"114.114.114.114 8.8.4.4\" # 配置生效 $ nmcli con up ens160 或者\n# Config File $ vi /etc/netplan/01-network-manager-all.yaml network: version: 2 renderer: NetworkManager ethernets: ens3: dhcp4: no addresses: - 192.168.100.199/24 gateway4: 192.168.100.1 nameservers: address: [114.114.114.114, 8.8.4.4] wifis: ... # Apply the changes you made in the config file $ sudo netplan apply # To check if the system successfully applied the changes $ systemd-resolve --status | grep 'DNS Servers' -A2 DNS Servers: 114.114.114.114 8.8.8.8 8.8.4.4 注意：您系统上的文件可能缺少整个以太网或 wifi 部分。 在这种情况下，添加缺少的行，确保遵守示例中提供的缩进。\nTesting the Domain Name Resolution Speed\n$ time dig @114.114.114.114 Others  Bluetooth: OFF Formats: United States Blank screen: 10 Night Light: On Touchpad: OFF Fractional Scaling  SoftWare\u0026Updates software-properties-gtk or software-properties-kde\n  Ubuntu Software 栏 Download from 选择 USTC MIRRORS。\n  Other Software 栏下开启 Canonical Partner Repositories (The partner repositories offer access to proprietary and closed-source software)。\n  Ubuntu 自动下载并安装对你的系统至关重要的安全更新。而这个自动更新经常导致你“无法锁定管理目录”错误。在 Updates 栏下选择\n For other packages, subscribe to: All updates Automatically check for updates: Every two weeks When there are security updates: Download and Install automatically When there are other updates: Display immediately Notify me of a new Ubuntu version: For long-term support versions    更新系统:\n$ sudo apt update $ sudo apt upgrade $ sudo apt autoremove   Livepatch: 更新内核不需要 Reboot required 了\n$ sudo ua attach    Ubuntu Software \u0026 Update 卡在 cache refresh\n通过 apt update 可以看见是 Connecting to security.ubuntu.com Failed，解决办法是更改 /etc/hosts 文件添加其 IP，可通过 EASYCOUNTER 查找：\n## security.ubuntu.com 91.189.88.142 security.ubuntu.com 91.189.88.152 security.ubuntu.com 91.189.91.38 security.ubuntu.com 91.189.91.39 security.ubuntu.com ## archive.canonical.com 91.189.92.150 archive.canonical.com 91.189.92.191 archive.canonical.com 91.189.91.15 archive.canonical.com ## downloads.sourceforge.net 216.105.38.13 downloads.sourceforge.net ubuntu下如何获取源码包和源码\n  在 Software \u0026 Updates 中选中 Source code，不要 Reload，因为很慢，在命令行中 update。或者在软件源配置文件 /etc/apt/sources.list 中添加 deb-src 项。\n  获取 xxx 源码包的详细信息\n$ sudo apt-cache showsrc xxx   获取源码包，并将源码包解压到同名目录\n$ sudo apt-get source xxx   Upgrade Ubuntu version\n 打开 Software Updater 更新软件 打开 Software \u0026 Updates 选择 Updates 栏，在 Notify me of a new Ubuntu Version 中选择 For any new version 。 打开 Software Updater 更新到新 Ubuntu 版本。 使用 lsb_release -a 确认 Ubuntu 版本。  Input Method Editor 首先在 Language Support 中下载语言包\nIBus ubuntu libpinyin 输入法支持云拼音，只需要开启就可以了。\n搜狗细胞词库\n到hslinuxextra下载sougou-phrases-full.7z。\n经过与ibus开发者协商，ibus-pinyin的词库查找规则做了一些更改，只要在词库目录（就是有一个.db文件的那个目录，一般是/usr/share/ibus-libpinyin/db/目录）把新词库复制过来并改名为local.db就可以使用了，如果感觉词库不好，直接删除掉local.db，就可以让ibus使用原来的词库。\n覆盖以后，你把ibus重启一下ibus-daemon -d -x -r，如果你能打出下面的这个词组，说明生效了：\n弗雷德霍姆行列式 这个词库，基于ibus原有的android词库文件，另外增加了搜狗的细胞词库。\nFcitx 4 在Ubuntu Wayland 桌面中使用fictx管理中文输入法\n$ sudo apt install fcitx -y 设置 fcitx：\n  在 Language Support 中选择 fcitx，全局应用，并恢复 ibus 自定义切换语言快捷键设置。\n  (可选）wayland桌面默认不读取/etc/profile中的环境变量，而是从/etc/environment文件中读取，这是导致fcitx不能正常工作的原因。\n$ sudo vim /etc/environment INPUT_METHOD=fcitx GTK_IM_MODULE=fcitx QT_IM_MODULE=fcitx XMODIFIERS=@im=fcitx   输入法框架：\n 搜狗输入法 for Linux 百度输入法Linux版 Google拼音  其他：\n 百度输入法不能安装用于更换皮肤的 fcitx-ui-qimpanel，否则乱码。需要手动安装 fcitx-libs，否则开机不自动启动。 在 fcitx 与 sogoupinyin 安装完之后，需要重启才能使用。  皮肤：\n fcitx 皮肤：/usr/share/fcitx/skin sogoupinyin 皮肤：/usr/share/sogou-qimpanel/skin。  旧：可以改名为 zip 解压 新：受版权保护    Fcitx 5 安装\n配置工具 KDE 下使用 kde-config-fcitx5， Gnome 下使用 fcitx5-config-qt。\n20.04 (20220122) 官方仓库里没有 Gnome 的配置工具 kcm-fcitx5（内含 fcitx5-config-qt），因此通过 ppa:zhsj/fcitx5 来安装\n$ sudo add-apt-repository ppa:zhsj/fcitx5 $ sudo apt-get update $ sudo apt install fcitx5 fcitx5-chinese-addons 或者也可以通过**通过 flatpak 安装**。\n安装后在 Ubuntu 在 Language Support 里修改输入法系统为 fcitx5，记得点击 Apply System-Wide。\n安装报如下错\nE: Failed to fetch http://103.95.217.6/ppa.launchpad.net/zhsj/fcitx5/ubuntu/pool/main/f/fcitx5-chinese-addons/fcitx5-module-cloudpinyin_5.0.4-1~ubuntu20.04.1~ppa1_amd64.deb 503 Service Unavailable [IP: 103.95.217.6 80] E: Aborting install. 可以在浏览器中打开链接直接下载。\n肥猫百万大词库\nDownload latest version of “zhwiki.dict” from https://github.com/felixonmars/fcitx5-pinyin-zhwiki/releases\nCopy into ~/.local/share/fcitx5/pinyin/dictionaries/ (create the folder if it does not exist)\n可以在设置中看到是否启用，或者输入 “jinjinjin” 会出现 “鑫”。\nAutomatically switch wallpapers Apps  Shotwell：在侧边栏 Photos 中 Ctrl + A，在菜单栏 File 中选择 Set as Desktop SlideShow…；这会把图片复制到 .local/share/shotwell/wallpaper，并在该目录生成 wallpaper.xml，wallpaper.xml 定义自动切换壁纸动画。 替代软件： Variety、BingWall 等。 脚本分享：styli.sh、lswc 动态壁纸：komorebi、LiveWallpaper  unsplash   gsettings set org.gnome.desktop.background picture-uri file://$HOME/Wallpaper\n  添加脚本\n$ vi $HOME/.unsplash.sh #!/bin/bash SAVE_DIR=$HOME/DataOne/Unsplash FILE_NAME=daily$(date '+%Y%m%d').jpeg wget -O $SAVE_DIR/$FILE_NAME https://source.unsplash.com/1920x1080/daily cp $SAVE_DIR/$FILE_NAME $HOME/Wallpaper 在 Unsplash Source 查看更多 API。\n  crontab -e\n0 12 * * * /home/vane/.unsplash.sh   除了使用 crontab 外，还可以使用 Startup Applications Preferences 添加一个启动项。\n  wallhaven   gsettings set org.gnome.desktop.background picture-uri $HOME/Wallpaper\n一般文件内容开头都会有一个文件类型的标记，根据文件名后缀只是一个快捷的方法，不用读取文件内容就判断文件类型，但不是唯一的方法。\n  vi $HOME/.wallhaven/wallhaven.sh\n#!/bin/bash  WORK_DIR=$HOME/.wallhaven SAVE_DIR=$HOME/Pictures/wallhaven IMG_URL=https://w.wallhaven.cc/full function GetListing() { echo 'get listing' listing=$(curl https://wallhaven.cc/api/v1/search?apikey=\u0026categories=010\u0026purity=111\u0026atleast=1920x1080\u0026ratios=16x9\u0026sorting=random\u0026order=desc\u0026page=1) echo 'save listing' echo $listing | jq -r '.data[].path' | awk -F '/' '{print $NF}'  $WORK_DIR/listing echo 'save res' cat $WORK_DIR/listing | wc -l  $WORK_DIR/res SetWallpaper } function SetWallpaper() { if [ -a $WORK_DIR/res ]; then echo 'read res' read res if [ $res -ne 0 ]; then echo 'get img' img=$(cat $WORK_DIR/listing | tail -${res} | head -1) echo \"down $imgfrom $IMG_URL/${img:10:2}/$img\" curl -o $SAVE_DIR/$img $IMG_URL/${img:10:2}/$img if [ $? -eq 0 ]; then echo 'set wallpaper' cp $SAVE_DIR/$img $HOME/Wallpaper echo 'res-1' echo $(($res - 1))  $WORK_DIR/res echo 'exit' exit 0 else echo 'download error' SetWallpaper fi else echo 'res=0' GetListing fi else echo 'no res' GetListing fi } SetWallpaper 使用 Shell 脚本来处理 JSON，jq Manual，wallhaven API v1 Documentation\n  crontab -e\n0 12 * * * /home/vane/.wallhaven/wallhaven.sh Gsettings 无法在 Cron 中使用：出现此问题是因为 cron 仅使用一组非常有限的环境变量。 唯一一个负责在将其设置为 cron 作业时以正确方式运行问题脚本的环境变量是 DBUS_SESSION_BUS_ADDRESS。\n  Astronomy #!/bin/bash API_KEY=zTL5rJmctXwHcsjfCSalfDRNFTeaVYa9FxgINVVU HTTP_REQUEST=https://api.nasa.gov/planetary/apod?api_key=$API_KEY HTTP_RESPONSE=$(curl $HTTP_REQUEST) IMG_HDURL=$(echo $HTTP_RESPONSE | jq -r '.hdurl') IMG_FILENAME=$(echo ${IMG_HDURL##*/}) curl -o $HOME/DataOne/Images/Astronomy/$IMG_FILENAME $IMG_HDURL cp -av $HOME/DataOne/Images/Astronomy/$IMG_FILENAME $HOME/Wallpaper Social Telegram 先通过手机登录，再在电脑端登录。电脑先登录，手机老是收不到验证码。\n简介   Telegram —— 中文名又称\"电报\"，或简称\"TG\"。\n  Telegram 是跨平台的即时通信软件，其客户端是自由及开放源代码软件，但服务器是专有软件。\n  Telegram 在中国大陆境内无法直接连接，注册和使用都需要科学上网，请自备节点和工具。\n  下载：Telegram 有官方版和第三方版本，但出于安全和隐私的考虑，推荐大家使用 Telegram 官方版客户端\n  推荐设置  Privacy and Security  Phone Number  谁能看见我的手机号码：Nobody 谁能通过手机号码找到我：My Contacts   Forwarded Messages：Nobody Calls：Nobody Groups：My Contacts   Local Passcode：本地密码只是本设备打开 Telegram 的应用密码 Two-Step Verification：为了账号安全，强烈推荐您设置两步验证密码。 Delete my account：推荐您设置为一年  隐私保护注意事项  资料设置  昵称及用户名：避免使用与其他社交平台相同或相似的昵称及用户名 手机号码：在\"设置——隐私——电话号码\"中设置\"不允许任何人查看我的手机号码\"和\"仅允许联系人通过手机号码找到我\"。   群组聊天：Telegram 的群聊是\"不安全\"的。 公开群组的所有聊天内容都可被其他人查看，即使他人并未注册 Telegram； 对于群组内的机器人，它们可以收集群组内的绝大部分消息。 媒体文件：在分享照片时，请注意使用专业修图软件打码处理关键信息，并清除照片包含的地理位置信息 分享链接：从其他平台分享内容至 Telegram 时，请注意清除分享链接中的用户 UserID 识别信息，他人完全有可能从您的分享链接中获取您的用户信息。 第三方客户端：如无特殊需要，请使用官方 Telegram 客户端。第三方客户端有能力获取和控制您的账户，读取您全部的聊天记录，收集您设备的可识别信息，包括但不限于：手机号、设备型号、IMEI码、MAC码等。  常见问题及解答  无法给他人发送私聊：“Sorry, you can only send messages to mutual contacts at the momet.”  @SpamBot But I can’t message non-contacts！ No，I’ll never do any of this   群组和频道有什么类型？有什么特点？  群组(Group)或者频道(Channel)有两种类型。  一种是公开群组(Public Group/Channel) 一种是私有群组(Private Group/Channel)   公开群组(Public Group/Channel) 有自定义设置的ID，所有人可以通过搜索功能，输入id查询到相应的群组。公开群组的历史消息对所有人可见，即使没加入公开群组，也可以查看群组历史消息。 私有群组(Private Group/Channel) 没有自定义的ID，要加入只能通过点击邀请链接或者被邀请入群， 在私有群组，群主可以设定历史消息的可见性。而对于没有加入群组的人，则不可以查看群组的消息。   Telegram 用户名是什么？  其他用户可以通过用户名找到您，您将出现在“全局结果”下的联系人搜索中。这样人们就可以在不知道您的电话号码的情况下通过 Telegram 与您联系。 由于用户名的唯一性，可以防止他人盗用你的头像和昵称冒充你。   如何添加联系人？：添加和删除联系人都是单向操作，对方设备并不会同步。 添加非手机号码联系人后，对方能知道自己的手机号码吗？：如果想取消分享你的手机号，请到隐私设置(Privacy and Security)中找到手机号码(Phone Number)的设置，在里面移除对方即可。 不登陆 Telegram 如何查看频道消息？：Telegram 公开频道可以直接通过浏览器输入 https://t.me/s/频道id 访问，不需要拥有TG账号。  进阶知识 什么是 MTProxy 代理？\n MTProxy 是 Telegram 的官方项目，仅能用于代理 Telegram 软件 MTP 代理是在 Telegram 中内置的代理程序，可以直接在软件内配置，而不需要下载任何其他 App 来配置代理  主题与美化 美化主题频道\n 官方 Desktop 桌面版主题频道 @themes 官方 Android 安卓主题频道 @Androidthemes  Sticker Pack 用现成的图片集来制作 stickers pack。Linux 可以方便地使用 ImageMagick 来操作。\nTelegram 要求 Sticker 图片为 PNG 格式，并且要有透明层，至少一边为 512 像素，另一边则不超过 512 像素。最大文件大小为 350KB。透明层就算了，我不会玩 PS。那么直接偷懒(死)来批量把当前目录下 JPG 和 PNG 混杂的图片们统一转换为 PNG 好了。\n几条命令发给 stickers bot：\n /newstickerpack 发送表情包的名字… 在内置的 emoji 中发送一个最符合你要发送图片的表情… 然后把对应的图片作为文件发送 如果还有其他图片的话重复 3-4 全部表情图片设置完毕，发送 /publish 命令 为你的 stickers pack 取一个短名字 (用于 URL)  在Telegram上使用EFB同时推送QQ与微信消息 众所周知,待机耗电两巨头皆出自TX,但其对于工作人群和大学生而言又是不可或缺的通讯手段.Telegram作为一款合格的IM支持Android众多特性(TX出来挨打),通知栏回复、消息再提醒、自定义震动以及最关键的FCM推送(FCM的特性和优势可以在Google上查询).使用插件利用Telegram来完成QQ微信的消息代收是目前Android系统较优秀的解决方案\n事前准备 物品准备\n 墙外VPS一枚 Telegram账号一枚 稳定的飞机 Xshell(注意不要下载成苏杰马克丁版)/PUTTY 可联网设备一枚,推荐电脑 基本的Linux和vim知识  本教程基于EFB v2.0.0, efb-qq-slave v2.0.0b2, efb-wechat-slave v2.0.0制作,方案为MASTER SLAVE处于同一系统且QQ微信各使用一个 Bot ,使用 Debian 10\n获取 Telegram ID\n向 @get_id_bot 发起会话,击 /start 即可获得你的 Telegram ID\n使用EFB转发微信消息 申请 Telegram Bot\n向 @BotFather 发起会话，发送命令 /newbot 以创建Bot（用户名须以Bot为结尾）\n设置好后还须对bot进行权限设置\n发送 /setprivacy 到 @BotFather，选择刚刚创建好的 Bot 用户名，然后选择 “Disable”.\n发送 /setjoingroups 到 @BotFather，选择刚刚创建好的 Bot 用户名，然后选择 “Enable”.\n发送 /setcommands 到 @BotFather，选择刚刚创建好的 Bot 用户名，然后发送如下内容：\nhelp - 显示命令列表. link - 将聊天链接到群组. unlink_all - 取消所有聊天与群组的链接. info - 显示当前Telegram聊天的信息. chat - 生成聊天对话框. update_info - 更新组名称和资料图片. 安装 EFB 及其从端\n安装相关依赖:\n$ apt install python3 python3-pip python3-pil python3-setuptools python3-numpy python3-yaml python3-requests ffmpeg libmagic-dev libwebp-dev vim -y 安装 EFB :\n$ pip3 install ehforwarderbot efb-telegram-master efb-wechat-slave 创建配置文件\n创建 EFB 配置文件:\n$ mkdir -p ~/.ehforwarderbot/profiles/wx/ $ vim ~/.ehforwarderbot/profiles/wx/config.yaml master_channel: blueset.telegram slave_channels: - blueset.wechat 创建 ETM 配置文件:\n$ mkdir -p ~/.ehforwarderbot/profiles/wx/blueset.telegram $ vim ~/.ehforwarderbot/profiles/wx/blueset.telegram/config.yaml token: \"123456\" #值为你在 @BotFather 处获得的 bot token admins: - 123456 #值为你在 @get_id_bot 处获得的 chat id 创建 EWS 配置文件:\n$ mkdir -p ~/.ehforwarderbot/profiles/wx/blueset.wechat $ vim ~/.ehforwarderbot/profiles/wx/blueset.wechat/config.yaml 其内容参见可选的配置文件，根据文档配置即可。\n输入ehforwarderbot --profile wx,扫码登录即可收发消息,使用screen命令保存后台\n使用EFB转发QQ消息 申请 Telegram Bot\n向 @BotFather 发起会话，发送命令 /newbot 以创建Bot（用户名须以Bot为结尾）\n设置好后还须对bot进行权限设置\n发送 /setprivacy 到 @BotFather，选择刚刚创建好的 Bot 用户名，然后选择 “Disable”.\n发送 /setjoingroups 到 @BotFather，选择刚刚创建好的 Bot 用户名，然后选择 “Enable”.\n发送 /setcommands 到 @BotFather，选择刚刚创建好的 Bot 用户名，然后发送如下内容：\nlink - 将会话绑定到 Telegram 群组. chat - 生成会话头. recog - 回复语音消息以进行识别. extra - 获取更多功能. 安装 EFB 及其从端\n$ apt-get install libopus0 ffmpeg libmagic1 python3-pip git nano docker.io libssl-dev python3-dev build-essential #安装相关依赖 $ pip3 install efb-telegram-master #安装 EFB $ pip3 install -U git+https://github.com/milkice233/efb-qq-slave $ pip3 install git+https://github.com/milkice233/efb-qq-plugin-iot 创建配置文件\n创建 EFB 配置文件:\n$ mkdir -p ~/.ehforwarderbot/profiles/qq/ $ vim ~/.ehforwarderbot/profiles/qq/config.yaml master_channel: blueset.telegram slave_channels: - milkice.qq 创建 ETM 配置文件:\n$ mkdir -p ~/.ehforwarderbot/profiles/qq/blueset.telegram $ vim ~/.ehforwarderbot/profiles/qq/blueset.telegram/config.yaml token: \"123456\" #值为你在 @BotFather 处获得的 bot token admins: - 123456 #值为你在 @get_id_bot 处获得的 chat id IOT 部分:\n$ wget https://github.com/opq-osc/OPQ/releases/download/v6.0.20/OPQBot_6.0.20_darwin_amd64.tar.gz #根据需要版本自行更改链 启动需要到Gitter获取token并填入CoreConf.conf文件\n如果需要更改API的端口请更改Port (例如更改成2333端口,就改成Port = “0.0.0.0:2333”)\n进入到文件目录 执行命令\nscreen -S iot ./OPQBot #输入完毕后 Ctrl+A+D  登录请 等待控制台输出Everything is ok!后 再用浏览器访问 http://IP:PORT/v1/Login/GetQRcode (IP为你机子的内网ip或者公网ip,PORT为你上一步更改的端口,默认8888\n然后用手机扫码登录,不支持帐号密码登陆\n创建 EQS 配置文件\n$ mkdir -p ~/.ehforwarderbot/profiles/qq/milkice.qq $ vim ~/.ehforwarderbot/profiles/qq/milkice.qq/config.yaml Client: iot iot: qq: 1234567890 # 此处填写登录的QQ号 host: \"http://127.0.0.1\" # 默认IP为本地 port: 8888 # 默认端口为 8888 receive_self_msg: False # 不接收自己发出的消息 输入ehforwarderbot --profile qq 即可,同样可以使用screen命令保存后台\n问题发现及解决方案   提示错误: efb-wechat-slave 2.0.0 has requirement requests=2.22.0, but you'll have requests 2.21.0 which is incompatible.\n输入 pip3 install requests==2.22.0 解决\n  升级相关组件输入 pip3 install --upgrade efb-qq-slave efb-wechat-slave efb-telegram-master\n  参考链接 安装并使用 EFB：在 Telegram 收发 QQ 消息 - Milkice’s IceBox\n在 Telegram 上实现微信收发，EHForwarderBot 搭建记录 - Eliot’s Blog\nEFB WeChat Slave Channel：EFB 微信从端 (EWS) - bluesethttps://linux.cn/article-12826-1.html\nMutt Mutt 是一个基于文本的邮件客户端，因其强大的功能而闻名。 Mutt虽然已诞生二十多年了，但仍然是大量用户的首选邮件客户端。\nMutt主要侧重于作为邮件用户代理（MUA），最初是为了查看邮件而编写的。 与其他邮件应用程序相比，稍后实现的功能（检索，发送和过滤邮件）比较简单，因此用户可能希望使用外部应用程序来扩展Mutt的功能。\n模块搭配方案 就像穿衣搭配一样，收件发件过滤邮件转发邮件各种功能都有很多种程序可以用，mutt怎么搭配呢？\n常用选项有这些(User/Transport/Delivery)：\n MUA 收件：fetchmail或getmail或OfflineIMAP MTA 发件：sendmail或msmtp或postfix。其中msmtp兼容强，postfix对国内不友好 MDA 分类: procmail或maildrop 邮件编辑：VIM。  一般搭配是：\n 老式搭配：mutt + getmail + sendmail + procmail 新式搭配：mutt + fetchmail + msmtp + maildrop  这里我们用：mutt + fetchmail + msmtp + procmail\n安装：\n$ sudo apt install mutt fetchmail msmtp procmail -y Mutt或各个写协作程序在配置前都是不能使用的，学习曲线还是比较陡峭的，所以要做好准备去花好一段去了解和学习各个部件。\n大概的配置流程是：\n 配置收件：~/.fetchmailrc 配置过滤：~/.procmailrc 配置发件：~/.msmtprc 配置mutt框架本身：~/.muttrc  注意：初学过程中，不要一上来就配置mutt。最好是先从各个部件开始：收件-过滤邮件-阅读邮件-发件-mutt界面，按照这种顺序。\n收件：配置Fetchmail  Fetchmail是由著名的《大教堂与集市》作者 Eric Steven Raymond 编写的。\n Fetchmail是一个非常简单的收件程序，而且是前台运行、一次性运行的，意思是：你每次手动执行fetchmail命令，都是在前台一次收取完，程序就自动退出了，不是像一般邮件客户端一直在后台运行。\n注意：fetchmail只负责收件，而不负责存储！所以它是要调用另一个程序如procmail来进行存储的。\nfetchmail的配置文件为~/.fetchmailrc。然后文件权限最少要设置chmod 600 ~/.fetchmailrc\n比如我们要设置多个邮箱账户同时收取，那么配置如下：\npoll pop.AAA.com protocol POP3 user \"me@AAA.com\" password \"123\" poll pop.BBB.com protocol POP3 user \"me\" there with password \"123\" is falko here fetchall poll pop.CCC.com protocol POP3 user \"me\" there with password \"123\" is till here keep poll pop.DDD.com protocol POP3 user \"me\" password \"123\" ## QQ 邮箱 poll pop.qq.com port 995 protocol POP3 user \"1664548605@qq.com\" password [授权码] ssl keep # 全局选项 mimedecode # 不加 -d %T 就会报 ~/Mail/inbox is not a mailbox. 错误 mda \"/usr/bin/procmail -d %T\" 其中：\n 各种参数可以不按顺序，也可以不在一行。 空格隔开每个参数，poll隔开每个账户。 here, there, with, is等等，都不是关键词，随便写不影响参数。 以下是必填  poll后面是邮件服务器的地址，一般是pop.xxx.com protocol后面是收件协议，一般是pop或pop3 user后面是用户名，可以是username，也可以是邮箱地址 password后面是密码   sslproto：可能会报错 fetchmail: pop.qq.com: upgrade to TLS failed.，故可以禁掉SSL，同 man 手册查到  加上option --nosslcertck，虽然有报错，但至少可以收邮件了。 加--sslprotocl '', 注意要用空字符串   四选一：  nofetchall ：仅检索新消息（默认）。 fetchall ：获取所有消息，无论是否看到。 keep ：不要从服务器上删除看到的消息。 nokeep ：从服务器中删除看到的消息。   mimedecode用来自动解码MIME mda后面指定本机安装的邮件过滤分类程序。如果不填，则收取的邮件在本地不会保存。注意用which procmail查一下路径。 QQ 邮箱客户端设置 Outlook 设置：失败了  配置完成后，可以运行fetcmail -v来看看是否有错误信息，如果能够正常显示很多行的收取信息，那么就能正确登录邮箱收取了。\n一般收取的命令如下：\n# 只收取未读邮件 $ fetchmai # 收取所有邮件 $ fetchmail -a # （重要）收取新邮件，但不在服务器端删除已经收取的邮件 $ fetchmail -k 但是fetchmail只负责收取，不负责“下载”部分，你找不到邮件存在哪了。 所以还需要配置MDA分类器，如procmail，才能看到下载后的邮件。\n注意：Fetch其实不是在Mutt“里”使用的，而是脱离mutt之外的！也就是说，Mutt只负责读取本地存储邮件的文件夹更新，而不会自动帮你去执行fetchmail命令。\n你必须自己手动执行，或者用Crontab定期收取，或者设为Daemon守护进程，还可以在Mutt中设置快捷键执行Shell命令：\n  要使fetchmail作为守护进程运行，我们必须编辑/etc/default/fetchmail并将START_DAEMON设置为yes\n$ vi /etc/default/fetchmail START_DAEMON=yes 接下来，必须创建配置文件/etc/fetchmailrc并设置 set daemon 300 （这意味着fetchmail应该每300秒检索一次电子邮件）。\n  设置Mutt快捷键收取邮件的方法是在~/.muttrc中加入macro：\nmacro index,pager I 'shell-escape fetchmail -vkenter' 这样的话，你就可以在index邮件列表中按I执行外部shell命令收取邮件了。\n  邮件过滤：配置Procmail Procmail是单纯负责邮件的存储、过滤和分类的，一般配合fetchmail收件使用。\n在Pipline中，fetchmail把收到的邮件全部传送到Procmail进行过滤筛选处理，然后Procmail就会把邮件存到本地形成文件，然后给邮件分类为工作、生活、重要、垃圾等。\n当然，分类规则是自己可以指定的。可以根据发信人、主题、长度以及关键字 等对邮件进行排序、分类、整理。\nProcmail 的配置文件是 ~/.procmailrc ，记得改权限：chmod 600 ~/.procmailrc。\n内容也非常简单，前面是邮件位置、日志等默认选项，后面则是一块一块的过滤规则。\n基本配置：\n# 邮件存储地址 MAILDIR=$HOME/Mail # 默认：收件箱 DEFAULT=$MAILDIR/inbox VERBOSE=off LOGFILE=/tmp/procmaillog # 某个垃圾邮件规则 :0 * ^From: webmaster@st\\.zju\\.edu\\.cn # 垃圾文件的存储位置 /dev/null # 其它所有都存到收件箱中 :0: inbox/ 其中，$HOME/Mail是设定的邮件存储位置。\n我们需要手动创建mkdir ~/Mail，否则程序会报错。\n配置好后，我们再测试一下就会看到：\n$ fetchmail -a 78 messages for 1664548605@qq.com at pop.qq.com (2843793 octets). reading message 1664548605@qq.com@pop.qq.com:1 of 78 (36692 octets) not flushed ... $ tree ~/Mail /home/vane/Mail └── inbox 0 directories, 1 file $ du -h Mail/inbox 2.1M\tMail/inbox 可以看到，所有邮件都保存在了inbox这个单一文件中。这个文件可以打开看到MIME格式(协议)的邮件源码。就像HTML一样，展示给我们的和背后的源码不一样。\n那么怎么把这个类似HTML的MIME格式邮件解析为我们人能读懂的内容呢？——这个我们就要靠mutt自己了，mutt自身具备基本的MIME邮件解析功能（不包括HTML格式邮件读取）。\n发件：配置msmtp msmtp是作为sendmail发邮件程序更好的替代品。\nmsmtp的配置文件为~/.msmtprc，记得改权限：chmod 600 ~/.msmtprc\n配置内容比收件还简单，因为发件永远比收件简单。\n基本配置：\naccount default auth login host smtp.XXX.com port 587 from ME@XXX.com user ME password passwd # 关于tls，如果是阿里云则不用写，如果是Outlook的话，必须写 tls on tls_starttls off tls_certcheck off # QQ 邮箱例子 account default # QQ邮箱这里必须是 on，否则会 535 Login Fail auth on host smtp.qq.com port 587 from 1664548605@qq.com # user 必须是 @ 之前的部分，不能自定义，否则会 535 Login Fail user 1664548605 password [授权码] tls on tls_starttls off tls_certcheck off logfile /tmp/msmtp.log QQ 邮箱例子：使用mutt+msmtp在Linux命令行界面下发邮件。\n总之，哪怕QQ 邮箱设置对了，也要多试几次才能发送成功。\n主界面：配置Mutt Mutt的配置文件为~/.muttrc，记得改权限：chmod 600 ~/.muttrc\n另外：mutt的配置文件还可以放在~/.mutt/muttrc。这种方法有一个好处，即~/.mutt/目录下可以放很多主题、插件等文件。\n基本配置：\n# 通用设定 set use_from=yes set envelope_from=yes #移动已读邮件 set move=yes #回复的时候调用原文 set include set charset=\"utf-8\" #自动显示HTML auto_view text/html # 发送者账号 set realname=\"Vane Hsiung\" set from=\"1664548605@qq.com\" # 分类邮箱 #Mail box type set mbox_type = Maildir set folder = \"$HOME/Mail\" #INBOX set spoolfile = \"$HOME/Mail/inbox\" #Seen box set mbox=\"$HOME/Mail/seen\" #Sent box set record=\"$HOME/Mail/sent\" #Draft box set postponed=\"$HOME/Mail/draft\" # 关联程序（需要自己用which命令确定一下） # 默认使用 nano set editor=\"vim\" set sendmail=\"/usr/bin/msmtp\" 以上如果有什么问题，可参考etchmail + proc + msmtp + mutt configuration samples。\n确认邮箱服务器 即使上面配置一切OK，也不一定能正常收发邮件。因为你用的Gmail、QQ、网易、阿里云等等，后台都有一系列的第三方收取设置。这是各不相同的。\n除了第三方客户端的允许，我们还要设置POP。最好放开全部邮件或者最近30天，然后禁止客户端删信。这是什么意思呢？POP默认客户端在收件后，服务器上的邮件就自动删除了！这个不太合适，所以必须要禁止。\n基本操作 邮件列表操作：\n 基本：q:Quit, d:删除当前邮件, s:将邮件移动至指定文件夹, m:创建新邮件, r:回复当前邮件, ?:帮助 移动：j/k 上下移动邮件, z/Z上下翻页,  跳至序号处（不进入邮件）  打开选中的邮件 /在当前文件夹搜索 d 将选中邮件标记为删除, N 将选中邮件标记为未读, $ 让标记的东西生效，如删除、未读等。 f 转发选中邮件, e 编辑选中邮件 c切换文件夹(inbox/seen/draft等), 需要输入文件夹名称，或按?在列表里选择，j/k上下移动。  在邮件中的操作：\n j/k 上一封／下一封邮件, : 向下翻页, : 向下滚动 e 编辑当前邮件, t编辑TO，c编辑CC，b编辑BCC，y发送邮件，a添加附件，Return查看附件，E编辑附件，D删除附件  使用命令操作：\nMutt如同Vim一样，不光可以把命令绑定为快捷键，还能直接输入:直接输入命令。 但是稍有不同的是，Mutt称之为Action，而且需要用:exec 这样格式执行。\n比如sidebar侧边栏的移动，命令是：sidebar-next, sidebar-prev。 那么我们可以直接输入:exec sidebar-next，按下回车执行。\nIRC 简介 芬兰人雅尔可·欧伊卡利宁（Jarkko Oikarinen）于1988年8月创造了IRC来取代一个叫做MUT的程序。\n IRC（Internet Relay Chat的缩写，“因特网中继聊天”）是一个位于应用层的协议。 其主要用于群体聊天，但同样也可以用于个人对个人的聊天。 一个IRC服务器可以连接其他的IRC服务器以扩展为一个IRC网络。 IRC 不强制注册；但如果你注册了，就可以强制把占用自己唯一 ID 的人踢下线。 IRC 协议简单，开源实现多，其第三方机器人程序非常众多，几乎每种语言都有一个实现。 IRC 是开源社区会议标准；因此，许多开源世界的技术大牛混在那里。  irchelp：一个致力于帮助用户了解IRC的网站。\nIRC：Linux文档项目的IRC HOWTO\n服务器 首先要区分一些概念：\n Networks：是指的互相隔离的网络，如Freenode和DALnet这些是世界知名的网络，但互相隔离，频道不共享。 Servers：Network网络中的某一台电脑服务器，你加入世界上任何一个server都能加入这个Network。IRC是一个分布式的客户端/服务器结构。通过连接到一个IRC服务器，我们可以访问这个服务器以及它所连接的其他服务器上的频道（即这个 Network 中所有频道）。  频道存在于一个IRC服务器上。一个频道类似于一个聊天室，频道名称必须以#符号开始，例如#irchelp。\n要使用IRC，必须先登录到一个IRC服务器上，最常见的为irc.freenode.net——最大的IRC网络，为免费和开源软件社区，非营利组织和相关社区提供讨论设施。\nFreenode 用户模式。\nIRC使用的服务器端口有:\n 6667（明文传输，如irc://irc.freenode.net） 6697（SSL加密传输，如ircs://irc.freenode.net:6697）。  IRCD: 简称互联网中继聊天守护，是服务器软件实现了IRC 协议，使人们通过上网彼此交谈（交换文本即时消息）。\n客户端 IRC用户透过客户端软件和服务器相连。\nInternet Relay Chat客户端的比较：\n   Client Homepage Description     Irssi https://irssi.org/ 支持IPv6的模块化文本UI IRC客户端。轻量级流行客户端。   WeeChat https://weechat.org/ 便携式和多接口（文本，Web和GUI）IRC客户端。    Irssi 安装\n$ apt install irssi 命令行输入irssi即进入了聊天室。\n和一般Linux程序的一般命令、格式都不同，IRC客户端一般有自己的命令。窗口右下方[(status)]是输入命令的地方。\n一般命令(不区分大小写)：\n /quit，退出程序。一般的ctrl-c, ctrl-d, esc, q之类的都不管用 /help，帮助 /network list 查看已保存的服务器列表 /connect xxx.xxx.xxx 连接某服务器。连接 freenode，需要到 https://irc.com/login/sso 注册，然后按照 https://freenode.net/kb/answer/sasl 进行设置。 /join xxx 加入某channel /leave或/part 离开当前channel /normal或/n 查看当前channel的人数 /list -YES 查看当前服务器的所有chennels (慎用) /nick NewNickName 更改当前昵称 /msg NickName Content 给某人发送消息，一般都是给/msg nickserv管理人NPC发送消息  常用快捷键：\n Alt + 1/2/3/4...，切换window窗口，一般一个channel一个窗口 Alt + n/p，上下滚动屏幕  IRC 常用缩写词\n配置\n如果想长期保存、备份一个固定的程序配置，那么就需要修改配置文件。\nirssi默认的配置文件为~/.irssi/config。\n配置中，会在第一次运行时就自动设置了一些，包括根据当前电脑账户的用户名设置nickname等。整个配置，是一直“类似”JSON的格式。\nsettings ：记录自己的名字：nick, real_name, user_name\nservers ：这是指的Network而不是具体某台server，如Freenode、Dal、ESPer、EFnet等大型网络。服务器配置案例：\nservers = ( { address = \"irc.dal.net\"; chatnet = \"DALnet\"; port = \"6667\"; }, { address = \"路径\"; chatnet = \"下面chatnet对应的名称\"; port = \"端口\"; autoconnect = true; use_ssl = \"yes\"; password = \"用户名:密码\"; } ); chatnets：记录各个网络的登录信息，也可以作为“别名”，这样每次/connect不用输入全路径了。配置完每个服务器后，还要配置相应的chatnets，每一条的名称都要与servers中的对应。\nchatnets = { DALnet = { type = \"IRC\"; max_kicks = \"4\"; max_msgs = \"20\";max_whois = \"30\"; }; Freenode = { type = \"IRC\"; max_kicks = \"4\"; max_msgs = \"20\";max_whois = \"30\"; autosendcmd = \"/msg nickserv identify MyName MyPassword\"; }; }; channels ：记录自己收藏的频道名。RC的频道不是用URL之类很复杂的东西，全都是用#tag这种简单一个标签来区分的，非常好记。\nchannels = ( { name = \"#lobby\"; chatnet = \"EsperNet\"; autojoin = \"No\"; }, { name = \"#freenode\"; chatnet = \"Freenode\"; autojoin = \"No\"; }, ); statusbar：界面美化的设置。目前IRSSI的世界里，唯一知名的主题只有weed。\nMultimedia Pipewire 从 Pulseaudio 切换到 Pipewire 的理由是对于蓝牙的“LDAC”“APTX”之类编码格式的支持\nRhythmbox Music\n搜 “无损音乐” “车载音乐” 打包下载。\n电台\n很多电台是基于mms协议的，如果rhythmbox无法播放mms协议的电台，则需要安装支持mms协议的gstreamer插件——因为rhymbox使用gstreamer做后台解码。支持mms协议的插件为gstreamer bad插件，所以执行命令：\n$ sudo apt-get install gstreamer0.10-plugins-bad 同样的，如果需要播放mp3文件则安装ugly插件，需要播放wma文件则安装ffmpeg插件。\n电视台和电台MMS地址\n分享Rhythmbox电台列表\n最终还是没什么无法播放mms，因为 Rhythmbox 报错了。\nFeelUOwn FeelUOwn 是一个稳定、用户友好以及高度可定制的音乐播放器。\nSpotify 作为世界上最大的音乐流媒体服务商，Spotify 因优秀的设计和精准的音乐推荐算法让不少人为之倾心。\n在正式注册 Spotify 之前，我们先来看一看曲库的问题。由于不同地区的歌曲版权差异，Spotify 在不同地区提供服务时，其相应的曲库也有所不同。例如港区的曲库中，粤语歌就要比美区多，相反美区的英文歌就要比港区多。同理，若你喜欢听其他语种的歌，注册当地的 Spotify 则是最好的选择。\n注册后要是发现当前的地区选择并不是很理想，想要换区也是可行的。首先要挂上自己想要换到地区的代理，然后进入自己的「Profile/资料」界面，点击「Edit Profile/修改资料」，「Country/国家」这个选项就会出现你当前所挂代理地区，保存更改即可换区成功。\n登录的话，需要先在登录界面设置Proxy重启。登录后在设置里改回来，不再需要Proxy了。\nSpotifyd An open source Spotify client running as a UNIX daemon.\nNeteaseMusic Linux 下官方只发布了 deb 包，flatpak 直接安装\nYesPlayMusic 高颜值的第三方网易云播放器\nNetEase-MusicBox 网易云音乐命令行版\nlx-music-desktop 一个基于 electron 的音乐软件\nlisten1_desktop one for all free music in china\nQQMusic PulseAudio PulseAudio 是在GNOME 或 KDE等桌面环境中广泛使用的音频服务。它在内核音频组件（比如ALSA 和 OSS）和应用程序之间充当代理的角色。\n配置 Pulseaudio 支持通过多种模块扩展其功能。在这里可以找到PulseAudio可用的模块的详细信息： Pulseaudio Loadable Modules。增加 load-module  到文件 /etc/pulse/default.pa就可以启用对应的模块。\n启动 警告： 如果你给每个用户拷贝了配置文件（例如client.conf, daemon.conf 或者 default.pa）到~/.config/pulse/ 或者 ~/.pulse/目录下，确定这些文件的修改与/etc/pulse/下的文件修改同步，否则PulseAudio可能由于配置文件错误而拒绝启动。\n注意： 大多数X11环境会在启动X11会话时自动启动PulseAudio。\n少数情况下PulseAudio在启动X11时没有自动启动，可运行下面的命令启动：\n$ pulseaudio --start 运行下面的命令可以终止PulseAudio：\n$ pulseaudio --kill 在不支持的桌面环境中自动启动 注意： 正如之前所说, 如果用户安装了桌面环境，PulseAudio很可能通过 /etc/X11/xinit/xinitrc.d/pulseaudio文件或者 /etc/xdg/autostart/目录下的文件自动启动\n查看PulseAudio是否正在运行：\n$ pgrep -af pulseaudio 369 /usr/bin/pulseaudio 如果PulseAudio未运行而且用户正在使用X11，运行下面的命令可以在启动PulseAudio的同时加载需要的X11插件：\n$ start-pulseaudio-x11 如果你没有运行GNOME, KDE或者Xfce，并且你的~/.xinitrc文件并未引用/etc/X11/xinit/xinitrc.d目录下的文件内容，为了让PulseAudio自动启动，你可以这样做：\n~/.xinitrc /usr/bin/start-pulseaudio-x11 后端设置 ALSA 配置ALSA与PulseAudio共同工作必须的文件/etc/asound.conf。\n为了防止应用程序使用ALSA的OSS模拟功能而忽略PulseAudio（从而导致其他应用程序无法播放声音），确定snd_pcm_oss模块没有在系统启动时自动加载。如果该模块已经被加载(lsmod | grep oss)，运行下面命令以卸载该模块：\n# rmmod snd_pcm_oss 均衡器 PulseAudio内置了10段均衡器系统，按下列步骤操作以启用均衡器：\n加载均衡器通道和dbus协议模块 $ pactl load-module module-equalizer-sink $ pactl load-module module-dbus-protocol 安装并运行图形前端 $ sudo apt install pulseaudio-equalizer $ qpaeq 每次启动时加载均衡器和dbus模块 编辑 /etc/pulse/default.pa 并加入下面几行：\n### Load the integrated PulseAudio equalizer and D-Bus module load-module module-equalizer-sink load-module module-dbus-protocol FFmpeg  powershell 执行与在 cmd 执行不一样，poweshell 某些 -c:v 会报错 ffmpeg 输出参数含义  frame: 编码的帧数量 fps：每秒编码的帧数 q：质量因子 size/ Lsize：视频和音频编码后的大小，即基本等于视频和音频 之和 time：输出帧的显示时间 bitrate：输出视频的比特率 dup：输入帧重复（duplicate）的数量 drop：输入帧丢弃（drop）的个数 speed：编码速度    视频文件本身其实是一个容器（container），里面包括了视频和音频，也可能有字幕等其他内容。\n视频和音频都需要经过编码，才能保存成文件。不同的编码格式（CODEC），有不同的压缩率，会导致文件大小和清晰度的差异。\n编码器（encoders）是实现某种编码格式的库文件。只有安装了某种格式的编码器，才能实现该格式视频/音频的编码和解码。\nFFmpeg 的命令行参数非常多，可以分成五个部分：\n$ ffmpeg [全局参数] [输入文件参数] -i 输入文件 [输出文件参数] [输出文件] 常用参数  -c：指定编码器 -c copy：直接复制，不经过重新编码（这样比较快） -c:v：指定视频编码器 -c:a：指定音频编码器 -i：指定输入文件 -an：去除音频流 -vn： 去除视频流 -preset：指定输出的视频质量，会影响文件的生成速度，有以下几个可用的值 ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow。 -y：不经过确认，输出时直接覆盖同名文件。  查看视频文件的元信息 $ ffmpeg -i input.mp4 -hide_banner 转换编码格式 $ ffmpeg -i [input.file] -c:v libx264 output.mp4 转成 H.264 编码，一般使用编码器 libx264\n转换容器格式 $ ffmpeg -i input.mp4 -c copy output.mkv 改变分辨率 $ ffmpeg -i input.mp4 -vf scale=720:-1 output.mp4 提取视频 $ ffmpeg -i input.mp4 -an -c:v copy ouput.mp4 -vcodec codec 强制使用codec编解码方式。如果用copy表示原始编解码数据必须被拷贝。\n提取音频 $ ffmpeg -i input.mp4 -vn -c:a copy output.aac -c:a copy表示不改变音频编码，直接拷贝。\n添加音轨 $ ffmpeg -i input.aac -i input.mp4 output.mp4 音视频合成 $ ffmpeg -i video.mp4 -i audio.aac -c:v copy -c:a copy output.mp4 截图 从指定时间开始，连续对1秒钟的视频进行截图\n$ ffmpeg -y -i input.mp4 -ss 00:01:24 -t 00:00:01 output_%3d.jpg 指定只截取一帧\n$ ffmpeg -ss 01:23:45 -i input.mp4 -vframes 1 -q:v 2 output.jpg -vframes 1指定只截取一帧，-q:v 2表示输出的图片质量，一般是1到5之间（1 为质量最高）。\n裁剪 $ ffmpeg -ss [start] -i [input] -t [duration] -c copy [output] $ ffmpeg -ss [start] -i [input] -to [end] -c copy [output] 裁剪（cutting）指的是，截取原始视频里面的一个片段，输出为一个新视频。可以指定开始时间（start）和持续时间（duration），也可以指定结束时间（end）。\n添加字幕  外挂字幕：一个单独的外部字幕文件，格式类型一般有srt、vtt、ass等等。播放视频时，需要把外挂字幕和视频放在同一目录下，并在播放器中选择字幕文件才可以在视频中看到字幕。 软字幕：也叫内挂字幕、封装字幕、内封字幕，字幕流等，就是把前面的外挂字幕的字幕文件嵌入到视频中作为流的一部分，如果一个视频有多个字幕流那么播放视频是还得选择对应的字幕流 硬字幕：是嵌入到视频帧里面的字幕，它就像视频水印一样作为视频帧的一分部分了，不管再任何平台字幕看起来都是一样的，而且也不再要求播放器单独对字母进行渲染  常见的字幕格式有：\n SRT（标准外挂字幕格式）：只包含文字和时间码，没有样式，显示效果由播放器决定，不同的播放器显示出的效果可能差别很大。 ASS（高级外挂字幕格式）：支持样式、字体、字幕定位、淡入淡出、简单的特效。如果不缺字体，不同的播放器显示效果基本一致。  ffmpeg字幕处理流程(容器是否支持字幕流指的是输出容器)\n添加软字幕：\n$ ffmpeg -i video.mp4 -i subtitle.srt -c copy output.mkv 软字幕只有部分容器格式比如(mkv)才支持，MP4/MOV等不支持，而且也只有部分播放器支持软字幕或者外挂字幕(如VLC播放器)。\n添加多个字幕：\nffmpeg -i input.mp4 -i zh_CN.srt -i en_US.srt -map 0:v -map 0:a -map 1 -map 2 -c:v copy -c:a copy -metadata:s:s:0 language=chn -metadata:s:s:1 language=eng \"output.mp4\"  -map 是轨道参数，如果只有一个字幕，就不需要这个参数。-map 0:v 表示第一个文件输入视频轨道，-map 0:a 表示第二个轨道是第一个文件输入的音频轨道，-map 1 建立第三个轨道，-map 2 建立第四个轨道。如果没添加 map 参数，默认就只有一个字幕轨道，第二个英文字幕会覆盖第一个中文字幕轨道。 -metadata:s:s:0 language=chn 第一条字幕的语言设置为中文，-metadata:s:s:1 language=eng 第二条字幕的语言设置为英文。 language 不能自定义，只能设置成固定的缩写。  添加硬字幕：\n$ ffmpeg -i video.mkv -vf subtitles=subtitle.srt out.mp4 下载 m3u8 现在比较常见的视频流媒体，大部分都是 m3u8 格式的，而对于 m3u8 格式的视频而言，如果你下载过，你会发现它就是一个文本文件，大概也就只有几十 kb，从磁盘大小来看，应该也知道它并不是一个直接的视频文件。\n什么是 m3u8\n说到 m3u8 就要先说说 HLS（HTTP Live Streaming）。HLS 是 Apple 公司针对 iPhone、iPod、iTouch 等移动设备，而研发的基于 HTTP 协议的流媒体解决方案。在 HLS 技术中，Web 服务器可以向客户端提供接近实时的音视频流，但是它又是使用的标准的 HTTP 协议。所以基本上，比较大型的点播直播类服务，都是基于 HLS 的。\n而该技术的原理，就是将视频文件或者视频流，进行切片（ts文件），并建立索引文件（m3u8），它支持的视频流编码为 H.264，音频流编码为 AAC。\n简单来说，基于 HLS 的视频流，会将完整的视频，切割成一个个比较小的视频片段（ts 文件），然后根据协议组合成一个 m3u8 文件。这些比较小的 ts 文件，是可以单独播放的。而视频播放器，拿到 m3u8 文件之后，根据对其内 ts 片段的索引，连续播放不同的视频片段，来达到流畅的播放效果。\n下载的 m3u8 文件\n说这些概念都没用，我们来看两个真实的被下载的 m3u8 文件。\n这种 m3u8 文件就还是比较清晰的，能看到它一个个的片段。但是需要注意的是，这里的片段，全部是基于域名的相对地址，也就是说，这样一个 m3u8 文件，你丢到播放器里，是无法播放的，但是如果你记录了原始下载这个 m3u8 的链接，它在播放器里是可以正常播放的。\n当然，如果你修改这个 m3u8 文件，将它相对路径拼接上域名地址，也是可以达到播放的效果的。\n再来看看另外一种 m3u8 文件，它其内的 ts 片段，都是完整地址。\n像这种具有完整地址的 ts 片段，哪怕你将它保存成一个本地的文件，播放器依然是可以直接播放的，不过这里本质上依然是在在线播放。\n这两中 m3u8 文件，虽然有细微的差别，但是它们都是基于标准的协议。\n简单总结一下：\n m3u8 不是视频内容的文件，它占用的磁盘空间非常的小。 m3u8 文件，如果其内的 ts 片段，是完整地址，则可以保存后播放，否者只能在线播放。 播放器播放 m3u8 文件的时候，实际上，还是在线从线上获取的视频流进行播放，所以是存在失效的情况的。  暂时知道这三点就可以了，接下来我们再看如何将一个 m3u8 文件，下载成一个 mp4 视频文件。\n使用 fmpeg 下载 m3u8\nffmpeg 是一套可以用来记录、转换音视频，并将其转化为流的开源程序，采用 LGPL 或 GPL 协议许可证书，很多大型的音视频软件，内部都是基于 ffmpeg 的。\n$ ffmpeg -i \"m3u8_file_uri\" \"save_video.mp4\" 到此，如果 m3u8 的链接正确可播放，就会开始下载，等待下载完成就可以了，最终会在指定目录下，保存 save_video.mp4 文件，它就是最终我们下载的离线视频文件。\nMPV MPV 是一个基于 MPlayer 和 mplayer2 的开源极简全能播放器。支持各种视频格式、音频解码、支持特效字幕（电影动漫的ass特效字幕都没啥问题），不仅支持本地播放，同样支持网络播放（mpv 集成了 youtube-dl）。重点是 MPV 具有多系统平台支持、命令行、自定义、GPU 解码、脚本支持等特点……\nOSC 界面 由于默认情况下，MPV 播放器简约到连 GUI 界面都没有提供，因此需要通过命令行或配置文件设置。\n虽然 MPV 并没有提供官方的 GUI 界面，没有菜单，但它提供 OSC 操作界面和快捷键用于操作，只要关联好文件格式，使用 mpv 打开视频后，使用上其实也非常的简单方便。\n快捷键 操作主要通过键盘快捷键（区分大小写）调整。下面介绍一些常用的 mpv 快捷键（更多的快捷键请阅读官方参考手册）。\n鼠标操作\n   快捷键 作用说明     鼠标左键双击 进入/退出全屏   鼠标右键单击 暂停/继续播放   鼠标滚轮 快进/快退    播放控制\n   快捷键  作用说明     p Space 暂停、继续播放   / * 减少/增加音量   9 0 减少/增加音量（数字键盘区的9、0不可用）   m  静音   ← → 快退/快进5秒   ↑ ↓ 快进/快退1分钟     上一个/下一个（播放列表中）   Enter  下一个（播放列表中）   l  设定/清除 A-B循环点   L  循环播放   s  截屏   q  停止播放并退出   Q  保存当前播放进度并退出，播放同样文件从上次保存进度继续播放。    视频控制\n   快捷键 作用说明     _(下划线) 循环切换可用视频轨   A 循环切换视频画面比例   Alt+0 0.5倍源视频画面大小   Alt+1 1倍源视频画面大小   Alt+2 2倍源视频画面大小    音频控制\n   快捷键  作用说明     #  循环切换可用音频轨   Ctrl + Ctrl - 音轨延迟+/- 0.1秒    字幕控制\n   快捷键  作用说明     V  关闭/开启字幕   j J 循环切换可用字幕轨   x z 字幕延迟 +/- 0.1秒   r t 上移/下移字幕位置    窗口控制\n   快捷键 作用说明     T 窗口始终置顶   f 进入/退出全屏   ESC 退出全屏    配置 因为mpv本身不具有图形化前端，绝大多数的设置选项都是靠在主设置文件 ~/.config/mpv/mpv.conf 中输入参数实现的。\n## 部分选项之间有关联作用，MPV读取参数时由上往下读，所以注意书写通用参数的顺序，可查看手册[02]的顺序逻辑部分的错误示范 ## 基础 ## # 视频硬件解码API选择 # 因系统环境、显卡、驱动等差异硬件解码API方式（阅读官方参考手册查询）各有不同，建议实际测试验证后再填入可用API。 # 默认值为 no（使用软件解码），auto 为自动。 hwdec=auto # 尽可能所有格式先尝试上面指定视频硬件解码API #hwdec-codecs=all  # 输出log， # ~~/ 意思是 mpv config dir(for example ~/.config/mpv/) log-file=\"~~/mpv.log\" ## 功能 ## # --fs 等效 --fullscreen。运行MPV自动进入全屏 #fs=yes  # 默认为系统原生窗口界面，启用此项使用无边框界面 #border=no # 窗口置顶 #ontop=yes  # 窗口模式下最大占屏幕的百分比 # 例如在FHD屏上打开4k视频初始窗口过大 #autofit-larger=80%x80%  # 窗口模式下最小占屏幕的百分比 # 例如在4k屏上打开720p视频初始窗口过小 #autofit-smaller=50%x50%  # 默认yes，默认情况下MPV的窗口比例锁定为视频比例。启用此项以实现窗口自由拉伸行为 # 当 keepaspect=yes 时四周填充黑边 # keepaspect-window=no  # 以暂停状态启动播放器 #pause=yes  # 始终循环播放当前文件 #loop=inf  # 播放列表循环 #loop-playlist=no  # 默认情况下播完列表所有文件MPV自动关闭，设置为 yes 所有播放完毕不退出，设置为 always 可以实现类似“每个文件播完都暂停”的效果  keep-open=yes # 退出时记住播放状态。缓存目录默认在设置文件夹中的 \"watch_later\" save-position-on-quit=yes # 播放网络视频时的向后缓存大小（KiB或MiB） demuxer-max-bytes=20MiB ## OSD ## ## OSD 即 On-Screen-Display ，通常为屏幕上弹出显示的信息。  ## OSC 即 on-screen-controller ，MPV中指的是简易操控界面 #  在跳转时间轴时显示的信息类型 osd-on-seek=msg-bar # 更改OSD字体大小（全局，影响多个功能显示的文本）（默认值：55） #osd-font-size=40  # 以秒为单位显示OSD时间（毫秒精度），有助于查看视频帧的确切时间戳 osd-fractions=yes # 开始播放时短暂显示的信息：文件名 osd-playing-msg=\"${filename}\" # 设置OSD文本信息的持续时间（毫秒）（默认值：1000） osd-duration=2000 ## 音频 ## # 最大音量。默认值130（130的响度约为100的两倍） volume-max=120 # 播放器启动音量。0为静音，默认100 #volume=100  # 自动加载同名外挂音轨（fuzzy为模糊名，exact为精确名）  audio-file-auto=fuzzy ## 视频 ## # 如果做过专业校色应开启（系统目录存在对应的icm校色文档）。未做校色的广色域屏应手动指定 --target-prim= #icc-profile-auto=yes  ## 脚本 滤镜 着色器 ## ## 内置脚本开关（如果没有必要的目的，那就不要屏蔽mpv内建的功能 # 控制台 #load-osd-console=no # 统计信息 #load-stats-overlay=no  ## 字幕 ## # 自动加载当前播放文件的同名外挂字幕 sub-auto=fuzzy # 在指定的额外目录中寻找匹配的字幕，支持相对和绝对路径。 # 示例即自动搜索当前文件路径下名为\"sub\",\"subtitles\",\"字幕\"和C盘的\"字幕库\"文件夹内 #sub-file-paths=sub;subtitles;字幕;C:/字幕库 # 字幕首选语言为中文，但MPV优先加载外挂轨道，此项参数可能实际用处不大 slang=chs,sc,zh,chi,zho # 在插值和颜色管理之前，将字幕混合到视频帧上。值video类似于yes，但是以视频的原始分辨率绘制字幕，并与视频一起缩放 # 启用此功能会将字幕限制在视频的可见部分（不能出现在视频下方的黑色空白处） # 还会让字幕受 --icc-profile --target-prim --target-trc --interpolation --gamma-factor --glsl-shaders 的影响 # 与 --interpolation 一起使用时，可提高字幕渲染性能  #blend-subtitles=video  # [当 --blend-subtitles=yes/video 时无效] 使ASS字幕尽可能输出在黑边上 sub-ass-force-margins=yes ## 截图 ## ## 以下预设参数只是为了截取最高质量的图片（高质量截图处理效率较低） #  screenshot-format=png # JPEG的最高质量，默认为90  #screenshot-jpeg-quality=100  # 用与源视频相同的色度半采样写入JPEG，默认yes #screenshot-jpeg-source-chroma=yes  # PNG压缩等级，过高的等级影响性能，默认为7  #screenshot-png-compression=5  # PNG的压缩过滤器。默认5即可实现最佳压缩率  #screenshot-png-filter=5  # 使用适当的色彩空间标记屏幕截图（并非所有格式受支持）默认no #screenshot-tag-colorspace=yes  # 主要影响PNG，尽可能使用和视频输出时相同的位深，默认yes #screenshot-high-bit-depth=yes # 若直接在模板中设置路径，此时无需 --screenshot-directory screenshot-template=\"MPV-%P-N%n\" # 截屏文件保存路径 # ~/ 意思是 user home directory root (similar to shell, $HOME) screenshot-directory=\"~/Pictures\" Shotcut Shotcut is a free, open source, cross-platform video editor.\nDaVinci Resolve 专业的剪辑、调色、特效和音频后期制作！\nMKVToolNix MKVToolNix is a set of tools to create, alter and inspect Matroska(mkv) files under Linux, other Unices and Windows.\n轨道提取模式：\nmkvextract 输入文件名 tracks [选项] TID1:目标文件名1 [TID2:目标文件名2 ...] TID:输出文件名\t如果输入文件中存在 ID 为 TID 的轨道，则将其提取为文件 输出文件名。轨道 ID 与 mkvmerge --identify 文件 选项所输出的相同。\n$ mkvextract \"Another Movie.mkv\" tracks 0:video.h265 \"1:main audio.aac\" VLC VLC is a free and open source cross-platform multimedia player and framework that plays most multimedia files, and various streaming protocols.\nDownload Aria2 Aria2是一款开源下载工具，可帮助简化不同设备和服务器之间的下载过程。它支持磁力链接、BT种子、http等类型的文件下载，与迅雷相比，Aria2有着优秀的性能及较低的资源占用，架构本身非常轻巧，通常只需要4兆字节（HTTP下载）到9兆字节（用于BitTorrent交互）之间。最重要的一点是Aria2完全免费！\n$ sudo apt-get install aria2 下载安装完成之后，可以通过输入 aria2c -v 来验证是否安装成功。\nUsage 命令行使用\n使用Aria2下载文件，只需在命令后附加地址即可：\n$ aria2c URL 下载后以其他名称保存文件\n$ aria2c -o fileName URL 下载多个文件\n$ aria2c -Z URL URL 从列表下载文件：\n$ aria2c -i URLs.txt 限制下载速度：\n# 单个文件 aria2c –max-download-limit=500k URL # 全局 aria2c –max-overall-download-limit=500k URL 断点续传：\n$ aria2c -c URL 下载磁力链接文件：要下载磁力链接文件，如果下载没有速度，可以添加--bt-tracker=选项，tracker 中用 , 隔开：\n$ aria2c --bt-tracker=tracker,tracker torrent tracker 服务器：\n  trackerslist：trackers_best (20 trackers) = link / mirror / mirror 2\n  TrackersListCollection：BEST Tracker list (78 trackers)= link / mirror\n  中国可用的 BT Tracker 服务器列表\n  将多行文本转换成一行并用逗号隔开\n$ cat tracker | xargs | tr ' ' ','   分段下载：可以加快文件的下载速度，对于下载大文件时特别有用，-s 后面的参数值介于1~5之间，你可以根据实际情况选择。下面命令将使用2连接来下载该文件：\n$ aria2c -s 2 URL 后台下载：\n$ aria2c -D url $ aria2c –deamon=true url 验证文件：\n$ aria2c –checksum=md5=提供的md5 设置dht端口：\n$ aria2c –dht-listen-port=1234 torrent 下载需要引用页的文件：\n$ aria2c –referer=referurl URL 下载需要Cookie验证的文件：\n$ aria2c –essay-header=’Cookie:key=value’ URL $ aria2c –load-cookies=cookie文件 URL 从密码保护的网站下载一个文件：\n$ aria2c --http-user=xxx --http-password=xxx URL $ aria2c --ftp-user=xxx --ftp-password=xxx URL 注意：当源地址存在诸如\u0026,*等shell的特殊字符，请使用单引号或双引号把URI包含起来。\nRPC Server 模式\n该模式可以配合 Web UI 进行图形管理。默认启动是 6800 端口，怕别人盗用，可以设置用户名和密码(1.18.4以上版本支持密钥)。\n$ aria2c --enable-rpc --rpc-listen-all --rpc-allow-origin-all -c --dir ~/Download Configurat ion 默认情况下，aria2 检查旧路径 $HOME/.aria2/aria2.conf 是否存在，否则它会将 $XDG_CONFIG_HOME/aria2/aria2.conf 解析为它的配置文件。 您可以使用 --conf-path 选项指定配置文件的路径。 如果您不想使用配置文件，请使用 --no-conf 选项。\n配置详解：\n# Description: Awesome Aria2 configuration file # Version: 2021.09.15 ## '#'开头为注释内容, 选项都有相应的注释说明, 根据需要修改 ## ## 被注释的选项填写的是默认值, 如为空则无默认设置，请自行选取需要更改的添加到你的配置文件中 ## ## 文件保存设置 ## # 下载路径(可使用绝对路径或相对路径), 默认: 当前启动位置 #dir= dir=/home/kurome/Downloads # 磁盘缓存 # 启用磁盘缓存. 如果设置为 0, 将禁用磁盘缓存. 此功能将下载的数据缓存在内存中, 最多占用此选项设置的字节数. 缓存存储由 aria2 实例创建并对所有下载共享. 由于数据以较大的单位写入并按文件的偏移重新排序, 所以磁盘缓存的一个优点是减少磁盘的 I/O. 如果调用哈希检查时并且数据缓存在内存中时, 将不需要从磁盘中读取. 大小可以包含 K 或 M (1K = 1024, 1M = 1024K). disk-cache=64M # 文件预分配方式, 可选：none, prealloc, trunc, falloc, 默认:prealloc # 预分配对于机械硬盘可有效降低磁盘碎片、提升磁盘读写性能、延长磁盘寿命。 # 机械硬盘使用 ext4（具有扩展支持），btrfs，xfs 或 NTFS（仅 MinGW 编译版本）等文件系统建议设置为 falloc # 若无法下载，提示 fallocate failed.cause：Operation not supported 则说明不支持，请设置为 none # prealloc 分配速度慢, trunc 无实际作用，不推荐使用。 # 固态硬盘不需要预分配，只建议设置为 none ，否则可能会导致双倍文件大小的数据写入，从而影响寿命。 file-allocation=none # 文件分配限制 # 不对比此参数设置大小小的分配文件. 您可以增加数值的单位 K 或 M (1K = 1024, 1M = 1024K). no-file-allocation-limit=64M # 断点续传 # 继续下载部分完成的文件. 启用此选项可以继续下载从浏览器或其他程序按顺序下载的文件. 此选项目前只支持 HTTP(S)/FTP 下载的文件. continue=true # 始终断点续传 # 始终断点续传. 如果设置为\"是\", aria2 始终尝试断点续传, 如果无法恢复, 则中止下载. 如果设置为\"否\", 对于不支持断点续传的 URI 或 aria2 遇到 N 个不支持断点续传的 URI (N 为 --max-resume-failure-tries 选项设置的值), aria2 会从头下载文件. 参见 --max-resume-failure-tries 参数. always-resume=false # 最大断点续传尝试次数 # 当 --always-resume 选项设置为\"否\"时, 如果 aria2 检测到有 N 个 URI 不支持断点续传时, 将从头开始下载文件. 如果 N 设置为 0, 当所有 URI 都不支持断点续传时才会从头下载文件. 参见 --always-resume 选项. max-resume-failure-tries=0 # 获取服务器文件时间 # 从 HTTP/FTP 服务获取远程文件的时间戳, 如果可用将设置到本地文件 remote-time=true ## 进度保存设置 ## # 从会话文件中读取下载任务 input-file=/home/kurome/.aria2/aria2.session # 会话文件保存路径 # 当退出时保存错误及未完成的任务到指定的文件中. 必须用绝对路径 # 您可以在重启 aria2 时使用 --input-file 选项重新加载. 如果您希望输出的内容使用 GZip 压缩, 您可以在文件名后增加 .gz 扩展名. 请注意, 通过 aria2.addTorrent() 和 aria2.addMetalink() RPC 方法添加的下载, 其元数据没有保存到文件的将不会保存. 通过 aria2.remove() 和 aria2.forceRemove() 删除的下载将不会保存. #save-session= save-session=/home/kurome/.aria2/aria2.session # 任务状态改变后保存会话的间隔时间（秒）, 0 为仅在进程正常退出时保存, 默认:0 # 为了及时保存任务状态、防止任务丢失，此项值只建议设置为 1 save-session-interval=1 # 自动保存任务进度到控制文件(*.aria2)的间隔时间（秒），0 为仅在进程正常退出时保存，默认：60 # 不论设置的值为多少, aria2 会在任务结束时保存控制文件. 可以设置的值为 0 到 600. # 此项值也会间接影响从内存中把缓存的数据写入磁盘的频率 # 想降低磁盘 IOPS (每秒读写次数)则提高间隔时间 # 想在意外非正常退出时尽量保存更多的下载进度则降低间隔时间 # 非正常退出：进程崩溃、系统崩溃、SIGKILL 信号、设备断电等 auto-save-interval=20 # 强制保存，即使任务已完成也保存信息到会话文件, 默认:false # 即使任务完成或删除时使用 --save-session 选项时也保存该任务. 此选项在这种情况下还会保存控制文件. 此选项可以保存被认为已经完成但正在做种的 BT 任务. # 开启后会在任务完成后保留 .aria2 文件，文件被移除且任务存在的情况下重启后会重新下载。 # 关闭后已完成的任务列表会在重启后清空。 force-save=false ## 下载连接设置 ## # 文件未找到重试次数 # 如果 aria2 从远程 HTTP/FTP 服务器收到 \"文件未找到\" 的状态超过此选项设置的次数后下载将会失败. 设置为 0 将会禁用此选项. 此选项仅影响 HTTP/FTP 服务器. 重试时同时会记录重试次数, 所以也需要设置 --max-tries 这个选项. max-file-not-found=10 # 最大尝试次数 # 设置最大尝试次数. 0 表示不限制，默认:5 max-tries=0 # 重试等待时间, 默认:0 (禁用) # 设置重试间隔时间(秒). 当此选项的值大于 0 时, aria2 在 HTTP 服务器返回 503 响应时将会重试. retry-wait=10 # 连接超时时间 # 设置建立 HTTP/FTP/代理服务器 连接的超时时间(秒). 当连接建立后, 此选项不再生效, 请使用 --timeout 选项. connect-timeout=10 # 超时时间。默认：60 timeout=10 # 最大同时下载任务数, 运行时可修改, 默认:5 max-concurrent-downloads=5 # 单服务器最大连接线程数, 任务添加时可指定, 默认:1 # 最大值为 16 (增强版无限制), 且受限于单任务最大连接线程数(split)所设定的值。 max-connection-per-server=16 # 单任务最大连接线程数, 任务添加时可指定, 默认:5 # 下载时使用 N 个连接. 如果提供超过 N 个 URI 地址, 则使用前 N 个地址, 剩余的地址将作为备用. 如果提供的 URI 地址不足 N 个, 这些地址多次使用以保证同时建立 N 个连接. 同一服务器的连接数会被 --max-connection-per-server 选项限制. split=64 # 文件最小分段大小, 添加时可指定, 默认:20M # aria2 不会分割小于 2*SIZE 字节的文件. 例如, 文件大小为 20MB, 如果 SIZE 为 10M, aria2 会把文件分成 2 段 [0-10MB) 和 [10MB-20MB), 并且使用 2 个源进行下载 (如果 --split = 2). 如果 SIZE 为 15M, 由于 2*15M  20MB, 因此 aria2 不会分割文件并使用 1 个源进行下载. 您可以增加数值的单位 K 或 M (1K = 1024, 1M = 1024K). 可以设置的值为: 1M-1024M. # 理论上值越小使用下载分段就越多，所能获得的实际线程数就越大，下载速度就越快，但受限于所下载文件服务器的策略。 min-split-size=4M # 文件分片大小，最小值为 1M，默认：1M # 设置 HTTP/FTP 下载的分配大小. aria2 根据这个边界分割文件. 所有的分割都是这个长度的倍数. 此选项不适用于 BitTorrent 下载. 如果 Metalink 文件中包含分片哈希的结果此选项也不适用. piece-length=1M # 允许分片大小变化。默认：false # 如果设置为\"否\", 当分片长度与控制文件中的不同时, aria2 将会中止下载. 如果设置为\"是\", 您可以继续, 但部分下载进度将会丢失. allow-piece-length-change=true # 分片选择算法 # 指定 HTTP/FTP 下载使用的分片选择算法. 分片表示的是并行下载时固定长度的分隔段. 如果设置为\"默认\", aria2 将会按减少建立连接数选择分片. 由于建立连接操作的成本较高, 因此这是合理的默认行为. 如果设置为\"顺序\", aria2 将选择索引最小的分片. 索引为 0 时表示为文件的第一个分片. 这将有助于视频的边下边播. --enable-http-pipelining 选项有助于减少重连接的开销. 请注意, aria2 依赖于 --min-split-size 选项, 所以有必要对 --min-split-size 选项设置一个合理的值. 如果设置为\"随机\", aria2 将随机选择一个分片. 就像\"顺序\"一样, 依赖于 --min-split-size 选项. 如果设置为\"几何\", aria2 会先选择索引最小的分片, 然后会为之前选择的分片保留指数增长的空间. 这将减少建立连接的次数, 同时文件开始部分将会先行下载. 这也有助于视频的边下边播. #stream-piece-selector=default # 最小速度限制 # 当下载速度低于此选项设置的值(B/s) 时将会关闭连接. 0 表示不设置最小速度限制. 您可以增加数值的单位 K 或 M (1K = 1024, 1M = 1024K). 此选项不会影响 BT 下载. lowest-speed-limit=0 # 全局最大下载速度 # 设置全局最大下载速度 (字节/秒). 0 表示不限制. 您可以增加数值的单位 K 或 M (1K = 1024, 1M = 1024K). max-overall-download-limit=0 # 最大下载速度 # 设置每个任务的最大下载速度 (字节/秒). 0 表示不限制. 您可以增加数值的单位 K 或 M (1K = 1024, 1M = 1024K). max-download-limit=0 # 禁用 IPv6, 默认:false disable-ipv6=true # 支持 GZip # 如果远程服务器的响应头中包含 Content-Encoding: gzip 或 Content-Encoding: deflate , 将发送包含 Accept: deflate, gzip 的请求头并解压缩响应. http-accept-gzip=true # URI 复用 # 当所有给定的 URI 地址都已使用, 继续使用已经使用过的 URI 地址. reuse-uri=false # URI 选择算法 # 指定 URI 选择的算法. 可选的值包括 \"按顺序\", \"反馈\" 和 \"自适应\". 如果设置为\"按顺序\", URI 将按列表中出现的顺序使用. 如果设置为\"反馈\", aria2 将根据之前的下载速度选择 URI 列表中下载速度最快的服务器. 同时也将有效跳过无效镜像. 之前统计的下载速度将作为服务器状态文件的一部分, 参见 --server-stat-of 和 --server-stat-if 选项. 如果设置为\"自适应\", 将从最好的镜像和保留的连接里选择一项. 补充说明, 其返回的镜像没有被测试过, 同时如果每个镜像都已经被测试过时, 返回的镜像还会被重新测试. 否则, 其将不会选择其他镜像. 例如\"反馈\", 其使用服务器状态文件. #uri-selector=feedback # 禁用 netrc，默认:false no-netrc=true # .netrc 文件路径 #netrc-path=$(HOME)/.netrc # 允许覆盖 # 如果相应的控制文件不存在时从头重新下载文件. 参见 --auto-file-renaming 选项. allow-overwrite=false # 文件自动重命名。默认:true # 重新命名已经存在的文件. 此选项仅对 HTTP(S)/FTP 下载有效. 新的文件名后会在文件名后、扩展名 (如果有) 前追加句点和数字(1..9999). auto-file-renaming=true # 使用 UTF-8 处理 Content-Disposition，默认:false # 处理 \"Content-Disposition\" 头中的字符串时使用 UTF-8 字符集来代替 ISO-8859-1, 例如, 文件名参数, 但不是扩展版本的文件名. content-disposition-default-utf8=true # 最低 TLS 版本，可选：TLSv1.1、TLSv1.2、TLSv1.3 默认:TLSv1.2 #min-tls-version=TLSv1.2 ## BT/PT 下载设置 ## # BT 监听端口(TCP), 默认:6881-6999 # 设置 BT 下载的 TCP 端口. 多个端口可以使用逗号 \",\" 分隔, 例如: 6881,6885. 您还可以使用短横线 \"-\" 表示范围: 6881-6999, 或可以一起使用: 6881-6889, 6999. # 直通外网的设备，比如 VPS ，务必配置防火墙和安全组策略允许此端口入站 # 内网环境的设备，比如 NAS ，除了防火墙设置，还需在路由器设置外网端口转发到此端口 listen-port=51413 # DHT 网络与 UDP tracker 监听端口(UDP), 默认:6881-6999 # 设置 DHT (IPv4, IPv6) 和 UDP 服务器使用的 UCP 端口. 多个端口可以使用逗号 \",\" 分隔, 例如: 6881,6885. 您还可以使用短横线 \"-\" 表示范围: 6881-6999, 或可以一起使用: 6881-6889, 6999. # 因协议不同，可以与 BT 监听端口使用相同的端口，方便配置防火墙和端口转发策略。 dht-listen-port=51413 # 启用 DHT (IPv4), 默认:true # 启用 IPv4 DHT 功能. 此选项同时会启用 UDP 服务器支持. PT 下载(私有种子)会自动禁用 enable-dht=true # 启用 DHT (IPv6)，默认:false # 启用 IPv6 DHT 功能. 如果种子设置为私有, 即使此选项设置为\"是\", aria2 也不会启用 DHT. 使用 --dht-listen-port 选项设置监听的端口. # 在没有 IPv6 支持的环境开启可能会导致 DHT 功能异常 enable-dht6=false # 外部 IP 地址 # 指定用在 BitTorrent 下载和 DHT 中的外部 IP 地址. 它可能被发送到 BitTorrent 服务器. 对于 DHT, 此选项将会报告本地节点正在下载特定的种子. 这对于在私有网络中使用 DHT 非常关键. 虽然这个方法叫外部, 但其可以接受各种类型的 IP 地址. # 使用场景：在家庭宽带没有公网 IP 的情况下可以把 BT 和 DHT 监听端口转发至具有公网 IP 的服务器，在此填写服务器的 IP ，可以提升 BT 下载速率。 #bt-external-ip= # DHT (IPv4) 文件，默认：$HOME/.aria2/dht.dat # 修改 IPv4 DHT 路由表文件路径. dht-file-path=/home/kurome/.aria2/dht.dat # DHT (IPv6) 文件，默认：$HOME/.aria2/dht6.dat # 修改 IPv6 DHT 路由表文件路径. dht-file-path6=/home/kurome/.aria2/dht6.dat # IPv4 DHT 网络引导节点 dht-entry-point=dht.transmissionbt.com:6881 # IPv6 DHT 网络引导节点 dht-entry-point6=dht.transmissionbt.com:6881 # 启用本地节点发现(LPD),PT 下载(私有种子)会自动禁用,默认:false bt-enable-lpd=true # 指定用于本地节点发现的接口，可能的值：接口，IP地址 # 如果未指定此选项，则选择默认接口。 #bt-lpd-interface= # 启用节点交换, 默认:true # 启用节点交换扩展. 如果种子设置为私有, 即使此选项设置为\"是\", aria2 也不会启用此功能. enable-peer-exchange=true # BT 下载最大连接数（单任务），运行时可修改。0 为不限制，默认:55 # 理想情况下连接数越多下载越快，但在实际情况是只有少部分连接到的做种者上传速度快，其余的上传慢或者不上传。 # 如果不限制，当下载非常热门的种子或任务数非常多时可能会因连接数过多导致进程崩溃或网络阻塞。 # 进程崩溃：如果设备 CPU 性能一般，连接数过多导致 CPU 占用过高，因资源不足 Aria2 进程会强制被终结。 # 网络阻塞：在内网环境下，即使下载没有占满带宽也会导致其它设备无法正常上网。因远古低性能路由器的转发性能瓶颈导致。 bt-max-peers=128 # BT 下载期望速度值（单任务），运行时可修改。单位 K 或 M 。默认:50K # BT 下载速度低于此选项值时会临时提高连接数来获得更快的下载速度，不过前提是有更多的做种者可供连接。 # 实测临时提高连接数没有上限，但不会像不做限制一样无限增加，会根据算法进行合理的动态调节。 bt-request-peer-speed-limit=10M # 全局最大上传速度, 运行时可修改, 默认:0 (无限制) # 设置全局最大上传速度 (字节/秒). 0 表示不限制. 您可以增加数值的单位 K 或 M (1K = 1024, 1M = 1024K). # 设置过低可能影响 BT 下载速度 max-overall-upload-limit=2M # 单任务上传速度限制, 默认:0 (无限制) # 设置每个任务的最大上传速度 (字节/秒). 0 表示不限制. 您可以增加数值的单位 K 或 M (1K = 1024, 1M = 1024K). max-upload-limit=0 # 最小分享率, 0 为一直做种, 默认:1.0 # 指定分享率. 当分享率达到此选项设置的值时会完成做种. 强烈建议您将此选项设置为大于等于 1.0. 如果您想不限制分享比率, 可以设置为 0.0. 如果同时设置了 --seed-time 选项, 当任意一个条件满足时将停止做种. seed-ratio=1.0 # 最小做种时间（分钟） # 此选项设置为 0 时, 将在 BT 任务下载完成后不进行做种. seed-time=30 # 做种前检查文件哈希, 默认:true # 如果设置为\"是\", 当使用 --check-integrity 选项完成哈希检查及文件完成后才继续做种. 如果您希望仅当文件损坏或未完成时检查文件, 请设置为\"否\". 此选项仅对 BT 下载有效 bt-hash-check-seed=true # 继续之前的BT任务时, 无需再次校验, 默认:false # 不检查之前下载文件中每个分片的哈希值. bt-seed-unverified=false # BT tracker 服务器连接超时时间（秒）。默认：60 # 建立连接后，此选项无效，将使用 bt-tracker-timeout 选项的值 bt-tracker-connect-timeout=10 # BT tracker 服务器超时时间（秒）。默认：60 bt-tracker-timeout=10 # BT 服务器连接间隔时间。默认：0 (自动) # 设置请求 BT 服务器的间隔时间 (秒). 此选项将完全覆盖服务器返回的最小间隔时间和间隔时间, aria2 仅使用此选项的值.如果设置为 0, aria2 将根据服务器的响应情况和下载进程决定时间间隔. #bt-tracker-interval=0 # BT 下载优先下载文件开头或结尾 # 尝试先下载每个文件开头或结尾的分片. 此选项有助于预览文件. 参数可以包括两个关键词: head 和 tail. 如果包含两个关键词, 需要使用逗号分隔. 每个关键词可以包含一个参数, SIZE. 例如, 如果指定 head=SIZE, 每个文件的最前 SIZE 数据将会获得更高的优先级. tail=SIZE 表示每个文件的最后 SIZE 数据. SIZE 可以包含 K 或 M (1K = 1024, 1M = 1024K). bt-prioritize-piece=head=32M,tail=32M # 保存通过 WebUI(RPC) 上传的种子文件(.torrent)，默认:true # 在 dir 选项设置的目录中保存上传的种子文件或 Metalink 文件. 文件名包括 SHA-1 哈希后的元数据和扩展名两部分. 对于种子文件, 扩展名为 '.torrent'. 对于 Metalink 为 '.meta4'. 如果此选项设置为\"否\", 通过 aria2.addTorrent() 或 aria2.addMetalink() 方法添加的下载将无法通过 --save-session 选项保存. # 所有涉及种子文件保存的选项都建议开启，不保存种子文件有任务丢失的风险。 # 通过 RPC 自定义临时下载目录可能不会保存种子文件。 rpc-save-upload-metadata=true # 下载种子文件(.torrent)自动开始下载, 默认:true，可选：false|mem # true：保存种子文件 # false：仅下载种子文件 # mem：将种子保存在内存中 # 如果设置为\"是\"或\"仅内存\", 当后缀为 .torrent 或内容类型为 application/x-bittorrent 的文件下载完成时, aria2 将按种子文件读取并下载该文件中提到的文件. 如果设置为\"仅内存\", 该种子文件将不会写入到磁盘中, 而仅会存储在内存中. 如果设置为\"否\", 则 .torrent 文件会下载到磁盘中, 但不会按种子文件读取并且其中的文件不会进行下载. follow-torrent=true # 种子文件下载完后暂停任务，默认：false # 在开启 follow-torrent 选项后下载种子文件或磁力会自动开始下载任务进行下载，而同时开启当此选项后会建立相关任务并暂停。 pause-metadata=false # 保存磁力链接元数据为种子文件(.torrent), 默认:false # 保存种子文件为 \".torrent\" 文件. 此选项仅对磁链生效. 文件名为十六进制编码后的哈希值及 \".torrent\"后缀. 保存的目录与下载文件的目录相同. 如果相同的文件已存在, 种子文件将不会保存. bt-save-metadata=true # 加载已保存的元数据文件(.torrent)，默认:false # 当使用磁链下载时, 在从 DHT 获取种子元数据之前, 首先尝试加载使用 --bt-save-metadata 选项保存的文件. 如果文件加载成功, 则不会从 DHT 下载元数据. bt-load-saved-metadata=true # 删除 BT 下载任务中未选择文件，默认:false # 当 BT 任务完成后删除未选择的文件. 要选择需要下载的文件, 请使用 --select-file 选项. 如果没有选择, 则所有文件都默认为需要下载. 此选项会从磁盘上直接删除文件, 请谨慎使用此选项. bt-remove-unselected-file=true # BT强制加密, 默认: false # 启用后将拒绝旧的 BT 握手协议并仅使用混淆握手及加密。可以解决部分运营商对 BT 下载的封锁，且有一定的防版权投诉与迅雷吸血效果。 # 此选项相当于后面两个选项(bt-require-crypto=true, bt-min-crypto-level=arc4)的快捷开启方式，但不会修改这两个选项的值。 bt-force-encryption=true # BT加密需求，默认：false # 启用后拒绝与旧的 BitTorrent 握手协议(\\19BitTorrent protocol)建立连接，始终使用混淆处理握手。 #bt-require-crypto=true # BT最低加密等级，可选：plain（明文），arc4（加密），默认：plain # 设置加密方法的最小级别. 如果节点提供多种加密方法, aria2 将选择满足给定级别的最低级别. #bt-min-crypto-level=arc4 # 分离仅做种任务，默认：false # 从正在下载的任务中排除已经下载完成且正在做种的任务，并开始等待列表中的下一个任务。 # 统计当前活动下载任务(参见 -j 选项) 时排除仅做种的任务. 这意味着, 如果参数设置为 -j3, 此选项打开并且当前有 3 个正在活动的任务, 并且其中有 1 个进入做种模式, 那么其会从正在下载的数量中排除(即数量会变为 2), 在队列中等待的下一个任务将会开始执行. 但要知道, 在 RPC 方法中, 做种的任务仍然被认为是活动的下载任务. bt-detach-seed-only=true ## 客户端伪装 ## # 自定义 User Agent user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.63 Safari/537.36 Edg/93.0.961.47 # BT 客户端伪装 # PT 下载需要保持 user-agent 和 peer-agent 两个参数一致 # 部分 PT 站对 Aria2 有特殊封禁机制，客户端伪装不一定有效，且有封禁账号的风险。 # 自定义 User Agent，默认：aria2/$VERSION #user-agent=Deluge 1.3.15 # Peer Agent # 指定 BT 扩展握手期间用于节点客户端版本的字符串. peer-agent=Deluge 1.3.15 # 节点 ID 前缀 # 指定节点 ID 的前缀. BT 中节点 ID 长度为 20 字节. 如果超过 20 字节, 将仅使用前 20 字节. 如果少于 20 字节, 将在其后不足随机的数据保证为 20 字节. peer-id-prefix=-DE13F0- ## 执行额外命令 ## # 下载停止后执行的命令 # 从 正在下载 到 删除、错误、完成 时触发。暂停被标记为未开始下载，故与此项无关。 #on-download-stop=/home/kurome/.aria2/delete.sh # 下载完成后执行的命令 # 此项未定义则执行 下载停止后执行的命令 (on-download-stop) #on-download-complete=/home/kurome/.aria2/clean.sh # 下载错误后执行的命令 # 此项未定义则执行 下载停止后执行的命令 (on-download-stop) #on-download-error= # 下载暂停后执行的命令 #on-download-pause= # 下载开始后执行的命令 #on-download-start= # BT 下载完成后执行的命令 #on-bt-download-complete= ## RPC 设置 ## # 启用 JSON-RPC/XML-RPC 服务器, 默认:false enable-rpc=true # 接受所有远程请求, 默认:false # 在 RPC 响应头增加 Access-Control-Allow-Origin 字段, 值为 * .web界面跨域权限需要 rpc-allow-origin-all=true # 允许外部访问, 默认:false rpc-listen-all=true # RPC 监听端口, 默认:6800 rpc-listen-port=6800 # RPC 密钥, v1.18.4新增功能, 取代 --rpc-user 和 --rpc-passwd 选项 rpc-secret=SetForYourself # RPC 最大请求大小 # 设置 JSON-RPC/XML-RPC 最大的请求大小. 如果 aria2 检测到请求超过设定的字节数, 会直接取消连接. rpc-max-request-size=10M # RPC 服务 SSL/TLS 加密, 默认：false # RPC 将通过 SSL/TLS 加密传输. RPC 客户端需要使用 https 协议连接服务器. 对于 WebSocket 客户端, 使用 wss 协议. 使用 --rpc-certificate 和 --rpc-private-key 选项设置服务器的证书和私钥. # 不推荐开启，建议使用 web server 反向代理，比如 Nginx、Caddy ，灵活性更强。 #rpc-secure= # 在 RPC 服务中启用 SSL/TLS 加密时的证书文件, # 使用 PEM 格式时，您必须通过 --rpc-private-key 指定私钥 #rpc-certificate=/path/to/certificate.pem # 在 RPC 服务中启用 SSL/TLS 加密时的私钥文件 #rpc-private-key=/path/to/certificate.key # 事件轮询方式, 可选：epoll, kqueue, port, poll, select, 不同系统默认值不同 # 设置事件轮训的方法. 对于 epoll, kqueue, port 和 poll, 只有系统支持时才可用. 最新的 Linux 支持 epoll. 各种 *BSD 系统包括 Mac OS X 支持 kqueue. Open Solaris 支持 port. 默认值根据您使用的操作系统不同而不同. #event-poll=select ## 高级选项 ## # 启用异步 DNS 功能。默认：true #async-dns=true # 指定异步 DNS 服务器列表，未指定则从 /etc/resolv.conf 中读取。 #async-dns-server=119.29.29.29,223.5.5.5,8.8.8.8,1.1.1.1 # 指定单个网络接口，可能的值：接口，IP地址，主机名 # 如果接口具有多个 IP 地址，则建议指定 IP 地址。 # 已知指定网络接口会影响依赖本地 RPC 的连接的功能场景，即通过 localhost 和 127.0.0.1 无法与 Aria2 服务端进行讯通。 #interface= # 指定多个网络接口，多个值之间使用逗号(,)分隔。 # 使用 interface 选项时会忽略此项。 #multiple-interface= ## 日志设置 ## # 日志文件保存路径，默认：不保存 # 如果设置为 \"-\", 日志则写入到 stdout. 如果忽略或设置为空字符串(\"\"), 日志将不会记录到磁盘上. #log= # 日志级别，可选 debug, info, notice, warn, error 。默认：debug #log-level=warn # 控制台日志级别，可选 debug, info, notice, warn, error ，默认：notice console-log-level=notice # 安静模式，禁止在控制台输出日志，默认：false quiet=false # 下载进度摘要输出间隔时间（秒），0 为禁止输出。默认：60 summary-interval=0 ## BitTorrent trackers ## # BT 服务器地址 2022/02/26 # 逗号分隔的 BT 服务器地址. 如果服务器地址在 --bt-exclude-tracker 选项中, 其将不会生效. bt-tracker=udp://open.tracker.cl:1337/announce,udp://tracker.opentrackr.org:1337/announce,udp://9.rarbg.com:2810/announce,udp://www.torrent.eu.org:451/announce,udp://tracker2.dler.org:80/announce,udp://tracker.torrent.eu.org:451/announce,udp://tracker.moeking.me:6969/announce,udp://tracker.bitsearch.to:1337/announce,udp://tracker.0x.tf:6969/announce,udp://tracker-udp.gbitt.info:80/announce,udp://tr.cili001.com:8070/announce,udp://retracker.lanta-net.ru:2710/announce,udp://open.stealth.si:80/announce,udp://ipv4.tracker.harry.lu:80/announce,udp://explodie.org:6969/announce,udp://exodus.desync.com:6969/announce,udp://bt2.archive.org:6969/announce,udp://bt1.archive.org:6969/announce,https://tracker.nanoha.org:443/announce,https://tracker.lilithraws.org:443/announce 更多：Aria2 完美配置\nAria2 Web 控制台\nAira2 没有软件界面，程序员可以用代码执行任务，但普通用户怎样添加下载任务呢？——打开浏览器，输入网址aria2c.com（YAAW 的中文版）就可以打开 Aria2 Web 控制台。\nJSON-RPC Path 默认为: http://localhost:6800/jsonrpc，如果提示 “Aria2 RPC 服务器错误”，按照以下方法修改：\n 普通情况设置为: http://host:port/jsonrpc  host: 指运行 Aria2 所在机器的 IP 或者名字 port: 使用 --rpc-listen-port 选项设置的端口, 未设置则是 6800；可通过 lsof -i:6800 查看端口是否被占用   使用 --rpc-secret=xxxxxx 选项设置为: http://token:xxxxxx@host:port/jsonrpc 使用 --rpc-user=user --rpc-passwd=pwd 选项设置为: http://user:pwd@host:port/jsonrpc 以上JSON-RPC Path 中的 http 可以用 ws 替代, 代表使用 WebSocket 协议。换用 ws 也可能解决 “Aria2 RPC 服务器错误”。 当使用 https://aria2c.com 访问时, 可能需要使用 https 或 wss 协议。  在 Web UI 中对 Aria2 的设置会在 Aria2 重启后丢失,，必要的设置请写入配置文件。\n已经下载完成的任务会在 Aria2 重启后消失, 除非启用了 --force-save 选项。\nProtocol **HTTP / HTTPS / FTP / SFTP **\n超文本传输协议（HTTP / HTTPS）和 文件传输协议（FTP / SFTP）将文件放到服务器上，然后由服务器传送到不同的用户机器上，称为Client-Server Model简称C/S模式，或者叫一对多模式。\n缺点是：当非常多的用户同时访问和下载服务器上的文件时，由于服务器处理能力和带宽的限制，下载速度会急剧下降，有的用户可能访问不了服务器。\nBitTorrent 协议\nBitTorrent(简称BT)是一个文件分发协议，每个下载者在下载的同时不断向其他下载者上传已下载的数据。BT协议与FTP协议不同，特点是下载的人越多，下载速度越快，原因在于每个下载者将已下载的数据提供给其他下载者下载，充分利用了用户的上载带宽。通过一定的策略保证上传速度越快，下载速度也越快。在很短时间内，BitTorrent协议成为一种新的变革技术。\nBitTorrent 的发展依赖于对等网络 (Peer - to - Peer 简称 P2P)。P2P技术体现了互联网最根本的内涵——自由和免费，它的主要优点如下：\n 对等性高：非中心化，互联网回归本色——联系和传输； 扩展性强：用户扩展与资源、服务、系统同步扩展； 健壮性高：服务分散和自适应，耐攻击、高容错性； 性价比高：P2P成本低、存储和技术能力强； 负载均衡：分布存储和技术，整个网络负载得以均衡。  在P2P网络中，每个参与的节点既是服务器又是客户端，既是信息的提供者又是信息的消费者。P2P信息检索的目的就是网络中的任意节点都可以提交检索的请求，然后这些检索通过相关信息的节点将会回应请求，按照某种路由机制路由到本地相关的内容，以对等的形式直接传送到请求节点上。\n检索过程分为以下几个阶段：每个节点在加入网络的时候，会对存储在本节点上的内容进行索引，以满足本地内容检索的目的。然后按某种预定的规则选择一些节点作为自己的邻居，加入到P2P网络当中。发起者P提出检索请求q，并将q发送给自己的邻居，P的邻居收到q后，再按照某种策略转发给它在网络中的其它邻居节点。这样，q就在整个网络中传播开来。收到请求q的节点如果存储有相应内容信息 , 则将对应的内容返回。\n普通的HTTP/FTP下载使用TCP/IP协议，BitTorrent协议是架构于TCP/IP协议之上的一个P2P文件传输协议，处于TCP/IP结构的应用层。 BitTorrent协议本身也包含了很多具体的内容协议和扩展协议，并在不断扩充中。\n根据BitTorrent协议，文件发布者会根据要发布的文件生成提供一个.torrent文件，即种子文件，也简称为“种子”。\n种子还有如下相关概念：\n 发布BT种子的人，做种多少天指的就是持续多少天不撤种。这期间如果有别人下完了，就叫出种。下完的人可以继续做种。这时发布种子的人就可以不做种了，叫撤种。 一个资源只要有一个人在做种，那就其他人就可以继续下。如果没人做种了，叫断种，这是资源就死了，下不了了。某人长时间一直做种，叫保种。  .torrent文件本质上是文本文件，包含Tracker信息和文件信息两部分。Tracker信息主要是BT下载中需要用到的Tracker服务器的地址和针对Tracker服务器的设置，文件信息是根据对目标文件的计算生成的，计算结果根据BitTorrent协议内的B编码规则进行编码。它的主要原理是需要把提供下载的文件虚拟分成大小相等的块，块大小必须为2k的整数次方（由于是虚拟分块，硬盘上并不产生各个块文件），并把每个块的索引信息和Hash验证码写入种子文件（.torrent）中。所以，种子文件（.torrent）就是被下载文件的“索引”。\n下载者要下载文件内容，需要先得到相应的.torrent文件，然后使用BT客户端软件进行下载。\n下载时，BT客户端首先解析.torrent文件得到Tracker地址，然后连接Tracker服务器。Tracker服务器回应下载者的请求，提供下载者其他下载者（包括发布者）的IP。下载者再连接其他下载者，根据.torrent文件，两者分别对方告知自己已经有的块，然后交换对方没有的数据。此时不需要其他服务器参与，分散了单个线路上的数据流量，因此减轻了服务器负担。\n下载者每得到一个块，需要算出下载块的Hash验证码与.torrent文件中的对比，如果一样则说明块正确，不一样则需要重新下载这个块。这种规定是为了解决下载内容准确性的问题。\n从 BT 客户端角度考虑，下载原理分为以下几步：\n 根据 BitTorrent 协议，文件发布者会根据要发布的文件生成提供一个 .torrent 文件。客户端可从 Web 服务器上下载种子文件，并从中得到 Tracker 服务器 URL。 根据 Tracker URL 与 Tracker 服务器建立连接，并从服务器上得到 Peers 信息。 根据 Peers 信息与一个 Peer 建立连接，依据 Peer wire 协议完成握手，并从 Peer 端下载数据文件。同时监听 Peer 的连接，并给 Peer 上传数据文件。  迅雷，俗称吸血雷：\n 吸血就是指一些客户端在进行P2P下载时，从其它客户端下载的数据量非常多，但是分享给其它客户端的数据非常少，下载完成后立即关机走人的行为 而迅雷就是这样的一个下载器，迅雷的服务器疯狂索取资源，但自己又不上传资源给别人），当收集了大量资源后，进而下载限速，开启付费会员制度  BT下载讲究共享精神，这跟互联网的共享精神一脉相承，所以请不要在BT下载器设置里面限制上传速度。\n鉴于这类自私行为对其它合理使用P2P网络的用户的伤害，现在的很多P2P软件都加入反吸血功能。就是说检测到特定用户的吸血行为或者吸血软件时自动对这些用户降权处理，简单来说就是你的上传速度低的话，你的下载速度也不会特别快。\n这里又要多嘴一句\n 迅雷靠着自身在国内多年的发展，服务器里囤积了大量资源，所以很多其他BT下载器下载不动的资源，可能只有迅雷下载的动（因为它原来从别人那里下载了后存在了它的服务器上） 同理，很多文件可能只有115才能能离线下载，也是因为当年的115就存储了大量的资源在它服务器上 这里顺便可以说一下，所谓的百度云秒离线功能，不过是在你离线下载之前，已经有人把这个文件离线下载到百度云服务器中了  BT下载带来的好处\n 快。减少了网路传输节点。 减轻服务器压力。如果某公司有新版本软件推出（如LOL游戏更新时），服务器必定会人山人海，而使用BT能大大减轻服务器的负担，节约服务器的购置成本。 保护隐私。与有http那种中央服务器的网络系统不同，BT下载节点能遍布整个互联网（每个人都是分享者与下载者），给包括开发者在内的任何人、组织、或政府带来监控难题。  坏处当然也有，从上面第3点不难得出，BT下载很容易导致一个问题：盗版泛滥——海盗湾。\n上面说过了，想加入BT下载的无中心网络，首先需要找Tracker服务器问路，于是Tracker服务器成为了版权组织打击的重点，他们的想法很明确，只要除掉了Tracker，BT下载就完了。\n然而魔高一尺道高一丈，需求带动发展，这反而促使了BT技术的一次大升级，这带来了磁力链接。\nMagNet 协议\nMagNet协议，也就是磁力链接，简称磁链。 Magnet不需要Tracker服务器，也不需要.torrent文件，仅需要一串字符就可以进行文件下载。\n磁力链接基于的是DHT网络技术，因此可以在无固定Tracker服务器的情况下下载，实际过程是把所有下载者都变成一个小型Tracker服务。\nDHT技术：2002年，纽约大学的两个教授Petar Maymounkov和David Mazières发表了一篇论文，提出了一种真正去中心化的“点对点”下载模型，他们将其称为Kademlia方法。2005年，BT软件开始引入这种技术，在BT中被称为DHT协议（Distributed Hash Table，分布式哈希表）。\nDHT是一种分布式存储方法。DHT的作用是找到那些与本机正在下载（上传）相同文件的对端主机（Peer），当然，实现这一过程并不依赖Tracker服务器。在DHT网络中的每个客户端负责一个小范围的路由，并负责存储一小部分数据，从而实现整个DHT网络的寻址和存储。这种信息获取方式保证了整个网络没有单个的中心，即使一个节点下线，依然可以通过其他节点来获取文件，因此也就不需要Tracker服务器来告诉你，其他节点在什么地方。\nPEX：是Peer Exchange的简写，我们可以将其理解为“节点信息交换”。虽然DHT解决了去中心化的问题，但要在没有“中心协调员”（Tracker）的情况下实现高效寻址，就要借助PEX。PEX所提供的功能有点类似于以前的Tracker服务器，但工作方式却非常不同，我们可以打个比方来说明：\n 当你得到一个磁力链接并进行下载时，使用比如迅雷，迅雷就会实例化出一个DHT节点，加入DHT网络 把DHT网络比作一个朋友圈子，当你被A带进这个朋友圈，此刻你就只认识A而已 但是你的目的是想找唐纳德·特朗普（川普）总统，所以你就问A要川普的联系方式，但是A也没有川普的联系方式， 他介绍了一个美国朋友B给你认识 于是你去问B要川普的联系方式，B其实也没有川普的联系方式，但是B认识一个美国州长C 于是你又得到了C的联系方式，C把川普的联系方式告诉你之后，你就可以写信或者致电给川普了  这里相关的有个有趣的理论「六度分隔理论」（也叫六度空间理论）：简单来说，就是最多通过6个中间人你就能够认识世界上任何一个陌生人。\nMagnet links（磁力链接）示例：\nmagnet:?xt=urn:btih:36684b463ca2aa2f9347b18e9f6b1a9090bdb073\u0026dn=Microsoft+iSCSI+Initiator  magnet：协议名。 xt：exact topic的缩写，表示资源定位点。BTIH（BitTorrent Info Hash）表示哈希方法名，这里还可以使用SHA1和MD5。这个值是文件的标识符，是不可缺少的。 dn：display name的缩写，表示向用户显示的文件名。这是一个可选项。 tr：tracker的缩写，表示tracker服务器的地址。这是一个可选项，本例中并未出现。  可能看出了DHT+PEX+Magnet Link模式中的一个问题——BT客户端的“第一步是如何迈出的”，套用在介绍PEX时使用的例子，那就是你怎怎么进入A的这个朋友圈的（即DHT节点如何进入DHT网络）？这确实是个问题。解决这个问题依然需要一台服务器（bootstrap node），不过这台服务器所起的作用与Tracker不同，它仅负责接纳DHT节点如何进入DHT网络，当DHT节点与其它DHT节点“搭上了话”，之后这台服务器就没有什么用处了。bootstrap node可以是不同BT客户端厂商独立运营的，也可以是几家联合共用，总之，它是分散的，只要在客户端软件中内置一张表单，那客户端就将有非常多的入口可供选择。\neD2k 协议\nBT / 磁力 / eD2k都是P2P技术 。eD2k链接对应的客户端，如eMule电骡是共享软件，而Magnet磁链对应的BT软件则是下载软件。这让它们在使用上，有着很多根本性的区别：\n BT使用的时候，只要你不下载东西你就不会上传 eMule电骡不同，比如，开启eMule电骡后，第一件事做的并不是什么下载，而是设置共享目录，该目录中的所有文件，都会实时共享到eD2k网络和KAD网络中。 目录中共享了的文件都会生成eD2k链接，所有人通过相应的eD2k链接，都能够拿到你共享的文件，一旦有人下载相应文件，那么你的eMule客户端就会上传数据，换言之，你想下载别人的文件，需要别人开着eMule客户端 我们平时使用eD2k链接下载，资源也是来自他人eMule所共享的文件的。当然，共享目录中也可以啥都不放，但很多eMule客户端都拥有队列优先级机制，上传得少，下载速度也会被限制。  电驴可以说是进化版的BT，用户不需要下载什么种子文件了，直接在“电驴”软件上输入eD2k开头的一长串代码一样的链接，就能下载。\n电驴以及后来的电骡、VERYCD电驴还有各种类似的软件，采用的eD2k网络仍是基于服务器的，你需要连接到服务器并从服务器索引 / 查找用户或者文件\n重要的是电驴提供的其中一种模式——KAD网络（类似磁力下载中的DHT网络），能够脱离中央服务器，直接实现网络来用户之间的点对点传输\n历史证明，这个脱离中央服务器的革新，真的十分十分的重要——这是电驴软件在面对盗版问题时，能够生存下来的主要原因，因为他们可以说，那是用户之间的自发传输行为，没有经过服务器\n但是，尽管电驴做了如此多的革新，但还是逃不过被时代淘汰的命运，客户端对于大部分人来说配置起来十分复杂，愿意一直开着服务器上传资源的人越来越少，更多人只想单纯的索取（类似上文提到的迅雷吸血行为），如今使用eD2k分享资源的人实在算少数，远不如磁力下载。\nOthers AriaNg\nAriaNg 是一个让 aria2 更容易使用的现代 Web 前端\n 使用很简单，将文件下载解压即可，可以本地打开 index.html 文件，也可上传到服务器。 如果您懒得部署 AriaNg ，可以直接访问现成的 http://a2.ssss.fun 。 打开后需要配置 AriaNg，打开 AriaNg 设置 - RPC，修改 Aria2 RPC 地址 和 Aria2 RPC 密钥 ，点击 重新加载 AriaNg 即可。  WebUI-Aria2\n这个项目的目标是创建世界上最好和最热门的界面来与 aria2 交互。\n使用非常简单，只需在任何网络浏览器中下载并打开 index.html。\nAria2 for ….\n比如 YAAW for Chrome、Aria2 for Chrome 、Aria2 for Edge 之类的。\n在浏览器中直接内置一个 AriaNg，用于直接管理 Aria2。\nUsing Aria2 as a Daemon\n运行 gnome-session-properties打开应用程序首选项管理，添加：\n Name: Aria2 Daemon Command: /usr/bin/aria2c --conf-path=/home/kurome/.aria2/aria2.conf -D  会建立 .config/autostart/aria2c.desktop\n[Desktop Entry] Type=Application Exec=/usr/bin/aria2c --conf-path=/home/vane/.aria2/aria2.conf -D Hidden=false NoDisplay=false X-GNOME-Autostart-enabled=true Name[en_US]=Aria2 Daemon Name=Aria2 Daemon Comment[en_US]= Comment= BT 下载预热\n是这样滴，和很多BT客户端一样，Aria2有个dht.dat文件(开启ipv6还有个dht6.dat)，这玩意用于存储一种叫做DHT Routing Table的东西，DHT网络由无数节点组成，你接触到一个后能通过它接触到更多的节点，Aria2我记得是有内置的节点，但是！如果你在Aria2第一次运行的时候直接下载磁力链接或者冷门种子，你很可能遇到连MetaData都无法获取的情况，这就是因为第一次只是初始化dht.dat文件，你本地不存在DHT Routing Table的缓存，所以你无法从DHT网络中获取足够的数据。\n那么怎么办？我的建议是，找个热门种子(千万建议是种子，而不是磁力链接)，然后下一波，挂着做种，过几个小时后退出Aria2，或者等Aria2会话自动保存，你会发现dht.dat从空文件变成有数据了，这时候你下载就会正常很多。\n什么是PT，PT和BT有什么不同？\n答：PT（Private Tracker）下载其实也是Bt下载的一种，但有两个明显的改进：一是私密的小范围下载，二是进行流量统计，根据上载量决定你的权限。\nBT下载时，软件会分析.torrent种子文件得到Tracker地址，然后连接Tracker服务器，服务器返回其他下载者的IP，下载者再与这些IP联系进行下载，从而减轻了服务器的负担，BT下载的Tracker是公开的，而Private Tracker 下载(PT下载)的Tracker则是私有的，每个人的Tracker是不同的，即passkey不同，passkey对PT下载者很重要，所以不要轻易泄露出去。\n其实和通常BT相比，PT就是多了一个passkey验证，这样就能保证未注册的用户不能下载。所以passkey很重要，一旦发现有问题，就要到站点上去重置passkey。Tracker Server根据passkey把BT客户端上传量和下载量进行计算，从而算出分享率(上传量/下载量)。如果分享率太小，将会被删除帐号，从而不能下载。\n这样Private Tracker 下载(PT下载)是一种小范围的BT下载，通过禁用DHT有要求地选择并控制用户数量，这样，在有限的范围内，下载的用户基本上都可以达到自己的宽带上限，Private Tracker 下载(PT下载)下载还通过论坛等方式的约束机制将BT下载的理念现实化，真正让用户做到下载的过程中努力上传。因此，Private Tracker 下载(PT下载)的速度很快，能够让用户款待得到最大程度的使用。\nPT通过对做种时间和流量的要求在一定程度上避免了BT中存在的下完不做种的现象，因此在网络上，尤其是需要大文件（如高清）资源交换的时候广受欢迎，在PT站里，“水管”代表上传带宽的大小，大水管可以通过快速的上传获得积分，PT站点也会采取措施（比如做种时间，优惠等）使上传较慢的小水管能够参与贡献和共享资源。\nRPC\n首先了解什么叫RPC，为什么要RPC，RPC是指远程过程调用，也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。\n比如说，一个方法可能是这样定义的：\nEmployee getEmployeeByName(String fullName) 那么：\n 首先，要解决通讯的问题，主要是通过在客户端和服务器之间建立TCP连接，远程过程调用的所有交换的数据都在这个连接里传输。连接可以是按需连接，调用结束后就断掉，也可以是长连接，多个远程过程调用共享同一个连接。 第二，要解决寻址的问题，也就是说，A服务器上的应用怎么告诉底层的RPC框架，如何连接到B服务器（如主机或IP地址）以及特定的端口，方法的名称名称是什么，这样才能完成调用。比如基于Web服务协议栈的RPC，就要提供一个endpoint URI，或者是从UDDI服务上查找。如果是RMI调用的话，还需要一个RMI Registry来注册服务的地址。 第三，当A服务器上的应用发起远程过程调用时，方法的参数需要通过底层的网络协议如TCP传递到B服务器，由于网络协议是基于二进制的，内存中的参数的值要序列化成二进制的形式，也就是序列化（Serialize）或编组（marshal），通过寻址和传输将序列化的二进制发送给B服务器。 第四，B服务器收到请求后，需要对参数进行反序列化（序列化的逆操作），恢复为内存中的表达方式，然后找到对应的方法（寻址的一部分）进行本地调用，然后得到返回值。 第五，返回值还要发送回服务器A上的应用，也要经过序列化的方式发送，服务器A接到后，再反序列化，恢复为内存中的表达方式，交给A服务器上的应用  为什么RPC呢？就是无法在一个进程内，甚至一个计算机内通过本地调用的方式完成的需求，比如比如不同的系统间的通讯，甚至不同的组织间的通讯。由于计算能力需要横向扩展，需要在多台机器组成的集群上部署应用，\nRPC的协议有很多，比如最早的CORBA，Java RMI，Web Service的RPC风格，Hessian，Thrift，甚至Rest API。\n其他下载工具\n qBittorrent Transmission rTorrent Deluge  有支持ed2k的计划吗？\n真是笑死我了，你们难道真的认为那所谓迅雷等国产BT下载软件会使用真正的eDonkey网络？\n非也！它们只不过通过ed2k链接所列出的哈希值 直接链接到它们服务器自身（如迅雷、百度）所存储的文件 或链接到BitTorrent协议的种子和磁力链接上。你们用的软件不是P2P（Peer to Peer），而是P2SP（Peer to Server and to Peer）！\n如果你们用过真正的ed2k下载器（如eMule、aMule）的话，你们会发现，真正的eDonkey网络早已消亡，截至目前全球用户也就50-60万的样子。\n最后，作为曾经的eMule老用户，我可以说明真正的eDonkey网络不仅有繁琐的排队机制，还有文件优先级网络优先级等复杂的设定，远比你们想像中难用的多。\nwarez groups\n  RELOADED\nRELOADED成立于2004年，前身是传奇破解组DEVIANCE，曾经在2次重大的政府扫荡中生存下来，由于竞争对手HOODLUM和VENGEANCE被端掉，RELOADED从此称霸PC游戏破解圈，在新游的首发破解上，RELOADED能占据80%。\nRELOADED也是国内最常见的PC游戏破解组，你在各个资源站看到标题写着某某游戏“R组”破解，就是他们的“杰作”。\n高光时刻：\n1、各大破解组都在追求游戏发售前破解游戏，而RELOADED最著名的应该就是2008年对《刺客信条》的破解了，R组在游戏发售1个月之前就放出破解版。\n2、修复了《彩虹六号：维加斯2》数字版的BUG，育碧当年对《彩虹六号：维加斯2》数字版无法运行的BUG毫无办法，最终只能给玩家发放RELOADED的游戏破解补丁…这次事件让育碧颜面扫地，却成就了RELOADED。\n3、打破《分裂细胞：混沌理论》424天不被破解的记录。\n  SKIDROW\nSKIDROW 是来自美国的游戏破解组，成立时间大概是上个世纪90年代，主要作品有《猎杀潜艇5》、《刺客信条2》等，之后由于人员解散，直到2007年 SKIDROW 才重新开始活跃。\nSKIDROW 在同行中的口碑一般，被RELOADED等破解组爆出过盗用其他破解组代码的料。\n1、 Skidrow成名于DRM事件，DRM是育碧的反破解系统，Skidrow破解组成功破解了育碧两袋DRM系统，最著名的作品是对《刺客信条2》的破解。\n2、2017年，继CPY之后，成功破解了最新的Denuvo64加密技术。并批评CPY只会用Emulation(仿真器)而不是真正的破解。\n  Razor1911\nRazor1911 是来自挪威的破解组，成立于1985年，最初由3个年轻的计算机爱好者组成，主要是破解Commodore64和amiga机种的游戏软件，名称中的1911是因为1991在16进制里写作777，代表不朽。\n作为老牌破解组之一， Razor1911在2001年和2004年的FBI两次反盗版行动中幸存下来，不知道是不是因为名字带来的好运。在业内，如果说RELOADED是以高产著称，那么Razor1911就是以技术见长。\nRazor1911破解组最著名的作品应该是《星际争霸：母巢之战》的硬盘版，间接导致了星际争霸在全世界的流行。\n1、制作《星际争霸：母巢之战》硬盘版，在这一版的星际争霸中，所有文件的体积加起来只有100m多一点，而最为经典的地方就在于他们把光盘版中两个600m左右的install.exe文件压缩到了只有22m的大小。\n2、破解《GTA4》和该游戏价值20万美元的SecuRom反破解系统。\n3、破解EA origin平台的加密技术。\n4、破解《孤岛危机》和《上古卷轴5：天际》。\n  CPY\nCPY全名 CONSPiR4CY，是来自于意大利的破解组，成立于1999年，相比上面的三大破解组成立较晚。但是最近几年，CPY在破解了Denuvo加密技术（D加密）后名声大噪，俨然已超越了上面三大破解组。\n在国内有CPY掌握核心技术的说法，Steam、EA origin、Denuvo等加密技术先后被CPY破解。\n高光时刻：\n1、2015年，继Steam平台后，EA origin平台加密技术被破解，宣布了这套加密系统彻底完蛋。\n2、破解D加密技术，随后一系列热门游戏遭到破解，包括：《合金装备5 幻痛》《古墓丽影 崛起》《毁灭战士4》《看门狗2》等等。\n  CODEX\n会破解D加密，如今几乎已经垄断破解业。并在.nfo文件招聘栏中提到CODEX什么都不要，只要竞争!\n2022年2月，CODEX宣告退休。\n PLAZA EMPRESS    STEAMPUNKS\n  youtube-dl youtube-dl 是一个命令行程序，用于从 YouTube.com 和更多其他网站下载视频。 基于 Python 实现，不限于特定平台。\n# 安装 $ pip install -i https://pypi.tuna.tsinghua.edu.cn/simple youtube-dl # 使用 $ youtube-dl [OPTIONS] URL [URL...] 当前版本（2021.06.06）不能下载哔哩哔哩播放列表，可以用类似软件如 you-get， annie 代替。\nUsage 下载视频或整个视频播放列表\n 要从 Youtube 下载视频或整个视频播放列表，只需直接使用 URL 即可：youtube-dl [url]。程序自动选择一个最清晰的格式下载。 如果要指定视频下载之后的名称，可以使用如下方式：youtube-dl -o '名称' [url]。 还可以在下载视频时附加更多详细信息，可用的参数有标题、上传者名称（频道名称）和视频上传日期等：youtube-dl -o '%(title)s by %(uploader)s on %(upload_date)s in %(playlist)s.%(ext)s' [ul]。  查看视频的所有类型，只看不下载\n命令：youtube-dl -F [url]或者youtube-dl --list-formats [url]。 这是一个列清单参数，执行后并不会下载视频，但能知道这个目标视频都有哪些格式存在，以便有选择的下载。\n下载指定质量的视频和音频并自动合并\n下载最佳/最差质量的音/视频文件：\n默认情况下，youtube-dl将自主选择最佳质量的视频下载。 但是，也可以以特定的质量或格式来下载视频或播放列表\nYoutube-dl 支持以下品质：\n best选择最佳质量的音/视频文件 worst选择质量最差的格式（视频和音频） bestvideo选择最佳质量的仅视频格式（例如DASH视频），可能无法使用。 worstvideo选择质量最差的纯视频格式，可能无法使用。 bestaudio选择最优质的音频格式，可能无法使用。 worstaudio选择质量最差的音频格式，可能无法使用。  例如，如果要自动选择并下载最佳质量格式（音频和视频），只需使用以下命令：youtube-dl -f best [url]。\n您还可以组合使用以下不同的格式选项：youtube-dl -f bestvideo+bestaudio [ul]。该命令将分别下载最高质量的仅视频和最高质量的纯音频格式，再用ffmpeg或avconv合并成一个最佳质量的mkv文件；如果您不想合并，请将+（加号）替换为,（逗号）即可分别得到最高质量的音频和视频（两个文件）：youtube-dl -f 'bestvideo,bestaudio' [url]。\n 下载指定质量的音/视频文件：\n-F 获取的所有视频格式的清单，最左边一列就是编号对应着不同的格式。由于YouTube的1080p及以上的分辨率都是音视频分离的，所以我们需要分别下载视频和音频，可以使用137+140这样的组合。如果系统中安装了ffmpeg的话，youtube-dl 会自动合并下好的视频和音频，然后自动删除单独的音视频文件：youtube-dl -f [format code] [url]。\n从播放列表下载视频时，某些视频可能没有相同的格式。 在这种情况下，可以按首选顺序指定多个格式代码，例如：命令youtube-dl -f 22/17/18 将以格式 22 下载视频（如果可用）；如果格式 22不可用，则它将下载格式 17（如果可用）；如果格式 22 和 17 都不可用，最后尝试下载格式 18。如果所有格式代码都不匹配，Youtube-dl 会报出提示。还需要注意的是，斜杠是左关联的，即最左侧的格式代码是首选。\n下载字幕\n youtube-dl --write-sub [url]这样会下载一个vtt格式的英文字幕和mkv格式的1080p视频下来 youtube-dl --write-sub --skip-download [url]下载单独的vtt字幕文件,而不会下载视频 youtube-dl --write-sub --all-subs [url]下载所有语言的字幕(如果有的话) youtube-dl --write-auto-sub [url]下载自动生成的字幕(YouTube only)  下载多个视频\n youtube-dl  有时我们需要一次下载多个不同的视频，此时我们只需用空格将多个URL分隔开即可。 youtube-dl -a url.txt也可以将要下载视频的URL全部放在文本文件中，并将其作为参数传递给youtube-dl。此命令将下载url.txt文件中所有URL指向的视频。  只下载（视频中的）音频\n youtube-dl -x [url]仅从视频网站下载其音频。 youtube-dl -x --audio-format mp3 [ul]默认情况下，youtube-dl 将以Ogg （opus）格式保存音频。此命令将从给定的视频/播放列表下载音频，将其转换为 MP3 并将其保存在当前目录中。应注意：您应该安装 ffmpeg 或 avconv 将文件转换为 mp3 格式。  下载带有描述、元数据、注释、字幕和缩略图的视频\n要下载视频及其他详细信息，如：说明、元数据、注释、字幕和缩略图等，请使用以下命令： youtube-dl --write-description --write-info-json --write-annotations --write-sub --write-thumbnail [url]\n通过文件扩展名下载音/视频\n 以您的首选格式下载视频，例如 MP4，只需执行：youtube-dl --format mp4 [url]或者youtube-dl -f mp4 [url]。 某些视频可能无法以您的首选格式提供。 在这种情况下，youtube-dl 将下载其他最佳可用格式。例如： youtube-dl -f 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best' [ul] 此命令将下载最佳质量的MP4格式文件。如果 MP4 格式不可用，则它将下载其他最佳可用格式。  限制下载视频的大小\n从YouTube播放列表下载多个视频时，您可能只想下载特定大小的视频。例如：\n 此命令不会下载任何小于指定大小（例如100MB）的视频：youtube-dl --min-filesize 100M 。 如果您不想下载大于给定大小的视频，可以这样：youtube-dl --max-filesize 100M 。  我们还可以用组合格式，选择运算符来下载特定大小的视频。例如：\n 以下命令将下载最佳视频格式但不大于 100MB 的视频：youtube-dl -f 'best[filesize。  按日期下载视频\nYoutube-dl 允许我们按照上传日期来筛选和下载视频或播放列表，例如：\n 要下载 2019 年 8 月 1 日上传的视频，可以使用：youtube-dl --date 20190801 [URL]； 下载在特定日期或之前上传的视频：youtube-dl --datebefore 20190801 [URL]； 下载在特定日期或之后上传的视频：youtube-dl --dateafter 20190101 [URL]； 仅下载过去 6 个月内上传的视频：youtube-dl --dateafter now-6months [URL]； 下载特定时间段内（例如 2018 年 1 月 1 日至 2019 年 1 月 1 日）上传的视频：youtube-dl --dateafter 20180101 --datebefore 20190101 [URL]。  从播放列表下载特定的视频\n从播放列表下载特定的视频，是youtube-dl 的另一个非常有用的功能。例如：\n 要从播放列表下载第 10 个文件，可使用：youtube-dl --playlist-items 10 [playlist_url]； 要下载多个指定的文件，只需用逗号分隔：youtube-dl --playlist-items 2,3,7,10 [playlist_url]；  也可以按序号来指定要下载范围，例如：\n 从第 10 个开始，直接下载完整个列表：youtube-dl --playlist-start 10 [playlist_url]； 在播放列表中仅下载从第 2 到第 5 的文件：youtube-dl --playlist-start 2 --playlist-end 5 [playlist_url]。  Configuration 在 Linux 和 macOS 上，系统配置文件位于 /etc/youtube-dl.conf，用户配置文件位于 ~/.config/youtube-dl/config。\n# Continue on download errors, for example to skip unavailable videos in a playlist --ignore-errors # Time to wait before giving up, in seconds --socket-timeout 10 # Download only videos not listed in the archive file. Record the IDs of all downloaded videos in it. #--download-archive /path/archive.txt # Number of retries (default is 10), or \"infinite\". --retries infinite # Give these arguments to the external downloader --external-downloader aria2c --external-downloader-args \"--no-conf -c\" # Output filename template, see the \"OUTPUT TEMPLATE\" for all the info -o '~/Videos/%(id)s.%(ext)s' # Write thumbnail image to disk #--write-thumbnail # download best 30hz mp4 file , h264+aac ,use http or https protocol,because we can use aria2c downloader to have a faster speed --format '(bestvideo[ext=mp4][fps # Embed thumbnail in the audio as cover art #--embed-thumbnail # Write metadata to the video file --add-metadata curl 简介 curl 是常用的命令行工具，用来请求 Web 服务器。它的名字就是客户端（client）的 URL 工具的意思。\n它的功能非常强大，命令行参数多达几十种。如果熟练的话，完全可以取代 Postman 这一类的图形界面工具。\n本文介绍它的主要命令行参数，作为日常的参考，方便查阅。\n不带有任何参数时，curl 就是发出 GET 请求。\n$ curl https://www.example.com 上面命令向www.example.com发出 GET 请求，服务器返回的内容会在命令行输出。\n主要命令行参数 -A\n-A参数指定客户端的用户代理标头，即User-Agent。curl 的默认用户代理字符串是curl/[version]。\n$ curl -A 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36' https://google.com 上面命令将User-Agent改成 Chrome 浏览器。\n$ curl -A '' https://google.com 上面命令会移除User-Agent标头。\n也可以通过-H参数直接指定标头，更改User-Agent。\n$ curl -H 'User-Agent: php/1.0' https://google.com -b\n-b参数用来向服务器发送 Cookie。\n$ curl -b 'foo=bar' https://google.com 上面命令会生成一个标头Cookie: foo=bar，向服务器发送一个名为foo、值为bar的 Cookie。\n$ curl -b 'foo1=bar;foo2=bar2' https://google.com 上面命令发送两个 Cookie。\n$ curl -b cookies.txt https://www.google.com 上面命令读取本地文件cookies.txt，里面是服务器设置的 Cookie（参见-c参数），将其发送到服务器。\n-c\n-c参数将服务器设置的 Cookie 写入一个文件。\n$ curl -c cookies.txt https://www.google.com 上面命令将服务器的 HTTP 回应所设置 Cookie 写入文本文件cookies.txt。\n-d\n-d参数用于发送 POST 请求的数据体。\n$ curl -d 'login=emma＆password=123'-X POST https://google.com/login # 或者 $ curl -d 'login=emma' -d 'password=123' -X POST https://google.com/login 使用-d参数以后，HTTP 请求会自动加上标头Content-Type : application/x-www-form-urlencoded。并且会自动将请求转为 POST 方法，因此可以省略-X POST。\n-d参数可以读取本地文本文件的数据，向服务器发送。\n$ curl -d '@data.txt' https://google.com/login 上面命令读取data.txt文件的内容，作为数据体向服务器发送。\n–data-urlencode\n--data-urlencode参数等同于-d，发送 POST 请求的数据体，区别在于会自动将发送的数据进行 URL 编码。\n$ curl --data-urlencode 'comment=hello world' https://google.com/login 上面代码中，发送的数据hello world之间有一个空格，需要进行 URL 编码。\n-e\n-e参数用来设置 HTTP 的标头Referer，表示请求的来源。\ncurl -e 'https://google.com?q=example' https://www.example.com 上面命令将Referer标头设为https://google.com?q=example。\n-H参数可以通过直接添加标头Referer，达到同样效果。\ncurl -H 'Referer: https://google.com?q=example' https://www.example.com -F\n-F参数用来向服务器上传二进制文件。\n$ curl -F 'file=@photo.png' https://google.com/profile 上面命令会给 HTTP 请求加上标头Content-Type: multipart/form-data，然后将文件photo.png作为file字段上传。\n-F参数可以指定 MIME 类型。\n$ curl -F 'file=@photo.png;type=image/png' https://google.com/profile 上面命令指定 MIME 类型为image/png，否则 curl 会把 MIME 类型设为application/octet-stream。\n-F参数也可以指定文件名。\n$ curl -F 'file=@photo.png;filename=me.png' https://google.com/profile 上面命令中，原始文件名为photo.png，但是服务器接收到的文件名为me.png。\n-G\n-G参数用来构造 URL 的查询字符串。\n$ curl -G -d 'q=kitties' -d 'count=20' https://google.com/search 上面命令会发出一个 GET 请求，实际请求的 URL 为https://google.com/search?q=kitties\u0026count=20。如果省略--G，会发出一个 POST 请求。\n如果数据需要 URL 编码，可以结合--data--urlencode参数。\n$ curl -G --data-urlencode 'comment=hello world' https://www.example.com -H\n-H参数添加 HTTP 请求的标头。\n$ curl -H 'Accept-Language: en-US' https://google.com 上面命令添加 HTTP 标头Accept-Language: en-US。\n$ curl -H 'Accept-Language: en-US' -H 'Secret-Message: xyzzy' https://google.com 上面命令添加两个 HTTP 标头。\n$ curl -d '{\"login\": \"emma\", \"pass\": \"123\"}' -H 'Content-Type: application/json' https://google.com/login 上面命令添加 HTTP 请求的标头是Content-Type: application/json，然后用-d参数发送 JSON 数据。\n-i\n-i参数打印出服务器回应的 HTTP 标头。\n$ curl -i https://www.example.com 上面命令收到服务器回应后，先输出服务器回应的标头，然后空一行，再输出网页的源码。\n-I\n-I参数向服务器发出 HEAD 请求，然会将服务器返回的 HTTP 标头打印出来。\n$ curl -I https://www.example.com 上面命令输出服务器对 HEAD 请求的回应。\n--head参数等同于-I。\n$ curl --head https://www.example.com -k\n-k参数指定跳过 SSL 检测。\n$ curl -k https://www.example.com 上面命令不会检查服务器的 SSL 证书是否正确。\n-L\n-L参数会让 HTTP 请求跟随服务器的重定向。curl 默认不跟随重定向。\n$ curl -L -d 'tweet=hi' https://api.twitter.com/tweet –limit-rate4\n--limit-rate用来限制 HTTP 请求和回应的带宽，模拟慢网速的环境。\n$ curl --limit-rate 200k https://google.com 上面命令将带宽限制在每秒 200K 字节。\n-o\n-o参数将服务器的回应保存成文件，等同于wget命令。\n$ curl -o example.html https://www.example.com 上面命令将www.example.com保存成example.html。\n-O\n-O参数将服务器回应保存成文件，并将 URL 的最后部分当作文件名。\n$ curl -O https://www.example.com/foo/bar.html 上面命令将服务器回应保存成文件，文件名为bar.html。\n-s\n-s参数将不输出错误和进度信息。\n$ curl -s https://www.example.com 上面命令一旦发生错误，不会显示错误信息。不发生错误的话，会正常显示运行结果。\n如果想让 curl 不产生任何输出，可以使用下面的命令。\n$ curl -s -o /dev/null https://google.com -S\n-S参数指定只输出错误信息，通常与-s一起使用。\n$ curl -s -o /dev/null https://google.com 上面命令没有任何输出，除非发生错误。\n-u\n-u参数用来设置服务器认证的用户名和密码。\n$ curl -u 'bob:12345' https://google.com/login 上面命令设置用户名为bob，密码为12345，然后将其转为 HTTP 标头Authorization: Basic Ym9iOjEyMzQ1。\ncurl 能够识别 URL 里面的用户名和密码。\n$ curl https://bob:12345@google.com/login 上面命令能够识别 URL 里面的用户名和密码，将其转为上个例子里面的 HTTP 标头。\n$ curl -u 'bob' https://google.com/login 上面命令只设置了用户名，执行后，curl 会提示用户输入密码。\n-v\n-v参数输出通信的整个过程，用于调试。\n$ curl -v https://www.example.com --trace参数也可以用于调试，还会输出原始的二进制数据。\n$ curl --trace - https://www.example.com -x\n-x参数指定 HTTP 请求的代理。\n$ curl -x socks5://james:cats@myproxy.com:8080 https://www.example.com 上面命令指定 HTTP 请求通过myproxy.com:8080的 socks5 代理发出。\n如果没有指定代理协议，默认为 HTTP。\n$ curl -x james:cats@myproxy.com:8080 https://www.example.com 上面命令中，请求的代理使用 HTTP 协议。\n-X\n-X参数指定 HTTP 请求的方法。\n$ curl -X POST https://www.example.com 上面命令对https://www.example.com发出 POST 请求。\nHTTPie HTTPie（http）以一种更人性化的方式做同样的工作。你会看到彩色的、格式化的输出，这使得它更容易理解和调试。\naxel Lightweight CLI download accelerator\nUSENET 起源 简单地说，USENET是一个巨大无比的网上讨论组，一般也称为\"新闻组\"（newsgroups）。你可以将它想象成一个包罗万象、无所不有的网上论坛，但是它又不同于我们通常看到的普通论坛。这要从它的起源说起。\n上个世纪70年代末，当时还没有互联网和浏览器，它们都要在十多年后才会出现。那时所谓\"上网\"，就是用modem（调制解调器），拨一个电话号码，将自己的电脑连到另一台电脑（也称\"主机\"），收收邮件，看看上面系统管理员发的通告。如果想换一台主机看看，那就必须先挂断，再拨另外一个电话号码。\n这样的上网方式，很不利于开展多人的讨论。由于是拨号上网，只有地理位置相近的用户，才会登录同一台主机。很难想象，同一台机器的登录用户，既有东岸的纽约人，也有西岸的洛杉矶人。即使长途电话费不是问题，当时的主机也没有能力同时负担太多的远程终端。因此，迫切需要一种大规模的、分布式的、多中心的远程信息交换手段。\n1979年，Duke大学的两个研究生Tom Truscott和Jim Ellis，提出一种分布式的网上讨论组的构想。这种讨论组创建之初，主要是供UNIX爱好者协会（USENIX）的成员使用，因此就被定名为USENET。当然，后来全世界的用户都在使用它。\n运行机制 USENET的运行机制其实非常简单。对于用户来说，只有三步。\n1）网络服务提供商（ISP）在一个网络中，设定一台服务器作为USENET专用服务器，再将它的网址告诉用户。\n2）用户想要发言的时候，就向这个网址发送帖子（post），这与发送Email很相似，但是两者格式不一样，在USENET上发言必须使用专用的客户端。不过，现在大多数的Email客户端都带有新闻组功能，最常见的Outlook Express的设置可以参考网上的说明。\n3）查看其他人的发言时，就必须从服务器上下载其他人的帖子。下载完成后，如果想回复某人的帖子，就再重复第二步。\n可以看到，这个过程同邮件列表的运行几乎一模一样，不同之处在于，USENET服务器每天会同其他USENET服务器交换帖子。这就是说，全世界所有的USENET服务器最终都可以互相交换帖子，保持内容的同步。所以理论上，不管你的帖子是发到哪一台服务器上，最终全世界的人们都会看到，并且会从世界各地给你回复。\n因此，USENET就有一个其他交流机制所没有的优点，即这是一个真正的全世界参与的讨论组。\n内容结构 由于USENET中的讨论内容无所不包，所以必须根据主题分类。每一个主题就是一个\"频道\"，对这个主题感兴趣的用户就订阅这个频道。\nUSENET中的主题分类采用等级制（hierarchies），在形式上同域名很相似，即\"一级主题.二级主题.三级主题….\"，中间以小数点分隔。\n一级主题有9个。\n * comp.*: 与计算机相关的讨论。（computer-related discussions，比如comp.software, comp.sys.amiga）\n* misc.*: 各种不属于其他分类的主题。（Miscellaneous topics，比如misc.education, misc.forsale, misc.kids）\n* news.*: 对USENET本身的讨论（比如news.groups, news.admin）\n* rec.*: 休闲和娱乐（Recreation and entertainment，比如rec.music, rec.arts.movies）\n* sci.*: 与科学相关的讨论。（Science related discussions，比如sci.psychology, sci.research）\n* soc.*: 与社会相关的讨论。（Social discussions，比如soc.college.org, soc.culture.african）\n* talk.*: 各种争议性话题的讨论。（Talk about various controversial topics，比如talk.religion, talk.politics, talk.origins）\n* humanities.*: 艺术、文学、哲学方面的讨论。（Fine arts, literature, and philosophy，比如humanities.classics, humanities.design.misc）\n* alt.*: 自由讨论区。（alternative）\n 这9个一级主题中，除了alt.*以外，都不能自行设立讨论区。只有在alt主题区中，可以自己发起主题\"频道\"。\n二进制内容 USENET最初设计的时候，只打算用来传递文本信息，没有考虑传递二进制数据（也就是\"文件\"）。但是，随着互联网的发展，不传递二进制数据看上去是不可能的。\n于是，专门的编码方式被设计了出来，使得二进制文件可以转换成文本文件，在USENET上传递，用户下载以后再传换成原来的格式。这时，USENET就不仅是一个讨论组了，而成了传递文件的一种手段，图片、音频和视频都可以通过USENET传播。\n事实上，如今USENET上的流量，99%都已经是二进制文件了。它们大部分都在alt.binaries这个主题中传播。由于不受监管，所以各种各样的文件都有。\n收费服务 根据一项统计，2007年4月USENET上一天的流量为3.12TB，且还在快速增加中。这么大的流量，使得世界上提供USENET的服务商肯定不会很多。大家可以查看这个网页，上面有USENET提供商的不完全列表。\n这些服务商，又分为免费和收费两种。免费的USENET绝大多数都不提供二进制文件下载，查看alt.free.newsservers主题可以获得最新的免费USENET服务器的信息。\n在收费服务商中，名气比较大的是GIGANEWS，它提供多种收费账户供用户选择。其中白金用户每月费用为19.99美元，可以无限量下载，14天内不满意可以退款。如果你是一个狂热的下载爱好者，我强烈推荐去购买一个账户。\nGoogle Groups Google Groups也提供免费USENET服务。（当然，没有二进制文件下载。）我会另写文章专门介绍，这里就省略了。\nEditor VSCode 中国国内下载 VSCode 速度慢问题解决：使用 azure 中国 cdn 镜像地址加速下载 VSCode\n将默认下载地址\nhttps://az764295.vo.msecnd.net/stable/ 替换为 vscode.cdn.azure.cn\nhttps://vscode.cdn.azure.cn/stable/ 自动换行\n将word wrap的off改成on\n最适合程序员的笔记软件\nhttps://github.dev/[用户名]/[仓库名] 大小写转换快捷键\n File-Preference-Keybord Shortcuts 或直接按ctrl+k+ctrl+s 在上面的搜索栏中，输入 Transform 就可以看到有Transform to Uppercase和Trasnfrom to Lowercase的命令 设置快捷键  Google Keep Now I am using Google Keep.\nGoogle Keep键盘快捷键\n   hortcut Action     J/K Next/previous note   Shift + J/K Move note to next/previous position   N/P Next/previous list item   Shift + N/P Move list item to next/previous position   C New note   L New list   / Search   Ctrl + A Select all   E Archive   # Delete   F Pin/unpin   X Select   Ctrl + G Toggle list and grid view   Esc Close editor   Ctrl + Shift + 8 Toggle checkboxes   Ctrl + ] / [ Indent/dedent list item   ? Open shortcut list   @ Send feedback    Joplin+Typora+OneDrive Joplin $ wget -O - https://raw.githubusercontent.com/laurent22/joplin/dev/Joplin_install_and_update.sh | bash MarkText Foxit PDF Reader Industry’s most powerful PDF reader.\nPortable PDF Unlocker PDFCrack pdftk OCRmyPDF OCRmyPDF adds an OCR text layer to scanned PDF files, allowing them to be searched\nWPS WPS Office is a lightweight, feature-rich comprehensive office suite with high compatibility.\n最好用 snap 或者 flatpak 版本，因为很久没更新了，只有 WPS 2019，没有适配新的 KDE 5 和 Gnome 40。\nSublime Text Atom Vim vi 与 vim.tiny $ whereis vi vi: /usr/bin/vi /usr/share/man/man1/vi.1.gz $ ls -al /usr/bin/vi lrwxrwxrwx 1 root root 20 Oct 26 20:31 /usr/bin/vi - /etc/alternatives/vi $ ls -al /etc/alternatives/vi lrwxrwxrwx 1 root root 17 Oct 26 20:31 /etc/alternatives/vi - /usr/bin/vim.tiny 可见，在Ubuntu上，vi是vim.tiny的软连接，但是执行命令vi与vim.tiny后是不一样，比如vi是：在编辑模式下使用方向键的时候，并不会使光标移动，而是在命令行中出现[A [B [C [D之类的字母；并且编辑错误的话，退格键(Backspace键)是使用不了的。\nMethods to find out which (configuration) files are read by executable when started-‘strace vim/nano’ (Ubuntu)：\n$ strace -o $HOME/tracefile vi $ cat tracefile | grep vimrc stat(\"/usr/share/vim/vimrc.tiny\", {st_mode=S_IFREG|0644, st_size=662, ...}) = 0 openat(AT_FDCWD, \"/usr/share/vim/vimrc.tiny\", O_RDONLY) = 3 stat(\"/home/vane/.vimrc\", 0x7fff3e755550) = -1 ENOENT (No such file or directory) openat(AT_FDCWD, \"/home/vane/.vimrc\", O_RDONLY) = -1 ENOENT (No such file or directory) openat(AT_FDCWD, \"/home/vane/_vimrc\", O_RDONLY) = -1 ENOENT (No such file or directory) stat(\"/home/vane/.vim/vimrc\", 0x7fff3e755550) = -1 ENOENT (No such file or directory) openat(AT_FDCWD, \"/home/vane/.vim/vimrc\", O_RDONLY) = -1 ENOENT (No such file or directory) 可以看到 vi，加载的是 /usr/share/vim/vimrc.tiny\n$ strace -o $HOME/tracefile vim.tiny $ cat tracefile | grep vimrc stat(\"/usr/share/vim/vimrc\", {st_mode=S_IFREG|0644, st_size=2266, ...}) = 0 openat(AT_FDCWD, \"/usr/share/vim/vimrc\", O_RDONLY) = 3 stat(\"/home/vane/.vimrc\", 0x7fff7c99cc30) = -1 ENOENT (No such file or directory) openat(AT_FDCWD, \"/home/vane/.vimrc\", O_RDONLY) = -1 ENOENT (No such file or directory) openat(AT_FDCWD, \"/home/vane/_vimrc\", O_RDONLY) = -1 ENOENT (No such file or directory) stat(\"/home/vane/.vim/vimrc\", 0x7fff7c99cc30) = -1 ENOENT (No such file or directory) openat(AT_FDCWD, \"/home/vane/.vim/vimrc\", O_RDONLY) = -1 ENOENT (No such file or directory) 可以看到 vim.tiny，加载的是 /usr/share/vim/vimrc\n$ diff -u /etc/vim/vimrc /etc/vim/vimrc.tiny --- /etc/vim/vimrc\t2020-01-30 19:11:47.000000000 +0800 +++ /etc/vim/vimrc.tiny\t2020-04-15 14:40:31.000000000 +0800 @@ -1,55 +1,13 @@ ... +\" Vim configuration file, in effect when invoked as \"vi\". The aim of this +\" configuration file is to provide a Vim environment as compatible with the +\" original vi as possible. Note that ~/.vimrc configuration files as other +\" configuration files in the runtimepath are still sourced. +\" When Vim is invoked differently (\"vim\", \"view\", \"evim\", ...) this file is +\" _not_ sourced; /etc/vim/vimrc and/or /etc/vim/gvimrc are. ... 可以看到，上面什么说明白了。\nVim clear last search highlighting :noh VIMRC The ultimate Vim configuration (vimrc)\ncopilot.vim Neovim plugin for GitHub Copilot\nNeovim Neovim 提出了将 Vim 扩展为一个 IDE 的想法。\n它增加了现代终端的功能，如光标样式、焦点事件、括号内粘贴等，并内置了一个终端模拟器。最重要的是，你不需要忘却 Vim 的习惯就可以开始使用 Neovim。\n最适合程序员的笔记软件 程序员的笔记软件，应该满足下面几个条件。\n 跨平台，同时支持桌面电脑（Windows，Mac，Linux）和手机（Android，iOS）。 随时同步，打开任何一台机器，都能接着上一次的工作继续写。 实时存储，如果软件突然关闭，也不会丢失内容。 支持 Markdown 格式，便于后期直接发布。 支持推送到远程 Git 仓库，产生历史版本，同时作为远程备份。  Stackedit.io 和 HackMD.io，都不是很理想。\nGitHub 官方推出的 github.dev。只要访问 https://github.dev/[用户名]/[仓库名]，你就能在浏览器里面，使用 VS Code 编辑指定仓库。它实际上就是 VS Code 编辑器的 Web 版，并且与 Git 高度集成。GitHub 提供了一个快捷入口。 打开 GitHub 仓库主页，按一下小数点（.）这个键， 页面就会自动跳转到 VS Code 编辑环境。\n如果你更希望使用手机原生 App，我推荐 Obsidian。它有全平台的客户端，并且可以参考这篇文章设置 Git 集成。\n评论里还有很多推荐，选择一个合适的就行。\nShell Tmux Tmux 是一个终端复用器（terminal multiplexer），非常有用，属于常用的开发工具。\n简介 会话与进程\n命令行的典型使用方式是，打开一个终端窗口（terminal window，以下简称\"窗口\"），在里面输入命令。用户与计算机的这种临时的交互，称为一次\"会话\"（session） 。\n会话的一个重要特点是，窗口与其中启动的进程是连在一起的。打开窗口，会话开始；关闭窗口，会话结束，会话内部的进程也会随之终止，不管有没有运行完。\n一个典型的例子就是，SSH 登录远程计算机，打开一个远程窗口执行命令。这时，网络突然断线，再次登录的时候，是找不回上一次执行的命令的。因为上一次 SSH 会话已经终止了，里面的进程也随之消失了。\n为了解决这个问题，会话与窗口可以\"解绑\"：窗口关闭时，会话并不终止，而是继续运行，等到以后需要的时候，再让会话\"绑定\"其他窗口。\nTmux 的作用\nTmux 就是会话与窗口的\"解绑\"工具，将它们彻底分离。\n 它允许在单个窗口中，同时访问多个会话。这对于同时运行多个命令行程序很有用。 它可以让新窗口\"接入\"已经存在的会话。 它允许每个会话有多个连接窗口，因此可以多人实时共享会话。 它还支持窗口任意的垂直和水平拆分。  类似的终端复用器还有 GNU Screen。Tmux 与它功能相似，但是更易用，也更强大。\n基本用法 安装\nTmux 一般需要自己安装。\n$ sudo apt-get install tmux 启动与退出\n安装完成后，键入tmux命令，就进入了 Tmux 窗口。\n$ tmux Tmux 窗口，底部有一个状态栏。状态栏的左侧是窗口信息（编号和名称），右侧是系统信息。\n按下Ctrl+d或者显式输入exit命令，就可以退出 Tmux 窗口。\n$ exit 前缀键\nTmux 窗口有大量的快捷键。所有快捷键都要通过前缀键唤起。默认的前缀键是Ctrl+b，即先按下Ctrl+b，快捷键才会生效。\n举例来说，帮助命令的快捷键是Ctrl+b ?。它的用法是，在 Tmux 窗口中，先按下Ctrl+b，再按下?，就会显示帮助信息。\n然后，按下 ESC 键或q键，就可以退出帮助。\n会话管理 新建会话\n第一个启动的 Tmux 窗口，编号是0，第二个窗口的编号是1，以此类推。这些窗口对应的会话，就是 0 号会话、1 号会话。\n使用编号区分会话，不太直观，更好的方法是为会话起名。\n$ tmux new -s  上面命令新建一个指定名称的会话。\n分离会话\n在 Tmux 窗口中，按下Ctrl+b d或者输入tmux detach命令，就会将当前会话与窗口分离。\n$ tmux detach 上面命令执行后，就会退出当前 Tmux 窗口，但是会话和里面的进程仍然在后台运行。\ntmux ls命令或Ctrl+b s可以查看当前所有的 Tmux 会话。\n$ tmux ls # or $ tmux list-session 接入会话\ntmux attach命令用于重新接入某个已存在的会话。\n# 使用会话编号 $ tmux attach -t 0 # 使用会话名称 $ tmux attach -t  杀死会话\ntmux kill-session命令用于杀死某个会话。\n# 使用会话编号 $ tmux kill-session -t 0 # 使用会话名称 $ tmux kill-session -t  切换会话\ntmux switch命令用于切换会话。\n# 使用会话编号 $ tmux switch -t 0 # 使用会话名称 $ tmux switch -t  重命名会话\ntmux rename-session命令或Ctrl+b $用于重命名会话。\n$ tmux rename-session -t 0  上面命令将0号会话重命名。\n最简操作流程 综上所述，以下是 Tmux 的最简操作流程。\n 在服务器端新建会话tmux new -s my_session。 在 Tmux 窗口运行所需的程序。 按下快捷键Ctrl+b d将会话分离。 下次使用时，重新连接到会话tmux attach-session -t my_session。  窗格操作 Tmux 可以将窗口分成多个窗格（pane），每个窗格运行不同的命令。以下命令都是在 Tmux 窗口中执行。\n划分窗格\ntmux split-window命令用来划分窗格。\n# 划分上下两个窗格，或 Ctrl+b \" $ tmux split-window # 划分左右两个窗格，或 Ctrl+b % $ tmux split-window -h 移动光标\ntmux select-pane命令或Ctrl+b 用来移动光标位置。\n# 光标切换到上方窗格，或 Ctrl+b ; $ tmux select-pane -U # 光标切换到下方窗格，或 Ctrl+b o $ tmux select-pane -D # 光标切换到左边窗格 $ tmux select-pane -L # 光标切换到右边窗格 $ tmux select-pane -R  Ctrl+b x：关闭当前窗格。 Ctrl+b !：将当前窗格拆分为一个独立窗口。 Ctrl+b z：当前窗格全屏显示，再使用一次会变回原来大小。 Ctrl+b Ctrl+：按箭头方向调整窗格大小。 Ctrl+b q：显示窗格编号。  交换窗格位置\ntmux swap-pane命令用来交换窗格位置。\n# 当前窗格上移，或 Ctrl+b { $ tmux swap-pane -U # 当前窗格下移，或 Ctrl+b } $ tmux swap-pane -D  Ctrl+b Ctrl+o：所有窗格向前移动一个位置，第一个窗格变成最后一个窗格。 Ctrl+b Alt+o：所有窗格向后移动一个位置，最后一个窗格变成第一个窗格。  窗口管理 除了将一个窗口划分成多个窗格，Tmux 也允许新建多个窗口。\n新建窗口\ntmux new-window命令用来创建新窗口。\n$ tmux new-window # 新建一个指定名称的窗口 $ tmux new-window -n  Ctrl+b c：创建一个新窗口，状态栏会显示多个窗口的信息。\n切换窗口\ntmux select-window命令用来切换窗口。\n# 切换到指定编号的窗口 $ tmux select-window -t  # 切换到指定名称的窗口 $ tmux select-window -t   Ctrl+b p：切换到上一个窗口（按照状态栏上的顺序）。 Ctrl+b n：切换到下一个窗口。 Ctrl+b ：切换到指定编号的窗口，其中的是状态栏上的窗口编号。 Ctrl+b w：从列表中选择窗口。  重命名窗口\ntmux rename-window命令或Ctrl+b ,用于为当前窗口起名（或重命名）。\n$ tmux rename-window  其他命令 下面是一些其他命令。\n# 列出所有快捷键，及其对应的 Tmux 命令 $ tmux list-keys # 列出所有 Tmux 命令及其参数 $ tmux list-commands # 列出当前所有 Tmux 会话的信息 $ tmux info # 重新加载当前的 Tmux 配置 $ tmux source-file ~/.tmux.conf Fish 命令行是程序员的必备技能。图形界面虽然好看，解决问题还是要靠命令行。\n命令行由 Shell 提供。各种命令通过 Shell，传递给操作系统的内核。学习命令行就是在学习 Shell。\nShell 有好几种，目前最常用是 Bash 和 zsh。但是，在我看来，它们都不如 Fish Shell 好用。\n五年前，我第一次尝试 Fish，感到很惊艳，一直用到现在。本文介绍 Fish 的主要特点，希望你也来尝试它。\n简介 Fish 是\"the friendly interactive shell\"的简称，最大特点就是方便易用。很多其他 Shell 需要配置才有的功能，Fish 默认提供，不需要任何配置。\n如果你想拥有一个方便好用的 Shell，又不想学习一大堆语法，或者花费很多时间配置，那么你一定要尝试一下 Fish。\n安装 Ubuntu 的安装方法。\n$ sudo apt install fish 其他系统的安装请参考官方网站。\n启动与帮助 安装完成后，就可以启动 Fish。\n$ fish 由于 Fish 的语法与 Bash 有很大差异，Bash 脚本一般不兼容。因此，我建议不要将 Fish 设为默认 Shell，而是每次手动启动它。\n使用过程中，如果需要帮助，可以输入help命令。浏览器就会自动打开，显示在线文档。\n$ help 彩色显示 进入 Fish 以后，你注意到的第一件事，可能就是它默认彩色显示。\n# 无效命令为红色 $ mkd # 有效命令为蓝色 $ mkdir 有效路径会有下划线。\n$ cat ~/somefi 上面代码表示，存在以~/somefi开头的路径。如果没有下划线，你就知道这个路径不存在。\n自动建议 Fish 会自动在光标后面给出建议，表示可能的选项，颜色为灰色。\n# 命令建议 $ /bin/hostname # 参数建议 $ grep --ignore-case # 路径建议 $ ls node_modules 如果采纳建议，可以按下→或Control + F。如果只采纳一部分，可以按下Alt + →。\n自动补全 输入命令时，Fish 会自动显示匹配的上一条历史记录。\n$ git commit -m \"feat: first commit\" 如果没有匹配的历史记录，Fish 会猜测可能的结果，自动补全各种输入。比如，输入pyt再按下Tab，就会自动补全为python命令。\n如果有多个可能的结果，Fish 会把它们都列出，还带有简要介绍。\n$ vi[按下 Tab 键] vi (Executable link, 2.7MB) view (Vi IMproved, 一个程序员的文本编辑器) viewer.py (Executable, 967B) viewres (Graphical class browser for Xt) ...and 12 more rows 这时，再按一次tab，就可以在这些命令之中选择。\n除了补全命令，Fish 还可以补全参数。比如，ls命令的-l参数后面按下Tab键，就会显示可以连用的其他参数。\n$ ls -l[按下 Tab 键] -l1 (List one file per line) -lA (Show hidden except . and ..) -la (Show hidden) -lB (Ignore files ending with ~) ...and 16 more rows``` Fish 还可以自动补全 Git 分支。\n$ git checkout master 易懂的语法 Fish 的语法非常自然，一眼就能看懂。\nif语句：\nif grep fish /etc/shells echo Found fish else if grep bash /etc/shells echo Found bash else echo Got nothing end switch语句：\nswitch (uname) case Linux echo Hi Tux! case Darwin echo Hi Hexley! case FreeBSD NetBSD DragonFly echo Hi Beastie! case '*' echo Hi, stranger! end while循环：\nwhile true echo \"Loop forever\" end for循环：\nfor file in *.txt cp $file $file.bak end 函数 Fish 的函数用来封装命令，或者为现有的命令起别名。\nfunction ll ls -lhG $argv end 上面代码定义了一个ll函数。命令行执行这个函数以后，就可以用ll命令替代ls -lhG。其中，变量$argv表示函数的参数。\n下面是另一个例子。\nfunction ls command ls -hG $argv end 上面的代码重新定义ls命令。注意，函数体内的ls之前，要加上command，否则会因为无限循环而报错。\n提示符 fish_prompt函数用于定义命令行提示符（prompt）。\nfunction fish_prompt set_color purple date \"+%m/%d/%y\" set_color FF0 echo (pwd) '' set_color normal end 执行上面的函数以后，你的命令行提示符就会变成下面这样。\n02/06/13 /home/tutorial  配置 Fish 的配置文件是~/.config/fish/config.fish，每次 Fish 启动，就会自动加载这个文件。\n我们可以在这个文件里面写入各种自定义函数，它们会被自动加载。比如，上面的fish_prompt函数就可以写在这个文件里面，这样每次启动 Fish，就会出现自定义的提示符。\nFish 还提供 Web 界面配置该文件。\n$ fish_config 输入上面的命令以后，浏览器就会自动打开本机的 8000 端口，用户可以在网页上对 Fish 进行配置，比如选择提示符和配色主题。\nZsh Oh My Zsh $ sh -c \"$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)\" oh-my-zsh应该对通配符作了限制，需要用跳脱字符\nsudo apt remove fcitx\\* Zsh theme：What’s the best theme for Oh My Zsh?\nProxy v2ray 节点准备 简单来讲节点是形如如下的神秘链接：\nss://xxxxxxxxxxxxxxxxxxxxxxxxxxxx vmess://xxxxxxxxxxxxxxxxxxxxxxxxxxxx 如果你没有这些连接：\n 自行部署，你则需要自行购买处于自由互联网的服务器并进行节点搭建，这不在本文讨论范围内。如果你需要购买服务器，推荐一个 VPS 提供商：justhost.ru。 购买机场的订阅服务，可以参考它们的订阅流程以获取节点。需要提醒的是，机场服务属于灰色产业，随时有停止服务的可能，购买建议以月付进行购买以避免过大损失。关于机场审计规则，我们的观点是\"我可以不看，但是你不可以封禁\"。对于机场审计程度，读者可根据自身实际情况自行评估。 如果你不想花任何费用，可安装赛风这类软件。它是自由软件。如果你使用赛风，可以非常方便的发送空邮件到get@psiphon3.com以获取赛风下载链接。赛风应用目前只支持 Windows\\Android\\IOS\\MacOS 平台。当你在这些平台上能够访问自由互联网时，可以去各个渠道搜索可用的节点和代理资源。注意，使用公共节点需要自行承担可能的风险。  安装 v2ray/Xray-core 是使用 Qv2ray（原项目已停止开发） 以及 V2rayA 的前提，需要先进行安装。\nQv2ray 和 V2rayA 是两款非常优秀的在 Linux 上可用的科学上网通用客户端：\n Qv2ray：安装后在 Plugins 中，选择 V2ray Core Plugin，并进行 V2ray 的设置。现在你已经可以使用，你需要按照官方文档导入已有的链接或订阅。 V2rayA：2rayA 是一个浏览器客户端，使用非常方便。更多使用方法请看官方文档  代理配置 在经过上述步骤后，你应该已经有了 SOCKS5 代理以及 HTTP 代理的地址和端口。接下来进行设置：\n  系统代理：在节点链接后，你可在系统设置 - 网络设置 - 代理中设置代理。注意，系统设置中的代理配置在 KDE 桌面环境中并不是所有应用都会遵守。没有遵循系统设置代理的应用还需要单独进行代理配置。\n  终端\n可以通过 export 命令设置当前终端的代理方式。比如使用 tldr 或 github raw 等资源需要设置 https 代理。\nexport https_proxy=http://127.0.0.1:8889 export http_proxy=http://127.0.0.1:8889 export all_proxy=http://127.0.0.1:8889 不同终端命令所识别的环境变量名不同，如 all_proxy 对 curl 生效，而对 wget 则不生效，具体可查看各个命令的 man page。\n  proxychains/proxychains-ng\n如果对于一个应用，KDE 的系统代理不生效，在终端 export 了 ALL_PROXY 变量再用终端启动此应用代理也不生效，并且这个应用自身也没有配置代理的选项（即应用不支持代理）。此时可以使用 proxychains，它可以为单行命令配置代理，它是一个预加载的 hook，允许通过一个或多个 SOCKS 或 HTTP 代理重定向现有动态链接程序的 TCP 流量（即强制应用走代理）。\n$ sudo apt install proxychains $ sudo vim /etc/proxychains.conf socks5 127.0.0.1 1089   透明代理 全局代理，也即透明代理。之所以叫做透明代理，是因为这代理对于操作系统中的各个应用相当于是透明的，应用们感知不到代理的存在。之所以叫做全局代理，很明显意为全局所有流量都走代理。\n  在 Qv2ray 的“首选项-入站设置”的下方启用任意门设置选项。\n 监听 ipv4 地址可填127.0.0.1 或 0.0.0.0，建议前者。若需双栈代理，则在监听 ipv6 地址填上::1（如果监听 ipv4 填了 0.0.0.0 则可不填）。 嗅探选择 Full，Destination Override 的三项均勾选。 模式选择“tproxy”。    安装cgproxy软件，编辑/etc/cgproxy/config.json：\n 在cgroup_proxy中括号里加上\"/\"，port改为 Qv2ray 首选项里的透明代理的端口。 cgproxy默认配置是代理所有 tcp 和 udp，ipv4 和 ipv6 的流量，如果不希望代理其中的某种（些）流量，则将对应的enable_xxx改为 false。注意这里的配置要和 Qv2ray 选项里的配置一致，如 Qv2ray 选项里没有勾选 udp，则这里务必把enable_udp改为 false。 如果希望当本机作为网关设备时为连接到本机的其他设备（如连接到本机开设的 wifi 热点的设备）也提供透明代理，则把enable_gateway改为 true    透明代理的基本原理是拦截系统发出的所有流量，并将这些流量转到代理工具里，从而实现让系统所有流量都走代理的目的。此时，为了避免流量出现死循环（即代理工具发出的流量又转回到代理工具里），需要将代理工具排除在透明代理环境外面。有两种方式可以实现这一点：\n  通过execsnoop监控代理工具的启动，并自动将其移至透明代理环境外面：\n cgproxy软件自带execsnoop支持，以上cgproxy测试过的发行版均可支持。 编辑/etc/cgproxy/config.json，在program_noproxy中括号里加上\"v2ray\"、\"qv2ray\"，以使qv2ray和v2ray发出的流量不经过透明代理。如果你的v2ray或qv2ray不在PATH里，则需要填写它们的绝对路径。    在每次连接代理节点时，让qv2ray自己把自己移到透明代理环境外面：\n安装 Qvplugin-Command 插件，在插件设置里的“pre-connection”栏里加上一句\nsh -c \"cgnoproxy --pid $(pgrep -x qv2ray)\"     如果启用了 udp 的透明代理（dns 也是 udp），则给 v2ray 二进制文件加上相应的特权：\nsudo setcap \"cap_net_admin,cap_net_bind_service=ep\" /usr/bin/v2ray 否则 udp 的透明代理可能会出问题。如果每次更新了 v2ray 二进制文件，都需要重新执行此命令。\n  启动透明代理服务：systemctl start cgproxy.service或systemctl enable --now cgproxy.service。\n  以上步骤完成后，透明代理应该能正常使用了。\ndns 如果勾选了“dns 拦截”，且启用了 dns 和 udp 的透明代理，则 v2ray 会拦截对系统 dns 的请求，并将其转发到 v2ray 的内置 dns 里，即让 v2ray 内置 dns 接管系统 dns。但 v2ray 内置 dns 是会遵循路由规则的。\n如果没勾选“dns 拦截”，则 v2ray 虽然不会让内置 dns 接管系统 dns，但如果启用了 dns 和 udp 的透明代理，则系统 dns 也会走透明代理进 v2ray，并遵循 v2ray 的路由规则。\n因此，在启用了 dns 和 udp 的透明代理时，若系统 dns 或 v2ray 的内置 dns 配置不当，可能导致 dns 请求发不出去，从而影响正常上网。\n由于 qv2ray 常见的路由规则是绕过国内 ip，国外 ip 均走代理。在这个情形中，以下两个配置是典型的有问题的 dns 配置方式：\n 配置了国外普通 dns 作为首选，但代理本身不支持 udp（此时 dns 查询的 udp 流量出不去，dns 无法查询） 配置了使用域名的 doh 作为首选。此时 doh 的域名无法被解析，从而 doh 也无法使用。  一般而言，如果并不在意将 dns 查询发给谁，那么，在绕过国内 ip 的情况下，只需要配置一个国内普通 dns 作为首选即可保证不会出问题。若代理本身不支持 udp，又希望使用国外 dns，则可以考虑使用使用 ip 的 doh（如https://1.1.1.1/dns-query等）。\n如果需要更复杂的 dns 配置，建议参考上游文档，并选择合适的不会影响正常上网的 dns 配置。\nClash 下载 clash\n$ gzip -d clash-v1.6.5.gz $ mkdir ~/.clash \u0026\u0026 mv clash-v1.6.5 ~/.clash/clash 下载配置\n$ wget -O config.yaml [订阅链接] 运行 clash\n$ chmod 770 clash./clash -d . 使用 clash dashboard 选择节点\n设置系统代理：\n  GUI：打开系统设置，点击网络代理右边的 ⚙ 按钮，选择手动\n HTTP 和 HTTPS 代理为 127.0.0.1:7890 Socks 主机为 127.0.0.1:7891    CLI：change system proxy settings from the command line\n# To modify a DConf setting: $ gsettings set    # To read a DConf setting: $ gsettings get     相关软件：\n glider Lantern Privoxy openvpn Shadowsocks Tor trojan：trojan教程  脚本一 $ vi ~/.clash/run-clash.sh #!/bin/bash CLASH_HOME=/home/vane/.clash subscription=\"订阅连接\" # 设置系统代理 function setting { gsettings set org.gnome.system.proxy.http host '127.0.0.1' gsettings set org.gnome.system.proxy.http port '7890' gsettings set org.gnome.system.proxy.https host '127.0.0.1' gsettings set org.gnome.system.proxy.https port '7890' gsettings set org.gnome.system.proxy.socks host '127.0.0.1' gsettings set org.gnome.system.proxy.socks port '7891' } # 更新订阅 function update { wget -O $CLASH_HOME/config.yaml $subscription } # 运行 clash function run { # 打开系统代理（之前已经设置了） gsettings set org.gnome.system.proxy mode 'manual' $CLASH_HOME/clash -d $CLASH_HOME/ } # 停止运行 clash function stop { # 关闭系统代理  gsettings set org.gnome.system.proxy mode 'none' } if [ \"$1\" = \"-u\" ]; then update elif [ \"$1\" = \"-r\" ]; then run elif [ \"$1\" = \"-s\" ]; then setting else if [ \"$1\" ]; then $CLASH_HOME/clash $1 else echo Plese run clash -r fi fi trap stop EXIT How to change system proxy settings from the command line on Ubuntu desktop\n$ chmod 700 run-clash.sh 脚本二 $ vi ~/.clash/rc.sh #!/bin/bash /usr/bin/wget -O home/kurome/.clash/config.yaml \"订阅连接\" /home/kurome/.clash/clash -d /home/kurome/.clash/ clash as a daemon：\n$ sudo vi /usr/lib/systemd/system/clash.service [Unit] Description=Clash daemon, A rule-based proxy in Go. After=network.target [Service] Type=simple Restart=always RestartSec=10 ExecStart=/bin/bash /home/kurome/.clash/rc.sh [Install] WantedBy=multi-user.target 运行\n$ systemctl enable clash.service $ systemctl start clash.service $ systemctl status clash.service 如果不想代理了，可以直接在 clash dashboard 的 Proxy （如果有的话）或者 Settting 里选择 DIRECT，而不是关闭 clash.service。根据设置的规则，有的流量会走代理，有的流量直接走。\nTUN 模式 “系统代理”一般只是桌面环境下的约定，需要 app 遵循约定才行。也就是说 HTTP_PROXY 这种环境变量只是约定俗成的，大家都从这里面读取代理地址，但是程序里必须要有读取这个变量的相关代码才行。\n因此某些软件\u0026命令行软件不支持系统代理。\nClash for Windows tun 模式对全部 app 生效——对于不遵循系统代理的软件，TUN 模式可以接管其流量并交由 CFW 处理。启动 TUN 模式需要进行如下操作：\n  安装 nftables 和 iproute2 并重启\n$ sudo apt install nftables iproute2 $ sudo reboot   点击General中Service Mode右边Manage，在打开窗口中安装服务模式，安装完成应用会自动重启（某些系统需要手动重启 APP），Service Mode 右边地球图标变为绿色即安装成功\n  点击General中TUN Mode右边开关启动 TUN 模式\n  无法安装参考：\n$ curl https://gist.githubusercontent.com/Fndroid/2119fcb5ccb5a543a8f6a609418ae43f/raw/592eba4f480c7ccb4f29c9b8e80d24bfd5dda8cf/linux.sh  cfw-tun.sh \u0026\u0026 chmod +x cfw-tun.sh \u0026\u0026 sudo ./cfw-tun.sh install  如要卸载则将 install 改为 uninstall，最后一部分位 CFW 安装目录\n  Setup System stack in Fake-IP mode Edit config\ndns: enable: true listen: 0.0.0.0:1053 fake-ip-range: 198.18.0.1/16 enhanced-mode: fake-ip nameserver: - 114.114.114.114 tun: enable: true stack: system dns-hijack: - tcp://8.8.8.8:53 interface-name: en0 Run Clash\nsudo ./clash Set Route\n# Based on https://github.com/Kr328/kr328-clash-setup-scripts/blob/master/setup-clash-tun.sh ipset create localnetwork hash:net ipset add localnetwork 127.0.0.0/8 ipset add localnetwork 10.0.0.0/8 ipset add localnetwork 169.254.0.0/16 ipset add localnetwork 192.168.0.0/16 ipset add localnetwork 224.0.0.0/4 ipset add localnetwork 240.0.0.0/4 ipset add localnetwork 172.16.0.0/12 ip tuntap add user root mode tun utun0 ip link set utun0 up ip route replace default dev utun0 table 0x162 ip rule add fwmark 0x162 lookup 0x162 iptables -t mangle -N CLASH iptables -t mangle -F CLASH iptables -t mangle -A CLASH -p tcp --dport 53 -j MARK --set-mark 0x162 iptables -t mangle -A CLASH -p udp --dport 53 -j MARK --set-mark 0x162 iptables -t mangle -A CLASH -m addrtype --dst-type BROADCAST -j RETURN iptables -t mangle -A CLASH -m set --match-set localnetwork dst -j RETURN iptables -t mangle -A CLASH -d 198.18.0.0/16 -j MARK --set-mark 0x162 iptables -t mangle -A CLASH -j MARK --set-mark 0x162 iptables -t mangle -I OUTPUT -j CLASH iptables -t mangle -I PREROUTING -m set ! --match-set localnetwork dst -j MARK --set-mark 0x162 sysctl -w net/ipv4/ip_forward=1 sysctl -w net.ipv4.conf.utun0.rp_filter=0 Set Gateway and DNS server in other devices\nSet the gateway and DNS server, then enjoy the clash\nTProxy Mode Transparent proxies act as intermediaries between a user and a web service. When a user connects to a service, the transparent proxy intercepts the request before passing it on to the provider. Transparent proxies are considered transparent because the user isn’t aware of them. On the other hand, the servers hosting the service recognize that the proxied traffic is coming from a proxy and not directly from the user.\nAnd Tproxy is first choice of realize transparent proxy with NAT on Linux. In the past, Clash TProxy mode only support TCP traffic. After version 0.19, Clash TProxy mode also support UDP traffic, it will solve a NAT problem.\nWhat’s different between TProxy mode and TUN mode?\nThere’s no big difference in user-side.\nIn developer side, Tproxy is a proxy, although it is not perceived by the application. And TUN is a gatway, application knows there is a gateway, and traffic must pass through it.\nCheck your config\nMake sure you config have no tun field.\ndns: enable: true listen: 0.0.0.0:1053 enhanced-mode: redir-host # or fake-ip nameserver: - 114.114.114.114 Add Rules in iptable\niptables -t nat -N clash iptables -t nat -A clash -d 0.0.0.0/8 -j RETURN iptables -t nat -A clash -d 10.0.0.0/8 -j RETURN iptables -t nat -A clash -d 127.0.0.0/8 -j RETURN iptables -t nat -A clash -d 169.254.0.0/16 -j RETURN iptables -t nat -A clash -d 172.16.0.0/12 -j RETURN iptables -t nat -A clash -d 192.168.0.0/16 -j RETURN iptables -t nat -A clash -d 224.0.0.0/4 -j RETURN iptables -t nat -A clash -d 240.0.0.0/4 -j RETURN iptables -t nat -A clash -d \"$local_ipv4\" -j RETURN iptables -t nat -A clash -p tcp -j REDIRECT --to-port \"$proxy_port\" iptables -t nat -I PREROUTING -p tcp -d 8.8.8.8 -j REDIRECT --to-port \"$proxy_port\" iptables -t nat -I PREROUTING -p tcp -d 8.8.4.4 -j REDIRECT --to-port \"$proxy_port\" iptables -t nat -A PREROUTING -p tcp -j clash iptables -t nat -A OUTPUT -p tcp -d 198.18.0.0/16 -j REDIRECT --to-port \"$proxy_port\" # use it just for fake-ip iptables -t nat -N CLASH_DNS iptables -t nat -F CLASH_DNS iptables -t nat -A CLASH_DNS -p udp -j REDIRECT --to-port 1053 iptables -t nat -I OUTPUT -p udp --dport 53 -j CLASH_DNS iptables -t nat -I PREROUTING -p udp --dport 53 -j REDIRECT --to 1053 配置文件 Clash 是基于 Go 语言写的科学上网工具，目前支持 windows, mac, android, openwrt, linux 平台，支持 ss, trojan, vmess, snell 协议，支持分流规则。\nclash 配置文件格式为 yaml 格式，格式如下：\nport: 7890 socks-port: 7891 allow-lan: true mode: Rule log-level: info external-controller: :9090 proxies: - {name: cfmem.com - 🇭🇰 gq - 香港Amazon数据中心 20-1} proxy-groups: - name: 🔰 节点选择 type: select proxies: - ♻️ 自动选择 - 🎯 全球直连 - cfmem.com - 🇭🇰 gq - 香港Amazon数据中心 20-1 rules: - DOMAIN-SUFFIX,local,🎯 全球直连 proxies proxies 代表节点数据，所有的分流规则都是按照这些节点数据来的，这里可以有很多个节点数据，可以是 trojan, ss, vmess 类型都可以，我们来看个例子：\n{name: cfmem.com - 🇭🇰 gq - 香港Amazon数据中心 20-1, server: xxxx, port: 59113, type: vmess, uuid: 1111111, alterId: 0, cipher: auto, tls: false} clash 用统一的格式来定义不同的节点类型，用 type 来进行区分，特有的属性只需要在这个结构体加上自己属性就可以， clash 客户端会根据 type 不同而来读数据\nproxy-groups 可以把 proxy-groups 理解为一道又道的过滤网，当你发出一个请求时，这个请求将会被在哪一层的过滤网给拦截下来，取决于你的 rules 与 请求匹配。我们来解析一下 proxy-groups 里面的参数。\nname\n代表组的名称，组的名称可以随意命名，但建议取有意义的名称，组的名称可以被其它的组引用，也可以放在规则里面\ntype\ntype 代表这个组的类型，有下面四种情况\n  select 手动选择，该组在节点列表上，手动选择列表或者 proxy-group\n  url-test 延迟最低节点，测试该组所有节点的延迟\n  fallback 回落，连接该组第一个节点，不可用时切换到下一个节点\n  load-balance 负载均衡，由该组2个以上的节点提供链接\n  proxies\n这里可以是组名称或者节点名称，依次从上到下进行选择，比如看下面这个\n- name: 🔰 节点选择 type: select proxies: - ♻️ 自动选择 - 🎯 全球直连 - cfmem.com - 🇭🇰 gq - 香港Amazon数据中心 20-1 - cfmem.com - 🇭🇰 gq - 香港Amazon数据中心 26-2 - cfmem.com - 🇭🇰 gq - 香港Amazon数据中心 28-3 - cfmem.com - 🇭🇰 香港-4 - cfmem.com - 🇭🇰 香港 2-5 - cfmem.com - 🇭🇰 香港 3-6 - cfmem.com - 🇭🇰 香港 4-7 - cfmem.com - 🇭🇰 香港 10-8 - cfmem.com - 🇭🇰 香港 11-9 - name: ♻️ 自动选择 type: url-test url: http://www.gstatic.com/generate_204 interval: 300 proxies: - cfmem.com - 🇭🇰 gq - 香港Amazon数据中心 20-1 - cfmem.com - 🇭🇰 gq - 香港Amazon数据中心 26-2 - cfmem.com - 🇭🇰 gq - 香港Amazon数据中心 28-3 - cfmem.com - 🇭🇰 香港-4 - cfmem.com - 🇭🇰 香港 2-5 - cfmem.com - 🇭🇰 香港 3-6 - cfmem.com - 🇭🇰 香港 4-7 - cfmem.com - 🇭🇰 香港 10-8 - cfmem.com - 🇭🇰 香港 11-9 - cfmem.com - 🇭🇰 香港 12-10 - name: 🌍 国外媒体 type: select proxies: - 🔰 节点选择 - ♻️ 自动选择 - 🎯 全球直连 - cfmem.com - 🇭🇰 gq - 香港Amazon数据中心 20-1 名称为自动选择的组会每间隔 300 毫秒去 ping 节点数据，测试的地址是：http://www.gstatic.com/generate_204\n而 国外媒体这一项是手动选择默认选择第一个 节点选择，节点选择的第一个是自动选择，所以默认是根据 ping 值来选择节点的\nrules rules 也就是具体的分发规则了，规则一般由 [规则前缀],[域名或地址],[组名] 组成。我们来看下，其中 no-resolve 表示不要解析这条规则，只处理直接 ip 访问请求\nrules: - DOMAIN-SUFFIX,local,🎯 全球直连 - IP-CIDR,192.168.0.0/16,🎯 全球直连,no-resolve - IP-CIDR,10.0.0.0/8,🎯 全球直连,no-resolve - IP-CIDR,172.16.0.0/12,🎯 全球直连,no-resolve - IP-CIDR,127.0.0.0/8,🎯 全球直连,no-resolve - IP-CIDR,100.64.0.0/10,🎯 全球直连,no-resolve - IP-CIDR6,::1/128,🎯 全球直连,no-resolve - IP-CIDR6,fc00::/7,🎯 全球直连,no-resolve - IP-CIDR6,fe80::/10,🎯 全球直连,no-resolve - IP-CIDR6,fd00::/8,🎯 全球直连,no-resolve - DOMAIN-KEYWORD,1drv,Ⓜ️ 微软服务 规则前缀有这些内容\n  DOMAIN-SUFFIX 表示包含什么后缀的域名\n  IP-CIDR IPV4匹配\n  IP-CIDR6 IPV6匹配\n  DOMAIN-KEYWORD,xxx 表示包含 xxx域名关键字的链接\n  DOMAIN abc.hello.com 表示包含完整的域名\n  PROCESS-NAME 表示进程名称\n  GEOIP 数据库（国家代码）匹配\n  MATCH 全匹配（一般放在最后）\n  DNS污染 DNS服务器即是将用户请求的域名(网站URL)转换为IP地址的服务器。当年中国长城防火墙开始部署时就是通过DNS污染来屏蔽网站的。这项名为DNS污染的技术，就是对用户请求的域名回应一个错误的IP地址，使用户无法访问某个网站。至此，国内几乎所有的公共DNS服务器都被污染，用户无法请求到被屏蔽网站的正确IP地址。但是目前，防火墙的屏蔽功能早已不止DNS污染那么简单了，可以针对IP/域名直接阻断连接，甚至屏蔽了国外未受污染的DNS服务器，因此仅靠国内的DNS是不够翻墙的。\n对抗DNS劫持 早期的DNS服务器（我们日常使用的基本也是）都是明文传输数据的，这就意味着防火墙可以探测出你访问的网站，并且直接篡改DNS服务器回应的IP地址。这不仅仅存在于长城防火墙，还存在于某些无良网络运营商，把用户的请求的网站劫持到某个假的网站上。\n于是目前出现了DoH与DoT，可使用https/tls 加密传输DNS请求，这使得DNS不再容易被劫持了。国内的许多公共DNS也都提供了这项服务。以下是我所推荐的国内DNS。\n https://223.5.5.5/dns-query https://223.6.6.6/dns-query https://doh.pub/dns-query  或许可以参考 如何选择适合的公共 DNS？\n何时使用 Clash只会在域名匹配为直连时使用配置文件的DNS，其余时刻均交给节点进行远程解析。当然，节点域名也会使用配置文件的DNS。\n举个例子，访问 google.com 时，匹配到代理规则，那么这个流量将直接被发送至节点服务器，交给节点处理（通常是节点服务器的DNS解析，这个不用管了）。访问 microsoft.com 时，匹配到直连规则，Clash将使用配置文件的DNS设定进行解析。\nDNS配置 首先，打开你的 Clash 配置文件（如果你使用 Clash for Windows 或 Clash for Android, 可以使用软件自带的“覆写/Mixin”功能），添加以下段落：\ndns: enable: true listen: 0.0.0.0:53Copy 这一段的意思是启用 Clash 的 DNS 服务并让其在 53 端口（这是绝大多数操作系统将 DNS 解析报文发送到的端口）监听来自任意网络界面的 DNS 请求。如果你的设备并不需要向其他设备提供解析服务，或你的设备常常需要接入不安全的网络（如手机，笔记本电脑），应当将第三行的 0.0.0.0:53 改为 127.0.0.1:53 让 Clash 仅监听本机的 DNS 解析报文。\n（Clash 默认会同时监听 IPv4 和 IPv6 界面，如果你不需要后者，可以添加一行 ipv6: false）\n由于连接到加密 DNS 服务时，需要解析服务器本身的域名，因此需要指定一些相对干净的国内 明文 DNS 服务器地址。继续添加以下部分（注意缩进）：\n#--omitted-- default-nameserver: - 119.29.29.29 - 223.5.5.5Copy 当收到 DNS 解析请求时，Clash 会使用以上 DNS 服务器解析加密 DNS 服务器地址并建立连接。\n接下来，指定解析国内域名时使用的加密 DNS 服务器地址：\n#--omitted-- nameserver: - https://doh.pub/dns-query - https://dns.alidns.com/dns-queryCopy Clash 支持 DoH（https://domain.tld/dns-query 形式） 和 DoT（tls://domain.tld 形式）两种加密 DNS 协议，不支持 DoQ.（当然也支持在此指定备用的明文 DNS）\n然后，指定解析国外域名时使用的加密 DNS 服务器地址，并设置分流规则：\n#--omitted-- fallback: - https://1.1.1.1/dns-query - https://dns.google/dns-query fallback-filter: geoip: true geoip-code: CN ipcidr: - 240.0.0.0/4Copy “fallback” 字段指定的 DNS 服务器将被用于解析非国外域名，而 “fallback-filter” 字段则实现我们想要的分流规则——当请求解析的域名在 GeoIP 数据库内的国家代码不是 CN 时，或是域名在前文设置的 DNS 服务器内的解析结果位于 240.0.0.0/4 这一 IP 段内时（被屏蔽的域名解析常常会被污染到这一段），使用 “fallback” 字段指定的 DNS 服务器解析域名。\n最后，修改系统 DNS 服务器为 127.0.0.1 即可。\n代理环境中的 DNS 解析行为 虽然 Fake IP 这个概念早在 2001 年就被提出来了，但是到 Clash 提供 fake-ip 增强模式以后，依然有很多人对 Fake IP 这个概念以及其作用知之甚少。本文就简单谈谈在代理环境中，TCP 连接建立之前发生的事。由于移动设备操作系统中网络栈相对复杂，本文的例子也并不一定适用于移动端环境。文章中也许会存在很多错误，也希望各路大佬的勘误和斧正。\n不使用代理 如果在不使用任何代理的情况下，打开一个没有命中 DNS 缓存的网站（比如 blog.skk.moe）的时候，浏览器和操作系统大概会执行这么一些操作：\n 浏览器自己都有 DNS 缓存机制，因此浏览器会先开始寻找自己的缓存，不过没有找到 blog.skk.moe 的解析结果 浏览器通过调用操作系统的 getaddrinfo 方法，向操作系统寻求解析结果 操作系统自己也有一层 DNS 缓存，但是现在操作系统从自己的缓存中依然找不到这一结果 在系统的网络设置之中有设置上游 DNS 地址，假设操作系统中设置的是 119.29.29.29，那么操作系统会向 119.29.29.29 发起解析请求（UDP 流量）拿到 blog.skk.moe 的 IP 当然如果 119.29.29.29 自己没有 blog.skk.moe 的解析结果会找它的上游去要。不过我们不关心这一点，反正最后 119.29.29.29 会把 blog.skk.moe 的解析结果返回给设备的操作系统 现在，浏览器已经可以开始向 blog.skk.moe 的 IP 发起 HTTPS 连接了  以上是打开一个网页常见的 DNS 解析流程，对于其它非 HTTP 的 TCP 连接（比如 SMTP）也都差不多是这个流程——由于 TCP/IP 的协议特性，在应用发起 TCP 连接时，会先发出一个 DNS question（发一个 IP Packet），获取要连接的服务器的 IP 地址，然后直接向这个 IP 地址发起连接。\n设置代理并使用直连 现在，我们在应用程序（比如我们的浏览器、或者其它应用）中设置了代理，但是这个代理不涉及到任何远端服务器（直连模式）。接下来以设置了 SOCKS5 代理的浏览器为例。\n 浏览器不再需要从自己的 DNS 缓存中寻找 blog.skk.moe，因为已经有了 SOCKS5 代理，浏览器可以直接将域名封装在 SOCKS5 流量之中发往代理客户端 代理客户端从 SOCKS5 流量中抽出 blog.skk.moe 这个域名并设法获得解析结果 代理客户端将你的 SOCKS5 流量还原成标准的 TCP 请求 代理客户端将这个 TCP 连接建立起来，在这个例子之中 TCP 连接承载的是 HTTPS  之前由于获取解析结果是浏览器在操作，而大部分浏览器都会选择调用系统的 getaddrinfo 方法，因此如果你想要在 DNS 上做一些黑魔法就只能在操作系统层面实现，比如在本机或者别处架设一个带黑魔法的 DNS 服务器，然后你系统中设置使用这个 DNS 服务器。现在 DNS 解析是由代理客户端执行，因此在代理客户端上就可以实现一些黑魔法。比如 Surge 自己实现了一个 DNS Server 可以并发向多个上游同时发起查询、比如 V2Ray 可以实现不同域名的查询分流，等等。当然代理客户端也可以使用操作系统的 getaddrinfo 方法。\n设置代理并将流量转发到远端服务器 现在在上一步的基础之上，我们为代理服务器设置了一个远端服务器，这个代理会使用 某种协议 和远端服务器通信，并且这种协议和 SOCKS5 一样支持将域名封装在传输中。浏览器和代理客户端之间依然使用 SOCKS5 通信。\n 因为已经有了 SOCKS5 代理，浏览器可以直接将域名 blog.skk.moe 和整个请求封装在 SOCKS5 流量之中发往代理客户端 代理客户端从 SOCKS5 流量中抽出 blog.skk.moe 这个域名以及其它数据 代理客户端使用 某种协议 将浏览器发出的 SOCKS5 的流量重组并发给远端服务器 远端服务器使用相同的 某种协议 从流量中获得其中的域名 blog.skk.moe 远端服务器的代理服务端发起了一次 DNS 解析请求试图解析 blog.skk.moe。绝大部分情况下，代理的服务端都会直接使用操作系统的 getaddrinfo 方法、也就是由远端服务器的操作系统负责 DNS  这一次，不论是代理客户端还是你的浏览器都没有进行 DNS 解析，DNS 解析是在远端服务器上进行的。因为 某种协议 支持封装域名，然后这一次和 blog.skk.moe 连接的是远端服务器，考虑到针对 CDN 优化，DNS 解析自然需要在远端服务器上执行。\n现在我已经介绍了通过代理直连和通过代理发送给远端服务器了。但是毫无疑问，我相信本文所有的读者自己使用的上网方式都不会是全面直连或者全面代理。这就是接下来要讲的：\n设置代理并使用 IP 规则和域名规则进行分流 分流是一个麻烦事。一般情况下，你可能会需要使用域名进行分流（不论是白名单还是黑名单）。不过更多情况下你会使用到基于 IP 的规则来进行分流。\n先来看第一个例子：使用域名规则进行分流。\n 浏览器将带有域名 blog.skk.moe 的 HTTPS 请求封装在 SOCKS5 流量之中发往代理客户端 代理客户端从 SOCKS5 流量中抽取出域名 blog.skk.moe 代理客户端开始将blog.skk.moe 和域名规则列表开始比较。这个列表可以是白名单或黑名单，域名可能也没有匹配上。反正最终比较得出的结果就是 blog.skk.moe 是否需要走代理。 如果不需要走代理，代理客户端剩下会做的事情和本文第二部分「设置代理并使用直连」就完全一样了；同理，需要走代理的话就需要进行本文第三部分的那个流程  使用域名规则分流很简单，除非 blog.skk.moe 最终是直连，否则代理客户端不需要进行 DNS 解析。\n现在来看第二个例子：使用 IP 规则分流。\n 浏览器将带有域名 blog.skk.moe 的 HTTPS 请求封装在 SOCKS5 流量之中发往代理客户端 代理客户端从 SOCKS5 流量中抽取出域名 blog.skk.moe 代理客户端得到 blog.skk.moe 的解析结果 代理客户端开始将blog.skk.moe 的解析结果和 IP 规则列表开始比较。这个列表可以是 cnlist 或者 MaxMind IP 数据库。反正最终得出的结果就是 blog.skk.moe 解析结果的 IP 是否需要走代理。 如果不需要走代理，代理客户端剩下会做的事情和本文第二部分「设置代理并使用直连」就完全一样了；同理，需要走代理的话就需要进行本文第三部分的那个流程。  使用 IP 规则分流，前提首先你得有一个 IP 拿来比较。所以代理客户端必须先进行一次 DNS 解析。使用什么方法进行 DNS 解析并不重要，之前已经说过代理客户端甚至可以使用自己的黑魔法，而我们只需要关心最终代理客户端拿到了一个 IP 并且可以用于规则判定。\n此时需要注意的是，虽然代理客户端获得了一个 IP，但是你只有在直连的时候，代理客户端可能（并且基本上都会）复用这个 IP；如果是将流量交给远程服务器，由于 某种协议 支持封装域名，因此远程服务器拿到的还是域名不是 IP、还需要进行一次解析。也就是说，远端服务器连接的 IP 与 代理客户端解析得到的 IP 毫无关系。\n使用 redir / tun2socks 实现全局流量经过代理 在开始之前，我们先复习一下 TCP/IP 协议怎么说的——「在应用发起 TCP 连接时，会先发出一个 DNS question（发一个 IP Packet），获取要连接的服务器的 IP 地址，然后直接向这个 IP 地址发起连接」\n全局流量代理可能会出现在路由器上或者 TUN/TAP 型的支持全局代理客户端上。用户不再主动为每个应用程序设置代理。此时应用程序是不会感知到代理客户端的存在，它们会正常的发起 TCP 连接，并且由于 TCP/IP 协议，在拿到 DNS 解析结果之前，连接是不能建立的。\n 浏览器自己都有 DNS 缓存机制，因此浏览器会先开始寻找自己的缓存，不过没有找到 blog.skk.moe 的解析结果 浏览器通过调用操作系统的 getaddrinfo 方法，向操作系统寻求解析结果 操作系统自己也有一层 DNS 缓存，但是现在操作系统从自己的缓存中依然找不到这一结果 在系统的网络设置之中有设置上游 DNS 地址。代理客户端可能会修改系统设置中的 DNS 到 127.0.0.1 或者别的 IP、也可能保留用户之前的设置，这无所谓，因为… 操作系统发出的 DNS 解析请求会经过代理客户端并最终被截获 代理客户端可以将这个解析请求原样发出去、或者用自己的黑魔法，总之代理客户端都会拿到一个解析结果 代理客户端将这个解析结果返回回去，操作系统拿到了这个解析结果并返回给浏览器 浏览器对这个解析结果的 IP 建立一个 TCP 连接并发送出去 这个 TCP 连接被代理客户端截获。由于之前代理客户端进行的 DNS 解析请求这一动作，代理客户端可以找到这个只包含目标 IP 的 TCP 连接原来的目标域名 如果是支持 redir 的代理客户端，那么代理客户端就会直接将域名和 TCP 连接中的其它数据封装成 某种协议 发给远端服务器；或者封装成 SOCKS5 后交给支持 SOCKS5 的代理客户端  如果代理客户端需要按照域名进行分流，一般会在第 6 步代理客户端解析出一个 IP 或者第 9 步代理客户端拿到域名以后。FancySS、KoolSS、SSTap 的流程大抵都是如此。\n和应用程序直接将流量封装成 SOCKS5 大有不同，在类似于透明代理的环境下浏览器和其它应用程序是正常地发起 TCP 连接。因此除非得到一个 DNS 解析结果，否则 TCP 连接不会建立；代理客户端也会需要通过这个 DNS 查询动作，才能找到之后的 TCP 连接的域名。 你大概能够发现，浏览器、应用程序直接设置 SOCKS5 代理的话，可以不在代理客户端发起 DNS 解析请求就能将流量发送给远端服务器；而在透明代理模式下，不论是否需要 IP 规则分流都需要先进行一次 DNS 解析才能建立连接。\n有没有办法能像直接设置 SOCKS5 代理一样省掉一次 DNS 解析呢？有，就是代理客户端自己不先执行查询动作，丢一个 Fake IP 回去让浏览器、应用程序立刻建立 TCP 连接：\n在 redir / tun2socks 中使用 Fake IP Fake IP 的定义出自 RFC3089。这个 RFC 定义了一种新的将 TCP 连接封装成 SOCKS 协议的方法。\n 浏览器自己都有 DNS 缓存机制，因此浏览器会先开始寻找自己的缓存，不过并没有找到 blog.skk.moe 的解析结果 浏览器通过调用操作系统的 getaddrinfo 方法，向操作系统寻求解析结果 操作系统自己也有一层 DNS 缓存，但是现在操作系统从自己的缓存中依然找不到这一结果 在系统的网络设置之中设置了一个专门的上游 DNS 地址，可能是用户手动设置的也可能是代理客户端设置的。不论如何，这个设置最终会使操作系统向代理客户端发起 DNS 请求 操作系统发出的 DNS 解析请求会经过代理客户端并最终被截获 代理客户端从解析请求中获得域名，从 Fake IP 池中选取一个 IP 建立映射 代理客户端将这个 Fake IP 返回回去，操作系统拿到了这个 Fake IP 并返回给浏览器 浏览器对 Fake IP 建立一个 TCP 连接并发送出去 这个 TCP 连接被代理客户端截获。代理客户端抽取出 Fake IP 并反查出这个 TCP 连接中对应的域名 有了 TCP 连接和域名，代理客户端可以轻易地将其使用 SOSCKS5 或者 某种协议 进行封装  有了 Fake IP，代理客户端无需进行 DNS 解析。最后不论是浏览器、代理客户端还是远端服务器都不会去和 Fake IP 进行连接，因为在代理客户端这里就已经完成了截获、重新封装。\n即使按照域名规则分流，代理客户端都没有进行 DNS 解析的需要。只有在遇到了按照 IP 进行分流的规则时，代理客户端才需要进行一次解析拿到一个 IP 用于判断。即便如此，这个 IP 只用于分流规则的匹配，不会被用于实际的连接。\nFancySS 和 Surge / Clash 的区别 FancySS 是使用的 redir，Surge 的增强模式使用的是 Fake IP，Clash 的增强模式既有 redir-host 也有 Fake IP。首先把 FancySS 等路由器上常见的代理客户端和 Clash 的 redir-host 分为一类，Surge 的增强模式和 Clash 的 fake-ip 模式分为另一类。\n路由器上常见的代理客户端一般内置了 dns2socks、dnscryp-proxy、PCap_DNSProxy 等等 DNS 方案、也支持按照一定的规则进行分流，但是都是用于答复应用程序的 DNS question 使其建立 TCP 连接的，除非直连，否则通过这些 DNS 方案拿到的解析结果的 IP 并不会被用上。 大部分路由器上的代理客户端，DNS 解析请求都是通过路由器本机发出（或转发到单一远端服务器进行解析），因此解析结果只能说「至少能用」（不一定是有 CDN 优化的，甚至有可能会有 DNS 污染），如果流量不经过代理客户端直接发往这些 IP 地址，一般也不会影响浏览器、应用程序的正常使用。因此路由器上的代理客户端可以实现通过 iptables 控制让某些端口、某些设备的流量不经过代理客户端。 而在 Fake IP 模式下，浏览器、应用程序都是对 Fake IP 发起连接，如果没有代理客户端对连接进行重新封转，那么这部分流量就不能被发往真实的目的 IP，因此所有流量都必须经过代理客户端，而根据端口、设备的分流就需要由代理客户端自己实现。\n如果操作系统或者浏览器缓存了 DNS 解析结果 之前的透明代理的两个例子中，我们都假定浏览器和操作系统都没有缓存 DNS 解析结果。但是，如果操作系统或者应用程序缓存了 DNS 解析结果会发生什么？\n如果是不使用 Fake IP 的 redir / tun2socks 情况下，由于操作系统、浏览器或者应用程序中的任何一个缓存了 DNS 解析结果，因此 TCP 连接可以直接根据缓存的解析结果的 IP 建立，代理客户端并没有预先收到对应的 DNS question。在这种情况下，代理客户端有可能直接将这个连接视为和 IP 连接而不是和域名连接，根据域名规则的分流可能就会因此失效，不过根据 IP 分流的规则没有失效。 如果为了避免域名分流规则失效，你可以设法阻止操作系统或者浏览器缓存 DNS 解析结果，这样每次建立 TCP 连接之前都会发送 DNS question 使代理客户端探测到域名。但是这意味着每次 TCP 连接建立都需要代理客户端进行一次 DNS 解析请求（当然代理客户端可以对 DNS 解析进行缓存避免出现延时激增）。\n而对于 Fake IP 模式来说，由于代理客户端内存储有 Fake IP 和真实域名之间的映射表，因此即使操作系统或应用程序缓存了 Fake IP，在之后的 TCP 连接中，代理客户端收到流量后依然可以抽取出 Fake IP 反查出域名，因此不受 DNS 缓存的影响。\n我在这里留几个问题给大家思考一下：\n 如果使用了 Fake IP，代理客户端不论域名是否真实存在都会返回一个 Fake IP 给浏览器，那么浏览器在试图访问一个不存在的域名时，错误信息应该是什么样的？会不会出现 DNS 解析失败的错误信息？ 如果操作系统或者浏览器缓存了 Fake IP，但是代理客户端中 Fake IP 和域名的映射表丢失以后，会出现什么状况？可能会出现什么错误信息？  第二个问题很有趣。因为如果你找到了第二个问题的答案，你就会意识到 Clash 在 Fake IP 模式下偶发的无法上网的原因了。\n参考资料  HTTP 代理原理及实现（一） - 我的文章中举得都是 SOCKS5 的例子，如果想了解一下在 HTTP 代理中流量是如何被封装的，可以看看屈屈的这篇博客 Surge 原理与实现 - Surge 开发者写的 Surge 早期版本的工作原理，可以了解一下 Surge 是怎么处理各种协议的流量的 漫谈各种黑科技式 DNS 技术在代理环境中的应用 - Kitsunebi 开发者写的文章，详细地介绍了在不同的 V2Ray 配置下的 DNS 行为，同时还有对移动端网络栈的一些介绍  WireGuard 官方文档：https://github.com/pirate/wireguard-docs\nWireGuard 是由 Jason Donenfeld 等人用 C 语言编写的一个开源 VPN 协议，被视为下一代 VPN 协议，旨在解决许多困扰 IPSec/IKEv2、OpenVPN 或 L2TP 等其他 VPN 协议的问题。它与 Tinc 和 MeshBird 等现代 VPN 产品有一些相似之处，即加密技术先进、配置简单。从 2020 年 1 月开始，它已经并入了 Linux 内核的 5.6 版本，这意味着大多数 Linux 发行版的用户将拥有一个开箱即用的 WireGuard。\n术语 Peer/Node/Device\n连接到 VPN 并为自己注册一个 VPN 子网地址（如 192.0.2.3）的主机。还可以通过使用逗号分隔的 CIDR 指定子网范围，为其自身地址以外的 IP 地址选择路由。\n中继服务器（Bounce Server）\n一个公网可达的对等节点，可以将流量中继到 NAT 后面的其他对等节点。Bounce Server 并不是特殊的节点，它和其他对等节点一样，唯一的区别是它有公网 IP，并且开启了内核级别的 IP 转发，可以将 VPN 的流量转发到其他客户端。\n子网（Subnet）\n一组私有 IP，例如 192.0.2.1-255 或 192.168.1.1/24，一般在 NAT 后面，例如办公室局域网或家庭网络。\nCIDR 表示法\nCIDR中文全称是无分类域间路由选择，英文全称是Classless Inter-Domain Routing，在平常，大家多称之为无分类编址，它也是构成超网的一种技术实现。CIDR在一定程度上解决了路由表项目过多过大的问题。CIDR之所以称为无分类编址，就是因为CIDR完全放弃了之前的分类IP地址表示法，它真正消除了传统的A类、B类、C类地址以及划分子网的概念，它使用如下的IP地址表示法：\nIP地址 ::= {， } / 网络前缀所占位数 CIDR仅将IP地址划分为网络前缀和主机号两个部分，可以说又回到了二级IP地址的表示，不过大家要注意，最后面用“/”斜线分隔，在其后写上了网络前缀所占的位数，这样就不需要告知路由器地址掩码，仅需要通过网络前缀所占的位数就可以得到地址掩码，为了统一，CIDR中的地址掩码依然称为子网掩码。\nNAT\n子网的私有 IP 地址由路由器提供，通过公网无法直接访问私有子网设备，需要通过 NAT 做网络地址转换。路由器会跟踪发出的连接，并将响应转发到正确的内部 IP。\n公开端点（Public Endpoint）\n节点的公网 IP 地址:端口，例如 123.124.125.126:1234，或者直接使用域名 some.domain.tld:1234。如果对等节点不在同一子网中，那么节点的公开端点必须使用公网 IP 地址。\n私钥（Private key）\n单个节点的 WireGuard 私钥，生成方法是：wg genkey  example.key。\n公钥（Public key）\n单个节点的 WireGuard 公钥，生成方式为：wg pubkey example.key.pub。\nDNS\n域名服务器，用于将域名解析为 VPN 客户端的 IP，不让 DNS请求泄漏到 VPN 之外。\n工作原理 中继服务器工作原理\n中继服务器（Bounce Server）和普通的对等节点一样，它能够在 NAT 后面的 VPN 客户端之间充当中继服务器，可以将收到的任何 VPN 子网流量转发到正确的对等节点。事实上 WireGuard 并不关心流量是如何转发的，这个由系统内核和 iptables 规则处理。\n如果所有的对等节点都是公网可达的，则不需要考虑中继服务器，只有当有对等节点位于 NAT 后面时才需要考虑。\n*在 WireGuard 里，客户端和服务端基本是平等的，差别只是谁主动连接谁而已。*双方都会监听一个 UDP 端口，谁主动连接，谁就是客户端。主动连接的客户端需要指定对端的公网地址和端口，被动连接的服务端不需要指定其他对等节点的地址和端口。如果客户端和服务端都位于 NAT 后面，需要加一个中继服务器，客户端和服务端都指定中继服务器作为对等节点，它们的通信流量会先进入中继服务器，然后再转发到对端。\nWireGuard 是支持漫游的，也就是说，双方不管谁的地址变动了，WireGuard 在看到对方从新地址说话的时候，就会记住它的新地址（跟 mosh 一样，不过是双向的）。所以双方要是一直保持在线，并且通信足够频繁的话（比如配置 persistent-keepalive），两边的 IP 都不固定也不影响的。\n流量路由\n利用 WireGuard 可以组建非常复杂的网络拓扑，这里主要介绍几个典型的拓扑：\n 端到端直接连接  这是最简单的拓扑，所有的节点要么在同一个局域网，要么直接通过公网访问，这样 WireGuard 可以直接连接到对端，不需要中继跳转。\n一端位于 NAT 后面，另一端直接通过公网暴露  这种情况下，最简单的方案是：通过公网暴露的一端作为服务端，另一端指定服务端的公网地址和端口，然后通过 persistent-keepalive 选项维持长连接，让 NAT 记得对应的映射关系。\n两端都位于 NAT 后面，通过中继服务器连接  大多数情况下，当通信双方都在 NAT 后面的时候，NAT 会做源端口随机化处理，直接连接可能比较困难。可以加一个中继服务器，通信双方都将中继服务器作为对端，然后维持长连接，流量就会通过中继服务器进行转发。\n两端都位于 NAT 后面，通过 UDP NAT 打洞  上面也提到了，当通信双方都在 NAT 后面的时候，直接连接不太现实，因为大多数 NAT 路由器对源端口的随机化相当严格，不可能提前为双方协调一个固定开放的端口。必须使用一个信令服务器（STUN），它会在中间沟通分配给对方哪些随机源端口。通信双方都会和公共信令服务器进行初始连接，然后它记录下随机的源端口，并将其返回给客户端。这其实就是现代 P2P 网络中 WebRTC 的工作原理。有时候，即使有了信令服务器和两端已知的源端口，也无法直接连接，因为 NAT 路由器严格规定只接受来自原始目的地址（信令服务器）的流量，会要求新开一个随机源端口来接受来自其他 IP 的流量（比如其他客户端试图使用原来的通信源端口）。运营商级别的 NAT 就是这么干的，比如蜂窝网络和一些企业网络，它们专门用这种方法来防止打洞连接。更多细节请参考下一部分的 NAT 到 NAT 连接实践的章节。\n如果某一端同时连接了多个对端，当它想访问某个 IP 时，如果有具体的路由可用，则优先使用具体的路由，否则就会将流量转发到中继服务器，然后中继服务器再根据系统路由表进行转发。你可以通过测量 ping 的时间来计算每一跳的长度，并通过检查对端的输出（wg show wg0）来找到 WireGuard 对一个给定地址的路由方式。\n报文格式\nWireGuard 使用加密的 UDP 报文来封装所有的数据，UDP 不保证数据包一定能送达，也不保证按顺序到达，但隧道内的 TCP 连接可以保证数据有效交付。WireGuard 的报文格式如下图所示：\n性能\nWireGuard 声称其性能比大多数 VPN 协议更好，但这个事情有很多争议，比如某些加密方式支持硬件层面的加速。\nWireGuard 直接在内核层面处理路由，直接使用系统内核的加密模块来加密数据，和 Linux 原本内置的密码子系统共存，原有的子系统能通过 API 使用 WireGuard 的 Zinc 密码库。WireGuard 使用 UDP 协议传输数据，在不使用的情况下默认不会传输任何 UDP 数据包，所以比常规 VPN 省电很多，可以像 55 一样一直挂着使用，速度相比其他 VPN 也是压倒性优势。\n安全模型\nWireGuard 使用以下加密技术来保障数据的安全：\n 使用 ChaCha20 进行对称加密，使用 Poly1305 进行数据验证。 利用 Curve25519 进行密钥交换。 使用 BLAKE2 作为哈希函数。 使用 HKDF 进行解密。  WireGuard 的加密技术本质上是 Trevor Perrin 的 Noise 框架的实例化，它简单高效，其他的 VPN 都是通过一系列协商、握手和复杂的状态机来保障安全性。WireGuard 就相当于 VPN 协议中的 qmail，代码量比其他 VPN 协议少了好几个数量级。\n密钥管理\nWireGuard 通过为每个对等节点提供简单的公钥和私钥来实现双向认证，每个对等节点在设置阶段生成密钥，且只在对等节点之间共享密钥。每个节点除了公钥和私钥，不再需要其他证书或预共享密钥。\n在更大规模的部署中，可以使用 Ansible 或 Kubernetes Secrets 等单独的服务来处理密钥的生成、分发和销毁。\n如果你不想在 wg0.conf 配置文件中直接硬编码，可以从文件或命令中读取密钥，这使得通过第三方服务管理密钥变得更加容易：\n[Interface] ... PostUp = wg set %i private-key /etc/wireguard/wg0.key (cat /some/path/%i/privkey) 从技术上讲，多个服务端之间可以共享相同的私钥，只要客户端不使用相同的密钥同时连接到两个服务器。但有时客户端会需要同时连接多台服务器，例如，你可以使用 DNS 轮询来均衡两台服务器之间的连接，这两台服务器配置相同。大多数情况下，每个对等节点都应该使用独立的的公钥和私钥，这样每个对等节点都不能读取到对方的流量，保障了安全性。\n搭建使用与配置详解 快速开始 安装\n# Ubuntu ≥ 18.04 $ apt install wireguard 在中继服务器上开启 IP 地址转发：\n$ echo \"net.ipv4.ip_forward = 1\"  /etc/sysctl.conf $ echo \"net.ipv4.conf.all.proxy_arp = 1\"  /etc/sysctl.conf $ sysctl -p /etc/sysctl.conf 添加 iptables 规则，允许本机的 NAT 转换：\n$ iptables -A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT $ iptables -A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT $ iptables -A FORWARD -i wg0 -o wg0 -m conntrack --ctstate NEW -j ACCEPT $ iptables -t nat -A POSTROUTING -s 192.0.2.0/24 -o eth0 -j MASQUERADE 需要把 eth0 改成你实际使用的网卡接口名称。\n配置文件\n配置文件可以放在任何路径下，但必须通过绝对路径引用。默认路径是 /etc/wireguard/wg0.conf。\n生成密钥\n#生成私钥 $ wg genkey  example.key # 生成公钥 $ wg pubkey example.key.pub 启动与停止\n$ wg-quick up /full/path/to/wg0.conf $ wg-quick down /full/path/to/wg0.conf # 启动/停止 VPN 网络接口 $ ip link set wg0 up $ ip link set wg0 down # 注册/注销 VPN 网络接口 $ ip link add dev wg0 type wireguard $ ip link delete dev wg0 # 注册/注销 本地 VPN 地址 $ ip address add dev wg0 192.0.2.3/32 $ ip address delete dev wg0 192.0.2.3/32 # 添加/删除 VPN 路由 $ ip route add 192.0.2.3/32 dev wg0 $ ip route delete 192.0.2.3/32 dev wg0 查看信息\n# 查看系统 VPN 接口信息 $ ip link show wg0 # 查看 VPN 接口详细信息 $ wg show all $ wg show wg0 # 查看 VPN 接口地址 $ ip address show wg0 路由\n# 查看系统路由表 $ ip route show table main $ ip route show table local # 获取到特定 IP 的路由 $ ip route get 192.0.2.3 一键安装\n一键安装请参考这个项目：WireGuard installer\n配置详解 WireGuard 使用 INI 语法作为其配置文件格式。配置文件可以放在任何路径下，但必须通过绝对路径引用。默认路径是 /etc/wireguard/wg0.conf。\n配置文件的命名形式必须为 ${WireGuard 接口的名称}.conf。通常情况下 WireGuard 接口名称以 wg 为前缀，并从 0 开始编号，但你也可以使用其他名称，只要符合正则表达式 ^[a-zA-Z0-9_=+.-]{1,15}$ 就行。\n你可以选择使用 wg 命令来手动配置 VPN，但一般建议使用 wg-quick，它提供了更强大和用户友好的配置体验，可以通过配置文件来管理配置。\n下面是一个配置文件示例：\n[Interface] # Name = node1.example.tld Address = 192.0.2.3/32 ListenPort = 51820 PrivateKey = localPrivateKeyAbcAbcAbc= DNS = 1.1.1.1,8.8.8.8 Table = 12345 MTU = 1500 PreUp = /bin/example arg1 arg2 %i PostUp = /bin/example arg1 arg2 %i PreDown = /bin/example arg1 arg2 %i PostDown = /bin/example arg1 arg2 %i [Peer] # Name = node2-node.example.tld AllowedIPs = 192.0.2.1/24 Endpoint = node1.example.tld:51820 PublicKey = remotePublicKeyAbcAbcAbc= PersistentKeepalive = 25 [Interface]\n这一节定义本地 VPN 配置。例如：\n本地节点是客户端，只路由自身的流量，只暴露一个 IP。\n[Interface] # Name = phone.example-vpn.dev Address = 192.0.2.5/32 PrivateKey =  本地节点是中继服务器，它可以将流量转发到其他对等节点（peer），并公开整个 VPN 子网的路由。\n[Interface] # Name = public-server1.example-vpn.tld Address = 192.0.2.1/24 ListenPort = 51820 PrivateKey =  DNS = 1.1.1.1  Name  这是 INI 语法中的标准注释，用于展示该配置部分属于哪个节点。这部分配置会被 WireGuard 完全忽略，对 VPN 的行为没有任何影响。\nAddress  定义本地节点应该对哪个地址范围进行路由。如果是常规的客户端，则将其设置为节点本身的单个 IP（使用 CIDR 指定，例如 192.0.2.3/32）；如果是中继服务器，则将其设置为可路由的子网范围。\n例如：\n 常规客户端，只路由自身的流量：Address = 192.0.2.3/32 中继服务器，可以将流量转发到其他对等节点（peer）：Address = 192.0.2.1/24 也可以指定多个子网或 IPv6 子网：Address = 192.0.2.1/24,2001:DB8::/64  ListenPort  当本地节点是中继服务器时，需要通过该参数指定端口来监听传入 VPN 连接，默认端口号是 51820。常规客户端不需要此选项。\nPrivateKey  本地节点的私钥，所有节点（包括中继服务器）都必须设置。不可与其他服务器共用。\n私钥可通过命令 wg genkey  example.key 来生成。\nDNS  通过 DHCP 向客户端宣告 DNS 服务器。客户端将会使用这里指定的 DNS 服务器来处理 VPN 子网中的 DNS 请求，但也可以在系统中覆盖此选项。例如：\n 如果不配置则使用系统默认 DNS 可以指定单个 DNS：DNS = 1.1.1.1 也可以指定多个 DNS：DNS = 1.1.1.1,8.8.8.8  Table  定义 VPN 子网使用的路由表，默认不需要设置。该参数有两个特殊的值需要注意：\n Table = off : 禁止创建路由 Table = auto（默认值） : 将路由添加到系统默认的 table 中，并启用对默认路由的特殊处理。  例如：Table = 1234\nMTU  定义连接到对等节点（peer）的 MTU（Maximum Transmission Unit，最大传输单元），默认不需要设置，一般由系统自动确定。\nPreUp  启动 VPN 接口之前运行的命令。这个选项可以指定多次，按顺序执行。\n例如添加路由：PreUp = ip rule add ipproto tcp dport 22 table 1234\nPostUp  启动 VPN 接口之后运行的命令。这个选项可以指定多次，按顺序执行。\n例如：\n  从文件或某个命令的输出中读取配置值：\nPostUp = wg set %i private-key /etc/wireguard/wg0.key   添加一行日志到文件中：\nPostUp = echo \"$(date +%s) WireGuard Started\"  /var/log/wireguard.log   调用 WebHook：\nPostUp = curl https://events.example.dev/wireguard/started/?key=abcdefg   添加路由：\nPostUp = ip rule add ipproto tcp dport 22 table 1234   添加 iptables 规则，启用数据包转发：\nPostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE   强制 WireGuard 重新解析对端域名的 IP 地址：\nPostUp = resolvectl domain %i \"~.\"; resolvectl dns %i 192.0.2.1; resolvectl dnssec %i yes   PreDown  停止 VPN 接口之前运行的命令。这个选项可以指定多次，按顺序执行。\n例如：\n  添加一行日志到文件中：\nPreDown = echo \"$(date +%s) WireGuard Going Down\"  /var/log/wireguard.log   调用 WebHook：\nPreDown = curl https://events.example.dev/wireguard/stopping/?key=abcdefg   PostDown  停止 VPN 接口之后运行的命令。这个选项可以指定多次，按顺序执行。\n例如：\n  添加一行日志到文件中：\nPostDown = echo \"$(date +%s) WireGuard Going Down\"  /var/log/wireguard.log   调用 WebHook：\nPostDown = curl https://events.example.dev/wireguard/stopping/?key=abcdefg   删除 iptables 规则，关闭数据包转发：\nPostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE   [Peer]\n定义能够为一个或多个地址路由流量的对等节点（peer）的 VPN 设置。对等节点（peer）可以是将流量转发到其他对等节点（peer）的中继服务器，也可以是通过公网或内网直连的客户端。\n中继服务器必须将所有的客户端定义为对等节点（peer），除了中继服务器之外，其他客户端都不能将位于 NAT 后面的节点定义为对等节点（peer），因为路由不可达。对于那些只为自己路由流量的客户端，只需将中继服务器作为对等节点（peer），以及其他需要直接访问的节点。\n举个例子，在下面的配置中，public-server1 作为中继服务器，其他的客户端有的是直连，有的位于 NAT 后面：\n  public-server1（中继服务器）\n[peer] : public-server2, home-server, laptop, phone\n  public-server2（直连客户端）\n[peer] : public-server1\n  home-server（客户端位于 NAT 后面）\n[peer] : public-server1, public-server2\n  laptop（客户端位于 NAT 后面）\n[peer] : public-server1, public-server2\n  phone（客户端位于 NAT 后面）\n[peer] : public-server1, public-server2\n  配置示例：\n  对等节点（peer）是路由可达的客户端，只为自己路由流量\n[Peer] # Name = public-server2.example-vpn.dev Endpoint = public-server2.example-vpn.dev:51820 PublicKey =  AllowedIPs = 192.0.2.2/32   对等节点（peer）是位于 NAT 后面的客户端，只为自己路由流量\n[Peer] # Name = home-server.example-vpn.dev Endpoint = home-server.example-vpn.dev:51820 PublicKey =  AllowedIPs = 192.0.2.3/32   对等节点（peer）是中继服务器，用来将流量转发到其他对等节点（peer）\n[Peer] # Name = public-server1.example-vpn.tld Endpoint = public-server1.example-vpn.tld:51820 PublicKey =  # 路由整个 VPN 子网的流量 AllowedIPs = 192.0.2.1/24 PersistentKeepalive = 25    Endpoint  指定远端对等节点（peer）的公网地址。如果对等节点（peer）位于 NAT 后面或者没有稳定的公网访问地址，就忽略这个字段。通常只需要指定中继服务器的 Endpoint，当然有稳定公网 IP 的节点也可以指定。例如：\n  通过 IP 指定：\nEndpoint = 123.124.125.126:51820   通过域名指定：\nEndpoint = public-server1.example-vpn.tld:51820   AllowedIPs  允许该对等节点（peer）发送过来的 VPN 流量中的源地址范围。同时这个字段也会作为本机路由表中 wg0 绑定的 IP 地址范围。如果对等节点（peer）是常规的客户端，则将其设置为节点本身的单个 IP；如果对等节点（peer）是中继服务器，则将其设置为可路由的子网范围。可以使用 , 来指定多个 IP 或子网范围。该字段也可以指定多次。\n当决定如何对一个数据包进行路由时，系统首先会选择最具体的路由，如果不匹配再选择更宽泛的路由。例如，对于一个发往 192.0.2.3 的数据包，系统首先会寻找地址为 192.0.2.3/32 的对等节点（peer），如果没有再寻找地址为 192.0.2.1/24 的对等节点（peer），以此类推。\n例如：\n  对等节点（peer）是常规客户端，只路由自身的流量：\nAllowedIPs = 192.0.2.3/32   对等节点（peer）是中继服务器，可以将流量转发到其他对等节点（peer）：\nAllowedIPs = 192.0.2.1/24   对等节点（peer）是中继服务器，可以转发所有的流量，包括外网流量和 VPN 流量，可以用来干嘛你懂得：\nAllowedIPs = 0.0.0.0/0,::/0   对等节点（peer）是中继服务器，可以路由其自身和其他对等节点（peer）的流量：\nAllowedIPs = 192.0.2.3/32,192.0.2.4/32   对等节点（peer）是中继服务器，可以路由其自身的流量和它所在的内网的流量：\nAllowedIPs = 192.0.2.3/32,192.168.1.1/24   PublicKey  对等节点（peer）的公钥，所有节点（包括中继服务器）都必须设置。可与其他对等节点（peer）共用同一个公钥。\n公钥可通过命令 wg pubkey example.key.pub 来生成，其中 example.key 是上面生成的私钥。\n例如：PublicKey = somePublicKeyAbcdAbcdAbcdAbcd=\nPersistentKeepalive  如果连接是从一个位于 NAT 后面的对等节点（peer）到一个公网可达的对等节点（peer），那么 NAT 后面的对等节点（peer）必须定期发送一个出站 ping 包来检查连通性，如果 IP 有变化，就会自动更新Endpoint。\n例如：\n 本地节点与对等节点（peer）可直连：该字段不需要指定，因为不需要连接检查。 对等节点（peer）位于 NAT 后面：该字段不需要指定，因为维持连接是客户端（连接的发起方）的责任。 本地节点位于 NAT 后面，对等节点（peer）公网可达：需要指定该字段 PersistentKeepalive = 25，表示每隔 25 秒发送一次 ping 来检查连接。  GUI Utilities Gnome GNOME 系统设置面板（gnome-control-center）和 GNOME 应用使用 dconf 配置系统存储设置。您可以使用 gsettings 或 dconf 命令行工具直接访问 dconf 数据库。这也可以让你修改用户界面不公开的设置。\nGNOME 桌面拥有强大的搜索功能，按 Super 键并搜索一些东西，可以进入“Settings-Search”中来设置可以搜索的内容和顺序。\nDo Not Disturb 使通知只在消息栏中，不会在桌面上弹出。\nGnome 3 自动切换的壁纸会有一个有时钟小图标。\n浏览 GNOME Shell cheat sheet 中解释了如何高效地使用 GNOME shell，它展示了 GNOME shell 的特色和快捷键，包括切换任务，使用键盘，窗口控制，面板，概览模式等等。以下是部分常用的快捷键：\n Super + m：显示消息托盘 Super + a：显示应用程序菜单 Alt- + Tab：切换当前使用的应用 Alt- + ` (美式键盘 Tab 上面的按键)：切换前台应用程序的窗口 Alt + F2，然后输入 r 或 restart：在图形界面出问题时重启界面（仅用于 X/传统 模式，不适用于 Wayland 模式）。也可通过此运行后台应用，如 cfw。  遗留名称 注意： 一些 GNOME 程序在文档和对话框中的名称已经更改，但执行文件名称却没有。下面表格列出了一些这样的应用程序。\n提示： 在搜索栏中搜索应用的遗留名称将成功找到对应的应用，例如搜索 nautilus 将返还 文件。\n   当前 遗留     文件 Nautilus   Web Epiphany   视频 Totem   主菜单 Alacarte   文档查看器 Evince   磁盘使用情况分析器 Baobab   图像查看器 EoG (Eye of GNOME)   密码和密钥 Seahorse    修改文件默认关联的应用程序  mime类型文件存在于以下的两个路径：  /usr/share/mime ~/.local/share/mime    /usr/share/mime/text/makrdown.xml  应用程序的desktop文件，存在于以下的两个路径：  /usr/share/applications ~/.local/share/applications    [Desktop Entry] # 应用名称，即开始菜单中的名称 Type=ApplicationName=name # 应用执行文件位置 Exec=appPath # 应用图标位置 Icon=default48.png # 是否显示终端 Terminal=false # 所属分类 StartupNotify=trueCategories=Office # MIME 类型 MimeType=text/x-markdown  应用程序默认关联文件，存在于以下的两个路径：  /usr/share/applications/mimeapps.list ~/.local/share/applications/mimeapps.list    Gedit 编码 直接打开gedit（非通过文件打开），点击左上角 Open，点击左下角 Automatically Detected，下拉选择 Add or Remove…，将简体中文编码都选上。\n或者：\n$ gsettings list-keys org.gnome.gedit.preferences.encodings candidate-encodings $ gsettings set org.gnome.gedit.preferences.encodings candidate-encodings \"['UTF-8', 'ISO-8859-15', 'UTF-16', 'GBK', 'GB18030', 'GB2312']\" NVIDIA Optimus NVIDIA Optimus 是一项允许英特尔（Intel）集成图形处理器（GPU）和英伟达（NVIDIA）独立图形处理器置入并通过一台笔记本电脑访问的技术。\n桌面卡死 总的来说，就是杀死相关进程，或者避免使用造成卡死相关软件。\n  选择其他 tty：\n$ pkill Xorg pkill 用于杀死一个进程，与 kill 不同的是它会杀死指定名字的所有进程。kill 命令杀死指定进程 PID，需要配合 ps 使用。\n  安全重启：同时按住 Ctrl 和 Alt 键，按住不要放，按一下 SysRq 键（有的键盘是PrtSc），按一下 R 键，按一下 E 键，依次按下 I , S , U , B 键。\n  解决 Ubuntu 经常卡死：ubuntu 的卡死可能与显卡驱动不兼容有关。用 nvidia 代替 nouveau显卡驱动。其中 nvidia-driver-470-server 是 server 版，最好用 nvidia-driver-470\n  PRIME synchronization You can enable PRIME synchronization to prevent screen tearing. It requires:\n Linux kernel 4.5 or higher; X server 1.19 or higher; NVIDIA driver 370.23 or higher.  PRIME synchronization will be enabled automatically after you enable KMS for nvidia-drm module.\n  Add this line to the end of /etc/modprobe.d/nvidia.conf:\noptions nvidia-drm modeset=1   Regenerate your initramfs image by running:\n# update-initramfs -u   Reboot.\n  要检查重新启动后以前的更改是否有效，请运行命令：\n$ sudo cat /sys/module/nvidia_drm/parameters/modeset Y see more about nvidia on uat BinaryDriverHowto/Nvidia\nPermanently Set NVIDIA PowerMizer Settings $ nvidia-settings -q GpuPowerMizerMode Attribute 'GPUPowerMizerMode' (rastating-PC:1[gpu:0]): 0. Valid values for 'GPUPowerMizerMode' are: 0, 1 and 2. 'GPUPowerMizerMode' can use the following target types: GPU. $ nvidia-settings -a \"[gpu:0]/GpuPowerMizerMode=1\" Attribute 'GPUPowerMizerMode' (rastating-PC:1[gpu:0]) assigned value 1. $ nvidia-settings -q GpuPowerMizerMode Attribute 'GPUPowerMizerMode' (rastating-PC:1[gpu:0]): 1. Valid values for 'GPUPowerMizerMode' are: 0, 1 and 2. 'GPUPowerMizerMode' can use the following target types: GPU. 添加到开机启动\n Name：NVIDIA X Server Performance Settings Command：/usr/bin/nvidia-settings -a \"[gpu:0]/GpuPowerMizerMode=1\"  密钥环 如果你用过 Ubuntu 或者其他的 Linux 发行版里的自动登录功能, 你可能遇到过这种弹出消息：\n 请输入密码以解锁你的登录密钥环\n登录密钥环在你登录系统时未解锁。\n 如果你一直点击取消，它会不断弹出几次才会消失。你可能想知道，为什么你会一直看到这个密钥环信息呢？\n让我来告诉你吧。它其实不是错误，而是一个安全特性。\n奇怪吗？下面就让我来解释下 Linux 里的密钥环概念。\n密钥环是什么，为什么需要它？ 在现实生活中你为什么要用钥匙环（也叫钥匙链）？你用它把一把或多把钥匙串到一起, 以便于携带和查找。\nLinux 里也是类似的。密钥环特性使你的系统可以将各种密码放在一起，并将其保存在一个地方。\n大多数 Linux 桌面环境，如 GNOME、KDE、Xfce 等采用 GNOME 密钥环来提供这个功能。\n该密钥环保存了 ssh 密钥、GPG 密钥以及使用此功能的应用程序（例如 Chromium 浏览器）的密钥。默认情况下，“密钥环”通过主密码来保护，该密码通常是帐户的登录密码。\n系统上的每个用户都有自己的密钥环，（通常）密码与用户帐户本身的密码相同。当你使用密码登录系统时，你的密匙环将使用你帐户的密码自动解锁。\n当你启用 Ubuntu 中的自动登录功能时时，就有问题了。这意味着你无需输入密码即可登录系统。在这种情况下，你的密钥环不会自动解锁。\n密钥环是一个安全特性\n记得我说过密钥环是一个安全特性吗？现在想象一下你在 Linux 电脑上开启了自动登录功能。有权访问你电脑的任何人无需密码就能进入你的系统。但是你可能不会在意，因为你只是用它来访问互联网。\n但是，如果你在 Ubuntu 中使用 Chromium 或 Google Chrome 之类的浏览器，并使用它来保存各种网站的登录密码，那么你将遇到麻烦。任何人都可以使用浏览器并利用你在浏览器中保存的密码登录网站。这不很危险吗？\n这就是为什么当你使用 Chrome 时，它将反复地提示你先解锁密钥环。这确保了只有知道密钥环密码（即账户密码）的人才能使用在浏览器中保存的密码来登录它们相关的网站。\n如果你反复取消解锁密钥环的提示，它最终将消失，并允许你使用浏览器。但是，保存的密码将不会被解锁，你在 Chromium/Chome 浏览器上将会看到“同步暂停”的提示。\n如果密钥环一直存在，为什么你从来没有见过它呢?\n如果你在你的 Linux 系统上从没见过它的话，这个问题就很有道理。\n如果你从没有用过自动登录功能（或者修改你的账户密码），你可能都没有意识到这个特性的存在。\n这是因为当你通过你的密码登录系统时，你的密钥环被你的账户密码自动解锁了。\nUbuntu（和其他发行版）在执行普通的管理任务如修改用户、安装新软件等需要输入密码，无论你是否是自动登录的。但是对于日常任务像使用浏览器，它不需要输入密码因为密钥环已经被解锁了。\n当你切换到自动登录时，你不再需要输入登录密码。这意味着密钥环没有被自动解锁，因此当你使用利用了密钥环特性的浏览器时，它将提示你来解锁密钥环。\n你可以轻松地管理密钥环和密码\n这个密钥环放在哪里？它的核心是一个守护任务（一个后台自动运行的程序）。\n别担心。你不必通过终端来操作守护任务。大多数桌面环境都自带一个可以和这个守护进程进行交互的图形化应用程序。KDE 上有 KDE 钱包，GNOME 和其他桌面上叫做“密码和密钥”（Password And Keys）。\n你可以用这个 GUI 程序来查看哪些应用程序在用密钥环来管理/保护密码。\n你可以看到，我的系统有自动创建的登录密钥环。也有一个存储 GPG 和 SSH 密钥的密钥环。那个证书用来保存证书机构颁发的证书（如 HTTPS 证书）。\n你也可以使用这个应用程序来手动保存网站的密码。\n这里有一个潜在的问题，如果你格式化你的系统，手动保存的密码必然会丢失。通常，你会备份你的个人文件，但并不是所有的用户特定数据，如密钥环文件。\n有一种办法能解决它。密钥环数据通常保存在 ~/.local/share/keyrings 目录。在这里你可以看到所有的密钥环，但是你不能直接看到它们的内容。如果你移除密钥环的密码（我会在这篇文章的后面描述操作步骤），你可以像一个普通的文本文件一样读取密钥环的内容。你可以将这个解锁后的密钥环文件完整地复制下来，并在其他的 Linux 机器上运行“密码和密钥”应用程序导入到其中。\n总结一下目前为止所学的内容：\n 大多数 Linux 系统缺省已经安装并激活了密钥环特性 系统上的每个用户都拥有他自己的密钥环 密钥环通常是用账户密码锁定的（保护） 当你通过密码登录时密钥环会被自动解锁 对于自动登录，密钥环不会自动解锁，因此当你试图使用依赖密钥环的应用程序时会被提示先解锁它 并不是所有的浏览器或应用程序利用了密钥环特性 （Linux 上）安装一个 GUI 程序可以和密钥环交互 你可以用密钥环来手动存储加密格式的密码 你可以自己修改密钥环密码 你可以通过导出（需要先解锁密钥环）并导入到其他计算机上的方式来获取手工保存的密码。  修改密钥环密码 假设你修改了你的账户密码。当你登录时，你的系统试图通过新的登录密码来自动解锁密钥环。但是密钥环还在使用老的登录密码。\n这种情况下，你可以修改密钥环密码为新的登录密码，这样密码环才能在你登录系统时自动解锁。\n 从菜单中打开“密码和密钥”应用程序 在“Login”密钥环上右击并点击“修改密码”：  如果你不记得老的登录密码怎么办？\n你可能知道在 Ubuntu 上重置忘记的密码很容易。但是密钥环在这种场景下还是有问题。你修改了账户密码，但是你不记得仍然被密钥环使用的老的账户密码。\n你不能修改它因为你不知道老的密码。怎么办？\n这种情况下，你将不得不移除整个密钥环。你可以通过“密码和密钥”应用程序来操作。\n另外，你也可以手动删除 ~/.local/share/keyrings 目录下的密钥环文件。\n老的密钥环文件被移除后，你再打开 Chrome/Chromium 时，它会提示你创建一个新的密钥环。\n你可以用新的登录密码，密钥环就会被自动解锁了。\n禁用密钥环密码 在你想用自动登录但又不想手动解锁密钥环时，你可以把禁用密钥环密码作为一个规避方法。记住你正在禁用一个安全特性，因此请三思。\n操作步骤和修改密钥环相似。打开“密码和密钥”应用程序，然后修改密钥环密码。\n技巧在于当它提示修改密码时，不要输入新密码，而是点击“继续”按钮。这将移除密钥环的密码。\n这种方法，密钥环没有密码保护，并将一直处于解锁状态。\nGnome Tweaks GNOME 桌面有称为“扩展”的小插件或附加组件，学会使用 GNOME 扩展来扩展系统的可用性。\n$ sudo apt install gnome-tweaks 同时会安装新的 GNOME Shell extensions，可以禁用桌面图标、Ubuntu Dock。可从浏览器安装 GNOME Shell extensions。\n如 OpenWeather，需设置 Location，Units 为公制单位，Layout为Right\ntheme design: Skeuomorphism vs Flat Design vs Material Design\n 主题目录： /usr/share/themes 或 ~/.themes 图标鼠标目录： /usr/share/icons 或 ~/.icons 壁纸： /usr/share/background , /usr/share/wallpapers  Ubuntu Dock Ubuntu Dock 就是 Dash to Dock。安装：\n$ sudo apt-get install gnome-shell-extension-dashtodock 重启，在 Extension 中设置 Dash to Dock，Dash to Dock 与 Ubuntu Dock 只能开启一个，否则有两个 Dock，但是就算关闭 Dash to Dock，Dash to Dock 设置依旧起作用到 Ubuntu Dock。\n重新登录。\nKDE Connect/GSConnect Files and links. Shared between devices.\nNetSpeed Displays Internet Speed\nClipboard Indicator Clipboard Manager extension for Gnome-Shell - Adds a clipboard indicator to the top panel, and caches clipboard history.\nCoverflow Alt-Tab Replacement of Alt-Tab, iterates through windows in a cover-flow manner.\nBluetooth Quick Connect Allow to connect to paired devices from gnome control panel.\nDesktop Icons NG (DING) with these advantages:\n Drag’n’Drop, both inside the desktop, between desktop and applications, and nautilus windows Allows to use “Open with…” option with several files When hovering or clicking on an icon with a name too large to fit, it shows the full name Doesn’t hang the compositor when there is too much activity in the desktop folder  Frippery Move Clock Move clock to left of status menu button\nInput Method Panel Input Method Panel using KDE’s kimpanel protocol for Gnome-Shell\nLock Keys Numlock \u0026 Capslock status on the panel\nOpenWeather Weather extension to display weather information from https://openweathermap.org/ or https://darksky.net for almost all locations in the world.\nPanel Date Format Allows to customize the date format on the panel.\nRefresh Wifi Connections This extension adds a refresh button to the Wi-Fi connection selection dialog to manually request for a network scan.\nScreenshot Tool Conveniently create, copy, store and upload screenshots. Please log out and log in again after updating.\nSound Input \u0026 Output Device ChooserLivepatch Shows a list of sound output and input devices (similar to gnome sound settings) in the status menu below the volume slider.\nStatus Area Horizontal Spacing Reduce the horizontal spacing between icons in the top-right status area\nUnite Unite is a GNOME Shell extension which makes a few layout tweaks to the top panel and removes window decorations to make it look like Ubuntu Unity Shell.\nUser Themes Load shell themes from user directory.\nVitals A glimpse into your computer’s temperature, voltage, fan speed, memory usage, processor load, system resources, network speed and storage stats. This is a one stop shop to monitor all of your vital sensors. Uses asynchronous polling to provide a smooth user experience.\nPapirus Icon Theme $ sudo add-apt-repository ppa:papirus/papirus $ sudo apt-get update $ sudo apt-get install papirus-icon-theme Materia Theme $ sudo apt install materia-gtk-theme Chrome Import Passwords\n Launch Chrome on your computer. Type the following in the address bar and pressEnter: chrome://flags On the flags screen, put your cursor in the search box and type Password import. You should see the Password import flag in the search results. To enable this flag, click the dropdown menu next to the flag and select Enabled. Click Relaunch at the bottom to relaunch Chrome. This will restore all of your open tabs. When Chrome opens, click the three dots in the top-right corner, and select Settings  Passwords on the following screen. Click the three dots next to Saved Passwords and select Import. Navigate to your CSV passwords file and select it to import it into Chrome.  Tampermonkey 提供用户脚本\n FastGithub 镜像加速访问、克隆和下载 文本选中复制：解除网站不允许复制的限制，文本选中后点击复制按钮即可复制，主要用于 百度文库 道客巴巴 无忧考网 学习啦 蓬勃范文 思否社区 力扣 知乎 语雀 等 秒传链接提取：用于提取和生成百度网盘秒传链接 知乎增强：移除登录弹窗 网页复制限制解除  Download All Images 下载网页所有图片\nuBlock Origin 禁广告\n沙拉查词 聚合词典专业划词翻译\nInfinity New Tab Chrome Extension，解决 Chrome new tab 加载后会清空搜索栏问题\nQuestions The repository ‘http://dl.google.com/linux/chrome/deb stable Release’ does not have a Release file\nThe “key” is “repository can’t be authenticated”\nIMHO… you don’t have the key of the repo\nTo solve that just use this command:\n$ wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | sudo apt-key add - Chromium Chromium 是一款来自 “The Chromium Project” 的开源图形网络浏览器，基于 Blink 渲染引擎。它也是商业软件 Google Chrome 浏览器得以组成的基础。\n在这里你可以看到 Google Chrome 与 Chromium 浏览器的区别。此外，还有一点重要的不同：2021年3月2日发布的 Chromium 89 及其以后版本不再支持 Google 账户同步功能。\n注意： 目前，可以通过 使用 Chrome 的OAuth2 凭证或者 申请一个属于自己的凭证来恢复同步功能, 但是请注意，这不一定是一个长期的解决方案。长期来讲，最好考虑使用 xbrowsersync 来同步书签数据。\nFirefox 主要用于 Firefox，安装媒体解码器来播放 MP3、MPEG4 和其他格式媒体文件。由于各个国家的版权问题， Ubuntu 在默认情况下不会安装它。\n$ sudo apt-get install ubuntu-restricted-extras 这种方式会安装 .exe 程序，不如直接安装\n$ sudo apt-get install h264enc Flameshot Powerful, yet simple to use open-source screenshot software.\n   Keys Description     ←, ↓, ↑, → Move selection 1px   Shift + ←, ↓, ↑, → Resize selection 1px   Esc Quit capture   Ctrl + C Copy to clipboard   Ctrl + S Save selection as a file   Ctrl + Z Undo the last modification   Right Click Show color picker   Mouse Wheel Change the tool’s thickness    Add a new Shortcuts\n On ‘Name’, name it ‘Flameshot’ Define the command as ‘flameshot gui’. Select ‘Define shortcut…‘and click your keyboard win + shift + Prt Sc key.  PPSSPP A PSP emulator.\n$ sudo add-apt-repository ppa:ppsspp/stable $ sudo apt-get update $ sudo apt install ppsspp Graphics:\n Rendering Mode  set the Backend from OpenGL to Vulkan.   Framework Control  Frameskipping is Off Auto-Frameskip is Off set the Alternative Speed to Unlimited   Postprocessing effects  Postprocessing shader should be off.   Performance  If your Device is Powerful, high rendering resolution will work. Its recommended to first try with 2x Rendering resolution as It brings impressive graphics and supports stable gameplay too Hardware transform, Software skinning, Vertex cache and Lazy texture caching should be checked. Retain changed textures should be unchecked while keeping Disable slower effects and Hardware Installation checked.   Overlay Information  Select FPS in Show FPS counter.    System:\n Make sure Fast memory is checked Set I/O timing method, to Simulate UMD delays or Fast  yuzu yuzu 是 Citra的制作者写的一个开源NS模拟器，用C++编写，特点包括Vulkan API的支持、灵活的模拟器配置以及游戏配置等等。\n玩了 super mario odyssey，过场动画很卡顿，可以软配置的很少，主要看硬件配置，我的配置玩 BOTW 是不可能了。\n安装   选择 File - Open yuzu Folder\n  在打开的目录下，新建keys文件夹（如果没有），然后进入keys文件夹，放入key文件prod.keys，内容如下\naes_kek_generation_source = 4d870986c45d20722fba1053da92e8a9 aes_key_generation_source = 89615ee05c31b6805fe58f3da24f7aa8 bis_kek_source = 34c1a0c48258f8b4fa9e5e6adafc7e4f bis_key_00 = 374e0e2ab275141f811badcb0fefd881b71d6af540de58895901aa0c01663bc8 bis_key_01 = 0b08f19a42ac5ae590b3373ad9698344a571f35165663536dae0842b5221b31c bis_key_02 = 38f0936f33bacedc0c0a159ffbbeee0f40bb08386915bdd0c6730349b99081ec bis_key_03 = 38f0936f33bacedc0c0a159ffbbeee0f40bb08386915bdd0c6730349b99081ec bis_key_source_00 = f83f386e2cd2ca32a89ab9aa29bfc7487d92b03aa8bfdee1a74c3b6e35cb7106 bis_key_source_01 = 41003049ddccc065647a7eb41eed9c5f44424edab49dfcd98777249adc9f7ca4 bis_key_source_02 = 52c2e9eb09e3ee2932a10c1fb6a0926c4d12e14b2a474c1c09cb0359f015f4e4 device_key = bd16c45b2647d842c5ee3c869e3a9607 device_key_4x = 2078900c6bb36fff1fdad57a7dd1b66e eticket_rsa_kek = 19c8b441d318802bad63a5beda283a84 eticket_rsa_kek_source = dba451124ca0a9836814f5ed95e3125b eticket_rsa_kekek_source = 466e57b74a447f02f321cde58f2f5535 header_kek_source = 1f12913a4acbf00d4cde3af6d523882a header_key = aeaab1ca08adf9bef12991f369e3c567d6881e4e4a6a47a51f6e4877062d542d header_key_source = 5a3ed84fdec0d82631f7e25d197bf5d01c9b7bfaf628183d71f64d73f150b9d2 key_area_key_application_00 = ef979e289a132c23d39c4ec5a0bba969 key_area_key_application_01 = cdedbab97b69729073dfb2440bff2c13 key_area_key_application_02 = 75716ed3b524a01dfe21456ce26c7270 key_area_key_application_03 = f428306544cf5707c25eaa8bc0583fd1 key_area_key_application_04 = 798844ec099eb6a04b26c7c728a35a4d key_area_key_application_05 = a57c6eecc5410ada22712eb3ccbf45f1 key_area_key_application_06 = 2a60f6c4275df1770651d5891b8e73ec key_area_key_application_07 = 32221bd6ed19b938bec06b9d36ed9e51 key_area_key_application_08 = fb20aa9e3dbf67350e86479eb431a0b3 key_area_key_application_09 = ce8d5fa79e220d5f48470e9f21be018b key_area_key_application_0a = 38b865725adcf568a81d2db3ceaa5bcc key_area_key_application_0b = bbddfd40a59d0ff555c0954239972213 key_area_key_application_0c = 3fee7204e21c6b0ff1373226c0c3e055 key_area_key_application_source = 7f59971e629f36a13098066f2144c30d key_area_key_ocean_00 = b33813e4c9c4399c75fabc673ab4947b key_area_key_ocean_01 = c54166efa8c9c0f6511fa8b580191677 key_area_key_ocean_02 = 3061ce73461e0b0409d6a33da85843c8 key_area_key_ocean_03 = 06f170025a64921c849df168e74d37f2 key_area_key_ocean_04 = dc857fd6dc1c6213076ec7b902ec5bb6 key_area_key_ocean_05 = 131d76b70bd8a60036d8218c15cb610f key_area_key_ocean_06 = 17d565492ba819b0c19bed1b4297b659 key_area_key_ocean_07 = 37255186f7678324bf2b2d773ea2c412 key_area_key_ocean_08 = 4115c119b7bd8522ad63c831b6c816a6 key_area_key_ocean_09 = 792bfc652870cca7491d1685384be147 key_area_key_ocean_0a = dfcc9e87e61c9fba54a9b1c262d41e4d key_area_key_ocean_0b = 66fe3107f5a6a8d8eda2459d920b07a1 key_area_key_ocean_0c = b79b6bf3d6cdc5ec10277fc07a4fec93 key_area_key_ocean_source = 327d36085ad1758dab4e6fbaa555d882 key_area_key_system_00 = 6dd02aa15b440d6231236b6677de86bc key_area_key_system_01 = 4ab155e7f29a292037fd147592770b12 key_area_key_system_02 = b7a74adeaf89c2a198c327bdff322d7d key_area_key_system_03 = d5aab1acd23a8aec284a316df859d377 key_area_key_system_04 = 9b44b45b37de9d14754b1d22c2ca742c key_area_key_system_05 = 0012e957530d3dc7af34fbbe6fd44559 key_area_key_system_06 = 01744e3b0818445cd54ee9f89da43192 key_area_key_system_07 = d0d30e46f5695b875f11522c375c5a80 key_area_key_system_08 = bd06cb1b86bd5c433667470a09eb63de key_area_key_system_09 = e19f788f658eda8bbf34a1dd2a9503a9 key_area_key_system_0a = 7070e7ff5cfe448630143a9874903c38 key_area_key_system_0b = 3fa471d4483e58b8f7756fcb64f63890 key_area_key_system_0c = 7bfd381df3369407ab1c6bdd9fabf522 key_area_key_system_source = 8745f1bba6be79647d048ba67b5fda4a keyblob_00 = f759024f8199101dddc1ef91e6eecf37e24b95ac9272f7ae441d5d8060c843a48322d21cdd06d4fc958c68d3800eb4db939ffbec930177f77d136144ff615aa8835e811bb958deda218f8486b5a10f531b30cb9d269645ac9fc25c53fc80525e56bd3602988a9fcf06bbf99ca910ad6530791d512c9d57e17abf49220de6419bf4eca1685c1e4df77f19db7b44a985ca keyblob_01 = bd27264ae07e979756411d0c66e679e3c50851f3e902d9c2cd1a438b948159a517ec1566c10570326ea2697ee62da46f14bb5d581bfc06fd0c9387ea33d2d4dc63e7809ba90f03dd2c7112ffbfa548951b9b8c688b5e4f2951d24a73da29c668154a5d4838dba71ee068ace83fe720e8c2a495c596f73525dc3c05994b40ad27f8c60322f75cd548b821af9162e16f76 keyblob_02 = a3d4a8e153b8e6ae6e6aef3e8f219cb4b7790f47856accc76268f9afa99a1ff8b1a72f63d1f99f480a3c1532078bb59abdd25203cfb12a38b33e9ba6a09afb6f24283b3ba76a0161230a73669ddf5493c2b7919d094fd795b484794854f71e4f4c672245d7770e29397722444d111b4229cdbf35707b70634ea8f140766e884cc580cb1e2d9aa9866ffef920010fc409 keyblob_03 = 1558f525ae8c5be9243fb6d8a8b0a8ee0e886a59035668740a936619b7a5c83e821198b171d18e51445054df68688e45703b936818a827d8e540dd6bef2e11ec9ddc6cfe5fc736dd769b9f6e0a23a62e2e5f49e86143646a04ec3a23f828373a336a5c224a91f8a0c6c6a7b5844dd6415804209f83c943aeca9cfd856db6bd4ec32009c8cb268ed053052c9237dfd8bc keyblob_04 = 9fbeb1957fc1629e08b753a9086d6e01ffb4f11466b7417e3fa7f5f1efb754406704fd75afaf91a408a0b524c1fc80d36c2046fa4757412efe4c11e382f72e8a10d90ed580017d9deb87af2549b6b02661af48ff94f6072c0fef7fc2833b8bdae503898e2e927ac0663e8b6391dd4f1d685313935e2c48ece7d177c88bc9c883ede36c3677495784b838d7265c6ba7a1 keyblob_05 = 94a92da1d73c2b3e165c891ced5607fc6628ca2a0654f3fbc05711c063377c6e9c96a9d0192e530dd510e4fd41aa62ef4213c5f6e059e7e21db098a9b22d1e6c29bee148aaef15c52549d9165de96e85b0d029ecdc5843e2f32cb18be707eec61909cf3385d45bc2a4c8d76e9bfad5a40c4b92dcb982aa50d474897ac9ebb5351a7015dcc277a08f1214ad41384d7941 keyblob_key_00 = 839944c8a38df6791020b38147e906b0 keyblob_key_01 = b9e6fbde828b5f42c897ade8fd14c625 keyblob_key_02 = b6988a0795d294ef522908692d5db7ca keyblob_key_03 = 0e57d7777171d125d3fe3af5b397d009 keyblob_key_04 = b55a282d698fabeb4e03c67ff2026bc5 keyblob_key_05 = fdb542c1f1bdf134ec20b1fda02bc9e1 keyblob_key_source_00 = df206f594454efdc7074483b0ded9fd3 keyblob_key_source_01 = 0c25615d684ceb421c2379ea822512ac keyblob_key_source_02 = 337685ee884aae0ac28afd7d63c0433b keyblob_key_source_03 = 2d1f4880edeced3e3cf248b5657df7be keyblob_key_source_04 = bb5a01f988aff5fc6cff079e133c3980 keyblob_key_source_05 = d8cce1266a353fcc20f32d3b517de9c0 keyblob_mac_key_00 = 604422526723e541a849fa4c18660e0b keyblob_mac_key_01 = 279481456b1dc259d35599e6392e01e5 keyblob_mac_key_02 = dbbfb8096b676c2a54b5d9c61b423a94 keyblob_mac_key_03 = 48b7aef6d9b1edb132b8901a245a7750 keyblob_mac_key_04 = 544c082e9f8602c736dc0732d4319f88 keyblob_mac_key_05 = a540ec8ba84bd31eaaa9ce9f95226875 keyblob_mac_key_source = 59c7fb6fbe9bbe87656b15c0537336a5 mariko_master_kek_source_05 = 77605ad2ee6ef83c3f72e2599dac5e56 mariko_master_kek_source_06 = 1e80b8173ec060aa11be1a4aa66fe4ae mariko_master_kek_source_07 = 940867bd0a00388411d31adbdd8df18a mariko_master_kek_source_08 = 5c24e3b8b4f700c23cfd0ace13c3dc23 mariko_master_kek_source_09 = 8669f00987c805aeb57b4874de62a613 mariko_master_kek_source_0a = 0e440cedb436c03faa1daebf62b10982 mariko_master_kek_source_0b = e541acecd1a7d1abed0377f127caf8f1 mariko_master_kek_source_0c = 52719bdfa78b61d8d58511e48e4f74c6 master_kek_00 = f759024f8199101dddc1ef91e6eecf37 master_kek_01 = bd27264ae07e979756411d0c66e679e3 master_kek_02 = a3d4a8e153b8e6ae6e6aef3e8f219cb4 master_kek_03 = 1558f525ae8c5be9243fb6d8a8b0a8ee master_kek_04 = 9fbeb1957fc1629e08b753a9086d6e01 master_kek_05 = 94a92da1d73c2b3e165c891ced5607fc master_kek_08 = e42f1ec8002043d746575ae6dd9f283f master_kek_09 = cec2885fbeef5f6a989db84a4cc4b393 master_kek_0a = dd1a730232522b5cb4590cd43869ab6a master_kek_0b = fc6f0c891d42710180724ed9e112e72a master_kek_0c = 43f7fc20fcec22a5b2a744790371b094 master_kek_source_06 = 374b772959b4043081f6e58c6d36179a master_kek_source_07 = 9a3ea9abfd56461c9bf6487f5cfa095c master_kek_source_08 = dedce339308816f8ae97adec642d4141 master_kek_source_09 = 1aec11822b32387a2bedba01477e3b67 master_kek_source_0a = 303f027ed838ecd7932534b530ebca7a master_kek_source_0b = 8467b67f1311aee6589b19af136c807a master_kek_source_0c = 683bca54b86f9248c305768788707923 master_key_00 = c2caaff089b9aed55694876055271c7d master_key_01 = 54e1b8e999c2fd16cd07b66109acaaa6 master_key_02 = 4f6b10d33072af2f250562bff06b6da3 master_key_03 = 84e04ec20b9373818c540829cf147f3d master_key_04 = cfa2176790a53ff74974bff2af180921 master_key_05 = c1dbedcebf0dd6956079e506cfa1af6e master_key_06 = 0aa90e6330cdc12d819b3254d11a4e1e master_key_07 = 929f86fbfe4ef7732892bf3462511b0e master_key_08 = 23cfb792c3cb50cd715da0f84880c877 master_key_09 = 75c93b716255319b8e03e14c19dea64e master_key_0a = 73767484c73088f629b0eeb605f64aa6 master_key_0b = 8500b14bf4766b855a26ffc614097a8f master_key_0c = b3c503709135d4b35de31be4b0b9c0f7 master_key_source = d8a2410ac6c59001c61d6a267c513f3c package1_key_00 = f4eca1685c1e4df77f19db7b44a985ca package1_key_01 = f8c60322f75cd548b821af9162e16f76 package1_key_02 = c580cb1e2d9aa9866ffef920010fc409 package1_key_03 = c32009c8cb268ed053052c9237dfd8bc package1_key_04 = ede36c3677495784b838d7265c6ba7a1 package1_key_05 = 1a7015dcc277a08f1214ad41384d7941 package2_key_00 = a35a19cb14404b2f4460d343d178638d package2_key_01 = a0dd1eacd438610c85a191f02c1db8a8 package2_key_02 = 7e5ba2aafd57d47a85fd4a57f2076679 package2_key_03 = bf03e9889fa18f0d7a55e8e9f684323d package2_key_04 = 09df6e361e28eb9c96c9fa0bfc897179 package2_key_05 = 444b1a4f9035178b9b1fe262462acb8e package2_key_06 = 442cd9c21cfb8914587dc12e8e7ed608 package2_key_07 = 70c821e7d6716feb124acbac09f7b863 package2_key_08 = 8accebcc3d15a328a48365503f8369b6 package2_key_09 = f562a7c6c42e3d4d3d13ffd504d77346 package2_key_0a = 0803167ec7fc0bc753d8330e5592a289 package2_key_0b = 341db6796aa7bdb8092f7aae6554900a package2_key_0c = 4e97dc4225d00c6ae33d49bddd17637d package2_key_source = fb8b6a9c7900c849efd24d854d30a0c7 per_console_key_source = 4f025f0eb66d110edc327d4186c2f478 retail_specific_aes_key_source = e2d6b87a119cb880e822888a46fba195 rsa_oaep_kek_generation_source = a8ca938434127fda82cc1aa5e807b112 rsa_private_kek_generation_source = ef2cb61a56729b9157c38b9316784ddd save_mac_kek_source = d89c236ec9124e43c82b038743f9cf1b save_mac_key = 71a917f1bac8f4f04d732e734c90e2ec save_mac_key_source = e4cd3d4ad50f742845a487e5a063ea1f save_mac_sd_card_kek_source = 0489ef5d326e1a59c4b7ab8c367aab17 save_mac_sd_card_key_source = 6f645947c56146f9ffa045d595332918 sd_card_custom_storage_key_source = 370c345e12e4cefe21b58e64db52af354f2ca5a3fc999a47c03ee004485b2fd0 sd_card_kek_source = 88358d9c629ba1a00147dbe0621b5432 sd_card_nca_key_source = 5841a284935b56278b8e1fc518e99f2b67c793f0f24fded075495dca006d99c2 sd_card_save_key_source = 2449b722726703a81965e6e3ea582fdd9a951517b16e8f7f1f68263152ea296a sd_seed = fdb479221c43741a118fb5475374d2f7 secure_boot_key = 208de9b9de94ff698d00657a6a82a973 ssl_rsa_kek = b011100660d1dccbad1b1b733afa9f95 ssl_rsa_kek_source_x = 7f5bb0847b25aa67fac84be23d7b6903 ssl_rsa_kek_source_y = 9a383bf431d0bd8132534ba964397de3 titlekek_00 = 62a24d6e6d0d0e0abf3554d259be3dc9 titlekek_01 = 8821f642176969b1a18021d2665c0111 titlekek_02 = 5d15b9b95a5739a0ac9b20f600283962 titlekek_03 = 1b3f63bcb67d4b06da5badc7d89acce1 titlekek_04 = e45c1789a69c7afbbf1a1e61f2499459 titlekek_05 = ddc67f7189f4527a37b519cb051eee21 titlekek_06 = b1532b9d38ab036068f074c0d78706ac titlekek_07 = 81dc1b1783df268789a6a0edbf058343 titlekek_08 = 47dfe4bf0eeda88b17136b8005ab08ea titlekek_09 = adaa785d90e1a9c182ac07bc276bf600 titlekek_0a = 42daa957c128f75bb1fda56a8387e17b titlekek_0b = d08903363f2c8655d3de3ccf85d79406 titlekek_0c = be2682599db34caa9bc7ebb2cc7c654c titlekek_source = 1edc7b3b60e6b4d878b81715985e629b tsec_key = 53ec4ac7c6c32ff2abff3eeff4f84f36 tsec_root_key_02 = 4b4fbcf58e23cf4902d478b76c8048ec yuzu以及Ryujinx都需要prod.keys，里面包含了NS设备需要的key，需要通过 Hekate等一些列工具生成。yuzu不需要单独安装固件，只要把key文件放好就可以启动游戏了。\n  关闭模拟器，重新打开 yuzu ，若没有弹窗，则配置成功\n  设置 General\n确保勾选 Multicore CPU Emulation 和 Confirm exit while emulation is runing。\nLimit Speed percent：游戏运行速度，默认即可，可加快或限速\nPause emulation when inbackground：退到后台模拟器暂停运行\nHide mouse inactivity：运行时鼠标隐藏\nPrompt for user for game boot：游戏启动时选择哪个账户游玩\nWeb\nyuzu web service：填了用户名和令牌以后可以向官网报告游戏兼容性\nTelemetry：开了以后能让yuzu开发者查看你的使用情况，以便改善模拟器\nDiscord Presence：在discord中显示你的游戏状态\n系统\nSystem 页面，Language 选择 Simplified Chinese，Region 选择 China。这个设置的是系统语言，很多游戏会根据系统语言自动切换游戏内显示的语言。当然前提是游戏本身包含中文，如果游戏本身无中文只能通过打补丁的方式显示中文。\nCustom RTC：修改系统时间，可以触发某些游戏的特定彩蛋之类的功能。\nRNG seed：随机数种子，一般情况别改改。\nProfile Manager：这里可以改switch用户名称、头像。可以设置多个用户\nCPU\n图形\n API设置：支持OpenGL和Vulkan。 Use disk shader cache：磁盘着色器缓存，建议开启，这样就不用每次都重新编译，而是直接从磁盘加载到内存 Use asynchronous GPU emulation：GPU异步模拟，yuzu重写了GPU显存管理器，加速了缓存机制，使得帧数得到明显提示，同时性能提升40%-400%（来自BSoD Gaming的测试数据） Use NVDEC emulation：NVDEC是一项硬件转码技术，能减少转码期间计算密集型任务中CPU的负担，这是Nvidia的一个技术，有了它，过场动画的播放会畅顺很多  Advanced\n Accuracy Level：即模拟器左下角状态栏的 GPU NORMAL。是处理图形绘制精确度，开启High可能会修复一些图形错误，但是速度可能会变慢，一般选默认Normal即可 Use Vysnc (OpenGL Only)：开启垂直同步 Use Fast GPU time： 使用GPU加速渲染 Anisotropic Filtering：是各项异性过滤，是用来处理图形纹理错误的，可以选2x-16x  声音\n默认。\n控制\n连接手柄，选择该设备。\n管理 游戏格式分为两种，.xci 格式和 .nsp 格式。简单一点说，.xci 格式是卡带版，.nsp 格式是数字版。因此基本上所有的 DLC 基本都是 .nsp 格式，但也有 .xci 里集成了 DLC 的情况。\n添加游戏\n双击模拟器中间，添加游戏目录，游戏目录也不要有中文。添加完就可以看到游戏了。\n安装Update和DLC\n选择File -Install Files to NAND…，选中 Update和DLC文件，Update 安装最新就行，DLC 需要全部安装（可以不按顺序）。\n安装 Mod\nMod 用于修改游戏，如解决一些bug以及优化性能等。右键单击要为其添加模组的游戏。然后将整个mod文件夹粘贴到那里。你可以从 Switch Mods 获得一些基本的 yuzu 模组。\n注意：您可以通过右键单击游戏并单击属性来检查您拥有的游戏模组。\n放入着色器缓存\n放入着色器缓存（shader cache）可以明显提升游戏的流畅性，建议找找别人的着色器缓存。\n具体放入步骤：右键某个游戏，选择打开可转移着色器缓存，即可弹出缓存所在文件夹，然后放入你下载的别人的缓存就行了，比如 vulkan.bin 和 opengl.bin\nrubick 基于 electron 的开源工具箱，自由集成丰富插件。\nuTools uTools 是一个极简、插件化的现代桌面软件，通过自由选配丰富的插件，打造得心应手的工具集合。\nGoldendict通过快捷键（默认 alt + space ）就可以快速呼出这个搜索框。你可以往输入框内粘贴文本、图片、截图、文件、文件夹等等，能够处理此内容的插件也早已准备就绪，统一的设计风格和操作方式，助你高效的得到结果。\n一旦你熟悉它后，能够为你节约大量时间，即用即走、不中断、无干扰，让你可以更加专注地改变世界。\nLiferea Liferea is a web feed reader/news aggregator that brings together all of the content from your favorite subscriptions into a simple interface that makes it easy to organize and browse feeds. Its GUI is similar to a desktop mail/news client, with an embedded web browser.\nCalibre calibre is a powerful and easy to use e-book manager. Users say it’s outstanding and a must-have. It’ll allow you to do nearly everything and it takes things a step beyond normal e-book software. It’s also completely free and open source and great for both casual users and computer experts.\nVentoy 简单来说，Ventoy是一个制作可启动U盘的开源工具。\n有了Ventoy你就无需反复地格式化U盘，你只需要把 ISO/WIM/IMG/VHD(x)/EFI 等类型的文件直接拷贝到U盘里面就可以启动了，无需其他操作。\nbalenaEtcher Supported Operating Systems\n Linux (most distros) macOS 10.10 (Yosemite) and later Microsoft Windows 7 and later  UNetbootin UNetbootin installs Linux/BSD distributions to a partition or USB drive\nWoeUSB-ng WoeUSB-ng is a simple tool that enable you to create your own usb stick windows installer from an iso image or a real DVD. This is a rewrite of original WoeUSB.\nGoldenDict Timeshift System restore tool for Linux.\nTodoist Plank Plank is meant to be the simplest dock on the planet.\nMotrix A full-featured download manager.\nSteam YACReader work_crawler Download comics novels\ndingtalk 钉钉桌面版，基于electron和钉钉网页版开发\nhowdy Windows Hello™ style facial authentication for Linux\n向日葵 向日葵远程控制软件是一款免费的集远程控制电脑手机、远程桌面连接、远程开机、远程管理、支持内网穿透的一体化远程控制管理工具软件。\nKeePassXC CLI Utilities Ansible 安装Ansible之后,不需要启动或运行一个后台进程,或是添加一个数据库.只要在一台电脑(可以是一台笔记本)上安装好,就可以通过这台电脑管理一组远程的机器.在远程被管理的机器上,不需要安装运行任何软件,因此升级Ansible版本不会有太多问题.\nfdupes You can call it like fdupes -r /dir/ect/ory and it will print out a list of dupes. fdupes has also a simple Homepage and a Wikipedia article, which lists some more programs.\ndigiKam 可用于查找重复相片，然后根据需要删除重复内容。\nbypy bypy info 认证特别慢，而授权码又只有10分钟，导致后面授权码过期 Heroku server 认证失败失败。\n如此，可以通过手动认证。\n  通过 bypy -dv 查看详细输出，得到 Full URL，如 https://bypyoauth.herokuapp.com/auth?code=...\u0026bypy_version=1.7.2\u0026redirect_uri=oob，在浏览器中打开，获得token。\n  将其放在 ~/.bypy/bypy.json 中。\n  源码仓库也有示例。\n我下载一个大文件，总共12G左右，已用了两个晚上，中途没关（由于不是立马就要的东西，就用时间换金钱了），一次看进度时，Terminal 就卡退了，重新运行后，bypy会继续上次下载，而不是重新开始（这样话太可怕了）。\nFRP frp 是一个专注于内网穿透的高性能的反向代理应用，支持 TCP、UDP、HTTP、HTTPS 等多种协议。可以将内网服务以安全、便捷的方式通过具有公网 IP 节点的中转暴露到公网。\n其他内网穿透工具\n ngrok ZeroTier N2N Dog Tunnel Tinc  Git $ vi .gitignore_default $ vi .auto-git.sh #!/bin/bash TIME=\"$(date '+%Y%m%d%H%M%S')\" echo '###SakamotoKuromeSource###' /bin/bash $HOME/Documents/SakamotoKuromeSource/deploy.sh echo '###vNotebook###' cd $HOME/Documents/vNotebook git pull echo '#Tree DataOne' echo '#Ignore files larger than 100MB' cat .gitignore_default  .gitignore find . -size +100M | sed 's|^./||g' | cat  .gitignore git add . git commit -m \"Update-${TIME}\" git push -v $ crontab -e 0 12 * * * /home/vane/.auto-git.sh  A collection of useful .gitignore templates Ignore files 100MB in your Git repos About large files on GitHub  GitHub Desktop Focus on what matters instead of fighting with Git. Whether you’re new to Git or a seasoned user, GitHub Desktop simplifies your development workflow.\nlibguestfs libguestfs 支持几乎所有类型的磁盘镜像。\n在基于 Debian 的系统上：\n$ apt-get install libguestfs-tools 我们可以像下面这样挂载一个 qcow2 格式的磁盘镜像：\n$ guestmount -a /path/to/qcow2/image -m  /path/to/mount/point 要卸载它，则执行：\n$ guestunmount qcow2_mount_poin Oracle JDK   解压缩到目录\n$ tar -zxv -f jdk-7u60-linux-x64.gz -C dir   修改环境变量\n$ vi ~/.bashrc export JAVA_HOME=/usr/lib/jvm/jdk1.7.0_60 # 这里换成自己解压的jdk 目录 export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib export PATH=${JAVA_HOME}/bin:$PATH   使环境变量生效\n$ source ~/.bashrc   Snapper Snapper 是一个由 openSUSE 的 Arvin Schnell 开发的工具，用于管理 Btrfs 子卷和 LVM 精简配置(thin-provisioned)卷。它可以创建和比较快照，在快照间回滚，并支持自动按时间序列创建快照。\n列出子卷列表\n$ sudo btrfs subvolume list -p / ID 256 gen 7746 parent 5 top level 5 path @ ID 258 gen 7746 parmount -n -o remount,rw /ent 5 top level 5 path @home 安装 snapper\n$ sudo apt install snapper snapper-gui 创建配置文件，启用自动快照\n$ sudo snapper -c root create-config / $ sudo snapper -c home create-config /home Snapshots on boot\n$ sudo systemctl status snapper-boot.timer 管理 snapshot\n$ sudo snapper-gui Fail2Ban Fail2Ban 是一款入侵防御软件，可以保护服务器免受暴力攻击。 它是用 Python 编程语言编写的。 Fail2Ban 基于auth 日志文件工作，默认情况下它会扫描所有 auth 日志文件，如 /var/log/auth.log、/var/log/apache/access.log 等，并禁止带有恶意标志的IP，比如密码失败太多，寻找漏洞等等标志。\n通常，Fail2Ban 用于更新防火墙规则，用于在指定的时间内拒绝 IP 地址。 它也会发送邮件通知。 Fail2Ban 为各种服务提供了许多过滤器，如 ssh、apache、nginx、squid、named、mysql、nagios 等。\nFail2Ban 能够降低错误认证尝试的速度，但是它不能消除弱认证带来的风险。 这只是服务器防止暴力攻击的安全手段之一。\nSyncthing Syncthing是一款开源免费跨平台的文件同步工具，是基于P2P技术实现设备间的文件同步，所以它的同步是去中心化的，即你并不需要一个服务器，故不需要担心这个中心的服务器给你带来的种种限制，而且类似于torrent协议，参与同步的设备越多，同步的速度越快。针对隐私问题，Syncthing软件只会将数据存储于个人信任的设备上，不会存储到服务器上。设备之间的通信均通过TLS进行，Syncthing还使用了完全正向保密技术来进一步保障你的数据安全。对于处于不同局域网之中的设备之间的文件同步，Syncthing也提供了支持。\nmasscan Masscan号称是最快的互联网端口扫描器，最快可以在六分钟内扫遍互联网。\nImageMagick Use ImageMagick to create, edit, compose, or convert digital images. It can read and write images in a variety of formats (over 200) including PNG, JPEG, GIF, WebP, HEIC, SVG, PDF, DPX, EXR and TIFF. ImageMagick can resize, flip, mirror, rotate, distort, shear and transform images, adjust image colors, apply various special effects, or draw text, lines, polygons, ellipses and Bézier curves.\np7zip 7-Zip is a file archiver with a high compression ratio.\np7zip 是 7-Zip 的 POSIX 系统移植，支持 Linux。\n警告： 不要将7z格式用于备份目的，因为它不会保存文件的所有者/组。有关更多详细信息，请参见7z(1)。\n添加文件或目录至已有的存档（或创建一个新的存档）：\n$ 7z a 也可以通过参数-p设置密码，并通过标志-mhe = on隐藏存档的结构：\n$ 7z a -p -mhe=on 更新存档内已有的文件或添加新文件：\n$ 7z u 列出存档内容：\n$ 7z l 从存档中解压文件至当前文件夹，不使用存档内的目录结构：\n$ 7z e 如果需要恢复存档内的目录结构，使用：\n$ 7z x 解压至新的目录：\n$ 7z x -o校验存档完整性：\n$ 7z t Differences between 7z, 7za and 7zr binaries The package includes three binaries, /usr/bin/7z, /usr/bin/7za, and /usr/bin/7zr. Their manual pages explain the differences:\n 7z(1) uses plugins to handle archives. 7za(1) is a stand-alone executable that handles fewer archive formats than 7z. 7zr(1) is a stand-alone executable. It is a “light-version” of 7za that only handles 7z archives. In contrast to 7za, it cannot handle encrypted archives.  分卷压缩与解压缩 rar\n# rar a -vSIZE 压缩后的文件名 被压缩的文件或者文件夹 # 最大限制为 12M $ rar a -m5 -v12m myarchive myfiles #解压 $ rar e myarchive.part1.rar tar\n要将目录logs打包压缩并分割成多个1M的文件，可以用下面的命令：\n$ tar cjf - logs/ | split -b 1m - logs.tar.bz2. 完成后会产生下列文件：\nlogs.tar.bz2.aa, logs.tar.bz2.ab, logs.tar.bz2.ac 要解压的时候只要执行下面的命令就可以了：\n$ cat logs.tar.bz2.a* | tar xj 7z\n压缩：\n$ 7z a name.7z filename -v10m 这里a是添加文件到压缩卷，name.7z是压缩后文件,然后filename可以是文件夹或文件，-v10m是限制每个包大小不超过10m.\n解压到当前目录：\n$ 7z x film.7z.001 Wudao-dict 有道词典的命令行版本，支持英汉互查和在线查询。\nascii-image-converter ttyd Share your terminal over the web\nprogress Linux tool to show progress for cp, mv, dd, … (formerly known as cv)\nvosk-api Offline speech recognition API for Android, iOS, Raspberry Pi and servers with Python, Java, C# and Node\nconvert MP3 to text The software you can use is Vosk-api, a modern speech recognition toolkit based on neural networks. It supports 7+ languages and works on variety of platforms including RPi and mobile.\nFirst you convert the file to the required format and then you recognize it:\n$ ffmpeg -i file.mp3 -ar 16000 -ac 1 file.wav Then install vosk-api with pip:\n$ pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple vosk Then use these steps:\n$ git clone https://github.com/alphacep/vosk-api $ cd vosk-api/python/example $ curl -O http://alphacephei.com/vosk/models/vosk-model-small-en-us-0.15.zip $ unzip vosk-model-small-en-us-0.15.zip $ mv vosk-model-small-en-us-0.15 model $ python3 ./test_simple.py test.wav  result.json The result will be stored in json format.\nThe same directory also contains an srt subtitle output example, which is easier to evaluate and can be directly useful to some users:\n$ python3 -m pip install srt $ python3 ./test_srt.py test.wav The example given in the repository says in perfect American English accent and perfect sound quality three sentences which I transcribe as:\none zero zero zero one nine oh two one oh zero one eight zero three The “nine oh two one oh” is said very fast, but still clear. The “z” of the before last “zero” sounds a bit like an “s”.\nThe SRT generated above reads:\n1 00:00:00,870 -- 00:00:02,610 what zero zero zero one 2 00:00:03,930 -- 00:00:04,950 no no to uno 3 00:00:06,240 -- 00:00:08,010 cyril one eight zero three so we can see that several mistakes were made, presumably in part because we have the understanding that all words are numbers to help us.\nNext I also tried with the vosk-model-en-us-0.22.zip which was a 1.8G download compared to 40M of vosk-model-small-en-us-0.15 and is listed at https://alphacephei.com/vosk/models:\n$ mv model vosk-model-small-en-us-0.15 $ curl -O http://alphacephei.com/vosk/models/vosk-model-en-us-0.22.zip $ unzip vosk-model-en-us-0.22.zip $ mv vosk-model-en-us-0.22 model and the result was:\n1 00:00:00,840 -- 00:00:02,610 one zero zero zero one 2 00:00:04,026 -- 00:00:04,980 i know what you window 3 00:00:06,270 -- 00:00:07,980 serial one eight zero three which got one more word correct.\ninxi inix 是一个用于获取 Linux 系统信息的终端命令。能够获取软件和硬件的详细信息，比如计算机型号、内核版本、发行版号以及桌面环境等信息，甚至可以读取主存模块占用主板的哪块 RAM 卡槽等详细信息。\ninxi 还可以用于监控系统中正在消耗 CPU 或者内存资源的进程。\n在 Ubuntu/Debian 发行版系统中，安装命令：\nsudo apt install inxi 用 -F 参数可以获取详细的系统信息。几乎囊括了所有层次的系统信息。\ninxi -F BusyBox BusyBox 是一个开源（GPL）项目，提供了近 400 个常用命令的简单实现，包括 ls、mv、ln、mkdir、more、ps、gzip、bzip2、tar 和 grep。它还包含了编程语言 awk、流编辑器 sed、文件系统检查工具 fsck、软件包管理器rpm 和 dpkg ，当然还有一个可以方便的访问所有这些命令的 shell（sh）。简而言之，它包含了所有 POSIX 系统需要的基本命令，以执行常见的系统维护任务以及许多用户和管理任务。\n事实上，它甚至包含一个 init 命令，可以作为 PID 1 启动，以作为所有其它系统服务的父进程。换句话说，BusyBox 可以作为 systemd、OpenRC、sinit、init 和其他初始化系统的替代品。\nBusyBox 非常小。作为一个可执行文件，它不到 1MB，所以它在嵌入式、边缘计算 和物联网领域很受欢迎，因为这些场景的存储空间是很宝贵的。在容器和云计算的世界里，它作为精简的 Linux 容器镜像的基础镜像也很受欢迎。\n极简主义 BusyBox 的部分魅力在于它的极简主义。它的所有命令都被编译到一个二进制文件里（busybox），它的手册只有 81 页（根据我对 man 送到 pr 管道的计算），但它涵盖了近 400 条命令。\n作为一个例子的比较，这是 “原版” 的 useradd —help 的输出：\n-b, --base-dir BASE_DIR base directory for home -c, --comment COMMENT GECOS field of the new account -d, --home-dir HOME_DIR home directory of the new account -D, --defaults print or change the default config -e, --expiredate EXPIRE_DATE expiration date of the new account -f, --inactive INACTIVE password inactivity -g, --gid GROUP name or ID of the primary group -G, --groups GROUPS list of supplementary groups -h, --help display this help message and exit -k, --skel SKEL_DIR alternative skeleton dir -K, --key KEY=VALUE override /etc/login.defs -l, --no-log-init do not add the user to the lastlog -m, --create-home create the user's home directory -M, --no-create-home do not create the user's home directory -N, --no-user-group do not create a group with the user's name -o, --non-unique allow users with non-unique UIDs -p, --password PASSWORD encrypted password of the new account -r, --system create a system account -R, --root CHROOT_DIR directory to chroot into -s, --shell SHELL login shell of the new account -u, --uid UID user ID of the new account -U, --user-group create a group with the same name as a user 而这是是同一命令的 BusyBox 版本：\n-h DIR Home directory -g GECOS GECOS field -s SHELL Login shell -G GRP Group -S Create a system user -D Don't assign a password -H Don't create home directory -u UID User id -k SKEL Skeleton directory (/etc/skel) 这种差异是一种特性还是一种限制，取决于你是喜欢你的命令拥有 20 个选项还是 10 个选项。对于一些用户和某些用例来说，BusyBox 的极简主义刚刚满足所需。对于其他人来说，它是一个很好的最小化环境，可以作为一个后备工具，或者作为安装更强大的工具的基础，比如 Bash、Zsh、GNU Awk 等等。\nLynis  使用这个全面的开源安全审计工具检查你的 Linux 机器的安全性。\n 你有没有想过你的 Linux 机器到底安全不安全？Linux 发行版众多，每个发行版都有自己的默认设置，你在上面运行着几十个版本各异的软件包，还有众多的服务在后台运行，而我们几乎不知道或不关心这些。\n要想确定安全态势（指你的 Linux 机器上运行的软件、网络和服务的整体安全状态），你可以运行几个命令，得到一些零碎的相关信息，但你需要解析的数据量是巨大的。\n如果能运行一个工具，生成一份关于机器安全状况的报告，那就好得多了。而幸运的是，有一个这样的软件：Lynis。它是一个非常流行的开源安全审计工具，可以帮助强化基于 Linux 和 Unix 的系统。根据该项目的介绍：\n “它运行在系统本身，可以进行深入的安全扫描。主要目标是测试安全防御措施，并提供进一步强化系统的提示。它还将扫描一般系统信息、易受攻击的软件包和可能的配置问题。Lynis 常被系统管理员和审计人员用来评估其系统的安全防御。”\n 安装 Lynis 你的 Linux 软件仓库中可能有 Lynis。如果有的话，你可以用以下方法安装它：\n$ sudo apt install lynis 然而，如果你的仓库中的版本不是最新的，你最好从 GitHub 上安装它。事实上，Lynis 主要是用 shell 脚本来实现的。\n运行 Lynis 通过给 Lynis 一个 -h 选项来查看帮助部分，以便有个大概了解：\n$ sudo lynis -h 你会看到一个简短的信息屏幕，然后是 Lynis 支持的所有子命令。\n接下来，尝试一些测试命令以大致熟悉一下。要查看你正在使用的 Lynis 版本，请运行：\n$ sudo lynis show version 3.0.0 要查看 Lynis 中所有可用的命令：\n$ sudo lynis show commands Commands: lynis audit lynis configure lynis generate lynis show lynis update lynis upload-only 审计 Linux 系统 要审计你的系统的安全态势，运行以下命令：\n$ sudo lynis audit system 这个命令运行得很快，并会返回一份详细的报告，输出结果可能一开始看起来很吓人，但我将在下面引导你来阅读它。这个命令的输出也会被保存到一个日志文件中，所以你可以随时回过头来检查任何可能感兴趣的东西。\nLynis 将日志保存在这里：\nFiles: - Test and debug information : /var/log/lynis.log - Report data : /var/log/lynis-report.dat 你可以验证是否创建了日志文件。它确实创建了：\n$ ls -l /var/log/lynis.log -rw-r-----. 1 root root 341489 Apr 30 05:52 /var/log/lynis.log $ ls -l /var/log/lynis-report.dat -rw-r-----. 1 root root 638 Apr 30 05:55 /var/log/lynis-report.dat 探索报告 Lynis 提供了相当全面的报告，所以我将介绍一些重要的部分。作为初始化的一部分，Lynis 做的第一件事就是找出机器上运行的操作系统的完整信息。之后是检查是否安装了什么系统工具和插件：\n[+] Initializing program ------------------------------------ - Detecting OS... [ DONE ] - Checking profiles... [ DONE ] --------------------------------------------------- Program version: 3.0.0 Operating system: Linux Operating system name: Red Hat Enterprise Linux Server 7.8 (Maipo) Operating system version: 7.8 Kernel version: 3.10.0 Hardware platform: x86_64 Hostname: example ---------------------------------------------------  [+] System Tools ------------------------------------ - Scanning available tools... - Checking system binaries... [+] Plugins (phase 1) ------------------------------------ Note: plugins have more extensive tests and may take several minutes to complete - Plugin: pam [..] - Plugin: systemd [................] 接下来，该报告被分为不同的部分，每个部分都以 [+] 符号开头。下面可以看到部分章节。（哇，要审核的地方有这么多，Lynis 是最合适的工具！）\n[+] Boot and services [+] Kernel [+] Memory and Processes [+] Users, Groups and Authentication [+] Shells [+] File systems [+] USB Devices [+] Storage [+] NFS [+] Name services [+] Ports and packages [+] Networking [+] Printers and Spools [+] Software: e-mail and messaging [+] Software: firewalls [+] Software: webserver [+] SSH Support [+] SNMP Support [+] Databases [+] LDAP Services [+] PHP [+] Squid Support [+] Logging and files [+] Insecure services [+] Banners and identification [+] Scheduled tasks [+] Accounting [+] Time and Synchronization [+] Cryptography [+] Virtualization [+] Containers [+] Security frameworks [+] Software: file integrity [+] Software: System tooling [+] Software: Malware [+] File Permissions [+] Home directories [+] Kernel Hardening [+] Hardening [+] Custom tests Lynis 使用颜色编码使报告更容易解读。\n 绿色。一切正常 黄色。跳过、未找到，可能有个建议 红色。你可能需要仔细看看这个  在我的案例中，大部分的红色标记都是在 “Kernel Hardening” 部分找到的。内核有各种可调整的设置，它们定义了内核的功能，其中一些可调整的设置可能有其安全场景。发行版可能因为各种原因没有默认设置这些，但是你应该检查每一项，看看你是否需要根据你的安全态势来改变它的值：\n[+] Kernel Hardening ------------------------------------ - Comparing sysctl key pairs with scan profile - fs.protected_hardlinks (exp: 1) [ OK ] - fs.protected_symlinks (exp: 1) [ OK ] - fs.suid_dumpable (exp: 0) [ OK ] - kernel.core_uses_pid (exp: 1) [ OK ] - kernel.ctrl-alt-del (exp: 0) [ OK ] - kernel.dmesg_restrict (exp: 1) [ DIFFERENT ] - kernel.kptr_restrict (exp: 2) [ DIFFERENT ] - kernel.randomize_va_space (exp: 2) [ OK ] - kernel.sysrq (exp: 0) [ DIFFERENT ] - kernel.yama.ptrace_scope (exp: 1 2 3) [ DIFFERENT ] - net.ipv4.conf.all.accept_redirects (exp: 0) [ DIFFERENT ] - net.ipv4.conf.all.accept_source_route (exp: 0) [ OK ] - net.ipv4.conf.all.bootp_relay (exp: 0) [ OK ] - net.ipv4.conf.all.forwarding (exp: 0) [ OK ] - net.ipv4.conf.all.log_martians (exp: 1) [ DIFFERENT ] - net.ipv4.conf.all.mc_forwarding (exp: 0) [ OK ] - net.ipv4.conf.all.proxy_arp (exp: 0) [ OK ] - net.ipv4.conf.all.rp_filter (exp: 1) [ OK ] - net.ipv4.conf.all.send_redirects (exp: 0) [ DIFFERENT ] - net.ipv4.conf.default.accept_redirects (exp: 0) [ DIFFERENT ] - net.ipv4.conf.default.accept_source_route (exp: 0) [ OK ] - net.ipv4.conf.default.log_martians (exp: 1) [ DIFFERENT ] - net.ipv4.icmp_echo_ignore_broadcasts (exp: 1) [ OK ] - net.ipv4.icmp_ignore_bogus_error_responses (exp: 1) [ OK ] - net.ipv4.tcp_syncookies (exp: 1) [ OK ] - net.ipv4.tcp_timestamps (exp: 0 1) [ OK ] - net.ipv6.conf.all.accept_redirects (exp: 0) [ DIFFERENT ] - net.ipv6.conf.all.accept_source_route (exp: 0) [ OK ] - net.ipv6.conf.default.accept_redirects (exp: 0) [ DIFFERENT ] - net.ipv6.conf.default.accept_source_route (exp: 0) [ OK ] 看看 SSH 这个例子，因为它是一个需要保证安全的关键领域。这里没有什么红色的东西，但是 Lynis 对我的环境给出了很多强化 SSH 服务的建议：\n[+] SSH Support ------------------------------------ - Checking running SSH daemon [ FOUND ] - Searching SSH configuration [ FOUND ] - OpenSSH option: AllowTcpForwarding [ SUGGESTION ] - OpenSSH option: ClientAliveCountMax [ SUGGESTION ] - OpenSSH option: ClientAliveInterval [ OK ] - OpenSSH option: Compression [ SUGGESTION ] - OpenSSH option: FingerprintHash [ OK ] - OpenSSH option: GatewayPorts [ OK ] - OpenSSH option: IgnoreRhosts [ OK ] - OpenSSH option: LoginGraceTime [ OK ] - OpenSSH option: LogLevel [ SUGGESTION ] - OpenSSH option: MaxAuthTries [ SUGGESTION ] - OpenSSH option: MaxSessions [ SUGGESTION ] - OpenSSH option: PermitRootLogin [ SUGGESTION ] - OpenSSH option: PermitUserEnvironment [ OK ] - OpenSSH option: PermitTunnel [ OK ] - OpenSSH option: Port [ SUGGESTION ] - OpenSSH option: PrintLastLog [ OK ] - OpenSSH option: StrictModes [ OK ] - OpenSSH option: TCPKeepAlive [ SUGGESTION ] - OpenSSH option: UseDNS [ SUGGESTION ] - OpenSSH option: X11Forwarding [ SUGGESTION ] - OpenSSH option: AllowAgentForwarding [ SUGGESTION ] - OpenSSH option: UsePrivilegeSeparation [ OK ] - OpenSSH option: AllowUsers [ NOT FOUND ] - OpenSSH option: AllowGroups [ NOT FOUND ] 我的系统上没有运行虚拟机或容器，所以这些显示的结果是空的：\n[+] Virtualization ------------------------------------ [+] Containers ------------------------------------ Lynis 会检查一些从安全角度看很重要的文件的文件权限：\n[+] File Permissions ------------------------------------ - Starting file permissions check File: /boot/grub2/grub.cfg [ SUGGESTION ] File: /etc/cron.deny [ OK ] File: /etc/crontab [ SUGGESTION ] File: /etc/group [ OK ] File: /etc/group- [ OK ] File: /etc/hosts.allow [ OK ] File: /etc/hosts.deny [ OK ] File: /etc/issue [ OK ] File: /etc/issue.net [ OK ] File: /etc/motd [ OK ] File: /etc/passwd [ OK ] File: /etc/passwd- [ OK ] File: /etc/ssh/sshd_config [ OK ] Directory: /root/.ssh [ SUGGESTION ] Directory: /etc/cron.d [ SUGGESTION ] Directory: /etc/cron.daily [ SUGGESTION ] Directory: /etc/cron.hourly [ SUGGESTION ] Directory: /etc/cron.weekly [ SUGGESTION ] Directory: /etc/cron.monthly [ SUGGESTION ] 在报告的底部，Lynis 根据报告的发现提出了建议。每项建议后面都有一个 “TEST-ID”（为了下一部分方便，请将其保存起来）。\nSuggestions (47): ---------------------------- * If not required, consider explicit disabling of core dump in /etc/security/limits.conf file [KRNL-5820] https://cisofy.com/lynis/controls/KRNL-5820/ * Check PAM configuration, add rounds if applicable and expire passwords to encrypt with new values [AUTH-9229] https://cisofy.com/lynis/controls/AUTH-9229/ Lynis 提供了一个选项来查找关于每个建议的更多信息，你可以使用 show details 命令和 TEST-ID 号来访问：\n$ sudo lynis show details TEST-ID 这将显示该测试的其他信息。例如，我检查了 SSH-7408 的详细信息：\n$ sudo lynis show details SSH-7408 2020-04-30 05:52:23 Performing test ID SSH-7408 (Check SSH specific defined options) 2020-04-30 05:52:23 Test: Checking specific defined options in /tmp/lynis.k8JwazmKc6 2020-04-30 05:52:23 Result: added additional options for OpenSSH \u0026lt; 7.5 2020-04-30 05:52:23 Test: Checking AllowTcpForwarding in /tmp/lynis.k8JwazmKc6 2020-04-30 05:52:23 Result: Option AllowTcpForwarding found 2020-04-30 05:52:23 Result: Option AllowTcpForwarding value is YES 2020-04-30 05:52:23 Result: OpenSSH option AllowTcpForwarding is in a weak configuration state and should be fixed 2020-04-30 05:52:23 Suggestion: Consider hardening SSH configuration [test:SSH-7408] [details:AllowTcpForwarding (set YES to NO)] [solution:-] 试试吧 如果你想更多地了解你的 Linux 机器的安全性，请试试 Lynis。如果你想了解 Lynis 是如何工作的，可以研究一下它的 shell 脚本，看看它是如何收集这些信息的。\nHow can I protect against single user mode Potential Attacks\nSingle User Mode\nThis is the easiest way to gain unauthorised access to a Linux system is to boot the server into Single User Mode because it does not, by default, require a root password to gain root level access. Single User Mood can be accessed by power cycling the machine and interrupting the boot process. To boot into single user mode where the GRUB bootloader is used perform the following; interrupt the boot process, press e to edit the boot configuration file, append to the line starting Linux one of either s, S, 1 or systemd. unit=[rescue.target, emergency.target, rescue] to change the argument being passed to the kernel during boot to boot into Single User Mode, then press ctrl+x.\nProtecting Against Single User Mode\nFor a traditional init based system\nAs root edit the file /etc/sysconfig/init then on the line SINGLE=/sbin/sushell change sushell TO sulogin.\nFor a systemd based system\nThe target configuration need to be altered for the root password to be prompted for. The targets are located in /lib/systemd/system the files which need alteration are emergency.service and rescue.service. Alter the line starting ExecStart=-/bin/sh –c “/usr/sbin/sushell; ……” and change the /usr/sbin/sushell to/usr/sbin/sulogin in both emergency.service and rescue.service.\nTo check this has taken affect\nThen save changes and reboot to confirm the alteration has taken affect, if the alteration was success when booting into single user mode it shall ask for the root password.\nRoot Password\nBy default, some Linux distributions do not have root password sets, this can be checked by running the command head -1 /etc/shadow and if the second column, using a colon as a delimiter, is an exclamation mark then no password has been set. If no root password is set, then regardless of if the system is set to prompt for a password for Single User Mode or not it will just load root access.\nSecuring Bootloader\nInsecure bootloaders can result in the bootloader being bypassed completely and a shell being used to gain direct root level access to the system. This is done by interrupting the GRUB boot process and appending init=/bin/bas to the line beginning linux16. This will tell the kernel to use bash instead of init.\nProtecting against bootloader side loading\nThe GRUB bootloader can be password protected by placing the configuration in /etc/grub.d/40_custom file because this file will remain un touched by updates and upgrades to the boot loader. In /etc/grub.d/40_custom add set superusers=”admin” then password admin after that save and exit the file and run the following command grub2-mkpasswd-… (allow tab completion to finish this command so that the system compatible script is run) the output of this command from grub2. Onwards need to be added to the end of the line password admin in /etc/grub.d/40_custom. After that the grub file need to be recompiled by running the command grub2-mkconfig –o /boot/grub2/grub.cfg for centos or update-grub¬ on debian.\nTo check this has taken affect\nThen save changes and reboot to confirm the alteration has taken affect, if the alteration was success when booting and wanting to change the grub setting you will need to supply the username admin and the encrypted password.\nProtecting Against Recovery Attack\nThese measures can aid in protection however, if a disk is used the recover Linux feature on the disk can be used to mount the file system and alter the GRUB setting from the disk. To protect against make any removable media have a lower boot priority than the boot drive and password protect the BIOS and boot option menu to stop someone who hasn’t got access altering the boot order and booting into a disk to make changes to the system.\nCheckInstall 如果你已经从它的源码运行“make install”安装了linux程序。想完整移除它将变得真的很麻烦，除非程序的开发者在Makefile里提供了uninstall的目标设置。否则你必须在安装前后比较你系统里文件的完整列表，然后手工移除所有在安装过程中加入的文件。\n这时候Checkinstall就可以派上使用。Checkinstall会跟踪install命令行所创建或修改的所有文件的路径(例如：“make install”、“make install_modules”等)并建立一个标准的二进制包，让你能用你发行版的标准包管理系统安装或卸载它，请参考其官方文档。\n安装Checkinstall：\n# apt install checkinstall  一旦checkinstall安装好，你就可以用下列格式创建一个特定的软件包\n# checkinstall   如果没有参数，默认安装命令“make install”将被使用。\n在这个例子里，我们将创建一个htop包，这是一个linux交互式文本模式进程查看器（类似 top）。\n首先，让我们从项目的官方网站下载源代码，作为一个好的习惯，我们存储源码包到/usr/local/src下，并解压它。\n# cd /usr/local/src # wget http://hisham.hm/htop/releases/1.0.3/htop-1.0.3.tar.gz # tar xzf htop-1.0.3.tar.gz # cd htop-1.0.3  让我们看看htop的安装命令是什么，以便我们能用Checkinstall命令调用它，如下面所示，htop用“make install”命令安装。\n# ./configure # make install  因此，要创建一个htop安装包，我们可以不带任何参数的调用checkinstall，这将使用“make install”命令创建一个包。在这个过程中， checkinstall命令会问你几个问题。\n简而言之，如下命令会创建一个htop包：\n# ./configure # checkinstall  然后checkinstall将根据你的linux系统是什么，自动地创建一个.rpm或者.deb包。\ngksudo/kdesudo Taken from here:\n You should never use normal sudo to start graphical applications as root. You should use gksudo (kdesudo on Kubuntu) to run such programs. gksudo sets HOME=/root, and copies .Xauthority to a tmp directory. This prevents files in your home directory becoming owned by root.\n Please note that this is primarily about configuration files. If you run Nautilus as root, even with gksu/gksudo, and you create a file or folder anywhere with it (including in your home directory), that file or folder will be owned by root. But if you run Nautilus (or most other graphical applications) as root with sudo, they may save their configuration files in your home directory (rather than root’s home directory). Those configuration files may be owned by root and inaccessible when you’re not running as root, which can severely mess up your settings, and may even keep some applications from working altogether.\nThe solution, once you have made this mistake, is to find the configuration files and delete them or chown them back to belonging your non-root user. Many such files start with a . or are contained in a directory that starts with a .. Some are located inside the .config folder in your home directory. To see files and folders that start with a . in Nautilus, press Ctrl+H (this shows hidden files.) To see them with ls, use the -a (or -A) flag.\nTo find if there are files not owned by you in your home directory, you can use the following command in a terminal:\nfind $HOME -not -user $USER -exec ls -lad {} \\; which will list all files under the home directory not owned by the user.\nman 手册页（man pages），即参考手册页（reference manual pages）的简称，是你进入 Linux 的钥匙。你想知道的一切都在那里，包罗万象。这套文档永远不会赢得普利策奖，但这套文档是相当准确和完整的。手册页是主要信源，其权威性是众所周知的。\n虽然它们是源头，但阅读起来并不是最令人愉快的。有一次，在很久以前的哲学课上，有人告诉我，阅读 亚里士多德 是最无聊的阅读。我不同意：说到枯燥的阅读，亚里士多德远远地排在第二位，仅次于手册页。\n乍一看，这些页面可能看起来并不完整，但是，不管你信不信，手册页并不是为了隐藏信息 —— 只是因为信息量太大，这些页面必须要有结构，而且信息是以尽可能简短的形式给出的。这些解释相当简略，需要一些时间来适应，但一旦你掌握了使用它们的技巧，你就会发现它们实际上是多么有用。\n入门 这些页面是通过一个叫做 man 的工具查看的，使用它的命令相当简单。在最简单的情况下，要使用 man，你要在命令行上输入 man，后面加一个空格和你想查询的命令，比如 ls 或 cp，像这样：\nman ls man 会打开 ls 命令的手册页。\n你可以用方向键上下移动，按 q 退出查看手册页。通常情况下，手册页是用 less 打开的，所以 less 命令的键盘快捷键在 man 中也可以使用。\n例如，你可以用 /search_term 来搜索一个特定的文本，等等。\n有一个关于手册页的介绍，这是一篇值得阅读介绍。它非常详细地说明了手册页是如何布局和组织的。\n要看这个页面，请打开一个终端，然后输入：\nman man 节 在你开始更深入地研究手册页之前，知道手册页有一个固定的页面布局和一个归档方案会有帮助。这可能会让新手感到困惑，因为我可以说：“看手册页中关于 ls 的 NAME 节（section）”，我也可以说：“看第 5 节（section）中的 passwd 的手册页。”\n这个词，“节（section）” 被用于两种不同的方式，但并不总是向新人解释其中的区别。\n我不确定为什么会出现这种混淆，但我在培训新用户和初级系统管理员时看到过几次这种混淆。我认为这可能是隧道视野，专注于一件事会使一个人忘记另一件事。一叶障目，不见泰山。\n对于那些已经知道其中的区别的人，你可以跳过这一小节。这一部分是针对那些刚接触到手册页的人。\n这就是区别：\n对于手册页\n单独的手册页是用来显示信息块的。例如，每个手册页都有一个“NAME”节，显示命令的名称和简短的描述。还会有另一个信息块，称为“SYNOPSIS”，显示该命令是如何使用的，以此类推。\n每个手册页都会有这些，以及其他的标题。这些在各个手册页上的节，或者说标题，有助于保持事情的一致性和信息的分工。\n对于手册\n使用“节”，如 “查看第 5 节中的 passwd 的手册页”，是指整个手册的内容。当我们只看一页时，很容易忽略这一点，但是 passwd 手册页是同一本手册的一部分，该手册还有 ls、rm、date、cal 等的手册页。\n整个 Linux 手册是巨大的；它有成千上万的手册页。其中一些手册页有专门的信息。有些手册页有程序员需要的信息，有些手册页有网络方面的独特信息，还有一些是系统管理员会感兴趣的。\n这些手册页根据其独特的目的被分组。想想看，把整个手册分成几个章节 —— 每章有一个特定的主题。有 9 个左右的章节（非常大的章节）。碰巧的是，这些章节被称为“节”。\n总结一下：\n 手册中单页（我们称之为“手册页”）的节是由标题定义的信息块。 这个大的手册（所有页面的集合）中的章节，刚好被称为“节”。  现在你知道区别了，希望本文的其余部分会更容易理解。\n手册页的节 你将会看到不同的手册页，所以让我们先研究一下各个页面的布局。\n手册页被分成几个标题，它们可能因提供者不同而不同，但会有相似之处。一般的分类如下：\n NAME（名称） SYNOPSIS（概要） DESCRIPTION（描述） EXAMPLES（例子） DIAGNOSTICS（诊断） FILES（文件） LIMITS（限制） PORTABILITY（可移植性） SEE ALSO（另见） HISTORY（历史） WARNING（警告）或BUGS（错误） NOTES（注意事项）  NAME - 在这个标题下是命令的名称和命令的简要描述。\nSYNOPSIS - 显示该命令的使用方法。例如，这里是 cal 命令的概要：\ncal [Month] [Year] 概要以命令的名称开始，后面是选项列表。概要采用命令行的一般形式；它显示了你可以输入的内容和参数的顺序。方括号中的参数（[]）是可选的；你可以不输入这些参数，命令仍然可以正常工作。不在括号内的项目必须使用。\n请注意，方括号只是为了便于阅读。当你输入命令时，不应该输入它们。\nDESCRIPTION - 描述该命令或工具的作用以及如何使用它。这一节通常以对概要的解释开始，并说明如果你省略任何一个可选参数会发生什么。对于长的或复杂的命令，这一节可能会被细分。\nEXAMPLES - 一些手册页提供了如何使用命令或工具的例子。如果有这一节，手册页会尝试给出一些简单的使用例子，以及更复杂的例子来说明如何完成复杂的任务。\nDIAGNOSTICS - 本节列出了由命令或工具返回的状态或错误信息。通常不显示不言自明的错误和状态信息。通常会列出可能难以理解的信息。\nFILES - 本节包含了 UNIX 用来运行这个特定命令的补充文件的列表。这里，“补充文件”是指没有在命令行中指定的文件。例如，如果你在看 passwd 命令的手册，你可能会发现 /etc/passwd 列在这一节中，因为 UNIX 是在这里存储密码信息。\nLIMITS - 本节描述了一个工具的限制。操作系统和硬件的限制通常不会被列出，因为它们不在工具的控制范围内。\nPORTABILITY - 列出其他可以使用该工具的系统，以及该工具的其他版本可能有什么不同。\nSEE ALSO - 列出包含相关信息的相关手册页。\nHISTORY - 提供命令的简要历史，如它第一次出现的时间。\nWARNING - 如果有这个部分，它包含了对用户的重要建议。\nNOTES - 不像警告那样严重，但也是重要的信息。\n同样，并不是所有的手册都使用上面列出的确切标题，但它们足够接近，可以遵循。\n手册的节 整个 Linux 手册集合的手册页传统上被划分为有编号的节：\n第 1 节：Shell 命令和应用程序\n第 2 节：基本内核服务 - 系统调用和错误代码\n第 3 节：为程序员提供的库信息\n第 4 节：网络服务 - 如果安装了 TCP/IP 或 NFS 设备驱动和网络协议\n第 5 节：文件格式 - 例如：显示 tar 存档的样子\n第 6 节：游戏\n第 7 节：杂项文件和文档\n第 8 节：系统管理和维护命令\n第 9 节：不知名的内核规格和接口\n将手册页分成这些组，可以使搜索更有效率。在我工作的地方，我有时会做一些编程工作，所以我花了一点时间看第 3 节的手册页。我也做一些网络方面的工作，所以我也知道要涉足网络部分。作为几个实验性机器的系统管理员，我在第 8 节花了很多时间。\n将手册网归入特定的节（章节），使搜索信息更加容易 —— 无论是对需要搜索的人，还是对进行搜索的机器。\n你可以通过名称旁边的数字来判断哪个手册页属于哪个部分。例如，如果你正在看 ls 的手册页，而页面的最上面写着。 LS(1)，那么你正在浏览第 1 节中的 ls 页面，该节包含关于 shell 命令和应用程序的页面。\n下面是另一个例子。如果你在看 passwd 的手册页，页面的顶部显示: PASSWD(1)，说明你正在阅读第 1 节中描述 passwd 命令如何更改用户账户密码的手册页。如果你看到 PASSWD(5)，那么你正在阅读关于密码文件和它是如何组成的的手册页。\npasswd 恰好是两个不同的东西：一个是命令的名称，一个是文件的名称。同样，第 1 节描述了命令，而第 5 节涉及文件格式。\n括号中的数字是重要的线索 —— 这个数字告诉你正在阅读的页面来自哪一节。\n搜索一个特定的节 基本命令：\nman -a name 将在每一节中搜索由 name 标识的手册页，按数字顺序逐一显示。要把搜索限制在一个特定的部分，请在 man 命令中使用一个参数，像这样：\nman 1 name 这个命令将只在手册页的第 1 节中搜索 name。使用我们前面的 passwd 例子，这意味着我们可以保持搜索的针对性。如果我想阅读 passwd 命令的手册页，我可以在终端输入以下内容：\nman 1 passwd man 工具将只在第 1 节中搜索 passwd 并显示它。它不会在任何其他节中寻找 passwd。\n这个命令的另一种方法是输入: man passwd.1。\n搜索包含某个关键词的所有手册页 如果你想获得包含某个关键词的手册页的列表，man 命令中的 -k 选项（通常称为标志或开关）可以派上用场。例如，如果你想看一个关于 ftp 的手册列表，你可以通过输入以下内容得到这个列表：\nman -k ftp 在接下来的列表中，你可以选择一个特定的手册页来阅读。\n在某些系统上，在 man -k 工作之前，系统管理员需要运行一个叫做 catman 的工具。\n了解手册的各个节 有两个有趣的工具可以帮助你搜索信息：whatis和 whereis。\nwhatis\n有的时候，我们完全可以得到我们需要的信息。我们需要的信息有很大的机会是可以找到的 —— 找到它可能是一个小问题。\n例如，如果我想看关于 passwd 文件的手册页，我在终端上输入：\nman passwd 我就会看到关于 passwd 命令所有信息的手册页，但没有关于 passwd 文件的内容。我知道 passwd 是一个命令，也有一个 passwd 文件，但有时，我可能会忘记这一点。这时我才意识到，文件结构在手册页中的不同节，所以我输入了：\nman 4 passwd 我得到这样的答复：\nNo manual entry for passwd in section 4 See 'man 7 undocumented' for help when manual pages are not available. 又是一次健忘的失误。文件结构在 System V UNIX 页面的第 4 节中。几年前，当我建立文件时，我经常使用 man 4 ...；这仍然是我的一个习惯。那么它在 Linux 手册中的什么地方呢？\n现在是时候调用 whatis 来纠正我了。为了做到这一点，我在我的终端中输入以下内容：\nwhatis passwd 然后我看到以下内容：\npasswd (1) - change user password passwd (1ssl) - compute password hashes passwd (5) - the password file 啊！passwd 文件的页面在第 5 节。现在没问题了，可以访问我想要的信息了：\nman 5 passwd 然后我被带到了有我需要的信息的手册页。\nwhatis 是一个方便的工具，可以用简短的一句话告诉你一个命令的作用。想象一下，你想知道 cal 是做什么的，而不想查看手册页。只要在命令提示符下键入以下内容。\nwhatis cal 你会看到这样的回应：\ncal (1) - displays a calendar and the date of Easter 现在你知道了 whatis 命令，我可以告诉你一个秘密 —— 有一个 man 命令的等价物。为了得到这个，我们使用 -f 开关：man -f ...。\n试试吧。在终端提示下输入 whatis cal。执行后就输入：man -f cal。两个命令的输出将是相同的。\nwhereis\nwhereis 命令的名字就说明了这一点 —— 它告诉你一个程序在文件系统中的位置。它也会告诉你手册页的存放位置。再以 cal 为例，我在提示符下输入以下内容：\nwhereis cal 我将看到这个：\ncal: /usr/bin/cal /usr/share/man/man1/cal.1.gz 仔细看一下这个回答。答案只在一行里，但它告诉我两件事：\n /usr/bin/cal 是 cal 程序所在的地方，以及 /usr/share/man/man1/cal.1.gz 是手册页所在的地方（我也知道手册页是被压缩的，但不用担心 —— man 命令知道如何即时解压）。  whereis 依赖于 PATH 环境变量；它只能告诉你文件在哪里，如果它们在你的 PATH 环境变量中。\n你可能想知道是否有一个与 whereis 相当的 man 命令。没有一个命令可以告诉你可执行文件的位置，但有一个开关可以告诉你手册页的位置。在这个例子中使用 date 命令，如果我们输入：\nwhereis date 在终端提示符下，我们会看到：\ndate: /usr/bin/date /usr/share/man/man1/date.1.gz 我们看到 date 程序在 /usr/bin/ 目录下，其手册页的名称和位置是：/usr/share/man/man1/date.1.gz。\n我们可以让 man 像 whereis 一样行事，最接近的方法是使用 -w 开关。我们不会得到程序的位置，但我们至少可以得到手册页的位置，像这样：\nman -w date 我们将看到这样的返回：\n/usr/share/man/man1/date.1.gz 你知道了 whatis 和 whereis，以及让 man 命令做同样（或接近）事情的方法。我展示了这两种方法，有几个不同的原因。\n多年来，我使用 whatis 和 whereis，因为它们在我的培训手册中。直到最近我才了解到 man -f ... 和 man -w ...。我确信我看了几百次 man 的手册页，但我从未注意到 -f 和 -w 开关。我总是在看手册页的其他东西（例如：man -k ...）。我只专注于我需要找到的东西，而忽略了其他的东西。一旦我找到了我需要的信息，我就会离开这个页面，去完成工作，而不去注意这个命令所提供的其他一些宝贝。\n这没关系，因为这部分就是手册页的作用：帮助你完成工作。\n直到最近我向别人展示如何使用手册页时，我才花时间去阅读 —— “看看还有什么可能” —— 我们才真正注意到关于 man 命令的 -f 和 -w 标记可以做什么的信息。\n不管你使用 Linux 多久了，或者多么有经验，总有一些新东西需要学习。\n手册页会告诉你在完成某项任务时可能需要知道的东西 —— 但它们也有很多内容 —— 足以让你看起来像个魔术师，但前提是你要花时间去读。\n结论 如果你花一些时间和精力在手册页上，你将会取得胜利。你对手册页的熟练程度，将在你掌握 Linux 的过程中发挥巨大作用。\ntldr Collaborative cheatsheets for console commands\n“TLDR” 是流行的互联网行话，意思是“太长不读（to long didn’t read）”。这就是他们创建 tldr 的想法。如果你觉得手册页太长而不想阅读，tldr 通过提供命令的实际例子而将其简化了。\nls ls 命令可以列出一个 POSIX 系统上的文件。这是一个简单的命令，但它经常被低估，不是它能做什么（因为它确实只做了一件事），而是你该如何优化对它的使用。\nGNU 还是 BSD？ 在了解 ls 的隐藏能力之前，你必须确定你正在运行哪个 ls 命令。有两个最流行的版本：包含在 GNU coreutils 包中的 GNU 版本，以及 BSD 版本。如果你正在运行 Linux，那么你很可能已经安装了 GNU 版本的 ls。如果你正在运行 BSD 或 MacOS，那么你有的是 BSD 版本。本文会介绍它们的不同之处。\n你可以使用 --version 选项找出你计算机上的版本：\n$ ls --version 如果它返回有关 GNU coreutils 的信息，那么你拥有的是 GNU 版本。如果它返回一个错误，你可能正在运行的是 BSD 版本（运行 man ls | head 以确定）。\n你还应该调查你的发行版可能具有哪些预设选项。终端命令的自定义通常放在 $HOME/.bashrc 或 $HOME/.bash_aliases 或 $HOME/.profile 中，它们是通过将 ls 别名化为更复杂的 ls 命令来完成的。例如：\nalias ls='ls --color' 发行版提供的预设非常有用，但它们确实很难分辨出哪些是 ls 本身的特性，哪些是它的附加选项提供的。你要是想要运行 ls 命令本身而不是它的别名，你可以用反斜杠“转义”命令：\n$ \\ls 分类 单独运行 ls 会以适合你终端的列数列出文件：\n$ ls ~/example bunko jdk-10.0.2 chapterize otf2ttf.ff despacer overtar.sh estimate.sh pandoc-2.7.1 fop-2.3 safe_yaml games tt 这是有用的信息，但所有这些文件看起来基本相同，没有方便的图标来快速表示出哪个是目录、文本文件或图像等等。\n使用 -F（或 GNU 上的长选项 --classify）以在每个条目之后显示标识文件类型的指示符：\n$ ls ~/example bunko jdk-10.0.2/ chapterize* otf2ttf.ff* despacer* overtar.sh* estimate.sh pandoc@ fop-2.3/ pandoc-2.7.1/ games/ tt* 使用此选项，终端中列出的项目使用简写符号来按文件类型分类：\n 斜杠（/）表示目录（或“文件夹”）。 星号（*）表示可执行文件。这包括二进制文件（编译代码）以及脚本（具有可执行权限的文本文件）。 符号（@）表示符号链接（或“别名”）。 等号（=）表示套接字。 在 BSD 上，百分号（%）表示涂改whiteout（某些文件系统上的文件删除方法）。 在 GNU 上，尖括号（）表示门door（Illumos 和 Solaris上的进程间通信）。 竖线（|）表示 FIFO 管道。 这个选项的一个更简单的版本是 -p，它只区分文件和目录。  （LCTT 译注：在支持彩色的终端上，使用 --color 选项可以以不同的颜色来区分文件类型，但要注意如果将输出导入到管道中，则颜色消失。）\n长列表 从 ls 获取“长列表”的做法是如此常见，以至于许多发行版将 ll 别名为 ls -l。长列表提供了许多重要的文件属性，例如权限、拥有每个文件的用户、文件所属的组、文件大小（以字节为单位）以及文件上次更改的日期：\n$ ls -l -rwxrwx---. 1 seth users 455 Mar 2 2017 estimate.sh -rwxrwxr-x. 1 seth users 662 Apr 29 22:27 factorial -rwxrwx---. 1 seth users 20697793 Jun 29 2018 fop-2.3-bin.tar.gz -rwxrwxr-x. 1 seth users 6210 May 22 10:22 geteltorito -rwxrwx---. 1 seth users 177 Nov 12 2018 html4mutt.sh [...] 如果你不想以字节为单位，请添加 -h 标志（或 GNU 中的 --human）以将文件大小转换为更加人性化的表示方法：\n$ ls --human -rwxrwx---. 1 seth users 455 Mar 2 2017 estimate.sh -rwxrwxr-x. 1 seth seth 662 Apr 29 22:27 factorial -rwxrwx---. 1 seth users 20M Jun 29 2018 fop-2.3-bin.tar.gz -rwxrwxr-x. 1 seth seth 6.1K May 22 10:22 geteltorito -rwxrwx---. 1 seth users 177 Nov 12 2018 html4mutt.sh 要看到更少的信息，你可以带有 -o 选项只显示所有者的列，或带有 -g 选项只显示所属组的列：\n$ ls -o -rwxrwx---. 1 seth 455 Mar 2 2017 estimate.sh -rwxrwxr-x. 1 seth 662 Apr 29 22:27 factorial -rwxrwx---. 1 seth 20M Jun 29 2018 fop-2.3-bin.tar.gz -rwxrwxr-x. 1 seth 6.1K May 22 10:22 geteltorito -rwxrwx---. 1 seth 177 Nov 12 2018 html4mutt.sh 也可以将两个选项组合使用以显示两者。\n时间和日期格式 ls 的长列表格式通常如下所示：\n-rwxrwx---. 1 seth users 455 Mar 2 2017 estimate.sh -rwxrwxr-x. 1 seth users 662 Apr 29 22:27 factorial -rwxrwx---. 1 seth users 20697793 Jun 29 2018 fop-2.3-bin.tar.gz -rwxrwxr-x. 1 seth users 6210 May 22 10:22 geteltorito -rwxrwx---. 1 seth users 177 Nov 12 2018 html4mutt.sh 月份的名字不便于排序，无论是通过计算还是识别（取决于你的大脑是否倾向于喜欢字符串或整数）。你可以使用 --time-style 选项和格式名称更改时间戳的格式。可用格式为：\n full-iso：ISO 完整格式（1970-01-01 21:12:00） long-iso：ISO 长格式（1970-01-01 21:12） iso：iso 格式（01-01 21:12） locale：本地化格式（使用你的区域设置） posix-STYLE：POSIX 风格（用区域设置定义替换 STYLE）  你还可以使用 date 命令的正式表示法创建自定义样式。\n按时间排序 通常，ls 命令按字母顺序排序。你可以使用 -t 选项根据文件的最近更改的时间（最新的文件最先列出）进行排序。\n例如：\n$ touch foo bar baz $ ls bar baz foo $ touch foo $ ls -t foo bar baz 列出方式 ls 的标准输出平衡了可读性和空间效率，但有时你需要按照特定方式排列的文件列表。\n要以逗号分隔文件列表，请使用 -m：\nls -m ~/example bar, baz, foo 要强制每行一个文件，请使用 -1 选项（这是数字 1，而不是小写的 L）：\n$ ls -1 ~/bin/ bar baz foo 要按文件扩展名而不是文件名对条目进行排序，请使用 -X（这是大写 X）：\n$ ls bar.xfc baz.txt foo.asc $ ls -X foo.asc baz.txt bar.xfc 隐藏杂项 在某些 ls 列表中有一些你可能不关心的条目。例如，元字符 . 和 .. 分别代表“本目录”和“父目录”。如果你熟悉在终端中如何切换目录，你可能已经知道每个目录都将自己称为 .，并将其父目录称为 ..，因此当你使用 -a 选项显示隐藏文件时并不需要它经常提醒你。\n要显示几乎所有隐藏文件（. 和 .. 除外），请使用 -A 选项：\n$ ls -a . .. .android .atom .bash_aliases [...] $ ls -A .android .atom .bash_aliases [...] 有许多优秀的 Unix 工具有保存备份文件的传统，它们会在保存文件的名称后附加一些特殊字符作为备份文件。例如，在 Vim 中，备份会以在文件名后附加 ~ 字符的文件名保存。\n这些类型的备份文件已经多次使我免于愚蠢的错误，但是经过多年享受它们提供的安全感后，我觉得不需要用视觉证据来证明它们存在。我相信 Linux 应用程序可以生成备份文件（如果它们声称这样做的话），我很乐意相信它们存在 —— 而不用必须看到它们。\n要隐藏备份文件，请使用 -B 或 --ignore-backups 隐藏常用备份格式（此选项在 BSD 的 ls 中不可用）：\n$ ls bar.xfc baz.txt foo.asc~ foo.asc $ ls -B bar.xfc baz.txt foo.asc 当然，备份文件仍然存在；它只是过滤掉了，你不必看到它。\n除非另有配置，GNU Emacs 在文件名的开头和结尾添加哈希字符（＃）来保存备份文件（#file＃）。其他应用程序可能使用不同的样式。使用什么模式并不重要，因为你可以使用 --hide 选项创建自己的排除项：\n$ ls bar.xfc baz.txt #foo.asc# foo.asc $ ls --hide=\"#*#\" bar.xfc baz.txt foo.asc 递归地列出目录 除非你在指定目录上运行 ls，否则子目录的内容不会与 ls 命令一起列出：\n$ ls -F example/ quux* xyz.txt $ ls -R quux xyz.txt ./example: bar.xfc baz.txt #foo.asc# foo.asc 使用别名使其永久化 ls 命令可能是 shell 会话期间最常使用的命令。这是你的眼睛和耳朵，为你提供上下文信息和确认命令的结果。虽然有很多选项很有用，但 ls 之美的一部分就是简洁：两个字符和回车键，你就知道你到底在哪里以及附近有什么。如果你不得不停下思考（更不用说输入）几个不同的选项，它会变得不那么方便，所以通常情况下，即使最有用的选项也不会用了。\n解决方案是为你的 ls 命令添加别名，以便在使用它时，你可以获得最关心的信息。\n要在 Bash shell 中为命令创建别名，请在主目录中创建名为 .bash_aliases 的文件（必须在开头包含 .）。 在此文件中，列出要创建的别名，然后是要为其创建别名的命令。例如：\nalias ls='ls -A -F -B --human --color' 这一行导致你的 Bash shell 将 ls 命令解释为 ls -A -F -B --human --color。\n你不必仅限于重新定义现有命令，还可以创建自己的别名：\nalias ll='ls -l' alias la='ls -A' alias lh='ls -h' 要使别名起作用，shell 必须知道 .bash_aliases 配置文件存在。在编辑器中打开 .bashrc 文件（如果它不存在则创建它），并包含以下代码块：\nif [ -e $HOME/.bash_aliases ]; then source $HOME/.bash_aliases fi 每次加载 .bashrc（这是一个新的 Bash shell 启动的时候），Bash 会将 .bash_aliases 加载到你的环境中。你可以关闭并重新启动 Bash 会话，或者直接强制它执行此操作：\n$ source ~/.bashrc 如果你忘了你是否有别名命令，which 命令可以告诉你：\n$ which ls alias ls='ls -A -F -B --human --color' /usr/bin/ls 如果你将 ls 命令别名为带有选项的 ls 命令，则可以通过将反斜杠前缀到 ls 前来覆盖你的别名。例如，在示例别名中，使用 -B 选项隐藏备份文件，这意味着无法使用 ls 命令显示备份文件。 可以覆盖该别名以查看备份文件：\n$ ls bar baz foo $ \\ls bar baz baz~ foo 做一件事，把它做好 ls 命令有很多选项，其中许多是特定用途的或高度依赖于你所使用的终端。在 GNU 系统上查看 info ls，或在 GNU 或 BSD 系统上查看 man ls 以了解更多选项。\n你可能会觉得奇怪的是，一个以每个工具“做一件事，把它做好”的前提而闻名的系统会让其最常见的命令背负 50 个选项。但是 ls 只做一件事：它列出文件，而这 50 个选项允许你控制接收列表的方式，ls 的这项工作做得非常、非常好。\nexa A modern replacement for ‘ls’.\ndu (Disk Usage) 在 Linux 中使用 ls 命令 列出的目录内容中，目录的大小仅显示 4KB。这是一个默认的大小，是用来存储磁盘上存储目录的元数据的大小。\ndu 命令 表示 磁盘使用率。这是一个标准的 Unix 程序，用于估计当前工作目录中的文件空间使用情况。\n它使用递归方式总结磁盘使用情况，以获取目录及其子目录的大小。\n$ du -hs --max-depth=0 /path/dir  du – 这是一个命令 -h – 以易读的格式显示大小 (例如 1K 234M 2G) -s – 仅显示每个参数的总数 --max-depth=N – 目录的打印深度  NCurses Disk Usage Ncdu is a disk usage analyzer with an ncurses interface.\nncdu 命令旨在提供一份关于你在硬盘上使用的空间的交互式报告。\ngdu Fast disk usage analyzer with console interface written in Go\nDiff diff是Unix系统的一个很重要的工具程序。\n它用来比较两个文本文件的差异，是代码版本管理的基石之一。你在命令行下，输入：\n$ diff   diff就会告诉你，这两个文件有何差异。它的显示结果不太好懂，下面我就来说明，如何读懂diff。\n三种格式 由于历史原因，diff有三种格式：\n 正常格式（normal diff） 上下文格式（context diff） 合并格式（unified diff）  我们依次来看。\n示例文件 为了便于讲解，先新建两个示例文件。\n第一个文件叫做f1，内容是每行一个a，一共7行。\na a a a a a a 第二个文件叫做f2，修改f1而成，第4行变成b，其他不变。\na a a b a a a 正常格式 现在对f1和f2进行比较：\n$ diff f1 f2 这时，diff就会显示正常格式的结果：\n4c4 b 第一行是一个提示，用来说明变动位置。\n4c4 它分成三个部分：前面的\"4\"，表示f1的第4行有变化；中间的\"c\"表示变动的模式是内容改变（change），其他模式还有\"增加\"（a，代表addition）和\"删除\"（d，代表deletion）；后面的\"4\"，表示变动后变成f2的第4行。\n第二行分成两个部分。\n前面的小于号，表示要从f1当中去除该行（也就是第4行），后面的\"a\"表示该行的内容。\n第三行用来分割f1和f2。\n--- 第四行，类似于第二行。\n b 前面的大于号表示f2增加了该行，后面的\"b\"表示该行的内容。\n最早的Unix（即AT\u0026T版本的Unix），使用的就是这种格式的diff。\n上下文格式 上个世纪80年代初，加州大学伯克利分校推出BSD版本的Unix时，觉得diff的显示结果太简单，最好加入上下文，便于了解发生的变动。因此，推出了上下文格式的diff。\n它的使用方法是加入c参数（代表context）。\n$ diff -c f1 f2 显示结果如下：\n*** f1 2012-08-29 16:45:41.000000000 +0800 --- f2 2012-08-29 16:45:51.000000000 +0800 *************** *** 1,7 **** a a a !a a a a --- 1,7 ---- a a a !b a a a 这个结果分成四个部分。\n第一部分的两行，显示两个文件的基本情况：文件名和时间信息。\n*** f1 2012-08-29 16:45:41.000000000 +0800 --- f2 2012-08-29 16:45:51.000000000 +0800 ***表示变动前的文件，---表示变动后的文件。\n第二部分是15个星号，将文件的基本情况与变动内容分割开。\n*************** 第三部分显示变动前的文件，即f1。\n*** 1,7 **** a a a !a a a a 这时不仅显示发生变化的第4行，还显示第4行的前面三行和后面三行，因此一共显示7行。所以，前面的*** 1,7 ****就表示，从第1行开始连续7行。\n另外，文件内容的每一行最前面，还有一个标记位。如果为空，表示该行无变化；如果是感叹号（!），表示该行有改动；如果是减号（-），表示该行被删除；如果是加号（+），表示该行为新增。\n第四部分显示变动后的文件，即f2。\n--- 1,7 ---- a a a !b a a a 除了变动行（第4行）以外，也是上下文各显示三行，总共显示7行。\n合并格式 如果两个文件相似度很高，那么上下文格式的diff，将显示大量重复的内容，很浪费空间。1990年，GNU diff率先推出了\"合并格式\"的diff，将f1和f2的上下文合并在一起显示。\n它的使用方法是加入u参数（代表unified）。\n$ diff -u f1 f2 显示结果如下：\n--- f1 2012-08-29 16:45:41.000000000 +0800 +++ f2 2012-08-29 16:45:51.000000000 +0800 @@ -1,7 +1,7 @@ a a a -a +b a a a 它的第一部分，也是文件的基本信息。\n--- f1 2012-08-29 16:45:41.000000000 +0800 +++ f2 2012-08-29 16:45:51.000000000 +0800 ---表示变动前的文件，+++表示变动后的文件。\n第二部分，变动的位置用两个@作为起首和结束。\n@@ -1,7 +1,7 @@ 前面的\"-1,7\"分成三个部分：减号表示第一个文件（即f1），“1\"表示第1行，“7\"表示连续7行。合在一起，就表示下面是第一个文件从第1行开始的连续7行。同样的，\"+1,7\"表示变动后，成为第二个文件从第1行开始的连续7行。\n第三部分是变动的具体内容。\na a a -a +b a a a 除了有变动的那些行以外，也是上下文各显示3行。它将两个文件的上下文，合并显示在一起，所以叫做\"合并格式”。每一行最前面的标志位，空表示无变动，减号表示第一个文件删除的行，加号表示第二个文件新增的行。\ngit格式 版本管理系统git，使用的是合并格式diff的变体。\n$ git diff 显示结果如下：\ndiff --git a/f1 b/f1 index 6f8a38c..449b072 100644 --- a/f1 +++ b/f1 @@ -1,7 +1,7 @@ a a a -a +b a a a 第一行表示结果为git格式的diff。\ndiff --git a/f1 b/f1 进行比较的是，a版本的f1（即变动前）和b版本的f1（即变动后）。\n第二行表示两个版本的git哈希值（index区域的6f8a38c对象，与工作目录区域的449b072对象进行比较），最后的六位数字是对象的模式（普通文件，644权限）。　index 6f8a38c..449b072 100644 第三行表示进行比较的两个文件。\n--- a/f1 +++ b/f1 ---表示变动前的版本，+++表示变动后的版本。\n后面的行都与官方的合并格式diff相同。\n@@ -1,7 +1,7 @@ a a a -a +b a a a Crontab 使用 crontab 命令来执行定时任务。所谓定时任务，就是未来的某个或多个时点，预定要执行的任务，比如每五分钟收一次邮件、每天半夜两点分析一下日志等等。\nInstalling $ sudo apt install cronie Running $ systemctl enable crond.service $ systemctl start crond.service 命令详解 crontab 命令通过 /etc/cron.allow 和 /etc/cron.deny 文件来限制某些用户是否可以使用 crontab 命令：\n 当系统中有 /etc/cron.allow 文件时，只有写入此文件的用户可以使用 crontab 命令，没有写入的用户不能使用 crontab 命令。 当系统中只有 /etc/cron.deny 文件时，写入此文件的用户不能使用 crontab 命令，没有写入文件的用户可以使用 crontab 命令。 /etc/cron.allow 文件比 /etc/cron.deny 文件的优先级高，Linux 系统中默认只有 /etc/cron.deny 文件。  crontab 命令的基本格式如下：\ncrontab [选项] [file] 注意，这里的 file 指的是命令文件的名字，表示将 file 作为 crontab 的任务列表文件并载入 crontab，若在命令行中未指定文件名，则此命令将接受标准输入（键盘）上键入的命令，并将它们键入 crontab。\n常用选项    选项 功能     -u user 用来设定某个用户的 crontab 服务，例如 “-u demo” 表示设备 demo 用户的 crontab 服务，此选项一般有 root 用户来运行。   -e 编辑某个用户的 crontab 文件内容。如果不指定用户，则表示编辑当前用户的 crontab 文件。   -l 显示某用户的 crontab 文件内容，如果不指定用户，则表示显示当前用户的 crontab 文件内容。   -r 从 /var/spool/cron 删除某用户的 crontab 文件，如果不指定用户，则默认删除当前用户的 crontab 文件。   -i 在删除用户的 crontab 文件时，给确认提示。    crontab 文件格式 * * * * * 执行的任务 执行的任务字段既可以定时执行系统命令，也可以定时执行某个 Shell 脚本。\n执行时间\n   项目 含义 范围     第一个”*\" 一小时当中的第几分钟（minute） 0~59   第二个\"*\" 一天当中的第几小时（hour） 0~23   第三个\"*\" 一个月当中的第几天（day） 1~31   第四个\"*\" 一年当中的第几个月（month） 1~12   第五个\"*\" 一周当中的星期几（week） 0~7（0和7都代表星期日）    时间特殊符号\n   特殊符号 含义     *（星号） 代表任何时间。比如第一个\"*“就代表一小时种每分钟都执行一次的意思。   ,（逗号） 代表不连续的时间。比如\"0 8，12，16***命令\"就代表在每天的 8 点 0 分、12 点 0 分、16 点 0 分都执行一次命令。   -（中杠） 代表连续的时间范围。比如\"0 5 ** 1-6命令”，代表在周一到周六的凌晨 5 点 0 分执行命令。   /（正斜线） 代表每隔多久执行一次。比如\"*/10****命令\"，代表每隔 10 分钟就执行一次命令。    当“crontab -e”编辑完成之后，一旦保存退出，那么这个定时任务实际就会写入 /var/spool/cron/ 目录中，每个用户的定时任务用自己的用户名进行区分。而且 crontab 命令只要保存就会生效，只要 crond 服务是启动的。\ncrontab举例\n   时间 含义     45 22 ***命令 在每天 22 点 45 分执行命令   0 17 ** 1命令 在每周一的 17 点 0 分执行命令   0 5 1，15**命令 在每月 1 日和 15 日的凌晨 5 点 0 分执行命令   40 4 ** 1-5命令 在每周一到周五的凌晨 4 点 40 分执行命令   */10 4 ***命令 在每天的凌晨 4 点，每隔 10 分钟执行一次命令   0 0 1，15 * 1命令 在每月 1 日和 15 日，每周一 0 点 0 分都会执行命令    注意事项\n 6 个选项都不能为空，必须填写。如果不确定，则使用“*”代表任意时间。 crontab 定时任务的最小有效时间是分钟，最大有效时间是月。像 2018 年某时执行、3 点 30 分 30 秒这样的时间都不能被识别。 在定义时间时，日期和星期最好不要在一条定时任务中出现，因为它们都以天为单位，非常容易让管理员混淆。 在定时任务中，不管是直接写命令，还是在脚本中写命令，最好都使用绝对路径。有时使用相对路径的命令会报错。  run a script on startup Put the script in the appropriate user’s cron table (i. e. the crontab) with a schedule of @reboot.\nA user can edit its cron table with crontab -e.\nAn example which will run /path/to/script.sh at startup:\n@reboot /path/to/script.sh If you need to run it as root, don’t use @reboot sudo /path/to/script.sh; use sudo crontab -eu root to edit root’s crontab.\nps 简介 要对进程进行监测和控制，首先必须要了解当前进程的情况，也就是需要查看当前进程，而 ps 命令（Process Status）就是最基本同时也是非常强大的进程查看命令。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。总之大部分信息都是可以通过执行该命令得到的。ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用top命令。\nlinux上进程有5种状态：\n  就绪状态和运行状态\n就绪状态的状态标志state的值为TASK_RUNNING。此时，程序已被挂入运行队列，处于准备运行状态。一旦获得处理器使用权，即可进入运行状态。\n当进程获得处理器而运行时 ，state的值仍然为TASK_RUNNING，并不发生改变；但Linux会把一个专门用来指向当前运行任务的指针current指向它，以表示它是一个正在运行的进程。\n  可中断等待状态\n状态标志state的值为TASK_INTERRUPTIBL。此时，由于进程未获得它所申请的资源而处在等待状态。一旦资源有效或者有唤醒信号，进程会立即结束等待而进入就绪状态。\n  不可中断等待状态\n状态标志state的值为TASK_UNINTERRUPTIBL。此时，进程也处于等待资源状态。一旦资源有效，进程会立即进入就绪状态。这个等待状态与可中断等待状态的区别在于：处于TASK_UNINTERRUPTIBL状态的进程不能被信号量或者中断所唤醒，只有当它申请的资源有效时才能被唤醒。\n这个状态被应用在内核中某些场景中，比如当进程需要对磁盘进行读写，而此刻正在DMA中进行着数据到内存的拷贝，如果这时进程休眠被打断（比如强制退出信号）那么很可能会出现问题，所以这时进程就会处于不可被打断的状态下。\n  停止状态\n状态标志state的值为TASK_STOPPED。当进程收到一个SIGSTOP信号后，就由运行状态进入停止状态，当受到一个SIGCONT信号时，又会恢复运行状态。这种状态主要用于程序的调试，又被叫做“暂停状态”、“挂起状态”。\n  中止状态\n状态标志state的值为TASK_DEAD。进程因某种原因而中止运行，进程占有的所有资源将被回收，除了task_struct结构（以及少数资源）以外，并且系统对它不再予以理睬，所以这种状态也叫做“僵死状态”，进程成为僵尸进程。\n  ps 标识进程状态对应的 5 种状态码：\n R：就绪状态和运行状态 runnable (on run queue) S：可中断等待状态 sleeping D：不可中断等待状态 uninterruptible sleep (usually IO) T：停止状态 traced or stopped Z：中止状态 a defunct (”zombie”) process  ps 标识进程的其他状态码：\n X：死掉的进程 Dead （应该不会出现） W：内存交互状态Paging （从 2.6 内核开始无效） N：高优先级 ：低优先级 s：包含子进程 L：被锁入内存 l：多线程状态 +：前台进程  命令参数 在不同的 Linux 发行版上，ps 命令的语法各不相同，为此，Linux 采取了一个折中的方法，即融合各种不同的风格，兼顾那些已经习惯了其它系统上使用 ps 命令的用户。ps命令支持三种使用的语法格式：\n UNIX 风格，选项可以组合在一起，并且选项前必须有“-”连字符； BSD 风格，选项可以组合在一起，但是选项前不能有“-”连字符； GNU 风格的选项，选项前有两个“-”连字符；  ps 命令常用的参数：\nps -a 显示所有终端下执行的进程，包含其他用户的进程 ps -A 显示所有进程 ps -e 和-A功能一样 ps -H 显示树状结构，表示程序间的相互关系 ps -f 全格式显示进程 ps a 显示当前终端下执行的进程 ps c 显示进程的真实名称 ps e 列出程序所使用的环境变量 ps f 用ASCII字符显示树状结构，表达程序间的相互关系 ps x 显示所有进程，无论是否运行在终端上 ps u 显示用户相关的进程或者与用户相关的属性 ps r 只显示正在运行的进程 使用实例 大家如果执行 man ps 命令，则会发现 ps 命令的帮助为了适应不同的类 UNIX 系统，可用格式非常多，不方便记忆。所以，我建议大家记忆几个固定选项即可。\nps aux 查看系统中所有的进程\n# ps aux USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND root 1 0.0 0.2 2872 1416 ? Ss Jun04 0:02 /sbin/init root 2 0.0 0.0 0 0 ? S Jun04 0:00 [kthreadd] root 3 0.0 0.0 0 0 ? S Jun04 0:00 [migration/0] root 4 0.0 0.0 0 0 ? S Jun04 0:00 [ksoftirqd/0] …省略部分输出… 输出信息中各列的具体含义：\n   表头 含义     USER 该进程是由哪个用户产生的。   PID 进程的 ID。   %CPU 该进程占用 CPU 资源的百分比，占用的百分比越高，进程越耗费资源。   %MEM 该进程占用物理内存的百分比，占用的百分比越高，进程越耗费资源。   VSZ 该进程占用虚拟内存的大小，单位为 KB。   RSS 该进程占用实际物理内存的大小，单位为 KB。   TTY 该进程是在哪个终端运行的。其中，tty1 ~ tty7 代表本地控制台终端（可以通过 Alt+F1 ~ F7 快捷键切换不同的终端），tty1~tty6 是本地的字符界面终端，tty7 是图形终端。pts/0 ~ 255 代表虚拟终端，一般是远程连接的终端，第一个远程连接占用 pts/0，第二个远程连接占用 pts/1，依次増长。   STAT 进程状态。   START 该进程的启动时间。   TIME 该进程占用 CPU 的运算时间，注意不是系统时间。   COMMAND 产生此进程的命令名。    ps -le 查看系统中所有的进程\nps aux 命令可以看到系统中所有的进程，ps -le 命令也能看到系统中所有的进程。由于 -l 选项的作用，所以 ps -le 命令能够看到更加详细的信息，比如父进程的 PID、优先级等。但是这两个命令的基本作用是一致的，掌握其中一个就足够了。\n# ps -le F S UID PID PPID C PRI Nl ADDR SZ WCHAN TTY TIME CMD 4 S 0 1 0 0 80 0 - 718 - ? 00:00:02 init 1 S 0 2 0 0 80 0 - 0 - ? 00:00:00 kthreadd 1 S 0 3 2 0 -40 - - 0 - ? 00:00:00 migration/0 1 S 0 4 2 0 80 0 - 0 - ? 00:00:00 ksoflirqd/0 1 S 0 5 2 0 -40 - - 0 - ? 00:00:00 migration/0 …省略部分输出… 输出信息中各列的含义：\n   表头 含义     F 进程标志，说明进程的权限，常见的标志有两个: 1：进程可以被复制，但是不能被执行；4：进程使用超级用户权限；   S 进程状态。具体的状态和\"psaux\"命令中的 STAT 状态一致；   UID 运行此进程的用户的 ID；   PID 进程的 ID；   PPID 父进程的 ID；   C 该进程的 CPU 使用率，单位是百分比；   PRI 进程的优先级，数值越小，该进程的优先级越高，越早被 CPU 执行；   NI 进程的优先级，数值越小，该进程越早被执行；   ADDR 该进程在内存的哪个位置；   SZ 该进程占用多大内存；   WCHAN 该进程是否运行。\"-“代表正在运行；   TTY 该进程由哪个终端产生；   TIME 该进程占用 CPU 的运算时间，注意不是系统时间；   CMD 产生此进程的命令名；    ps -l 查看当前 Shell 产生的进程\n# ps -l F S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD 4 S 0 18618 18614 0 80 0 - 1681 - pts/1 00:00:00 bash 4 R 0 18683 18618 4 80 0 - 1619 - pts/1 00:00:00 ps top 简介 top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。\ntop显示系统当前的进程和其他状况，是一个动态显示过程，即可以通过用户按键来不断刷新当前状态。如果在前台执行该命令，它将独占前台，直到用户终止该程序为止。\n比较准确的说，top命令提供了实时的对系统处理器的状态监视。它将显示系统中CPU最“敏感”的任务列表。该命令可以按CPU使用、内存使用和执行时间对任务进行排序；而且该命令的很多特性都可以通过交互式命令或者在个人定制文件中进行设定。\n命令参数 top 命令的基本格式如下：\n#top [选项] 选项：\n -d 秒数：指定 top 命令每隔几秒更新。默认是 3 秒； -b：使用批处理模式输出。一般和”-n\"选项合用，用于把 top 命令重定向到文件中； -n 次数：指定 top 命令执行的次数。一般和\"-b\"选项合用； -p 进程PID：仅查看指定 ID 的进程； -s：使 top 命令在安全模式中运行，避免在交互模式中出现错误； -u 用户名：只监听某个用户的进程；  交互操作指令 在 top 命令的显示窗口中，还可以使用如下按键，进行一下交互操作：\n ? 或 h：显示交互模式的帮助 P：按照 CPU 的使用率排序，默认就是此选项 M：按照内存的使用率排序 N：按照 PID 排序 T：按照 CPU 的累积运算时间排序，也就是按照 TIME+ 项排序 k：按照 PID 给予某个进程一个信号。一般用于中止某个进程，信号 9 是强制中止的信号 r：按照 PID 给某个进程重设优先级（Nice）值 ：立即刷新 s：设置刷新时间间隔 c：显示命令完全模式 t:：显示或隐藏进程和CPU状态信息 m：显示或隐藏内存状态信息 l：显示或隐藏uptime信息 f：增加或减少进程显示标志 S：累计模式，会把已完成或退出的子进程占用的CPU时间累计到父进程的TIME+ u：指定显示用户进程 i：只显示正在运行的进程 W：保存对top的设置到文件 ~/.toprc，下次启动将自动调用toprc文件的设置。 q：退出  使用实例 # top top - 12:26:46 up 1 day, 13:32, 2 users, load average: 0.00, 0.00, 0.00 Tasks: 95 total, 1 running, 94 sleeping, 0 stopped, 0 zombie Cpu(s): 0.1%us, 0.1%sy, 0.0%ni, 99.7%id, 0.1%wa, 0.0%hi, 0.1%si, 0.0%st Mem: 625344k total, 571504k used, 53840k free, 65800k buffers Swap: 524280k total, 0k used, 524280k free, 409280k cached PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 19002 root 20 0 2656 1068 856 R 0.3 0.2 0:01.87 top 1 root 20 0 2872 1416 1200 S 0.0 0.2 0:02.55 init 2 root 20 0 0 0 0 S 0.0 0.0 0:00.03 kthreadd 第一行为任务队列信息\n   内 容 说 明     12:26:46 系统当前时间   up 1 day, 13:32 系统的运行时间.本机己经运行 1 天 13 小时 32 分钟   2 users 当前登录了两个用户   load average: 0.00,0.00，0.00 系统在之前 1 分钟、5 分钟、15 分钟的平均负载。如果 CPU 是单核的，则这个数值超过 1 就是高负载：如果 CPU 是四核的，则这个数值超过 4 就是高负载 （这个平均负载完全是依据个人经验来进行判断的，一般认为不应该超过服务器 CPU 的核数）    第二行为进程信息\n   内 容 说 明     Tasks: 95 total 系统中的进程总数   1 running 正在运行的进程数   94 sleeping 睡眠的进程数   0 stopped 正在停止的进程数   0 zombie 僵尸进程数。如果不是 0，则需要手工检查僵尸进程    第三行为 CPU 信息\n   内 容 说 明     Cpu(s): 0.1 %us 用户模式占用的 CPU 百分比   0.1%sy 系统模式占用的 CPU 百分比   0.0%ni 改变过优先级的用户进程占用的 CPU 百分比   99.7%id 空闲 CPU 占用的 CPU 百分比   0.1%wa 等待输入/输出的进程占用的 CPU 百分比   0.0%hi 硬中断请求服务占用的 CPU 百分比   0.1%si 软中断请求服务占用的 CPU 百分比   0.0%st st（steal time）意为虚拟时间百分比，就是当有虚拟机时，虚拟 CPU 等待实际 CPU 的时间百分比    第四行为物理内存信息\n   内 容 说 明     Mem: 625344k total 物理内存的总量，单位为KB   571504k used 己经使用的物理内存数量   53840k free 空闲的物理内存数量。我们使用的是虚拟机，共分配了 628MB内存，所以只有53MB的空闲内存   65800k buffers/cache 作为缓冲的内存数量    缓冲（buffer）和缓存（cache）的区别：\n 缓存（cache）是在读取硬盘中的数据时，把最常用的数据保存在内存的缓存区中，再次读取该数据时，就不去硬盘中读取了，而在缓存中读取。 缓冲（buffer）是在向硬盘写入数据时，先把数据放入缓冲区,然后再一起向硬盘写入，把分散的写操作集中进行，减少磁盘碎片和硬盘的反复寻道，从而提高系统性能。  简单来说，缓存（cache）是用来加速数据从硬盘中\"读取\"的，而缓冲（buffer）是用来加速数据\"写入\"硬盘的。\n第五行为交换分区（swap）信息\n   内 容 说 明     Swap: 524280k total 交换分区（虚拟内存）的总大小   Ok used 已经使用的交换分区的大小   524280k free 空闲交换分区的大小   409280k cached 作为缓存的交换分区的大小    第六行为系统进程信息\n再来看 top 命令的第二部分输出，主要是系统进程信息，各个字段的含义如下：\n PID：进程的 ID。 USER：该进程所属的用户。 PR：优先级，数值越小优先级越高。 NI：优先级，数值越小、优先级越高。 VIRT：该进程使用的虚拟内存的大小，单位为 KB。 RES：该进程使用的物理内存的大小，单位为 KB。 SHR：共享内存大小，单位为 KB。 S：进程状态。 %CPU：该进程占用 CPU 的百分比。 %MEM：该进程占用内存的百分比。 TIME+：该进程共占用的 CPU 时间。 COMMAND：进程的命令名。  htop htop 是一个 Linux 下的交互式的进程浏览器，可以用来替换Linux下的top命令。\n与Linux传统的top相比，htop更加人性化。它可让用户交互式操作，支持颜色主题，可横向或纵向滚动浏览进程列表，并支持鼠标操作。\nbpytop Linux/OSX/FreeBSD resource monitor\nlsof 简介 lsof 命令，“list opened files”的缩写，直译过来，就是列举系统中已经被打开的文件。通过 lsof 命令，我们就可以根据文件找到对应的进程信息，也可以根据进程信息找到进程打开的文件。\n在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，无论这个文件的本质如何，该文件描述符为应用程序与基础操作系统之间的交互提供了通用接口。因为应用程序打开文件的描述符列表提供了大量关于这个应用程序本身的信息，因此通过lsof工具能够查看这个列表对系统监测以及排错将是很有帮助的。\n在终端下输入lsof即可显示系统打开的文件，因为 lsof 需要访问核心内存和各种文件，所以必须以 root 用户的身份运行它才能够充分地发挥其功能。\n$ sudo lsof | less COMMAND PID TID TASKCMD USER FD TYPE DEVICE SIZE/OFF NODE NAME systemd 1 root cwd DIR 8,2 4096 2 / systemd 1 root rtd DIR 8,2 4096 2 / systemd 1 root txt REG 8,2 1620224 2491035 /usr/lib/systemd/systemd systemd 1 root mem REG 8,2 1369352 2498532 /usr/lib/x86_64-linux-gnu/libm-2.31.so systemd 1 root mem REG 8,2 178528 2490726 /usr/lib/x86_64-linux-gnu/libudev.so.1.6.17 输出各列信息的意义如下：\n  COMMAND：进程的名称\n  PID：进程标识符\n  PPID：父进程标识符（需要指定-R参数）\n  USER：进程所有者\n  PGID：进程所属组\n  FD：文件描述符（filedescriptor，简称 fd），应用程序通过文件描述符识别该文件类型。\n例如 cwd 表示current work dirctory，即应用程序的当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改。txt 表示该类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 /usr/lib/systemd/systemd 程序。\n  TYPE：文件类型，如DIR、REG等，常见的文件类型:\n DIR：目录 REG：普通文件 CHR：字符 BLK：块设备类型 UNIX： UNIX 域套接字 FIFO：先进先出 (FIFO) 队列 IPv4：网际协议 (IP) 套接字    DEVICE：指定磁盘的名称\n  SIZE：文件的大小\n  NODE：索引节点（文件在磁盘上的标识）\n  NAME：打开文件的确切名称\n  命令参数    参数 含义     -a 列出打开文件存在的进程   -c  列出指定进程名所打开的文件   -g 列出GID号进程详情   -d  列出占用该文件号的进程   +d  列出目录下被打开的文件   +D  递归列出目录下被打开的文件   -n  列出使用NFS的文件   -i  列出符合条件的进程   -p  列出指定进程号所打开的文件   -u 列出UID号进程详情   -h 显示帮助信息   -v 显示版本信息    使用实例 查询某个文件被哪个进程调用\n$ lsof /bin/bash 查询某个目录下所有的文件是被哪些进程调用的\n$ lsof +d /usr/lib 查看以httpd开头的进程调用了哪些文件\n$ lsof -c httpd 查询PID是1的进程调用的文件\n$ lsof -p 1 按照用户名查询某个用户的进程调用的文件\n$ lsof -u username 列出某个用户以及某个进程所打开的文件信息\n$ lsof -u test -c mysql 列出所有的网络连接\n$ lsof -i 列出所有tcp 网络连接信息\n$ lsof -i tcp 列出谁在使用某个端口\n$ lsof -i :3306 列出某个用户的所有活跃的网络端口\n$ lsof -a -u test -i 根据文件描述列出对应的文件信息\n$ lsof -d txt 列出被进程号为1234的进程所打开的所有 IPV4 network files\n$ lsof -i 4 -a -p 1234 列出目前连接主机nf5260i5-td上端口为：20，21，80相关的所有文件信息，且每隔3秒重复执行\n$ lsof -i @nf5260i5-td:20,21,80 -r 3 write 在服务器上，有时会有多个用户同时登录，一些必要的沟通就显得尤为重要。比如,我必须关闭某个服务，或者需要重启服务器，当然需要通知同时登录服务器的用户，这时就可以使用 write 命令。\nwrite 命令的信息如下：\n 命令名称：write。 英文原意：send a message to another user。 所在路径：/usr/bin/write。 执行权限：所有用户。 功能描述：向其他用户发送信息。  write 命令的基本格式如下:\n$ write 用户名 [终端号] write 命令没有多余的选项，我们要向在某个终端登录的用户发送信息，就可以这样来执行命令：\n# 向在pts/1 (远程终端1)登录的user1用户发送信息，使用\"Ctrl+D\"快捷键保存发送的数据 $ write user1 pts/1 hello I will be in 5 minutes to restart, please save your data 这时，user1 用户就可以收到你要在 5 分钟之后重启系统的信息了。\nxargs 标准输入与管道命令 Unix 命令都带有参数，有些命令可以接受\"标准输入\"（stdin）作为参数。\n$ cat /etc/passwd | grep root 上面的代码使用了管道命令（|）。管道命令的作用，是将左侧命令（cat /etc/passwd）的标准输出转换为标准输入，提供给右侧命令（grep root）作为参数。\n因为grep命令可以接受标准输入作为参数，所以上面的代码等同于下面的代码。\n$ grep root /etc/passwd 但是，大多数命令都不接受标准输入作为参数，只能直接在命令行输入参数，这导致无法用管道命令传递参数。举例来说，echo命令就不接受管道传参。\n$ echo \"hello world\" | echo 上面的代码不会有输出。因为管道右侧的echo不接受管道传来的标准输入作为参数。\nxargs 命令的作用 xargs命令的作用，是将标准输入转为命令行参数。\n$ echo \"hello world\" | xargs echo hello world 上面的代码将管道左侧的标准输入，转为命令行参数hello world，传给第二个echo命令。\nxargs命令的格式如下。\n$ xargs [-options] [command] 真正执行的命令，紧跟在xargs后面，接受xargs传来的参数。\nxargs的作用在于，大多数命令（比如rm、mkdir、ls）与管道一起使用时，都需要xargs将标准输入转为命令行参数。\n$ echo \"one two three\" | xargs mkdir 上面的代码等同于mkdir one two three。如果不加xargs就会报错，提示mkdir缺少操作参数。\nxargs 的单独使用 xargs后面的命令默认是echo。\n$ xargs # 等同于 $ xargs echo 大多数时候，xargs命令都是跟管道一起使用的。但是，它也可以单独使用。\n输入xargs按下回车以后，命令行就会等待用户输入，作为标准输入。你可以输入任意内容，然后按下Ctrl d，表示输入结束，这时echo命令就会把前面的输入打印出来。\n$ xargs hello (Ctrl + d) hello 再看一个例子。\n$ xargs find -name \"*.txt\" ./foo.txt ./hello.txt 上面的例子输入xargs find -name以后，命令行会等待用户输入所要搜索的文件。用户输入\"*.txt\"，表示搜索当前目录下的所有 TXT 文件，然后按下Ctrl d，表示输入结束。这时就相当执行find -name *.txt。\n-d 参数与分隔符 默认情况下，xargs将换行符和空格作为分隔符，把标准输入分解成一个个命令行参数。\n$ echo \"one two three\" | xargs mkdir 上面代码中，mkdir会新建三个子目录，因为xargs将one two three分解成三个命令行参数，执行mkdir one two three。\n-d参数可以更改分隔符。\n$ echo -e \"a\\tb\\tc\" | xargs -d \"\\t\" echo a b c 上面的命令指定制表符\\t作为分隔符，所以a\\tb\\tc就转换成了三个命令行参数。echo命令的-e参数表示解释转义字符。\n-p 参数，-t 参数 使用xargs命令以后，由于存在转换参数过程，有时需要确认一下到底执行的是什么命令。\n-p参数打印出要执行的命令，询问用户是否要执行。\n$ echo 'one two three' | xargs -p touch touch one two three ?... 上面的命令执行以后，会打印出最终要执行的命令，让用户确认。用户输入y以后（大小写皆可），才会真正执行。\n-t参数则是打印出最终要执行的命令，然后直接执行，不需要用户确认。\n$ echo 'one two three' | xargs -t rm rm one two three -0 参数与 find 命令 由于xargs默认将空格作为分隔符，所以不太适合处理文件名，因为文件名可能包含空格。\nfind命令有一个特别的参数-print0，指定输出的文件列表以null分隔。然后，xargs命令的-0参数表示用null当作分隔符。\n$ find /path -type f -print0 | xargs -0 rm 上面命令删除/path路径下的所有文件。由于分隔符是null，所以处理包含空格的文件名，也不会报错。\n还有一个原因，使得xargs特别适合find命令。有些命令（比如rm）一旦参数过多会报错\"参数列表过长\"，而无法执行，改用xargs就没有这个问题，因为它对每个参数执行一次命令。\n$ find . -name \"*.txt\" | xargs grep \"abc\" 上面命令找出所有 TXT 文件以后，对每个文件搜索一次是否包含字符串abc。\n-L 参数 如果标准输入包含多行，-L参数指定多少行作为一个命令行参数。\n$ xargs find -name \"*.txt\" \"*.md\" find: paths must precede expression: `*.md' 上面命令同时将\"*.txt\"和*.md两行作为命令行参数，传给find命令导致报错。\n使用-L参数，指定每行作为一个命令行参数，就不会报错。\n$ xargs -L 1 find -name \"*.txt\" ./foo.txt ./hello.txt \"*.md\" ./README.md 上面命令指定了每一行（-L 1）作为命令行参数，分别运行一次命令（find -name）。\n下面是另一个例子。\n$ echo -e \"a\\nb\\nc\" | xargs -L 1 echo a b c 上面代码指定每行运行一次echo命令，所以echo命令执行了三次，输出了三行。\n-n 参数 -L参数虽然解决了多行的问题，但是有时用户会在同一行输入多项。\n$ xargs find -name \"*.txt\" \"*.md\" find: paths must precede expression: `*.md' 上面的命令将同一行的两项作为命令行参数，导致报错。\n-n参数指定每次将多少项，作为命令行参数。\n$ xargs -n 1 find -name 上面命令指定将每一项（-n 1）标准输入作为命令行参数，分别执行一次命令（find -name）。\n下面是另一个例子。\n$ echo {0..9} | xargs -n 2 echo 0 12 34 56 78 9 上面命令指定，每两个参数运行一次echo命令。所以，10个阿拉伯数字运行了五次echo命令，输出了五行。\n-I 参数 如果xargs要将命令行参数传给多个命令，可以使用-I参数。\n-I指定每一项命令行参数的替代字符串。\n$ cat foo.txt one two three $ cat foo.txt | xargs -I file sh -c 'echo file; mkdir file' one two three $ ls one two three 上面代码中，foo.txt是一个三行的文本文件。我们希望对每一项命令行参数，执行两个命令（echo和mkdir），使用-I file表示file是命令行参数的替代字符串。执行命令时，具体的参数会替代掉echo file; mkdir file里面的两个file。\n–max-procs 参数 xargs默认只用一个进程执行命令。如果命令要执行多次，必须等上一次执行完，才能执行下一次。\n--max-procs参数指定同时用多少个进程并行执行命令。--max-procs 2表示同时最多使用两个进程，--max-procs 0表示不限制进程数。\n$ docker ps -q | xargs -n 1 --max-procs 0 docker kill 上面命令表示，同时关闭尽可能多的 Docker 容器，这样运行速度会快很多。\nawk awk是处理文本文件的一个应用程序，几乎所有 Linux 系统都自带这个程序。\n它依次处理文件的每一行，并读取里面的每一个字段。对于日志、CSV 那样的每行格式相同的文本文件，awk可能是最方便的工具。\nawk其实不仅仅是工具软件，还是一种编程语言。不过，本文只介绍它的命令行用法，对于大多数场合，应该足够用了。\n基本用法 awk的基本用法就是下面的形式。\n# 格式 $ awk 动作 文件名 # 示例 $ awk '{print $0}' demo.txt 上面示例中，demo.txt是awk所要处理的文本文件。前面单引号内部有一个大括号，里面就是每一行的处理动作print $0。其中，print是打印命令，$0代表当前行，因此上面命令的执行结果，就是把每一行原样打印出来。\n下面，我们先用标准输入（stdin）演示上面这个例子。\n$ echo 'this is a test' | awk '{print $0}' this is a test 上面代码中，print $0就是把标准输入this is a test，重新打印了一遍。\nawk会根据空格和制表符，将每一行分成若干字段，依次用$1、$2、$3代表第一个字段、第二个字段、第三个字段等等。\n$ echo 'this is a test' | awk '{print $3}' a 上面代码中，$3代表this is a test的第三个字段a。\n下面，为了便于举例，我们把/etc/passwd文件保存成demo.txt。\nroot❌0:0:root:/root:/usr/bin/zsh daemon❌1:1:daemon:/usr/sbin:/usr/sbin/nologin bin❌2:2:bin:/bin:/usr/sbin/nologin sys❌3:3:sys:/dev:/usr/sbin/nologin sync❌4:65534:sync:/bin:/bin/sync 这个文件的字段分隔符是冒号（:），所以要用-F参数指定分隔符为冒号。然后，才能提取到它的第一个字段。\n$ awk -F ':' '{ print $1 }' demo.txt root daemon bin sys sync 变量 除了$ + 数字表示某个字段，awk还提供其他一些变量。\n变量NF表示当前行有多少个字段，因此$NF就代表最后一个字段。\n$ echo 'this is a test' | awk '{print $NF}' test $(NF-1)代表倒数第二个字段。\n$ awk -F ':' '{print $1, $(NF-1)}' demo.txt root /root daemon /usr/sbin bin /bin sys /dev sync /bin 上面代码中，print命令里面的逗号，表示输出的时候，两个部分之间使用空格分隔。\n变量NR表示当前处理的是第几行。\n$ awk -F ':' '{print NR \") \" $1}' demo.txt 1) root 2) daemon 3) bin 4) sys 5) sync 上面代码中，print命令里面，如果原样输出字符，要放在双引号里面。\nawk的其他内置变量如下。\n FILENAME：当前文件名 FS：字段分隔符，默认是空格和制表符。 RS：行分隔符，用于分割每一行，默认是换行符。 OFS：输出字段的分隔符，用于打印时分隔字段，默认为空格。 ORS：输出记录的分隔符，用于打印时分隔记录，默认为换行符。 OFMT：数字输出的格式，默认为％.6g。  函数 awk还提供了一些内置函数，方便对原始数据的处理。\n函数toupper()用于将字符转为大写。\n$ awk -F ':' '{ print toupper($1) }' demo.txt ROOT DAEMON BIN SYS SYNC 上面代码中，第一个字段输出时都变成了大写。\n其他常用函数如下。\n tolower()：字符转为小写。 length()：返回字符串长度。 substr()：返回子字符串。 sin()：正弦。 cos()：余弦。 sqrt()：平方根。 rand()：随机数。  awk内置函数的完整列表，可以查看手册。\n条件 awk允许指定输出条件，只输出符合条件的行。\n输出条件要写在动作的前面。\n$ awk '条件 动作' 文件名 请看下面的例子。\n$ awk -F ':' '/usr/ {print $1}' demo.txt root daemon bin sys 上面代码中，print命令前面是一个正则表达式，只输出包含usr的行。\n下面的例子只输出奇数行，以及输出第三行以后的行。\n# 输出奇数行 $ awk -F ':' 'NR % 2 == 1 {print $1}' demo.txt root bin sync # 输出第三行以后的行 $ awk -F ':' 'NR 3 {print $1}' demo.txt sys sync 下面的例子输出第一个字段等于指定值的行。\n$ awk -F ':' '$1 == \"root\" {print $1}' demo.txt root $ awk -F ':' '$1 == \"root\" || $1 == \"bin\" {print $1}' demo.txt root bin if 语句 awk提供了if结构，用于编写复杂的条件。\n$ awk -F ':' '{if ($1  \"m\") print $1}' demo.txt root sys sync 上面代码输出第一个字段的第一个字符大于m的行。\nif结构还可以指定else部分。\n$ awk -F ':' '{if ($1  \"m\") print $1; else print \"---\"}' demo.txt root --- --- sys sync find find 命令由 POSIX 规范 定义，它创建了一个用于衡量 POSIX 系统的开放标准，这包括 Linux、BSD 和 macOS。简而言之，只要你运行的是 Linux、BSD 或 macOS，那么 find 已经安装了。\n但是，并非所有的 find 命令都完全相同。例如，GNU 的 find 命令有一些 BSD、Busybox 或 Solaris 上 find 命令可能没有或有但实现方式不同的功能。本文使用 findutils 包中的 GNU find，因为它很容易获得且非常流行。本文演示的大多数命令都适用于 find 的其他实现，但是如果你在 Linux 以外的平台上尝试命令并得到非预期结果，尝试下载并安装 GNU 版本。\nman文档中给出的find命令的一般形式为：\nfind [-H] [-L] [-P] [-D debugopts] [-Olevel] [path...] [expression] 其实[-H] [-L] [-P] [-D debugopts] [-Olevel]这几个选项并不常用（至少在我的日常工作中，没有用到过），上面的find命令的常用形式可以简化为：\nfind [path...] [expression]   path：find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录\n  expression：expression可以分为——“-options [-print -exec -ok …]”\n   -options，指定find命令的常用选项 -print，find命令将匹配的文件输出到标准输出 -exec，find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为'command' { } \\;，注意{ }和\\；之间的空格 find ./ -size 0 -exec rm {} \\; 删除文件大小为零的文件 （还可以以这样做：rm -i find ./ -size 0 或 find ./ -size 0 | xargs rm -f \u0026）  为了用ls -l命令列出所匹配到的文件，可以把ls -l命令放在find命令的-exec选项中：find . -type f -exec ls -l { } \\; 在/logs目录中查找更改时间在5日以前的文件并删除它们：find /logs -type f -mtime +5 -exec rm { } \\; -ok，和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。 find . -name \"*.conf\" -mtime +5 -ok rm { } \\; 在当前目录中查找所有文件名以.LOG结尾、更改时间在5日以上的文件，并删除它们，只不过在删除之前先给出提示    也有人这样总结find命令的结构：\nfind start_directory options criteria_to_match action_to_perform_on_results 常用选项  -name  按照文件名查找文件。 find /dir -name filename  在/dir目录及其子目录下面查找名字为filename的文件 find . -name \"*.c\" 在当前目录及其子目录（用“.”表示）中查找任何扩展名为“c”的文件 -perm 按照文件权限来查找文件。 find . -perm 755 –print 在当前目录下查找文件权限位为755的文件，即文件属主可以读、写、执行，其它用户可以读、执行的文件 -prune  使用这一选项可以使find命令不在当前指定的目录中查找，如果同时使用-depth选项，那么-prune将被find命令忽略。 find /apps -path \"/apps/bin\" -prune -o –print 在/apps目录下查找文件，但不希望在/apps/bin目录下查找 find /usr/sam -path \"/usr/sam/dir1\" -prune -o –print 在/usr/sam目录下查找不在dir1子目录之内的所有文件 -user  按照文件属主来查找文件。 find ~ -user sam –print 在$HOME目录中查找文件属主为sam的文件 -group  按照文件所属的组来查找文件。 find /apps -group gem –print 在/apps目录下查找属于gem用户组的文件 -mtime -n +n  按照文件的更改时间来查找文件， - n表示文件更改时间距现在n天以内，+ n表示文件更改时间距现在n天以前。 find / -mtime -5 –print 在系统根目录下查找更改时间在5日以内的文件 find /var/adm -mtime +3 –print 在/var/adm目录下查找更改时间在3日以前的文件 -nogroup  查找无有效所属组的文件，即该文件所属的组在/etc/groups中不存在。 find / –nogroup -print -nouser  查找无有效属主的文件，即该文件的属主在/etc/passwd中不存在。 find /home -nouser –print -newer file1 ! file2  查找更改时间比文件file1新但比文件file2旧的文件。 -type  查找某一类型的文件，诸如： b - 块设备文件。 d - 目录。 c - 字符设备文件。 p - 管道文件。 l - 符号链接文件。 f - 普通文件。 find /etc -type d –print 在/etc目录下查找所有的目录 find . ! -type d –print 在当前目录下查找除目录以外的所有类型的文件 find /etc -type l –print 在/etc目录下查找所有的符号链接文件 -size n：[c] 查找文件长度为n块的文件，带有c时表示文件长度以字节计。 find . -size +1000000c –print 在当前目录下查找文件长度大于1 M字节的文件 find /home/apache -size 100c –print 在/home/apache目录下查找文件长度恰好为100字节的文件 find . -size +10 –print 在当前目录下查找长度超过10块的文件（一块等于512字节） -depth：在查找文件时，首先查找当前目录中的文件，然后再在其子目录中查找。 find / -name \"CON.FILE\" -depth –print 它将首先匹配所有的文件然后再进入子目录中查找 -mount：在查找文件时不跨越文件系统mount点。 find . -name \"*.XC\" -mount –print 从当前目录开始查找位于本文件系统中文件名以XC结尾的文件（不进入其它文件系统） -follow：如果find命令遇到符号链接文件，就跟踪至链接所指向的文件。  按名称查找文件 你可以借助正则表达式使用完整或部分的文件名来定位文件。find 命令需要你给出想搜索的目录；指定搜索属性选项，例如，-name 用于指定区分大小写的文件名；然后是搜索字符串。默认情况下，搜索字符串按字面意思处理：除非你使用正则表达式语法，否则 find 命令搜索的文件名正是你在引号之间输入的字符串。\n假设你的 Documents 目录包含四个文件：Foo、foo、foobar.txt 和 foo.xml。以下是对 foo 的字面搜索：\n$ find ~ -name \"foo\" /home/tux/Documents/examples/foo 你可以使用 -iname 选项使其不区分大小写来扩大搜索范围：\n$ find ~ -iname \"foo\" /home/tux/Documents/examples/foo /home/tux/Documents/examples/Foo 通配符 你可以使用基本的 shell 通配符来扩展搜索。例如，* 表示任意数量的字符：\n$ find ~ -iname \"foo*\" /home/tux/Documents/examples/foo /home/tux/Documents/examples/Foo /home/tux/Documents/examples/foo.xml /home/tux/Documents/examples/foobar.txt ? 表示单个字符：\n$ find ~ -iname \"foo*.???\" /home/tux/Documents/examples/foo.xml /home/tux/Documents/examples/foobar.txt 这不是正则表达式语法，因此 . 在示例中只表示字母“点”。\n正则表达式 你还可以使用正则表达式。与 -iname 和 -name 一样，也有区分大小写和不区分大小写的选项。但不一样的是，-regex 和 -iregex 搜索应用于整个路径，而不仅仅是文件名。这意味着，如果你搜索 foo，你不会得到任何结果，因为 foo 与 /home/tux/Documents/foo 不匹配。相反，你必须要么搜索整个路径，要么在字符串的开头使用通配符：\n$ find ~ -iregex \".*foo\" /home/tux/Documents/examples/foo /home/tux/Documents/examples/Foo 查找近一周修改过的文件 要查找近一周修改的文件，使用 -mtime 选项以及过去的天数（负数）：\n$ find ~ -mtime -7 /home/tux/Documents/examples/foo /home/tux/Documents/examples/Foo /home/tux/Documents/examples/foo.xml /home/tux/Documents/examples/foobar.txt 查找近几天修改的文件 你可以结合使用 -mtime 选项来查找近几天范围内修改的文件。对于第一个 -mtime 参数，表示上一次修改文件的最近天数。第二个参数表示最大天数。例如，搜索修改时间超过 1 天但不超过 7 天的文件：\n$ find ~ -mtime +1 -mtime -7 按文件类型限制搜索 指定查找文件的类型来优化 find 的结果是很常见的。如果你不确定要查找的内容，则不应该使用此选项。但如果你知道要查找的是文件而不是目录，或者是目录而不是文件，那么这可能是一个很好的过滤器。选项是 -type，它的参数是代表不同类型数据的字母代码。最常见的是：\n d - 目录 f - 文件 l - 链接文件 s - 套接字 p - 命名管道（用于 FIFO） b - 块设备（通常是硬盘）  下面是一些例子：\n$ find ~ -type d -name \"Doc*\" /home/tux/Documents $ find ~ -type f -name \"Doc*\" /home/tux/Downloads/10th-Doctor.gif $ find /dev -type b -name \"sda*\" /dev/sda/dev/sda1 调整范围 find 命令默认是递归的，这意味着它会在指定的目录中层层搜索结果。这在大型文件系统中可能会变得不堪重负，但你可以使用 -maxdepth 选项来控制搜索深度：\n$ find /usr -iname \"*xml\" | wc -l 15588 $ find /usr -maxdepth 2 -iname \"*xml\" | wc -l 15 也可以使用 -mindepth 设置最小递归深度：\n$ find /usr -mindepth 8 -iname \"*xml\" | wc -l 9255 与 xargs 在使用find命令的-exec选项处理匹配到的文件时， find命令将所有匹配到的文件一起传递给exec执行。但有些系统对能够传递给exec的命令长度有限制，这样在find命令运行几分钟之后，就会出现溢出错误。错误信息通常是“参数列太长”或“参数列溢出”。这就是xargs命令的用处所在，特别是与find命令一起使用。\nfind命令把匹配到的文件传递给xargs命令，而xargs命令每次只获取一部分文件而不是全部，不像-exec选项那样。这样它可以先处理最先获取的一部分文件，然后是下一批，并如此继续下去。\n在有些系统中，使用-exec选项会为处理每一个匹配到的文件而发起一个相应的进程，并非将匹配到的文件全部作为参数一次执行；这样在有些情况下就会出现进程过多，系统性能下降的问题，因而效率不高；\n而使用xargs命令则只有一个进程。另外，在使用xargs命令时，究竟是一次获取所有的参数，还是分批取得参数，以及每一次获取参数的数目都会根据该命令的选项及系统内核中相应的可调参数来确定。\n来看看xargs命令是如何同find命令一起使用的，并给出一些例子。\nfind . -type f -print | xargs file 查找系统中的每一个普通文件，然后使用xargs命令来测试它们分别属于哪类文件\nfind / -name \"core\" -print | xargs echo \"\" /tmp/core.log 在整个系统中查找内存信息转储文件(core dump) ，然后把结果保存到/tmp/core.log 文件中：\nfind . -type f -print | xargs grep \"hostname\" 用grep命令在所有的普通文件中搜索hostname这个词\nfind ./ -mtime +3 -print|xargs rm -f –r 删除3天以前的所有东西 （find . -ctime +3 -exec rm -rf {} \\;）\nfind ./ -size 0 | xargs rm -f \u0026 删除文件大小为零的文件\nfind命令配合使用exec和xargs可以使用户对所匹配到的文件执行几乎所有的命令。\nfd fd 命令是一个流行的、用户友好的 find 命令的替代品。\ngrep grep (global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来)是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。\ngrep 这个名字，来源于一个 Unix/Linux 中的古老的行编辑器 ed 中执行相似操作的命令：\ng/re/p 语法如下所示:\ngrep [OPTIONS] PATTERN [FILE...] grep [OPTIONS] [-e PATTERN | -f FILE] [FILE...] grep命令用于搜索由Pattern参数指定的模式，并将每个匹配的行写入标准输出中。这些模式是具有限定的正则表达式，它们使用ed或egrep命令样式。\n如果在File参数中指定了多个名称，grep命令将显示包含匹配行的文件的名称。\n对 shell 有特殊含义的字符 ($, *, [, |, ^, (, ), \\ ) 出现在 Pattern参数中时必须带双引号。如果 Pattern参数不是简单字符串，通常必须用单引号将整个模式括起来。在诸如 [a-z], 之类的表达式中，-（减号）cml 可根据当前正在整理的序列来指定一个范围。整理序列可以定义等价的类以供在字符范围中使用。\n如果未指定任何文件，grep会假定为标准输入。\n基本集 grep正则表达式元字符集：\n ^ 锚定行的开始 如：'^grep'匹配所有以grep开头的行。 $ 锚定行的结束 如：'grep$'匹配所有以grep结尾的行。 . 匹配一个非换行符的字符 如：'gr.p'匹配gr后接一个任意字符，然后是p。 * 匹配零个或多个先前字符 如：' *grep'匹配所有一个或多个空格后紧跟grep的行。 .*一起用代表任意字符。 [] 匹配一个指定范围内的字符，如'[Gg]rep'匹配Grep和grep。 [^]  匹配一个不在指定范围内的字符，如：'[^A-FH-Z]rep'匹配不包含A-F和H-Z的一个字母开头，紧跟rep的行。 \\(..\\) 标记匹配字符，如：'\\(love\\)'，love被标记为1。 \\ 锚定单词的开始，如：'\\ \\ 锚定单词的结束，如grep\\'匹配包含以grep结尾的单词的行。 x\\{m\\} 连续重复字符x，m次，如：'o\\{5\\}'匹配包含连续5个o的行。 x\\{m,\\} 连续重复字符x,至少m次，如：'o\\{5,\\}'匹配至少连续有5个o的行。 x\\{m,n\\} 连续重复字符x，至少m次，不多于n次，如：'o\\{5,10\\}'匹配连续5–10个o的行。 \\w 匹配一个文字和数字字符，也就是[A-Za-z0-9]，如：'G\\w*p'匹配以G后跟零个或多个文字或数字字符，然后是p。 \\W  w的反置形式，匹配一个非单词字符，如点号句号等。\\W*则可匹配多个。 \\b 单词锁定符，如: '\\bgrep\\b'只匹配grep，即只能是grep这个单词，两边均为空格。  常用选项 -? 同时显示匹配行上下的？行，如：grep -2 pattern filename同时显示匹配行的上下2行。\n-b，--byte-offset 打印匹配行前面打印该行所在的块号码。\n-c,--count 只打印匹配的行数，不显示匹配的内容。\n-f File，--file=File 从文件中提取模板。空文件中包含0个模板，所以什么都不匹配。\n-h，--no-filename 当搜索多个文件时，不显示匹配文件名前缀。\n-i，--ignore-case 忽略大小写差别。\n-q，--quiet 取消显示，只返回退出状态。0则表示找到了匹配的行。\n-l，--files-with-matches 打印匹配模板的文件清单。\n-L，--files-without-match 打印不匹配模板的文件清单。\n-n，--line-number 在匹配的行前面打印行号。\n-s，--silent 不显示关于不存在或者无法读取文件的错误信息。\n-v，--revert-match 反检索，只显示不匹配的行。\n-w，--word-regexp 如果被\\引用，就把表达式做为一个单词搜索。\n-V，--version 显示软件版本信息。\n怎么样使用 grep 来搜索一个文件 搜索 /etc/passwd 文件下的 boo 用户,输入:\n$ grep boo /etc/passwd 输出内容:\nfoo❌1000:1000:foo,,,:/home/foo:/bin/ksh 可以使用 grep 去强制忽略大小写。例如，使用 -i 选项可以匹配 boo, Boo, BOO 和其他组合：\n$ grep -i \"boo\" /etc/passwd 递归使用 grep 你可以递归地使用 grep 进行搜索。例如，在文件目录下面搜索所有包含字符串“192.168.1.5”的文件\n$ grep -r \"192.168.1.5\" /etc/ 或者是：\n$ grep -R \"192.168.1.5\" /etc/ 示例输出:\n/etc/ppp/options:# ms-wins 192.168.1.50/etc/ppp/options:# ms-wins 192.168.1.51/etc/NetworkManager/system-connections/Wired connection 1:addresses1=192.168.1.5;24;192.168.1.2; 你会看到搜索到 192.168.1.5 的结果每一行都前缀以找到匹配的文件名（例如：/etc/ppp/options）。输出之中包含的文件名可以加 -h 选项来禁止输出：\n$ grep -h -R \"192.168.1.5\" /etc/ 或者\n$ grep -hR \"192.168.1.5\" /etc/ 示例输出:\n# ms-wins 192.168.1.50# ms-wins 192.168.1.51addresses1=192.168.1.5;24;192.168.1.2; 使用 grep 去搜索文本 当你搜索 boo 时，grep 命令将会匹配 fooboo，boo123, barfoo35 和其他所有包含 boo 的字符串，你可以使用 -w 选项去强制只输出那些仅仅包含那个整个单词的行（LCTT译注：即该字符串两侧是英文单词分隔符，如空格，标点符号，和末端等，因此对中文这种没有断字符号的语言并不适用。）。\n$ grep -w \"boo\" file 使用 grep 命令去搜索两个不同的单词 使用 egrep 命令如下:\n$ egrep -w 'word1|word2' /path/to/file （LCTT 译注：这里使用到了正则表达式，因此使用的是 egrep 命令，即扩展的 grep 命令。）\n统计文本匹配到的行数 grep 命令可以通过加 -c 参数显示每个文件中匹配到的次数：\n$ grep -c 'word' /path/to/file 传递 -n 选项可以输出的行前加入匹配到的行的行号：\n$ grep -n 'root' /etc/passwd 示例输出:\n1:root:x:0:0:root:/root:/bin/bash1042:rootdoor:x:0:0:rootdoor:/home/rootdoor:/bin/csh3319:initrootapp:x:0:0:initrootapp:/home/initroot:/bin/ksh 反转匹配（不匹配） 可以使用 -v 选项来输出不包含匹配项的内容，输出内容仅仅包含那些不含给定单词的行，例如输出所有不包含 bar 单词的行：\n$ grep -v bar /path/to/file UNIX/Linux 管道与 grep 命令 grep 常常与管道一起使用，在这个例子中，显示硬盘设备的名字：\n# dmesg | egrep '(s|h)d[a-z]' 显示 CPU 型号：\n# cat /proc/cpuinfo | grep -i 'Model' 然而，以上命令也可以按照以下方法使用，不使用管道:\n# grep -i 'Model' /proc/cpuinfo 示例输出:\nmodel : 30model name : Intel(R) Core(TM) i7 CPU Q 820 @ 1.73GHzmodel : 30model name : Intel(R) Core(TM) i7 CPU Q 820 @ 1.73GHz 如何仅仅显示匹配到内容的文件名字? 使用 -l 选项去显示那些文件内容中包含 main() 的文件名：\n$ grep -l 'main' *.c 最后，你可以强制 grep 以彩色输出：\n$ grep --color vivek /etc/passwd 查找文件内容 从根目录开始查找所有扩展名为 .log 的文本文件，并找出包含 “ERROR” 的行：\n$ find / -type f -name \"*.log\" | xargs grep \"ERROR\" 例子：从当前目录开始查找所有扩展名为 .in 的文本文件，并找出包含 “thermcontact” 的行：\n$ find . -name \"*.in\" | xargs grep \"thermcontact\" cat bat A cat(1) clone with wings.\n添加了语法高亮和 Git 集成等功能，并且还提供了分页选项。\nip linux的ip命令和ifconfig类似，但前者功能更强大，并旨在取代后者。使用ip命令，只需一个命令，你就能很轻松地执行一些网络管理任务。ifconfig是net-tools中已被废弃使用的一个命令，许多年前就已经没有维护了。iproute2套件里提供了许多增强功能的命令，ip命令即是其中之一。\n设置和删除Ip地址 要给你的机器设置一个IP地址，可以使用下列ip命令：\n$ sudo ip addr add 192.168.0.193/24 dev wlan0 请注意IP地址要有一个后缀，比如/24。这种用法用于在无类域内路由选择（CIDR）中来显示所用的子网掩码。在这个例子中，子网掩码是255.255.255.0。\n在你按照上述方式设置好IP地址后，需要查看是否已经生效。\n$ ip addr show wlan0 你也可以使用相同的方式来删除IP地址，只需用del代替add。\n$ sudo ip addr del 192.168.0.193/24 dev wlan0 列出路由表条目 ip命令的路由对象的参数还可以帮助你查看网络中的路由数据，并设置你的路由表。第一个条目是默认的路由条目，你可以随意改动它。\n在这个例子中，有几个路由条目。这个结果显示有几个设备通过不同的网络接口连接起来。它们包括WIFI、以太网和一个点对点连接。\n$ ip route show 假设现在你有一个IP地址，你需要知道路由包从哪里来。可以使用下面的路由选项（译注：列出了路由所使用的接口等）：\n$ ip route get 10.42.0.47 更改默认路由 要更改默认路由，使用下面ip命令：\n$ sudo ip route add default via 192.168.0.196 显示网络统计数据 使用ip命令还可以显示不同网络接口的统计数据。\n当你需要获取一个特定网络接口的信息时，在网络接口名字后面添加选项ls即可。使用多个选项**-s**会给你这个特定接口更详细的信息。特别是在排除网络连接故障时，这会非常有用。\n$ ip -s -s link ls p2p1 ARP条目 地址解析协议（ARP）用于将一个IP地址转换成它对应的物理地址，也就是通常所说的MAC地址。使用ip命令的neigh或者neighbour选项，你可以查看接入你所在的局域网的设备的MAC地址。\n$ ip neighbour 监控netlink消息 也可以使用ip命令查看netlink消息。monitor选项允许你查看网络设备的状态。比如，所在局域网的一台电脑根据它的状态可以被分类成REACHABLE或者STALE。使用下面的命令：\n$ ip monitor all 激活和停止网络接口 你可以使用ip命令的up和down选项来激某个特定的接口，就像ifconfig的用法一样。\n在这个例子中，当ppp0接口被激活和在它被停止和再次激活之后，你可以看到相应的路由表条目。这个接口可能是wlan0或者eth0。将ppp0更改为你可用的任意接口即可。\n$ sudo ip link set ppp0 down $ sudo ip link set ppp0 up 获取帮助 当你陷入困境，不知道某一个特定的选项怎么用的时候，你可以使用help选项。man页面并不会提供许多关于如何使用ip选项的信息，因此这里就是获取帮助的地方。\n比如，想知道关于route选项更多的信息：\n$ ip route help 小结 对于网络管理员们和所有的Linux使用者们，ip命令是必备工具。是时候抛弃ifconfig命令了，特别是当你写脚本时。\ndig 使用 dig 来进行 DNS 查询。\n参数类型：查询和格式化 有两种主要的参数可以传递给 dig：\n 告诉 dig 要进行什么 DNS 查询的参数。 告诉 dig 如何 格式化响应的参数。  首先，让我们看一下查询选项。\n主要的查询选项 你通常想控制 DNS 查询的 3 件事是：\n 名称（如 jvns.ca）。默认情况下，查询的是空名称（.）。 DNS 查询类型（如 A 或 CNAME）。默认是 A。 发送查询的 服务器（如 8.8.8.8）。默认是 /etc/resolv.conf 中的内容。  其格式是：\ndig @server name type 这里有几个例子：\n dig @8.8.8.8 jvns.ca 向谷歌的公共 DNS 服务器（8.8.8.8）查询 jvns.ca。 dig ns jvns.ca 对 jvns.ca 进行类型为 NS 的查询。  -x：进行反向 DNS 查询\n我偶尔使用的另一个查询选项是 -x，用于进行反向 DNS 查询。下面是输出结果的样子。\n$ dig -x 172.217.13.174 174.13.217.172.in-addr.arpa. 72888 IN PTR yul03s04-in-f14.1e100.net。 -x 不是魔术。dig -x 172.217.13.174 只是对 174.13.217.172.in-addr.arpa. 做了一个 PTR 查询。下面是如何在不使用 `-x’ 的情况下进行完全相同的反向 DNS 查询。\n$ dig ptr 174.13.217.172.in-addr.arpa. 174.13.217.172.in-addr.arpa. 72888 IN PTR yul03s04-in-f14.1e100.net。 我总是使用 -x，因为它可以减少输入。\nDNS反向查询大概的一个定义就是：\n从 IP 地址获取 PTR 记录。也就是说，通过使用一些网络工具可以将 IP 地址转换为主机名。 实际上，PRT 代表 POINTER，在 DNS 系统有唯一性，将 IP 地址与规范化的主机名联系起来。PTR 记录其实是 NDS 系统的一部分，但是由专门的区域文件组成的，使用的是传统的 in-addr.arpa 格式。\n格式化响应的选项 现在，让我们讨论一下你可以用来格式化响应的参数。\n我发现 dig 默认格式化 DNS 响应的方式对初学者来说是很难接受的。下面是输出结果的样子：\n;  DiG 9.16.20  -r jvns.ca ;; global options: +cmd ;; Got answer: ;; -HEADERde: QUERY, status: NOERROR, id: 28629 ;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1 ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 4096 ; COOKIE: d87fc3022c0604d60100000061ab74857110b908b274494d (good) ;; QUESTION SECTION: ;jvns.ca. IN A ;; ANSWER SECTION: jvns.ca. 276 IN A 172.64.80.1 ;; Query time: 9 msec ;; SERVER: 192.168.1.1#53(192.168.1.1) ;; WHEN: Sat Dec 04 09:00:37 EST 2021 ;; MSG SIZE rcvd: 80 如果你不习惯看这个，你可能需要花点时间来筛选，找到你要找的 IP 地址。而且大多数时候，你只对这个响应中的一行感兴趣（jvns.ca. 180 IN A 172.64.80.1）。\n下面是我最喜欢的两种方法，可以使 dig 的输出更容易管理：\n方式 1 : +noall +answer\n这告诉 dig 只打印 DNS 响应中的“答案”部分的内容。下面是一个查询 google.com 的 NS 记录的例子：\n$ dig +noall +answer ns google.com google.com. 158564 IN NS ns4.google.com. google.com. 158564 IN NS ns1.google.com. google.com. 158564 IN NS ns2.google.com. google.com. 158564 IN NS ns3.google.com. 这里的格式是：\nNAME TTL TYPE CONTENT google.com 158564 IN NS ns3.google.com. 顺便说一下：如果你曾经想知道 IN 是什么意思，它是指“查询类”，代表“互联网internet”。它基本上只是上世纪 80、90 年代的遗物，当时还有其他网络与互联网竞争，如“混沌网络chaosnet”。\n方式 2：+short\n这就像 dig +noall +answer，但更短：它只显示每条记录的内容。比如说：\n$ dig +short ns google.com ns2.google.com. ns1.google.com. ns4.google.com. ns3.google.com. digrc 如果你不喜欢 dig 的默认格式（我就不喜欢！），你可以在你的主目录下创建一个 .digrc 文件，告诉它默认使用不同的格式。\n我非常喜欢 +noall +answer 格式，所以我把 +noall +answer 放在我的 ~/.digrc 中。下面是我使用该配置文件运行 dig jvns.ca 时的情况。\n$ dig jvns.ca jvns.ca. 255在172.64.80.1中 这样读起来就容易多了！\n如果我想回到所有输出的长格式（我有时会这样做，通常是因为我想看响应的权威部分的记录），我可以通过运行再次得到一个长答案。\n$ dig +all jvns.ca dig +trace 我使用的最后一个 dig 选项是 +trace。dig +trace 模仿 DNS 解析器在查找域名时的做法 —— 它从根域名服务器开始，然后查询下一级域名服务器（如 .com），以此类推，直到到达该域名的权威域名服务器。因此，它将进行大约 30 次 DNS 查询。（我用 tcpdump 检查了一下，对于每个根域名服务器的 A / AAAA 记录它似乎要进行 2 次查询，所以这已经是 26 次查询了。我不太清楚它为什么这样做，因为它应该已经有了这些 IP 的硬编码，但它确实如此。）\n我发现这对了解 DNS 的工作原理很有用，但我不认为我用它解决过问题。\n为什么要用 dig 尽管有一些更简单的工具来进行 DNS 查询（如 dog 和 host），我发现自己还是坚持使用 dig。\n我喜欢 dig 的地方实际上也是我 不喜欢 dig 的地方 —— 它显示了大量的细节！\n我知道，如果我运行 dig +all，它将显示 DNS 响应的所有部分。例如，让我们查询 jvns.ca 的一个根名称服务器。响应有 3 个部分，我可能会关心：回答部分、权威部分和附加部分。\n$ dig @h.root-servers.net. jvns.ca +all ;; Got answer: ;; -HEADERde: QUERY, status: NOERROR, id: 18229 ;; flags: qr rd; QUERY: 1, ANSWER: 0, AUTHORITY: 4, ADDITIONAL: 9 ;; WARNING: recursion requested but not available ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 1232 ;; QUESTION SECTION: ;jvns.ca. IN A ;; AUTHORITY SECTION: ca. 172800 IN NS c.ca-servers.ca. ca. 172800 IN NS j.ca-servers.ca. ca. 172800 IN NS x.ca-servers.ca. ca. 172800 IN NS any.ca-servers.ca. ;; ADDITIONAL SECTION: c.ca-servers.ca. 172800 IN A 185.159.196.2 j.ca-servers.ca. 172800 IN A 198.182.167.1 x.ca-servers.ca. 172800 IN A 199.253.250.68 any.ca-servers.ca. 172800 IN A 199.4.144.2 c.ca-servers.ca. 172800 IN AAAA 2620:10a:8053::2 j.ca-servers.ca. 172800 IN AAAA 2001:500:83::1 x.ca-servers.ca. 172800 IN AAAA 2620:10a:80ba::68 any.ca-servers.ca. 172800 IN AAAA 2001:500:a7::2 ;; Query time: 103 msec ;; SERVER: 198.97.190.53#53(198.97.190.53) ;; WHEN: Sat Dec 04 11:23:32 EST 2021 ;; MSG SIZE rcvd: 289 dog 也显示了 “附加” 部分的记录，但它没有明确指出哪个是哪个（我猜 + 意味着它在附加部分？） ，但它似乎没有显示“权威”部分的记录。\n$ dog @h.root-servers.net. jvns.ca NS ca. 2d0h00m00s A \"c.ca-servers.ca.\" NS ca. 2d0h00m00s A \"j.ca-servers.ca.\" NS ca. 2d0h00m00s A \"x.ca-servers.ca.\" NS ca. 2d0h00m00s A \"any.ca-servers.ca.\" A c.ca-servers.ca. 2d0h00m00s + 185.159.196.2 A j.ca-servers.ca. 2d0h00m00s + 198.182.167.1 A x.ca-servers.ca. 2d0h00m00s + 199.253.250.68 A any.ca-servers.ca. 2d0h00m00s + 199.4.144.2 AAAA c.ca-servers.ca. 2d0h00m00s + 2620:10a:8053::2 AAAA j.ca-servers.ca. 2d0h00m00s + 2001:500:83::1 AAAA x.ca-servers.ca. 2d0h00m00s + 2620:10a:80ba::68 AAAA any.ca-servers.ca. 2d0h00m00s + 2001:500:a7::2 而 host 似乎只显示“答案”部分的记录（在这种情况下没有得到记录）：\n$ host jvns.ca h.root-servers.net Using domain server: Name: h.root-servers.net Address: 198.97.190.53#53 Aliases: 总之，我认为这些更简单的 DNS 工具很好（我甚至自己做了一个 简单的网络 DNS 工具），如果你觉得它们更容易，你绝对应该使用它们，但这就是为什么我坚持使用 dig 的原因。drill 的输出格式似乎与 dig 的非常相似，也许 drill 更好！但我还没有真正试过它。\nSamba Samba 是 SMB/CIFS 网络协议的重新实现, 可以在 Linux 和 Windows 系统间进行文件、打印机共享，和 NFS 的功能类似。\n安装 $ sudo apt install samba $ sudo systemctl enable --now smbd.service Samba 服务的配置文件是 /etc/samba/smb.conf，smb.conf(5)提供了详细的文档。\n如果使用了 防火墙，请记得打开需要的端口(通常是 137-139 + 445)。完整列表请查看 Samba 端口使用。\n创建共享 创建的目录即之后能够在Windows主机上直接访问的目录。例如：在用户samba_user的主目录下新建share文件夹为共享目录，由于Windows下的文件夹需可读可写可执行，需更改权限为777\n$ mkdir /home/samba_user/smbshare $ sudo chmod 777 /home/samba_user/smbshare 修改 /etc/samba/smb.conf，在smb.conf文件最后加上以下内容\n$ sudo vim /etc/samba/smb.conf [share] path = /home/samba_user/smbshare public = yes writable = yes valid users = samba_user create mask = 0644 force create mode = 0644 directory mask = 0755 force directory mode = 0755 available = yes  [share]表示共享文件夹的别名，之后将直接使用这个别名 force create mode 与 force directory mode的设置是因为Windows下与Linux下文件和文件夹的默认权限不同造成的，Windows下新建的文件是可执行的，必须强制设定其文件权限。 valid users 设置为你当前的Linux用户名，例如我的是samba_user，因为第一次打开共享文件夹时，需要验证权限。  用户管理 Samba 需要 Linux 账户才能使用 - 可以使用已有账户或创建新用户。\n虽然用户名可以和 Linux 系统共享，Samba 使用单独的密码管理，将下面的 samba_user 替换为上面设置的 valid users:\n$ sudo smbpasswd -a samba_user 根据服务器角色的差异，可能需要修改已有的文件权限和属性。\nWhich is faster-Samba or scp? Depends on the machines. Machines with really fast CPU may do SCP or SFTP faster.\nOtherwise, Samba will probably be faster because it doesn’t have to encrypt.\nsudo 简单的说，sudo 是一种权限管理机制，管理员可以授权于一些普通用户去执行一些 root 执行的操作，而不需要知道 root 的密码。\n严谨些说，sudo 允许一个已授权用户以超级用户或者其它用户的角色运行一个命令。当然，能做什么不能做什么都是通过安全策略来指定的。sudo 支持插件架构的安全策略，并能把输入输出写入日志。第三方可以开发并发布自己的安全策略和输入输出日志插件，并让它们无缝的和 sudo 一起工作。默认的安全策略记录在 /etc/sudoers 文件中。而安全策略可能需要用户通过密码来验证他们自己。也就是在用户执行 sudo 命令时要求用户输入自己账号的密码。如果验证失败，sudo 命令将会退出。\n命令语法 $ sudo [-bhHpV][-s ][-u ][指令] $ sudo [-klv] 参数：\n -b 在后台执行指令。 -h 显示帮助。 -H 将HOME环境变量设为新身份的HOME环境变量。 -k 结束密码的有效期限，也就是下次再执行sudo时便需要输入密码。 -l 列出目前用户可执行与无法执行的指令。 -p 改变询问密码的提示符号。 -s 执行指定的shell。 -u  以指定的用户作为新的身份。若不加上此参数，则预设以root作为新的身份。 -v 延长密码有效期限5分钟。 -V 显示版本信息。 -S 从标准输入流替代终端来获取密码  基本配置 系统默认创建了一个名为 sudo 的组。只要把用户加入这个组，用户就具有了 sudo 的权限。\n至于如何把用户加入 sudo 组，您可以直接编辑 /etc/group 文件，当然您得使用一个有 sudo 权限的用户来干这件，在 sudo 组中加入新的用户，要使用逗号分隔多个用户。\n或者您可以使用 usermod 命令把用户添加到一个组中：\n$ sudo usermod -a -G sudo jack 上面的设置中我们把用户 jack 添加到了 sudo 组中，所以当用户 jack 登录后就可以通过 sudo 命令以 root 权限执行命令了！\n详细配置 在前面的配置中我们只是把用户 jack 加入了 sudo 组，他就具有了通过 root 权限执行命令的能力。\n现在我们想问一下，这是怎么发生的？是时候介绍如何配置 sudo 命令了！\nsudo 命令的配置文件为 /etc/sudoers。\n编辑这个文件是有单独的命令的 visudo，这个文件我们最好不要使用 vim 命令来打开，是因为一旦你的语法写错会造成严重的后果，这个工具会替你检查你写的语法，这个文件的语法遵循以下格式：\nwho where whom command 说白了就是哪个用户在哪个主机以谁的身份执行那些命令，那么这个 where, 是指允许在那台主机 ssh 连接进来才能执行后面的命令，文件里面默认给 root 用户定义了一条规则：\nroot ALL=(ALL:ALL) ALL  root 表示 root 用户。 ALL 表示从任何的主机上都可以执行，也可以这样 192.168.100.0/24。 (ALL:ALL) 是以谁的身份来执行，ALL:ALL 就代表 root 可以任何人的身份来执行命令。 ALL 表示任何命令。  那么整条规则就是 root 用户可以在任何主机以任何人的身份来执行所有的命令。\n现在我们可以回答 jack 为什么具有通过 root 权限执行命令的能力了。打开 /etc/sudoers 文件：\n%sudo ALL=(ALL:ALL) ALL sudo 组中的所有用户都具有通过 root 权限执行命令的能力！\n再看个例子：\nnick 192.168.10.0/24=(root) /usr/sbin/useradd 上面的配置只允许 nick 在 192.168.10.0/24 网段上连接主机并且以 root 权限执行 useradd 命令。\n设置 sudo 时不需要输入密码\n只需要在配置行中添加 NOPASSWD: 就可以了：\n%sudo ALL=(ALL:ALL) NOPASSWD:ALL 日志 在 ubuntu 中，sudo 的日志默认被记录在 /var/log/auth.log 文件中。当我们执行 sudo 命令时，相关日志都是会被记录下来的。\n与输出重定向 如果当前用户没有某个文件的写权限，又要通过输出重定向往该文件中写入内容。结果只能是 “Permission denied”。\n比如当前用户为 nick，下面的命令试图查询 /root 目录下的文件并把结果写入到 /root/test.txt 文件中，注意用户 nick 没有对 /root/test.txt 文件的写权限：\n$ sudo ls -al /root/test.txt -rw-r--r-- 1 root root 0 Jan 10 05:19 /root/test.txt $ sudo ls -al /root  /root/test.txt -bash: /root/test.txt: Premission denied 不工作的原因是：虽然 ls 命令是以 sudo 方式执行的，但是输出重定向操作是由当前 shell 执行的，它(当前 shell)没有 /root/test.txt 文件的权限，所以最终失败。\n搞清楚了原因，就可以通过不同的方式来解决这个问题了，下面介绍四种方式。\n以 sudo 方式运行 shell\n既然是 shell 进程没有权限，那就用 sudo 的方式执行 shell：\n$ sudo bash -c 'ls -al /root  /root/test.txt' 把命令写入脚本，以 sudo 方式执行脚本\n把下面的代码保存到脚本文件 test.sh 中：\n#!/bin/bash ls -al /root  /root/test.txt 然后通过下面的方式执行：\n$ chmod +x test.sh $ sudo ./test.sh 如果觉着创建脚本麻烦的话还可以使用变通的方式：\n$ sudo bash  ls -al /root  /root/test.txt  EOF 或者是下面的写法：\n$ echo 'ls -al /root  /root/test.txt' | sudo bash 先通过 sudo -s 启动 shell，然后执行命令\n先通过 sudo -s 命令切换到 root 用户再执行命令，最后 ctrl + d 退出。\n通过 sudo tee 命令实现\nTee 命令用于将数据重定向到文件，另一方面还可以提供一份重定向数据的副本作为后续命令的 stdin。简单的说就是把数据重定向到给定文件和屏幕上：\n面的命令中通过 sudo tee 把 ls 命令的输出写入文件：\n$ sudo ls -al /root | sudo tee /root/test.txt  /dev/null 其中的  /dev/null 阻止 tee 把内容输出到终端。\nfdisk Linux 系统中所有的硬件设备都是通过文件的方式来表现和使用的，我们将这些文件称为设备文件，硬盘对应的设备文件一般被称为块设备文件。\n磁盘分类 比较常见的磁盘类型有消费类市场中的 SATA 硬盘和服务器中使用的 SCSI 硬盘、SAS 硬盘，当然还有当下大热的各种固态硬盘。\nSATA 硬盘\nSATA(Serial ATA)口的硬盘又叫串口硬盘，Serial ATA 采用串行连接方式，串行 ATA 总线使用嵌入式时钟信号，具备了更强的纠错能力，与以往相比其最大的区别在于能对传输指令(不仅仅是数据)进行检查，如果发现错误会自动矫正，这在很大程度上提高了数据传输的可靠性。串行接口还具有结构简单、支持热插拔的优点。SATA 硬盘主要用于消费类市场和一些低端服务器：\nSCSI 硬盘\nSCSI 硬盘即采用 SCSI 接口的硬盘。它由于性能好、稳定性高，因此在服务器上得到广泛应用。同时其价格也不菲，正因它的价格昂贵，所以在普通PC上很少见到它的踪迹。SCSI 硬盘使用 50 针接口，外观和普通硬盘接口有些相似(下图来自互联网)：\nSAS 硬盘\nSAS 是 Serial Attached SCSI 的缩写，即串行连接的 SCSI，其目标是定义一个新的串行点对点的企业级存储设备接口。串行接口减少了线缆的尺寸，允许更快的传输速度。SAS 硬盘与相同转速的 SCSI 硬盘相比有相同或者更好的性能。SAS 硬盘一般用于比较高端的服务器。\n固态硬盘\n固态硬盘(Solid State Disk)，一般称之为 SSD 硬盘，固态硬盘是用固态电子存储芯片阵列而制成的硬盘，由控制单元和存储单元(FLASH芯片、DRAM芯片)组成。其主要特点是没有传统硬盘的机械结构，读写速度非常快(下图来自互联网)：\n表示方法 在 Linux 系统中磁盘设备文件的命名规则为：\n主设备号 + 次设备号 + 磁盘分区号 对于目前常见的磁盘，一般表示为：\nsd[a-z]x  主设备号代表设备的类型，相同的主设备号表示同类型的设备。当前常见磁盘的主设备号为 sd。 次设备号代表同类设备中的序号，用 “a-z” 表示。比如 /dev/sda 表示第一块磁盘，/dev/sdb 表示第二块磁盘。 x 表示磁盘分区编号。在每块磁盘上可能会划分多个分区，针对每个分区，Linux 用 /dev/sdbx 表示，这里的 x 表示第二块磁盘的第 x 个分区。  磁盘分区 创建磁盘分区大概有下面几个目的：\n 提升数据的安全性(一个分区的数据损坏不会影响其他分区的数据) 支持安装多个操作系统 多个小分区对比一个大分区会有性能提升 更好的组织数据  本文以常见的 MBR 分区为例介绍磁盘分区中的一些常见概念。MBR 磁盘的分区由主分区、扩展分区和逻辑分区组成。在一块磁盘上，主分区的最大个数是 4，其中扩展分区也是一个主分区，并且最多只能有一个扩展分区，但可以在扩展分区上创建多个逻辑分区。因此主分区(包括扩展分区)的范围是 1-4，逻辑分区从 5 开始。对于逻辑分区，Linux 规定它们必须建立在扩展分区上，而不是建立在主分区上。\n主分区的作用是用来启动操作系统的，主要存放操作系统的启动或引导程序。\n扩展分区只不过是逻辑分区的 “容器”。实际上只有主分区和逻辑分区是用来进行数据存储的，因而可以将数据集中存放在磁盘的逻辑分区中。\n我们可以通过 fdisk 命令来查看磁盘分区的信息：\n$ sudo fdisk -l /dev/sda 分区信息：\n Device 显示了磁盘分区对应的设备文件名。 Boot 显示是否为引导分区，是引导分区就有一个 ‘*’ 号。 Start 表示磁盘分区的起始位置。 End 表示磁盘分区的结束位置。 Sectors 表示分区占用的扇区数目。 Size 显示分区的大小。 Id/Type 显示的内容相同，分别是数值 ID 及其文字描述。 Id 列显示了磁盘分区对应的 ID，根据分区的不同，分区对应的 ID 号也不相同。Linux 下用 83 表示主分区和逻辑分区，5 表示扩展分区，8e 表示 LVM 分区，82 表示交换分区，7 表示 NTFS 分区。  划分磁盘分区 fdisk 是 Linux 系统中一款功能强大的磁盘分区管理工具，可以观察硬盘的使用情况，也可以用来管理磁盘分区。\n假设我们的 Linux 系统中增加了一块新的磁盘，系统对应的设备名为 /dev/sdd，下面我们通过 fdisk 命令对这个磁盘进行分区：\n$ (echo n; echo p; echo 1; echo ; echo ; echo w) | sudo fdisk /dev/sdd  命令 n 来创建新分区 p 来创建主分区 主分区的编号为 1- 4，这里我们输入了 1。 分区的大小是通过设置分区开始处的扇区和结束处的扇区设置的。这里如果回车两次会把整个磁盘划分为一个分区，也就是整个磁盘的容器都分给了一个分区。 注意此时的分区信息还没有写入到磁盘中，在这里还可以反悔，如果确认执行上面的分区，执行 w 命令就行了。  这时分区操作已经完成了，我们可以通过下面的命令查看分区的结果：\n$ sudo fdisk -l /dev/sdd 分区是使用磁盘的基础，在分区完成后还需要对分区进行格式化，并把格式化后的文件系统挂载到 Linux 系统之后才能存储文件。\n更改分区的类型\n创建的分区类型默认为 83(Linux)，如果想要一个 8e(Linux LVM)类型的分区，在 fdisk 输入 t 命令来修改分区的类型。\nfuser 当使用umount命令卸载挂载点时，会遇到“device is busy”提示，这时fuser就能查出谁在使用这个资源。\n描述 fuser可以显示出当前哪个程序在使用磁盘上的某个文件、挂载点、甚至网络端口，并给出程序进程的详细信息。\n每个进程 ID 后面跟有一个字母代码。字母代码的解释如下所述。\n c：表示此进程正在使用该文件作为其当前目录。 e：将此文件作为程序的可执行对象使用 f：打开的文件。默认不显示。 F：打开的文件，用于写操作。默认不显示。 r：表示此进程正在将该文件用作其根目录。 m：指示进程使用该文件进行内存映射，抑或该文件为共享库文件，被进程映射进内存。 s：将此文件作为共享库（或其他可装载对象）使用  对于具有已挂载文件系统的块特殊设备，将列出使用该设备上的任何文件的所有进程。对于所有类型的文件（文本文件、可执行文件、目录、设备，等等），只会报告使用该文件的进程。\n对于所有类型的设备，fuser 还会显示打开设备的任何已知内核使用者。内核使用者显示为下列格式之一：\n[module_name] [module_name,dev_path=path] [module_name,dev=(major,minor)] [module_name,dev=(major,minor),dev_path=path] 如果指定了多组文件，可能需要为其他每个文件组重新指定选项。单个短划线可取消当前施行的选项。\n各个进程 ID 输出到标准输出中的单个行上，并以空格分隔。所有其他输出（包括单个终止换行符）均被写入到标准错误。\n任何用户都可以运行 fuser，但只有超级用户可以终止其他用户的进程。\n选项 支持以下选项：\n -a：显示所有命令行中指定的文件，默认情况下被访问的文件才会被显示。 -c：和-m一样，用于POSIX兼容。 -k：杀掉访问文件的进程。如果没有指定-signal就会发送SIGKILL信号。 -i：杀掉进程之前询问用户，如果没有-k这个选项会被忽略。 -l：列出所有已知的信号名称。 -m：name 指定一个挂载文件系统上的文件或者被挂载的块设备（名称name）。这样所有访问这个文件或者文件系统的进程都会被列出来。如果指定的是一个目录会自动转换成\"name/\",并使用所有挂载在那个目录下面的文件系统。 -n：space 指定一个不同的命名空间(space).这里支持不同的空间文件(文件名，此处默认)、tcp(本地tcp端口)、udp(本地udp端口)。对于端口， 可以指定端口号或者名称，如果不会引起歧义那么可以使用简单表示的形式，例如：name/space (即形如:80/tcp之类的表示)。 -s：静默模式，这时候-u,-v会被忽略。-a不能和-s一起使用。 -signal：使用指定的信号，而不是用SIGKILL来杀掉进程。可以通过名称或者号码来表示信号(例如-HUP,-1),这个选项要和-k一起使用，否则会被忽略。 -u：在每个PID后面添加进程拥有者的用户名称。 -v：详细模式。输出似ps命令的输出，包含PID,USER,COMMAND等许多域,如果是内核访问的那么PID为kernel. -V 输出版本号。 -4：使用IPV4套接字,不能和-6一起应用，只在-n的tcp和udp的命名存在时不被忽略。 -6：使用IPV6套接字,不能和-4一起应用，只在-n的tcp和udp的命名存在时不被忽略。 -：重置所有的选项，把信号设置为SIGKILL.  示例 示例 1 显示使用某个文件的进程信息\n这个命令在umount的时候很有用，可以找到还有哪些用到这个设备了。\n$ fuser -um /dev/sda2 /dev/sda2: 6378c(quietheart) 6534c(quietheart) 6628(quietheart) 6653c(quietheart) 7429c(quietheart) 7549c(quietheart) 7608c(quietheart) 示例 2 杀掉打开readme文件的程序\n这里，会在kill之前询问是否确定。最好加上-v以便知道将要杀那个进程。\n$ fuser -m -k -i readme 示例 3 查看那些程序使用tcp的80端口\n$ fuser -v -n tcp 80 # or $ fuser -v 80/tcp tcpdump tcpdump 是一款 Linux 平台的抓包工具。它可以抓取涵盖整个 TCP/IP 协议族的数据包，支持针对网络层、协议、主机、端口的过滤，并提供 and、or、not 等逻辑语句来过滤无用的信息。\ntcpdump 是一个非常复杂的工具，掌握它的方方面面实属不易，也不推荐，能够用它来解决日常工作问题才是关系。\n命令选项 tcpdump 有很多命令选项，想了解所有选项可以 Linux 命令行输入 tcpdump -h，man tcpdump 查看每个选项的意思。\n下面列举一些常用选项：\n -A 只使用 ASCII 打印报文的全部数据，不要和 -X 一起使用，获取 http 可以用 tcpdump -nSA port 80 -b 在数据链路层上选择协议，包括 ip, arp, rarp, ipx 等 -c 指定要抓取包的数量 -D 列出操作系统所有可以用于抓包的接口 -e 输出链路层报头 -i 指定监听的网卡，-i any 显示所有网卡 -n 表示不解析主机名，直接用 IP 显示，默认是用 hostname 显示 -nn 表示不解析主机名和端口，直接用端口号显示，默认显示是端口号对应的服务名 -p 关闭接口的混杂模式 -P 指定抓取的包是流入的包还是流出的，可以指定参数 in, out, inout 等，默认是 inout -q 快速打印输出，即只输出少量的协议相关信息 -s len 设置要抓取数据包长度为 len，默认只会截取前 96bytes 的内容，-s 0 的话，会截取全部内容。 -S 将 TCP 的序列号以绝对值形式输出，而不是相对值 -t 不要打印时间戳 -vv 输出详细信息（比如 tos、ttl、checksum等） -X 同时用 hex 和 ascii 显示报文内容 -XX 同 -X，但同时显示以太网头部  过滤器 网络报文是很多的，很多时候我们在主机上抓包，会抓到很多我们并不关心的无用包，然后要从这些包里面去找我们需要的信息，无疑是一件费时费力的事情，tcpdump 提供了灵活的语法可以精确获取我们关心的数据，这些语法说得专业点就是过滤器。\n过滤器简单可分为三类：协议（proto）、传输方向（dir）和类型（type）。\n一般的 表达式格式 为：\n 关于 proto：可选有 ip, arp, rarp, tcp, udp, icmp, ether 等，默认是所有协议的包 关于 dir：可选有 src, dst, src or dst, src and dst，默认为 src or dst 关于 type：可选有 host, net, port, portrange（端口范围，比如 21-42），默认为 host  常用操作 测试环境 IP：172.18.82.173\n抓取某主机的数据包 抓取主机 172.18.82.173 上所有收到（DST_IP）和发出（SRC_IP）的所有数据包\n$ tcpdump host 172.18.82.173 抓取经过指定网口 interface ，并且 DST_IP 或 SRC_IP 是 172.18.82.173 的数据包\n$ tcpdump -i eth0 host 172.18.82.173 筛选 SRC_IP，抓取经过 interface 且从 172.18.82.173 发出的包\n$ tcpdump -i eth0 src host 172.18.82.173 筛选 DST_IP，抓取经过 interface 且发送到 172.18.82.173 的包\n$ tcpdump -i eth0 dst host 172.18.82.173 抓取主机 200.200.200.1 和主机 200.200.200.2 或 200.200.200.3 通信的包\n$ tcpdump host 200.200.200.1 and \\(200.200.200.2 or 200.200.200.3\\) 抓取主机 200.200.200.1 和除了主机 200.200.200.2 之外所有主机通信的包\n$ tcpdump ip host 200.200.200.1 and ! 200.200.200.2 抓取某端口的数据包 抓取所有端口，显示 IP 地址\n$ tcpdump -nS 抓取某端口上的包\n$ tcpdump port 22 抓取经过指定 interface，并且 DST_PORT 或 SRC_PORT 是 22 的数据包\n$ tcpdump -i eth0 port 22 筛选 SRC_PORT\n$ tcpdump -i eth0 src port 22 筛选 DST_PORT\n$ tcpdump -i eth0 dst port 22 比如希望查看发送到 host 172.18.82.173 的网口 eth0 的 22 号端口的包\n$ tcpdump -i eth0 -nnt dst host 172.18.82.173 and port 22 -c 1 -vv 抓取某网络（网段）的数据包 抓取经过指定 interface，并且 DST_NET 或 SRC_NET 是 172.18.82 的包\n$ tcpdump -i eth0 net 172.18.82 筛选 SRC_NET\n$ tcpdump -i eth0 src net 172.18.82 筛选 DST_NET\n$ tcpdump -i eth0 dst net 172.18.82 抓取某协议的数据包 $ tcpdump -i eth0 icmp $ tcpdump -i eth0 ip $ tcpdump -i eth0 tcp $ tcpdump -i eth0 udp $ tcpdump -i eth0 arp 复杂的过滤条件 抓取经过 interface eth0 发送到 host 200.200.200.1 或 200.200.200.2 的 TCP 协议 22 号端口的数据包\n$ tcpdump -i eth0 -nntvv -c 10 '((tcp) and (port 22) and ((dst host 200.200.200.1) or (dst host 200.200.200.2)))' 对于复杂的过滤器表达式，为了逻辑清晰，可以使用 ()，不过默认情况下，tcpdump 会将 () 当做特殊字符，所以必须使用 '' 来消除歧义。\n抓取经过 interface eth0， DST_MAC 或 SRC_MAC 地址是 00:16:3e:12:16:e7 的 ICMP 数据包\n$ tcpdump -i eth0 '((icmp) and ((ether host 00:16:3e:12:16:e7)))' -nnvv 抓取经过 interface eth0，目标网络是 172.18 但目标主机又不是 172.18.82.173 的 TCP 且非 22 号端口号的数据包\n$ tcpdump -i eth0 -nntvv '((dst net 172.18) and (not dst host 172.18.82.173) and (tcp) and (not port 22))' 抓取流入 interface eth0，host 为 172.18.82.173 且协议为 ICMP 的数据包\n$ tcpdump -i eth0 -nntvv -P in host 172.18.82.173 and icmp 抓取流出 interface eth0，host 为 172.18.82.173 且协议为 ICMP 的数据包\n$ tcpdump -i eth0 -nntvv -P out host 172.18.82.173 and icmp 与其他工具的配合 tcpdump 抓包的时候，默认是打印到屏幕输出，如果是抓取包少还好，如果包很多，很多行数据，刷刷刷从眼前一闪而过，根本来不及看清内容。不过，tcpdump 提供了将抓取的数据保存到文件的功能，查看文件就方便分析多了，而且还能与其他图形工具一起配合分析，比如 wireshark、Snort 等。\n -w 选项表示把数据报文输出到文件  $ tcpdump -w capture_file.pcap port 80  -r 选项表示读取文件里的数据报文，显示到屏幕上  $ tcpdump -nXr capture_file.pcap host host1 .pcap 格式的文件需要用 wireshark、Snort 等工具查看，使用 vim 或 cat 会出现乱码。\ntcpdump 的输出格式 tcpdump 的输出格式总体上为：\n系统时间 源主机.端口  目标主机.端口 数据包参数 比如下面的例子，显示了 TCP 的三次握手过程：\n21:27:06.995846 IP (tos 0x0, ttl 64, id 45646, offset 0, flags [DF], proto TCP (6), length 64) 192.168.1.106.56166  124.192.132.54.80: Flags [S], cksum 0xa730 (correct), seq 992042666, win 65535, options [mss 1460,nop,wscale 4,nop,nop,TS val 663433143 ecr 0,sackOK,eol], length 0 21:27:07.030487 IP (tos 0x0, ttl 51, id 0, offset 0, flags [DF], proto TCP (6), length 44) 124.192.132.54.80  192.168.1.106.56166: Flags [S.], cksum 0xedc0 (correct), seq 2147006684, ack 992042667, win 14600, options [mss 1440], length 0 21:27:07.030527 IP (tos 0x0, ttl 64, id 59119, offset 0, flags [DF], proto TCP (6), length 40) 192.168.1.106.56166  124.192.132.54.80: Flags [.], cksum 0x3e72 (correct), ack 2147006685, win 65535, length 0 第一条是 SYN 报文，通过 Flags[S] 看出。第二条是 [S.]，表示 SYN-ACK 报文。常见的 TCP 报文的 Flags 如下：\n [S]： SYN（开始连接） [.]: 没有 Flag [P]: PSH（推送数据） [F]: FIN （结束连接） [R]: RST（重置连接）  Others Ubuntu Packages Search List of applications—Arch 常用软件—openSUSE 应用程序—Ubuntu 生态适配清单—UOS QEMU KVM QEMU 的图形前端 与其他的虚拟化程序如 VirtualBox 和 VMware 不同, QEMU不提供管理虚拟机的GUI（运行虚拟机时出现的窗口除外），也不提供创建具有已保存设置的持久虚拟机的方法。除非您已创建自定义脚本以启动虚拟机，否则必须在每次启动时在命令行上指定运行虚拟机的所有参数。\nLibvirt提供了一种管理 QEMU 虚拟机的便捷方式。有关可用的前端，请参阅 libvirt 客户端列表。\n创建新虚拟系统 创建硬盘镜像 除非直接从 CD-ROM 或网络引导（并且不安装系统到本地），运行 QEMU 时都需要硬盘镜像。硬盘镜像是一个文件，存储虚拟机硬盘上的内容。\n一个硬盘镜像可能是 raw镜像, 和客户机器上看到的内容一模一样，并且将始终使用主机上的来宾硬盘驱动器的全部容量。此方法提供的I / O开销最小，但可能会浪费大量空间，因为guest虚拟机上未使用的空间无法在主机上使用。\n另外一种方式是qcow2 格式，仅当客户系统实际写入内容的时候，才会分配镜像空间。对客户机器来说，硬盘大小表现为完整大小，即使它可能仅占用主机系统上的非常小的空间。此映像格式还支持QEMU快照功能。但是，使用此格式而不是 raw 可能会影响性能。\nQEMU 提供 qemu-img命令创建硬盘镜像.例如创建一个 4 GB raw 格式的镜像:\n$ qemu-img create -f raw image_file 4G 您也可以用 -f qcow2 创建一个 qcow2 镜像。\n用 dd 或 fallocate 也可以创建一个 raw 镜像。\n警告： 如果硬盘镜像存储在 Btrfs 系统上，则应在创建任何映像之前考虑禁用该目录的 写时复制。\n调整镜像大小\n警告： 调整包含NTFS引导文件系统的镜像将无法启动已安装的操作系统，推荐在操作之前进行备份\n执行 qemu-img 带 resize 选项调整硬盘驱动镜像的大小.它适用于 raw 和 qcow2. 例如, 增加镜像 10 GB 大小, 运行:\n$ qemu-img resize disk_image +10G 在磁盘映像扩容后，必须使用虚拟机内部系统的分区工具对该镜像进行分区并格式化后才能真正开始使用新空间。 在收缩磁盘映像时，必须首先使用虚拟机内部系统的分区工具减少分该分区的大小，然后相应地收缩磁盘映像，否则收缩磁盘映像将导致数据丢失！\n安装操作系统 这是你第一次需要去启动模拟器的步骤，为了在磁盘镜像上安装操作系统，你必须同时将磁盘镜像与安装介质装载到虚拟机上，从安装介质中启动操作系统。\n以i386的客户机为例，为了从CD-ROM内的把可用于启动的ISO文件安装到磁盘镜像上，你需要：\n$ qemu-system-x86_64 -cdrom iso_image -boot order=d -drive file=disk_image,format=raw 在安装完操作系统后，就可以直接从QEMU镜像内启动了。\n注意： 默认情况下仅分配给虚拟机128MB的内存， 分配的内存大小可以通过 -m 调整， 比如 -m 512M 或 -m 2G。\n提示：\n 相较于指定 -boot order=x ，一部分用户感觉使用 -boot menu=on 启用boot菜单的体验更舒服些，至少在配置和实验时是这样的。 当使用无界面（headless）模式时， 将会默认在本地5900端口启动一个VNC服务器， 可以用 TigerVNC 连接到客户机的系统上: vncviewer :5900 若你在安装过程中需要替换软盘或CD，可以使用QEMU机器监视器（在虚拟机窗口中按Ctrl + Alt + 2）来删除存储设备并将其连接到虚拟机。使用info block查看块设备，然后使用change命令换出设备。按下Ctrl + Alt + 1返回虚拟机。  运行虚拟化的系统 qemu-system-* 程序 (例如 qemu-system-i386 或 qemu-system-x86_64, 取决于客户机架构)用来运行虚拟化的客户机. 用法是:\n$ qemu-system-i386 options disk_image 所有 qemu-system-*的选项是相同的。\n默认 QEMU会在窗口中显示虚拟机的视频输出.有一点要记住:当您单击QEMU窗口,鼠标指针被捕获。要放开，按 Ctrl+Alt+g.\n警告： QEMU 不应以 root 身份运行. 如果必须以root身份在某个脚本中运行QEMU，那么你需要使用 -runas 选项让QEMU放弃root权限\n启用 KVM KVM 必须要您处理器和内核支持, 和必要的 kernel modules加载。更多信息参见 KVM。\n要在KVM模式中启动QEMU, 追加 -enable-kvm到启动选项. 要检查是否为正在运行的 VM 启用了 KVM，请使用 Ctrl+Alt+Shift+2 进入 QEMU Monitor，然后键入 info kvm。\n注意：\n -machine 选项中的 accel=kvm 参数与-enable-kvm 或 -accel kvm 选项是等价的。 CPU模型 host 需要 KVM。 如果你使用GUI工具去启动QEMU，但是性能体验极差，那么最好检查一下是否真的开启了KVM支持，因为QEMU可能选择了备用的模拟模式，即软件级模拟。 需要启用KVM才能正常启动windows7和windows8，否则会出现“蓝屏”.  启用 IOMMU (Intel VT-d/AMD-Vi) 的支持 首先启用IOMMU。\n确保您的 CPU 支持 AMD-Vi/Intel Vt-d 并且已经在 BIOS 中打开。通常这个选项会在类似“其他 CPU 特性”的菜单里，也有可能隐藏在超频选项之中。选项可能就叫做 “VT-d” 或者 “AMD-Vi” ，也有可能是更通用的名称，比如“虚拟化技术”之类。有可能您主板的手册并不会解释这些。\n设置内核参数以启用 IOMMU，注意不同品牌的 CPU 所需的内核参数并不同。\n 对于 Intel CPU(VT-d)，使用 intel_iommu=on。 对于 AMD CPU(AMD-Vi)，使用 amd_iommu=on。  您同时需要设置iommu=pt，这将防止Linux试图接触(touching)无法直通的设备。\n在重启之后，检查 dmesg 以确认 IOMMU 已经被正确启用：\n$ dmesg | grep -e DMAR -e IOMMU ... [ 0.000000] Intel-IOMMU: enabled ... 添加 -device intel-iommu 选项创建IOMMU设备:\n$ qemu-system-x86_64 -enable-kvm -machine q35 -device intel-iommu -cpu host .. 注意： 在基于Intel CPU的系统上用 -device intel-iommu 创建QEMU内的IOMMU设备将会禁用PCI直通， 如果需要PCI直通，则不应设置-device intel-iommu。\n宿主机和虚拟机数据交互 网络 我们可以利用任何支持文件传输的网络协议实现客户机和宿主机之间的数据交互, 例如 NFS, SMB, NBD, HTTP, FTP, 或 SSH, 当然这么做的前提是你已经配置好二者之间的网络，且在系统上启动了相应的服务程序。\n在默认情况下，用户模式的客户机能够通过10.0.2.2这个IP访问到宿主机。任何运行于宿主机上的服务端程序都可以通过这个地址被访问到，比如说我们可以通过这个IP访问到宿主机上的SSH服务器或SMB服务器。因此在这种情况下，客户机能够挂载宿主机通过SMB or NFS暴露出来的目录，也可以访问宿主机上的HTTP服务器等。 通常情况下宿主机无法访问客户机上的服务，不过你也可以通过一些特殊的网络配置达到这个目的 (参阅#Tap 网络)\nQEMU 端口转发 QEMU能够将宿主机的端口转发到客户机上以实现一些功能，例如从宿主机上访问客户机的SSH端口。\n举个例子，将宿主机上的10022端口与客户机上的22 (SSH) 端口进行绑定， 对应的QEMU命令如下：\n$ qemu-system-x86_64 disk_image -nic user,hostfwd=tcp::10022-:22 确认你客户机上的sshd程序正在运行，然后可以通过如下命令连接到客户机的SSH端口\n$ ssh guest-user@localhost -p 10022 你可以用 SSHFS 把客户机的整个文件系统都挂到宿主机上，这样就可以在宿主机上对客户机的文件系统进行读写了。\n想进行多端口转发的话, 只需要在-nic参数中指定多个hostfwd, 以VNC端口为例:\n$ qemu-system-x86_64 disk_image -nic user,hostfwd=tcp::10022-:22,hostfwd=tcp::5900-:5900 QEMU 的内置SMB服务器 QEMU的文档中指出它有一个内置的SMB服务器，但实际上，它只是在宿主机上加载一个自动生成的smb.conf配置文件 (位于/tmp/qemu-smb.random_string)，然后启动宿主机上的Samba，使得客户机能够通过一个IP地址进行访问 (默认的IP地址是10.0.2.4)。这个方法只适用于用户网络，在你不想在宿主机开启通常的Samba服务 (客户机同样能访问这类Samba服务) 时这个方法还挺好用的。\n宿主机上必须安装 Samba。通过如下QEMU命令启用这项特性:\n$ sudo apt install samba $ qemu-system-x86_64 disk_image -net nic -net user,smb=shared_dir_path shared_dir_path 就是你想要在宿主机和客户机之间共享的目录。\n接着，在客户机内，你应该能够通过10.0.2.4访问到名为qemu的共享文件夹。例如在Windows Explorer中前往 \\\\10.0.2.4\\qemu 这个地址。\n注意：\n 如果你像这样多次指定共享选项 -net user,smb=shared_dir_path1 -net user,smb=shared_dir_path2 or -net user,smb=shared_dir_path1,smb=shared_dir_path2 qemu只会共享参数中最后的一个目录。 如果你不能访问共享文件夹且客户机系统为 Windows, 请检查 NetBIOS 协议是否被启用 并确认防火墙没有屏蔽NetBIOS协议的 端口 如果你不能访问共享文件夹且客户机系统为 Windows 10 Enterprise 或 Education 或 Windows Server 2016, 请启用游客访问.  共享多个文件夹并在运行时增删文件夹的一个方法是：共享一个空目录，然后在其中创建指向其余共享目录的符号链接。可以用下面的脚本修改SMB服务器的配置，这个脚本还能使宿主机上不允许执行的文件在客户机内拥有执行权限。\n#!/bin/bash eval $(ps h -C smbd -o pid,args | grep /tmp/qemu-smb | gawk '{print \"pid=\"$1\";conf=\"$6}') echo \"[global] allow insecure wide links = yes [qemu] follow symlinks = yes wide links = yes acl allow execute always = yes\"  $conf # in case the change is not detected automatically: smbcontrol --configfile=$conf $pid reload-config 仅当客户机第一次访问到网络驱动后，才能将该脚本启用，并作用于qemu启动的SMB服务器。共享多文件的另一个方法是在配置文件里加入额外的共享路径，就像下面这样\n$ echo \"[myshare] path=another_path read only=no guest ok=yes force user=username\"  $conf 这个共享文件夹可以在客户机内通过\\\\10.0.2.4\\*myshare*访问。\n网络 采用TAP设备（tun 与 tap 设备，都是虚拟网络设备，tun 设备用来实现三层隧道（三层 ip 数据报），tap 设备用来实现二层隧道（二层以太网数据帧）。）和网桥（使用网桥可以将多个接口连接到同一网段内，这一功能等同于交换式集线器。）的虚拟网络的性能应该会比使用用户模式网络或VDE要好，原因在于TAP设备和网桥是在内核中实现的。\n此外，虚拟网络的性能可以通过将网络设备直接注册到虚拟机中改善，这比默认情况下模拟e1000 NIC的性能表现要更好，参阅 [安装 virtio 驱动](#安装 virtio 驱动) 获得更多相关信息。\n关于链路层地址的限制 若在QEMU启动中指定了 -net nic 参数，QEMU将会为虚拟机注册一块虚拟网卡，其链路层地址为 52:54:00:12:34:56 。然而，当在多台虚拟机之间搭建桥接网络时，每台虚拟机在tap设备的虚拟机端都需要拥有一个独一无二的链路层地址 (MAC)，否则网桥会因为收到多个不同源却拥有相同MAC地址的数据包而无法正常工作。即使你为多个tap设备配置了不同的MAC地址也依旧会出现这个问题，因为当数据包通过tap设备时，tap设备并不会改写包内的链路层地址。\n因此请确保每个虚拟机拥有自己独一无二的网卡地址, 并且它们都以 52:54: 开头。 可以通过如下命令手动设置虚拟机的MAC地址, 下面的’X’可以替换成任何16进制字符:\n$ qemu-system-x86_64 -net nic,macaddr=52:54:XX:XX:XX:XX -net vde disk_image 用户模式 默认情况下，没有任何-netdev参数，QEMU将使用带有内置DHCP服务器的用户模式网络。当您的虚拟机运行其DHCP客户端时，将为其分配IP地址，它们将能够通过QEMU伪装的IP来访问物理主机的网络。\n警告： 仅适用于TCP和UDP协议，因此ICMP协议（包括ping）将不起作用。 请勿使用ping测试网络连接。\n如果主机已连接Internet，则此默认配置可以使您的虚拟机轻松访问Internet。但是如果您同时启动多个虚拟机，则虚拟机将无法在外部网络上直接看到，虚拟机也将无法相互通信。\nQEMU的用户模式网络可以提供更多功能，例如内置TFTP或SMB服务器，将主机端口重定向到虚拟机（例如，允许SSH连接到虚拟机）或将虚拟机连接到VLAN（vlan 全程 virtual lan，能够用来虚拟分配以太网。归属于不同的 VLAN ID 的设备之间需要一个路由才能够通信，这意味这不同的 VLAN ID 将以太网划分成了不同的分组。），以便它们可以彼此通信。 有关更多详细信息，请参见-net user标志上的QEMU文档。\n但是，用户模式网络在效用和性能上都有局限性。更高级的网络配置需要使用TAP设备或其他方法。\nTap 网络 Tap devices是一个Linux内核特性，允许您创建作为真实网络接口的虚拟网络接口。发送到tap接口的包将被传递到一个用户空间程序(如QEMU)，该程序将自己绑定到该接口。\nQEMU可以为虚拟机使用tap网络，因此发送到tap接口的包将被发送到虚拟机，并显示为来自虚拟机中的网络接口(通常是以太网接口)。相反，虚拟机通过其网络接口发送的所有内容都将出现在tap接口上。\nLinux桥接驱动程 序支持Tap设备，因此可以将Tap设备彼此桥接在一起，也可以连接其他主机接口，如eth0。如果您希望您的虚拟机能够相互通信，或者希望LAN上的其他机器能够与虚拟机通信，那么这是非常理想的方案。\n警告： 如果您将tap设备和一些主机接口桥接在一起，例如eth0，您的虚拟机将直接出现在外部网络上，这将使它们遭受攻击的可能。根据您的虚拟机可以访问的资源，您可能需要采取所有precautions来保护您的虚拟机。如果风险太大,虚拟机没有资源或您设置多个虚拟机,一个更好的解决方案可能是使用host-only networking建立NAT。在这种情况下，您只需要在主机上安装一个防火墙，而不是为每个虚拟机安装多个防火墙。\n正如在用户模式网络部分中指出的，tap设备提供比用户模式具有更高的网络性能。如果虚拟机中的操作系统支持virtio网络驱动程序，那么网络性能也会显著提高。假设使用tap0设备，virtio驱动程序在客户端上使用，并且没有使用脚本来帮助启动/停止网络，使用下面的qemu命令：\n-net nic,model=virtio -net tap,ifname=tap0,script=no,downscript=no 但是，如果已经使用带有virtio网络驱动程序的Tap设备，则甚至可以通过启用vhost来提高网络性能，例如：\n-net nic,model=virtio -net tap,ifname=tap0,script=no,downscript=no,vhost=on 仅主机网络\n如果为网桥提供了IP地址，并且使能发往该网桥的流量允许，但没有实际接口（例如eth0）连接到网桥，则虚拟机与虚拟机间，虚拟机与主机间能够相互通信。但是，如果您没有在物理主机上设置IP掩蔽，则他们将无法与外部网络进行通信。 此配置被其他虚拟化软件（例如VirtualBox）称为“仅主机网络模式”。\n提示：\n  如果你想设置IP掩蔽，例如虚拟机的NAT，请查看Internet sharing#Enable NAT页面。\n  您也许想在网桥接口上运行一个DHCP服务器来服务虚拟网络。例如，使用172.20.0.1/16子网，dnsmasq作为DHCP服务器:\n# ip addr add 172.20.0.1/16 dev br0 # ip link set br0 up # dnsmasq --interface=br0 --bind-interfaces --dhcp-range=172.20.0.2,172.20.255.254   内部网络\n如果您不为网桥提供IP地址并在iptables添加INPUT规则链，将所有流向网桥中的数据丢弃，则虚拟机将能够彼此通信，但无法与物理主机或外部网络通信。此配置被其他虚拟化软件（例如VirtualBox）称为“内部网络”。您将需要为虚拟机分配静态IP地址，或在其中一个虚拟机上运行DHCP服务器。\n在默认情况下，iptables将丢弃桥接网络中的数据包。您可能需要使用这样的iptables规则来允许桥接网络中的数据包:\n# iptables -I FORWARD -m physdev --physdev-is-bridged -j ACCEPT 使用 qemu-bridge-helper 桥接网络\n这种方法不需要启动脚本，并且很容易适应多个tap和多个桥。它使用/usr/lib/qemu/qemu-bridge-helper，允许在现有桥上创建tap设备。\n提示： 参见 Network bridge 获取创建网桥的信息.\n首先，创建一个配置文件，包含QEMU使用的所有网桥的名称:\n/etc/qemu/bridge.conf allow bridge0 allow bridge1 ... 现在启动虚拟机：\n$ qemu-system-i386 -net nic -net bridge,br=bridge0 [...] 在多个TAP设备的情况下，最基本的用法是要为所有NIC指定VLAN：\n$ qemu-system-i386 -net nic -net bridge,br=bridge0 -net nic,vlan=1 -net bridge,vlan=1,br=bridge1 [...] 手工创建网桥\n将虚拟机连接到主机接口，如eth0，这可能是最常见的配置。这种配置使虚拟机看起来直接位于外部网络，与物理主机位于同一以太网段。\n物理设备和Tap设备之间通过iptables进行网络共享\n桥接网络能在有线接口(例如eth0)之间工作，并且很容易设置。但是，如果主机通过无线设备连接到网络，则无法进行桥接。\n解决这个问题的一种方法是，给tap设备设置一个静态IP，使linux自动处理它的路由，然后通过iptables规则转发tap接口和连接到网络的设备之间的通信。\n通过 VDE2 配置网络 VDE全称为Virtual Distributed Ethernet，作为uml_switch的一个扩展，是一个用于管理虚拟网络的工具包\n其基本的思想是创建一个虚拟的开关，就如插座那样，允许虚拟机和物理机通过\"插入\"连接彼此。下面的配置非常简单，然而，VDE的功能远比展示的更强大，其能够接入虚拟开关，在不同的主机上运行它们并监听开关上的通信。\n本方法的优点在于无需sudo特权，普通用户一般没有运行modprobe的权限。\nVDE2 网桥 任何连接到vde上的虚拟机都会暴露给外部。举个例子，每台虚拟机都能直接从ADSL路由器那收到DHCP的配置信息。\n简化配置参数 如果你经常需要以不同的网络配置选项运行QEMU，就会发现时常得输入大量的-netdev和-device选项组合，这些是大量重复性的劳动。可以用-nic选项将二者结合，就如下面这样，底下这些参数：\n-netdev tap,id=network0,ifname=tap0,script=no,downscript=no,vhost=on -device virtio-net-pci,netdev=network0 可简化为:\n-nic tap,script=no,downscript=no,vhost=on,model=virtio-net-pci 要注意的是缺失了网络ID，因此将会以model=创建这些设备。{ic|-nic}}命令的前半部分参数正是-netdev的参数，而后半部分参数（model=之后的部分）则与设备有关，原本设备所提供的参数同样可以在此使用（例如，可以指定smb=）。若要完全禁用网络，可以用-nic none。\n图形 QEMU 可以使用一下几个图形输出：std, cirrus, vmware, qxl, xenfs 和 vnc。\n使用 vnc 选项，你可以单独运行客户机，并且通过 VNC 连接。\nstd 使用 -vga std 你可以得到最高 2560 x 1600 像素的分辨率。从 QEMU 2.2 开始是默认选项。\nqxl QXL是一个支持2D的并行虚拟化图形驱动。需要在客户机中安装驱动并在启动QEMU时设置-vga qxl选项。你可能也会想使用#SPICE优化QXL的图形表现。\n在Linux客户机中，需要加载qxl和bochs_drm这两个内核模块，以获得一个比较好的效果。\nQXL设备的默认VGA内存大小为16M，这样的内存大小最高支持QHD (2560x1440)的分辨率，如果想要一个更高的分辨率，请增加vga_memmb。\nvmware 尽管Bug有点多，但相比于std和cirrus它的表现会更好。对于Arch Linux客户机来说可以安装xf86-video-vmware和xf86-input-vmmouse获取VMware驱动。\nvirtio virtio-vga / virtio-gpu 是一个基于virgl的3D并行虚拟化图形驱动。目前依旧处于开发中，仅支持最近的（= 4.4）的Linux客户机，且需要以gallium-drivers=virgl选项编译mesa (=11.2)。\n若要在客户机上启用3D加速，那么需要用-vga virtio选项选择此vga，并用-display sdl,gl=on或-display gtk,gl=on在显示设备上启用opengl上下文，这两个选项分别适用于sdl输出和gtk输出。如果配置成功了，那么在客户机的kernel log里可以看到：\n# dmesg | grep drm [drm] pci: virtio-vga detected [drm] virgl 3d acceleration enabled cirrus cirrus是2.2之前默认的图形选项，不应当在现代操作系统中使用它。\nnone 这就像一台完全没有VGA卡的PC，无法通过-vnc访问它。另外，这种情况与使用-nographic选项不同，-nographic会让QEMU模拟VGA卡，只是关闭了SDL输出。\nSPICE SPICE project旨在为用户提供一种完全开源的方式，无缝地对虚拟机进行远程访问。\nVNC 可以用-vnc :*X*选项将QEMU的VGA输出重定向至VNC会话中。将*X*替换为输出目标的编号（0代表之后监听在5900，1代表监听在5901…）。\n$ qemu-system-x86_64 -vnc :0 警告： 默认的VNC服务器没有使用任何验证手段，用户可以从任何主机上连接到VNC。\n基本的口令验证\n可以通过使用password选项很容易地设置访问口令。必须在QEMU Monitor中指定口令，仅当用户提供口令时才有可能连接到VNC。\n$ qemu-system-x86_64 -vnc :0,password -monitor stdio 在QEMU Monitor中设置口令需使用change vnc password命令，然后指定一个口令。\n底下的命令将在启动VNC时直接为其设置口令：\n$ printf \"change vnc password\\n%s\\n\" MYPASSWORD | qemu-system-x86_64 -vnc :0,password -monitor stdio 注意： 口令被限制在8个字符内，可以用暴力破解的方式猜到口令。因此在公网上推荐使用更细致的保护措施。\n音频 -audiodev标识用于设定后端音频驱动及其相关选项。最简单的情况下，你需要选择一个驱动并设置一个id。\n-audiodev pa,id=snd0 使用音频设备 Intel HD Audio\n模拟Intel HD Audio需要添加控制器和编解码器设备。可以用如下命令列出可用的Intel HDA Audio设备：\n$ qemu-system-x86_64 -device help | grep hda 添加音频控制器：\n-device ich9-intel-hda 添加音频编解码器并将其映射到宿主机的音频后端id上。\n-device hda-output,audiodev=snd0 Intel 82801AA AC97\n模拟AC97需要添加声卡设备并将其映射到宿主机的一个音频后端id上。\n-device AC97,audiodev=snd0 无音频设备 通过如下命令获取支持模拟的音频驱动列表：\n$ qemu-system-x86_64 -soundhw help 比如，要在客户机上模拟hda驱动，需要使用-device intel-hda -device hda-duplex选项启动QEMU。\n注意： 客户机的显卡模拟驱动可能也会导致客户机中的音频质量出现问题，需要一个个进行排查。使用qemu-system-x86_64 -h | grep vga列出可用的选项\n安装 virtio 驱动 QEMU为用户提供并行虚拟化块设备和网络设备的能力，其是借助virtio驱动实现的，拥有更好的性能表现以及更低的开销。\nvirtio块设备需要使用-drive指定一个disk image的参数，且需要带上if=virtio参数：\n$ qemu-system-x86_64 -boot order=c -drive file=disk_image,if=virtio 网络配置也是类似的：\n$ qemu-system-x86_64 -nic user,model=virtio-net-pci 注意： 仅有当客户机有virtio设备对应的驱动时该方法才能起效，Linux是有这方面支持的，不过无法保证这些驱动能够兼容其他操作系统。\n以下以windows为例。\n块设备驱动 Windows没有自带virtio驱动，因此需要在安装时加载该驱动。镜像文件可以从Fedora 仓库下载。\n通过ISO加载只对Windows Vista和Windows Server 2008及其之后的版本有效。这个方法的具体操作是在主磁盘设备和Windows安装盘外挂载一个额外的cdrom设备，将系统镜像与virtio驱动一同加载：\n$ qemu-system-x86_64 ... \\ -drive file=windows_disk_image,index=0,media=disk,if=virtio \\ -drive file=windows.iso,index=2,media=cdrom \\ -drive file=virtio.iso,index=3,media=cdrom \\ ... 在安装过程中，Windows Installer会询问你“Where do you want to install Windows?”，其会返回一个警告表示没有找到任何磁盘设备。接下来跟着如下示例中的步骤进行操作（基于Windows Server 2012 R2 with Update）：\n Select the option Load Drivers. Uncheck the box for Hide drivers that are not compatible with this computer’s hardware. Click the browse button and open the CDROM for the virtio iso, usually named “virtio-win-XX”. Now browse to E:\\viostor\\[your-os]\\amd64, select it, and confirm.  现在应该能看到virtio磁盘出现在列表中了，等待着被选中、格式化并安装。\n网络驱动 安装virtio网络驱动程序要容易一些，只需如上所述添加-net参数即可。\n$ qemu-system-i386 -m 4G -vga std -drive file=windows_disk_image,if=virtio -net nic,model=virtio-net-pci -cdrom virtio-win-0.1-185.iso Windows将检测网络适配器并尝试为其找到驱动程序。如果失败，请转到“设备管理器”，找到带有感叹号图标的网络适配器（双击打开），切换到驱动程序并单击“更新驱动程序”，然后选择虚拟CD-ROM。别忘了选中显示要递归搜索目录的复选框。\nBalloon 驱动 如果想要追踪客户机内存状态（比如通过virsh的dommemstat命令）或者在运行时改变客户机内存大小（尽管依然无法改变实际的内存大小，不过可以通过inflating balloon驱动限制内存的使用），那么请在客户机上安装balloon驱动吧。\nQEMU 监视器 QEMU运行时会提供一个监视器console界面以方便用户同虚拟机进行交互。QEMU监视器提供了许多有趣的功能，例如获取当前虚拟机的信息，热插拔设备，创建快照等。在QEMU监视器console中运行help或?命令获得完整的命令列表。\n访问QEMU监视器Console 图形化界面\n当使用默认的std图形选项时，可以通过按下Ctrl+Alt+2组合键或从QEMU窗口上的View  compatmonitor0访问到QEMU监视器。若要返回到虚拟机的图形界面，那么按下Ctrl+Alt+1或者View  VGA就行。\n然而，这种标准的访问方式不够方便，而且并不是在QEMU的所有图形化输出方式中都适用。\nTelnet\n启动QEMU时带上-monitor telnet:127.0.0.1:*port*,server,nowait参数可以启用telnet。虚拟机启动后可以通过telnet访问到监视器：\n$ telnet 127.0.0.1 port 注意： 如果指定 127.0.0.1 作为监听地址，那么只能在运行QEMU的宿主机上连接到该监视器。如果想要远程访问，QEMU需要在0.0.0.0上进行监听：-monitor telnet:0.0.0.0:*port*,server,nowait。还要记住的是，最好对firewall进行配置，该连接是完全不进行认证和加密的，因此需要通过防火墙确保本地网络环境是可信的。\nUNIX socket\n通过-monitor unix:*socketfile*,server,nowait参数运行QEMU，之后就可以通过socat或openbsd-netcat连接到监视器上。\n例如，如果QEMU是通过如下命令启动：\n$ qemu-system-x86_64 [...] -monitor unix:/tmp/monitor.sock,server,nowait [...] 就可以像这样连接到监视器上：\n$ socat - UNIX-CONNECT:/tmp/monitor.sock 或者通过这种方式:\n$ nc -U /tmp/monitor.sock TCP\n可以使用-monitor tcp:127.0.0.1:*port*,server,nowait参数将监视器暴露于TCP端口上，然后用netcat（openbsd-netcat或gnu-netcat都可）进行连接：\n$ nc 127.0.0.1 port 注意： 为了能够从其它设备上通过TCP socket访问到监视器，而不仅仅从运行QEMU的主机上连接，需要像前面Telnet中描述的那样，在0.0.0.0地址上进行监听。\n标准 I/O\n如果以-monitor stdio参数运行QEMU，那么其实是可以在运行QEMU的终端下访问到监视器的。\n在Monitor conosle下向虚拟机发送按键行为 由于在某些配置下，宿主机可能会拦截一些按键组合另作他用，这导致要在虚拟机中触发一些特定按键组合变得有些困难（一个显然的例子就是Ctrl+Alt+F*组合，该组合用于改变当前的tty）。我们采用在monitor console下发送按键组合的方式解决该问题。只需切换到monitor console下，然后使用sendkey命令，即可将按键转发至虚拟机中，例如：\n(qemu) sendkey ctrl-alt-f2 通过 monitor console 创建快照和管理快照 注意： 该特性\"只\"支持qcow2格式的虚拟机磁盘镜像，对于raw是无效的。\n有时候我们很需要将虚拟机的当前状态进行保存，或是将虚拟机重置到之前的快照状态，而且最好是随时能进行这些操作。QEMU monitor console为用户提供了必要的功能，进行快照创建，快照管理，以及快照恢复。\n Use savevm name 用于创建一个名为name的快照。 Use loadvm name 用于将虚拟机状态恢复至快照name。 Use delvm name 用于删除快照name。 Use info snapshots 用于查看保存的快照列表，这些快照由一个自增长的ID和标签名（用户创建快照时赋予）进行标识。  以冻结模式运行虚拟机 QEMU支持以冻结态运行虚拟机（需使用-snapshot参数），换句话说，虚拟机关闭时，对于虚拟机的一切修改都会丢弃。当用户对磁盘镜像写入时，这些变动最终写入的位置是/tmp目录下的一个临时文件，QEMU关机时将会把他们丢弃。\n不过，即使虚拟机运行于冻结状态下，依旧可以通过monitor console将这些变化写入磁盘镜像（如果你想的话）。使用下面的命令：\n(qemu) commit all 另外如果在冻结状态下创建快照，这些快照在QEMU退出时都会被丢弃，除非你显式地commit了他们。\nmonitor console中的开机和暂停命令 在QEMU monitor console下也可以模拟对物理机的一些操作：\n system_powerdown 会向虚拟机发送ACPI关机信号，效果就类似物理机上按下电源按钮。 system_reset 会重置虚拟机，类似物理机上的重置按钮。该操作可能导致数据丢失或文件系统的损坏，这是因为虚拟机并不是\"干净地\"重启的。 stop 会暂停虚拟机。 cont 使暂停的虚拟机恢复运行。  虚拟机截屏 可以在monitor console下运行该命令，获取PPM格式的截屏图片：\n(qemu) screendump file.ppm QEMU 机器协议 QEMU机器协议（QMP）是一个基于JSON格式的协议，使得其他应用程序可以通过该协议控制QEMU实例。类似#QEMU 监视器，其提供了与运行中的虚拟机进行交互的能力，且能够编程进行控制。关于QMP各命令的描述可以在这个qmp-commands链接中找到。\n技巧 改善虚拟机的性能表现 底下是一些可以改善虚拟机性能表现的技术，例如：\n  启用#启用 KVM：QEMU的启动命令加上-enable-kvm选项。\n  通过-cpu host选项让QEMU模拟宿主机上的特定CPU，如果没有该选项QEMU尝试模拟的是一个更为通用的CPU。\n  特别的，如果客户机是Windows，启用Hyper-V enlightenments可以改善性能：-cpu host,hv_relaxed,hv_spinlocks=0x1fff,hv_vapic,hv_time.\n  如果宿主机有多个核心，可以用-smp选项为客户机分配更多核心。\n  检查是否为虚拟机分配的足够的内存。默认情况下，QEMU仅仅为每台虚拟机分配128MiB的内存，可以使用-m选项分配更多的内存。例如，-m 1024代表启动一台内存为1024MiB的虚拟机。\n  如果客户机操作系统支持相关的驱动，可以使用virtio创建网络设备或块设备。\n  使用TAP设备代替user-mode网络，参阅#Tap 网络。\n  如果客户机需要进行大量的磁盘写工作，在宿主机文件系统上设置合适的挂载选项可以优化该工作。例如，可以用barrier=0选项挂载一个ext4 file system。在使用这些性能强化选项之前最好阅读相关文档，因为性能上的提升通常伴随着数据完整性下降的代价。\n  如果有一块原始磁盘镜像，你可能会想要禁用cache：\n$ qemu-system-x86_64 -drive file=disk_image,if=virtio,cache=none   使用原生的Linux AIO：\n$ qemu-system-x86_64 -drive file=disk_image,if=virtio,aio=native,cache.direct=on   如果正同时运行多台虚拟机，而它们拥有同样的操作系统，可以通过启用内核页归并节省内存。参阅#开启KSM。\n  在一些情况下，可以在运行时从安装了balloon驱动的客户机上回收内存，这需要QEMU启动该客户机时使用-device virtio-balloon选项。\n  允许使用一个ICH-9 AHCI控制器的仿真层，尽管它并不稳定。AHCI的仿真模拟支持NCQ，因此可以同时处理多个读写请求：\n$ qemu-system-x86_64 -drive id=disk,file=disk_image,if=none -device ich9-ahci,id=ahci -device ide-drive,drive=disk,bus=ahci.0   参阅 https://www.linux-kvm.org/page/Tuning_KVM 获取更多信息\n开机时启动QEMU虚拟机 通过libvirt实现\n如果虚拟机是通过libvirt设置的，可以用virsh autostart将其配置为开机自启，或者通过virt-managerGUI中虚拟机的Boot Options，选择\"Start virtual machine on host boot up\"实现开机自启。\n通过systemd service实现\n可以用如下的systemd unit和config配置开机时启动QEMU VM。\n/etc/systemd/system/qemu@.service [Unit] Description=QEMU virtual machine [Service] Environment=\"haltcmd=kill -INT $MAINPID\" EnvironmentFile=/etc/conf.d/qemu.d/%i ExecStart=/usr/bin/qemu-system-x86_64 -name %i -enable-kvm -m 512 -nographic $args ExecStop=/bin/bash -c ${haltcmd} ExecStop=/bin/bash -c 'while nc localhost 7100; do sleep 1; done' [Install] WantedBy=multi-user.target 注意： 为了方便地结束任务，该service会等待至console端口被释放（这意味着VM已被关闭）。\n接着创建per-VM配置文件，命名为/etc/conf.d/qemu.d/*vm_name*，在其中设置好args和haltcmd变量，配置示例：\n/etc/conf.d/qemu.d/one args=\"-hda /dev/vg0/vm1 -serial telnet:localhost:7000,server,nowait,nodelay \\ -monitor telnet:localhost:7100,server,nowait,nodelay -vnc :0\" haltcmd=\"echo 'system_powerdown' | nc localhost 7100\" # or netcat/ncat /etc/conf.d/qemu.d/two args=\"-hda /srv/kvm/vm2 -serial telnet:localhost:7001,server,nowait,nodelay -vnc :1\" haltcmd=\"ssh powermanager@vm2 sudo poweroff\" 对该变量的描述如下：\n args - 使用的QEMU命令行参数。 haltcmd - 安全关闭虚拟机的命令，在第一个例子中，QEMU monitor是通过-monitor telnet:..选项暴露至telnet，因而关闭虚拟机是通过nc命令在monitor console中发送system_powerdown，完成ACPI关机的工作。在另一个例子里，使用的则是SSH。  若要设置启动时运行哪个虚拟机，enable qemu@*vm_name*.service这个systemd单元\n鼠标整合 添加-usb -device usb-tablet选项以避免点击客户机系统的窗口时鼠标被捕获。该选项代表QEMU能够在不捕获鼠标的情况下，向系统报告鼠标的位置，该选项启用时还会覆盖PS/2鼠标模拟功能。 命令示例：\n$ qemu-system-x86_64 -hda disk_image -m 512 -usb -device usb-tablet 宿主机的USB设备传递至虚拟机 从客户机访问连接到宿主机USB口的设备是可能的，首先需要识别设备连接的位置，可以用lsusb命令找到设备连接位置，例如：\n$ lsusb ... Bus 003 Device 007: ID 0781:5406 SanDisk Corp. Cruzer Micro U3 上面以显示的数字分别用于标识\n 003 host_bus 007 host_addr 0781 vendor_id 5406 product_id  基本的思想是在QEMU中-device usb-ehci,id=ehci或-device qemu-xhci,id=xhci分别对EHCI (USB 2)或XHCI (USB 3)（在win7无法自动安装 USB3 驱动，因此应用 USB2）控制器进行模拟，然后将物理设备通过-device usb-host,..选项进行添加。\n识别出该设备，并将其连接至任一总线以及宿主机上的地址，通用的语法如下：\n-device usb-host,bus=controller_id.0,vendorid=0xvendor_id,productid=0xproduct_id 应用于上面例子中使用的设备，它变成：\n-device usb-ehci,id=ehci -device usb-host,bus=ehci.0,vendorid=0x0781,productid=0x5406 运行QEMU时会遇到 libusb couldn't open USB device Permission denied 权限错误，可以通过 udev 为设备设定合适的权限。\n$ vi /etc/udev/rules.d/50-usbtinyisp.rules SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"0781\", ATTRS{idProduct}==\"5406\", GROUP=\"vane\", MODE=\"0660\" $ ls -al /dve/bus/usb/003/007 crw-rw---- 1 root vane 189, 11 Nov 7 12:37 /dev/bus/usb/003/007 使用SPICE进行USB重定向 使用#SPICE时可以将USB设备从客户端重定向至虚拟机中，无需使用QEMU命令。还支持为配置USB重定向插槽数（插槽数将决定可同时重定向的最大设备数）。相比于前面那种使用-usbdevice进行重定向的方法，SPICE方法的优势在于可以在虚拟机启动后USB设备热插拔，移除或添加USB设备时无需停机。这个方法还允许通过网络将客户端的USB设备重定向至服务端。总之，其是在QEMU虚拟机中使用USB设备最灵活的方法。\n开启KSM Kernel Samepage Merging (KSM) 是Linux内核的一个特性，允许应用程序向内核申请同其他申请页归并的进程进行页归并，KSM机制允许客户虚拟机之间进行页共享。当许多客户机运行相似的操作系统时，这个机制可以节省客观的内存。\n多屏支持 Linux的QXL驱动支持默认支持四头（虚拟屏幕），可以通过qxl.heads=N这一内核参数进行变更。\n复制和粘贴 在宿主机和客户机之间共享剪贴板的方法之一是使用SPICE远程桌面协议，通过SPICE客户端访问客户机，你需要遵照#SPICE节中描述的步骤，通过该方式运行的客户机将支持与宿主机进行复制粘贴的操作。\nQEMU-KVM Win7 环境准备   安装QEMU：sudo apt install qemu-kvm\n  下载 Windows virtio driver iso：https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/archive-virtio/virtio-win-0.1.102/，因为要将磁盘挂接为 virtio 磁盘。\n需使用 virtio-win-0.1.102，我使用最新的 virtio-win-0.1.208.iso，Windows安装程序会提示驱动没有包含签名错误No signed device drivers were found. Make sure that the installation media contains the correct drivers, and then click OK\n  创建系统盘 qemu-img create -f qcow2 Windows7-VM.img 30G，这将作为Win7的操作系统盘。\n  创建启动脚本\n$ vi start_Windows7_VM.sh #!/bin/bash DISKIMG=$HOME/.vm/Windows7-VM.img exec qemu-system-x86_64 --enable-kvm \\ \t-cpu host,hv_relaxed,hv_spinlocks=0x1fff,hv_vapic,hv_time \\ \t-drive file=${DISKIMG},if=virtio \\ \t-net nic,model=virtio-net-pci -net user,smb=$HOME/Downloads \\ \t-m 4096 \\ \t-smp cores=2,threads=4 \\ \t-monitor stdio \\ \t-vga std \\ \t-audiodev pa,id=snd0 -device ich9-intel-hda -device hda-output,audiodev=snd0 \\ \t-usb -device usb-tablet \\ \t-rtc base=localtime,clock=host \\ \t-name 'Windows7 VM' \\ \t$@ $ chmod u+x start_Windows7_VM.sh   ./start_Windows7_VM.sh -boot d -cdrom $HOME/Downloads/cn_windows_7_ultimate_x64_dvd_x15-66043.iso -drive file=$HOME/Downloads/virtio-win-0.1.102.iso,index=3,media=cdrom\n  安装 Win 7  选择 Custom（advanced）  选择 CD Drive (E:) virtio-win  选择 viostor  安装 Win7 Virtio SCSI Driver  安装好以后，就可以看到安装的目标磁盘了  进入常规的 Win7 安装流程  安装 Virtio 网络驱动 但是安装失败：\n尝试 device manager 安装：\n[QEMU 的内置SMB服务器](#QEMU 的内置SMB服务器) 宿主机的USB设备传递至虚拟机 QEMU-KVM WinXP SP3 windows_xp.sh #!/bin/bash DISKIMG=$HOME/.vm/WindowsXP-VM.img exec qemu-system-x86_64 --enable-kvm \\ \t-cpu host,hv_relaxed,hv_spinlocks=0x1fff,hv_vapic,hv_time \\ \t-drive file=${DISKIMG} \\ \t-net nic,model=rtl8139 -net user,smb=$HOME/Downloads \\ \t-m 4096 \\ \t-cpu Nehalem \\ \t-rtc base=localtime,clock=host \\ \t-usb -device usb-tablet \\ \t-monitor stdio \\ \t-vga std \\ \t$@ Windows XP cannot connect to samba share You have ‘client min protocol = NT1’ set, there is another similar setting ‘server min protocol’ which from Samba 4.11.0 is set to SMBv2. Your XP is probably only using SMBv1, so it will not be able to see or connect to your Samba server.\nSo you have to edit the [global] section in the /etc/samba/smb.conf and add the server min protocol = NT1 option here. Then restart the Samba service.\n例如：\n$ ps h -C smbd -o pid,args 1707 /usr/sbin/smbd --foreground --no-process-group $ vim /tmp/qemu-smb.SL95F1/smb.conf [global] server min protocol = NT1 $ sudo smbcontrol 1707 reload-config 或者编写如下脚本\n#!/bin/bash echo \"[global] server min protocol = NT1\"  /tmp/**/smb.conf sudo smbcontrol $(ps h -C smbd -o pid) reload-config Windows XP 上网提示：您的时钟快了/慢了 此时，无论你怎么调整日期和时间，都不能解决上网问题。即使把日期从2020年调整到2015年，此时虽然不在提示 “您的时钟快了”，也有证书期限等异常。\n出现这种问题的原因，是因为 Windows XP 确实太老了，Google Chrome、Mozilla Firefox 及其内核的浏览器已经不支持了。\nVirtual Machine Manager 键盘不能输入的问题 在 Display 中，设定 keymap，比如 en-us\n无网络 在 NIC 中，将 Device model 设置为 rtl8139\nQEMU-KVM Gentoo Configuration Host To create a disk image for the virtual machine, run:\n$ qemu-img create -f qcow2 Gentoo-VM.img 30G Download a minimal Gentoo LiveCD from here.\nSince QEMU requires a lot of options, it would be a good idea to put them into a shell script, e.g.:\n$ vim start_Gentoo_VM.sh #!/bin/bash DISKIMG=$HOME/VirtualMachine/Gentoo-VM.img exec qemu-system-x86_64 -enable-kvm \\  -bios /usr/share/edk2-ovmf/OVMF_CODE.fd \\  -cpu host \\  -drive file=${DISKIMG},if=virtio \\  -netdev user,id=vmnic,hostname=Gentoo-VM,hostfwd=tcp::10022-:22 \\  -device virtio-net,netdev=vmnic \\  -device virtio-rng-pci \\  -m 4G \\  -smp 2 \\  -monitor stdio \\  -vga std \\  -audiodev pa,id=snd0 -device ich9-intel-hda -device hda-output,audiodev=snd0 \\  -name \"Gentoo VM\" \\  $@ $ chmod u+x start_Gentoo_VM.sh Change the path to your disk image Gentoo-VM.img in the script. You can add more options when calling the script. To boot the disk image, run:\n$ ./start_Gentoo_VM.sh -boot d -cdrom $HOME/Downloads/install-amd64-minimal-20211107T170547Z.iso Install the guest per the Gentoo Handbook. See the guest section for optimum support. After the installation start the script without the additional options.\nUsing UEFI with QEMU UEFI for x86 QEMU/KVM VMs is called OVMF (Open Virtual Machine Firmware). It comes from EDK2 (EFI Development Kit), which is the UEFI reference implementation.\n$ sudo apt-get install ovmf 检查是否安装，命令为：\n$ dpkg -L ovmf | grep OVMF.fd /usr/share/ovmf/ OVMF.fd /usr/share/qemu/ OVMF.fd 要在虚拟机中运行操作系统的映像文件，添加 -bios /usr/share/ovmf/OVMF.fd。该代码调用名为 OVMF.fd 的文件，该文件是 Qemu 的 UEFI 固件。\n$ qemu-system-x86_64 -bios /usr/share/ovmf/OVMF.fd -cdrom ubuntu-21.04-desktop-amd64.iso 这个名为ovmf的包其实就是名为TianoCore的程序。该名称本身代表开放虚拟机固件)。\n“BdsDxe: failed to load Boot0001” solution: Try hitting F2 to enter the OVMF settings during guest boot and manually pick a new boot drive option.\nTips 通过 Qemu 安装 Windows 到硬盘 双系统新思路。今天装windows, 在linux上先用虚拟机，把硬盘直通进去，在raw盘上装好，然后更新grub, 再重启就可以直接接进去了。\n这样可以避免装机还要做启动盘，装机过程中的重启也可以避免了。\nwin的安装过程中驱动都是按照虚拟机的配置安装的，但是win10是自动装驱动的，重启进去后过了一会显卡驱动自动都装好了。\nLooking Glass Looking Glass 讓 Linux 可完美玩 Windows 遊戲 超低延遲不掉格\n當用戶安裝了虛擬電腦（VM）實行 Windows，並執行遊戲時，它採用的 KVM frame relay 技術可將 Windows 顯示記憶體，透過 PCI pass-through 直接由 Windows VM 被配置的顯示卡，複製到 Linux 被配置的顯示卡，這樣 Linux 便可在極為低延遲的情況下，接近完美顯示 Windows 遊戲的內容。\n簡單來說，就是一部 Linux 電腦裡面裝有虛擬電腦運行的 Windows，Windows 遊戲實行時，在被配置的顯示卡記憶體資料，在主機板 PCI 通道直接複製到 Linux 被配置的顯示卡。即是說 Windows 遊戲原本畫面，可高速反映到 Liunx 的虛擬電腦軟件上。這樣 Linux 用戶就算不 Dual boot 或使用兩個熒幕，在 Linux 上都可得到接近相同的打機體驗。\nxrdp xrdp 使用 RDP（Microsoft 远程桌面协议）为远程计算机提供图形登录。xrdp 接受来自各种 RDP 客户端的连接：FreeRDP、rdesktop、NeutrinoRDP 和 Microsoft 远程桌面客户端（适用于 Windows、macOS、iOS 和 Android）。\n正如 Windows 到 Windows 远程桌面一样，xrdp 不仅支持图形远程处理，还支持\n 双向剪贴板传输（文本、位图、文件） 音频重定向 驱动器重定向（在远程机器上安装本地客户端驱动器）  RDP 传输默认使用 TLS 加密。\nQEMU/KVM VS Virtualbox Linux 系统上的虚拟化解决方案 – KVM 和 VirtualBox\nKVM 提供了一些 VirtualBox 没有的功能，反之亦然。IT 世界中没有通用工具，因此使用适合您需求的工具非常重要。基本思想是：如果你想安装二进制 Linux 发行版作为来宾，使用 KVM。它速度更快，并且它的驱动程序包含在官方内核树中。如果您的客户涉及大量编译并且需要一些更高级的功能，并且/或者不是 Linux 系统，那么最好使用 VirtualBox。\n技术原因很简单：KVM 更好地与 Linux 集成，它更小更快，虽然你可以在 Linux 以外的其他客户机上使用它，但我们发现体验相当麻烦：BSD 的 I/O 和 Solaris 往往很慢（确切地说，是 OpenIndiana）在引导安装 ISO 后会立即出现恐慌。由于我们使用当前版本的 BSD（并且经常从源代码编译/更新系统）并且还需要 Solaris，我们发现 VirtualBox 是一个更好的选择。Oracle VirtualBox 的另一个优点是它支持挂起，即您可以将机器状态保存在主机的硬盘上并关闭 VirtualBox，当（重新)启动时，系统将从它离开的地方恢复。这就是为什么我们提到源代码编译：如果你有一台嘈杂的机器，你不想一夜之间离开，但你的 Gentoo 虚拟机只是编译一个新的 gcc 版本，暂停机器状态，关闭主机，明天继续。\n桌面虚拟化、KVM 还是 Virtualbox？\n这两者中的哪一个更适合在 Linux 台式机/笔记本电脑上运行 Windows 10 虚拟机？\n  带有virt-manager 的QEMU/KVM应该可以与 Virtualbox 媲美。\nVirtualbox 没问题，特别是如果跨主机操作系统使用相同的虚拟化很重要，但 QEMU/KVM 是更好的投资。QEMU/HAXM 也应该可以在 Mac 和 Windows 上运行，尽管它目前还不够成熟。\n  KVM, obviously. You’re probably going to need to learn how to manage it, but it is a much better system and allows abstraction on completely unexposed CPU hardware so you can easily take your image and put it onto another KVM. Windows doesn’t like to have it’s CPUs exchange on it very often.\n  KVM 与 VirtualBox\n  表现\n这是要考虑的最重要的领域之一，即管理程序的性能将如何影响您的基础架构。KVM 是 1 类管理程序（这些虚拟机管理程序直接运行在宿主机的硬件上来控制硬件和管理客操作系统），而 VirtualBox 是 2 类管理程序（这些虚拟机管理程序运行在传统的操作系统上，就像其他计算机程序那样运行），这意味着 KVM 应该优于 VirtualBox。\n根据SPECvirt_sc2013 基准测试，VirtualBox 通常比 KVM 需要更多时间来创建和启动服务器，而 KVM 以接近本机的速度运行应用程序，比其他行业管理程序更快。尽管对于典型负载，差异可能微不足道。\n  管理程序管理\n这两个给定的应用程序都可以通过 GUI 进行管理。Virtualbox 相对来说有更好的 GUI，但 KVM 的当前 GUI 使其管理比以往任何时候都更容易。”\n如果您更喜欢命令行，那么 KVM 中有各种命令行选项。Virtualbox 也提供了一个命令行界面，但它不如 KVM virsh 全面。您不能直接从 bash 启动 Virtualbox VM。\n  可扩展性\nKVM 继承了 Linux 的性能，如果来宾机器和请求的数量增加，可以扩展以匹配需求负载。KVM 允许对要求最苛刻的应用程序工作负载进行虚拟化，并且是许多企业虚拟化设置的基础，例如数据中心和私有云。\nVirtualBox 可以为每个 VM 提供多达 32 个虚拟 CPU，而不管主机上物理存在多少 CPU 内核。还可以为具有多达 1024 个 CPU 的主机提供支持。\n  安全\nKVM 提供增强的安全性，因为它结合使用 SELinux 和安全虚拟化 (sVirt)。VirtualBox 可以执行虚拟机的安全实时迁移和磁盘映像加密。它还包括远程桌面协议 (RDP) 身份验证和用于创建进一步身份验证要求以帮助提高安全性的 SDK。您可以在此页面上看到 Virtualbox 的安全功能列表。\n  成本和定价\nKVM 是一个开源的免费平台，由 Red Hat 等供应商提供有偿支持。虽然 Virtualbox 在限制范围内是免费的。一旦您超过一定的使用水平，您必须获得产品许可。\n  支持\n对于 KVM，您需要依赖开源社区和您自己的 IT 组织或受支持的供应商（如红帽）的支持。Oracle 正在积极开发 Virtualbox，您可以从他们那里获得任何支持。\n  libvirt Libvirt 是一组软件的汇集，提供了管理虚拟机和其它虚拟化功能（如：存储和网络接口等）的便利途径。这些软件包括：一个长期稳定的 C 语言 API、一个守护进程（libvirtd）和一个命令行工具（virsh）。Libvirt 的主要目标是提供一个单一途径以管理多种不同虚拟化方案以及虚拟化主机，包括：KVM/QEMU，Xen，LXC，OpenVZ 或 VirtualBox hypervisors。\nLibvirt 的一些主要功能如下：\n VM management（虚拟机管理）：各种虚拟机生命周期的操作，如：启动、停止、暂停、保存、恢复和迁移等；多种不同类型设备的热插拔操作，包括磁盘、网络接口、内存、CPU等。 Remote machine support（支持远程连接）：Libvirt 的所有功能都可以在运行着 libvirt 守护进程的机器上执行，包括远程机器。通过最简便且无需额外配置的 SSH 协议，远程连接可支持多种网络连接方式。 Storage management（存储管理）：任何运行 libvirt 守护进程的主机都可以用于管理多种类型的存储：创建多种类型的文件镜像（qcow2，vmdk，raw，…），挂载 NFS 共享，枚举现有 LVM 卷组，创建新的 LVM 卷组和逻辑卷，对裸磁盘设备分区，挂载 iSCSI 共享，以及更多…… Network interface management（网络接口管理）：任何运行 libvirt 守护进程的主机都可以用于管理物理的和逻辑的网络接口，枚举现有接口，配置（和创建）接口、桥接、VLAN、端口绑定。 Virtual NAT and Route based networking（虚拟 NAT 和基于路由的网络）：任何运行 libvirt 守护进程的主机都可以管理和创建虚拟网络。Libvirt 虚拟网络使用防火墙规则实现一个路由器，为虚拟机提供到主机网络的透明访问。  安装 基于守护进程/客户端的架构的 libvirt 只需要安装在需要要实现虚拟化的机器上。注意，服务器和客户端可以是相同的物理机器。\n服务端\n安装 libvirt 以及至少一个虚拟运行环境（hypervisor）：libvirt 的 KVM/QEMU 驱动 是 libvirt 的首选驱动，如果 KVM 功能已启用，则支持全虚拟化和硬件加速的客户机。\n$ sudo apt update $ sudo apt install qemu-kvm libvirt-daemon-system 安装 libvirt-daemon-system 后，需要将用于管理虚拟机的用户添加到libvirt组中。这对于 sudo 组的成员是自动完成的，但对于应该访问系统范围的 libvirt 资源的其他任何人，都需要另外完成。这样做将授予用户访问高级网络选项的权限。\n在终端中输入：\n$ sudo adduser $USER libvirt 如果选择的用户是当前用户，您需要注销并重新登录才能使新的组成员身份生效。\n客户端\n客户端是用于管理和访问虚拟机的用户界面。\n virsh — virsh 是用于管理和配置域（虚拟机）的命令行程序。 Virtual Machine Manager — 使用libvirt对KVM，Xen，LXC进行管理的图形化工具。  配置 对于系统 级别的管理任务（如：全局配置和镜像卷 位置），libvirt 要求至少要设置授权和启动守护进程。\n注意： 对于用户会话 级别的管理任务，守护进程的安装和设置不是 必须的。授权总是仅限本地，前台程序将启动一个 libvirtd 守护进程的本地实例。\n设置授权 自 libvirt：连接授权：Libvirt 守护进程允许管理员分别为客户端连接的每个网络 socket 选择不同授权机制。这主要是通过 libvirt 守护进程的主配置文件 /etc/libvirt/libvirtd.conf 来实现的。每个 libvirt socket 可以有独立的授权机制配置。目前的可选项有 none、polkit 和 sasl。\n由于 libvirt 在安装时将把 polkit 作为依赖一并安装，所以 polkit 通常是 unix_sock_auth 参数的默认值。但基于文件的权限仍然可用。\n使用 polkit\n注意： 为使 polkit 认证工作正常，应该重启一次系统。\nlibvirt 守护进程在 polkit 策略配置文件（/usr/share/polkit-1/actions/org.libvirt.unix.policy）中提供了两种策略：\n org.libvirt.unix.manage 面向完全的管理访问（读写模式后台 socket），以及 org.libvirt.unix.monitor 面向仅监视察看访问（只读 socket）。  默认的面向读写模式后台 socket 的策略将请求认证为管理员。这点类似于 sudo 认证，但它并不要求客户应用最终以 root 身份运行。默认策略下也仍然允许任何应用连接到只读 socket。\n基于文件的权限授权\n为了给 libvirt 组用户定义基于文件的权限以管理虚拟机，取消下列行的注释：\n$ vim /etc/libvirt/libvirtd.conf #unix_sock_group = \"libvirt\" #unix_sock_ro_perms = \"0777\" # set to 0770 to deny non-group libvirt users #unix_sock_rw_perms = \"0770\" #auth_unix_ro = \"none\" #auth_unix_rw = \"none\" 有些资料提到可以通过改变某些特定 libvirt 目录的权限以简化管理。需要记住的是：包更新时，这些变更会丢失。如要修改这些系统目录的权限，需要 root 用户权限。\n守护进程 libvirtd.service 和 virtlogd.service这两个服务单元都要启动。可以把 libvirtd.service 设置为启用，这时系统将同时启用 virtlogd.service 和 virtlockd.socket 两个服务单元，因此后二者不必再设置为启用。\n测试 测试 libvirt 在系统级工作是否正常：\n$ virsh -c qemu:///system 测试 libvirt 在用户会话级工作是否正常：\n$ virsh -c qemu:///session 管理 绝大部分的 libvirt 管理可以通过三个工具实现：virt-manager（图形界面）、virsh 和 guestfish（它是 libguestfs 的一部分）。\nvirsh Visrsh 用于管理客户域（虚拟机），在脚本式虚拟化管理环境中工作良好。由于需要通过通讯管道与虚拟运行环境通讯，绝大部分 virsh 命令需要管理员权限。尽管如此，一些典型的管理操作如域的创建、运行等也可以像VirtualBox 那样以普通用户身份执行。\nVirsh 允许带命令行选项执行。如果不带则进入其内置的交互式终端：virsh。交互式终端支持 tab 键命令补全。\n从命令行执行：\n$ virsh [可选项]  [参数]... 在交互式终端里运行：\nvirsh #  [参数]... 帮助也是可用的：\n$ virsh help [option*] or [group-keyword*] 存储池 存储池是指保存卷的位置。Libvirt 中卷的定义相当于其他系统中虚拟磁盘或虚拟机镜像的概念。存储池应该是一个目录、一个网络文件系统或一个分区（此处包括 LVM）。存储池可以在活动与不活动之间切换，可以为其分配存储空间。\n以下示例为添加存储池、目录和 LVM 卷的方法：\n$ virsh pool-define-as name type [source-host] [source-path] [source-dev] [source-name] [] [--source-format format] $ virsh pool-define-as poolname dir - - - - /home/username/.local/libvirt/images $ virsh pool-define-as poolname fs - - /dev/vg0/images - mntpoint 上述示例仅仅定义了存储池的信息，下面创建它：\n$ virsh pool-build poolname $ virsh pool-start poolname $ virsh pool-autostart poolname 删除它的命令：\n$ virsh pool-undefine poolname 提示： 对于 LVM 存储池而言：\n 最佳实践是仅把一个卷组分配给一个存储池。 请为存储池选择一个与 LVM 卷组不同的名字。否则当存储池被删除时，该卷组也将被删除。  用 virt-manager 新建存储池\n首先，连接到虚拟运行环境（例如QEMU/KVM的系统/用户会话）。然后，右键点击一个连接（例如QEMU/KVM）选择详情，切换到存储选项卡，点击左下角的**+**，按照向导操作。\n存储卷 存储池被创建之后，就可以在存储池中创建存储卷。如果你想新建一个域（虚拟机），那么这一步可以跳过，因为这一步可以在创建域的过程中完成。\n用 virsh 新建卷\n新建卷，列出卷，变更卷大小，删除卷：\n$ virsh vol-create-as poolname volumename 10GiB --format aw|bochs|raw|qcow|qcow2|vmdk $ virsh vol-upload --pool poolname volumename volumepath $ virsh vol-list poolname $ virsh vol-resize --pool poolname volumename 12GiB $ virsh vol-delete --pool poolname volumename $ virsh vol-dumpxml --pool poolname volumename # for details. 域 虚拟机被称作**“域”**。如果你想在命令行下操作，使用virsh列出，创建，暂停，关闭……域。virt-viewer可以用来查看使用virsh启动的域。域的创建通常以图形化的virt-manager或者命令行下的virt-install完成。 创建新域通常需要安装媒介，例如存储池中的iso文件或是直接从光驱安装。\n列出活动的和不活动的域：\n# virsh list --all 用 virt-install 新建域\n对于很详细的域（虚拟机）配置，可以用 virt-manager 新建域更简单地完成。但是，基础配置同样可以用virt-install完成并且同样运行顺利。至少要配置--name, --memory, 存储(--disk, --filesystem,或--nodisks),和安装方法（通常来说是.iso文件或CD）。查看virt-install(1)得到未列出的选项和更多的详情。\nWindows:\n$ virt-install \\  --name=windows7 \\  --memory 2048 \\  --cdrom /dev/sr0 \\  --os-variant=win7 \\  --disk /mnt/storage/domains/windows7.qcow2,size=20GiB \\  --network network=vm-net \\  --graphics spice 导入现有的卷：\n$ virt-install \\  --name demo \\  --memory 512 \\  --disk /home/user/VMs/mydisk.img \\  --import 用 virt-manager 新建域\n首先，连接到虚拟运行环境（例如 QEMU/KVM system 或用户 session，在连接上右击并选择 新建，然后跟随向导完成。\n 在第四步中取消选中立即分配全部虚拟磁盘空间会加快创建过程并节省实际虚拟磁盘空间占用；然而，这将导致将来花费额外的磁盘整理时间。 在第五步中打开高级选项并确认虚拟化类型设为 kvm（这通常是首选模式）。如果要求附加的硬件配置，选中安装前定制选项。  管理域\n启动域：\n$ virsh start domain $ virt-viewer --connect qemu:///session domain 正常关闭域；强制关闭域:\n$ virsh shutdown domain $ virsh destroy domain 在libvirtd启动时自动启动域:\n$ virsh autostart domain $ virsh autostart domain --disable 在宿主机关闭时自动关闭域:\n使用libvirt-guests.serviceSystemd服务，运行中的域可以在宿主机关闭时自动挂起/关闭。同时这个服务还可以让挂起/休眠的域在宿主机启动的时候自动恢复。查看/etc/conf.d/libvirt-guests并设置相关选项。\n编辑一个域的XML配置：\n$ virsh edit domain 注意： 直接被QEMU启动的虚拟机不被libvirt管理。\n网络 这里是有关 libvirt 网络的一个正宗的概述。\n默认情况下，当 libvirtd 服务启动后，即创建了一个名为 default 的 NAT 网桥与外部网络联通（仅 IPv4）。对于其他的网络连接需求，可创建下列四种类型的网络以连接到虚拟机：\n bridge — 这是一个虚拟设备，它通过一个物理接口直接共享数据。使用场景为：宿主机有 静态 网络、不需与其它域连接、要占用全部进出流量，并且域运行于 系统 层级。有关如何在现有默认网桥时增加另一个网桥的方法，请参阅 网桥。网桥创建后，需要将它指定到相应客户机的 .xml 配置文件中。 network — 这是一个虚拟网络，它可以与其它虚拟机共用。使用场景为：宿主机有 动态 网络（例如：NetworkManager）或使用无线网络。 macvtap — 直接连接到宿主机的一个物理网络接口。 user — 本地网络，仅用于用户 会话。  绝大多数用户都可以通过 virsh 的各种可选项创建具有各种功能的网络，一般来说比通过 GUI 程序（像 virt-manager 之类）更容易做到。也可以按用 virt-install 新建域 所述实现。\n注意： libvirt 通过 dnsmasq 处理 DHCP 和 DNS 请求，以启动每个虚拟网络的不同实例。也会为特定的路由添加 iptables 规则并启用 ip_forward 内核参数。这也意味着宿主机上已运行的dnsmasq并不是libvirt所必须的（并可能干扰到libvirt的dnsmasq实例）。\nUEFI 支持 Libvirt 可以通过 qemu 和 OVMF 来支持 UEFI 虚拟机。 安装 ovmf 。 添加下面的内容到 /etc/libvirt/qemu.conf 。\n$ vim /etc/libvirt/qemu.conf nvram = [ \"/usr/share/ovmf/x64/OVMF_CODE.fd:/usr/share/ovmf/x64/OVMF_VARS.fd\" ] 重启 libvirtd\n现在你可以创建一个 UEFI 虚拟机了。 你可以通过 virt-manager 来创建。当你进行到向导的最后一步时：\n 勾选在安装前自定义配置，之后点击完成。 在概况屏幕, 将固件改为’UEFI x86_64’。 点击开始安装 在启动屏幕，你需要使用linuxefi命令来启动安装程序，并且你需要在系统中运行efibootmgr验证确实运行在UEFI模式下。  VM 相关 VirtualBox 执行 .vbs 文件\n$ cscript test.vbs 删除备份\n删除虚拟机备份，当前状态前一个备份删除得快，两个备份之间的备份删除得慢。\n共享文件夹\n固定分配的共享文件夹对于定义共享文件夹的虚拟机是永久存在的；\n临时分配的共享文件夹在虚拟机运行时添加/删除，虚拟机关闭后消失。\n把img系统镜像转为VDI或VMDK格式文件\n$ VBoxManage convertdd *.img *.vdi 在 virtualbox 新建虚拟机时指定 vdi 硬盘文件，就可以安装系统\n增加现有虚拟机的磁盘大小 下面是你迟早会遇到的情况。\n你在 VirtualBox 中安装了一个或多个操作系统。在创建这些虚拟操作系统的同时，你还在 VirtualBox 中为它们创建了虚拟硬盘。\n你指定了虚拟磁盘的最大大小，比如说 15 或 20GB，但现在使用了一段时间后，你发现你的虚拟机已经没有空间了。\n虽然在 Ubuntu 和其他操作系统上有释放磁盘空间的方法，但更稳健的处理方式是增加 VirtualBox 中创建的虚拟机的磁盘大小。\n是的，你可以在 VirtualBox 中扩大虚拟硬盘，即使在创建之后也可以。虽然这是一个安全且经过测试的过程，但我们强烈建议你在执行这样的操作之前，先创建一个虚拟机的备份。\n我将向你展示如何在 VirtualBox 中以图形和命令行（对于 Linux 极客）方式调整磁盘大小。这两种方法都很简单直接。\n方法 1：在 VirtualBox 中使用虚拟媒体管理器\nVirtualBox 6 增加了一个调整虚拟磁盘大小的图形化选项。你可以在 VirtualBox 主页的文件选项卡中找到它。\n进入 “File - Virtual Media Manager”：\n在列表中选择一个虚拟机，然后使用 “Size” 滑块或输入你需要的大小值。完成后点击 “Apply”。\n请记住，虽然你增加了虚拟磁盘的大小，但如果你的空间是动态分配的，那么实际的分区大小仍然不变。\n方法 2：使用 Linux 命令行增加 VirtualBox 磁盘空间\n如果你使用 Linux 操作系统作为宿主机，在宿主机中打开终端并输入以下命令来调整 VDI 的大小：\nVBoxManage modifymedium \"/path_to_vdi_file\" --resize  在你按下回车执行命令后，调整大小的过程应该马上结束。\n 注意事项\nVirtualBox 早期版本命令中的 *modifyvdi 和 modifyhd 命令也支持，并在内部映射到 modifymedium 命令。\n 如果你不确定虚拟机的保存位置，可以在 VirtualBox 主页面点击 “Files - Preferences” 或使用键盘快捷键 Ctrl+G 找到默认位置。\nSeamless Mode 虚拟机通常在一个窗口中运行来宾操作系统及其程序。但是，VirtualBox和VMware都有一些功能，允许您在主机桌面上运行虚拟化程序，从而将它们从监狱中释放出来。…\n这意味着您可以在不使用虚拟机窗口和来宾操作系统桌面的情况下使用程序。如果使用多个监视器，甚至可以将虚拟机中的不同窗口放置在不同的监视器上。\n工作原理\n所有这些特性都同样工作。启动虚拟机，启动您想要使用的程序，然后启用“无缝模式”或“统一模式”。来宾操作系统的桌面和虚拟机窗口将消失，将来宾操作系统的窗口留在桌面上。它们看起来正在运行，好像它们在您的主机操作系统上运行，但虚拟机仍在后台运行。程序仍然是沙盒，因此它们无法访问主机操作系统的文件——它们似乎正在主机操作系统上运行。\n无论您使用的是Windows、Linux还是Mac，这些技巧都有效。您可以在Linux桌面上无缝运行Windows程序，也可以在Windows桌面上运行Linux软件。\n使用virtualbox的无缝模式\n请注意，VirtualBox只允许您在Windows、Linux和Solaris客户机上使用此功能。如果你设法让MacOSX在VirtualBox虚拟机上运行，或者你正在使用像俳句这样的小众操作系统，你将无法使用这个功能。\n在使用此功能之前，必须在要使用的来宾虚拟机内安装VirtualBox来宾添加软件包。如果您还没有这样做，请启动虚拟机，单击“设备”菜单，然后选择“安装来宾添加”。系统将提示您安装软件。\n要使用此功能，请同时按“主机键”（通常是右Ctrl键，但它显示在虚拟机窗口的右下角）和“L”。也可以单击“视图”菜单，然后选择“切换到无缝模式”。\nVirtualBox将隐藏来宾操作系统的桌面背景，使其看起来好像来宾操作系统的程序正在主机操作系统的桌面上运行。但是，正在运行的应用程序不会出现在操作系统的标准任务栏上。\n要退出无缝模式，只需按主机键，然后再次按L。您还可以在任务栏上方找到VirtualBox菜单，您可以将鼠标悬停在上面查看。单击查看并再次选择切换到无缝模式以禁用无缝模式。\n使用vmware的unity模式\nVMware有一个类似的功能，名为Unity mode。它可以在免费的VMware Player、VMware Workstation和VMware的其他付费应用程序上使用。与VirtualBox一样，VMware的Unity模式适用于Windows和Linux客户机。\nVBox+WinXP SP3 Windows XP; Guest Additions installation stuck; Virtualbox 6.1.18\nDisconnect network. It helps me.\nvs VMWare 工具是用来解决问题的，没必要看到开源就意识形态附体\npiix4_smbus Host SMBus controller not enabled\n从内核的说明文档来看，这个 piix4 实际上是 Intel 82371AB 南桥芯片，多功能总线控制器，而在 VMware 里面并没有这个真实的芯片组，但在启动时最会尝试载入这个驱动模块，所以会报错，但对系统没有任何影响。\n虚拟机网络模式 桥接\n桥接网络是指本地物理网卡和虚拟网卡通过VMnet0虚拟交换机进行桥接，物理网卡和虚拟网卡在拓扑图上处于同等地位，那么物理网卡和虚拟网卡就相当于处于同一个网段，虚拟交换机就相当于一台现实网络中的交换机,所以两个网卡的IP地址也要设置为同一网段。\n所以当我们要在局域网使用虚拟机，对局域网其他pc提供服务时，例如提供ftp，提供ssh，提供http服务，那么就要选择桥接模式。\n例如大学宿舍里有一个路由器，宿舍里四个人连接这个路由器，路由器的wanip就不理会了，这个ip是动态获取的，而lanip默认是192.168.1.1,子网掩码是255.255.255.0。而其他四个人是自动获取ip，假设四个人的ip是:\nA:192.168.1.100/255.255.255.0,\nB:192.168.1.101/255.255.255.0\nC:192.168.1.102/255.255.255.0\nD:192.168.1.103/255.255.255.0\n那么虚拟机的ip可以设置的ip地址是192.168.1.2-192.168.1.99,192.168.1.104-192.168.1.254 (即网络地址全0和全1的除外，再除去ABCD四个人的ip地址)\n那么虚拟机的ip地址可以设置为192.168.1.98/255.255.255.0，设置了这个ip地址，ABCD这四个人就可以通过192.168.1.98访问虚拟机了，如果虚拟机需要上外网，那么还需要配置虚拟机的路由地址，就是192.168.1.1了，这样，虚拟机就可以上外网了，但是，上网我们一般是通过域名去访问外网的，所以我们还需要为虚拟机配置一个dns服务器，我们可以简单点，把dns服务器地址配置为google的dns服务器:8.8.8.8,到此，虚拟机就可以上网了。\nNAT\nNAT模式中，就是让虚拟机借助NAT(网络地址转换)功能，通过宿主机器所在的网络来访问公网。\nNAT模式中，虚拟机的网卡和物理网卡的网络，不在同一个网络，虚拟机的网卡，是在vmware提供的一个虚拟网络。\nNAT和桥接的比较:\n NAT模式和桥接模式虚拟机都可以上外网。 由于NAT的网络在vmware提供的一个虚拟网络里，所以局域网其他主机是无法访问虚拟机的，而宿主机可以访问虚拟机，虚拟机可以访问局域网的所有主机，因为真实的局域网相对于NAT的虚拟网络，就是NAT的虚拟网络的外网。 桥接模式下，多个虚拟机之间可以互相访问；NAT模式下，多个虚拟机之间也可以相互访问。  如果你建一个虚拟机，只是给自己用，不需要给局域网其他人用，那么可以选择NAT，毕竟NAT模式下的虚拟系统的TCP/IP配置信息是由VMnet8(NAT)虚拟网络的DHCP服务器提供的，只要虚拟机的网路配置是DHCP，那么你不需要进行任何其他的配置，只需要宿主机器能访问互联网即可，就可以让虚拟机联网了。\n例如你想建多个虚拟机集群，作为测试使用，而宿主机可能是一个笔记本，ip不固定。这种应用场景，我们需要采用nat模式了，但是我们要考虑一个问题，虚拟机之间是需要互访的，默认采用dhcp，虚拟机的ip每次重启，ip都是不固定的，所以我们需要手工设置虚拟机的ip地址。\nHost-Only\n在Host-Only模式下，虚拟网络是一个全封闭的网络，它唯一能够访问的就是主机。其实Host-Only网络和NAT网络很相似，不同的地方就是Host-Only网络没有NAT服务，所以虚拟网络不能连接到Internet。主机和虚拟机之间的通信是通过VMware Network Adepter VMnet1虚拟网卡来实现的。\nHost-Only的宗旨就是建立一个与外界隔绝的内部网络，来提高内网的安全性。这个功能或许对普通用户来说没有多大意义，但大型服务商会常常利用这个功能。\npodman Podman: A tool for managing OCI containers and pods.\nAndroid-x86 android x86 是一个自由而开源的项目，将谷歌制作的安卓系统从 ARM 架构移植到了 x86 架构，可以让用户在他们的桌面电脑上运行安卓系统来享受所有的安卓功能和应用程序及游戏。\n首次启动运行该安卓系统，运行：\n$ qemu-img create -f qcow2 Android8-VM.img 30G $ gedit start_Android8_VM.sh #!/bin/bash DISKIMG=/media/kurome/Ventoy/QemuKVM/Android8-VM.img exec qemu-system-x86_64 --enable-kvm \\  -hda ${DISKIMG} \\  -net nic -net user \\  -m 4096 \\  -smp cores=2,threads=4 \\  -monitor stdio \\  -vga std \\  -soundhw es1370 \\  -usb -device usb-tablet \\  -name 'Andriod8 VM' \\  $@ $ chmod u+x start_Android8_VM.sh $ ./start_Android8_VM.sh -boot d -cdrom ~/Downloads/android-x86_64-9.0-r2.iso 在，安卓系统已经完全安装在你的 android.img 文件中，你应该使用下面的 QEMU 命令来启动它，而不是前面的命令：\n$ ./start_Android8_VM.sh Anbox Anbox 简介 Anbox 是 “Android in a box” 的缩写。Anbox 是一个基于容器的方法，可以在普通的 GNU/Linux 系统上启动完整的 Android 系统。\nAnbox 可以让你在 Linux 系统上运行 Android，而没有虚拟化的迟钝，因为核心的 Android 操作系统已经使用 Linux 命名空间（LXE）放置到容器中了。\nAndroid 容器不能直接访问到任何硬件，所有硬件的访问都是通过在主机上的守护进程进行的。\n每个应用程序将在一个单独窗口打开，就像其它本地系统应用程序一样，并且它可以显示在启动器中。\n安装使用 Anbox 也可作为 snap 软件包安装，请确保你已经在你的系统上启用了 snap 支持。\n为使 Anbox 工作，确保需要的内核模块已经安装在你的系统中。对于基于 Ubuntu 的用户，使用下面的 PPA 来安装它。\n$ sudo add-apt-repository ppa:morphis/anbox-support $ sudo apt update $ sudo apt install linux-headers-generic anbox-modules-dkms 在你安装 anbox-modules-dkms 软件包后，你必须手动重新加载内核模块，或需要系统重新启动。\n$ sudo modprobe ashmem_linux $ sudo modprobe binder_linux 安装 anbox。\n$ sudo apt install anbox 如果你已经在你的系统上安装 snap，其它的步骤可以忽略。\n$ sudo snap install --devmode --beta anbox 默认情况下，Anbox 并没有带有 Google Play Store。因此，我们需要手动下载每个应用程序（APK），并使用 Android 调试桥（ADB）安装它。\n$ sudo apt install android-tools-adb 既然我们不能使用 Play Store ，你就得从信得过的网站来下载 APK 软件包，像 APKMirror ，然后手动安装它。\n首先，你需要启动 ADB 服务。为做到这样，运行下面的命令。\n$ adb devices 安装语法格式：\n$ adb install Name-Of-Your-Application.apk Waydroid Waydroid是一个基于lxc容器技术，用以启动完整安卓系统的方案。\nGenymotion Android Virtual Devices for all your development \u0026 testing needs\nLooking Glass An extremely low latency KVMFR (KVM FrameRelay) implementation for guests with VGA PCI Passthrough.\nLibVF.IO Commodity GPU Multiplexing Driven By VFIO \u0026 YAML.\nWine 简介 Wine 是在x86、x86-64容许类Unix操作系统在X Window System运行Microsoft Windows程序的软件。另外，Wine也提供程序运行库（Winelib）来帮助计算机程序设计师将Windows程序移植到类Unix系统；也有不少软件经过Wine测试后发布，比如Picasa、uTorrent、MediaCoder。\nWine通过提供一个兼容层来将Windows的系统调用转换成与POSIX标准的系统调用。它还提供了Windows系统运行库的替代品和一些系统组件的替代品。为了避免著作权问题，Wine主要使用黑箱测试逆向工程来编写。\nWine最早是“Windows Emulator”，即Windows模拟器的缩写，但Wine现在为“Wine Is Not an Emulator”的递归缩写，即Wine不是模拟器。Wine的正确名称是“Wine”，而不是全大写或全小写。\nWine计划在1993年由Bob Amstadt及Eric Youngdale发起，最初目的是为了让16位Windows 3.1程序可以在Linux上执行，但随着电脑和时代的演进，Wine也一路支持到更新的Windows和64位的计算机体系结构。\n由于Windows的DLL为封闭源代码，所以程序员只能由最底层的设计开始，耗费大量的时间来编写和测试，最后达至兼容，这过程是困难且缓慢的。\n在1999年期间，当Corel加入这个计划后，Wine很快便能兼容WordPerfect Office，但Corel不久便停止支持这项计划，所以Wine的发展又逐渐趋缓，一直到2006年Google积极参与这个计划后，Wine的发展才又恢复起色，最后终于在2008年发布首个稳定版，其后便以每两周发布一个新版的速度发展着，除此之外，Google每年所举办的夏日代码大赛活动也对Wine有着不少贡献。\nWine虽然是从Linux开始发展，但现在已经支持多种平台，有BSD、Mac OS X与Solaris-x86，在2013年的自由及开源软件开发者欧洲会议上，Wine的项目领导人Alexandre Julliard（英语：Alexandre Julliard）表示目前将积极支持Android平台。\n在2008年，Wine已经能够完美运行很多知名程序，例如Lotus Notes及Microsoft Office 2007，Photoshop CS2，但其可靠性及稳定性仍有待改善。如果该程序包含本地的微软Windows系统的库，那样Wine便可很顺利运行该程序。\n有些Wine DLLs亦已能完美地取代Windows原来的DLLs，使得有些程序可完美运行。\n最晚到2006年，Wine上面已经可以完全基于Wine DLL完美地运行暴雪发行的多款3D游戏了，如魔兽世界、魔兽争霸等。\n注：以下如果使用zsh，~ 应替换为 $HOME才能正常使用\n安装 使用 Ubuntu 仓库版本\n$ sudo apt install wine 使用 wine 仓库安装最新版本\n如果您之前安装过来自其他仓库的 Wine 安装包，请在尝试安装 WineHQ 安装包之前删除它及依赖它的所有安装包（如：wine-mono、wine-gecko、winetricks），否则可能导致依赖冲突。\n如果您使用的是 64 位系统，请开启 32 bit 架构支持（如果您之前没有开启的话）：\n# Verifying you have 64-bit kernel architecture. $ dpkg --print-architecture # Verifying you have multi-arch support enabled.  $ dpkg --print-foreign-architectures # Enabling multi-arch support. $ sudo dpkg --add-architecture i386 $ sudo apt update 下载添加仓库密钥：\n$ wget -nc https://dl.winehq.org/wine-builds/winehq.key $ sudo apt-key add winehq.key 并添加 Ubuntu 20.04 仓库：\n$ sudo add-apt-repository 'deb https://dl.winehq.org/wine-builds/ubuntu/ focal main' 安装：\n$ sudo apt update $ sudo apt install --install-recommends winehq-stable 配置 配置Wine的方式通常有：\n winecfg是Wine的图形界面配置程序。控制台下调用$ winecfg（或指定系统目录：$ WINEPREFIX=~/.系统目录 winecfg）即可启动 control.exe是Windows控制面板的Wine实现，通过$ wine control命令启动 regedit是Wine的注册表编辑器，比较前两者，该工具能配置更多东西。部分常用键值参见：WineHQ’s article on Useful Registry Keys  初始设置 通过全局菜单，应用程序 - 附件 - 终端 ，输入命令： winecfg 这将在你的家目录中创建一个隐藏文件夹（.wine），其中包含类似于在Windows中的虚拟C：驱动器以及注册表文件。一旦该目录中创建完，wine配置窗口将出现。该窗口将允许您定制wine的各种设置，其中包括Windows版本，DLL替换，显示设置，驱动器映射，以及应用程序的特定设置。单击OK按钮关闭该窗口。\nWINEPREFIX Wine默认将配置文件和安装的Windows程序保存在~/.wine。这样的目录称为一个\"Wine prefix\"或\"Wine bottle\"（下文称“系统目录”）。每次运行Windows程序（包括内置程序，如winecfg）时，系统目录会自动创建（如果缺失）或更新。系统目录中存放有文件夹 ~/.wine/drive_c 相当于Windows下C:\\C盘（更确切的说应是系统盘）。\n通过设置WINEPREFIX环境变量，可以更改Wine系统目录的位置。如果希望让不同的Windows程序使用不同的系统环境或配置，这一变量会非常有用。建议把你安装的不同的Windows程序分给不同的WINEPREFIX，便于打包和隔离。当你要启动这个Windows程序前也记得要设置WINEPREFIX。\n例如，如果您使用 $ env WINEPREFIX=~/.win-a wine-A程序.exe参数来运行一个程序。另一个使用 $ env WINEPREFIX=~/.win-b wine-B程序.exe参数，这两个程序将使用独立的C盘和注册表配置。\n以下命令会建立一个默认的系统目录，且不启动任何Windows程序：\n$ env WINEPREFIX=~/.customprefix wineboot -u WINEARCH 这个WINEARCH 决定了你模拟的Windows是32位或是64位的x86。对应的值为win32及win64，如果你的Unix系统是64位的它就默认是win64。\n发行版所提供的wine一般都有32位及64位两个包，直接对应所模拟的Windows位数，包里面的Unix二进制及运行库也都是对应位数。\n对于64位用户，默认创建的系统目录是64位环境的。若想使用纯32位环境，修改WINEARCH 变量win32为即可： $ WINEARCH=win32 winecfg这样就会生成32位Wine环境。若不设置WINEARCH得到的就是64位环境。\n通过WINEPREFIX变量，在不同的系统目录分别创建32位和64位环境：\n$ WINEARCH=win32 WINEPREFIX=~/win32 winecfg $ WINEPREFIX=~/win64 winecfg 注意： 系统目录创建过程中，64位版本的wine将视全部目录如同64位系统目录，也将不会在已存在的目录中创建任何32位的。创建32位系统目录，您必须让Wine创建指定的WINEPREFIX目录。\nwinetricks也接受WINEPREFIX变量，以安装Steam为例：\n$ WINEARCH=win32 WINEPREFIX=~/.local/share/wineprefixes/steam winetricks steam 编辑 ~/.bashrc，使得 WINEPREFIX 和 WINEARCH 永久生效\nexport WINEPREFIX=$HOME/.config/wine/ export WINEARCH=win32 图形驱动 你需要安装32位的显卡驱动。缺少或未能正确配置驱动的一个标志是 Wine 在终端窗口里报告如下内容：\nDirect rendering is disabled, most likely your OpenGL drivers have not been installed correctly 注意： 在安装对应的库以后，你可能需要重启 X\n声音 Wine程序有可能遇到某些声音问题。首先，确保winecfg中只启用了一种声卡驱动。目前，Wine对Alsa的支持最好。\nMIDI 支持\nMIDI 是九十年代非常流行的游戏声音系统。如果你尝试运行老一点的游戏，音乐无法开箱即用的情况并不罕见。 Wine 拥有非常优秀的 MIDI 支持。但是首先你需要确保 Wine 会使用正确的 MIDI 输出。详细设置参考 Wine Wiki\n字体 中文乱码\n将中文字体copy到对应wine的目录（本地安装的wine是~/.wine，playonlinux是.PlayOnLinux/wineprefix/对应目录）下的drive_c/windows/Fonts/。\n在wine目录下任意位置添加modify_font.reg文件：\nREGEDIT4 [HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\FontLink\\SystemLink] \"Lucida Sans Unicode\"=\"SourceHanSans.ttc\" \"Microsoft Sans Serif\"=\"SourceHanSans.ttc\" \"MS Sans Serif\"=\"SourceHanSans.ttc\" \"Tahoma\"=\"SourceHanSans.ttc\" \"Tahoma Bold\"=\"SourceHanSans.ttc\" \"msyh\"=\"SourceHanSans.ttc\" \"Arial\"=\"SourceHanSans.ttc\" \"Arial Black\"=\"SourceHanSans.ttc\" 将SourceHanSans.ttc改成自己想改的中文字体。\n在wine命令提示符运行：\n$ regedit modify_font.reg 语言区域\n如果安装的系统LANG不为zh-CN，那么wine运行程序的默认语种也不会是中文，这可能导致一部分乱码。解决这个问题，用\n$ env LANG=zh_CN.UTF-8 wine example.exe 运行程序\n启动器和菜单 Wine不会为内置程序（如winecfg、winebrowser）创建桌面启动器和菜单项。但手动安装的Windows程序通常会自动创建启动器和菜单项。在Windows下，安装程序（如setup.exe）通常会在桌面和开始菜单建立快捷方式，而Wine下会创建遵循freedesktop.org规范的.desktop文件（即启动器，相当于快捷方式）。\n提示： 如果启动器没有自动创建，或者这些文件丢失了，可以尝试使用winemenubuilder修复。\nGnome3 中清理 Wine 菜单启动项\n系统全局的菜单启动器安装在 /usr/share/applications/，清除相应程序的“.desktop”文件即可从整个系统删除该启动器。\n如果这样还是无法解决问题，那么很可能 Wine 的启动器存放在用户级别的 ~/.local/share/applications/wine/Programs/ 目录中。删除相应的“.desktop”文件即可清理对应启动项。删除整个 Programs 文件夹将清理所有 Wine 程序的启动项。\n安装/运行/卸载 Windows 程序 警告： 千万不要以root身份运行Wine！详情参见本文。\n使用wine安装应用程序，可以按照以下步骤：\n 从某个地址下载Windows应用程序.exe（可执行文件）. 把它放在一个方便的目录（例如，桌面或个人文件夹） 打开终端，并且切换到.exe文件所在的目录。 输入命令 wine application-name.exe 。  这将使用Wine启动.EXE。如果它是一个安装程序，它应该像在windows一样的运行。如果应用程序要求目录来安装应用程序，选择把它放在 C:\\Program Files 。\n运行Windows程序格式为 WINEPREFIX=\"wine配置文件存放地\" wine [路径]程序.exe 参数 ，如：\n$ wine notepad.exe c:/abc.txt $ wine notepad.exe ~/.wine/drive_c/abc.txt 路径可以是Unix路径，也可以是（在有WINEPREFIX情况下的）Windows路径，wine会自动判断。\n对wine来说，你Unix系统里的其他文件（即模拟的C盘之外的文件）的Windows路径都以Z盘开头：\n$ wine notepad.exe z:/home/username/.wine/drive_c/abc.txt 内置的msiexec程序可以运行MSI安装包：\n$ [wine] msiexec /i path_to_msi 还可以通过在终端运行 winefile 使用 Wine 文件浏览器。\n在某些情况下，应用程序需要被从一个特定位置上运行。在这种情况下创建命令启动\n$ sh -c \"cd /home/USER/.wine/drive_c/Program Files/APPDIR; wine game.exe\" wine uninstaller 这将打开一个类似于Windows的程序“添加/删除程序”控制面板，让您卸载wine安装的应用程序。通过 wine 直接运行卸载程序也应该正常工作。或者，您也可以简单地删除应用程序的文件夹。\n技巧 提示： 此外您可能会感兴趣以下文章的开始所提供的链接\n Wine程序数据库 (Wine Application Database, AppDB) —— 特定Windows程序的Wine兼容情况（运行时的已知问题、用户评分、指南等等），Rating一列由运行结果好到坏为Platinum、Gold、Silver、Bronze、Garbage，无近期结果或近期仍然Silver以下的就放弃吧。 WineHQ论坛 —— 要是看完上述网页还有问题，可以到这里咨询  OpenGL 模式 很多游戏（比如魔兽争霸啦）都支持OpenGL模式，在Wine下可能比默认DirectX模式性能更好。一般添加-opengl启动程序即可，但不同程序可能有所不同：\n$ wine /path/to/3d_game.exe -opengl 请参考AppDB，了解特定程序的相关信息。\nWine 控制台 有些时候，可能需要运行.exe给游戏打补丁，比如给古董游戏添加宽屏支持。这时直接通过Wine运行可能没有用。那么，打开终端，运行一下命令：\n$ wineconsole cmd 将进入一个和Windows下cmd一样的命令行环境。在该环境下试试也许就可以了。\nwinetricks 使用Winetricks快速脚本，能够方便地安装许多Windows组件，包括DirectX、msxml（被Office 2007、IE浏览器依赖）visual运行库还有其他更多的。\n使用 Ubuntu 仓库版本\n$ sudo apt install winetricks 使用 Github 安装最新版本\n$ cd \"${HOME}/.local/bin\" $ wget https://raw.githubusercontent.com/Winetricks/winetricks/master/src/winetricks $ chmod u+x winetricks 可以用winetricks list-all来看看它支持什么。\nUsing winetricks\n获得 winetricks 后，您只需在控制台输入sh winetricks即可运行它。如果你先chmod +x winetricks ，你也可以使用./winetricks。如果不带参数运行，winetricks 会显示一个带有可用包列表的 GUI。如果您知道要安装的软件包的名称，可以将它们附加到 winetricks 命令，它将立即开始安装过程。例如，\n$ sh winetricks corefonts vcrun6 将安装 corefonts 和 vcrun6 软件包。\n所有 Wine 命令一样，winetricks 知道 WINEPREFIX 环境变量。\n$ env WINEPREFIX=~/.winetest sh winetricks mfc40 拥有多个 Wine 版本的用户可以指定 winetricks 应该使用哪个版本\n$ env WINE=~/wine-git/wine sh winetricks mfc40 使用 ~/wine-git 目录中的 Wine 安装 mfc40 包。\nMono \u0026 Gecko Mono 是 .NET Framework 的开源和跨平台实现。Wine 可以使用 Windows 构建的 Mono 来运行 .NET 应用程序。\nWine 实现了自己的 Internet Explorer 版本。该实现基于Mozilla 的 Gecko Layout Engine的自定义版本。\n在 USTC MIRROR 分别下载对应的版本，放入~/.cache/wine就可以了。\nCrossOver CrossOver是Wine的付费、商业化版本，提供更全面的终端用户支持。它包括脚本、补丁、GUI和可能永远不会被Wine项目接受的第三方软件。这种组合使得那些不太懂技术的人运行Windows程序变得相当容易。\n首先在 CrossOver 下载 .bin 安装包，然后要把 .bin 文件设置成可执行的：chmod u+x crossover.bin，接下来运行该文件：./crossover.bin。\n无限试用\ncrossover 有15天的试用期，crossover的时间验证信息写在每一个winebottle容器中，相互是完全隔离（不是写在全局配置中）。即使一个容器过期了，依然可以创建新的容器，并重新计算试用期，所以不需要重装软件本身。\n即使重装程序，已经过期的容器依旧不能用，不过可以删除该容器，或者删除容器下的.eval文件。\n$ rm ~/.cxoffice/**/.eval Tutorials 相对于 wine 而言，CrossOver 更加简洁方便，全程使用 GUI。\n在 Select Application 的时候，即使列表中没有列出你需要安装的 Windows 软件，依旧可以尝试使用默认的 Unlisted application，如一些 roguelike、galgame 游戏是可以直接运行的。\n如果无法运行：\n 如果报错缺少dll，这时就在网上查找一下，比如 sskin.dll，如果教程使用的 winetricks，则可以在 winetricks/files/verbs/all.txt 找到具体的依赖名称，如 Visual C++ 6 SP4 libraries，然后可以在 Select Application 输入依赖名来安装，如果下载慢，也可以通过软件显示的下载链接直接下载。 如果什么错也没报，那么就需要参考 Unsupported Troubleshooting 安装依赖或配置 winecfg，确保在安装游戏的时候没有选择升级依赖（比如 DirectX ）并且之后安装了必要的依赖项。推荐游戏自带的 CommonRedist 或在 WineHQ - Browse Applications、PlayOnLinux、PCGamingWiki 上找依赖，可以但不推荐在虚拟机中运行一下看报错。 如果先是正常运行，之后 wine 报错 page fault 退出，那么可以参考 Gathering debug logs in Crossover Linux 创建 crash log。  凡是依赖解决了，游戏一般是能够运行了，但是运行的好不好，有没有bug就不敢保证了，比如 Skul - The Hero Slayer 是可以直接运行的，但是无法正常显示血量，即使重新安装依赖也是如此。\n以下测试的是运行游戏所必须的依赖：\n  Sekiro Shadows Die Twice\n Microsoft Visual C++ 6.0 (4.2 \u0026 6.0) Redistributable    The Elder Scrolls V Skyrim Special Edition\n DirectX for Modern Games 使用 SkyrimSELauncher.exe 配置，使用 SkyrimSE.exe 启动    Life is Strange - Before the Storm\n 先安装下面两个依赖，如果 FitGirl 报 Getting unarc.dll returned an error code -6，就 try using the set memory limit to 2 gb option；如果是 Miss files，那么就重装。 Microsoft Visual C++ 6.0 (4.2 \u0026 6.0) Redistributable DirectX for Modern Games 游戏需要加载一会儿，这个时候屏幕没反应。    NieR - Automata\n DirectX for Modern Games 如果 unable to input name for profile creation，可以尝试将 CrossOver 升级到最新版本。    Dead Cells\n 参考 [playonlinux/dead cells](playonlinux/dead cells) 的 SourceCode 安装依赖后能够运行 DirectX for Modern Games OpenAL，安装后要在 Wine Configuration  Libraries 中添加 openal32（不加，点击无反应、闪退）（Libraries 中是运行时自动加载进来的库，而需要的 openal32 没有自动加载进来，因此手动添加） Microsoft Visual C++ 6.0 (4.2 \u0026 6.0) Redistributable    The Binding of Isaac Rebirth Repentance\n 要在 Wine Configuration  Libraries 中添加 openal32（不加，点击无反应、闪退） 《以撒的結合：重生》給新玩家的基本攻略    Valiant Hearts The Great War\n Copy over the cracked content from the /Crack directory on the image to your game install directory manually.    DARK SOULS REMASTERED\n 更改语言：In the game installation folder find the “steam_emu.ini”, open it and find the line with language, change it to schinese.（在 font 目录可以找到所有语言）    Braid\n DirectX for Modern Games    Dying Light Platinum Edition\n Microsoft Visual C++ 6.0 (4.2 \u0026 6.0) Redistributable    DXVK 游戏使用 Vulkan 将获取更好的性能，为使用 Vulkan，需启用 DXVK。DXVK provides a Vulkan-based translation layer for DXGI, D3D10 and D3D11, which can be used on Linux with Wine.\n打开 System Information，如果在属性下找到了 “vulkan.present”=“yes”，则表示支持 vulkan 并可以安装 DXVK。\n首先安装驱动程序\n$ sudo apt install mesa-vulkan-drivers mesa-vulkan-drivers:i386 libvulkan1 libvulkan1:i386 vulkan-utils 然后像安装普通软件那样，在 Select an Application to install 搜索并选择 DXVK (Upstream) 安装——DXVK (Builtin) 可能会导致游戏无法运行。安装后就自动启用了，也可以通过右键一个 BottleSettingsDXVK Vulkan backand for D3D11(Custom) 启用。\nEsync 注：Some Windows applications will not work correctly which ESync enabled. 例如 My Friend Pedro 开了后闪退，应该先保证正确运行，再考虑提升性能。\nWhat is “wine esync” and how should I set it up?\nthe thing with Far Cry 4, 3 and Primal also Dirt Rally in wine is that it massively loads wineserver and synchronizing all the time, so it is stuck at around 20 fps on ryzen, all those games mentioned. with esync, wineserver is skipped for synchronizing and eventfd is being used, thus increasing performance that much. Games that are CPU bound with wineserver having huge load (wineserver is singlethreaded) benefit the most of this\nWhat is the function of esync? Why most games need it disabled?\nThe function of esync is to provide lightweight thread synchronization facilities (events/semaphores/mutexes) so that game code that uses them heavily will run faster.\nIt does this using a linux-specific facility called eventfd, which is built around file descriptors. These are a limited resource normally not needed in large quantities, and therefore traditionally made available to a process only in moderate quantities. This helps prevent runaway processes and malicious code from consuming so many descriptors that none are left for other processes (a denial of service).\nTherefore, when a game that uses tens of thousands of thread synchronization objects is run with esync, it will fail unless the system’s per-process file descriptor limit is much higher than the traditional default. Some linux distributions have already adopted a high default, while others still default to a thousand or so. That’s why these games run fine with esync on some distributions but fail on others unless the system’s DefaultLimitNOFILE setting is increased.\nEdit: If you’re interested in esync technical issues that are not distribution-specific, check out this comment.\nHowToEsync What is Esync?\nEsync removes wineserver overhead for synchronization objects. This increases performance for a lot of games, especially ones that rely heavily on multithreading.\nA more detailed explanation can be found here.\nHow to check Esync compatibility\nSystems using Systemd 240 and newer are already compatible with Esync.\nIf you’re unsure that your system is compatible, run the ulimit -Hn command. If the value printed is equal to or greater than 524288, then your system is Esync-compatible.\nHow to make your system Esync compatible\nIf your system is not Esync-compatible (ulimit -Hn, which prints the limit for number of opened files for a process, prints a value lower than 524288, like 4096), you have 2 different methods of solving this problem. Which method is preferable depends on the distribution currently in use. Applying both methods should have no negative side effect.\n Modifying Systemd configuration  This method applies to Ubuntu and other systems using systemd. You (with root privileges or sudo) need to edit both /etc/systemd/system.conf and /etc/systemd/user.conf by adding DefaultLimitNOFILE=524288. If DefaultLimitNOFILE= already exists in both system.conf and user.conf, add 524288 after = and make sure to uncomment the line (remove the # in the beginning of the line) to make it functional.\nOnce the files are edited, restart your computer for the changes to take effect. To verify if the limits were applied, run ulimit -Hn to see 524288 being reported.\nIf the value printed still says something like 4096, try the ulimits method below.\nModifying ulimits.conf  On Linux distributions not using Systemd or distributions using pam-limits.conf (Arch Linux, Fedora, Solus,… ), you (with root privileges or sudo) need to edit /etc/security/limits.conf.\nChange username to your actual username. Once the file is edited, reboot for the changes to take effect, and verify by running ulimit -Hn to see the new limit (524288).\nusername hard nofile 524288 中文乱码 注：某些游戏会因为语言设置而无法运行。\n修改步骤：打开容器 C:Drive，返回到顶层文件夹（即容器名称），即可找到cxbottle.conf，在文件最后面添加如下内容：\n[EnvironmentVariables] \"LANG\" = \"zh_CN.UTF-8\" 实例 Cemu 用 Crossover 试了一下，不能用 vulkan，很卡，鼠标延迟很高。\nOffice 2013 Pro 注：在安装前先在 AppDB 中查找要安装的应用，在 Test Results 部分有相关教程，如 Microsoft Office 2013 Test Results\n注：要提高安装成功率，第一，不同 wine 版本安装结果是不同的，AppDB 有相应的信息；第二，winetricks 如果提供安装镜像的话，一定要用该镜像，winetrics 是一个很大的脚本，打开脚本搜索 office2013pro 即可找到官方镜像下载链接；第三，如果第一次安装失败，可以再尝试安装一次。\nI installed office 2013 and I used to get a black window after starting it up. I fixed the black screen by following the solution posted in the [WineHQ-Forum](https://forum.winehq.org/viewtopic.php?f=8\u0026t=28446\u0026p=109296\u0026hilit=office 2013#p109284).\nHere’s what I did:\nInstall Components\n$ sudo apt install winbind cabextract Create Clean 32bit Prefix for Win7\nCrete a clean 32 bit prefix and start up winecfg:\n$ env WINEPREFIX=~/.wine-office2013pro WINEARCH=win32 winecfg In the winecfg applications tab select “Windows version: Windows 7” Close wine config and install winetricks\nInstall Libraries\nThen start winetricks for your prefix\n$ env WINEPREFIX=~/.wine-office2013pro WINEARCH=win32 winetricks accept “select the default wineprefix” with OK. Now, select “Install Windows DLL components” and go and install msxml6（这个时候会下载 msxml6，可以手动下载后移动到~/.cache/winetricks中）\nTo fix the problem in PowerPoint (not enough memory), I added two overrides with winecfg in Library section: “riched20” and “usp10”.\n如果是中文软件需安装中文字体。\n在这里我直接使用 winetrics 成功安装 office2013pro（wine 6）：\n$ env WINEPREFIX=~/.wine-office2013pro WINEARCH=win32 winetricks office2013pro 这样下面步骤不需要了。\nFix Black Window\nIn order to fix the black window that impedes Office 13 to be used, add the HKCU\\Software\\Wine\\Direct3D\\MaxVersionGL new DWORD value 30002 (hexa) to the registry.\nHere’s how to do this: In Winetricks select Run regedit and wait for the Registry Editor window to open. In the folder tree expand HKEY_CURRENT_USER - Software - Wine and create a new key in the Wine folder. To do so, right click, select new–key and name it Direct3D. Now create new–DWORD Value, rename the file to MaxVersionGL and set the value data to 30002 (hexadecimal). Close the Registry Editor window.\nClose the winetricks window and run installer:\nInstall Office 2013\n$ env LANG=zh_CN.UTF-8 WINEPREFIX=~/.wine-office2013pro WINEARCH=win32 wine ~/PathTo/Office2013Setup.x86.exe From here, the install runs and completes 100%.\n安装后可以在 ~/.local/share/applications/wine 下找到 微信、QQ 的 .desktop 文件，右键编辑，将 Exec=env 行改为 Exec=env LANG=zh_CN.utf8\nWeChat Linux 安装微信的可选方案总结\n 腾讯官方 Web 版微信 Franz + 微信（基于 Web 版） Electronic-Wechat（基于 Web 版） 虚拟机 + 微信原生 PC 客户端 CrossOver + 微信原生 PC 客户端 Winetricks（基于 Wine） + 微信原生 PC 客户端 Winetricks-ZH（基于 Wine） + 微信原生 PC 客户端 AppImage + AppImage 打包构建的（Wine + 微信原生 PC 客户端） Flatpak + Flatpak 打包构建的（Deepin-Wine + 微信原生 PC 客户端） Wine + PlayonLinux + 微信原生 PC 客户端  Genshin Impact  Lutris An Anime Game Launcher 葡萄玩：跑腾讯云游戏，再用云游戏玩国服原神。  fstab /etc/fstab是用来存放文件系统的静态信息的文件。当系统启动的时候，系统会自动地从这个文件读取信息，并且会自动将此文件中指定的文件系统挂载到指定的目录。\n查看/etc/fstab\n# cat /etc/fstab      tmpfs /tmp tmpfs nodev,nosuid 0 0 /dev/sda1 / ext4 defaults,noatime 0 1 /dev/sda2 none swap defaults,nodelalloc 0 0 /dev/sda3 /home ext4 defaults,noatime 0 2 分别解释一下各字段的用处：\n  要挂载的分区或存储设备  挂载的目录位置  挂载分区的文件系统类型，比如：ext3、ext4、xfs、swap  挂载使用的参数有哪些。举例如下：  auto - 在启动时或键入了 mount -a 命令时自动挂载。 noauto - 只在你的命令下被挂载。 exec - 允许执行此分区的二进制文件。 noexec - 不允许执行此文件系统上的二进制文件。 ro - 以只读模式挂载文件系统。 rw - 以读写模式挂载文件系统。 user - 允许任意用户挂载此文件系统，若无显示定义，隐含启用 noexec, nosuid, nodev 参数。 users - 允许所有 users 组中的用户挂载文件系统. nouser - 只能被 root 挂载。 owner - 允许设备所有者挂载。 sync - I/O 同步进行。 async - I/O 异步进行。 dev - 解析文件系统上的块特殊设备。 nodev - 不解析文件系统上的块特殊设备。 suid - 允许 suid 操作和设定 sgid 位。这一参数通常用于一些特殊任务，使一般用户运行程序时临时提升权限。 nosuid - 禁止 suid 操作和设定 sgid 位。 noatime - 不更新文件系统上 inode 访问记录，可以提升性能。 nodiratime - 不更新文件系统上的目录 inode 访问记录，可以提升性能(参见 atime 参数)。 relatime - 实时更新 inode access 记录。只有在记录中的访问时间早于当前访问才会被更新。（与 noatime 相似，但不会打断如 mutt 或其它程序探测文件在上次访问后是否被修改的进程。），可以提升性能。 flush - vfat 的选项，更频繁的刷新数据，复制对话框或进度条在全部数据都写入后才消失。 defaults - 使用文件系统的默认挂载参数，例如 ext4 的默认参数为:rw, suid, dev, exec, auto, nouser, async.    dump 工具通过它决定何时作备份。dump 会检查其内容，并用数字来决定是否对这个文件系统进行备份。 允许的数字是 0 和 1 。0 表示忽略， 1 则进行备份。大部分的用户是没有安装 dump 的 ，对他们而言  应设为 0。  fsck 读取  的数值来决定需要检查的文件系统的检查顺序。允许的数字是0, 1, 和2。 根目录应当获得最高的优先权 1, 其它所有需要被检查的设备设置为 2。 0 表示设备不会被 fsck 所检查。  示例：\n/dev/sda1 /mnt/LinuxOSBuckup ext4 defaults 0 2 UUID of Storage Devices Finding UUID with blkid\n$ sudo blkid Finding UUID with ls\n$ ls -l /dev/disk/by-uuid Finding UUID with lsblk\n$ sudo lsblk -f Package Management dpkg 管理软件包 dpkg 意即 Debian 包管理器（Debian PacKaGe manager）。dpkg 是一个可以安装、构建、删除及管理 Debian 软件包的命令行工具。\n其它的一些工具如 dpkg-deb 和 dpkg-query 等使用 dpkg 作为执行某些操作的前端。\n现在大多数系统管理员使用 Apt、Apt-Get 及 Aptitude 等工具，不用费心就可以轻松地管理软件。\n尽管如此，必要的时候还是需要用 dpkg 来安装某些软件。\n常见命令及文件位置 dpkg 命令的语法:\n$ dpkg [ ...]  dpkg 相关文件的位置在 /var/lib/dpkg\n/var/lib/dpkg/status 包含了被 dpkg 命令（install、remove 等）所修改的包的信息\n/var/lib/dpkg/status 包含了可用包的列表\n安装/升级软件 在基于 Debian 的系统里，用以下命令来安装 .deb 软件包。要是已经安装了软件包，就会升级它。\n$ sudo dpkg -i package.deb 从文件夹里安装软件 在基于 Debian 的系统里，用下列命令从目录中逐个安装软件。这会安装 /opt/software 目录下的所有以 .deb 为后缀的软件。\n$ sudo dpkg -iR /opt/software 显示已安装软件列表 以下命令可以列出 Debian 系的系统中所有已安装的软件，同时会显示软件版本和描述信息。\n$ dpkg -l 查看指定的已安装软件 用以下命令列出指定的一个已安装软件，同时会显示软件版本和描述信息。\n$ dpkg -l package 查看软件安装目录 以下命令可以在基于 Debian 的系统上查看软件的安装路径。\n$ dpkg -L package 查看 deb 包内容 下列命令可以查看 deb 包内容。它会显示 .deb 包中的一系列文件。\n$ dpkg -c package.deb 显示软件的详细信息 以下命令可以显示软件的详细信息，如软件名、软件类别、版本、维护者、软件架构、依赖的软件、软件描述等等。\n$ dpkg -s package 查看文件属于哪个软件 用以下命令来查看文件属于哪个软件。\n$ dpkg -S /path/file 移除/删除软件 以下命令可以用来移除/删除一个已经安装的软件，但不删除配置文件。\n$ sudo dpkg -r package 清除软件 以下命令可以用来移除/删除包括配置文件在内的所有文件。\n$ sudo dpkg -P package Debian 打包入门 deb包本身有三部分组成：\n注：原文写的不是很好，具体学习还是看官方的 Debian 新维护者手册\nCardbook 是用于管理基于 CardDav 和 vCard 标准的联系人的Thunderbird扩展。\n使用 dh_make 在当前目录下创建一个 debian 目录。\n$ dh_make\\ \t--native \\ \t--single \\ \t--packagename cardbook_1.0.0 \\ \t--email minkush@example.com 一些重要的文件，比如 control、rules、changelog、copyright 等文件被初始化其中。所创建的文件的完整列表如下：\n$ find debian debian debian/manpage.sgml.ex debian/cardbook.doc-base.EX debian/changelog debian/control debian/postrm.ex debian/postinst.ex debian/source debian/source/format debian/README.Debian debian/manpage.1.ex debian/salsa-ci.yml.ex debian/rules debian/cardbook.cron.d.ex debian/README.source debian/preinst.ex debian/prerm.ex debian/copyright debian/cardbook-docs.docs debian/README debian/manpage.xml.ex 在当前目录执行 dpkg-buildpackage -us -uc -ui 将会在上层目录创建一个空的包文件以及四个名为 .changes、.deb、 .dsc、 .tar.gz 的文件。\n .dsc 文件包含了所发生的修改和签名 .deb 文件是用于安装的主要包文件。 .tar.gz （tarball）包含了源代码。  这个过程也在 debian/cardbook/usr/share/doc/cardbook 目录下创建了 README 和 changelog 文件。它们包含了关于这个包的基本信息比如描述、作者、版本。\n检查这个包安装的内容：\n$ dpkg -c cardbook_1.0.0_amd64.deb /usr /usr/share /usr/share/doc /usr/share/doc/cardbook /usr/share/doc/cardbook/README.Debian /usr/share/doc/cardbook/changelog.gz /usr/share/doc/cardbook/copyright build-essential 在 Ubuntu 中安装构建基础包（build-essential），只需要在终端中简单输入这个命令：\n$ sudo apt update \u0026\u0026 sudo apt install build-essential 构建基础包（build-essential）实际上是属于 Debian 的。在它里面其实并不是一个软件。它包含了创建一个 Debian 包（.deb）所需的软件包列表。这些软件包包括 libc、gcc、g++、make、dpkg-dev 等。构建基础包包含这些所需的软件包作为依赖，所以当你安装它时，你只需一个命令就能安装所有这些软件包。\n请不要认为构建基础包是一个可以在一个命令中神奇地安装从 Ruby 到 Go 的所有开发工具的超级软件包。它包含一些开发工具，但不是全部。\nPackage converter  alien：Alien is really designed to be used to convert from alien file formats to the packaging format used by the distribution you run it on. gentoo-zh：gentoo 本质是通过 bash 安装软件，因此，可以参考此仓库尝试手动安装软件。  Is linux binary universal to all kinds of distributions?\nThis is two questions:\nIs a Linux binary universal to all distributions?\nIt depends:\n If the program is using nothing outside the Linux kernel, it will be universal except for the 32- or 64-bit question. A Linux “hello world” (a minimalistic program that just prints “hello world” to a terminal window) could probably be independent of the distribution. If the program is using any non-kernel library or service (which is most of Linux, the kernel is fairly small), there are differences in which libraries are included, which versions these libraries are and where they are located. So in this (most common) case distributions are not equal.  Why do many commercial programs say that they only work on one or a few distributions?\nBecause there is a very large number of Linux distributions, and nobody wants to test their program on all of them.\nA commercial vendor will normally say that they support only the distributions they have tested their software on. It may or may not work on other distributions, from the vendor’s perspective the point is just that you can’t complain if it does not work on a distribution they don’t support.\nWhich distributions are selected for testing depends on what the vendor expects their customers to be using. Commercial/professional programs commonly pick enterprise distributions, possibly through a reasoning similar to “people who paid for their OS are more likely to pay for our software”, possibly simply by counting the distributions used by their existing customers.\nSee also Mark Shuttleworth (the guy that is the reason we have an Ubuntu in the first place) on [binary compatibility between Ubuntu and Debian](https://wiki.ubuntu.com/MarkShuttleworth#What about binary compatibility) - Debian is the closest distribution relative of Ubuntu.\nAPT Debian 使用一套名为 Advanced Packaging Tool（APT）的工具来管理包系统。在基于 Debian 的 Linux 发行版中，有各种工具可以与 APT 进行交互，以方便用户安装、删除和管理的软件包。apt-get 便是其中一款广受欢迎的命令行工具，但是最常用的命令都被分散在了 apt-get、apt-cache 和 apt-config 这三条命令当中，apt 命令的引入就是为了解决命令过于分散的问题。（简单来说就是：apt = apt-get、apt-cache 和 apt-config 中最常用命令选项的集合）\n   apt 命令 取代的命令 命令的功能     apt install apt-get install 安装软件包   apt remove apt-get remove 移除软件包   apt purge apt-get purge 移除软件包及配置文件   apt update apt-get update 刷新存储库索引   apt upgrade apt-get upgrade 升级所有可升级的软件包   apt autoremove apt-get autoremove 自动删除不需要的包   apt full-upgrade apt-get dist-upgrade 在升级软件包时自动处理依赖关系   apt search apt-cache search 搜索应用程序   apt show apt-cache show 显示装细节   apt list  列出包含条件的包（已安装，可升级等）   apt edit-sources  编辑源列表    列出所有手动安装软件 $ apt-mark showmanual 查看软件包依赖 当你在 Linux 中安装一个软件包，有时这个软件包还需要其他的软件包来使它工作正常。这些额外的软件包就叫作这个包的依赖。假如这些软件包之前没有在系统中被安装，那么这些依赖在安装这个软件包的同时会被自动安装上。\n使用 apt show 来查看依赖\n你可以使用 apt show 命令 来展示一个包的详细信息。其中依赖信息就是其中一部分，你可以在以 “Depends” 打头的那些行中看到它们。\n例如，下面展示的是使用 apt show 展示 ubuntu-restricted-extras 这个包的详细信息：\n$ apt show ubuntu-restricted-extras Package: ubuntu-restricted-extras Version: 67 ... Depends: ubuntu-restricted-addons Recommends: libavcodec-extra, ttf-mscorefonts-installer, unrar ... 如你所见，ubuntu-restricted-extras 包依赖于 ubuntu-restricted-addons 这个软件包。\n但你得小心的是依赖包还可能依赖于其他包，这样一直循环往复直到尽头。但幸好 APT 包管理器可以为你处理这些复杂的依赖关系，自动地安装所有的依赖（大多数情况下）。\n什么是推荐包？\n你注意到了上面结果输出中以 “Recommends” 开头的那些行了吗？\n推荐包不是软件包的直接依赖，但它们可以开启软件包的一些额外功能。\n正如你上面看到的那样， ubuntu-restricted-extras 包有 ttf-mscorefonts-installer 这个推荐包，用来在 Ubuntu 上安装 Microsoft 的字体。\n这些推荐包也会默认被一同安装上，假如你想显式地禁止这些推荐包的安装，你可以像下面这样使用 –-no-install-recommends 选项。\n$ sudo apt install --no-install-recommends package_name 使用 apt-cache 来直接获取依赖信息\n上面通过 apt show 的方式会获取到大量信息，假如你想在脚本中获取到依赖信息，那么 apt-cache 命令将会给你一个更好且更简洁的输出结果。\n$ apt-cache depends package_name 使用 dpkg 来查看一个 DEB 文件的依赖\napt 和 apt-cache 都作用于软件仓库中的软件包，但假如你下载了一个 DEB 文件，那么这两个命令就不起作用了。\n在这种情形下，你可以使用 dpkg 命令的 -I 或 --info 选项。\n$ dpkg -I path_to_deb_file 依赖信息就可以在以 “Depends” 开头的那些行中找到。\n使用 apt-rdepends 来查看依赖及依赖的依赖\n假如你想查看更多关于依赖的信息，那么你可以使用 apt-rdepends 工具。这个工具可以创建完整的依赖树。这样你就可以得到一个软件包的依赖以及这些依赖的依赖。\n它不是一个常规的 apt 命令，所以你需要从 universe 软件仓库中安装上它：\n$ sudo apt install apt-rdepends 这个命令的输出通常很多，取决于依赖树的大小。\neading package lists... Done Building dependency tree Reading state information... Done shutter Depends: procps Depends: xdg-utils imagemagick Depends: imagemagick-6.q16 (= 8:6.9.2.10+dfsg-2~) imagemagick-6.q16 Depends: hicolor-icon-theme Depends: libc6 (= 2.4) Depends: libmagickcore-6.q16-6 (= 8:6.9.10.2) Depends: libmagickwand-6.q16-6 (= 8:6.9.10.2) hicolor-icon-theme libc6 Depends: libcrypt1 (= 1:4.4.10-10ubuntu4) Depends: libgcc-s1 libcrypt1 Depends: libc6 (= 2.25) apt-rdepends 工具的功能非常多样，它还可以用来计算反向依赖。这意味着你可以查看某个特定的包被哪些软件包依赖。\n$ apt-rdepends -r package_name 输出可能会非常多，因为它将打印出反向依赖树。\n$ apt-rdepends -r ffmpeg Reading package lists... Done Building dependency tree Reading state information... Done ffmpeg Reverse Depends: ardour-video-timeline (= 1:5.12.0-3ubuntu4) Reverse Depends: deepin-screen-recorder (5.0.0-1build2) Reverse Depends: devede (4.15.0-2) Reverse Depends: dvd-slideshow (0.8.6.1-1) Reverse Depends: green-recorder (= 3.2.3) Repository Mirror Select the fastest mirror\nYou can use deb mirror to have the best mirror picked for you automatically.\napt-get now supports a ‘mirror’ method that will automatically select a good mirror based on your location. Putting:\ndeb mirror://mirrors.ubuntu.com/mirrors.txt precise main restricted universe multiverse deb mirror://mirrors.ubuntu.com/mirrors.txt precise-updates main restricted universe multiverse deb mirror://mirrors.ubuntu.com/mirrors.txt precise-backports main restricted universe multiverse deb mirror://mirrors.ubuntu.com/mirrors.txt precise-security main restricted universe multiverse on the top in your /etc/apt/sources.list file should be all that is needed to make it automatically pick a mirror for you based on your geographical location.\nThe command line way\nThere are many command line tools available to find the best APT mirrors based on download speed. I have tested the following tools and they are working just fine in my Ubuntu 20.04 LTS desktop.\n Apt-select Apt-smart  apt-fast apt-fast: A shellscript wrapper for apt that speeds up downloading of packages.\n$ sudo apt-get install aria2 $ sudo add-apt-repository ppa:apt-fast/stable $ sudo apt-get update $ sudo apt-get -y install apt-fast $ sudo nano /etc/apt-fast.conf MIRRORS=('https://mirrors.bfsu.edu.cn/ubuntu/,https://mirrors.tuna.tsinghua.edu.cn/ubuntu/') apt-aria2 #!/bin/bash  ## apt-aria2: To help download packages faster via aria2, instead of wget. ## Author: Anjishnu Sarkar ## Version: 0.5 ## Acknowledgement: This script is a rewrite of the apt-fast script by ## Matt Parnell (admin@mattparnell.com) (http://www.mattparnell.com) ## Usage: Same as apt-get. Using the option \"-y\" always. ## BUG: ## *) If this script is interuppted, then next time aria2 starts downloading ## the same from the begining. Can be solved - something to do with .st file. ## TODO: ## *) Start installing via apt-get as soon as first package is downloaded ## and also keep downloading at the same time. This however might lead ## to dependencies not being satisfied. ## Initialization(s): Download=\"False\" Install=\"True\" Confirm=\"True\" UniqueName=\"$RANDOM\" Options=\"$@\" ## Checking for commands which requires download while test -n \"${1}\" do case \"${1}\" in install|upgrade|dist-upgrade|source|build-dep) ## Download Download=\"True\" ;; update|remove|autoremove|purge|dselect-upgrade|clean|autoclean|check) ## Anything other than download Download=\"False\" ;; -d) ## Download only (don't install) Install=\"False\" ;; -y) ## No need to ask for confirmation Confirm=\"False\" ;; *) ## Nothing to be done. If any wrong options/commands are given then ## let apt-get handle it. ;; esac shift done ## In case download is true if [ \"$Download\" == \"True\" ];then ## Installing pre-requisite(s): aria2 if ! which aria2c  /dev/null; then echo \"Aria2 not installed. Installing aria2 first via apt-get\" apt-get -y --force-yes install aria2 fi ArchiveDir=/var/cache/apt/archives/ cd ${ArchiveDir}/partial PrintUris=$(apt-get --yes --print-uris ${Options}) if [ $? -ne 0 ];then echo \"Aborting.\" exit 1 fi PackageInfo=$(echo \"$PrintUris\" | awk '/Reading package/,/After this operation/') # echo \"$PrintUris\" | grep ^\\' | cut -d\\' -f2  \"$UniqueName\"-uris.txt echo \"$PrintUris\" | grep \"http:\" | cut -d\\' -f2  \"$UniqueName\"-uris.txt NumberOfPackages=$(wc -l \"$UniqueName\"-uris.txt | awk '{print $1}') ## Print info echo \"$PackageInfo\" echo \"Number of packages to be downloaded: $NumberOfPackages\" ## Check whether package has already been installed or not InstallUpgradeMsg=$(echo \"$PackageInfo\" | grep \\  -e \"The following NEW packages will be installed:\" \\  -e \"The following packages will be upgraded:\") if [ -z \"$InstallUpgradeMsg\" ];then rm -f \"$UniqueName\"-uris.txt exit 0 fi ## In $InstallUpgradeMsg is not null, then proceed... ## If confirm is true if [ \"$Confirm\" == \"True\" ];then echo -n \"Do you want to continue [y|n]? \" read Ans case \"$Ans\" in y|yes|\"\") ;; n|no|*) echo \"Abort.\" rm -f \"$UniqueName\"-uris.txt exit 1 ;; esac fi if [ $NumberOfPackages -ne 0 ];then ## Downloading the packages echo \"Proceeding with downloading ...\" while read DebUrl do DebName=$(basename \"$DebUrl\") echo \"$DebName\" AptConf=\"/etc/apt/apt.conf\" if [ -f \"$AptConf\" ];then http_proxy=$(grep -i \"http::proxy\" \"$AptConf\" | cut -d \\\" -f2) fi if [ -n \"$http_proxy\" ];then echo \"Using proxy...\" aria2c -c -s 10 -j 10 --http-proxy=$http_proxy \"$DebUrl\" else echo \"Not using proxy...\" aria2c -c -s 10 -j 10 \"$DebUrl\" fi if [ $? -eq 0 ];then mv $DebName ${ArchiveDir} fi done \"$UniqueName\"-uris.txt fi rm -f \"$UniqueName\"-uris.txt # echo \"Installing...\" if [ \"$Install\" == \"True\" ];then apt-get -y --force-yes ${Options} fi else ## Cases when download is false apt-get ${Options} fi PPA 软件仓库是一组文件，其中包含各种软件及其版本的信息，以及校验和等其他一些详细信息。每个版本的 Ubuntu 都有自己的四个官方软件仓库：\n Main - Canonical 支持的自由开源软件。 Universe - 社区维护的自由开源软件。 Restricted - 设备的专有驱动程序。 Multiverse - 受版权或法律问题限制的软件。  你可以在 这里 看到所有版本的 Ubuntu 的软件仓库。你可以浏览并转到各个仓库。\n这些信息存储在系统的 /etc/apt/sources.list 文件中。如果查看此文件的内容，你就会看到里面有软件仓库的网址。# 开头的行将被忽略。\nUbuntu 不会在官方仓库中立即提供新版本的软件。他们需要一个步骤来检查此新版本的软件是否与系统兼容，从而可以确保系统的稳定性。这意味着它需要经过几周才能在 Ubuntu 上可用，在某些情况下，这可能需要几个月的时间。\n为获取最新版本的软件，需要使用 PPA，PPA (Personal Package Archives) 允许开发者上传要构建的 Ubuntu 源包，并通过 Launchpad 作为 apt 的软件仓库发布。\n通过如下命令添加 PPA 软件仓库并获取最新版本软件：\n$ sudo add-apt-repository  $ sudo apt-get update $ sudo apt-get install  当你使用 PPA 时，它不会更改原始的 sources.list 文件。相反，它在 /etc/apt/sources.d 目录中创建了两个文件，一个 .list 文件和一个带有 .save 后缀的备份文件。这是一种安全措施，可以确保添加的 PPA 不会和原始的 sources.list 文件弄混，它还有助于移除 PPA。\n开发人员为他们的软件创建的 PPA 称为官方 PPA。但有时，个人会创建由其他开发人员所创建的项目的 PPA。为什么会有人这样做？ 因为许多开发人员只提供软件的源代码。\n如果 PPA 不适用于你的系统版本，你可以点击应用程序 PPA 页面的 View package details，在这里，你可以单击软件包以显示更多详细信息，还可以在此处找到包的源代码和 DEB 文件。建议 使用 Gdebi 安装这些 DEB 文件 而不是通过软件中心，因为 Gdebi 在处理依赖项方面要好得多。\n就安全性而言，很少见到因为使用 PPA 之后你的 Linux 系统被黑客攻击或注入恶意软件。到目前为止，我不记得发生过这样的事件。官方 PPA 可以不加考虑的使用，使用非官方 PPA 完全是你自己的决定。根据经验，如果程序需要 sudo 权限，则应避免通过第三方 PPA 进行安装。\nSnap \u0026 Flatpak A fundamental difference between Snap and Flatpak\nFlatpak is designed to install and update “apps”; user-facing software such as video editors, chat programs and more.\nsnaps can install anything which contains a kernel, printer drivers, audio subsystems and more.\nSnap and Flatpak are the software behind two universal Linux app stores: the Snap Store and Flathub.\n讨论 openSUSE 群\nFlatpak使用bubblewrap来隔离应用程序，bwrap是非常轻量化的沙箱程序，因此攻击面极小。但bwrap需要用户对Linux程序工作方式有准确的了解（使用哪些syscall），Flatpak相当于充当了一个bwrap的前端帮助控制bwrap权限。\n目前Flatpak的问题在于seccomp权限太过广泛，但目前Flatpak维护者已经意识到了这个问题（注释：在他们踩了一次坑之后），已经计划打算解决了。\n另一个问题是程序请求的权限过于广泛，但这更多是一个决策问题而不是技术问题，而且你可以用Flatseal手动调整权限。\nFlatpak你不能用常规程序方式来理解，每个程序都是一个完全独立的空间，只有给予了权限才有对应访问权，也可以用Portals调用文件选择器来获得单独一个文件的完全访问权，Flatpak版的Steam是把所有程序配置文件放在~/.var/app里面了，类似安卓下面的分区存储做法。\nAppImage就只是个自挂载程序，自带的文件透明挂载到它自己的根文件系统下面，所以依然依赖主机的一部分库。所以是的，跟打包者用的系统有关系。\nFlatpak不是这种机制，每个Flatpak空间是完全空白的，需要打包者自己选择加入哪些东西，所以Flatpak跨发行版的兼容性也更好。\n良好打包的AppImage可以有很好的跨发行版兼容性，但是代价就是需要手工测试每个发行版下面的效果。在跨发行版兼容性这点上我更看好Flatpak。\n最后，不要跟我提Snap，我不想碰那个东西，也对它没有研究的兴趣。\nFlatpak确实有很多可取之处，或者不能说是Flatpak可取，而是Linux桌面软件生态现状决定了，只有更激进的手段才能改变现状。\nAppImage那种策略还是过于不痛不痒了，结果就是程序仅仅是被打包成一个个单文件，但背后的库依赖地狱、权限隔离问题一个都没解决。\n但AppImage作者的想法本来也不是靠AppImage颠覆，他是希望Linux能够重新恢复LSB，确保发行版之间的兼容性本身可靠而不是依赖Flatpak这些技术，就类似于Windows上的软件不需要什么沙箱模拟器，你几乎可以保证旧版本的软件能在新版本运行。\n其实也可以说明，微软那种在桌面上采取的策略，很可能难以在Linux社区里推广开来，微软那种做法，确保绝对的向下兼容性，不是谁都有精力来做的。\n比如说如果让微软来做Wayland，那微软根本就不会把Wayland做出来，而是把X11一直迭代、削减臃肿功能直到性能和现代化图形技术栈的性能相匹敌，同时确保向下兼容性。而最新一代的X11很可能和最早的X11已经彻底不一样了，甚至会有“检测程序版本然后自动匹配对应的X11功能”这些奇怪的兼容性策略出来。或许有一天微软会把新项目叫做Wayland，但这个改名也仅仅是营销目的而不是技术目的。\n毕竟LSB已经没了，Ubuntu甚至砍掉32位兼容性，也可以说明其实Linux这边并没有太多人在乎这问题。\n毕竟“反正源代码都在那，重新编译一遍不就好了吗”\nFedora 群\n空のあお, [2/28/22 8:25 PM] 软件有不同版本的依赖 这些依赖很难共存 有些旧版依赖还有更旧的依赖 不说二进制兼容，有些连源码兼容都搞不定 就算搞定了，一段时间过后依赖升级了，还是得坏 flatpak的做法是维护abi稳定的qt和gtk两大ui库和必要桌面库的runtime，用来公用 通过容器隔离app，让每个app自己构建所需的特定依赖到容器里\n竹林里有冰, [2/28/22 8:33 PM] sandbox他是用bubblewrap实现的吧，你可以直接使用bubblewrap，应该一样可以做到他的沙盒化，更小巧一点 bubblewrap的缺点就是需要针对每个程序写上配置，除了有点麻烦其他倒还不错\nNeomonk Zen, [2/28/22 8:36 PM] 也不知flatpak的软件仓库，有没什么审核机制来防止恶意软件，如果没有的话，那还蛮可怕的，想想Chrome和Android的软件市场，都有很多恶意软件\nRobin Lee, [2/28/22 8:39 PM] 没有深入的审核，跟各大发行版的官方包差不多，但flatpak可以限制应用权限\n在 Ubuntu 上使用 Flatpak The official Flatpak PPA is the recommended way to install Flatpak. To install it, run the following in a terminal:\n$ sudo add-apt-repository ppa:flatpak/stable $ sudo apt update $ sudo apt install flatpak Flathub is the best place to get Flatpak apps. To enable it, run:\n$ flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo To complete setup, restart your system. Now all you have to do is install some apps!\nQuestions snap “canonical-livepatch” has “install-snap” change in progress\nSnap 包是 Ubuntu 16.04 LTS 发布时引入的新应用格式包。目前已流行在很多 Linux 发行版上。并且可以很方便地安装常用软件，如 VLC、Sublime Text、VSCode、Node、WPS等\n当你在安装完 Snap 后，你会发现在在根目录下会出现如 /dev/loop0 的挂载点，这些挂载点正是 Snap 软件包的目录。\n  原因是软件之前安装了一次，只是安装失败。\n$ snap changessnap abort 5\t## 5 为安装失败软件的 ID   现在重新安装\n  一些软件最好在官网下载或在 Snap 中下载，官方 Repository 可能并不新，比如 VLC。\ntasksel: Install Group Software 安装\n$ sudo apt install tasksel list tasks\n$ tasksel --list-tasks displays description\n$ tasksel --task-desc dns-server install\n$ sudo apt install dns-server pacstall An AUR-inspired package manager for Ubuntu\nAppImage Linux apps that run anywhere\n包管理器的进化 今天，每个可计算设备都会使用某种软件来完成预定的任务。在软件开发的上古时期，为了找出软件中的 bug 和其它缺陷，软件会被严格的测试。在近十年间，软件被通过互联网来频繁分发，以试图通过持续不断的安装新版本的软件来解决软件的缺陷问题。在很多情况下，每个独立的应用软件都有其自带的更新器。而其它一些软件则让用户自己去搞明白如何获取和升级软件。\nLinux 较早采用了维护一个中心化的软件仓库来发布软件更新这种做法，用户可以在这个软件仓库里查找并安装软件。在这篇文章里， 笔者将回顾在 Linux 上的如何进行软件安装的历史，以及现代操作系统如何保持更新以应对软件安全漏洞（CVE）不断的曝光。\n手动安装软件 曾几何时，软件都是通过 FTP 或邮件列表（LCTT 译注：即通过邮件列表发布源代码的补丁包）来分发的（最终这些发布方式在互联网的迅猛发展下都演化成为一个个现今常见的软件发布网站）。（一般在一个 tar 文件中）只有一个非常小的文件包含了创建二进制的说明。你需要做的是先解压这个包，然后仔细阅读当中的 README 文件， 如果你的系统上恰好有 GCC（LCTT 译注：GNU C Compiler）或者其它厂商的 C 编译器的话，你得首先运行 ./configure 脚本，并在脚本后添加相应的参数，如库函数的路径、创建可执行文件的路径等等。除此之外，这个配置过程也会检查你操作系统上的软件依赖是否满足安装要求。如果缺失了任何主要的依赖，该配置脚本会退出不再继续安装，直到你满足了该依赖。如果该配置脚本正常执行完毕，将会创建一个 Makefile 文件。\n当有了一个 Makefile 文件时， 你就可以接下去执行 make 命令（该命令由你所使用的编译器提供）。make 命令也有很多参数，被称为 make 标识flag，这些标识能为你的系统优化最终生成出来的二进制可执行文件。在计算机世界的早期，这些优化是非常重要的，因为彼时的计算机硬件正在为了跟上软件迅速的发展而疲于奔命。今日今时，编译标识变得更加通用而不是为了优化哪些具体的硬件型号，这得益于现代硬件和现代软件相比已经变得成本低廉，唾手可得。\n最后，在 make 完成之后， 你需要运行 make install （或 sudo make install）（LCTT 译注：依赖于你的用户权限） 来“真正”将这个软件安装到你的系统上。可以想象，为你系统上的每一个软件都执行上述的流程将是多么无聊费时，更不用说如果更新一个已经安装的软件将会多复杂，多么需要精力投入。（LCTT 译注：上述流程也称 CMMI 安装， 即Configure、Make、Make Install）\n软件包 package（LCTT 译注：下文简称“包”）这个概念是用来解决在软件安装、升级过程中的复杂性的。包将软件安装升级中需要的多个数据文件合并成一个单独的文件，这将便于传输和（通过压缩文件来）减小存储空间（LCTT 译注：减少存储空间这一点在现在已经不再重要），包中的二进制可执行文件已根据开发者所选择的编译标识预编译。包本身包括了所有需要的元数据，如软件的名字、软件的说明、版本号，以及要运行这个软件所需要的依赖包等等。\n不同流派的 Linux 发行版都创造了它们自己的包格式，其中最常用的包格式有：\n .deb：这种包格式由 Debian、Ubuntu、Linux Mint 以及其它的变种使用。这是最早被发明的包类型。 .rpm：这种包格式最初被称作红帽包管理器Red Hat Package Manager（LCTT 译注： 取自英文的首字母）。使用这种包的 Linux 发行版有 Red Hat、Fedora、SUSE 以及其它一些较小的发行版。 .tar.xz：这种包格式只是一个软件压缩包而已，这是 Arch Linux 所使用的格式。  尽管上述的包格式自身并不能直接管理软件的依赖问题，但是它们的出现将 Linux 软件包管理向前推进了一大步。\n软件仓库 多年以前（当智能电话还没有像现在这样流行时），非 Linux 世界的用户是很难理解软件仓库的概念的。甚至今时今日，大多数完全工作在 Windows 下的用户还是习惯于打开浏览器，搜索要安装的软件（或升级包），下载然后安装。但是，智能电话传播了软件“商店”（LCTT 译注： 对应 Linux 里的软件仓库）这样一个概念。智能电话用户获取软件的方式和包管理器的工作方式已经非常相近了。些许不同的是，尽管大多数软件商店还在费力美化它的图形界面来吸引用户，大多数 Linux 用户还是愿意使用命令行来安装软件。总而言之，软件仓库是一个中心化的可安装软件列表，上面列举了在当前系统中预先配置好的软件仓库里所有可以安装的软件。\n包管理器 包管理器用来和相应的软件仓库交互，获取软件的相应信息。下面对流行做一个简短介绍。\n基于 PRM 包格式的包管理器 更新基于 RPM 的系统，特别是那些基于 Red Hat 技术的系统，有着非常有趣而又详实的历史。实际上，现在的 YUM 版本（用于 企业级发行版）和 DNF（用于社区版）就融合了好几个开源项目来提供它们现在的功能。\nRed Hat 最初使用的包管理器，被称为 RPM（红帽包管理器Red Hat Package Manager），时至今日还在使用着。不过，它的主要作用是安装本地的 RPM 包，而不是去在软件仓库搜索软件。后来开发了一个叫 up2date 的包管理器，它被用来通知用户包的最新更新，还能让用户在远程仓库里搜索软件并便捷的安装软件的依赖。尽管这个包管理器尽职尽责，但一些社区成员还是感觉 up2date 有着明显的不足。\n现在的 YUM 来自于好几个不同社区的努力。1999-2001 年一群在 Terra Soft Solution 的伙计们开发了Yellowdog Updater（YUP），将其作为 Yellow Dog Linux 图形安装器的后端。杜克大学Duke University喜欢这个主意就决定去增强它的功能，它们开发了Yellowdog Updater, Modified（YUM），这最终被用来帮助管理杜克大学的 Red Hat 系统。Yum 壮大的很快，到 2005 年，它已经被超过一半的 Linux 市场所采用。今日，几乎所有的使用 RPM 的的 Linux 都会使用 YUM 来进行包管理（当然也有一些例外）。\nDandified Yum（DNF）是 YUM 的下一代接班人。从 Fedora 18 开始被作为包管理器引入系统，不过它并没有被企业版所采用，所以它只在 Fedora（以及变种）上占据了主导地位。DNF 的用法和 YUM 几乎一模一样，它主要是用来解决性能问题、晦涩无说明的API、缓慢/不可靠的依赖解析，以及偶尔的高内存占用。DNF 是作为 YUM 的直接替代品来开发的，因此这里笔者就不重复它的用法了，你只用简单的将 yum 替换为 dnf 就行了。\nZypper 是用来管理 RPM 包的另外一个包管理器。这个包管理器主要用于 SUSE（和 openSUSE），在MeeGo、Sailfish OS、Tizen 上也有使用。它最初开发于 2006 年，已经经过了多次迭代。除了作为系统管理工具 YaST 的后端和有些用户认为它比 YUM 要快之外也没有什么好多说的。\n基于 Debian 的包管理器 作为一个现今仍在被积极维护的最古老的 Linux 发行版之一，Debian 的包管理系统和基于 RPM 的系统的包管理系统非常类似。它使用扩展名为 “.deb” 的包，这种文件能被一个叫做 dpkg 的工具所管理。dpgk 同 rpm 非常相似，它被设计成用来管理在存在于本地（硬盘）的包。它不会去做包依赖关系解析（它会做依赖关系检查，不过仅此而已），而且在同远程软件仓库交互上也并无可靠的途径。为了提高用户体验并便于使用，Debian 项目开始了一个软件项目：Deity，最终这个代号被丢弃并改成了现在的 Advanced Pack Tool（APT）。\n在 1998 年，APT 测试版本发布（甚至早于 1999 年的 Debian 2.1 发布），许多用户认为 APT 是基于 Debian 系统标配功能之一。APT 使用了和 RPM 一样的风格来管理仓库，不过和 YUM 使用单独的 .repo 文件不同，APT 曾经使用 /etc/apt/sources.list 文件来管理软件仓库，后来的变成也可以使用 /etc/apt/sources.d 目录来管理。如同基于 RPM 的系统一样，你也有很多很多选项配置来完成同样的事情。你可以编辑和创建前述的文件，或者使用图形界面来完成上述工作（如 Ubuntu 的“Software \u0026 Updates”）。\n现今大多数的 Ubuntu 教程里都径直使用了 apt。 单独一个 apt 设计用来实现那些最常用的 APT 命令的。apt 命令看上去是用来整合那些被分散在 apt-get、apt-cache 以及其它一些命令的的功能的。它还加上了一些额外的改进，如色彩、进度条以及其它一些小功能。\n基于 Arch 的包管理器 Arch Linux 使用称为 packman 的包管理器。和 .deb 以及 .rpm 不同，它使用更为传统的 LZMA2 压缩包形式 .tar.xz 。这可以使 Arch Linux 包能够比其它形式的压缩包（如 gzip）有更小的尺寸。自从 2002 年首次发布以来， pacman 一直在稳定发布和改善。使用它最大的好处之一是它支持 Arch Build System，这是一个从源代码级别构建包的构建系统。该构建系统借助一个叫 PKGBUILD 的文件，这个文件包含了如版本号、发布号、依赖等等的元数据，以及一个为编译遵守 Arch Linux 需求的包所需要的带有必要的编译选项的脚本。而编译的结果就是前文所提的被 pacman 所使用的 .tar.xz 的文件。\n上述的这套系统技术上导致了 Arch User Respository（AUR）的产生，这是一个社区驱动的软件仓库，仓库里包括有 PKGBUILD 文件以及支持补丁或脚本。这给 Arch Linux 带了无穷无尽的软件资源。最为明显的好处是如果一个用户（或开发者）希望他开发的软件能被广大公众所使用，他不必通过官方途径去在主流软件仓库获得许可。而不利之处则是它必须将依赖社区的流程，类似于 Docker Hub、 Canonical 的 Snap Packages（LCTT 译注： Canonical 是 Ubuntu 的发行公司），或者其它类似的机制。\n有很多特定于 AUR 的包管理器能被用来从 AUR 里的 PGKBUILD 文件下载、编译、安装。其中 yaourt 和 pacaur 颇为流行。不过，这两个项目已经被 Arch Wiki 列为“不继续开发以及有已知的问题未解决”。因为这个原因，这里直接讨论 aurman，除了会搜索 AUR 以及包含几个有帮助的（其实很危险）的选项之外，它的工作机制和 pacman 极其类似。\nconda 简介 Conda 是一个开源的软件包管理系统和环境管理系统，用于安装多个版本的软件包及其依赖关系，并在它们之间轻松切换。 Conda 是为 Python 程序创建的，适用于 Linux，OS X 和 Windows，也可以打包和分发其他软件。\n安装 conda分为anaconda和miniconda。anaconda是包含一些常用包的版本（这里的常用不代表你常用），miniconda则是精简版，需要啥装啥，所以推荐使用miniconda。\nminiconda官网：https://conda.io/miniconda.html\n选择适合自己的版本下载：\n$ wget -c https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh 这里选择的是latest-Linux版本，所以下载的程序会随着python的版本更新而更新。\n安装：\n$ chmod 777 Miniconda3-latest-Linux-x86_64.sh $ bash Miniconda3-latest-Linux-x86_64.sh 加不加入环境变量都可以。所谓的会污染环境等等问题可能都是将大量的软件直接安装在conda的base环境中引起的，只要养成好的使用习惯，灵活使用conda create 命令将不同的软件安装到自己单独的虚拟环境中就可以了。把conda这条蟒蛇关进一个一个的笼子里，才能更好的为我们的科研服务~\n添加频道 这个道理跟家里的电视机是一样一样的，安装conda就相当于买了一台电视机，但是有电视了不意味着你就能看节目了，你要手动添加频道才能看你想看的电视节目。\n添加清华的镜像channels：\n$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ $ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ $ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/ $ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/ 为了分担清华源镜像的压力，北京外国语大学也开启了镜像站点，同样是由清华TUNA团队维护的，如果有小伙伴遇到清华源速度很慢的情况的话，可以考虑换成北外的镜像。\n$ conda config --add channels https://mirrors.bfsu.edu.cn/anaconda/cloud/bioconda/ $ conda config --add channels https://mirrors.bfsu.edu.cn/anaconda/cloud/conda-forge/ $ conda config --add channels https://mirrors.bfsu.edu.cn/anaconda/pkgs/free/ $ conda config --add channels https://mirrors.bfsu.edu.cn/anaconda/pkgs/main/ 显示安装的频道\n$ conda config --set show_channel_urls yes 查看已经添加的channels\n$ conda config --get channels 已添加的channel在哪里查看\n$ vim ~/.condarc 软件包管理 $ conda install gatk 搜索安装包 $ conda search gatk 安装完成后，可以用“which 软件名”来查看该软件安装的位置：\n$ which gatk 安装特定版本 $ conda install 软件名=版本号 $ conda install gatk=3.7 这时conda会先卸载已安装版本，然后重新安装指定版本。\n查看已安装软件 $ conda list 更新指定软件 $ conda update gatk 卸载指定软件 $ conda remove gatk 环境管理 退出conda环境 退出也很简单，之前我们是. ./activate 或者 (. ~/miniconda3/bin/activate)现在退出只要:\n$ . ./deactivate # 或者用  $ conda deactivate 就退出当前的环境了\n创建conda环境 之前创建的时候显示的是（base）这是conda的基本环境，有些软件依赖的是python2的版本，当你还是使用你的base的时候你的base里的python会被自动降级，有可能会引发别的软件的报错，所以，可以给一些特别的软件一些特别的关照，比如创建一个单独的环境。\n在conda环境下，输入conda env list（或者输入conda info --envs也是一样滴）查看当前存在的环境：\n$ conda env list 创建一个新的环境\n$ conda create -n python2 python=2  -n: 设置新的环境的名字 python=2 指定新环境的python的版本，非必须参数 这里也可以用一个-y参数，可以直接跳过安装的确认过程。  conda会创建一个新的python2的环境，并且会很温馨的提示你只要输入conda activate python2就可以启动这个环境了。\n删除环境 $ conda remove -n myenv --all 重命名环境 实际上conda并没有提供这样的功能，但是可以曲线救国，原理是先克隆一个原来的环境，命名成想要的名字，再把原来的环境删掉即可\n接下来演示把一个原来叫做py2的环境重新命名成python2：\n$ conda create -n python2 --clone py2 $ conda remove -n py2 --all 自动更新 Ubuntu 默认的配置会每天自动安装安全更新而忽略其它包的更新。\n更新机制 Ubuntu 默认定义了 4 个 systemd unit 执行更新任务，它们分别是：\n/lib/systemd/system/apt-daily-upgrade.service /lib/systemd/system/apt-daily-upgrade.timer /lib/systemd/system/apt-daily.service /lib/systemd/system/apt-daily.timer 中的 apt-daily.timer 和 apt-daily-upgrade.timer 是两个触发器，分别在每天指定的时间触发 apt-daily.service 和 apt-daily-upgrade.service。这两个 service 的类型都是 oneshot，意思是当任务完成后 service 进程退出。这两个 service 其实调用的是同一个脚本： /usr/lib/apt/apt.systemd.daily。apt-daily.service 为脚本传入参数 “update”，其功能为检查系统的更新并下载对应的更新包。apt-daily-upgrade.service 为脚本传入参数 “install”，其功能为安装更新并删除缓存在本地的更新包。\napt-daily.timer 默认每天触发两次，分别为 6 点和 18 点，主要是为了缓解服务器端的下载压力。我们可以根据自身业务的特点设置合适的触发时间。\napt-daily-upgrade.service 默认每天在 6 点触发一次，我们也可以设置为其它时间，比如午夜。\napt.systemd.daily /usr/lib/apt/apt.systemd.daily 脚本负责完成与更新相关的一系列工作，这些工作主要分为两大块：\n 检查更新并下载更新包 安装更新并清理更新包  apt.systemd.daily 脚本中调用 apt-config 命令从 /etc/apt/apt.conf.d/10periodic 文件和 /etc/apt/apt.conf.d/20auto-upgrades 读中取配变量，并根据这些变量的值来控制系统的更新策略。下面我们介绍几个比较重要的配置项。\n隔多少天执行一次 apt-get update，默认是 1 天，0 表示不执行该操作：\nAPT::Periodic::Update-Package-Lists \"1\"; 隔多少天执行一次 apt-get upgrade –download-only 下载更新包，0 表示不执行该操作：\nAPT::Periodic::Download-Upgradeable-Packages \"0\"; 下载的更新版被缓存在目录 /var/cache/apt/archives/ 中，执行升级操作时直接从缓存目录中读取包文件而不是从网络上下载。\n隔多少天执行一次 apt-get autoclean 清除无用的更新包，0 表示不执行该操作：\nAPT::Periodic::AutocleanInterval \"0\"; 隔多少天执行一次 Unattended-Upgrade 执行系统安全更新(或者所有包的更新)，0 表示不执行该操作：\nAPT::Periodic::Unattended-Upgrade \"1\"; 通过这些配置，我们可以控制自动更新的频率和行为。注意，到目前为止的配置还只能安装系统的安全更新，如果要想安装所有包的更新还需要其它的配置。\n在继续介绍后面的内容前，让我们先来了解一下 apt.systemd.daily 脚本中用到的 apt-config 命令和 apt.systemd.daily 脚本依赖的配置文件。\napt-config 命令\napt-config 是一个被 APT 套件使用的内部命令，使用它可以在脚本中提取 /etc/apt/apt.conf 目录下配置文件中的信息。\n比如，如果要在脚本中获取 APT::Periodic::Update-Package-Lists 的设置，可以使用下面的代码：\n#!/bin/bash ABC=0 eval $(apt-config shell ABC APT::Periodic::Update-Package-Lists) echo ${ABC} 此时脚本变量 ABC 中保存的就是 APT::Periodic::Update-Package-Lists 的值。\n10periodic 和 20auto-upgrades\n/etc/apt/apt.conf.d/10periodic 是 update-notifier-common 的配置文件：\n$ dpkg-query -S /etc/apt/apt.conf.d/10periodic update-notifier-common: /etc/apt/apt.conf.d/10periodic 在 ubuntu 16.04 和 18.04 中，这两个文件的默认内容是一样的。apt.systemd.daily 脚本在注释中说我们可以通过 /etc/apt/apt.conf.d/10periodic 文件自定义相关的变量值，它通过 get-config 命令来获得这些变量的值。但是测试的结果是 /etc/apt/apt.conf.d/20auto-upgrades 文件中的变量会覆盖 /etc/apt/apt.conf.d/10periodic 文件中的变量。看来是 get-config 命令根据文件名称的顺序，排在后面的文件中的变量会覆盖前面文件中的变量。\n在 desktop 版本中，通过 GUI 程序修改相关的变量，这两个文件都会被修改并保持一致，所以在 server 版中我们最好也同时修改这两个文件并保持其内容一致。\nunattended-upgrades Ubuntu 实际上是通过 unattended-upgrades 命令来自动安装更新的。Ubuntu 16.04/18.04 默认安装了这个包，如果碰到没有安装的情况你还可以通过下面的命令自行安装：\n$ sudo apt install unattended-upgrades unattended-upgrades 的配置文件为 /etc/apt/apt.conf.d/50unattended-upgrades。\n注意，unattended-upgrades 不仅能够安装系统的安全更新，还可以安装所有包的更新。但是默认的配置只安装安全更新，我们可以通过配置项让 unattended-upgrades 安装所有的包更新或者只安装安全更新。\nunattended-upgrades 命令被设计为通过 cron 定时执行系统更新，但在 Ubuntu 16.04/18.04 中是通过 systemd 的 timer unit 定时触发 service unit 执行的。\nunattended-upgrades 命令的日志文件存放在 /var/log/unattended-upgrades 目录下。\nunattended-upgrade 命令常见的用法之一是检查系统是否有更新：\n$ sudo unattended-upgrade --dry-run 另一种用法是安装更新：\n$ sudo unattended-upgrade 在 apt.systemd.daily 脚本中执行 unattended-upgrade 命令时，由于更新包已经提前下载到缓存目录了(/var/cache/apt/archives)，所以直接它直接使用缓存中的更新包。\n配置文件 50unattended-upgrades\n50unattended-upgrades 文件中的默认配置只是安装安全更新：\nUnattended-Upgrade::Allowed-Origins { \"${distro_id}:${distro_codename}\"; \"${distro_id}:${distro_codename}-security\"; \"${distro_id}ESM:${distro_codename}\"; // \"${distro_id}:${distro_codename}-updates\"; // \"${distro_id}:${distro_codename}-proposed\"; // \"${distro_id}:${distro_codename}-backports\"; }; 如果要自动安装所有包的更新，只要取消下面行的注释就行了：\n\"${distro_id}:${distro_codename}-updates\"; 我们还可以通过黑名单的方式指定不更新哪些包：\nUnattended-Upgrade::Package-Blacklist { \"vim\"; \"libc6\"; \"libc6-dev\"; \"libc6-i686\"; }; 下面的配置项指定在更新后移除无用的包：\nUnattended-Upgrade::Remove-Unused-Kernel-Packages \"true\"; Unattended-Upgrade::Remove-Unused-Dependencies \"true\"; 有些更新需要重启系统，而默认的配置是不重启系统的。下面的配置允许重启系统(更新完成后，如果需要重启，立即重启系统)：\nUnattended-Upgrade::Automatic-Reboot \"true\"; 但是多数情况下我们更期望指定一个时间让系统重启(如果需要重启，在下面配置中指定的时间重启系统)：\nUnattended-Upgrade::Automatic-Reboot-Time \"02:38\"; 在系统更新的过程中发生了错误怎么办？当然是通知管理员啦！下面的配置在发生错误时给管理员发送邮件：\nUnattended-Upgrade::Mail \"user@example.com\"; Unattended-Upgrade::MailOnlyOnError \"true\"; 注意：如果要向外网发送邮件，需要安装 mailx 等工具。\n关闭自动更新 如果你的主机运行在封闭的环境中，并且无法连接到有效的更新源，此时可以选择关闭自动更新功能。首选的方法是停止相关的服务：\n$ sudo systemctl stop apt-daily.service $ sudo systemctl stop apt-daily.timer $ sudo systemctl stop apt-daily-upgrade.service $ sudo systemctl stop apt-daily-upgrade.timer $ sudo systemctl disable apt-daily.service $ sudo systemctl disable apt-daily.timer $ sudo systemctl disable apt-daily-upgrade.service $ sudo systemctl disable apt-daily-upgrade.timer 或者修改自动更新程序的配置文件也可以，同时更新 /etc/apt/apt.conf.d/10periodic 和 /etc/apt/apt.conf.d/20auto-upgrades：\nAPT::Periodic::Update-Package-Lists \"1\"; APT::Periodic::Unattended-Upgrade \"1\"; 改为\nAPT::Periodic::Update-Package-Lists \"0\"; APT::Periodic::Unattended-Upgrade \"0\"; LVM 在对磁盘分区的大小进行规划时，往往不能确定这个分区要使用的空间的大小。而使用 fdisk、gdisk 等工具对磁盘分区后，每个分区的大小就固定了。如果分区设置的过大，就白白浪费了磁盘空间；如果分区设置的过小，就会导致空间不够用的情况出现。对于分区过小的问题，可以从新划分磁盘的分区，或者通过软连接的方式将此分区的目录链接到另外一个分区。这样虽然能够临时解决问题，但是给管理带来了麻烦。类似的问题可以通过 LVM 来解决。\nLVM 是什么 LVM 是 Logical Volume Manager 的缩写，中文一般翻译为 “逻辑卷管理”，它是 Linux 下对磁盘分区进行管理的一种机制。LVM 是建立在磁盘分区和文件系统之间的一个逻辑层，系统管理员可以利用 LVM 在不重新对磁盘分区的情况下动态的调整分区的大小。如果系统新增了一块硬盘，通过 LVM 就可以将新增的硬盘空间直接扩展到原来的磁盘分区上。\nLVM 的优点如下：\n 文件系统可以跨多个磁盘，因此大小不再受物理磁盘的限制。 可以在系统运行状态下动态地扩展文件系统大小。 可以以镜像的方式冗余重要数据到多个物理磁盘上。 可以很方便地导出整个卷组，并导入到另外一台机器上。  LVM 也有一些缺点：\n 在从卷组中移除一个磁盘的时候必须使用 reducevg 命令(这个命令要求root权限，并且不允许在快照卷组中使用)。 当卷组中的一个磁盘损坏时，整个卷组都会受影响。 因为增加了一个逻辑层，存储的性能会受影响。  LVM 的优点对服务器的管理非常有用，但对于桌面系统的帮助则没有那么显著，所以需要我们根据使用的场景来决定是否应用 LVM。\nLVM 中的基本概念 通过 LVM 技术，可以屏蔽掉磁盘分区的底层差异，在逻辑上给文件系统提供了一个卷的概念，然后在这些卷上建立相应的文件系统。下面是 LVM 中主要涉及的一些概念。\n **物理存储设备(Physical Media)：**指系统的存储设备文件，比如 /dev/sda、/dev/sdb 等。 **PV(物理卷 Physical Volume)：**指硬盘分区或者从逻辑上看起来和硬盘分区类似的设备(比如 RAID 设备)。 **VG(卷组 Volume Group)：**类似于非 LVM 系统中的物理硬盘，一个 LVM 卷组由一个或者多个 PV(物理卷)组成。 **LV(逻辑卷 Logical Volume)：**类似于非 LVM 系统上的磁盘分区，LV 建立在 VG 上，可以在 LV 上建立文件系统。 **PE(Physical Extent)：**PV(物理卷)中可以分配的最小存储单元称为 PE，PE 的大小是可以指定的。 **LE(Logical Extent)：**LV(逻辑卷)中可以分配的最小存储单元称为 LE，在同一个卷组中，LE 的大小和 PE 的大小是一样的，并且一一对应。  可以这么理解，LVM 是把硬盘的分区分成了更小的单位(PE)，再用这些单元拼成更大的看上去像分区的东西(PV)，进而用 PV 拼成看上去像硬盘的东西(VG)，最后在这个新的硬盘上创建分区(LV)。文件系统则建立在 LV 之上，这样就在物理硬盘和文件系统中间添加了一层抽象(LVM)。下图大致描述了这些概念之间的关系：\n对上图中的结构做个简单的介绍：\n两块物理硬盘 A 和 B 组成了 LVM 的底层结构，这两块硬盘的大小、型号可以不同。PV 可以看做是硬盘上的分区，因此可以说物理硬盘 A 划分了两个分区，物理硬盘 B 划分了三个分区。然后将前三个 PV 组成一个卷组 VG1，后两个 PV 组成一个卷组 VG2。接着在卷组 VG1 上划分了两个逻辑卷 LV1 和 LV2，在卷组 VG2 上划分了一个逻辑卷 LV3。最后，在逻辑卷 LV1、LV2 和 LV3 上创建文件系统，分别挂载在 /usr、/home 和 /var 目录。\nLVM 工具 在安装 Linux 时，如果选择使用 LVM 创建分区，就会安装 LVM 相关的工具。当前这个软件包的名称为 lvm2，其中包含了大量 LVM 工具。比如单是查看 LVM 相关实体状态的命令就有如下一些：\n$ sudo pvscan $ sudo pvs $ sudo pvdisplay $ sudo vgscan $ sudo vgs $ sudo vgdisplay $ sudo lvscan $ sudo lvs $ sudo lvdisplay 如果安装系统时没有默认安装 LVM 工具包，可以通过下面的命令安装它们：\n$ sudo apt update $ sudo apt install lvm2 接下来我们通过例子来演示如何使用 LVM 来一步步的创建出逻辑卷(LV)，然后在 LV 上创建文件系统并挂载到 Linux 系统中。\n使用 gdisk 对物理磁盘进行分区 目前常见的磁盘分区格式有两种，MBR 分区和 GPT 分区。\nMBR 分区，MBR 的意思是 “主引导记录”。MBR 最大支持 2TB 容量，在容量方面存在着极大的瓶颈。\nGPT 分区，GPT 意为 GUID 分区表，它支持的磁盘容量比 MBR 大得多。这是一个正逐渐取代 MBR 的新标准，它是由 UEFI 辅住而形成的，将来 UEFI 用于取代老旧的 BIOS，而 GPT 则取代老旧的 MBR。\n使用 fdisk 工具创建 MBR 磁盘分区，而 gdisk 是 Linux 系统中 GPT 格式的磁盘分区管理工具。\n假设我们的 Linux 系统中增加了一块新的磁盘，系统对应的设备名为 /dev/sdb，下面我们通过 gdisk 命令对这个磁盘进行分区。\n在用 gdisk 命令对磁盘分区前，我们先用 parted 命令查看 /dev/sdb 当前的分区情况：\n$ sudo parted /dev/sdb print 下面通过 gdisk 命令创建分区：\n$ sudo gdisk /dev/sdb 通过 p 命令可以查看磁盘当前的状态：输出中的前几行是磁盘的基本信息，比如总大小，一共有多少个扇区(sector)，每个扇区的大小，当前剩余的空间等等。\n然后是已经存在的分区信息：\n 第一列 Number 显示了分区的编号，比如 1 号指 /dev/sdb1。 第二列 Start 表示磁盘分区的起始位置。 第三列 End 表示磁盘分区的结束位置。 第四列 Size 显示分区的容量。 第五列 Code 和第六列 Name 显示分区类型的 ID和名称，比如 Linux filesystem 为 8300，Linux swap 为 8200，Linux LVM 为 8e00。  通过 n 命令来创建新分区：\n分区编号和开始/结束的扇区都直接通过回车选择默认值，这样所有的磁盘空间都划分到了一个分区中，然后输入 8e00 说明我们要创建的分区类型为 Linux LVM。最后输入 w 命令并确认执行分区操作。分区成功后可通过 p 命令查看我们创建的分区的信息。\n创建物理卷 PV # pvcreate DEVICE 现在我们可以基于磁盘分区 /dev/sdb1 来创建 LVM 物理卷(LV)，可以通过 pvcreate 命令来完成：\n$ sudo pvcreate /dev/sdb1 此时 /dev/sdb1 已经完成了从磁盘分区到 PV 的华丽转身！注意上面的命令，磁盘分区被直接转换成了 PV，连名称都没有变化！我们可以通过 pvs 命令查看 /dev/sdb1，目前它还没有被加入到 VG 中。\n创建卷组 VG # vgcreate    ... 基于一个或多个 PV，可以创建 VG。我们使用刚才创建的 PV /dev/sdb1 来创建一个名称为 nickvg 的 VG：\n$ sudo vgcreate -s 32G nickvg /dev/sdb1 注意 vgcreate 命令中的 -s 选项，它指定了 PE(Physical Extent) 的大小。可以通 vgs 命令观察 VG 的信息：\n$ sudo vgs nickvg 如果目标 VG 已经存在，则使用 vgextend 把 PV 加入到 VG 中即可。\n# vgextend   创建逻辑卷 LV # lvcreate -L   -n  有了 VG 就可以创建逻辑卷 LV 了，lvcreate 命令用来创建 LV，让我们在前面创建的 nickvg 上创建名称为 nicklv00 的 LV：\n$ sudo lvcreate -L 15G -n nicklv00 nickvg 选项 -L 指定新建 LV 的容量，这里是 15G；选项 -n 则指定新建 LV 的名称，这里为 nicklv00。可以通过 lvs 命令观察 LV 的信息，注意需要同时指出 LV 所在的 VG：\n$ sudo lvs nickvg/nicklv00 如果你想让要创建的逻辑卷拥有卷组（VG）的所有未使用空间，请使用以下命令：\n# lvcreate -l +100%FREE  -n  格式化逻辑卷(创建文件系统) # mkfs. /dev/mapper/- # mount /dev/mapper/-  当我们创建 LV nickvg/nicklv00 时，其实是创建了名称为 /dev/nickvg/nicklv00 的设备文件。\n现在你的逻辑卷应该已经在/dev/mapper/和/dev/YourVolumeGroupName中了。\n现在我们来格式化这个逻辑卷(在该 LV 上创建文件系统)，目标为比较常见的 ext4 格式：\n$ sudo mkfs.ext4 /dev/nickvg/nicklv00 然后创建个目录，比如 /home/doc，并把新建的文件系统挂载到这个目录上：\n$ sudo mkdir /home/doc $ sudo mount /dev/nickvg/nicklv00 /home/doc 最后可以通过 df 命令查看这个文件系统的使用情况。\n开机自动挂载 编辑 /etc/fstab 文件：\n$ sudo vim /etc/fstab 把下面的行添加的文件末尾并保存文件：\n/dev/mapper/nickvg-nicklv00 /home/doc ext4 defaults 0 2 调整逻辑卷 同时缩小逻辑卷和其文件系统\n 注意： 只有ext2，ext3，ext4，ReiserFS和 XFS 文件系统支持以下操作。\n 将MyVolGroup组中的逻辑卷mediavol扩大10GiB，并同时扩大其文件系统：\n# lvresize -L +10G --resizefs MyVolGroup/mediavol 将MyVolGroup组中的逻辑卷mediavol大小调整为15GiB，并同时调整其文件系统：\n# lvresize -L 15G --resizefs MyVolGroup/mediavol 将卷组中的所有剩余空间分配给mediavol：\n# lvresize -l +100%FREE --resizefs MyVolGroup/mediavol 重命名卷 重命名卷组\n要重命名一个卷组，请使用vgrename(8)命令。\n可使用下面的任意一条命令将卷组vg02重命名为my_volume_group\n# vgrename /dev/vg02 /dev/my_volume_group # vgrename vg02 my_volume_group 重命名逻辑卷\n要重命名一个逻辑卷，请使用lvrename(8)命令。\n可使用下面的任意一条命令将vg02组中的逻辑卷lvold重命名为lvnew.\n# lvrename /dev/vg02/lvold /dev/vg02/lvnew # lvrename vg02 lvold lvnew 移除逻辑卷 警告： 在移除逻辑卷之前，请先备份好数据以免丢失！\n首先，找到你所要移除的逻辑卷的名称。你可以使用以下命令来查看系统的所有逻辑卷：\n# lvs 接下来，找到你所要移除的逻辑卷的挂载点\n$ lsblk 并卸载它：\n# umount / 最后，使用以下命令来移除逻辑卷：\n# lvremove / 例如：\n# lvremove VolGroup00/lvolhome 请输入y来确定你要执行移除逻辑卷操作。\n此外，请不要忘了更新/etc/fstab。\n你可以再次使用lvs命令来确认你的逻辑卷已被移除。\nLVM 快照 LVM 机制还提供了对 LV 做快照的功能，也就是说可以给文件系统做一个备份，这也是设计 LVM 快照的主要目的。LVM 的快照功能采用写时复制技术(Copy-On-Write，COW)，这比传统的备份技术的效率要高很多。创建快照时不用停止服务，就可以对数据进行备份。说明：LVM 还支持 thin 类型的快照，但是本文中的快照都是指 COW 类型的快照。\nLVM 采用的写时复制，是指当 LVM 快照创建的时候，仅创建到实际数据的 inode 的硬链接(hark-link)而已。只要实际的数据没有改变，快照就只包含指向数据的 inode 的指针，而非数据本身。快照会跟踪原始卷中块的改变，一旦你更改了快照对应的文件或目录，这个时候原始卷上将要改变的数据会在改变之前拷贝到快照预留的空间。\nLVM 快照的原理\n创建快照实际上也是创建了一个逻辑卷，只不过该卷的属性与普通逻辑卷的属性有些不一样。我们可以通过下图来理解快照数据卷(图中的实线框表示快照区域，虚线框表示文件系统)：\n左图为最初创建的快照数据卷状况，LVM 会预留一个区域 (比如左图的左侧三个 PE 区块) 作为数据存放处。 此时快照数据卷内并没有任何数据，而快照数据卷与源数据卷共享所有的 PE 数据， 因此你会看到快照数据卷的内容与源数据卷中的内容是一模一样的。 等到系统运行一阵子后，假设 A 区域的数据被更新了(上面右图所示)，则更新前系统会将该区域的数据移动到快照数据卷中， 所以在右图的快照数据卷中被占用了一块 PE 成为 A，而其他 B 到 I 的区块则还是与源数据卷共享！\n由於快照区与原本的 LV 共享很多 PE 区块，因此快照区与被快照的 LV 必须要在同一个 VG 上头，下面两点非常重要：\n VG中需要预留存放快照本身的空间，不能全部被占满。 快照所在的 VG 必须与被备份的 LV 的 VG 相同，否则创建快照会失败。  创建 LVM 快照\n其实快照就是一个特殊类型的数据卷，所以创建快照的命令和创建数据卷的命令相同，也是 lvcreate：\n# lvcreate --size 100M --snapshot --name snap01 /dev/vg0/lv 此时如果把 LV snap01 挂载到系统中，里面的内容和 LV /dev/vg0/lv 中的内容是一样的。\n创建的快照的大小可以比源数据卷小，但是当源数据卷中的数据更新过多时会导致快照容量不足而引起的错误并丢失数据。如上你可以修改少于100M的数据，直到该快照逻辑卷空间不足为止。\n创建快照后，如果源数据卷中的文件被更新了，快照系统中则保存着其创建快照时的版本。\n还原部分数据\n如果我们明确的知道需要还原某个文件，可以挂载快照数据卷，直接拷贝其中旧版本的文件即可。\n合并快照(merge snapshot)\n要将逻辑卷卷’lv’ 恢复到创建快照’snap01’时的状态，即还原整个数据卷上的数据，请使用：\n# lvconvert --merge /dev/vg0/snap01 如果逻辑卷处于活动状态，则在下次重新启动时将进行合并（merging）(合并（merging）甚至可在LiveCD中进行)。\n注意： 合并后快照将被删除。\n可以拍摄多个快照，每个快照都可以任意与对应的逻辑卷合并。\n快照可以被挂载，并可用dd或者tar备份。使用dd备份的快照的大小为拍摄快照后对应逻辑卷中变更过文件的大小。 要使用备份，只需创建并挂载一个快照，并将备份写入或解压到其中。再将快照合并到对应逻辑卷即可。\n快照主要用于提供一个文件系统的拷贝，以用来备份; 比起直接备份分区，使用快照备份可以提供一个更符合原文件系统的镜像。\nZFS 历史 ZFS 是由 Matthew Ahrens 和 Jeff Bonwick 在 2001 年开发的。ZFS 是作为 Sun MicroSystem 公司的 OpenSolaris 的下一代文件系统而设计的。在 2008 年，ZFS 被移植到了 FreeBSD 。同一年，一个移植 ZFS on Linux 的项目也启动了。然而，由于 ZFS 是CDDL 许可的，它和 GPL 不兼容，因此不能将它迁移到 Linux 内核中。为了解决这个问题，绝大多数 Linux 发行版提供了一些方法来安装 ZFS　。\n在甲骨文公司收购太阳微系统公司之后不久，OpenSolaris 就闭源了，这使得 ZFS 的之后的开发也变成闭源的了。许多 ZFS 开发者对这件事情非常不满。三分之二的 ZFS 核心开发者，包括 Ahrens 和 Bonwick，因为这个决定而离开了甲骨文公司。他们加入了其它公司，并于 2013 年 9 月创立了 OpenZFS 这一项目。该项目引领着 ZFS 的开源开发。\n让我们回到上面提到的许可证问题上。既然 OpenZFS 项目已经和 Oracle 公司分离开了，有人可能好奇他们为什么不使用和 GPL 兼容的许可证，这样就可以把它加入到 Linux 内核中了。根据 OpenZFS 官网 的介绍，更改许可证需要联系所有为当前 OpenZFS 实现贡献过代码的人（包括初始的公共 ZFS 代码以及 OpenSolaris 代码），并得到他们的许可才行。这几乎是不可能的（因为一些贡献者可能已经去世了或者很难找到），因此他们决定保留原来的许可证。\n特性 正如前面所说过的，ZFS 是一个先进的文件系统。因此，它有一些有趣的特性。\n存储池 与大多数文件系统不同，ZFS 结合了文件系统和卷管理器的特性。这意味着，它与其他文件系统不同，ZFS 可以创建跨越一系列硬盘或池的文件系统。不仅如此，你还可以通过添加硬盘来增大池的存储容量。ZFS 可以进行分区和格式化。\n写时拷贝 Copy-on-write 是另一个有趣并且很酷的特性。在大多数文件系统上，当数据被重写时，它将永久丢失。而在 ZFS 中，新数据会写到不同的块。写完成之后，更新文件系统元数据信息，使之指向新的数据块（LCTT 译注：更新之后，原数据块成为磁盘上的垃圾，需要有对应的垃圾回收机制）。这确保了如果在写新数据的时候系统崩溃（或者发生其它事，比如突然断电），那么原数据将会保存下来。这也意味着，在系统发生崩溃之后，不需要运行 fsck 来检查和修复文件系统。\n快照 写时拷贝使得 ZFS 有了另一个特性：snapshots。ZFS 使用快照来跟踪文件系统中的更改。快照包含文件系统的原始版本（文件系统的一个只读版本），实时文件系统则包含了自从快照创建之后的任何更改。没有使用额外的空间。因为新数据将会写到实时文件系统新分配的块上。如果一个文件被删除了，那么它在快照中的索引也会被删除。所以，快照主要是用来跟踪文件的更改，而不是文件的增加和创建。\n快照可以挂载成只读的，以用来恢复一个文件的过去版本。实时文件系统也可以回滚到之前的快照。回滚之后，自从快照创建之后的所有更改将会丢失。\n数据完整性验证和自动修复 当向 ZFS 写入新数据时，会创建该数据的校验和。在读取数据的时候，使用校验和进行验证。如果前后校验和不匹配，那么就说明检测到了错误，然后，ZFS 会尝试自动修正错误。\nRAID-Z ZFS 不需要任何额外软件或硬件就可以处理 RAID（磁盘阵列）。毫不奇怪，因为 ZFS 有自己的 RAID 实现：RAID-Z 。RAID-Z 是 RAID-5 的一个变种，不过它克服了 RAID-5 的写漏洞：意外重启之后，数据和校验信息会变得不同步（LCTT 译注：RAID-5 的条带在正写入数据时，如果这时候电源中断，那么奇偶校验数据将跟该部分数据不同步，因此前边的写无效；RAID-Z 用了 “可变宽的 RAID 条带” 技术，因此所有的写都是全条带写入）。为了使用基本级别的 RAID-Z（RAID-Z1），你需要至少三块磁盘，其中两块用来存储数据，另外一块用来存储奇偶校验信息。而 RAID-Z2 需要至少两块磁盘存储数据以及两块磁盘存储校验信息。RAID-Z3 需要至少两块磁盘存储数据以及三块磁盘存储校验信息。另外，只能向 RAID-Z 池中加入偶数倍的磁盘，而不能是奇数倍的。\n巨大的存储潜力 创建 ZFS 的时候，它是作为最后一个文件系统而设计的 。那时候，大多数文件系统都是 64 位的，ZFS 的创建者决定直接跳到 128 位，等到将来再来证明这是对的。这意味着 ZFS 的容量大小是 32 位或 64 位文件系统的 1600 亿亿倍。事实上，Jeff Bonwick（其中一个创建者）说：“完全填满一个 128 位的存储池所需要的能量，从字面上讲，比煮沸海洋需要的还多。”\n如何安装 ZFS？ 如果你想立刻使用 ZFS（开箱即用），那么你需要安装 FreeBSD 或一个使用 illumos 内核的操作系统。illumos 是 OpenSolaris 内核的一个克隆版本。\n事实上，支持 ZFS 是一些有经验的 Linux 用户选择 BSD 的主要原因。\n如果你想在 Linux 上尝试 ZFS，那么只能在存储文件系统上使用。据我所知，没有任何 Linux 发行版可以在根目录上安装 ZFS，实现开箱即用。如果你对在 Linux 上尝试 ZFS 感兴趣，那么 ZFS on Linux 项目 上有大量的教程可以指导你怎么做。\n在 Ubuntu 上使用 ZFS 如果您正在考虑将 ZFS 用于您的超高速 NVMe SSD，这可能不是一个最佳选择。 它比别的文件系统要慢，不过，这完全没有问题， 它旨在存储大量的数据并保持安全。\n$ sudo apt-get install zfsutils-linux 创建池 在 ZFS 中，池大致相当于 RAID 。 它们很灵活且易于操作。\nRAID0 RAID0 只是把你的硬盘集中到一个池子里面，就像一个巨大的驱动器一样。 它可以提高你的驱动器速度，（LCTT 译注：数据条带化后，并行访问，可以提高文件读取速度）但是如果你的驱动器有损坏，你可能会失丢失数据。\n在计算机数据存储中，数据条带化是一种对逻辑顺序数据（例如文件）进行分段的技术，以便将连续的段存储在不同的物理存储设备上。\n要使用 ZFS 实现 RAID0，只需创建一个普通的池。\n$ sudo zpool create your-pool /dev/sdc /dev/sdd RAID1（镜像） 您可以在 ZFS 中使用 mirror 关键字来实现 RAID1 功能。 RAID1 会创建一个一对一的驱动器副本。 这意味着您的数据一直在备份。 它也提高了性能。 当然，你将一半的存储空间用于了复制。\n$ sudo zpool create your-pool mirror /dev/sdc /dev/sdd RAID5/RAIDZ1 ZFS 将 RAID5 功能实现为 RAIDZ1。 RAID5 要求驱动器至少是 3 个。并允许您通过将备份奇偶校验数据写入驱动器空间的 1/n（n 是驱动器数），留下的是可用的存储空间。 如果一个驱动器发生故障，阵列仍将保持联机状态，但应尽快更换发生故障的驱动器（LCTT 译注：与原文翻译略有不同，原文是驱动器的数目是三的倍数，根据 wiki， RAID5 至少需要 3 块驱动器，也可以从下面的命令中猜测)。\n$ sudo zpool create your-pool raidz1 /dev/sdc /dev/sdd /dev/sde RAID6/RAIDZ2 RAID6 与 RAID5 几乎完全相同，但它至少需要四个驱动器。 它将奇偶校验数据加倍，最多允许两个驱动器损坏，而不会导致阵列关闭（LCTT 译注：这里也与原文略有出入，原文是驱动器的数目是四的倍数，根据 wiki ，RAID6 至少需要四个驱动器)。\n$ sudo zpool create your-pool raidz2 /dev/sdc /dev/sdd /dev/sde /dev/sdf RAID10（条带化镜像） RAID10 旨在通过数据条带化提高存取速度和数据冗余来成为一个两全其美的解决方案。 你至少需要四个驱动器，但只能使用一半的空间。 您可以通过在同一个池中创建两个镜像来创建 RAID10 中的池（LCTT 译注：这里也与原文略有出入，原文是驱动器的数目是四的倍数，根据 wiki， RAID10 至少需要四个驱动器）。\n$ sudo zpool create your-pool mirror /dev/sdc /dev/sdd mirror /dev/sde /dev/sdf 池的操作 还有一些管理工具，一旦你创建了你的池，你就必须使用它们来操作。 首先，检查你的池的状态。\n$ sudo zpool status 更新 当你更新 ZFS 时，你也需要更新你的池。 当您检查它们的状态时，您的池会通知您任何更新。 要更新池，请运行以下命令。\n$ sudo zpool upgrade your-pool 你也可以更新全部池。\n$ sudo zpool upgrade -a 添加驱动器 您也可以随时将驱动器添加到池中。 告诉 zpool 池的名称和驱动器的位置，它会处理好一切。\n$ sudo zpool add your-pool /dev/sdx 实例 使用两块硬盘上的等容量分区建立 raid 1。\n$ ls -l /dev/disk/by-id usb-JMicron_Generic_DISK00_0123456789ABCDEF-0:0-part1 - ../../sdb1 usb-JMicron_Generic_DISK01_0123456789ABCDEF-0:1-part2 - ../../sdc2 $ sudo zpool create -f -o ashift=12 -o cachefile=/etc/zfs/zpool.cache -O compression=lz4 -O xattr=sa -O relatime=on -O acltype=posixacl -O dedup=off -m none dpool mirror usb-JMicron_Generic_DISK00_0123456789ABCDEF-0:0-part1 usb-JMicron_Generic_DISK01_0123456789ABCDEF-0:1-part2 $ sudo zfs create -o mountpoint=none -o canmount=off dpool/DATA $ sudo zfs create -o mountpoint=/home/kurome/DataPool dpool/DATA/important $ sudo zpool export dpool $ sudo zpool import dpool Systemd LINUX PID 1 和 SYSTEMD 要说清 Systemd，得先从Linux操作系统的启动说起。Linux 操作系统的启动首先从 BIOS 开始，然后由 Boot Loader 载入内核，并初始化内核。内核初始化的最后一步就是启动 init 进程。这个进程是系统的第一个进程，PID 为 1，又叫超级进程，也叫根进程。它负责产生其他所有用户进程。所有的进程都会被挂在这个进程下，如果这个进程退出了，那么所有的进程都被 kill 。如果一个子进程的父进程退了，那么这个子进程会被挂到 PID 1 下面。（注：PID 0 是内核的一部分，主要用于内进换页，参看：Process identifier）\nSysV Init PID 1 这个进程非常特殊，其主要就任务是把整个操作系统带入可操作的状态。比如：启动 UI – Shell 以便进行人机交互，或者进入 X 图形窗口。传统上，PID 1 和传统的 Unix System V 相兼容的，所以也叫 sysvinit，这是使用得最悠久的 init 实现。Unix System V 于1983年 release。\n在 sysvint 下，有好几个运行模式，又叫 runlevel。比如：常见的 3 级别指定启动到多用户的字符命令行界面，5 级别指定启起到图形界面，0 表示关机，6 表示重启。其配置在 /etc/inittab 文件中。\n与此配套的还有 /etc/init.d/ 和 /etc/rc[X].d，前者存放各种进程的启停脚本（需要按照规范支持 start，stop子命令），后者的 X 表示不同的 runlevel 下相应的后台进程服务，如：/etc/rc3.d 是 runlevel=3 的。 里面的文件主要是 link 到 /etc/init.d/ 里的启停脚本。其中也有一定的命名规范：S 或 K 打头的，后面跟一个数字，然后再跟一个自定义的名字，如：S01rsyslog，S02ssh。S 表示启动，K表示停止，数字表示执行的顺序。\nUpStart Unix 和 Linux 在 sysvint 运作多年后，大约到了2006年的时候，Linux内核进入2.6时代，Linux有了很多更新。并且，Linux开始进入桌面系统，而桌面系统和服务器系统不一样的是，桌面系统面临频繁重启，而且，用户会非常频繁的使用硬件的热插拔技术。于是，这些新的场景，让 sysvint 受到了很多挑战。\n比如，打印机需要CUPS等服务进程，但是如果用户没有打机印，启动这个服务完全是一种浪费，而如果不启动，如果要用打印机了，就无法使用，因为sysvint 没有自动检测的机制，它只能一次性启动所有的服务。另外，还有网络盘挂载的问题。在 /etc/fstab 中，负责硬盘挂载，有时候还有网络硬盘（NFS 或 iSCSI）在其中，但是在桌面机上，有很可能开机的时候是没有网络的， 于是网络硬盘都不可以访问，也无法挂载，这会极大的影响启动速度。sysvinit 采用 netdev 的方式来解决这个问题，也就是说，需要用户自己在 /etc/fstab 中给相应的硬盘配置上 netdev 属性，于是 sysvint 启动时不会挂载它，只有在网络可用后，由专门的 netfs 服务进程来挂载。这种管理方式比较难以管理，也很容易让人掉坑。\n所以，Ubuntu 开发人员在评估了当时几个可选的 init 系统后，决定重新设计这个系统，于是，这就是我们后面看到的 upstart 。 upstart 基于事件驱动的机制，把之前的完全串行的同步启动服务的方式改成了由事件驱动的异步的方式。比如：如果有U盘插入，udev 得到通知，upstart 感知到这个事件后触发相应的服务程序，比如挂载文件系统等等。因为使用一个事件驱动的玩法，所以，启动操作系统时，很多不必要的服务可以不用启动，而是等待通知，lazy 启动。而且事件驱动的好处是，可以并行启动服务，他们之间的依赖关系，由相应的事件通知完成。\nupstart 有着很不错的设计，其中最重要的两个概念是 Job 和 Event。\nJob 有一般的Job，也有service的Job，并且，upstart 管理了整个 Job 的生命周期，比如：Waiting, Starting, pre-Start, Spawned, post-Start, Running, pre-Stop, Stopping, Killed, post-Stop等等，并维护着这个生命周期的状态机。\nEvent 分成三类，signal, method 和 hooks。signal 就是异步消息，method 是同步阻塞的。hooks 也是同步的，但介于前面两者之间，发出hook事件的进程必须等到事件完成，但不检查是否成功。\n但是，upstart 的事件非常复杂，也非常纷乱，各种各样的事件（事件没有归好类）导致有点凌乱。不过因为整个事件驱动的设计比之前的 sysvinit 来说好太多，所以，也深得欢迎。\nSystemd 直到2010的有一天，一个在 RedHat工作的工程师 Lennart Poettering 和 Kay Sievers ，开始引入了一个新的 init 系统—— systemd。这是一个非常非常有野心的项目，这个项目几乎改变了所有的东西，systemd 不但想取代已有的 init 系统，而且还想干更多的东西。\nLennart 同意 upstart 干的不错，代码质量很好，基于事件的设计也很好。但是他觉得 upstart 也有问题，其中最大的问题还是不够快，虽然 upstart 用事件可以达到一定的启动并行度，但是，本质上来说，这些事件还是会让启动过程串行在一起。 如：NetworkManager 在等 D-Bus 的启动事件，而 D-Bus 在等 syslog 的启动事件。\nLennart 认为，实现上来说，upstart 其实是在管理一个逻辑上的服务依赖树，但是这个服务依赖树在表现形式上比较简单，你只需要配置——“启动 B好了就启动A”或是“停止了A后就停止B”这样的规则。但是，Lennart 说，这种简单其实是有害的（this simplification is actually detrimental）。他认为，\n  从一个系统管理的角度出来，他一开始会设定好整个系统启动的服务依赖树，但是这个系统管理员要人肉的把这个本来就非常干净的服务依整树给翻译成计算机看的懂的 Event/Action 形式，而且 Event/Action 这种配置方式是运行时的，所以，你需要运行起来才知道是什么样的。\n  Event逻辑从头到脚到处都是，这个事件扩大了运维的复杂度，还不如之前的 sysvint。 也就是说，当用户配置了 “启动 D-Bus 后请启动 NetworkManager”， 这个 upstart 可以干，但是反过来，如果，用户启动 NetworkManager，我们应该先去启动他的前置依赖 D-Bus，然而你还要配置相应的反向 Event。本来，我只需要配置一条依赖的，结果现在我要配置很多很多情况下的Event。\n  最后，upstart 里的 Event 的并不标准，很混乱，没有良好的定义。比如：既有，进程启动，运行，停止的事件，也有USB设备插入、可用、拔出的事件，还有文件系统设备being mounted、 mounted 和 umounted 的事件，还有AC电源线连接和断开的事件。你会发现，这进程启停的、USB的、文件系统的、电源线的事件，看上去长得很像， 但是没有被标准化抽像出来掉，因为绝大多数的事件都是三元组：start, condition, stop 。这种概念设计模型并没有在 upstart 中出现。因为 upstart 被设计为单一的事件，而忽略了逻辑依赖。\n  当然，如果 systemd 只是解决 upstart 的问题，他就改造 upstart 就好了，但是 Lennart 的野心不只是想干个这样的事，他想干的更多。\n首先，systemd 清醒的认识到了 init 进程的首要目标是要让用户快速的进入可以操作OS的环境，所以，这个速度一定要快，越快越好，所以，systemd 的设计理念就是两条：\n To start less. And to start more in parallel.  也就是说，按需启动，能不启动就不启动，如果要启动，能并行启动就并行启动，包括你们之间有依赖，我也并行启动。按需启动还好理解，那么，有依赖关系的并行启动，它是怎么做到的？这里，systemd 借鉴了 MacOS 的 Launchd 的玩法（在Youtube上有一个分享——Launchd: One Program to Rule them All，在苹果的开源网站上也有相关的设计文档——About Daemons and Services）\n要解决这些依赖性，systemd 需要解决好三种底层依赖—— Socket， D-Bus ，文件系统。\n  Socket依赖。如果服务C依赖于服务S的socket，那么就要先启动S，然后再启动C，因为如果C启动时找不到S的Socket，那么C就会失败。systemd 可以帮你在S还没有启动好的时候，建立一个socket，用来接收所有的C的请求和数据，并缓存之，一旦S全部启动完成，把systemd替换好的这个缓存的数据和Socket描述符替换过去。\n  D-Bus依赖。D-Bus 全称 Desktop Bus，是一个用来在进程间通信的服务。除了用于用户态进程和内核态进程通信，也用于用户态的进程之前。现在，很多的现在的服务进程都用 D-Bus 而不是Socket来通信。比如：NetworkManager 就是通过 D-Bus 和其它服务进程通讯的，也就是说，如果一个进程需要知道网络的状态，那么就必需要通过 D-Bus 通信。D-Bus 支持 “Bus Activation”的特性。也就是说，A要通过 D-Bus 服务和B通讯，但是B没有启动，那么 D-Bus 可以把B起来，在B启动的过程中，D-Bus 帮你缓存数据。systemd 可以帮你利用好这个特性来并行启动 A 和 B。\n  文件系统依赖。系统启动过程中，文件系统相关的活动是最耗时的，比如挂载文件系统，对文件系统进行磁盘检查（fsck），磁盘配额检查等都是非常耗时的操作。在等待这些工作完成的同时，系统处于空闲状态。那些想使用文件系统的服务似乎必须等待文件系统初始化完成才可以启动。systemd 参考了 autofs 的设计思路，使得依赖文件系统的服务和文件系统本身初始化两者可以并发工作。autofs 可以监测到某个文件系统挂载点真正被访问到的时候才触发挂载操作，这是通过内核 automounter 模块的支持而实现的。比如一个 open() 系统调用作用在某个文件系统上的时候，而这个文件系统尚未执行挂载，此时 open() 调用被内核挂起等待，等到挂载完成后，控制权返回给 open() 系统调用，并正常打开文件。这个过程和 autofs 是相似的。\n  下图来自 Lennart 的演讲里的一页PPT，展示了不同 init 系统的启动。\n除此之外，systemd 还在启动时管理好了一些下面的事。\n用C语言取代传统的脚本式的启动。前面说过，sysvint 用 /etc/rcX.d 下的各种脚本启动。然而这些脚本中需要使用 awk, sed, grep, find, xargs 等等这些操作系统的命令，这些命令需要生成进程，生成进程的开销很大，关键是生成完这些进程后，这个进程就干了点屁大的事就退了。换句话说就是，我操作系统干了那么多事为你拉个进程起来，结果你就把个字串转成小写就退了，把我操作系统当什么了？\n在正常的一个 sysvinit 的脚本里，可能会有成百上千个这样的命令。所以，慢死。因此，systemd 全面用 C 语言全部取代了。一般来说，sysvinit 下，操作系统启动完成后，用 echo $$ 可以看到，pid 被分配到了上千的样子，而 systemd 的系统只是上百。\n另外，systemd 是真正一个可以管住服务进程的——可以跟踪上服务进程所fork/exec出来的所有进程。\n  我们知道， 传统 Unix/Linux 的 Daemon 服务进程的最佳实践基本上是这个样子的（具体过程可参看这篇文章“[SysV Daemon](http://0pointer.de/public/systemd-man/daemon.html#SysV Daemons)”）\n 进程启动时，关闭所有的打开的文件描述符（除了标准描述符0,1,2），然后重置所有的信号处理。 调用 fork() 创建子进程，在子进程中 setsid()，然后父进程退出（为了后台执行） 在子进程中，再调用一次 fork()，创建孙子进程，确定没有交互终端。然后子进程退出。 在孙子进程中，把标准输入标准输出标准错误都连到 /dev/null 上，还要创建 pid 文件，日志文件，处理相关信号 …… 最后才是真正开始提供服务。    在上面的这个过程中，服务进程除了两次 fork 外还会 fork 出很多很多的子进程（比如说一些Web服务进程，会根据用户的请求链接来 fork 子进程），这个进程树是相当难以管理的，因为，一旦父进程退出来了，子进程就会被挂到 PID 1下，所以，基本上来说，你无法通过服务进程自已给定的一个pid文件来找到所有的相关进程（这个对开发者的要求太高了），所以，在传统的方式下用脚本启停服务是相当相当的 Buggy 的，因为无法做对所有的服务生出来的子子孙孙做到监控。\n  为了解决这个问题，upstart 通过变态的 strace 来跟踪进程中的 fork() 和 exec() 或 exit() 等相关的系统调用。这种方法相当笨拙。 systemd 使用了一个非常有意思的玩法来 tracking 服务进程生出来的所有进程，那就是用 cgroup （我在 Docker 的基础技术“cgroup篇”中讲过这个东西）。cgroup主要是用来管理进程组资源配额的事，所以，无论服务如何启动新的子进程，所有的这些相关进程都会同属于一个 cgroup，所以，systemd 只需要简单的去遍历一下相应的 cgroup 的那个虚文件系统目录下的文件，就可以正确的找到所有的相关进程，并将他们一一停止。\n  另外，systemd 简化了整个 daemon 开发的过程：\n 不需要两次 fork()，只需要实现服务本身的主逻辑就可以了。 不需要 setsid()，systemd 会帮你干 不需要维护 pid文件，systemd 会帮处理。 不需要管理日志文件或是使用syslog，或是处理HUP的日志reload信号。把日志打到 stderr 上，systemd 帮你管理。 处理 SIGTERM 信号，这个信号就是正确退出当前服务，不要做其他的事。 ……  除此之外，systemd 还能——\n 自动检测启动的服务间有没有环形依赖。 内建 autofs 自动挂载管理功能。 日志服务。systemd 改造了传统的 syslog 的问题，采用二进制格式保存日志，日志索引更快。 快照和恢复。对当前的系统运行的服务集合做快照，并可以恢复。 ……  还有好多好多，他接管很多很多东西，于是就让很多人不爽了，因为他在干了很多本不属于 PID 1 的事。\nSystemd 争论和八卦 于是 systemd 这个东西成了可能是有史以来口水战最多的一个开源软件了。systemd 饱受各种争议，最大的争议就是他破坏了 Unix 的设计哲学（相关的哲学可以读一下《Unix编程艺术》），干了一个大而全而且相当复杂的东西。当然，Lennart 并不同意这样的说法，他后来又写一篇blog “The Biggest Myths”来解释 systemd 并不是这样的，大家可以前往一读。\n这个争议大到什么样子呢？2014 年，Debian Linux 因为想准备使用 systemd 来作为标准的 init 守护进程来替换 sysvinit 。而围绕这个事的争论达到了空前的热度，争论中充满着仇恨，systemd 的支持者和反对者都在互相辱骂，导致当时 Debian 阵营开始分裂。还有人给 Lennart 发了死亡威胁的邮件，用比特币雇凶买杀手，扬言要取他的性命，在Youbute上传了侮辱他的歌曲，在IRC和各种社交渠道上给他发下流和侮辱性的消息。这已经不是争议了，而是一种不折不扣的仇恨！\n于是，Lennart 在 Google Plus 上发了贴子，批评整个 Linux 开源社区和 Linus 本人。他大意说，\n 这个社区太病态了，全是 ass holes，你们不停用各种手段在各种地方用不同的语言和方式来侮辱和漫骂我。我还是一个年轻人，我从来没有经历过这样的场面，但是今天我已经对这种场面很熟悉了。我有时候说话可能不准确，但是我不会像他样那样说出那样的话，我也没有被这些事影响，因为我脸皮够厚，所以，为什么我可以在如何大的反对声面前让 systemd 成功，但是，你们 Linux 社区太可怕了。你们里面的有精神病的人太多了。另外，对于Linus Torvalds，你是这个社区的 Role Model，但可惜你是一个 Bad Role Model，你在社区里的刻薄和侮辱性的言行，基本从一定程度上鼓励了其它人跟你一样，当然，并不只是你一个人的问题，而是在你周围聚集了一群和你一样的这样干的人。送你一句话—— A fish rots from the head down ！一条鱼是从头往下腐烂的……\n 这篇契文很长，喜欢八卦的同学可以前往一读。感受一下 Lennart 当时的心态（我觉得能算上是非常平稳了）。\nLinus也在被一媒体问起 systemd 这个事来（参看“Torvalds says he has no strong opinions on systemd”），Linus在采访里说，\n 我对 systemd 和 Lennart 的贴子没有什么强烈的想法。虽然，传统的 Unix 设计哲学—— “Do one thing and Do it well”，很不错，而且我们大多数人也实践了这么多年，但是这并不代表所有的真实世界。在历史上，也不只有systemd 这么干过。但是，我个人还是 old-fashioned 的人，至少我喜欢文本式的日志，而不是二进制的日志。但是 systemd 没有必要一定要有这样的品味。哦，我说细节了……\n 今天，systemd 占据了几乎所有的主流的 Linux 发行版的默认配置，包括：Arch Linux、CentOS、CoreOS、Debian、Fedora、Megeia、OpenSUSE、RHEL、SUSE企业版和 Ubuntu。而且，对于 CentOS, CoreOS, Fedora, RHEL, SUSE这些发行版来说，不能没有 systemd。（Ubuntu 还有一个不错的wiki – Systemd for Upstart Users 阐述了如何在两者间切换）\n其它 还记得在《缓存更新的套路》一文中，我说过，如果你要做好架构，首先你得把计算机体系结构以及很多老古董的基础技术吃透了。因为里面会有很多可以借鉴和相通的东西。那么，你是否从这篇文章里看到了一些有分布式架构相似的东西？\n比如：从 sysvinit 到 upstart 再到 systemd，像不像是服务治理？Linux系统下的这些服务进程，是不是很像分布式架构中的微服务？还有那个D-Bus，是不是很像SOA里的ESB？而 init 系统是不是很像一个控制系统？甚至像一个服务编排（Service Orchestration）系统？\n分布式系统中的服务之间也有很多依赖，所以，在启动一个架构的时候，如果我们可以做到像 systemd 那样并行启动的话，那么是不是就像是一个微服务的玩法了？\n嗯，你会发现，技术上的很多东西是相通的，也是互相有对方的影子，所以，其实技术并不多。关键是我们学在了表面还是看到了本质。\n命令 Systemd 是 Linux 系统工具，用来启动守护进程，已成为大多数发行版的标准配置。\n系统管理 Systemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面。\nsystemctl\nsystemctl是 Systemd 的主命令，用于管理系统。\n# 重启系统 $ sudo systemctl reboot # 关闭系统，切断电源 $ sudo systemctl poweroff # CPU停止工作 $ sudo systemctl halt # 暂停系统 $ sudo systemctl suspend # 让系统进入冬眠状态 $ sudo systemctl hibernate # 让系统进入交互式休眠状态 $ sudo systemctl hybrid-sleep # 启动进入救援状态（单用户状态） $ sudo systemctl rescue systemd-analyze\nsystemd-analyze命令用于查看启动耗时。\n# 查看启动耗时 $ systemd-analyze # 查看每个服务的启动耗时 $ systemd-analyze blame # 显示瀑布状的启动过程流$ $ systemd-analyze critical-chain # 显示指定服务的启动流 $ systemd-analyze critical-chain atd.service hostnamectl\nhostnamectl命令用于查看当前主机的信息。\n# 显示当前主机的信息 $ hostnamectl # 设置主机名。 $ sudo hostnamectl set-hostname rhel7 localectl\nlocalectl命令用于查看本地化设置。\n# 查看本地化设置 $ localectl # 设置本地化参数。 $ sudo localectl set-locale LANG=en_GB.utf8 $ sudo localectl set-keymap en_GB timedatectl\ntimedatectl命令用于查看当前时区设置。\n# 查看当前时区设置 $ timedatectl # 显示所有可用的时区 $ timedatectl list-timezones # 设置当前时区 $ sudo timedatectl set-timezone America/New_York $ sudo timedatectl set-time YYYY-MM-DD $ sudo timedatectl set-time HH:MM:SS loginctl\nloginctl命令用于查看当前登录的用户。\n# 列出当前session $ loginctl list-sessions # 列出当前登录用户 $ loginctl list-users # 列出显示指定用户的信息 $ loginctl show-user ruanyf Unit 含义\nSystemd 可以管理所有系统资源。不同的资源统称为 Unit（单元）。简单说，单元就是 Systemd 的最小功能单位，是单个进程的描述。一个个小的单元互相调用和依赖，组成一个庞大的任务管理系统，这就是 Systemd 的基本思想。\n由于 Systemd 要做的事情太多，导致单元有很多不同的种类，大概一共有12种。\n Service unit：系统服务 Target unit：多个 Unit 构成的一个组 Device Unit：硬件设备 Mount Unit：文件系统的挂载点 Automount Unit：自动挂载点 Path Unit：文件或路径 Scope Unit：不是由 Systemd 启动的外部进程 Slice Unit：进程组，资源分配 Snapshot Unit：Systemd 快照，可以切回某个快照 Socket Unit：进程间通信的 socket Swap Unit：swap 文件 Timer Unit：定时器  systemctl list-units命令可以查看当前系统的所有 Unit 。\n# 列出正在运行的 Unit $ systemctl list-units # 列出所有Unit，包括没有找到配置文件的或者启动失败的 $ systemctl list-units --all # 列出所有没有运行的 Unit $ systemctl list-units --all --state=inactive # 列出所有加载失败的 Unit $ systemctl list-units --failed # 列出所有正在运行的、类型为 service 的 Unit $ systemctl list-units --type=service Unit 的状态\nsystemctl status命令用于查看系统状态和单个 Unit 的状态。\n# 显示系统状态 $ systemctl status # 显示单个 Unit 的状态 $ sysystemctl status bluetooth.service # 显示远程主机的某个 Unit 的状态 $ systemctl -H root@rhel7.example.com status httpd.service 例如查看 httpd 状态\n$ sudo systemctl status httpd httpd.service - The Apache HTTP Server Loaded: loaded (/usr/lib/systemd/system/httpd.service; enabled) Active: active (running) since 金 2014-12-05 12:18:22 JST; 7min ago Main PID: 4349 (httpd) Status: \"Total requests: 1; Current requests/sec: 0; Current traffic: 0 B/sec\" CGroup: /system.slice/httpd.service ├─4349 /usr/sbin/httpd -DFOREGROUND ├─4350 /usr/sbin/httpd -DFOREGROUND ├─4351 /usr/sbin/httpd -DFOREGROUND ├─4352 /usr/sbin/httpd -DFOREGROUND ├─4353 /usr/sbin/httpd -DFOREGROUND └─4354 /usr/sbin/httpd -DFOREGROUND 12月 05 12:18:22 localhost.localdomain systemd[1]: Starting The Apache HTTP Server... 12月 05 12:18:22 localhost.localdomain systemd[1]: Started The Apache HTTP Server. 12月 05 12:22:40 localhost.localdomain systemd[1]: Started The Apache HTTP Server. 上面的输出结果含义如下。\n Loaded行：配置文件的位置，是否设为开机启动 Active行：表示正在运行 Main PID行：主进程ID Status行：由应用本身（这里是 httpd ）提供的软件当前状态 CGroup块：应用的所有子进程 日志块：应用的日志  除了status命令，systemctl还提供了三个查询状态的简单方法，主要供脚本内部的判断语句使用。\n# 显示某个 Unit 是否正在运行 $ systemctl is-active application.service # 显示某个 Unit 是否处于启动失败状态 $ systemctl is-failed application.service # 显示某个 Unit 服务是否建立了启动链接 $ systemctl is-enabled application.service Unit 管理\n对于用户来说，最常用的是下面这些命令，用于启动和停止 Unit（主要是 service）。\n# 立即启动一个服务 $ sudo systemctl start apache.service # 立即停止一个服务 $ sudo systemctl stop apache.service # 重启一个服务 $ sudo systemctl restart apache.service # 杀死一个服务的所有子进程 $ sudo systemctl kill apache.service # 重新加载一个服务的配置文件 $ sudo systemctl reload apache.service # 重载所有修改过的配置文件 $ sudo systemctl daemon-reload # 显示某个 Unit 的所有底层参数 $ systemctl show httpd.service # 显示某个 Unit 的指定属性的值 $ systemctl show -p CPUShares httpd.service # 设置某个 Unit 的指定属性 $ sudo systemctl set-property httpd.service CPUShares=500 有时候，该命令可能没有响应，执行systemctl stop服务停不下来。这时候就不得不\"杀进程\"了，向正在运行的进程发出kill信号，执行systemctl kill。\n依赖关系\nUnit 之间存在依赖关系：A 依赖于 B，就意味着 Systemd 在启动 A 的时候，同时会去启动 B。\nsystemctl list-dependencies命令列出一个 Unit 的所有依赖。\n$ systemctl list-dependencies nginx.service 上面命令的输出结果之中，有些依赖是 Target 类型（详见下文），默认不会展开显示。如果要展开 Target，就需要使用--all参数。\n$ systemctl list-dependencies --all nginx.service Unit 的配置文件 概述\n每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit 。\n除了系统默认的单元文件/lib/systemd/system，Systemd 默认从目录/etc/systemd/system/读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录/usr/lib/systemd/system/。那些支持 Systemd 的软件，安装的时候，也会自动在/usr/lib/systemd/system目录添加一个配置文件。\nsystemctl enable命令用于在/etc/systemd/system/和/usr/lib/systemd/system之间，建立符号链接关系。\n$ sudo systemctl enable clamd@scan.service # 等同于 $ sudo ln -s '/usr/lib/systemd/system/clamd@scan.service' '/etc/systemd/system/multi-user.target.wants/clamd@scan.service' 如果配置文件里面设置了开机启动，systemctl enable命令相当于激活开机启动。\n与之对应的，systemctl disable命令用于在两个目录之间，撤销符号链接关系，相当于撤销开机启动。\n$ sudo systemctl disable clamd@scan.service 配置文件的后缀名，就是该 Unit 的种类，比如sshd.socket。如果省略，Systemd 默认后缀名为.service，所以sshd会被理解成sshd.service。\n设置开机启动以后，软件并不会立即启动，必须等到下一次开机。如果想现在就运行该软件，那么要执行systemctl start命令。\n配置文件的状态\nsystemctl list-unit-files命令用于列出所有配置文件。\n# 列出所有配置文件 $ systemctl list-unit-files # 列出指定类型的配置文件 $ systemctl list-unit-files --type=service 这个命令会输出一个列表。\n$ systemctl list-unit-filesUNIT FILE STATEchronyd.service enabledclamd@.service staticclamd@scan.service disabled 这个列表显示每个配置文件的状态，一共有四种。\n enabled：已建立启动链接 disabled：没建立启动链接 static：该配置文件没有[Install]部分（无法执行），只能作为其他配置文件的依赖 masked：该配置文件被禁止建立启动链接  注意，从配置文件的状态无法看出，该 Unit 是否正在运行。这必须执行前面提到的systemctl status命令。\n$ systemctl status bluetooth.service 一旦修改配置文件，就要让 Systemd 重新加载配置文件，然后重新启动，否则修改不会生效。\n$ sudo systemctl daemon-reload $ sudo systemctl restart httpd.service 配置文件的格式\n配置文件就是普通的文本文件，可以用文本编辑器打开。\nsystemctl cat命令可以查看配置文件的内容。\n$ systemctl cat sshd.service [Unit] Description=OpenSSH server daemon Documentation=man:sshd(8) man:sshd_config(5) After=network.target sshd-keygen.service Wants=sshd-keygen.service [Service] EnvironmentFile=/etc/sysconfig/sshd ExecStart=/usr/sbin/sshd -D $OPTIONS ExecReload=/bin/kill -HUP $MAINPID Type=simpleKill Mode=process Restart=on-failure RestartSec=42s [Install] WantedBy=multi-user.target 从上面的输出可以看到，配置文件分成几个区块。每个区块的第一行，是用方括号表示的区别名，比如[Unit]。注意，配置文件的区块名和字段名，都是大小写敏感的。\n每个区块内部是一些等号连接的键值对。\n[Section] Directive1=value Directive2=value . . . 注意，键值对的等号两侧不能有空格。\n配置文件的区块\n[Unit]区块通常是配置文件的第一个区块，用来定义 Unit 的元数据，以及配置与其他 Unit 的关系。它的主要字段如下。\n  Description：当前服务的简单描述\n  Documentation：文档地址\n  启动顺序\n Before：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动 After：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之前启动。如network.target或sshd-keygen.service需要启动，那么sshd.service应该在它们之后启动。    依赖关系：\n举例来说，某 Web 应用需要 postgresql 数据库储存数据。在配置文件中，Before、After 只定义要在 postgresql 之后启动，而没有定义依赖 postgresql 。上线后，由于某种原因，postgresql 需要重新启动，在停止服务期间，该 Web 应用就会无法建立数据库连接。\n注意，Wants字段与Requires字段只涉及依赖关系，与启动顺序无关，默认情况下是同时启动的。\n Wants：与当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败。如sshd.service与sshd-keygen.service之间存在\"弱依赖\"关系，即如果\"sshd-keygen.service\"启动失败或停止运行，不影响sshd.service继续执行。 Requires：当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败。Requires字段则表示\"强依赖\"关系，即如果该服务启动失败或异常退出，那么sshd.service也必须退出。    BindsTo：与Requires类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行\n  Conflicts：这里指定的 Unit 不能与当前 Unit 同时运行\n  Condition...：当前 Unit 运行必须满足的条件，否则不会运行\n  Assert...：当前 Unit 运行必须满足的条件，否则会报启动失败\n  StartLimitIntervalSec=interval, StartLimitBurst=burst：设置单元的启动频率限制。 也就是该单元在 interval 时间内最多允许启动 burst 次。\n   [Service]区块用来定义如何启动当前服务，只有 Service 类型的 Unit 才有这个区块。它的主要字段如下。\n EnvironmentFile字段：指定当前服务的环境参数文件。该文件内部的key=value键值对，可以用$key的形式，在当前配置文件中获取。sshd 的环境参数文件是/etc/sysconfig/sshd。 ExecStart字段：定义启动进程时执行的命令。是配置文件里面最重要的字段。上面的例子中，启动sshd，执行的命令是/usr/sbin/sshd -D $OPTIONS，其中的变量$OPTIONS就来自EnvironmentFile字段指定的环境参数文件。与之作用相似的，还有如下这些字段。  ExecReload字段：重启服务时执行的命令 ExecStop字段：停止服务时执行的命令 ExecStartPre字段：启动服务之前执行的命令 ExecStartPost字段：启动服务之后执行的命令 ExecStopPost字段：停止服务之后执行的命令   Type：字段定义启动类型。它可以设置的值如下。  simple（默认值）：ExecStart字段启动的进程为主进程 forking：ExecStart字段将以fork()方式启动，此时父进程将会退出，子进程将成为主进程 oneshot：类似于simple，但只执行一次，Systemd 会等它执行完，才启动其他服务 dbus：类似于simple，但会等待 D-Bus 信号后启动 notify：类似于simple，启动结束后会发出通知信号，然后 Systemd 再启动其他服务 idle：类似于simple，但是要等到其他任务都执行完，才会启动该服务。一种使用场合是为让该服务的输出，不与其他服务的输出相混合   KillMode字段：定义 Systemd 如何停止服务。  control-group（默认值）：当前控制组里面的所有子进程，都会被杀掉 process：只杀主进程。比如sshd的KillMode设为process，子进程打开的 SSH session 仍然保持连接。 mixed：主进程将收到 SIGTERM 信号，子进程收到 SIGKILL 信号 none：没有进程会被杀掉，只是执行服务的 stop 命令。   Restart：Restart字段：定义了服务退出后，Systemd 重启该服务的方式。  no（默认值）：退出后不会重启 on-success：只有正常退出时（退出状态码为0），才会重启 on-failure：非正常退出时（退出状态码非0），包括被信号终止和超时，才会重启。比如sshd任何意外的失败，都将重启sshd；如果 sshd 正常停止（比如执行systemctl stop命令），它就不会重启。对于守护进程，推荐设为on-failure。 on-abnormal：只有被信号终止和超时，才会重启。对于那些允许发生错误退出的服务，可以设为on-abnormal。 on-abort：只有在收到没有捕捉到的信号终止时，才会重启 on-watchdog：超时退出，才会重启 always：不管是什么退出原因，总是重启   RestartSec字段：表示 Systemd 重启服务之前，需要等待的秒数。 TimeoutSec：定义 Systemd 停止当前服务之前等待的秒数  所有的启动设置之前，都可以加上一个连词号（-），表示\"抑制错误\"，即发生错误的时候，不影响其他命令的执行。比如，EnvironmentFile=-/etc/sysconfig/sshd（注意等号后面的那个连词号），就表示即使/etc/sysconfig/sshd文件不存在，也不会抛出错误。\n [Install]通常是配置文件的最后一个区块，定义如何安装这个配置文件，即怎样做到开机启动。它的主要字段如下。\n WantedBy字段：表示该服务所在的 Target，它的值是一个或多个 Target。Target的含义是服务组，表示一组服务。WantedBy=multi-user.target指的是，sshd 所在的 Target 是multi-user.target。当前 Unit 激活时（enable）符号链接会放入/etc/systemd/system目录下面 [Target 名].wants子目录中，如multi-user.target.wants子目录。 RequiredBy：它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入/etc/systemd/system目录下面以 Target 名 + .required后缀构成的子目录中 Alias：当前 Unit 可用于启动的别名 Also：当前 Unit 激活（enable）时，会被同时激活的其他 Unit  Unit 配置文件的完整字段清单，请参考官方文档。\nTarget 启动计算机的时候，需要启动大量的 Unit。如果每一次启动，都要一一写明本次启动需要哪些 Unit，显然非常不方便。Systemd 的解决方案就是 Target。\n简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于\"状态点\"，启动某个 Target 就好比启动到某种状态。\n传统的init启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。\n# 查看当前系统的所有 Target $ systemctl list-unit-files --type=target # 查看一个 Target 包含的所有 Unit $ systemctl list-dependencies multi-user.target # 查看启动时的默认 Target，在这个组里的所有服务，都将开机启动。 $ systemctl get-default # 设置启动时的默认 Target $ sudo systemctl set-default multi-user.target # 切换 Target 时，默认不关闭前一个 Target 启动的进程， # systemctl isolate 命令改变这种行为， # 关闭前一个 Target 里面所有不属于后一个 Target 的进程 $ sudo systemctl isolate multi-user.target Target 与 传统 RunLevel 的对应关系如下。\nTraditional runlevel New target name Symbolically linked to... Runlevel 0 | runlevel0.target - poweroff.target Runlevel 1 | runlevel1.target - rescue.target Runlevel 2 | runlevel2.target - multi-user.target Runlevel 3 | runlevel3.target - multi-user.target Runlevel 4 | runlevel4.target - multi-user.target Runlevel 5 | runlevel5.target - graphical.target Runlevel 6 | runlevel6.target - reboot.target 它与init进程的主要差别如下。\n（1）默认的 RunLevel（在/etc/inittab文件设置）现在被默认的 Target 取代，位置是/etc/systemd/system/default.target，通常符号链接到graphical.target（图形界面）或者multi-user.target（多用户命令行）。\n（2）启动脚本的位置，以前是/etc/init.d目录，符号链接到不同的 RunLevel 目录 （比如/etc/rc3.d、/etc/rc5.d等），现在则存放在/lib/systemd/system和/etc/systemd/system目录。\n（3）配置文件的位置，以前init进程的配置文件是/etc/inittab，各种服务的配置文件存放在/etc/sysconfig目录。现在的配置文件主要存放在/lib/systemd目录，在/etc/systemd目录里面的修改可以覆盖原始设置。\n日志管理 Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用journalctl一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是/etc/systemd/journald.conf。\njournalctl功能强大，用法非常多。\n# 查看所有日志（默认情况下 ，只保存本次启动的日志） $ sudo journalctl # 查看内核日志（不显示应用日志） $ sudo journalctl -k # 查看系统本次启动的日志 $ sudo journalctl -b $ sudo journalctl -b -0 # 查看上一次启动的日志（需更改设置） $ sudo journalctl -b -1 # 查看指定时间的日志 $ sudo journalctl --since=\"2012-10-30 18:17:16\" $ sudo journalctl --since \"20 min ago\" $ sudo journalctl --since yesterday $ sudo journalctl --since \"2015-01-10\" --until \"2015-01-11 03:00\" $ sudo journalctl --since 09:00 --until \"1 hour ago\" # 显示尾部的最新10行日志 $ sudo journalctl -n # 显示尾部指定行数的日志 $ sudo journalctl -n 20 # 实时滚动显示最新日志 $ sudo journalctl -f # 查看指定服务的日志 $ sudo journalctl /usr/lib/systemd/systemd # 查看指定进程的日志 $ sudo journalctl _PID=1 # 查看某个路径的脚本的日志 $ sudo journalctl /bin/bash # 查看指定用户的日志 $ sudo journalctl _UID=33 --since today # 查看某个 Unit 的日志 $ sudo journalctl -u nginx.service $ sudo journalctl -u nginx.service --since today # 实时滚动显示某个 Unit 的最新日志 $ sudo journalctl -u nginx.service -f # 合并显示多个 Unit 的日志 $ journalctl -u nginx.service -u php-fpm.service --since today # 查看指定优先级（及其以上级别）的日志，共有8级 # 0: emerg # 1: alert # 2: crit # 3: err # 4: warning # 5: notice # 6: info # 7: debug $ sudo journalctl -p err -b # 日志默认分页输出，--no-pager 改为正常的标准输出 $ sudo journalctl --no-pager # 以 JSON 格式（单行）输出 $ sudo journalctl -b -u nginx.service -o json # 以 JSON 格式（多行）输出，可读性更好 $ sudo journalctl -b -u nginx.serviceqq -o json-pretty # 显示日志占据的硬盘空间 $ sudo journalctl --disk-usage # 指定日志文件占据的最大空间 $ sudo journalctl --vacuum-size=1G # 指定日志文件保存多久 $ sudo journalctl --vacuum-time=1years 定时器示例 邮件脚本 先写一个发邮件的脚本mail.sh。\n#!/usr/bin/env bash echo \"This is the body\" | /usr/bin/mail -s \"Subject\" someone@example.com 上面代码的someone@example.com，请替换成你的邮箱地址。\n然后，执行这个脚本。\n$ bash mail.sh 执行后，你应该就会收到一封邮件，标题为Subject。\n如果你的 Linux 系统不能发邮件，建议安装 ssmtp 或者 msmtp。另外，mail命令的用法，可以参考这里。\nService 单元 Service 单元就是所要执行的任务，比如发送邮件就是一种 Service。\n新建 Service 非常简单，就是在/usr/lib/systemd/system目录里面新建一个文件，比如mytimer.service文件，你可以写入下面的内容。\n[Unit] Description=MyTimer [Service] ExecStart=/bin/bash /path/to/mail.sh 注意，定义的时候，所有路径都要写成绝对路径，比如bash要写成/bin/bash，否则 Systemd 会找不到。\n现在，启动这个 Service。\n$ sudo systemctl start mytimer.service 如果一切正常，你应该就会收到一封邮件。\nTimer 单元 Service 单元只是定义了如何执行任务，要定时执行这个 Service，还必须定义 Timer 单元。\n/usr/lib/systemd/system目录里面，新建一个mytimer.timer文件，写入下面的内容。\n[Unit] Description=Runs mytimer every hour [Timer] OnUnitActiveSec=1h Unit=mytimer.service [Install] WantedBy=multi-user.target 这个 Timer 单元文件分成几个部分。\n[Timer]部分定制定时器。Systemd 提供以下一些字段。\n OnActiveSec：定时器生效后，多少时间开始执行任务 OnBootSec：系统启动后，多少时间开始执行任务 OnStartupSec：Systemd 进程启动后，多少时间开始执行任务 OnUnitActiveSec：该单元上次执行后，等多少时间再次执行 OnUnitInactiveSec： 定时器上次关闭后多少时间，再次执行 OnCalendar：基于绝对时间，而不是相对时间执行 AccuracySec：如果因为各种原因，任务必须推迟执行，推迟的最大秒数，默认是60秒 Unit：真正要执行的任务，默认是同名的带有.service后缀的单元 Persistent：如果设置了该字段，即使定时器到时没有启动，也会自动执行相应的单元 WakeSystem：如果系统休眠，是否自动唤醒系统  上面的脚本里面，OnUnitActiveSec=1h表示一小时执行一次任务。其他的写法还有OnCalendar=*-*-* 02:00:00表示每天凌晨两点执行，OnCalendar=Mon *-*-* 02:00:00表示每周一凌晨两点执行，具体请参考中文手册。\nSystem time 一个操作系统通过如下内容确定时间：时间数值、时间标准、时区和夏令时调节(中国已经废止)。本文分别介绍各个部分的定义及如何设置他们。要维护准确的系统时间，请参考 网络时间协议 一文。\n硬件时钟和系统时钟 系统用两个时钟保存时间：硬件时钟和系统时钟。\n硬件时钟(即实时时钟 RTC 或 CMOS 时钟)仅能保存：年、月、日、时、分、秒这些时间数值，无法保存时间标准(UTC 或 localtime)和是否使用夏令时调节。\n系统时钟(即软件时间) 与硬件时间分别维护，保存了：时间、时区和夏令时设置。Linux 内核保存为自 UTC 时间 1970 年1月1日经过的秒数。初始系统时钟是从硬件时间计算得来，计算时会考虑/etc/adjtime的设置。系统启动之后，系统时钟与硬件时钟独立运行，Linux 通过时钟中断计数维护系统时钟。\n如果系统时间是按 32 位整数保存的，最大只能记到 2038 年，所以 32 位 Linux 系统将在 2038 年停止工作。\n大部分操作系统的时间管理包括如下方面：\n 启动时根据硬件时钟设置系统时间 运行时通过时间同步联网校正时间 关机时根据系统时间设置硬件时间  读取时间 下面命令可以获得硬件时间和系统时间(硬件时钟按 localtime 显示):\n$ timedatectl Local time: Thu 2022-01-27 10:35:26 CST Universal time: Thu 2022-01-27 02:35:26 UTC RTC time: Thu 2022-01-27 02:35:26 Time zone: Asia/Shanghai (CST, +0800) System clock synchronized: yes NTP service: active RTC in local TZ: no 名词解释：\n CST：(China Standard Time,UTC+8:00) 中国沿海时间(北京时间) UTC：(Universal Time Coordinated,UTC) 世界协调时间 GMT：(Greenwich Mean Time ,GMT）格林威治时间 LT：(locale time）本地时间  设置时间 设置系统时间的本地时间：\n# timedatectl set-time \"yyyy-MM-dd hh:mm:ss\" 例如:\n# timedatectl set-time \"2014-05-26 11:13:54\" 设置时间为2014年，5月26日，11时13分54秒。\n时间标准 时间表示有两个标准：localtime 和 UTC(Coordinated Universal Time) 。UTC 是与时区无关的全球时间标准。尽管概念上有差别，UTC 和 GMT (格林威治时间) 是一样的。localtime 标准则依赖于当前时区。\n时间标准由操作系统设定，Windows 默认使用 localtime，Mac OS 默认使用 UTC，而 UNIX 系列的操作系统两者都有。使用 Linux 时，最好将硬件时钟设置为 UTC 标准，并在所有操作系统中使用。这样 Linux 系统就可以自动调整夏令时设置，而如果使用 localtime 标准那么系统时间不会根据夏令时自动调整。\n通过如下命令可以检查当前设置，systemd 默认硬件时钟为协调世界时（UTC）。\n$ timedatectl status | grep local RTC in local TZ: no 硬件时间可以用 hwclock 命令设置，将硬件时间设置为 localtime：\n# timedatectl set-local-rtc 1 硬件时间设置成 UTC：\n# timedatectl set-local-rtc 0 上述命令会自动生成/etc/adjtime，无需单独设置。\n注意： 如果不存在 /etc/adjtime，systemd 会假定硬件时间按 UTC 设置。\n系统启动装入 rtc 驱动时可能会根据系统时钟设置硬件时钟。是否设置依赖于平台、内核版本和内核编译选项。如果进行了设置，此时会假定硬件时钟为 UTC 标准，/sys/class/rtc/rtcN/hctosys(N=0,1,2,..) 会设置成 1。后面 systemd 会根据/etc/adjtime重新设置。\n如果设置成本地时间，处理夏令时有些麻烦。如果夏令时调整发生在关机时，下次启动时时间会出现问题（更多信息）。最新的内核直接从实时时钟芯片（RTC）读取时间，不使用 hwclock，内核把从 RTC 读取的时间当作 UTC 处理。所以如果硬件时间是地方时，系统启动一开始识别的时间是错误的，之后很快会进行矫正。这可能导致一些问题（尤其是时间倒退时）。\nWindows 系统使用 UTC 如果同时安装了 Windows 操作系统（默认使用地方时），那么一般 RTC 会被设置为地方时。Windows 其实也能处理 UTC，需要修改注册表。建议让 Windows 使用 UTC，而非让 Linux 使用地方时。Windows 使用 UTC 后，请记得禁用 Windows 的时间同步功能，以防 Windows 错误设置硬件时间。如上文所说，Linux 可以使用NTP服务来在线同步硬件时钟。\n使用 regedit,新建如下 DWORD 值，并将其值设为十六进制的 1。\nHKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation\\RealTimeIsUniversal 也可以用管理员权限启动命令行来完成：\nreg add \"HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\TimeZoneInformation\" /v RealTimeIsUniversal /d 1 /t REG_DWORD /f 如果以上操作不起作用，并且你使用的是 Windows 64位系统，将 DWORD 修改为 QWORD。\n如果 Windows 要求根据夏令时更新时钟，可以允许。时钟仍然是 UTC，仅是显示时间会改变。\n设置时间标准后需要重新设置硬件时间和系统时间。\n如果你有时间偏移问题，再次设置你的时区:\n# timedatectl set-timezone Asia/Shanghai UTC 在Ubuntu的设置 Ubuntu及其衍生发行版会在安装时检测计算机上是否存在Windows，若存在则会默认使用localtime。这是为了让Windows用户能够在不修改注册表的情况下，在Ubuntu内看到正确的时间。\n要改变这种行为，请参见上面的内容。\n时区 检查当前时区：\n$ timedatectl status 显示可用时区：\n$ timedatectl list-timezones 修改时区：\n# timedatectl set-timezone / 例如：\n# timedatectl set-timezone Asia/Shanghai 此命令会创建一个/etc/localtime软链接，指向/usr/share/zoneinfo/中的时区文件，如果手动创建此链接请确保是相对链接而不是绝对链接。\n注意： 如果pre-systemd配置的/etc/timezone仍然存在于你的系统，你可以放心地将其删除，因为它不再使用。\n时钟偏移 最能代表“真实时间”的是国际原子时钟)，所有的时钟都是有误差的。电子时钟的时间是不准的，但是一般有固定的偏移。这种于基值的差称为“time skew”或“时间偏移”。用 hwclock 设置硬件时间时，会计算每天偏移的秒数。偏移值是原硬件时间与新设置硬件时间的差，并且考虑上次硬件时间设置时的偏移。新的偏移值会在设置时钟时写到文件 /etc/adjtime 。\n注意： 如果硬件时间值与原值的差小于 24 小时，偏移量不会重新计算，因为时间过短，无法精确设置偏移。\n如果硬件时钟总是过快或过慢，可能是计算了错误的偏移值。硬件时钟设置错误或者时间标准与其他操作系统不一致导致。删除文件 /etc/adjtime 可以删除偏移值，然后设置正确的硬件时钟和系统时钟，并检查时间标准是不是设置正确。\n注意： 使用 Systemd 时，要使用 /etc/adjtime中的 drift 值(即无法或不想使用 NTP 时); 需要每次调用 hwclock --adjust命令，可以通过 cron 任务实现。\n提高系统时间精度的方法有：\nNTP 可以通过网络时间协议同步 Linux 系统的时间。NTP 也会修正中断频率和每秒滴答数以减少时间偏移。并且每隔 11 分钟同步一次硬件时钟。\n时钟同步 网络时间协议 (NTP) 是一个通过包交换和可变延迟网络来同步计算机系统时间的协议。下列为这个协议的实现：\n NTP 守护进程是这个协议的参考实现，推荐用于时间服务器。它也可以调节中断频率和每秒滴答次数以减少系统时钟误差，使得硬件时钟每隔11秒重新同步一次。 sntp 是一个 SNTP 客户端。它取代了 ntpdate ，并被推荐用于非服务器环境。 systemd-timesyncd 是一个简单的 SNTP 守护进程。它只实现了客户端，专用于从远程服务器查询时间，更适用于绝大部分安装的情形。 OpenNTPD 是 OpenBSD 项目的一部分，同时实现了客户端和服务器。 Chrony 是一个客户端和服务器，更适合漫游，是为不能始终保持在线的系统而特别设计。 ntpclient 是简单的命令行 NTP 客户端  防火墙 保障数据的安全性是继保障数据的可用性之后最为重要的一项工作。防火墙作为公网与内网之间的保护屏障，在保障数据的安全性方面起着至关重要的作用。\n防火墙管理工具 众所周知，相较于企业内网，外部的公网环境更加恶劣，罪恶丛生。在公网与企业内网之间充当保护屏障的防火墙虽然有软件或硬件之分，但主要功能都是依据策略对穿越防火墙自身的流量进行过滤。就像家里安装的防盗门一样，目的是保护亲人和财产安全。防火墙策略可以基于流量的源目地址、端口号、协议、应用等信息来定制，然后防火墙使用预先定制的策略规则监控出入的流量，若流量与某一条策略规则相匹配，则执行相应的处理，反之则丢弃。这样一来，就能够保证仅有合法的流量在企业内网和外部公网之间流动了。\n从RHEL 7系统开始，firewalld防火墙正式取代了iptables防火墙。对于接触Linux系统比较早或学习过RHEL 5/6系统的读者来说，当他们发现曾经掌握的知识在RHEL 7/8中不再适用，需要全新学习firewalld时，难免会有抵触心理。其实，iptables与firewalld都不是真正的防火墙，它们都只是用来定义防火墙策略的防火墙管理工具而已；或者说，它们只是一种服务。iptables服务会把配置好的防火墙策略交由内核层面的netfilter网络过滤器来处理，而firewalld服务则是把配置好的防火墙策略交由内核层面的nftables包过滤框架来处理。换句话说，当前在Linux系统中其实存在多个防火墙管理工具，旨在方便运维人员管理Linux系统中的防火墙策略，我们只需要配置妥当其中的一个就足够了。\n虽然这些工具各有优劣，但它们在防火墙策略的配置思路上是保持一致的。大家甚至可以不用完全掌握本章介绍的内容，只要在这多个防火墙管理工具中任选一款并将其学透，就足以满足日常的工作需求了。\nIptables 在早期的Linux系统中，默认使用的是iptables防火墙管理服务来配置防火墙。尽管新型的firewalld防火墙管理服务已经被投入使用多年，但是大量的企业在生产环境中依然出于各种原因而继续使用iptables。\n策略与规则链 防火墙会按照从上到下的顺序来读取配置的策略规则，在找到匹配项后就立即结束匹配工作并去执行匹配项中定义的行为（即放行或阻止）。如果在读取完所有的策略规则之后没有匹配项，就去执行默认的策略。一般而言，防火墙策略规则的设置有两种：“通”（即放行）和“堵”（即阻止）。当防火墙的默认策略为拒绝时（堵），就要设置允许规则（通），否则谁都进不来；如果防火墙的默认策略为允许，就要设置拒绝规则，否则谁都能进来，防火墙也就失去了防范的作用。\niptables服务把用于处理或过滤流量的策略条目称之为规则，多条规则可以组成一个规则链，而规则链则依据数据包处理位置的不同进行分类，具体如下：\n 在进行路由选择前处理数据包（PREROUTING）； 处理流入的数据包（INPUT）； 处理流出的数据包（OUTPUT）； 处理转发的数据包（FORWARD）； 在进行路由选择后处理数据包（POSTROUTING）。  一般来说，从内网向外网发送的流量一般都是可控且良性的，因此使用最多的就是INPUT规则链，该规则链可以增大黑客人员从外网入侵内网的难度。\n比如在您居住的社区内，物业管理公司有两条规定：禁止小商小贩进入社区；各种车辆在进入社区时都要登记。显而易见，这两条规定应该是用于社区的正门的（流量必须经过的地方），而不是每家每户的防盗门上。根据前面提到的防火墙策略的匹配顺序，可能会存在多种情况。比如，来访人员是小商小贩，则直接会被物业公司的保安拒之门外，也就无须再对车辆进行登记。如果来访人员乘坐一辆汽车进入社区正门，则“禁止小商小贩进入社区”的第一条规则就没有被匹配到，因此按照顺序匹配第二条策略，即需要对车辆进行登记。如果是社区居民要进入正门，则这两条规定都不会匹配到，因此会执行默认的放行策略。\n但是，仅有策略规则还不能保证社区的安全，保安还应该知道采用什么样的动作来处理这些匹配的流量，比如“允许”“拒绝”“登记”“不理它”。这些动作对应到iptables服务的术语中分别是ACCEPT（允许流量通过）、REJECT（拒绝流量通过）、LOG（记录日志信息）、DROP（拒绝流量通过）。“允许流量通过”和“记录日志信息”都比较好理解，这里需要着重讲解的是REJECT和DROP的不同点。就DROP来说，它是直接将流量丢弃而且不响应；REJECT则会在拒绝流量后再回复一条“信息已经收到，但是被扔掉了”信息，从而让流量发送方清晰地看到数据被拒绝的响应信息。\n下面举一个例子，让各位读者更直观地理解这两个拒绝动作的不同之处。比如有一天您正在家里看电视，突然听到有人敲门，您透过防盗门的猫眼一看是推销商品的，便会在不需要的情况下开门并拒绝他们（REJECT）。但如果看到的是债主带了十几个小弟来讨债，此时不仅要拒绝开门，还要默不作声，伪装成自己不在家的样子（DROP）。\n当把Linux系统中的防火墙策略设置为REJECT动作后，流量发送方会看到端口不可达的响应：\n[root@linuxprobe ~]# ping -c 4 192.168.10.10 PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data. From 192.168.10.10 icmp_seq=1 Destination Port Unreachable From 192.168.10.10 icmp_seq=2 Destination Port Unreachable From 192.168.10.10 icmp_seq=3 Destination Port Unreachable From 192.168.10.10 icmp_seq=4 Destination Port Unreachable --- 192.168.10.10 ping statistics --- 4 packets transmitted, 0 received, +4 errors, 100 packet loss, time 3002ms 而把Linux系统中的防火墙策略修改成DROP动作后，流量发送方会看到响应超时的提醒。但是流量发送方无法判断流量是被拒绝，还是接收方主机当前不在线：\n[root@linuxprobe ~]# ping -c 4 192.168.10.10 PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data. --- 192.168.10.10 ping statistics --- 4 packets transmitted, 0 received, 100 packet loss, time 3000ms 基本的命令参数 iptables是一款基于命令行的防火墙策略管理工具，具有大量的参数，学习难度较大。好在对于日常的防火墙策略配置来讲，大家无须深入了解诸如“四表五链”的理论概念，只需要掌握常用的参数并做到灵活搭配即可，这就足以应对日常工作了。\n根据OSI七层模型的定义，iptables属于数据链路层的服务，所以可以根据流量的源地址、目的地址、传输协议、服务类型等信息进行匹配；一旦匹配成功，iptables就会根据策略规则所预设的动作来处理这些流量。另外，再次提醒一下，防火墙策略规则的匹配顺序是从上到下的，因此要把较为严格、优先级较高的策略规则放到前面，以免发生错误。表8-1总结归纳了常用的iptables命令参数。再次强调，无须死记硬背这些参数，只需借助下面的实验来理解掌握即可。\n命令格式 iptables [-t table] COMMAND chain CRETIRIA -j ACTION  -t table ：filter/nat/mangle COMMAND：定义如何对规则进行管理 chain：指定你接下来的规则到底是在哪个链上操作的，当定义策略的时候，是可以省略的 CRETIRIA:指定匹配标准 -j ACTION :指定如何进行处理  参数说明    参数 说明 示例     -F 清空规则链 iptables -F   -L 查看规则链 iptables -L   -A 追加规则 iptables -A INPUT   -D 删除规则 iptables -D INPUT 1   -R 修改规则 iptable -R INPUT 1 -s 192.168.120.0 -j DROP   -I 在头部插入规则 iptables -I INPUT 1 –dport 80 -j ACCEPT   -L 查看规则 iptables -L INPUT   -N 新的规则 iptables -N allowed   -V 查看iptables版本 iptables -V   -p 协议（tcp/udp/icmp） iptables -A INPUT -p tcp   -s 匹配原地址，加\" ! “表示除这个IP外 iptables -A INPUT -s 192.168.1.1   -d 匹配目的地址 iptables -A INPUT -d 192.168.12.1   –sport 匹配源端口流入的数据 iptables -A INPUT -p tcp –sport 22   –dport 匹配目的端口流出的数据 iptables -A INPUT -p tcp –dport 22   -i 匹配入口网卡流入的数据 iptables -A INPUT -i eth0   -o 匹配出口网卡流出的数据 iptables -A FORWARD -o eth0   -j 要进行的处理动作:DROP(丢弃)，REJECT(拒绝)，ACCEPT(接受)，SANT(基于原地址的转换) iptable -A INPUT 1 -s 192.168.120.0 -j DROP   –to-source 指定SANT转换后的地址 iptables -t nat -A POSTROUTING -s 192.168.10.0/24 -j SANT –to-source 172.16.100.1   -t 表名(raw、mangle、nat、filter) iptables -t nat   -m 使用扩展模块来进行数据包的匹配(multiport/tcp/state/addrtype) iptables -m multiport    动作说明 处理动作除了 ACCEPT、REJECT、DROP、REDIRECT 和 MASQUERADE 以外，还多出 LOG、ULOG、DNAT、SNAT、MIRROR、QUEUE、RETURN、TOS、TTL、MARK 等，其中某些处理动作不会中断过滤程序，某些处理动作则会中断同一规则链的过滤，并依照前述流程继续进行下一个规则链的过滤，一直到堆栈中的规则检查完毕为止。透过这种机制所带来的好处是，我们可以进行复杂、多重的封包过滤，简单的说，iptables 可以进行纵横交错式的过滤（tables）而非链状过滤（chains）。\n   动作 说明 示例     ACCEPT 将封包放行，进行完此处理动作后，将不再比对其它规则，直接跳往下一个规则链（nat:postrouting）    REJECT 拦阻该封包，并传送封包通知对方，可以传送的封包有几个选择：ICMP port-unreachable、ICMP echo-reply 或是 tcp-reset（这个封包会要求对方关闭联机），进行完此处理动作后，将不再比对其它规则，直接 中断过滤程序。 iptables -A FORWARD -p TCP –dport 22 -j REJECT –reject-with tcp-reset   DROP 丢弃封包不予处理，进行完此处理动作后，将不再比对其它规则，直接中断过滤程序。    REDIRECT 将封包重新导向到另一个端口（PNAT），进行完此处理动作后，将 会继续比对其它规则。 这个功能可以用来实作通透式 porxy 或用来保护 web 服务器。 iptables -t nat -A PREROUTING -p tcp –dport 80 -j REDIRECT –to-ports 8080   MASQUERADE 改写封包来源 IP 为防火墙 NIC IP，可以指定 port 对应的范围，进行完此处理动作后，直接跳往下一个规则链（mangle:postrouting）。这个功能与 SNAT 略有不同，当进行 IP 伪装时，不需指定要伪装成哪个 IP，IP 会从网卡直接读取，当使用拨接连线时，IP 通常是由 ISP 公司的 DHCP 服务器指派的，这个时候 MASQUERADE 特别有用。 iptables -t nat -A POSTROUTING -p TCP -j MASQUERADE –to-ports 1024-31000   LOG 将封包相关讯息纪录在 /var/log 中，详细位置请查阅 /etc/syslog.conf 组态档，进行完此处理动作后，将会继续比对其它规则。 iptables -A INPUT -p tcp -j LOG –log-prefix “INPUT packets”   SNAT 改写封包来源 IP 为某特定 IP 或 IP 范围，可以指定 port 对应的范围，进行完此处理动作后，将直接跳往下一个规则链（mangle:postrouting）。 iptables -t nat -A POSTROUTING -p tcp-o eth0 -j SNAT –to-source 194.236.50.155-194.236.50.160:1024-32000   DNAT 改写封包目的地 IP 为某特定 IP 或 IP 范围，可以指定 port 对应的范围，进行完此处理动作后，将会直接跳往下一个规则链（filter:input 或 filter:forward）。 iptables -t nat -A PREROUTING -p tcp -d 15.45.23.67 –dport 80 -j DNAT –to-destination 192.168.1.1-192.168.1.10:80-100   MIRROR 镜射封包，也就是将来源 IP 与目的地 IP 对调后，将封包送回，进行完此处理动作后，将会中断过滤程序。    QUEUE 中断过滤程序，将封包放入队列，交给其它程序处理。透过自行开发的处理程序，可以进行其它应用，例如：计算联机费用……等。    RETURN 结束在目前规则链中的过滤程序，返回主规则链继续过滤，如果把自订规则链看成是一个子程序，那么这个动作，就相当于提早结束子程序并返回到主程序中。    MARK 将封包标上某个代号，以便提供作为后续过滤的条件判断依据，进行完此处理动作后，将会继续比对其它规则。 iptables -t mangle -A PREROUTING -p tcp –dport 22 -j MARK –set-mark 2    例子 1．在iptables命令后添加-L参数查看已有的防火墙规则链。\n[root@linuxprobe ~]# iptables -L Chain INPUT (policy ACCEPT) target prot opt source destination ACCEPT udp -- anywhere anywhere udp dpt:domain ACCEPT tcp -- anywhere anywhere tcp dpt:domain ACCEPT udp -- anywhere anywhere udp dpt:bootps ACCEPT tcp -- anywhere anywhere tcp dpt:bootps Chain FORWARD (policy ACCEPT) target prot opt source destination ACCEPT all -- anywhere 192.168.122.0/24 ctstate RELATED,ESTABLISHED ACCEPT all -- 192.168.122.0/24 anywhere ACCEPT all -- anywhere anywhere REJECT all -- anywhere anywhere reject-with icmp-port-unreachable REJECT all -- anywhere anywhere reject-with icmp-port-unreachable Chain OUTPUT (policy ACCEPT) target prot opt source destination ACCEPT udp -- anywhere anywhere udp dpt:bootpc 2．在iptables命令后添加-F参数清空已有的防火墙规则链。\n[root@linuxprobe ~]# iptables -F [root@linuxprobe ~]# iptables -L Chain INPUT (policy ACCEPT) target prot opt source destination Chain FORWARD (policy ACCEPT) target prot opt source destination Chain OUTPUT (policy ACCEPT) target prot opt source destination 3．把INPUT规则链的默认策略设置为拒绝。\n[root@linuxprobe ~]# iptables -P INPUT DROP [root@linuxprobe ~]# iptables -L Chain INPUT (policy DROP) target prot opt source destination Chain FORWARD (policy ACCEPT) target prot opt source destination Chain OUTPUT (policy ACCEPT) target prot opt source destination 前文提到，防火墙策略规则的设置无非有两种方式：“通”和“堵”。当把INPUT链设置为默认拒绝后，就要往里面写入允许策略了，否则所有流入的数据包都会被默认拒绝掉。同学们需要留意的是，规则链的默认策略拒绝动作只能是DROP，而不能是REJECT。\n4．向INPUT链中添加允许ICMP流量进入的策略规则。\n在日常运维工作中，经常会使用ping命令来检查对方主机是否在线，而向防火墙的INPUT规则链中添加一条允许ICMP流量进入的策略规则就默认允许了这种ping命令检测行为。\n[root@linuxprobe ~]# iptables -I INPUT -p icmp -j ACCEPT [root@linuxprobe ~]# ping -c 4 192.168.10.10 PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data. 64 bytes from 192.168.10.10: icmp_seq=1 ttl=64 time=0.154 ms 64 bytes from 192.168.10.10: icmp_seq=2 ttl=64 time=0.041 ms 64 bytes from 192.168.10.10: icmp_seq=3 ttl=64 time=0.038 ms 64 bytes from 192.168.10.10: icmp_seq=4 ttl=64 time=0.046 ms --- 192.168.10.10 ping statistics --- 4 packets transmitted, 4 received, 0 packet loss, time 104ms rtt min/avg/max/mdev = 0.038/0.069/0.154/0.049 ms 5．删除INPUT规则链中刚刚加入的那条策略（允许ICMP流量），并把默认策略设置为允许。\n使用-F参数会清空已有的所有防火墙策略；使用-D参数可以删除某一条指定的策略，因此更加安全和准确。\n[root@linuxprobe ~]# iptables -D INPUT 1 [root@linuxprobe ~]# iptables -P INPUT ACCEPT [root@linuxprobe ~]# iptables -L Chain INPUT (policy ACCEPT) target prot opt source destination Chain FORWARD (policy ACCEPT) target prot opt source destination Chain OUTPUT (policy ACCEPT) target prot opt source destination 6．将INPUT规则链设置为只允许指定网段的主机访问本机的22端口，拒绝来自其他所有主机的流量。\n要对某台主机进行匹配，可直接写出它的IP地址；如需对网段进行匹配，则需要写为子网掩码的形式（比如192.168.10.0/24）。\n[root@linuxprobe ~]# iptables -I INPUT -s 192.168.10.0/24 -p tcp --dport 22 -j ACCEPT [root@linuxprobe ~]# iptables -A INPUT -p tcp --dport 22 -j REJECT [root@linuxprobe ~]# iptables -L Chain INPUT (policy ACCEPT) target prot opt source destination ACCEPT tcp -- 192.168.10.0/24 anywhere tcp dpt:ssh REJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachable ………………省略部分输出信息……………… 再次重申，防火墙策略规则是按照从上到下的顺序匹配的，因此一定要把允许动作放到拒绝动作前面，否则所有的流量就将被拒绝掉，从而导致任何主机都无法访问我们的服务。另外，这里提到的22号端口是ssh服务使用的。\n在设置完上述INPUT规则链之后，使用IP地址在192.168.10.0/24网段内的主机访问服务器（即前面提到的设置了INPUT规则链的主机）的22端口，效果如下：\n[root@Client A ~]# ssh 192.168.10.10 The authenticity of host '192.168.10.10 (192.168.10.10)' can't be established. ECDSA key fingerprint is SHA256:5d52kZi1la/FJK4v4jibLBZhLqzGqbJAskZiME6ZXpQ. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added '192.168.10.10' (ECDSA) to the list of known hosts. root@192.168.10.10's password: 此处输入服务器密码 Activate the web console with: systemctl enable --now cockpit.socket Last login: Wed Jan 20 16:30:28 2021 from 192.168.10.1 然后，再使用IP地址在192.168.20.0/24网段内的主机访问服务器的22端口（虽网段不同，但已确认可以相互通信），效果如下：\n[root@Client B ~]# ssh 192.168.10.10 Connecting to 192.168.10.10:22... Could not connect to '192.168.10.10' (port 22): Connection failed. 由上可以看到，提示连接请求被拒绝了（Connection failed）。\n7．向INPUT规则链中添加拒绝所有人访问本机12345端口的策略规则。\n[root@linuxprobe ~]# iptables -I INPUT -p tcp --dport 12345 -j REJECT [root@linuxprobe ~]# iptables -I INPUT -p udp --dport 12345 -j REJECT [root@linuxprobe ~]# iptables -L Chain INPUT (policy ACCEPT) target prot opt source destination REJECT udp -- anywhere anywhere udp dpt:italk reject-with icmp-port-unreachable REJECT tcp -- anywhere anywhere tcp dpt:italk reject-with icmp-port-unreachable ACCEPT tcp -- 192.168.10.0/24 anywhere tcp dpt:ssh REJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachable ………………省略部分输出信息……………… 8．向INPUT规则链中添加拒绝192.168.10.5主机访问本机80端口（Web服务）的策略规则。\n[root@linuxprobe ~]# iptables -I INPUT -p tcp -s 192.168.10.5 --dport 80 -j REJECT [root@linuxprobe ~]# iptables -L Chain INPUT (policy ACCEPT) target prot opt source destination REJECT tcp -- 192.168.10.5 anywhere tcp dpt:http reject-with icmp-port-unreachable REJECT udp -- anywhere anywhere udp dpt:italk reject-with icmp-port-unreachable REJECT tcp -- anywhere anywhere tcp dpt:italk reject-with icmp-port-unreachable ACCEPT tcp -- 192.168.10.0/24 anywhere tcp dpt:ssh REJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachable ………………省略部分输出信息……………… 9．向INPUT规则链中添加拒绝所有主机访问本机1000～1024端口的策略规则。\n前面在添加防火墙策略时，使用的是-I参数，它默认会把规则添加到最上面的位置，因此优先级是最高的。如果工作中需要添加一条最后“兜底”的规则，那就用-A参数吧。这两个参数的效果差别还是很大的：\n[root@linuxprobe ~]# iptables -A INPUT -p tcp --dport 1000:1024 -j REJECT [root@linuxprobe ~]# iptables -A INPUT -p udp --dport 1000:1024 -j REJECT [root@linuxprobe ~]# iptables -L Chain INPUT (policy ACCEPT) target prot opt source destination REJECT tcp -- 192.168.10.5 anywhere tcp dpt:http reject-with icmp-port-unreachable REJECT udp -- anywhere anywhere udp dpt:italk reject-with icmp-port-unreachable REJECT tcp -- anywhere anywhere tcp dpt:italk reject-with icmp-port-unreachable ACCEPT tcp -- 192.168.10.0/24 anywhere tcp dpt:ssh REJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachable REJECT tcp -- anywhere anywhere tcp dpts:cadlock2:1024 reject-with icmp-port-unreachable REJECT udp -- anywhere anywhere udp dpts:cadlock2:1024 reject-with icmp-port-unreachable ………………省略部分输出信息……………… 有关iptables命令的知识讲解到此就结束了，大家是不是意犹未尽？考虑到Linux防火墙的发展趋势，大家只要能把上面的实例吸收消化，就可以完全搞定日常的iptables配置工作了。但是请特别注意，使用iptables命令配置的防火墙规则默认会在系统下一次重启时失效，如果想让配置的防火墙策略永久生效，还要执行保存命令：\n[root@linuxprobe ~]# iptables-save  # Generated by xtables-save v1.8.2 on Wed Jan 20 16:56:27 2021 ………………省略部分输出信息……………… 对了，如果公司服务器是5/6/7版本的话，对应的保存命令应该是：\n[root@linuxprobe ~]# service iptables save iptables: Saving firewall rules to /etc/sysconfig/iptables: [ OK ] 基本概念 iptables 是一个配置 Linux 内核 防火墙 的命令行工具，是 Netfilter 项目的一部分。术语 iptables 也经常代指该内核级防火墙。iptables 可以直接配置，也可以通过许多 控制台 和 图形化 前端配置。iptables 用于 ipv4，ip6tables 用于 IPv6。iptables和ip6tables 拥有相同的语法，但是有些特别的选项，对 IPv4 和 IPv6 有些不同的。\niptables 可以检测、修改、转发、重定向和丢弃 IPv4 数据包。过滤 IPv4 数据包的代码已经内置于内核中，并且按照不同的目的被组织成 表 的集合。表 由一组预先定义的 链 组成，链 包含遍历顺序规则。每一条规则包含一个谓词的潜在匹配和相应的动作（称为 目标），如果谓词为真，该动作会被执行。也就是说条件匹配。iptables 是用户工具，允许用户使用 链 和 规则。很多新手面对复杂的 linux IP 路由时总是感到气馁，但是，实际上最常用的一些应用案例（NAT 或者基本的网络防火墙）并不是很复杂。\n理解 iptables 如何工作的关键是上面这张图。图中在上面的小写字母代表 表，在下面的大写字母代表 链。从任何网络端口 进来的每一个 IP 数据包都要从上到下的穿过这张图。一种常见的错误认知是认为 iptables 对从内部端口进入的数据包和从面向互联网端口进入的数据包采取不同的处理方式，相反，iptabales 对从任何端口进入的数据包都会采取相同的处理方式。可以定义规则使 iptables 采取不同的方式对待从不同端口进入的数据包。当然一些数据包是用于本地进程的，因此在图中表现为从顶端进入，到  停止，而另一些数据包是由本地进程生成的，因此在图中表现为从  发出，一直向下穿过该流程图。一份关于该流程图如何工作的详细解释请参考这里。\n在大多数使用情况下都不会用到 raw，mangle 和 security 表。\n表(Tables) ptables 包含 5 张表（tables）:\n raw 用于配置数据包，raw 中的数据包不会被系统跟踪。 filter 是用于存放所有与防火墙相关操作的默认表。 nat 用于 网络地址转换（例如：端口转发）。 mangle 用于对特定数据包的修改（参考 损坏数据包）。 security 用于 强制访问控制 网络规则（例如： SELinux – 详细信息参考 该文章）。  大部分情况仅需要使用 filter 和 nat。其他表用于更复杂的情况——包括多路由和路由判定——已经超出了本文介绍的范围。\n链(Chains) 表由链组成，链是一些按顺序排列的规则的列表。默认的 filter 表包含 INPUT， OUTPUT 和 FORWARD 3条内建的链，这3条链作用于数据包过滤过程中的不同时间点，如该上面流程图所示。nat 表包含PREROUTING， POSTROUTING 和 OUTPUT 链。\n使用 iptables(8) 查看其他表中内建链的描述。\n默认情况下，任何链中都没有规则。可以向链中添加自己想用的规则。链的默认规则通常设置为 ACCEPT，如果想确保任何包都不能通过规则集，那么可以重置为 DROP。默认的规则总是在一条链的最后生效，所以在默认规则生效前数据包需要通过所有存在的规则。\n用户可以加入自己定义的链，从而使规则集更有效并且易于修改。如何使用自定义链请参考 Simple stateful firewall。\n规则 (Rules) 数据包的过滤基于 规则。规则由一个目标（数据包包匹配所有条件后的动作）和很多匹配（导致该规则可以应用的数据包所满足的条件）指定。一个规则的典型匹配事项是数据包进入的端口（例如：eth0 或者 eth1）、数据包的类型（ICMP, TCP, 或者 UDP）和数据包的目的端口。\n目标使用 -j 或者 --jump 选项指定。目标可以是用户定义的链（例如，如果条件匹配，跳转到之后的用户定义的链，继续处理）、一个内置的特定目标或者是一个目标扩展。内置目标是 ACCEPT， DROP， QUEUE 和 RETURN，目标扩展是 REJECT 和 LOG。如果目标是内置目标，数据包的命运会立刻被决定并且在当前表的数据包的处理过程会停止。如果目标是用户定义的链，并且数据包成功穿过第二条链，目标将移动到原始链中的下一个规则。目标扩展可以被终止（像内置目标一样）或者不终止（像用户定义链一样）。详细信息参阅 iptables-extensions(8)。\n遍历链(Traversing Chains) 该流程图描述链了在任何接口上收到的网络数据包是按照怎样的顺序穿过表的交通管制链。第一个路由策略包括决定数据包的目的地是本地主机（这种情况下，数据包穿过 INPUT 链），还是其他主机（数据包穿过 FORWARD 链）；中间的路由策略包括决定给传出的数据包使用那个源地址、分配哪个接口；最后一个路由策略存在是因为先前的 mangle 与 nat 链可能会改变数据包的路由信息。数据包通过路径上的每一条链时，链中的每一条规则按顺序匹配；无论何时匹配了一条规则，相应的 target/jump 动作将会执行。最常用的3个 target 是 ACCEPT, DROP ,或者 jump 到用户自定义的链。内置的链有默认的策略，但是用户自定义的链没有默认的策略。在 jump 到的链中，若每一条规则都不能提供完全匹配，那么数据包像下面这张图片描述的一样返回到调用链。在任何时候，若 DROP target 的规则实现完全匹配，那么被匹配的数据包会被丢弃，不会进行进一步处理。如果一个数据包在链中被 ACCEPT，那么它也会被所有的父链 ACCEPT，并且不再遍历其他父链。然而，要注意的是，数据包还会以正常的方式继续遍历其他表中的其他链。\n模块(Modules) 有许多模块可以用来扩展 iptables，例如 connlimit, conntrack, limit 和 recent。这些模块增添了功能，可以进行更复杂的过滤。\nFirewalld RHEL 8系统中集成了多款防火墙管理工具，其中firewalld（Dynamic Firewall Manager of Linux systems，Linux系统的动态防火墙管理器）服务是默认的防火墙配置管理工具，它拥有基于CLI（命令行界面）和基于GUI（图形用户界面）的两种管理方式。\nRHEL 8系统中集成了多款防火墙管理工具，其中firewalld（Dynamic Firewall Manager of Linux systems，Linux系统的动态防火墙管理器）服务是默认的防火墙配置管理工具，它拥有基于CLI（命令行界面）和基于GUI（图形用户界面）的两种管理方式。\n相较于传统的防火墙管理配置工具，firewalld支持动态更新技术并加入了区域（zone）的概念。简单来说，区域就是firewalld预先准备了几套防火墙策略集合（策略模板），用户可以根据生产场景的不同而选择合适的策略集合，从而实现防火墙策略之间的快速切换。例如，我们有一台笔记本电脑，每天都要在办公室、咖啡厅和家里使用。按常理来讲，这三者的安全性按照由高到低的顺序来排列，应该是家庭、公司办公室、咖啡厅。当前，我们希望为这台笔记本电脑制定如下防火墙策略规则：在家中允许访问所有服务；在办公室内仅允许访问文件共享服务；在咖啡厅仅允许上网浏览。在以往，我们需要频繁地手动设置防火墙策略规则，而现在只需要预设好区域集合，然后轻点鼠标就可以自动切换了，从而极大地提升了防火墙策略的应用效率。firewalld中常见的区域名称（默认为public）以及相应的策略规则如表所示。\n   区域 默认规则策略     trusted 允许所有的数据包   home 拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、mdns、ipp-client、amba-client与dhcpv6-client服务相关，则允许流量   internal 等同于home区域   work 拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、ipp-client与dhcpv6-client服务相关，则允许流量   public 拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、dhcpv6-client服务相关，则允许流量   external 拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量   dmz 拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量   block 拒绝流入的流量，除非与流出的流量相关   drop 拒绝流入的流量，除非与流出的流量相关    终端管理工具 命令行终端是一种极富效率的工作方式，firewall-cmd是firewalld防火墙配置管理工具的CLI（命令行界面）版本。它的参数一般都是以“长格式”来提供的。大家不要一听到长格式就头大，因为RHEL 8系统支持部分命令的参数补齐，其中就包含这条命令（很酷吧）。也就是说，现在除了能用Tab键自动补齐命令或文件名等内容之外，还可以用Tab键来补齐表所示的长格式参数。这太棒了！\n   参数 作用     –get-default-zone 查询默认的区域名称   –set-default-zone= 设置默认的区域，使其永久生效   –get-zones 显示可用的区域   –get-services 显示预先定义的服务   –get-active-zones 显示当前正在使用的区域与网卡名称   –add-source= 将源自此IP或子网的流量导向指定的区域   –remove-source= 不再将源自此IP或子网的流量导向某个指定区域   –add-interface= 将源自该网卡的所有流量都导向某个指定区域   –change-interface= 将某个网卡与区域进行关联   –list-all 显示当前区域的网卡配置参数、资源、端口以及服务等信息   –list-all-zones 显示所有区域的网卡配置参数、资源、端口以及服务等信息   –add-service= 设置默认区域允许该服务的流量   –add-port= 设置默认区域允许该端口的流量   –remove-service= 设置默认区域不再允许该服务的流量   –remove-port= 设置默认区域不再允许该端口的流量   –reload 让“永久生效”的配置规则立即生效，并覆盖当前的配置规则   –panic-on 开启应急状况模式   –panic-off 关闭应急状况模式    与Linux系统中其他的防火墙策略配置工具一样，使用firewalld配置的防火墙策略默认为运行时（Runtime）模式，又称为当前生效模式，而且会随着系统的重启而失效。如果想让配置策略一直存在，就需要使用永久（Permanent）模式了，方法就是在用firewall-cmd命令正常设置防火墙策略时添加–permanent参数，这样配置的防火墙策略就可以永久生效了。但是，永久生效模式有一个“不近人情”的特点，就是使用它设置的策略只有在系统重启之后才能自动生效。如果想让配置的策略立即生效，需要手动执行firewall-cmd –reload命令。\n接下来的实验都很简单，但是提醒大家一定要仔细查看使用的是Runtime模式还是Permanent模式。如果不关注这个细节，就算正确配置了防火墙策略，也可能无法达到预期的效果。\n1．查看firewalld服务当前所使用的区域。\n这是一步非常重要的操作。在配置防火墙策略前，必须查看当前生效的是哪个区域，否则配置的防火墙策略将不会立即生效。\n[root@linuxprobe ~]# firewall-cmd --get-default-zone public 2．查询指定网卡在firewalld服务中绑定的区域。\n在生产环境中，服务器大多不止有一块网卡。一般来说，充当网关的服务器有两块网卡，一块对公网，另外一块对内网，那么这两块网卡在审查流量时所用的策略肯定也是不一致的。因此，可以根据网卡针对的流量来源，为网卡绑定不同的区域，实现对防火墙策略的灵活管控。\n[root@linuxprobe ~]# firewall-cmd --get-zone-of-interface=ens160 public 3．把网卡默认区域修改为external，并在系统重启后生效。\n[root@linuxprobe ~]# firewall-cmd --permanent --zone=external --change-interface=ens160 The interface is under control of NetworkManager, setting zone to 'external'. success [root@linuxprobe ~]# firewall-cmd --permanent --get-zone-of-interface=ens160 external 4．把firewalld服务的默认区域设置为public。\n默认区域也叫全局配置，指的是对所有网卡都生效的配置，优先级较低。在下面的代码中可以看到，当前默认区域为public，而ens160网卡的区域为external。此时便是以网卡的区域名称为准。\n通俗来说，默认区域就是一种通用的政策。例如，食堂为所有人准备了一次性餐具，而环保主义者则会自己携带碗筷。如果您自带了碗筷，就可以用自己的；反之就用食堂统一提供的。\n[root@linuxprobe ~]# firewall-cmd --set-default-zone=public Warning: ZONE_ALREADY_SET: public success [root@linuxprobe ~]# firewall-cmd --get-default-zone  public [root@linuxprobe ~]# firewall-cmd --get-zone-of-interface=ens160 external 5．启动和关闭firewalld防火墙服务的应急状况模式。\n如果想在1s的时间内阻断一切网络连接，有什么好办法呢？大家下意识地会说：“拔掉网线！”这是一个物理级别的高招。但是，如果人在北京，服务器在异地呢？panic紧急模式在这个时候就派上用场了。使用–panic-on参数会立即切断一切网络连接，而使用–panic-off则会恢复网络连接。切记，紧急模式会切断一切网络连接，因此在远程管理服务器时，在按下回车键前一定要三思。\n[root@linuxprobe ~]# firewall-cmd --panic-on success [root@linuxprobe ~]# firewall-cmd --panic-off success 6．查询SSH和HTTPS协议的流量是否允许放行。\n在工作中可以不使用–zone参数指定区域名称，firewall-cmd命令会自动依据默认区域进行查询，从而减少用户输入量。但是，如果默认区域与网卡所绑定的不一致时，就会发生冲突，因此规范写法的zone参数是一定要加的。\n[root@linuxprobe ~]# firewall-cmd --zone=public --query-service=ssh yes [root@linuxprobe ~]# firewall-cmd --zone=public --query-service=https no 7．把HTTPS协议的流量设置为永久允许放行，并立即生效。\n默认情况下进行的修改都属于Runtime模式，即当前生效而重启后失效，因此在工作和考试中尽量避免使用。而在使用–permanent参数时，则是当前不会立即看到效果，而在重启或重新加载后方可生效。于是，在添加了允许放行HTTPS流量的策略后，查询当前模式策略，发现依然是不允许放行HTTPS协议的流量：\n[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --add-service=https success [root@linuxprobe ~]# firewall-cmd --zone=public --query-service=https no 不想重启服务器的话，就用–reload参数吧：\n[root@linuxprobe ~]# firewall-cmd --reload success [root@linuxprobe ~]# firewall-cmd --zone=public --query-service=https yes 8．把HTTP协议的流量设置为永久拒绝，并立即生效。\n由于在默认情况下HTTP协议的流量就没有被允许，所以会有“Warning: NOT_ENABLED: http”这样的提示信息，因此对实际操作没有影响。\n[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --remove-service=http Warning: NOT_ENABLED: http success [root@linuxprobe ~]# firewall-cmd --reload  success 9．把访问8080和8081端口的流量策略设置为允许，但仅限当前生效。\n[root@linuxprobe ~]# firewall-cmd --zone=public --add-port=8080-8081/tcp success [root@linuxprobe ~]# firewall-cmd --zone=public --list-ports 8080-8081/tcp 10．把原本访问本机888端口的流量转发到22端口，要且求当前和长期均有效。\nSSH远程控制协议是基于TCP/22端口传输控制指令的，如果想让用户通过其他端口号也能访问ssh服务，就可以试试端口转发技术了。通过这项技术，新的端口号在收到用户请求后会自动转发到原本服务的端口上，使得用户能够通过新的端口访问到原本的服务。\n来举个例子帮助大家理解。假设小强是电子厂的工人，他喜欢上了三号流水线上的工人小花，但不好意思表白，于是写了一封情书并交给门卫张大爷，希望由张大爷转交给小花。这样一来，情书（信息）的传输由从小强到小花，变成了小强到张大爷再到小花，情书（信息）依然能顺利送达。\n使用firewall-cmd命令实现端口转发的格式有点长，这里为大家总结好了：\nfirewall-cmd --permanent --zone= --add-forward-port=port=:proto=:toport=:toaddr= 上述命令中的目标IP地址一般是服务器本机的IP地址：\n[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --add-forward-port=port=888:proto=tcp:toport=22:toaddr=192.168.10.10 success [root@linuxprobe ~]# firewall-cmd --reload success 在客户端使用ssh命令尝试访问192.168.10.10主机的888端口，访问成功：\n[root@client A ~]# ssh -p 888 192.168.10.10 The authenticity of host '[192.168.10.10]:888 ([192.168.10.10]:888)' can't be established. ECDSA key fingerprint is b8:25:88:89:5c:05:b6:dd:ef:76:63:ff:1a:54:02:1a. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added '[192.168.10.10]:888' (ECDSA) to the list of known hosts. root@192.168.10.10's password:此处输入远程root管理员的密码 Last login: Sun Jul 19 21:43:48 2021 from 192.168.10.10 11．富规则的设置。\n富规则也叫复规则，表示更细致、更详细的防火墙策略配置，它可以针对系统服务、端口号、源地址和目标地址等诸多信息进行更有针对性的策略配置。它的优先级在所有的防火墙策略中也是最高的。比如，我们可以在firewalld服务中配置一条富规则，使其拒绝192.168.10.0/24网段的所有用户访问本机的ssh服务（22端口）：\n[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --add-rich-rule=\"rule family=\"ipv4\" source address=\"192.168.10.0/24\" service name=\"ssh\" reject\" success [root@linuxprobe ~]# firewall-cmd --reload success 在客户端使用ssh命令尝试访问192.168.10.10主机的ssh服务（22端口）：\n[root@client A ~]# ssh 192.168.10.10 Connecting to 192.168.10.10:22... Could not connect to '192.168.10.10' (port 22): Connection failed. 图形管理工具 在各种版本的Linux系统中，几乎没有能让刘遄老师欣慰并推荐的图形化工具，但是firewall-config做到了。它是firewalld防火墙配置管理工具的GUI（图形用户界面）版本，几乎可以实现所有以命令行来执行的操作。毫不夸张地说，即使读者没有扎实的Linux命令基础，也完全可以通过它来妥善配置RHEL 8中的防火墙策略。\n成功 firewall-config 安装后，其工具的界面如图所示：\n其功能具体如下。\n1：选择运行时（Runtime）或永久（Permanent）模式的配置。\n2：可选的策略集合区域列表。\n3：常用的系统服务列表。\n4：主机地址的黑白名单。\n5：当前正在使用的区域。\n6：管理当前被选中区域中的服务。\n7：管理当前被选中区域中的端口。\n8：设置允许被访问的协议。\n9：设置允许被访问的端口。\n10：开启或关闭SNAT（源网络地址转换）技术。\n11：设置端口转发策略。\n12：控制请求icmp服务的流量。\n13：管理防火墙的富规则。\n14：被选中区域的服务，若勾选了相应服务前面的复选框，则表示允许与之相关的流量。\n15：firewall-config工具的运行状态。\n除了图中列出的功能，还有用于将网卡与区域绑定的Interfaces选项，以及用于将IP地址与区域绑定的Sources选项。另外再啰唆一句。在使用firewall-config工具配置完防火墙策略之后，无须进行二次确认，因为只要有修改内容，它就自动进行保存。\n下面进行动手实践环节。\n先将当前区域中请求http服务的流量设置为允许放行，但仅限当前生效。具体配置如图所示：\n尝试添加一条防火墙策略规则，使其放行访问8080～8088端口（TCP协议）的流量，并将其设置为永久生效，以达到系统重启后防火墙策略依然生效的目的。在按照下图所示的界面配置完毕之后，还需要在Options菜单中单击Reload Firewalld命令，让配置的防火墙策略立即生效。这与在命令行中使用–reload参数的效果一样。\n放行访问8080～8088端口的流量：\n让配置的防火墙策略规则立即生效：\n前面在讲解firewall-config工具的功能时，曾经提到了SNAT（Source Network Address Translation，源网络地址转换）技术。SNAT是一种为了解决IP地址匮乏而设计的技术，它可以使得多个内网中的用户通过同一个外网IP接入Internet。该技术的应用非常广泛，甚至可以说我们每天都在使用，只不过没有察觉到罢了。比如，当通过家中的网关设备（无线路由器）访问本书配套站点www.linuxprobe.com时，就用到了SNAT技术。\n大家可以看一下在网络中不使用SNAT技术和使用SNAT技术时的情况。在没有使用SNAT技术的局域网中有多台PC，如果网关服务器没有应用SNAT技术，则互联网中的网站服务器在收到PC的请求数据包，并回送响应数据包时，将无法在网络中找到这个私有网络的IP地址，所以PC也就收不到响应数据包了。在使用SNAT技术处理过的局域网中，由于网关服务器应用了SNAT技术，所以互联网中的网站服务器会将响应数据包发给网关服务器，再由后者转发给局域网中的PC。\n没有使用SNAT技术的网络：\n使用SNAT技术处理过的网络：\n使用iptables命令实现SNAT技术是一件很麻烦的事情，但是在firewall-config中却是小菜一碟了。用户只需按照下图进行配置，并选中Masquerade zone复选框，就自动开启了SNAT技术。\n为了让大家直观查看不同工具在实现相同功能时的区别，针对前面使用firewall-cmd配置的防火墙策略规则，这里使用firewall-config工具进行了重新演示：将本机888端口的流量转发到22端口，且要求当前和长期均有效，具体如下图所示：\n配置本地的端口转发：\n让防火墙效策略规则立即生效：\n用命令配置富规则可真辛苦，幸好我们现在有了图形用户界面的工具。让192.168.10.20主机访问本机的1234端口号，如下图所示。其中Element选项能够根据服务名称、端口号、协议等信息进行匹配；Source与Destination选项后的inverted复选框代表反选功能，将其选中则代表对已填写信息进行反选，即选中填写信息以外的主机地址；Log复选框在选中后，日志不仅会被记录到日志文件中，而且还可以在设置日志的级别（Level）后，再将日志记录到日志文件中，以方便后续的筛查。\n如果生产环境中的服务器有多块网卡在同时提供服务（这种情况很常见），则对内网和对外网提供服务的网卡要选择的防火墙策略区域也是不一样的。也就是说，可以把网卡与防火墙策略区域进行绑定，这样就可以使用不同的防火墙区域策略，对源自不同网卡的流量进行有针对性的监控，效果会更好。\n把网卡与防火墙策略区域进行绑定：\n网卡与策略区域绑定完成：\n最后再提一句，firewall-config工具真的非常实用，很多原本复杂的长命令被图形化按钮替代，设置规则也简单明了，足以应对日常工作。所以再次向大家强调配置防火墙策略的原则—只要能实现所需的功能，用什么工具请随君便。\n服务的访问控制列表 TCP Wrapper是RHEL 6/7系统中默认启用的一款流量监控程序，它能够根据来访主机的地址与本机的目标服务程序做出允许或拒绝的操作。在RHEL 8版本中，它已经被firewalld正式替代。换句话说，Linux系统中其实有两个层面的防火墙，第一种是前面讲到的基于TCP/IP协议的流量过滤工具，而TCP Wrapper服务则是能允许或禁止Linux系统提供服务的防火墙，从而在更高层面保护了Linux系统的安全运行。\nTCP Wrapper服务的防火墙策略由两个控制列表文件所控制，用户可以编辑允许控制列表文件来放行对服务的请求流量，也可以编辑拒绝控制列表文件来阻止对服务的请求流量。控制列表文件修改后会立即生效，系统将会先检查允许控制列表文件（/etc/hosts.allow），如果匹配到相应的允许策略则放行流量；如果没有匹配，则会进一步匹配拒绝控制列表文件（/etc/hosts.deny），若找到匹配项则拒绝该流量。如果这两个文件都没有匹配到，则默认放行流量。\n由于RHEL 8版本已经不再支持TCP Wrapper服务程序，因此我们接下来选择在一台老版本的服务器上进行实验。TCP Wrapper服务的控制列表文件配置起来并不复杂，常用的参数如表所示。\n   客户端类型 示例 满足示例的客户端列表     单一主机 192.168.10.10 IP地址为192.168.10.10的主机   指定网段 192.168.10. IP段为192.168.10.0/24的主机   指定网段 192.168.10.0/255.255.255.0 IP段为192.168.10.0/24的主机   指定DNS后缀 .linuxprobe.com 所有DNS后缀为.linuxprobe.com的主机   指定主机名称 www.linuxprobe.com 主机名称为www.linuxprobe.com的主机   指定所有客户端 ALL 所有主机全部包括在内    在配置TCP Wrapper服务时需要遵循两个原则：\n 编写拒绝策略规则时，填写的是服务名称，而非协议名称； 建议先编写拒绝策略规则，再编写允许策略规则，以便直观地看到相应的效果。  下面编写拒绝策略规则文件，禁止访问本机sshd服务的所有流量（无须修改/etc/hosts.deny文件中原有的注释信息）：\n[root@linuxprobe ~]# vim /etc/hosts.deny # # hosts.deny This file contains access rules which are used to # deny connections to network services that either use # the tcp_wrappers library or that have been # started through a tcp_wrappers-enabled xinetd. # # The rules in this file can also be set up in # /etc/hosts.allow with a 'deny' option instead. # # See 'man 5 hosts_options' and 'man 5 hosts_access' # for information on rule syntax. # See 'man tcpd' for information on tcp_wrappers sshd:* [root@linuxprobe ~]# ssh 192.168.10.10 ssh_exchange_identification: read: Connection reset by peer 接下来，在允许策略规则文件中添加一条规则，使其放行源自192.168.10.0/24网段，且访问本机sshd服务的所有流量。可以看到，服务器立刻就放行了访问sshd服务的流量，效果非常直观：\n[root@linuxprobe ~]# vim /etc/hosts.allow # # hosts.allow This file contains access rules which are used to # allow or deny connections to network services that # either use the tcp_wrappers library or that have been # started through a tcp_wrappers-enabled xinetd. # # See 'man 5 hosts_options' and 'man 5 hosts_access' # for information on rule syntax. # See 'man tcpd' for information on tcp_wrappers sshd:192.168.10. [root@linuxprobe ~]# ssh 192.168.10.10 The authenticity of host '192.168.10.10 (192.168.10.10)' can't be established. ECDSA key fingerprint is 70:3b:5d:37:96:7b:2e:a5:28:0d:7e:dc:47:6a:fe:5c. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added '192.168.10.10' (ECDSA) to the list of known hosts. root@192.168.10.10's password: Last login: Wed May 4 07:56:29 2021 [root@linuxprobe ~]#  Cockpit 驾驶舱管理工具 首先，Cockpit是一个英文单词，即“（飞机、船或赛车的）驾驶舱、驾驶座”，它用名字传达出了功能丰富的特性。其次，Cockpit是一个基于Web的图形化服务管理工具，对用户相当友好，即便是新手也可以轻松上手。而且它天然具备很好的跨平台性，因此被广泛应用于服务器、容器、虚拟机等多种管理场景。最后，红帽公司对Cockpit也十分看重，直接将它默认安装到了RHEL 8系统中，由此衍生的CentOS和Fedora也都标配有Cockpit。\nCockpit在默认情况下就已经被安装到系统中。下面执行dnf命令对此进行确认：\n[root@linuxprobe ~]# dnf install cockpit Updating Subscription Management repositories. Unable to read consumer identity This system is not registered to Red Hat Subscription Management. You can use subscription-manager to register. AppStream 3.1 MB/s | 3.2 kB 00:00 BaseOS 2.7 MB/s | 2.7 kB 00:00 Package cockpit-185-2.el8.x86_64 is already installed. Dependencies resolved. Nothing to do. Complete! 但是，Cockpit服务程序在RHEL 8版本中没有自动运行，下面将它开启并加入到开机启动项中：\n[root@linuxprobe ~]# systemctl start cockpit [root@linuxprobe ~]# systemctl enable cockpit.socket Created symlink /etc/systemd/system/sockets.target.wants/cockpit.socket → /usr/lib/systemd/system/cockpit.socket. 在Cockpit服务启动后，打开系统自带的浏览器，在地址栏中输入“本机地址:9090”即可访问。由于访问Cockpit的流量会使用HTTPS进行加密，而证书又是在本地签发的，因此还需要进行添加并信任本地证书的操作。\n添加额外允许的证书：\n确认信任本地证书：\n进入Cockpit的登录界面后，输入root管理员的账号与系统密码，单击Log In按钮后即可进入：\n进入Cockpit的Web界面，发现里面可谓“别有洞天”。Cockpit总共分为13个功能模块：系统状态（System）、日志信息（Logs）、硬盘存储（Storage）、网卡网络（Networking）、账户安全（Accounts）、服务程序（Services）、软件仓库（Applications）、报告分析（Diagnostic Reports）、内核排错（Kernel Dump）、SElinux、更新软件（Software Updates）、订阅服务（Subscriptions）、终端界面（Terminal）。下面逐一进行讲解。\n1．System\n进入Cockpit界面后默认显示的便是System（系统）界面，在该界面中能够看到系统架构、版本、主机名与时间等信息，还能够动态地展现出CPU、硬盘、内存和网络的复杂情况，这有点类似于Web版的“Winodws系统任务管理器”，属实好用。\n系统状态界面：\n2．Logs\n这个模块能够提供系统的全部日志，但是同学们可能会好奇，“为什么下图中的内容这么有限呢”？原因出在图中的两个选项中：时间和日志级别。通过这两个选项可以让用户更快地找到所需信息，而不是像/var/log/message文件那样一股脑儿地都抛给用户。\n日志信息界面：\n3．Storage\n这个功能模块是同学们最喜欢的一个模块，原因不是这个模块显示了硬盘的I/O读写负载情况，而是可以让用户通过该界面，用鼠标创建出RAID、LVM、VDO和iSCSI等存储设备。是的，您没有看错，RAID和LVM都可以用鼠标进行创建了，是不是很开心呢？\n硬盘存储界面：\n4．Networking\n既然名为Networking模块，那么动态看网卡的输出和接收值肯定是这个模块的标配功能了。我们不仅可以在这里进行网卡的绑定（Bonding）和聚合（Team），还可以创建桥接网卡及添加VLAN。最下方会单独列出与网卡相关的日志信息。\n网卡网络界面：\n**5．**Accounts\n大家千万别小看Accounts模块，虽然它的账户安全界面有些简陋，只有一个用于创建账户的按钮，但只要点击进入某个用户的管理界面中，马上会发现“别有洞天”——账户管理界面，这个界面中的功能非常丰富，我们在这里可以对用户进行重命名，设置用户的权限，还可以锁定、修改密码以及创建SSH密钥信息。\n账户安全界面：\n账户管理界面：\n6．Services\n在Services功能模块的界面中，可以查看系统中已有的服务列表和运行状态。单击某一服务，进入该服务的管理界面后，可以对具体的服务进行开启、关闭操作。在Services功能模块中设置了服务并将其加入到开机启动项后，在系统重启后也依然会为用户提供服务。\n服务程序界面：\n服务管理界面：\n7．Applications\n后期采用Cockpit或红帽订阅服务安装的软件都会显示在这个功能模块中。\n软件仓库界面：\n8．Diagnostic Report\nDiagnostic Report模块的功能是帮助用户收集及分析系统的信息，找到系统出现问题的原因。单击Create Report按钮后大约两分钟左右，会出现报告生成完毕的弹窗。好吧，摊牌了，这个功能其实很鸡肋，就是将sosreport命令做成了一个网页按钮。\n报告分析界面：\n报告生成完毕：\n9．Kernel Dump\nKernel Dump（Kdump）是一个在系统崩溃、死锁或死机时用来收集内核参数的一个服务。举例来说，如果有一天系统崩溃了，这时Kdump服务就会开始工作，将系统的运行状态和内核数据收集到一个名为dump core的文件中，以便后续让运维人员分析并找出问题所在。由于我们在安装系统时没有启动该服务，所以可以等到后续使用时再开启该功能界面。\n内核排错界面：\n10．SElinux\n下图所示为SELinux服务的控制按钮和警告信息界面。\nSElinux管理界面：\n11．Software Updates\n这里提到的Software Updates并不是我们用来更新其他常规软件的一个界面，而是用来对红帽客户订阅的服务进行更新的界面。用户只有在购买了红帽第三方服务后才能使用这里面的功能。在购买了红帽订阅服务后，用户便可以在这里下载到相应服务程序的最新版本和稳定版本。\n更新软件界面：\n12．Subscriptions\n这里依然是一则红帽公司的“小广告”—如果想成为尊贵的红帽服务用户，要付费购买订阅服务。个人用户无须购买，而且这对我们的后续实验没有任何影响。\n订阅服务界面：\n12．Terminal\n压轴的总是在最后。Cockpit服务提供了Shell终端的在线控制平台，可方便用户通过网页上的终端功能管理服务器。这个功能深受运维人员喜爱。\n终端管理界面\n至此，相信各位读者已经充分掌握了防火墙的管理能力。防火墙管理工具有很多种，我们任选其一即可。在配置后续的服务前，大家要记得检查网络和防火墙的状态，以避免出现服务明明配置正确，但无法从外部访问的情况，最终影响实验效果。\n在 Ubuntu 上使用 UFW\u0026GUFW Ubuntu 20.04 随附了一个称为UFW（非复杂防火墙）的防火墙配置工具。 它是用于管理iptables防火墙规则的用户友好型前端。 它的主要目标是使防火墙的管理变得更容易，或者顾名思义，变得简单。而GUFW是UFW的图形介面。\n检查UFW状态 UFW默认情况下处于禁用状态。 您可以使用以下命令检查UFW服务的状态：\n$ sudo ufw status verbose 输出将显示防火墙状态为非活动：\nStatus: inactive 如果UFW已激活，则输出将类似于以下内容：\nStatus: active UFW默认策略 UFW防火墙的默认行为是阻止所有传入和转发流量，并允许所有出站流量。 这意味着除非您专门打开端口，否则任何尝试访问您的服务器的人都将无法连接。 服务器上运行的应用程序和服务将可以访问外界。\n默认策略在/etc/default/ufw文件中定义，可以通过手动修改文件或使用sudo ufw default  命令来更改。\n防火墙策略是建立更复杂和用户定义的规则的基础。 通常，最初的UFW默认策略是一个很好的起点。\n应用配置文件 应用程序配置文件是INI格式的文本文件，描述了服务并包含该服务的防火墙规则。 在安装软件包期间，会在/etc/ufw/applications.d目录中创建应用程序配置文件。\n您可以通过键入以下内容列出服务器上所有可用的应用程序配置文件：\n$ sudo ufw app list Available applications: Nginx Full Nginx HTTP Nginx HTTPS OpenSSH 要查找有关特定配置文件和包含的规则的更多信息，请使用以下命令：\n$ sudo ufw app info 'Nginx Full' Profile: Nginx Full Title: Web Server (Nginx, HTTP + HTTPS) Description: Small, but very powerful and efficient web server Ports: 80,443/tcp 输出显示“ Nginx Full”配置文件打开了端口80和443。\n您也可以为应用创建自定义配置文件。\n启用UFW 如果要从远程位置连接到Ubuntu，则在启用UFW防火墙之前，必须明确允许传入的SSH连接。 否则，您将无法连接到计算机。\n要将您的UFW防火墙配置为允许传入的SSH连接，请键入以下命令：\n$ sudo ufw allow ssh Rules updated Rules updated (v6) 如果SSH在非标准端口上运行，则需要打开该端口。\n例如，如果您的ssh守护程序侦听端口7722，请输入以下命令以允许该端口上的连接：\n$ sudo ufw allow 7722/tcp 现在已将防火墙配置为允许传入的SSH连接，您可以通过键入以下内容来启用它：\n$ sudo ufw enable Command may disrupt existing ssh connections. Proceed with operation (y|n)? y Firewall is active and enabled on system startup 将警告您启用防火墙可能会破坏现有的ssh连接，只需键入y并单击Enter。\n打开端口 根据系统上运行的应用程序，您可能还需要打开其他端口。 打开端口的一般语法如下：\n$ ufw allow port_number/protocol 以下是有关如何允许HTTP连接的几种方法。\n第一种选择是使用服务名称。 UFW检查/etc/services文件中指定服务的端口和协议：\n$ sudo ufw allow http 您还可以指定端口号和协议：\n$ sudo ufw allow 80/tcp 如果未给出协议，则UFW会同时为tcp和udp创建规则。\n另一个选择是使用应用程序配置文件； 在这种情况下，“ Nginx HTTP”：\n$ sudo ufw allow 'Nginx HTTP' UFW还支持使用proto关键字指定协议的另一种语法：\n$ sudo ufw allow proto tcp to any port 80 端口范围\nUFW还允许您打开端口范围。 起始端口和结束端口用冒号（:）分隔，并且您必须指定协议tcp或udp。\n例如，如果要同时在tcp和udp上允许端口从7100到7200，则可以运行以下命令：\n$ sudo ufw allow 7100:7200/tcp 特定的IP地址和端口\n要允许来自给定源IP的所有端口上的连接，请使用from关键字，后跟源地址。\n以下是将IP地址列入白名单的示例：\n$ sudo ufw allow from 64.63.62.61 如果要仅允许给定IP地址访问特定端口，请使用to any port关键字，后跟端口号。\n例如，要允许IP地址为64.63.62.61的计算机访问端口22，请输入：\n$ sudo ufw allow from 64.63.62.61 to any port 22 子网\n允许连接到IP地址子网的语法与使用单个IP地址时的语法相同。 唯一的区别是您需要指定子网掩码。\n下面是一个示例，显示了如何允许访问从192.168.1.1到192.168.1.254的IP地址到端口3360（MySQL ）：\n$ sudo ufw allow from 192.168.1.0/24 to any port 3306 特定网络接口\n要允许在特定的网络接口上进行连接，请使用in on关键字，后跟网络接口(网卡)的名称：\n$ sudo ufw allow in on eth2 to any port 3306 拒绝连接 所有传入连接的默认策略均设置为deny，如果您未更改默认策略，除非您专门打开连接，否则UFW会阻止所有传入连接。\n撰写拒绝规则与撰写允许规则相同； 您只需要使用deny关键字而不是allow。\n假设您打开了端口80和443，并且服务器受到23.24.25.0/24网络的攻击。 要拒绝来自23.24.25.0/24的所有连接，您可以运行以下命令：\n$ sudo ufw deny from 23.24.25.0/24 以下是拒绝访问23.24.25.0/24中的端口80和443的示例，您可以使用以下命令：\n$ sudo ufw deny proto tcp from 23.24.25.0/24 to any port 80,443 删除UFW规则 有两种方法可以通过规则编号和指定实际规则来删除UFW规则。\n按规则号删除规则比较容易，尤其是当您不熟悉UFW时。 要首先通过规则编号删除规则，您需要找到要删除的规则的编号。 要获取编号规则的列表，请使用ufw status numbered命令：\n$ sudo ufw status numbered Status: active To Action From -- ------ ---- [ 1] 22/tcp ALLOW IN Anywhere [ 2] 80/tcp ALLOW IN Anywhere [ 3] 8080/tcp ALLOW IN Anywhere 要删除规则号3，该规则号允许连接到端口8080，请输入：\n$ sudo ufw delete 3 第二种方法是通过指定实际规则来删除规则。 例如，如果您添加了打开端口8069的规则，则可以使用以下命令将其删除：\n$ sudo ufw delete allow 8069 禁用UFW 如果出于任何原因要停止UFW并停用所有规则，则可以使用：\n$ sudo ufw disable 以后，如果您想重新启用UTF并激活所有规则，只需键入：\n$ sudo ufw enable 重设UFW 重置UFW将禁用UFW，并删除所有活动规则。 如果您想还原所有更改并重新开始，这将很有帮助。\n要重置UFW，请输入以下命令：\n$ sudo ufw reset IP伪装 IP伪装是Linux内核中NAT（网络地址转换）的一种变体，它通过重写源IP地址和目标IP地址和端口来转换网络流量。 借助IP伪装，您可以使用一台充当网关的Linux计算机，允许专用网络中的一台或多台计算机与Internet通信。\n使用UFW配置IP伪装涉及几个步骤。\n首先，您需要启用IP转发。 为此，请打开/etc/ufw/sysctl.conf文件，查找并取消注释以下行：net.ipv4.ip_forward = 1：\n$ sudo nano /etc/ufw/sysctl.conf net/ipv4/ip_forward=1 接下来，您需要配置UFW以允许转发数据包。 打开UFW配置文件，找到DEFAULT_FORWARD_POLICY键，然后将值从DROP更改为ACCEPT：\n$ sudo nano /etc/default/ufw DEFAULT_FORWARD_POLICY=\"ACCEPT\" 现在，您需要在nat表中设置POSTROUTING链的默认策略和伪装规则。 为此，请打开/etc/ufw/before.rules文件，附加以下几行：\n$ sudo nano /etc/ufw/before.rules #NAT table rules *nat :POSTROUTING ACCEPT [0:0] # Forward traffic through eth0 - Change to public network interface -A POSTROUTING -s 10.8.0.0/16 -o eth0 -j MASQUERADE # don't delete the 'COMMIT' line or these rules won't be processed COMMIT 别忘了在-A POSTROUTING行中替换eth0以匹配公共网络接口的名称：\n完成后，保存并关闭文件。\n最后，通过禁用和重新启用UFW重新加载UFW规则：\n$ sudo ufw disable $ sudo ufw e udev 如果你使用Linux比较长时间了，那你就知道，在对待设备文件这块，Linux改变了几次策略。在Linux早期，设备文件仅仅是是一些带有适当的属性集的普通文件，它由mknod命令创建，文件存放在/dev目录下。后来，采用了devfs, 一个基于内核的动态设备文件系统，他首次出现在2.3.46内核中。Mandrake，Gentoo等Linux分发版本采用了这种方式。devfs创建 的设备文件是动态的。但是devfs有一些严重的限制，从2.6.13版本后移走了。目前取代他的便是文本要提到的udev－－一个用户空间程序。\n目前很多的Linux分发版本采纳了udev的方式，因为它在Linux设备访问，特别是那些对设备有极端需求的站点(比如需要控制上千个硬盘)和热插拔设备(比如USB摄像头和MP3播放器)上解决了几个问题。下面我我们来看看如何管理udev设备。\n实际上，对于那些为磁盘，终端设备等准备的标准配置文件而言，你不需要修改什么。但是，你需要了解udev配置来使用新的或者外来设备，如果不修改配置， 这些设备可能无法访问，或者说Linux可能会采用不恰当的名字，属组或权限来创建这些设备文件。你可能也想知道如何修改RS－232串口，音频设备等文件的属组或者权限。这点在实际的Linux实施中是会遇到的。\n为什么使用udev 在此之前的设备文件管理方法(静态文件和devfs)有几个缺点：\n 不确定的设备映射。特别是那些动态设备，比如USB设备，设备文件到实际设备的映射并不可靠和确定。举一个例子：如果你有两个USB打印机。一个可能称 为/dev/usb/lp0,另外一个便是/dev/usb/lp1。但是到底哪个是哪个并不清楚，lp0,lp1和实际的设备没有一一对应的关系，因为 他可能因为发现设备的顺序，打印机本身关闭等原因而导致这种映射并不确定。理想的方式应该是：两个打印机应该采用基于他们的序列号或者其他标识信息的唯一 设备文件来映射。但是静态文件和devfs都无法做到这点。 没有足够的主/辅设备号。我们知道，每一个设备文件是有两个8位的数字：一个是主设备号 ，另外一个是辅设备号来分配的。这两个8位的数字加上设备类型(块设备或者字符设备)来唯一标识一个设备。不幸的是，关联这些身边的的数字并不足够。 /dev目录下文件太多。一个系统采用静态设备文件关联的方式，那么这个目录下的文件必然是足够多。而同时你又不知道在你的系统上到底有那些设备文件是激活的。 命名不够灵活。尽管devfs解决了以前的一些问题，但是它自身又带来了一些问题。其中一个就是命名不够灵活；你别想非常简单的就能修改设备文件的名字。缺省的devfs命令机制本身也很奇怪，他需要修改大量的配置文件和程序。 内核内存使用，devfs特有的另外一个问题是，作为内核驱动模块，devfs需要消耗大量的内存，特别当系统上有大量的设备时(比如上面我们提到的系统一个上有好几千磁盘时)  udev的目标是想解决上面提到的这些问题，他通采用用户空间(user-space)工具来管理/dev/目录树，他和文件系统分开。知道如何改变缺省配置能让你之大如何定制自己的系统，比如创建设备字符连接，改变设备文件属组，权限等。\nudev配置文件 主要的udev配置文件是/etc/udev/udev.conf。这个文件通常很短，他可能只是包含几行#开头的注释，然后有几行选项：\nudev_root=“/dev/” udev_rules=“/etc/udev/rules.d/” udev_log=“err“ 上面的第二行非常重要，因为他表示udev规则存储的目录，这个目录存储的是以.rules结束的文件。每一个文件处理一系列规则来帮助udev分配名字给设备文件以保证能被内核识别。\n你的/etc/udev/rules.d下面可能有好几个udev规则文件，这些文件一部分是udev包安装的，另外一部分则是可能是别的硬件或者软件包 生成的。比如在Fedora Core 5系统上，sane-backends包就会安装60-libsane.rules文件，另外initscripts包会安装60-net.rules文 件。这些规则文件的文件名通常是两个数字开头，它表示系统应用该规则的顺序。\n规则文件里的规则有一系列的键/值对组成，键/值对之间用逗号(,)分割。每一个键或者是用户匹配键，或者是一个赋值键。匹配键确定规则是否被应用，而赋 值键表示分配某值给该键。这些值将影响udev创建的设备文件。匹配键和赋值键操作符解释见下表：\n   操作符 匹配或赋值 解释     == 匹配 相等比较   != 匹配 不等比较   = 赋值 分配一个特定的值给该键，他可以覆盖之前的赋值。   += 赋值 追加特定的值给已经存在的键   := 赋值 分配一个特定的值给该键，后面的规则不可能覆盖它。    这有点类似我们常见的编程语言，比如C语言。只是这里的键一次可以处理多个值。有一些键在udev规则文件里经常出现，这些键的值可以使用通配符(*,?,甚至范围，比如[0-9])，这些常用键列举如下：\n   键 含义     ACTION 一个时间活动的名字，比如add，当设备增加的时候   KERNEL 在内核里看到的设备名字，比如sd*表示任意SCSI磁盘设备   DEVPATH 内核设备路径，比如/devices/*   SUBSYSTEM 子系统名字，比如sound,net   BUS 总线的名字，比如IDE,USB   DRIVER 设备驱动的名字，比如ide-cdromID 独立于内核名字的设备名字   SYSFS{ value} sysfs属性值，他可以表示任意   ENV{ key} 环境变量，可以表示任意   PROGRAM 可执行的外部程序，如果程序返回0值，该键则认为为真(true)   RESULT 上一个PROGRAM调用返回的标准输出。   NAME 根据这个规则创建的设备文件的文件名。注意：仅仅第一行的NAME描述是有效的，后面的均忽略。 如果你想使用使用两个以上的名字来访问一个设备的话，可以考虑SYMLINK键。   SYMLINK 根据规则创建的字符连接名   OWNER 设备文件的属组   GROUP 设备文件所在的组。   MODE 设备文件的权限，采用8进制   RUN 为设备而执行的程序列表   LABEL 在配置文件里为内部控制而采用的名字标签(下下面的GOTO服务)   GOTO 跳到匹配的规则（通过LABEL来标识），有点类似程序语言中的GOTO   IMPORT{ type} 导入一个文件或者一个程序执行后而生成的规则集到当前文件   WAIT_FOR_SYSFS 等待一个特定的设备文件的创建。主要是用作时序和依赖问题。   PTIONS 特定的选项： last_rule 对这类设备终端规则执行； ignore_device 忽略当前规则； ignore_remove 忽略接下来的并移走请求。all_partitions 为所有的磁盘分区创建设备文件。    我们给出一个列子来解释如何使用这些键。下面的例子来自Fedora Core 5系统的标准配置文件。\nKERNEL==\"*\", OWNER=\"root\" GROUP=\"root\", MODE=\"0600\" KERNEL==\"tty\", NAME=\"%k\", GROUP=\"tty\", MODE=\"0666\", OPTIONS=\"last_rule\" KERNEL==\"scd[0-9]*\", SYMLINK+=\"cdrom cdrom-%k\" KERNEL==\"hd[a-z]\", BUS==\"ide\", SYSFS{removable}==\"1\", SYSFS{device/media}==\"cdrom\", SYMLINK+=\"cdrom cdrom-%k\" ACTION==\"add\", SUBSYSTEM==\"scsi_device\", RUN+=\"/sbin/modprobe sg\" 上面的例子给出了5个规则，每一个都是KERNEL或者ACTION键开头：\n 第一个规则是缺省的，他匹配任意被内核识别到的设备，然后设定这些设备的属组是root，组是root，访问权限模式是0600(-rw——-)。这也是一个安全的缺省设置保证所有的设备在默认情况下只有root可以读写 第二个规则也是比较典型的规则了。它匹配终端设备(tty)，然后设置新的权限为0600，所在的组是tty。它也设置了一个特别的设备文件名:%K。在这里例子里，%k代表设备的内核名字。那也就意味着内核识别出这些设备是什么名字，就创建什么样的设备文件名。 第三行开始的KERNEL==”scd[0-9]*”,表示 SCSI CD-ROM 驱动. 它创建一对设备符号连接：cdrom和cdrom-%k。 第四行，开始的 KERNEL==”hd[a-z]“, 表示ATA CDROM驱动器。这个规则创建和上面的规则相同的符号连接。ATA CDROM驱动器需要sysfs值以来区别别的ATA设备，因为SCSI CDROM可以被内核唯一识别。. 第五行以 ACTION==”add”开始，它告诉udev增加 /sbin/modprobe sg 到命令列表，当任意SCSI设备增加到系统后，这些命令将执行。其效果就是计算机应该会增加sg内核模块来侦测新的SCSI设备。  当然，上面仅仅是一小部分例子，如果你的系统采用了udev方式，那你应该可以看到更多的规则。如果你想修改设备的权限或者创建信的符号连接，那么你需要熟读这些规则，特别是要仔细注意你修改的那些与之相关的设备。\n修改你的udev配置 在修改udev配置之前，我们一定要仔细，通常的考虑是：你最好不要修改系统预置的那些规则，特别不要指定影响非常广泛的配置，比如上面例子中的第一行。不正确的配置可能会导致严重的系统问题或者系统根本就无法这个正确的访问设备。\n而我们正确的做法应该是在/etc/udev/rules.d/下创建一个新的规则文件。确定你给出的文件的后缀是rules文件名给出的数字序列应该比标准配置文件高。比如，你可以创建一个名为99-my-udev.rules的规则文件。在你的规则文件中，你可以指定任何你想修改的配置，比如，假设你 修改修改floppy设备的所在组，还准备创建一个新的符号连接/dev/floppy，那你可以这么写：\nKERNEL==”fd[0-9]*“, GROUP=“users“, SYMLINK+=“floppy“ 有些发行版本，比如Fedora，采用了外部脚本来修改某些特定设备的属组，组关系和权限。因此上面的改动可能并不见得生效。如果你遇到了这个问题，你就需要跟踪和修改这个脚本来达到你的目的。或者你可以修改PROGRAM或RUN键的值来做到这点。\n某些规则的修改可能需要更深的挖掘。比如，你可能想在一个设备上使用sysfs信息来唯一标识一个设备。这些信息最好通过udevinfo命令来获取。\n$ udevinfo –a –p $(udevinfo –q path –n /dev/hda) 上面的命令两次使用udevinfo：一次是返回sysfs设备路径(他通常和我们看到的Linux设备文件名所在路径－－/dev/hda－－不同)；第 二次才是查询这个设备路径，结果将是非常常的syfs信息汇总。你可以找到最够的信息来唯一标志你的设备，你可以采用适当的替换udev配置文件中的 SYSFS选项。下面的结果就是上面的命令输出\n[root@localhost rules.d]# udevinfo -a -p $(udevinfo -q path -n /dev/hda1) Udevinfo starts with the device specified by the devpath and then walks up the chain of parent devices. It prints for every device found,all possible attributes in the udev rules key format. A rule to match, can be composed by the attributes of the device and the attributes from one single parent device. looking at device '/block/hda/hda1': KERNEL==\"hda1\" SUBSYSTEM==\"block\" DRIVER==\"\" ATTR{stat}==\" 1133 2268 2 4\" ATTR{size}==\"208782\" ATTR{start}==\"63\" ATTR{dev}==\"3:1\" looking at parent device '/block/hda': KERNELS==\"hda\" SUBSYSTEMS==\"block\" DRIVERS==\"\" ATTRS{stat}==\"28905 18814 1234781 302540 34087 133247 849708 981336 0 218340 1283968\" ATTRS{size}==\"117210240\" ATTRS{removable}==\"0\" ATTRS{range}==\"64\" ATTRS{dev}==\"3:0\" looking at parent device '/devices/pci0000:00/0000:00:1f.1/ide0/0.0': KERNELS==\"0.0\" SUBSYSTEMS==\"ide\" DRIVERS==\"ide-disk\" ATTRS{modalias}==\"ide:m-disk\" ATTRS{drivename}==\"hda\" ATTRS{media}==\"disk\" looking at parent device '/devices/pci0000:00/0000:00:1f.1/ide0': KERNELS==\"ide0\" SUBSYSTEMS==\"\" DRIVERS==\"\" looking at parent device '/devices/pci0000:00/0000:00:1f.1': KERNELS==\"0000:00:1f.1\" SUBSYSTEMS==\"pci\" DRIVERS==\"PIIX_IDE\" ATTRS{broken_parity_status}==\"0\" ATTRS{enable}==\"1\" ATTRS{modalias}==\"pci:v00008086d000024CAsv0000144Dsd0000C009bc01sc01i8a\" ATTRS{local_cpus}==\"1\" ATTRS{irq}==\"11\" ATTRS{class}==\"0x01018a\" ATTRS{subsystem_device}==\"0xc009\" ATTRS{subsystem_vendor}==\"0x144d\" ATTRS{device}==\"0x24ca\" ATTRS{vendor}==\"0x8086\" looking at parent device '/devices/pci0000:00': KERNELS==\"pci0000:00\" SUBSYSTEMS==\"\" DRIVERS==\"\" 举一个例子：假设你想修改USB扫描仪的配置。通过一系列的尝试，你已经为这个扫描仪标识了Linux设备文件(每次打开扫描仪时，名字都会变)。你可以使 用上面的命令替换这个正确的Linux设备文件名，然后定位输出的采用SYSFS{idVendor}行和SYSFS{idProduct}行。最后你可 以使用这些信息来为这个扫描仪创建新的选项。\nSYSFS{idVendor}==\"0686\", SYSFS{idProduct}==\"400e\", SYMLINK+=\"scanner\", MODE=\"0664\", group=\"scanner\" 上面的例子表示将扫描仪的组设置为scanner，访问权限设置为0664,同时创建一个/dev/scanner的符号连接。\nMounting usb automatically \u0026 having usb’s label as mountpoint Note for Ubuntu Server 11.10: This script fails on Ubuntu Server 11.10 due to the obsolete vol_id command. vol_id has been superseded by blkid. To fix the script, replace “vol_id” by “blkid -o udev” in the udev-auto-mount.sh script.\nI’ve been banging my head around this for a while now, and I think I’ve found a working solution. This is developed and tested on a Debian-based system, so it should work on Ubuntu. I’ll point out the assumptions it makes so it can be adapted to other systems as well.\n It will automatically mount USB drives on plugin, and shouldn’t take much to adapt for Firewire. It uses UDEV, so no monkeying with HAL/DeviceKit/GNOME-Anything. It automagically creates a /media/LABEL directory to mount the device to. However, it may interfere with other automounters; I can’t test for that. I expect that, with Gnome-VFS active, both may try to do the mount … if Gnome-VFS fails the mount, it might not configure a desktop icon. Unmounting from Gnome should be possible, but might require gksudo or similar.  I have not tested this on system boot, but the only reason I can see that it might not work is if it tries to mount the USB drive before the system is ready for mounts. If that’s the case, you’ll probably need one additional tweak to the mount script. (I’m checking with ServerFault to see if there’s any advice, but not much interest in it over there.)\nOn to it, then.\nUDEV references  Writing udev Rules (the reference for udev rules) man udev (see your system for the latest version) man udevadm (udev admin tool; again see your system for latest) Backup to USB drive on mount (completely different problem, but helpful for understanding the solution)  Background (UDEV? Whuzzat?) UDEV is the kernel’s hotplug system. It’s what automagically configures the proper devices and device symlinks (eg /dev/disk/by-label/), both at boot time and for devices added while the system is running.\nD-Bus and HAL are used for sending hardware events to listeners like Desktop Environments. So when you log into GNOME and insert a CD or plug in a USB drive, that event follows this chain:\nkernel - udev - dbus - hal - gnome-vfs/nautilus (mount) And presto, your drive gets mounted. But in a headless system, we don’t want to have to log in to get the benefits of automounting.\nUdev Rules Since UDEV lets us write rules and run programs on device insertion, this is an ideal choice. We’re going to take advantage of Debian/Ubuntu’s existing rules, let them setup the /dev/disk/by-label/ symlink for us, and add another rule that will mount the device for us.\nUDEV’s rules are kept in /etc/udev/rules.d (and /lib/udev/rules.d on Karmic), and are processed in numerical order. Any file not starting with a number gets processed after the numbered files. On my system, HAL rules are in a file called 90-hal.rules, so I put my rules in 89-local.rules so they get processed before they get to HAL. Primarily, you need to make sure these rules happen after the 60-persistent-storage.rules. local.rules may be good enough.\nPut this in your new rules file:\n# /etc/udev/rules.d/local.rules # /etc/udev/rules.d/89-local.rules # ADD rule: if we have a valid ID_FS_LABEL_ENC, and it's USB, mkdir and mount ENV{ID_FS_LABEL_ENC}==\"?*\", ACTION==\"add\", SUBSYSTEMS==\"usb\", \\ RUN+=\"/usr/local/sbin/udev-automounter.sh %k\"  Make sure there’s no spaces after the \\, just a newline (\\n). Change SUBSYSTEMS==\"usb\" to SUBSYSTEMS==\"usb|ieee1394\" for Firewire support. If you want the device to always be owned by a particular user, add an OWNER=\"username\" clause. If you just need the files owned by a particular user, tweak the mount script instead.  Reading the Rule\nThis adds a program to run to the device’s list of programs to run. It identifies USB partition devices by , then passes this information to a script that performs the mount. Specifically, this rule is matching:\n  ENV{ID_FS_LABEL_ENC}==\"?\\*\" – an environment variable set by an earlier system rule. Doesn’t exist for non-filesystems, so that’s why we check for it. We actually want to use ID_FS_LABEL for the mount point, but I haven’t convinced UDEV to escape it for me, so we’ll let the mount script handle that.\nThis and other environment variables are obtained by udev using the vol_id command (deprecated). It’s a handy tool to see nice quick details on a partition:\n$ sudo vol_id /dev/sdc1 ID_FS_TYPE=ext2 ID_FS_UUID=a40d282a-4a24-4593-a0ab-6f2600f920dd ID_FS_LABEL=Travel Dawgs ID_FS_LABEL_ENC=Travel\\x20Dawgs ID_FS_LABEL_SAFE=Travel_Dawgs   ACTION==\"add\" – only match add events…\n  SUBSYSTEMS==\"usb\" – only match devices that are on the USB bus. We use SUBSYSTEMS here because this matches against our device’s parents; the device we’re interested in will actually be SUBSYSTEM==“scsi”. Matching against a parent USB device avoids adding our program to the internal drives.\n  RUN+=\"...\" – not a match, but an action: add this program to the list of programs to run. In the program’s arguments, %k gets expanded to the device name (eg sdc1, not /dev/sdc1) and $env{FOO} gets the contents of environment variable FOO.\n  Testing the Rule\nThe first reference link (above) is an excellent UDEV tutorial, but it’s slightly out of date. The programs it runs for testing your rules (udevtest in particular) have been replaced by the catch-all udevadm utility.\nAfter you’ve added the rule, plug in your device. Give it a few seconds, then check to see what device it’s been assigned to with:\n$ ls -l /dev/disk/by-label/* lrwxrwxrwx 1 root root 10 2009-10-25 07:27 label_Foo - ../../sda1 lrwxrwxrwx 1 root root 10 2009-10-25 07:27 label_Bar - ../../sdb1 lrwxrwxrwx 1 root root 10 2009-10-25 07:27 label_Baz - ../../sdc1 If your removeable drive contains label_Baz, it’s on device sdc1. Run this and look at the output towards the end:\n$ sudo udevadm test /sys/block/sdc/sdc1 parse_file: reading (...) (many lines about files it reads) import_uevent_var: import into environment: (...) (many lines about env variables) (...) (many lines tracing rule matches \u0026 programs run) update_link: found 1 devices with name 'disk/by-label/LABEL_BAZ' update_link: found '/block/sdc/sdc1' for 'disk/by-label/LABEL_BAZ' update_link: compare (our own) priority of '/block/sdc/sdc1' 0 = 0 update_link: 'disk/by-label/LABEL_BAZ' with target 'sdc1' has the highest priority 0, create it udevtest: run: '/usr/local/sbin/udev-automounter.sh sdc1 LABEL_BAZ' udevtest: run: 'socket:/org/freedesktop/hal/udev_event' udevtest: run: 'socket:@/org/kernel/udev/monitor' Look for the script name from our RUN+= rule in the last few lines (3rd from the bottom in this example). You can see the arguments that would be used for this device. You can run that command now to check that the arguments are sound; if it works on your commandline, it should work automatically when a device is inserted.\nYou can also monitor UDEV events in realtime: run sudo udevadm monitor (see man udevadm for details on the switches). Then just plug in a new device and watch events scroll by. (Probably overkill unless you’re into really low-level details…)\nReloading the Rules\nOnce you’ve verified the rule is getting read properly, you need to tell UDEV to reload its rules so the new one takes effect. Use any of these methods (if the first doesn’t work, the second should… but try the first first):\n run sudo udevadm control --reload-rules run sudo /etc/init.d/udev reload reboot  Script! Actually, 2 Scripts… Here’s the first script. Since the program we run needs to complete quickly, this just spins the second script off in the background. Put this in /usr/local/sbin/udev-automounter.sh:\n#!/bin/sh # # USAGE: usb-automounter.sh DEVICE # DEVICE is the actual device node at /dev/DEVICE /usr/local/sbin/udev-auto-mount.sh ${1} \u0026 Here’s the second script. This does a bit more input checking. Put this in /usr/local/sbin/udev-auto-mount.sh. You may want to tweak the mount options below. This script now handles finding the partition LABEL on its own; UDEV only sends the DEVICE name.\nIf there’s a problem mounting drives at boot-time, you can put a nice long sleep 60 in this script, to give the system time to come all the way up before the script attempts to mount the drive.\nI’ve given a suggestion in the comments for how to check (run ps to see if a webserver is running), but you’ll want to tweak that for your system. I think most any network servers you might be using would suffice for this purpose – nfsd, smbd, apache, etc. The risk, of course, is that the mount script will fail if the service isn’t running, so maybe testing a particular file’s existence would be a better solution.\n#!/bin/sh # # USAGE: udev-auto-mount.sh DEVICE # DEVICE is the actual device node at /dev/DEVICE # # This script takes a device name, looks up the partition label and # type, creates /media/LABEL and mounts the partition. Mount options # are hard-coded below. DEVICE=$1 # check input if [ -z \"$DEVICE\" ]; then exit 1 fi # test that this device isn't already mounted device_is_mounted=`grep ${DEVICE} /etc/mtab` if [ -n \"$device_is_mounted\" ]; then echo \"error: seems /dev/${DEVICE} is already mounted\" exit 1 fi # If there's a problem at boot-time, this is where we'd put # some test to check that we're booting, and then run # sleep 60 # so the system is ready for the mount below. # # An example to experiment with: # Assume the system is \"booted enough\" if the HTTPD server is running. # If it isn't, sleep for half a minute before checking again. # # The risk: if the server fails for some reason, this mount script # will just keep waiting for it to show up. A better solution would # be to check for some file that exists after the boot process is complete. # # HTTPD_UP=`ps -ax | grep httpd | grep -v grep` # while [ -z \"$HTTPD_UP\" ]; do # sleep 30 # HTTPD_UP=`ps -ax | grep httpd | grep -v grep` # done # pull in useful variables from vol_id, quote everything Just In Case eval `/sbin/vol_id /dev/${DEVICE} | sed 's/^/export /; s/=/=\"/; s/$/\"/'` if [ -z \"$ID_FS_LABEL\" ] || [ -z \"$ID_FS_TYPE\" ]; then echo \"error: ID_FS_LABEL is empty! did vol_id break? tried /dev/${DEVICE}\" exit 1 fi # test mountpoint - it shouldn't exist if [ ! -e \"/media/${ID_FS_LABEL}\" ]; then # make the mountpoint mkdir \"/media/${ID_FS_LABEL}\" # mount the device # # If expecting thumbdrives, you probably want # mount -t auto -o sync,noatime [...] # # If drive is VFAT/NFTS, this mounts the filesystem such that all files # are owned by a std user instead of by root. Change to your user's UID # (listed in /etc/passwd). You may also want \"gid=1000\" and/or \"umask=022\", eg: # mount -t auto -o uid=1000,gid=1000 [...] # # case \"$ID_FS_TYPE\" in vfat) mount -t vfat -o sync,noatime,uid=1000 /dev/${DEVICE} \"/media/${ID_FS_LABEL}\" ;; # I like the locale setting for ntfs ntfs) mount -t auto -o sync,noatime,uid=1000,locale=en_US.UTF-8 /dev/${DEVICE} \"/media/${ID_FS_LABEL}\" ;; # ext2/3/4 don't like uid option ext*) mount -t auto -o sync,noatime /dev/${DEVICE} \"/media/${ID_FS_LABEL}\" ;; esac # all done here, return successful exit 0 fi exit 1 Super Bonus Cleanup Script! One more script. All this does is unmount the device and remove the mountpoint directories. It assumes it has privs to do this, so you’ll need to run it with sudo. This script now takes the full mountpoint on the commandline, eg:\n$ /usr/local/sbin/udev-unmounter.sh \"/media/My Random Disk\" Put this in /usr/local/sbin/udev-unmounter.sh:\n#!/bin/sh # # USAGE: udev-unmounter.sh MOUNTPT # MOUNTPT is a mountpoint we want to unmount and delete. MOUNTPT=\"$1\" if [ -z \"$MOUNTPT\" ]; then exit 1 fi # test mountpoint - it should exist if [ -e \"${MOUNTPT}\" ]; then # very naive; just run and pray umount -l \"${MOUNTPT}\" \u0026\u0026 rmdir \"${MOUNTPT}\" \u0026\u0026 exit 0 echo \"error: ${MOUNTPT} failed to unmount.\" exit 1 fi echo \"error: ${MOUNTPT} does not exist\" exit 1 GPG 前两篇文章，我介绍了RSA算法。\n今天，就接着来看，现实中怎么使用这个算法，对信息加密和解密。这要用到GnuPG软件（简称GPG），它是目前最流行、最好用的加密工具之一。\n什么是GPG 要了解什么是GPG，就要先了解PGP。\n1991年，程序员Phil Zimmermann为了避开政府监视，开发了加密软件PGP。这个软件非常好用，迅速流传开来，成了许多程序员的必备工具。但是，它是商业软件，不能自由使用。所以，自由软件基金会决定，开发一个PGP的替代品，取名为GnuPG。这就是GPG的由来。\nGnuPG 是完整实现了 RFC4880 （即PGP） 所定义的 OpenPGP 标准的自由软件。\nGnuPG 可以加密和签名你的数据和通讯信息，包含一个通用的密钥管理系统以及用于各种公钥目录的访问模块。\nGnuPG 是一个易于与其它程序整合的命令行工具，拥有很多前端程序和函数库。\nGnuPG 还支持 S/MIME 和 Secure Shell (ssh)。\nGPG有许多用途，本文主要介绍文件加密。至于邮件的加密，不同的邮件客户端有不同的设置，请参考Ubuntu网站的介绍。\n本文的使用环境为Linux命令行。如果掌握了命令行，Windows 或 Mac OS 客户端，就非常容易掌握。GPG并不难学，学会了它，从此就能轻松传递加密信息。建议读者一步步跟着教程做，对每条命令都自行测试。\n安装 GPG有两种安装方式。可以下载源码，自己编译安装。\n$ ./configure $ make $ make install 也可以安装编译好的二进制包。\n$ sudo apt-get install gnupg 安装完成后，键入下面的命令：\n$ gpg --help 如果屏幕显示GPG的帮助，就表示安装成功。\n配置 目录位置 GnuPG 用环境变量 $GNUPGHOME 定位配置文件的位置，默认情况下此变量并未被设置，会直接使用 $HOME，所以默认的配置目录是 ~/.gnupg。\n要改变默认位置，执行 $ gpg --homedir path/to/file 或在 startup files 中设置 GNUPGHOME。\n配置文件 默认的配置文件是 ~/.gnupg/gpg.conf 和 ~/.gnupg/dirmngr.conf.\ngnupg 目录的默认 权限 是 700，其中文件的权限是 600. 仅目录的所有者有权读写，访问这些文件。这是基于安全考虑，请不要变更。如果不使用这样的安全权限设置，会收到不安全文件的警告。\n在文件中附加需要的文件：/usr/share/gnupg 包含基本架构文件. gpg，第一次运行时，如果配置文件不存在，会自动复制文件到 ~/.gnupg。\n新用户的默认选项 要给新建用户设定一些默认选项，把配置文件放到 /etc/skel/.gnupg/。系统创建新用户时，就会把文件复制到 GnuPG 目录。还有一个 addgnupghome 命令可以为已有用户创建新 GnuPG 主目录：\n# addgnupghome user1 user2 此命令会将对检查 /home/user1/.gnupg 和 /home/user2/.gnupg，如果用户的 GnuPG 主目录不存在，就会从 skeleton 目录复制文件过去。\n生成密钥 安装成功后，使用 --full-generate-key 参数生成自己的密钥。\n$ gpg --full-generate-key 或用 gpg --gen-key 快速生成。以下使用 gpg2 --full-generate-key 演示。\n回车以后，会跳出一大段文字：\ngpg (GnuPG) 2.2.19; Copyright (C) 2019 Free Software Foundation, Inc. This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Please select what kind of key you want: (1) RSA and RSA (default) (2) DSA and Elgamal (3) DSA (sign only) (4) RSA (sign only) (14) Existing key from card Your selection? 第一段是版权声明，然后让用户自己选择加密算法。默认选择第一个选项，表示加密和签名都使用RSA算法。\n然后，系统就会问你密钥的长度。\nRSA keys may be between 1024 and 4096 bits long. What keysize do you want? (3072) 密钥越长越安全。\n接着，设定密钥的有效期。\nPlease specify how long the key should be valid. 0 = key does not expire  = key expires in n days w = key expires in n weeks m = key expires in n months y = key expires in n years Key is valid for? (0) 如果密钥只是个人使用，并且你很确定可以有效保管私钥，建议选择第一个选项，即永不过期。回答完上面三个问题以后，系统让你确认。\nIs this correct? (y/N) 输入y，系统就要求你提供个人信息。\nGnuPG needs to construct a user ID to identify your key. Real name: Email address Comment: “真实姓名\"填入你姓名的英文写法，“电子邮件地址\"填入你的邮件地址，“注释\"这一栏可以空着。\n然后，你的\"用户ID\"生成了。\nYou selected this USER-ID: \"Vane Hsiung \" 系统会让你最后确认一次。\nChange (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? 输入O表示\"确定”。\n接着，系统会要求你做一些随机的举动，以生成一个随机数。同时系统会让你设定一个私钥的密码。这是为了防止误操作，或者系统被侵入时有人擅自动用私钥。\nWe need to generate a lot of random bytes. It is a good idea to performsome other action (type on the keyboard, move the mouse, utilize thedisks) during the prime generation; this gives the random numbergenerator a better chance to gain enough entropy. 然后，系统就开始生成密钥了，\n几分钟以后，系统提示密钥已经生成了。\ngpg: key B893B73ABC92D2CA marked as ultimately trusted gpg: revocation certificate stored as ''public and secret key created and signed. 请注意上面的字符串\"B893B73ABC92D2CA”，这是\"用户ID\"的Hash字符串，可以用来替代\"用户ID”。\n这时，最好再生成一张\"撤销证书”，以备以后密钥作废时，可以请求外部的公钥服务器撤销你的公钥。\n$ gpg --gen-revoke [用户ID] 上面的\"用户ID\"部分，可以填入你的邮件地址或者Hash字符串（以下同）。\n密钥管理 列出密钥\nlist-keys参数列出系统中已有的密钥．\n$ gpg --list-keys 显示结果如下：\ngpg: checking the trustdb gpg: marginals needed: 3 completes needed: 1 trust model: pgp gpg: depth: 0 valid: 1 signed: 0 trust: 0-, 0q, 0n, 0m, 0f, 1u /home/vane/.gnupg/pubring.kbx ----------------------------- pub rsa3072 2021-10-17 [SC] BC158F7500033355B5324CF14C701F8BF2E03463 uid [ultimate] Vane Hsiung  sub rsa3072 2021-10-17 [E] 第一行显示公钥文件名（pubring.gpg），第二行显示公钥特征（4096位，Hash字符串和生成时间），第三行显示\"用户ID\"，第四行显示私钥特征。\n如果你要从密钥列表中删除某个密钥，可以使用如下参数。\n$ gpg --delete-secret-keys [用户ID] $ gpg --delete-key [用户ID] 输出密钥\n公钥文件（.gnupg/pubring.gpg）以二进制形式储存，armor参数可以将其转换为ASCII码显示。\n$ gpg --armor --output public-key.txt --export [用户ID] “用户ID\"指定哪个用户的公钥，output参数指定输出文件名（public-key.txt）。\n类似地，export-secret-keys参数可以转换私钥。\n$ gpg --armor --output private-key.txt --export-secret-keys 上传公钥\n公钥服务器是网络上专门储存用户公钥的服务器。send-keys参数可以将公钥上传到服务器。\n$ gpg --send-keys [用户ID] --keyserver hkp://subkeys.pgp.net 使用上面的命令，你的公钥就被传到了服务器subkeys.pgp.net，然后通过交换机制，所有的公钥服务器最终都会包含你的公钥。\n由于公钥服务器没有检查机制，任何人都可以用你的名义上传公钥，所以没有办法保证服务器上的公钥的可靠性。通常，你可以在网站上公布一个公钥指纹，让其他人核对下载到的公钥是否为真。fingerprint参数生成公钥指纹。\n$ gpg --fingerprint [用户ID] 输入密钥\n除了生成自己的密钥，还需要将他人的公钥或者你的其他密钥输入系统。这时可以使用import参数。\n$ gpg --import [密钥文件] 为了获得他人的公钥，可以让对方直接发给你，或者到公钥服务器上寻找。\n$ gpg --keyserver hkp://subkeys.pgp.net --search-keys [用户ID] 正如前面提到的，我们无法保证服务器上的公钥是否可靠，下载后还需要用其他机制验证．\n加密和解密 加密\n假定有一个文本文件demo.txt，怎样对它加密呢？\nencrypt参数用于加密。\n$ gpg --recipient [用户ID] --output demo.en.txt --encrypt demo.txt recipient参数指定接收者的公钥，output参数指定加密后的文件名，encrypt参数指定源文件。运行上面的命令后，demo.en.txt就是已加密的文件，可以把它发给对方。\n解密\n对方收到加密文件以后，就用自己的私钥解密。\n$ gpg --output demo.de.txt --decrypt demo.en.txt output 指定解密后生成的文件，decrypt参数指定需要解密的文件。运行上面的命令，demo.de.txt就是解密后的文件。\nGPG允许省略decrypt参数。\n$ gpg demo.en.txt 签名 对文件签名\n有时，我们不需要加密文件，只需要对文件签名，表示这个文件确实是我本人发出的。sign参数用来签名。\n$ gpg --sign demo.txt 运行上面的命令后，当前目录下生成demo.txt.gpg文件，这就是签名后的文件。这个文件默认采用二进制储存，如果想生成ASCII码的签名文件，可以使用clearsign参数。\n$ gpg --clearsign demo.txt 运行上面的命令后 ，当前目录下生成demo.txt.asc文件，后缀名asc表示该文件是ASCII码形式的。\n如果想生成单独的签名文件，与文件内容分开存放，可以使用detach-sign参数。　$ gpg --detach-sign demo.txt 运行上面的命令后，当前目录下生成一个单独的签名文件demo.txt.sig。该文件是二进制形式的，如果想采用ASCII码形式，要加上armor参数。　$ gpg --armor --detach-sign demo.txt 签名+加密\n上一节的参数，都是只签名不加密。如果想同时签名和加密，可以使用下面的命令。\n$ gpg --local-user [发信者ID] --recipient [接收者ID] --armor --sign --encrypt demo.txt local-user参数指定用发信者的私钥签名，recipient参数指定用接收者的公钥加密，armor参数表示采用ASCII码形式显示，sign参数表示需要签名，encrypt参数表示指定源文件。\n验证签名\n我们收到别人签名后的文件，需要用对方的公钥验证签名是否为真。verify参数用来验证。\n$ gpg --verify demo.txt.asc demo.txt 举例来说，openvpn网站就提供每一个下载包的gpg签名文件。你可以根据它的说明，验证这些下载包是否为真。\nLinux Kernel 来自 Wikipedia:\n 内核是计算机操作系统的核心组件，对系统有完全的控制。开机时最先启动，然后负责后续的启动工作。它负责处理其它软件的请求，将这些请求转化为中央处理器的数据处理请求。内核还负责管理内存，管理系统和其它打印机、扬声器等外围设备的通讯，是操作系统最基础的部分。\n 内核包安装在/boot/下的文件系统上。为了能够引导到内核，必须适当配置启动加载器。\nKernel module 内核模块是可以按需加载或卸载的内核代码，可以不重启系统就扩充内核的功能。\n要创建内核模块，请阅读此指南。模块可以设置成内置或者动态加载，要编译成可动态加载，需要在内核配置时将模块配置为 M (模块)。\n获取信息 模块保存在 /lib/modules/kernel_release (使用 uname -r 命令显示当前内核版本)。\n注意： 模块名通常使用 (_) 或 - 连接，但是这些符号在 modprobe 命令和 /etc/modprobe.d/ 配置文件中都是可以相互替换的。\n显示当前装入的内核模块：\n$ lsmod 在上面的输出中：\n Module 显示每个模块的名称 Size 显示每个模块的大小（并不是它们占的内存大小） Used by 显示每个模块被使用的次数和使用它们的模块  显然，这里有很多模块。加载的模块数量取决于你的系统和版本以及正在运行的内容。我们可以这样计数：\n$ lsmod | wc -l 67 modules.builtin 文件中列出了所有构建在内核中的模块\n$ more /lib/modules/$(uname -r)/modules.builtin | head -10 kernel/arch/x86/crypto/crc32c-intel.ko kernel/arch/x86/events/intel/intel-uncore.ko kernel/arch/x86/platform/intel/iosf_mbi.ko kernel/mm/zpool.ko kernel/mm/zbud.ko kernel/mm/zsmalloc.ko kernel/fs/binfmt_script.ko kernel/fs/mbcache.ko kernel/fs/configfs/configfs.ko kernel/fs/crypto/fscrypto.ko 显示模块信息：\n$ modinfo module_name 显示所有模块的配置信息：\n$ modprobe -c | less 显示某个模块的配置信息：\n$ modprobe -c | grep module_name 显示一个装入模块使用的选项：\n$ systool -v -m module_name 显示模块的依赖关系：\n$ modprobe --show-depends module_name 使用systemd自动加载模块 目前，所有必要模块的加载均由 udev 自动完成。所以，如果不需要使用任何额外的模块，就没有必要在任何配置文件中添加启动时加载的模块。但是，有些情况下可能需要在系统启动时加载某个额外的模块，或者将某个模块列入黑名单以便使系统正常运行。\n内核模块可以在/etc/modules-load.d/ 下的文件中明确列出，以便systemd在引导过程中加载它们。 每个配置文件都以 /etc/modules-load.d/.conf的样式命名。 配置文件仅包含要加载的内核模块名称列表，以换行符分隔。 空行和第一个非空白字符为#或;的行被忽略。\n$ cat /etc/modules-load.d/virtio-net.conf # Load virtio_net.ko at boot virtio_net 另见modules-load.d(5)。\n手动加载卸载 控制内核模块载入/移除的命令是kmod 软件包提供的, 要手动装入模块的话，执行:\n# modprobe module_name 按文件名加载模块:\n# insmod filename [args] 注意： 如果升级了内核但是没有重启，路径 /usr/lib/modules/$(uname -r)/ 已经不存在。modprobe 会返回错误 1，没有额外的错误信息。如果出现 modprobe 加载失败，请检查模块路径以确认是否是这个问题导致。\n如果要移除一个模块：\n# modprobe -r module_name 或者:\n# rmmod module_name 配置模块参数 手动加载时设置 传递参数的基本方式是使用 modprobe 选项，格式是 key=value：\n# modprobe module_name parameter_name=parameter_value 使用 /etc/modprobe.d/中的文件 要通过配置文件传递参数，在 /etc/modprobe.d/ 中放入任意名称 .conf 文件，加入:\n$ sudo gedit /etc/modprobe.d/myfilename.conf options modname parametername=parametercontents 例如\n$ sudo gedit /etc/modprobe.d/thinkfan.conf # On thinkpads, this lets the thinkfan daemon control fan speed options thinkpad_acpi fan_control=1 注意： 如果要在启动时就修改内核参数(从 init ramdisk 开始)，需要将相应的.conf-文件加入 mkinitcpio.conf 的 FILES 参数中。\n使用内核命令行 如果模块直接编译进内核，也可以通过启动管理器(GRUB, LILO 或 Syslinux)的内核行加入参数：\nmodname.parametername=parametercontents 例如:\nthinkpad_acpi.fan_control=1 别名 $ cat /etc/modprobe.d/myalias.conf # Lets you use 'mymod' in MODULES, instead of 'really_long_module_name' alias mymod really_long_module_name 有些模块具有别名，以方便其它程序自动装入模块。禁用这些别名可以阻止自动装入，但是仍然可以手动装入。\n$ cat /etc/modprobe.d/modprobe.conf # Prevent autoload of bluetooth alias net-pf-31 off # Prevent autoload of ipv6 alias net-pf-10 off 黑名单 禁用内核模块 对内核模块来说，黑名单是指禁止某个模块装入的机制。当对应的硬件不存在或者装入某个模块会导致问题时很有用。\n有些模块作为 initramfs 的一部分装入。\nmkinitcpio -M 会显示所有自动检测到到模块：要阻止 initramfs 装入某些模块，可以在 /etc/modprobe.d中将它们加入黑名单。并应在映像生成过程中通过modconf挂钩将其添加。\n运行 mkinitcpio -v 会显示各种钩子(例如 filesystem 钩子, SCSI 钩子等)装入的模块。如果您的HOOKS 数组中没有 modconf 钩子（例如，和默认配置不同）则请将该”.conf\"文件添加到/etc/mkinitcpio.conf中的FILES数组中。一旦您将其列入黑名单，请重新生成 initramfs，然后重新启动。\n使用 /etc/modprobe.d/ 中的文件 在 /etc/modprobe.d/ 中创建 .conf 文件，使用 blacklist 关键字屏蔽不需要的模块，例如如果不想装入 pcspkr 模块：\n$ sudo gedit /etc/modprobe.d/nobeep.conf # Do not load the pcspkr module on boot blacklist pcspkr 注意： blacklist 命令将屏蔽一个模板，所以不会自动装入，但是如果其它非屏蔽模块需要这个模块，系统依然会装入它。\n要避免这个行为，可以让 modprobe 使用自定义的 install 命令，而不是像往常一样将模块插入内核，因此您可以通过以下方式强制模块始终无法加载：\n$ sudo gedit /etc/modprobe.d/blacklist.conf ... install MODULE /bin/true ... 这样就可以 “屏蔽” 模块及所有依赖它的模块。\n使用内核命令行 提示： 如果模块损坏导致无法引导系统，这将非常有用。\n您也可以从引导加载程序中将模块列入黑名单。\n如Kernel参数.中所述，只需将module_blacklist=modname1,modname2,modname3 添加到引导加载程序的内核行中即可。\n注意： 将多个模块列入黑名单时，请注意，它们之间仅用逗号分隔。 空格或其他内容可能会破坏语法。\nKernel parameters 一共有三种办法，可以给内核传递参数，用于控制其行为方式：\n 在编译内核时（这个最根本，会决定后面两种方法） 内核启动时(通常是在一个启动管理器里设置). 在运行时 (通过修改在 /proc 和 /sys中的文件).  本页面主要是讲第二种方法。\n配置 内核参数可以在启动时临时修改，也可以永久性写到启动管理器的配置文件中，永远起作用。\n下面示例把参数quiet 和 splash 加到启动管理器。\nsystemd-boot   当启动菜单出现时 按 e进入编辑界面:\ninitrd=\\initramfs-linux.img root=/dev/sda2 quiet splash   如果想永久加入参数，编辑 /boot/loader/entries/arch.conf (假设你已经设置好了 EFI system partition) 的options 行:\n  注意：\n 如果没有设置显示启动菜单, 你需要按住Space启动电脑来进入启动菜单 。 如果不能够从启动菜单上进行编辑，修改 /boot/loader/loader.conf 加入 editor 1 来开启编辑功能。  更多信息请参见 systemd-boot .\nGRUB   在菜单出现后按 e 然后将它们添加至 linux 行：\nlinux /boot/vmlinuz-linux root=UUID=978e3e81-8048-4ae1-8a06-aa727458e8ff ro quiet splash 按 b 以便用这些参数启动。\n  要使改变在重启后仍生效，您可以手动编辑 /boot/grub/grub.cfg 中的如上内容。对于初学者，建议编辑 /etc/default/grub 并将您的内核选项添加至 GRUB_CMDLINE_LINUX_DEFAULT 行：\nGRUB_CMDLINE_LINUX_DEFAULT=\"quiet splash\" 然后重新生成 grub.cfg 文件：\n# grub-mkconfig -o /boot/grub/grub.cfg   有关配置GRUB的更多信息，请参阅 GRUB 。\n发布时间表 内核发布时间表：有吗？ 短的回答是，每两到三个月就有一个新的内核版本发布。长的回答是，这不是一个硬性规定。\n这个意思是，你经常会看到每两到三个月就有一个新的内核版本发布。这是内核维护者团队的目标，但并没有规定新版本必须在前一个版本的 8 周后准时发布的期限。\n新的内核版本（通常）是由 Linus Torvalds 在它准备好的时候发布的。通常是每 2 到 3 个月发布一次。该版本被宣布为“稳定”，一般以 X.Y 的格式编号。\n但这并不是 X.Y 开发的结束。稳定版会有更多的小版本以进行错误的修复。这些小版本在稳定版的内核上又增加了一个点，就像是 X.Y.Z。\n虽然 X.Y（通常）是由 Linux 创造者 Linus Torvalds 发布的，但是维护稳定的 X.Y 内核、合并错误修复和发布 X.Y.Z 版本的责任是由另外的内核开发者负责的。\n一个内核版本支持多长时间？ 和发布一样，一个内核版本支持多长时间也没有固定的日期和时间表。\n一个普通的稳定内核版本通常会被支持两个半月到三个月，这取决于下一个稳定内核版本的发布时间。\n例如，稳定版内核 5.14 会在稳定版内核 5.15 发布后的几周内达到生命末期。结束支持是由该稳定内核版本的维护者在 Linux 内核邮件列表中宣布的。用户和贡献者会被要求切换到新发布的稳定版本。\n但这只适用于正常的稳定内核版本，还有 LTS（长期支持）内核版本，它们的支持期要比 3 个月长得多。\nLTS 内核：它支持多长时间？ LTS 内核也没有固定的发布时间表。通常，每年都有一个 LTS 内核版本，一般是当年的最后一个版本，它至少会被支持两年。但同样，这里也没有固定的规则。\nLTS 内核的维护者可以同意某个 LTS 内核的维护时间超过通常的两年。这个协议是根据必要性和参与的人员来达成的。\n这种情况经常发生在 Android 项目中。由于两年的时间不足以让制造商结束对他们的硬件和软件功能的支持，你经常会发现一些 LTS 内核会被支持六年之久。\n你可以 在 Linux 内核网站上 找到这个信息。\n你的发行版可能没有跟随通常的 Linux 内核版本 如果你检查你的 Linux 内核版本，你可能会发现 你的发行版使用了一个旧的内核。也有可能该发行版提供的内核已经在内核网站上被标记为到达了生命末期。\n不要惊慌。你的发行版会负责修补内核的错误和漏洞。除非你真的在使用一个不知名的 Linux 发行版，否则你可以相信你的发行版会保持它的安全和健全。\n如果你有足够的理由，比如为了支持更新的硬件，你可以自由地在你使用的任何发行版或 Ubuntu 中安装最新的 Linux 内核 。\n如果你想了解更多细节，我已经 在这里解释了为什么你的发行版使用过时的 Linux 内核。\n安装内核 dpkg\n从 kernel.ubuntu.com 网站手动下载可用的最新 Linux 内核：\n linux-image-X.Y.Z-generic-.deb linux-modules-X.Y.Z-generic-.deb  手动安装内核：\n$ sudo dpkg --install *.deb 重启系统，使用新内核：\n$ sudo reboot 检查是否如你所愿：\n$ uname -r apt-get\n不同于上一个方法，这种方法会从 Ubuntu 官方仓库下载、安装内核版本：\n运行：\n$ sudo apt-get upgrade linux-image-generic XanMod Kernel 最新内核集成的一些新特性的确是可以提升性能的。xanmod 内核的安装可以去它们的官方网站来查询，xanmod 内核的特性很多地方都有，官方也写的有很多，不过大多数还是以下几点：\n 改善了 CPU 调度能力 改善了 I/O 的调度能力 增加了一些和性能有关的第三方补丁 使用了最新的 GCC 进行编译 使用了最新的 MicroCode  安装的方式也比较简单，添加源并且更新安装就行了：\n$ echo 'deb http://deb.xanmod.org releases main' | sudo tee /etc/apt/sources.list.d/xanmod-kernel.list \u0026\u0026 wget -qO - https://dl.xanmod.org/gpg.key | sudo apt-key add - 然后安装，我个人安装的是最新的 5.8.1 的 edge：\n$ sudo apt update \u0026\u0026 sudo apt install linux-xanmod-edge 安装完毕后还可以安装最新的微码：\n$ sudo apt update \u0026\u0026 sudo apt install linux-xanmod 重启以应用\n$ sudo reboot Zen/Liquorix Kernel  一些内核黑客合作的结果，是适合日常使用的优秀内核 以吞吐量和功耗为代价来换取性能 相对 linux 内核加入了 Fsync 功能。Fsync 是维尔福公司发布的一个可以帮助提升大量多线程应用运行帧率的特殊内核补丁，这对改善游戏性能有很大帮助。在一些采用 .Net 的 wine 游戏中会有 明显的性能提升 如果你使用英伟达显卡，记得更换驱动为相应的 dkms 版本。一般来说较新的显卡安装 nvidia-dkms 即可。DKMS，即 Dynamic Kernel Module System。可以使内核变更（如升级）后自动编译模块，适配新内核。  Questions about: I’m not a kernel expert, but my understanding is that there are different ways for the kernel to prioritize tasks to be processed by the CPU. Priority on a server or workstation is different from a gaming PC. The Zen (and Liquorix) kernel alters the way this is done to optimise for gaming and multimedia. From what I can tell, the difference between the Zen and Liquorix kernels is the scheduler used, but are otherwise the same. There’s more info here.\nUbuntu Prerequisites:\n$ sudo add-apt-repository ppa:damentz/liquorix \u0026\u0026 sudo apt-get update The Liquorix kernel can be installed by way of meta-packages. This will guarantee that the latest kernel is installed on every upgrade.\n64-bit:\n$ sudo apt-get install linux-image-liquorix-amd64 linux-headers-liquorix-amd64 可选内核 切換内核 可以通过修改 /etc/default/grub 中的 GRUB_DEFAULT 值来改变默认启动项。\n查看 grub menu 目前的選項 ：\n$ grep -A100 submenu /boot/grub/grub.cfg |grep menuentry submenu 'Advanced options for Ubuntu' $menuentry_id_option 'gnulinux-advanced-4a67ec61-9cd5-4a26-b00f-9391a34c8a29' { menuentry 'Ubuntu, with Linux 4.4.0-1062-aws' --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option 'gnulinux-4.4.0-1062-aws-advanced-4a67ec61-9cd5-4a26-b00f-9391a34c8a29' { menuentry 'Ubuntu, with Linux 4.4.0-1062-aws (recovery mode)' --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option 'gnulinux-4.4.0-1062-aws-recovery-4a67ec61-9cd5-4a26-b00f-9391a34c8a29' { menuentry 'Ubuntu, with Linux 4.4.0-1061-aws' --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option 'gnulinux-4.4.0-1061-aws-advanced-4a67ec61-9cd5-4a26-b00f-9391a34c8a29' { menuentry 'Ubuntu, with Linux 4.4.0-1061-aws (recovery mode)' --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option 'gnulinux-4.4.0-1061-aws-recovery-4a67ec61-9cd5-4a26-b00f-9391a34c8a29' { 接下來修改 grub config 檔案：\n$ sudo nano /etc/default/grup 找到 GRUB_DEFAULT=0 ，將數字 0 改成想用來開機的 kernel，以這個例子來說：\n 0 = ‘Ubuntu, with Linux 4.4.0-1062-aws’ = ‘gnulinux-4.4.0-1062-aws-advanced-4a67ec61-9cd5-4a26-b00f-9391a34c8a29’ 1 = ‘Ubuntu, with Linux 4.4.0-1062-aws (recovery mode)’ = ‘gnulinux-4.4.0-1062-aws-recovery-4a67ec61-9cd5-4a26-b00f-9391a34c8a29’ 2 = ‘Ubuntu, with Linux 4.4.0-1061-aws’ = ‘gnulinux-4.4.0-1061-aws-advanced-4a67ec61-9cd5-4a26-b00f-9391a34c8a29’ 3 = ‘Ubuntu, with Linux 4.4.0-1061-aws (recovery mode)’ = ‘gnulinux-4.4.0-1061-aws-recovery-4a67ec61-9cd5-4a26-b00f-9391a34c8a29’  GRUB 启动项序号从 0 开始计数，0 代表第一个启动项，也是上述选项的默认值，1 表示第二个启动项，以此类推。主菜单和子菜单项之间用  隔开。\n下面的例子启动的是主菜单项 ‘Advanced options for Arch Linux’ 下子菜单的第三项：\n  使用数字编号：\nGRUB_DEFAULT=2 # or GRUB_DEFAULT=\"12\"   使用菜单标题：\nGRUB_DEFAULT=\"Advanced options for UbuntuUbuntu, with Linux 4.4.0-1061-aws\"   还可以这样：\nGRUB_DEFAULT=\"gnulinux-advanced-4a67ec61-9cd5-4a26-b00f-9391a34c8a29gnulinux-4.4.0-1061-aws-advanced-4a67ec61-9cd5-4a26-b00f-9391a34c8a29\"   更新 grup 設定：\n$ sudo update-grub $ sudo reboot   删除旧内核 随着时间的流逝，持续的内核更新会在系统中积聚大量的不再使用的内核，浪费你的磁盘空间。每个内核镜像和其相关联的模块/头文件会占用200-400MB的磁盘空间，因此由不再使用的内核而浪费的磁盘空间会快速地增加。\nGRUB管理器为每个旧内核都维护了一个GRUB入口，以备你想要使用它们。\n作为磁盘清理的一部分，如果你不再使用这些，你可以考虑清理掉这些镜像。\n在删除旧内核之前，记住最好留有2个最近的内核（最新的和上一个版本），以防主要的版本出错。\n在Ubuntu内核镜像包含了以下的包。\n linux-image-: 内核镜像 linux-image-extra-: 额外的内核模块 linux-headers-: 内核头文件  首先检查系统中安装的内核镜像。\n$ dpkg --list | grep linux-image $ dpkg --list | grep linux-headers 在列出的内核镜像中，你可以移除一个特定的版本。\n$ sudo apt-get purge linux-image-3.19.0-15 $ sudo apt-get purge linux-headers-3.19.0-15 上面的命令会删除内核镜像和它相关联的内核模块和头文件。\n注意如果你还没有升级内核那么删除旧内核会自动触发安装新内核。这样在删除旧内核之后，GRUB配置会自动升级来移除GRUB菜单中相关GRUB入口。\n如果你有很多没用的内核，你可以用shell表达式来一次性地删除多个内核。注意这个括号表达式只在bash或者兼容的shell中才有效。\n$ sudo apt-get purge linux-image-3.19.0-{18,20,21,25} $ sudo apt-get purge linux-headers-3.19.0-{18,20,21,25} 上面的命令会删除4个内核镜像：3.19.0-18、3.19.0-20、3.19.0-21 和 3.19.0-25。\n如果GRUB配置由于任何原因在删除旧内核后没有正确升级，你可以尝试手动用update-grub2命令来更新配置。\n$ sudo update-grub2 现在就重启来验证GRUB菜单是否已经正确清理了。\n编写第一个内核模块 容器 Namespace 概念 **namespace 是 Linux 内核用来隔离内核资源的方式。**通过 namespace 可以让一些进程只能看到与自己相关的一部分资源，而另外一些进程也只能看到与它们自己相关的资源，这两拨进程根本就感觉不到对方的存在。具体的实现方式是把一个或多个进程的相关资源指定在同一个 namespace 中。\nLinux namespaces 是对全局系统资源的一种封装隔离，使得处于不同 namespace 的进程拥有独立的全局系统资源，改变一个 namespace 中的系统资源只会影响当前 namespace 里的进程，对其他 namespace 中的进程没有影响。\n用途 实际上，Linux 内核实现 namespace 的一个主要目的就是实现轻量级虚拟化(容器)服务。在同一个 namespace 下的进程可以感知彼此的变化，而对外界的进程一无所知。这样就可以让容器中的进程产生错觉，认为自己置身于一个独立的系统中，从而达到隔离的目的。也就是说 linux 内核提供的 namespace 技术为 docker 等容器技术的出现和发展提供了基础条件。\n我们可以从 docker 实现者的角度考虑该如何实现一个资源隔离的容器。比如是不是可以通过 chroot 命令切换根目录的挂载点，从而隔离文件系统。为了在分布式的环境下进行通信和定位，容器必须要有独立的 IP、端口和路由等，这就需要对网络进行隔离。同时容器还需要一个独立的主机名以便在网络中标识自己。接下来还需要进程间的通信、用户权限等的隔离。最后，运行在容器中的应用需要有进程号(PID)，自然也需要与宿主机中的 PID 进行隔离。也就是说这六种隔离能力是实现一个容器的基础，让我们看看 linux 内核的 namespace 特性为我们提供了什么样的隔离能力：\n上表中的前六种 namespace 正是实现容器必须的隔离技术，至于新近提供的 Cgroup namespace 目前还没有被 docker 采用。相信在不久的将来各种容器也会添加对 Cgroup namespace 的支持。\n发展历史 Linux 在很早的版本中就实现了部分的 namespace，比如内核 2.4 就实现了 mount namespace。大多数的 namespace 支持是在内核 2.6 中完成的，比如 IPC、Network、PID、和 UTS。还有个别的 namespace 比较特殊，比如 User，从内核 2.6 就开始实现了，但在内核 3.8 中才宣布完成。同时，随着 Linux 自身的发展以及容器技术持续发展带来的需求，也会有新的 namespace 被支持，比如在内核 4.6 中就添加了 Cgroup namespace。\nLinux 提供了多个 API 用来操作 namespace，它们是 clone()、setns() 和 unshare() 函数，为了确定隔离的到底是哪项 namespace，在使用这些 API 时，通常需要指定一些调用参数：CLONE_NEWIPC、CLONE_NEWNET、CLONE_NEWNS、CLONE_NEWPID、CLONE_NEWUSER、CLONE_NEWUTS 和 CLONE_NEWCGROUP。如果要同时隔离多个 namespace，可以使用 | (按位或)组合这些参数。同时我们还可以通过 /proc 下面的一些文件来操作 namespace。\n查看进程所属的 namespace\n从版本号为 3.8 的内核开始，/proc/[pid]/ns 目录下会包含进程所属的 namespace 信息，使用下面的命令可以查看当前进程所属的 namespace 信息：\n$ ll /proc/$$/ns total 0 lrwxrwxrwx 1 kurome kurome 0 Mar 3 11:33 cgroup - 'cgroup:[4026531835]' lrwxrwxrwx 1 kurome kurome 0 Mar 3 11:33 ipc - 'ipc:[4026531839]' lrwxrwxrwx 1 kurome kurome 0 Mar 3 11:33 mnt - 'mnt:[4026531840]' lrwxrwxrwx 1 kurome kurome 0 Mar 3 11:33 net - 'net:[4026532008]' lrwxrwxrwx 1 kurome kurome 0 Mar 3 11:33 pid - 'pid:[4026531836]' lrwxrwxrwx 1 kurome kurome 0 Mar 3 11:33 pid_for_children - 'pid:[4026531836]' lrwxrwxrwx 1 kurome kurome 0 Mar 3 11:33 time - 'time:[4026531834]' lrwxrwxrwx 1 kurome kurome 0 Mar 3 11:33 time_for_children - 'time:[4026531834]' lrwxrwxrwx 1 kurome kurome 0 Mar 3 11:33 user - 'user:[4026531837]' lrwxrwxrwx 1 kurome kurome 0 Mar 3 11:33 uts - 'uts:[4026531838]' 首先，这些 namespace 文件都是链接文件。链接文件的内容的格式为 xxx:[inode number]。其中的 xxx 为 namespace 的类型，inode number 则用来标识一个 namespace，我们也可以把它理解为 namespace 的 ID。如果两个进程的某个 namespace 文件指向同一个链接文件，说明其相关资源在同一个 namespace 中。\n其次，在 /proc/[pid]/ns 里放置这些链接文件的另外一个作用是，一旦这些链接文件被打开，只要打开的文件描述符(fd)存在，那么就算该 namespace 下的所有进程都已结束，这个 namespace 也会一直存在，后续的进程还可以再加入进来。\n除了打开文件的方式，我们还可以通过文件挂载的方式阻止 namespace 被删除。比如我们可以把当前进程中的 uts 挂载到 ~/uts 文件：\n$ touch ~/uts $ sudo mount --bind /proc/$$/ns/uts ~/uts 使用 stat 命令检查下结果：\n$ stat ~/uts 很神奇吧，~/uts 的 inode 和链接文件中的 inode number 是一样的，它们是同一个文件。\nclone() 函数 我们可以通过 clone() 在创建新进程的同时创建 namespace。clone() 在 C 语言库中的声明如下：\n/* Prototype for the glibc wrapper function */ #define _GNU_SOURCE #include int clone(int (*fn)(void *), void *child_stack, int flags, void *arg); 实际上，clone() 是在 C 语言库中定义的一个封装(wrapper)函数，它负责建立新进程的堆栈并且调用对编程者隐藏的 clone() 系统调用。Clone() 其实是 linux 系统调用 fork() 的一种更通用的实现方式，它可以通过 flags 来控制使用多少功能。一共有 20 多种 CLONE_ 开头的 falg(标志位) 参数用来控制 clone 进程的方方面面(比如是否与父进程共享虚拟内存等)，下面我们只介绍与 namespace 相关的 4 个参数：\n fn：指定一个由新进程执行的函数。当这个函数返回时，子进程终止。该函数返回一个整数，表示子进程的退出代码。 child_stack：传入子进程使用的栈空间，也就是把用户态堆栈指针赋给子进程的 esp 寄存器。调用进程(指调用 clone() 的进程)应该总是为子进程分配新的堆栈。 flags：表示使用哪些 CLONE_ 开头的标志位，与 namespace 相关的有CLONE_NEWIPC、CLONE_NEWNET、CLONE_NEWNS、CLONE_NEWPID、CLONE_NEWUSER、CLONE_NEWUTS 和 CLONE_NEWCGROUP。 arg：指向传递给 fn() 函数的参数。  setns() 函数 通过 setns() 函数可以将当前进程加入到已有的 namespace 中。setns() 在 C 语言库中的声明如下：\n#define _GNU_SOURCE #include int setns(int fd, int nstype); 和 clone() 函数一样，C 语言库中的 setns() 函数也是对 setns() 系统调用的封装：\n fd：表示要加入 namespace 的文件描述符。它是一个指向 /proc/[pid]/ns 目录中文件的文件描述符，可以通过直接打开该目录下的链接文件或者打开一个挂载了该目录下链接文件的文件得到。 nstype：参数 nstype 让调用者可以检查 fd 指向的 namespace 类型是否符合实际要求。若把该参数设置为 0 表示不检查。  前面我们提到：可以通过挂载的方式把 namespace 保留下来。保留 namespace 的目的是为以后把进程加入这个 namespace 做准备。在 docker 中，使用 docker exec 命令在已经运行着的容器中执行新的命令就需要用到 setns() 函数。为了把新加入的 namespace 利用起来，还需要引入 execve() 系列的函数，该函数可以执行用户的命令，比较常见的用法是调用 /bin/bash 并接受参数运行起一个 shell。\nunshare() 函数 通过 unshare 函数可以在原进程上进行 namespace 隔离。也就是创建并加入新的 namespace 。unshare() 在 C 语言库中的声明如下：\n#define _GNU_SOURCE #include int unshare(int flags); 和前面两个函数一样，C 语言库中的 unshare() 函数也是对 unshare() 系统调用的封装。调用 unshare() 的主要作用就是：不启动新的进程就可以起到资源隔离的效果，相当于跳出原先的 namespace 进行操作。\n系统还默认提供了一个叫 unshare 的命令，其实就是在调用 unshare() 系统调用。下面的 demo 使用 unshare 命令把当前进程的 user namespace 设置成了 root：\n$ whoami nick $ unshare --map-root-user --user sh -c whoami root 控制组 简介 说实话，一些未知的软件应用可能需要被控制或限制——至少是为了稳定性或者某种程度上的安全性。很多时候，一个bug或者仅仅只是烂代码就有可能破坏掉整个机器甚至可能削弱整个生态。幸运的是，有一种方式可以控制应用程序，Linux控制组（cgroups）是一个内核功能，用于限制、记录和隔离一个或多个进程对CPU、内存、磁盘I/O 以及网络的访问及使用。\n即，cgroups(Control Groups) 是 linux 内核提供的一种机制，这种机制可以根据需求把一系列系统任务及其子任务整合(或分隔)到按资源划分等级的不同组内，从而为系统资源管理提供一个统一的框架。简单说，cgroups 可以限制、记录任务组所使用的物理资源。本质上来说，cgroups 是内核附加在程序上的一系列钩子(hook)，通过程序运行时对资源的调度触发相应的钩子以达到资源追踪和限制的目的。\n控制组技术最初是由谷歌开发的，最终在2.6.24版本（2008年1月）中并入Linux内核主线。这项技术被部分重新设计，添加了kernfs（用于分割一些sysfs逻辑），这些改变被合并到3.15和3.16版本的内核中。\n实现 cgroups 的主要目的是为不同用户层面的资源管理提供一个统一化的接口。从单个任务的资源控制到操作系统层面的虚拟化（Linux 容器或者LXC），cgroups 提供了四大功能：\n 资源限制：一个控制组可以配置成不能超过指定的内存限制或是不能使用超过一定数量的处理器或限制使用特定的外围设备。 优先级：一个或者多个控制组可以配置成使用更少或者更多的CPU 时间片数量或者磁盘 IO 带宽，实际上就等同于控制了任务运行的优先级。 记录：一个控制组的资源使用情况会被监督以及测量。 控制：进程组可以被冻结，暂停或者重启。  概念 Task(任务) 在 linux 系统中，内核本身的调度和管理并不对进程和线程进行区分，只是根据 clone 时传入的参数的不同来从概念上区分进程和线程。这里使用 task 来表示系统的一个进程或线程。\nCgroup(控制组) cgroups 中的资源控制以 cgroup 为单位实现。Cgroup 表示按某种资源控制标准划分而成的任务组，包含一个或多个子系统。一个任务可以加入某个 cgroup，也可以从某个 cgroup 迁移到另一个 cgroup。\nSubsystem(子系统) cgroups 中的子系统就是一个资源调度控制器(又叫 controllers)。比如 CPU 子系统可以控制 CPU 的时间分配，内存子系统可以限制内存的使用量。内核版本 4.10.0，支持的 subsystem 如下( cat /proc/cgroups)：\n blkio 对块设备的 IO 进行限制。 cpu 限制 CPU 时间片的分配，与 cpuacct 挂载在同一目录。 cpuacct 生成 cgroup 中的任务占用 CPU 资源的报告，与 cpu 挂载在同一目录。 cpuset 给 cgroup 中的任务分配独立的 CPU(多处理器系统) 和内存节点。 devices 允许或禁止 cgroup 中的任务访问设备。 freezer 暂停/恢复 cgroup 中的任务。 hugetlb 限制使用的内存页数量。 memory 对 cgroup 中的任务的可用内存进行限制，并自动生成资源占用报告。 net_cls 使用等级识别符（classid）标记网络数据包，这让 Linux 流量控制器（tc 指令）可以识别来自特定 cgroup 任务的数据包，并进行网络限制。 net_prio 允许基于 cgroup 设置网络流量(netowork traffic)的优先级。 perf_event 允许使用 perf 工具来监控 cgroup。 pids 限制任务的数量。  Hierarchy(层级) 层级有一系列 cgroup 以一个树状结构排列而成，每个层级通过绑定对应的子系统进行资源控制。层级中的 cgroup 节点可以包含零个或多个子节点，子节点继承父节点挂载的子系统。一个操作系统中可以有多个层级。\n接口 （以下为 Ubuntu 20.04，内核 5.13.0-30-generic）\ncgroups 以文件的方式提供应用接口，我们可以通过 mount 命令来查看 cgroups 默认的挂载点：\n$ mount | grep cgroup tmpfs on /sys/fs/cgroup type tmpfs (ro,nosuid,nodev,noexec,mode=755,inode64) cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,name=systemd) ... cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset) 第一行的 tmpfs 说明 /sys/fs/cgroup 目录下的文件都是存在于内存中的临时文件。\n第二行的挂载点 /sys/fs/cgroup/systemd 用于 systemd 系统对 cgroups 的支持。\n其余的挂载点则是内核支持的各个子系统的根级层级结构。\n需要注意的是，在使用 systemd 系统的操作系统中，/sys/fs/cgroup 目录都是由 systemd 在系统启动的过程中挂载的，并且挂载为只读的类型。换句话说，系统是不建议我们在 /sys/fs/cgroup 目录下创建新的目录并挂载其它子系统的。这一点与之前的操作系统不太一样。\n下面让我们来探索一下 /sys/fs/cgroup 目录及其子目录下都是些什么：\n$ ls /sys/fs/cgroup blkio cpu,cpuacct freezer misc net_prio rdma cpu cpuset hugetlb net_cls perf_event systemd cpuacct devices memory net_cls,net_prio pids unified /sys/fs/cgroup 目录下是各个子系统的根目录。我们以 memory 子系统为例，看看 memory 目录下都有什么？\n$ ls /sys/fs/cgroup/memory cgroup.clone_children memory.memsw.limit_in_bytes cgroup.event_control memory.memsw.max_usage_in_bytes cgroup.procs memory.memsw.usage_in_bytes cgroup.sane_behavior memory.move_charge_at_immigrate memory.failcnt memory.numa_stat memory.force_empty memory.oom_control memory.kmem.failcnt memory.pressure_level memory.kmem.limit_in_bytes memory.soft_limit_in_bytes memory.kmem.max_usage_in_bytes memory.stat memory.kmem.slabinfo memory.swappiness memory.kmem.tcp.failcnt memory.usage_in_bytes memory.kmem.tcp.limit_in_bytes memory.use_hierarchy memory.kmem.tcp.max_usage_in_bytes notify_on_release memory.kmem.tcp.usage_in_bytes release_agent memory.kmem.usage_in_bytes system.slice memory.limit_in_bytes tasks memory.max_usage_in_bytes user.slice memory.memsw.failcnt 这些文件就是 cgroups 的 memory 子系统中的根级设置。比如 memory.limit_in_bytes 中的数字用来限制进程的最大可用内存，memory.swappiness 中保存着使用 swap 的权重等等。\n手动方法 你可以直接或者间接（通过LXC、libvirt或者Docker）访问及管理控制组，这里我首先介绍使用sysfs以及libgroups库。接下来的示例需要你预先安装一个必须的包。\n$ sudo apt-get install libcgroup1 cgroup-tools 我将使用一个简单的shell脚本文件test.sh作为示例应用程序，它将会在无限while循环中运行以下两个命令。\n$ cat test.sh !/bin/shwhile [ 1 ]; do echo \"hello world\" sleep 60 done 安装必要的包后，你可以直接通过sysfs的目录结构来配置你的控制组，例如，要在内存子系统中创建一个叫做foo的控制组，只需要在/sys/fs/cgroup/memory底下新建一个叫做foo的目录：\n$ sudo mkdir /sys/fs/cgroup/memory/foo 在我们使用 cgroups 时，最好不要直接在各个子系统的根目录下直接修改其配置文件。推荐的方式是为不同的需求在子系统树中定义不同的节点。\ncgroups 的文件系统会在创建文件目录的时候自动创建配置文件：\n$ ls /sys/fs/cgroup/memory/foo cgroup.clone_children memory.memsw.failcnt cgroup.event_control memory.memsw.limit_in_bytes cgroup.procs memory.memsw.max_usage_in_bytes memory.failcnt memory.memsw.usage_in_bytes memory.force_empty memory.move_charge_at_immigrate memory.kmem.failcnt memory.numa_stat memory.kmem.limit_in_bytes memory.oom_control memory.kmem.max_usage_in_bytes memory.pressure_level memory.kmem.slabinfo memory.soft_limit_in_bytes memory.kmem.tcp.failcnt memory.stat memory.kmem.tcp.limit_in_bytes memory.swappiness memory.kmem.tcp.max_usage_in_bytes memory.usage_in_bytes memory.kmem.tcp.usage_in_bytes memory.use_hierarchy memory.kmem.usage_in_bytes notify_on_release memory.limit_in_bytes tasks memory.max_usage_in_bytes 默认情况下，每个新建的控制组将会继承对系统整个内存池的访问权限。但对于某些应用程序，这些程序拒绝释放已分配的内存并继续分配更多内存，这种默认继承方式显然不是个好主意。要使程序的内存限制变得更为合理，你需要更新文件memory.limit_in_bytes。\n限制控制组foo下运行的任何应用的内存上限为50MB：\n$ echo 50000000 | sudo tee /sys/fs/cgroup/memory/foo/memory.limit_in_bytes 验证设置：\n$ sudo cat memory.limit_in_bytes 49999872 请注意，回读的值始终是内核页面大小的倍数（即4096字节或4KB）。这个值是内存的最小可分配大小。\n启动应用程序test.sh：\n$ sh ~/test.sh 使用进程ID（PID），将应用程序移动到内存控制器底下的控制组foo：\n$ echo 2152 | sudo tee /sys/fs/cgroup/memory/foo/cgroup.procs 使用相同的PID，列出正在运行的进程并验证它是否在正确的控制组下运行：\n$ ps -o cgroup 2152 CGROUP 5:devices:/user.slice,4:pids:/user.slice/user-1000.slice/user@1000.service,3:m... 或者通过 /proc/[pid]/cgroup 来查看指定进程属于哪些 cgroup：\n$ cat /proc/2152/cgroup 13:cpuset:/ 12:blkio:/ 11:misc:/ 10:rdma:/ 9:freezer:/ 8:cpu,cpuacct:/ 7:perf_event:/ 6:hugetlb:/ 5:devices:/user.slice 4:pids:/user.slice/user-1000.slice/user@1000.service 3:memory:/foo #here 2:net_cls,net_prio:/ 1:name=systemd:/user.slice/user-1000.slice/user@1000.service/gnome\\x2dsession\\x2dmanager.slice/gnome-session-manager@ubuntu.service 0::/user.slice/user-1000.slice/user@1000.service/gnome\\x2dsession\\x2dmanager.slice/gnome-session-manager@ubuntu.service 每一行包含用冒号隔开的三列，他们的含义分别是：\n cgroup 树的 ID， 和 /proc/cgroups 文件中的 ID 一一对应。 和 cgroup 树绑定的所有 subsystem，多个 subsystem 之间用逗号隔开。这里 name=systemd 表示没有和任何 subsystem 绑定，只是给他起了个名字叫 systemd。 进程在 cgroup 树中的路径，即进程所属的 cgroup，这个路径是相对于挂载点的相对路径。  你还可以通过读取文件来监控控制组正在使用的资源。在这种情况下，你可以查看你的进程（以及生成的子进程）被分配的内存大小。\n$ cat /sys/fs/cgroup/memory/foo/memory.usage_in_bytes 188416 当进程“迷路”时 现在让我们重新创建相同的场景，但这次我们将控制组foo的内存限制从50MB改为500 bytes：\n$ echo 500 | sudo tee /sys/fs/cgroup/memory/foo/memory.limit_in_bytes 注意：如果任务超出其定义的限制，内核将进行干预，并在某些情况下终止该任务。\n同样，当您重新读取值时，它将始终是内核页面大小的倍数。因此，虽然您将其设置为500字节，但它实际上被设置为4 KB：\n$ cat /sys/fs/cgroup/memory/foo/memory.limit_in_bytes 4096 启动应用程序test.sh，将其移动到控制组下并监视系统日志：\n$ sudo tail -f /var/log/messages ... 请注意，内核的Out-Of-Mempry Killer（也叫做oom-killer 内存不足杀手）在应用程序达到4KB限制时就会介入。它会杀死应用程序，应用程序将不再运行，你可以通过输入以下命令进行验证：\n$ ps -o cgroup 2152 使用libcgroup 之前描述的许多早期步骤都可以通过libcgroup包中提供的管理工具进行简化。例如，使用cgcreate二进制文件的单个命令即可创建sysfs条目和文件。\n输入以下命令即可在内存子系统下创建一个叫做foo的控制组：\n$ sudo cgcreate -g memory:foo 注意：libcgroup提供了一种管理控制组中任务的机制。\n使用与之前相同的方法，你就可以开始设置内存阈值：\n$ echo 50000000 | sudo tee /sys/fs/cgroup/memory/foo/memory.limit_in_bytes 验证新配置的设置：\n$ sudo cat memory.limit_in_bytes 50003968 使用cgexec二进制文件在控制组foo中运行应用程序：\n$ sudo cgexec -g memory:foo ~/test.sh 使用它的进程ID - PID来验证应用程序是否在控制组和子系统（内存）下运行：\n$ ps -o cgroup 2945 CGROUP 6:memory:/foo,1:name=systemd:/user.slice/user-0.slice/session-1.scope 如果您的应用程序不再运行，并且您想要清理并删除控制组，则可以使用二进制文件cgdelete来执行此操作。要从内存控制器下删除控制组foo，请输入：\n$ sudo cgdelete memory:foo 持久组 您也可以通过一个简单的配置文件和服务的启动来完成上述所有操作。您可以在/etc/cgconfig.conf文件中定义所有控制组名称和属性。以下为foo组添加了一些属性：\n$ cat /etc/cgconfig.conf group foo { cpu { cpu.shares = 100; } memory { memory.limit_in_bytes = 5000000; } } cpu.shares选项定义了该组的CPU优先级。默认情况下，所有组都继承1024 shares（CPU share指的是控制组中的任务被分配到的CPU的 time的优先级，即值越大，分配到的CPU time越多，这个值需大于等于2），即100%的CPU time（CPU time是CPU用于处理一个程序所花费的时间）。通过将cpu.shares的值降低到更保守的值（如100），这个组将会被限制只能使用大概10%的CPU time。\n就如之前讨论的，在控制组中运行的进程也可以被限制它能访问的CPUs（内核）的数量。将以下部分添加到同一个配置文件cgconfig.conf中组名底下。\ncpuset { cpuset.cpus=\"0-5\"; } 有了这个限制，这个控制组会将应用程序绑定到到0核到5核——也就是说，它只能访问系统上的前6个CPU核。\n接下来，您需要使用cgconfig服务加载此配置。首先，启用cgconfig以在系统启动时能够加载上述配置：\n$ sudo systemctl enable cgconfig Create symlink from /etc/systemd/system/sysinit.target.wants/cgconfig.service to /usr/lib/systemd/system/cgconfig.service. 现在，启动cgconfig服务并手动加载相同的配置文件（或者您可以跳过此步骤直接重启系统）：\n$ sudo systemctl start cgconfig 在控制组foo下启动该应用程序并将其绑定到您设置的内存和CPU限制：\n$ sudo cgexec -g memory,cpu,cpuset:foo ~/test.sh \u0026 除了将应用程序启动到预定义的控制组之外，其余所有内容都将在系统重新启动后持续存在。但是，您可以通过定义依赖于cgconfig服务的启动初始脚本来启动该应用程序，自动执行该过程。\n总结 通常来说，限制一个机器上一个或者多个任务的权限是必要的。控制组提供了这项功能，通过使用它，您可以对一些特别重要或无法控制的应用程序实施严格的硬件和软件限制。如果一个应用程序没有设置上限阈值或限制它可以在系统上消耗的内存量，cgroups可以解决这个问题。如果另一个应用程序没有CPU上的限制，那么cgroups可以再一次解决您的问题。您可以通过cgroup完成这么多工作，只需花一点时间，您就可以使用你的操作系统环境恢复稳定性，安全性和健全性。\n使用 Systemd 当 Linux 的 init 系统发展到 systemd 之后，systemd 与 cgroups 发生了融合(或者说 systemd 提供了 cgroups 的使用和管理接口)。\nSystemd 依赖 cgroups\n要理解 systemd 与 cgroups 的关系，我们需要先区分 cgroups 的两个方面：层级结构(A)和资源控制(B)。首先 cgroups 是以层级结构组织并标识进程的一种方式，同时它也是在该层级结构上执行资源限制的一种方式。我们简单的把 cgroups 的层级结构称为 A，把 cgrpups 的资源控制能力称为 B。\n对于 systemd 来说，A 是必须的，如果没有 A，systemd 将不能很好的工作。而 B 则是可选的，如果你不需要对资源进行控制，那么在编译 Linux 内核时完全可以去掉 B 相关的编译选项。\nSystemd 默认挂载的 cgroups 系统\n在系统的开机阶段，systemd 会把支持的 controllers (subsystem 子系统)挂载到默认的 /sys/fs/cgroup/ 目录下面，除了 systemd 目录外，其它目录都是对应的 subsystem。\n/sys/fs/cgroup/systemd 目录是 systemd 维护的自己使用的非 subsystem 的 cgroups 层级结构。换句话说就是，并不允许其它的程序动这个目录下的内容。其实 /sys/fs/cgroup/systemd 目录对应的 cgroups 层级结构就是 systemd 用来使用 cgoups 中 feature A 的。\nCgroup 的默认层级\n过将 cgroup 层级系统与 systemd unit 树绑定，systemd 可以把资源管理的设置从进程级别移至应用程序级别。因此，我们可以使用 systemctl 指令，或者通过修改 systemd unit 的配置文件来管理 unit 相关的资源。\n默认情况下，systemd 会自动创建 slice、scope 和 service unit 的层级来为 cgroup 树提供统一的层级结构。\n系统中运行的所有进程，都是 systemd init 进程的子进程。在资源管控方面，systemd 提供了三种 unit 类型：\n service： 一个或一组进程，由 systemd 依据 unit 配置文件启动。service 对指定进程进行封装，这样进程可以作为一个整体被启动或终止。 scope：一组外部创建的进程。由进程通过 fork() 函数启动和终止、之后被 systemd 在运行时注册的进程，scope 会将其封装。例如：用户会话、 容器和虚拟机被认为是 scope。 slice： 一组按层级排列的 unit。slice 并不包含进程，但会组建一个层级，并将 scope 和 service 都放置其中。真正的进程包含在 scope 或 service 中。在这一被划分层级的树中，每一个 slice 单位的名字对应通向层级中一个位置的路径。  以通过 systemd-cgls 命令来查看 cgroups 的层级结构\nControl group /: -.slice ├─419 bpfilter_umh ├─user.slice │ ├─user-125.slice │ │ ├─session-c1.scope │ │ │ ├─1101 gdm-session-worker [pam/gdm-launch-environment] │ │ │ ├─1158 /usr/lib/gdm3/gdm-x-session dbus-run-session -- gnome-session - │ │ │ ├─1160 /usr/lib/xorg/Xorg vt1 -displayfd 3 -auth /run/user/125/gdm/Xau │ │ │ ├─1347 dbus-run-session -- gnome-session --autostart /usr/share/gdm/gr │ │ │ ├─1348 dbus-daemon --nofork --print-address 4 --session │ │ │ ├─1349 /usr/libexec/gnome-session-binary --systemd --autostart /usr/sh │ │ │ ├─1352 /usr/libexec/at-spi-bus-launcher │ │ │ ├─1357 /usr/bin/dbus-daemon --config-file=/usr/share/defaults/at-spi2/ │ │ │ ├─1378 /usr/bin/gnome-shell │ │ │ ├─1432 ibus-daemon --panel disable --xim │ │ │ ├─1435 /usr/libexec/ibus-dconf │ │ │ ├─1438 /usr/libexec/ibus-x11 --kill-daemon │ │ │ ├─1440 /usr/libexec/ibus-portal │ │ │ ├─1451 /usr/libexec/at-spi2-registryd --use-gnome-session service、scope 和 slice unit 被直接映射到 cgroup 树中的对象。当这些 unit 被激活时，它们会直接一一映射到由 unit 名建立的 cgroup 路径中。例如，cron.service 属于 system.slice，会直接映射到 cgroup system.slice/cron.service/ 中。 注意，所有的用户会话、虚拟机和容器进程会被自动放置在一个单独的 scope 单元中。\n默认情况下，系统会创建四种 slice：\n -.slice：根 slice system.slice：所有系统 service 的默认位置 user.slice：所有用户会话的默认位置 machine.slice：所有虚拟机和 Linux 容器的默认位置  创建临时的 cgroup\n对资源管理的设置可以是 transient(临时的)，也可以是 persistent (永久的)。我们先来介绍如何创建临时的 cgroup。\n需要使用 systemd-run 命令创建临时的 cgroup，它可以创建并启动临时的 service 或 scope unit，并在此 unit 中运行程序。systemd-run 命令默认创建 service 类型的 unit，比如我们创建名称为 toptest 的 service 运行 top 命令：\n$ sudo systemd-run --unit=toptest --slice=test top -b 然后查看一下 test.slice 的状态：\n$ sudo systemctl status test.slice 创建了一个 test.slice/toptest.service cgroup 层级关系。再看看 toptest.service 的状态：\n$ sudo systemctl status toptest.service top 命令被包装成一个 service 运行在后台了！\n接下来我们就可以通过 systemctl 命令来限制 toptest.service 的资源了。在限制前让我们先来看一看 top 进程的 cgroup 信息：\n$ cat /proc/2850/cgroup 比如我们限制 toptest.service 的 CPUShares 为 600，可用内存的上限为 550M：\n$ sudo systemctl set-property toptest.service CPUShares=600 MemoryLimit=500M 再次检查 top 进程的 cgroup 信息：\n$ cat /proc/2850/cgroup 在 CPU 和 memory 子系统中都出现了 toptest.service 的名字。同时去查看 /sys/fs/cgroup/memory/test.slice 和 /sys/fs/cgroup/cpu/test.slice 目录，这两个目录下都多出了一个 toptest.service 目录。我们设置的 CPUShares=600 MemoryLimit=500M 被分别写入了这些目录下的对应文件中。\n临时 cgroup 的特征是，所包含的进程一旦结束，临时 cgroup 就会被自动释放。比如我们 kill 掉 top 进程，然后再查看 /sys/fs/cgroup/memory/test.slice 和 /sys/fs/cgroup/cpu/test.slice 目录，刚才的 toptest.service 目录已经不见了。\n通过配置文件修改 cgroup\n所有被 systemd 监管的 persistent cgroup(持久的 cgroup)都在 /usr/lib/systemd/system/ 目录中有一个 unit 配置文件。比如我们常见的 service 类型 unit 的配置文件。我们可以通过设置 unit 配置文件来控制应用程序的资源，persistent cgroup 的特点是即便系统重启，相关配置也会被保留。需要注意的是，scope unit 不能以此方式创建。下面让我们为 cron.service 添加 CPU 和内存相关的一些限制，编辑 /lib/systemd/system/cron.service 文件：\n$ sudo vim /lib/systemd/system/cron.service [Service] CPUShares=600 MemoryLimit=500M EnviromentFile=-/etc/default/cron ExecStart=/usr/sbin/cron -f $EXTRA_OPTS IgnoreSIGPIPE=false KillMode=process 然后重新加载配置文件并重启 cron.service：\n$ sudo systemctl daemon-reload $ sudo systemctl restart cron.service 现在去查看 /sys/fs/cgroup/memory/system.slice/cron.service/memory.limit_in_bytes 和 /sys/fs/cgroup/cpu/system.slice/cron.service/cpu.shares 文件，是不是已经包含我们配置的内容了！\n通过 systemctl 命令修改 cgroup\n除了编辑 unit 的配置文件，还可以通过 systemctl set-property 命令来修改 cgroup，这种方式修该的配置也会在重启系统时保存下来。现在我们把 cron.service 的 CPUShares 改为 700：\n$ sudo systemctl set-property cron.service CPUShares=700 查看 /sys/fs/cgroup/cpu/system.slice/cron.service/cpu.shares 文件的内容应该是 700，重启系统后该文件的内容还是 700。\nSystemd-cgtop 命令\n类似于 top 命令，systemd-cgtop 命令显示 cgoups 的实时资源消耗情况。\n通过它我们就可以分析应用使用资源的情况。\nLXC LXC（Linux容器，Linux Container）相当于你运行了一个接近于裸机的虚拟机。这项技术始于2008年，LXC的大部分功能来自于Solaris容器（又叫做Solaries Zones）以及之前的FreeBSD jails技术。 LXC并不是创建一个成熟的虚拟机，而是创建了一个拥有自己进程程和网络空间的虚拟环境，使用命名空间来强制进程隔离并利用内核的控制组（cgroups）功能，该功能可以限制，计算和隔离一个或多个进程的CPU，内存，磁盘I / O和网络使用情况。 您可以将这种用户空间框架想像成是chroot的高级形式。\n chroot 是一个改变当前运行进程以及其子进程的根目录的操作。一个运行在这种环境的程序无法访问根目录外的文件和命令。\n 注意：LXC使用命名空间来强制进程隔离，同时利用内核的控制组来计算以及限制一个或多个进程的CPU，内存，磁盘I / O和网络使用。\n但容器究竟是什么？简短的答案是容器将软件应用程序与操作系统分离，为用户提供干净且最小的Linux环境，与此同时在一个或多个隔离的“容器”中运行其他所有内容。容器的目的是启动一组有限数量的应用程序或服务（通常称为微服务），并使它们在独立的沙盒环境中运行。\n这种隔离可防止在给定容器内运行的进程监视或影响在另一个容器中运行的进程。此外，这些集装箱化服务不会影响或干扰主机。能够将分散在多个物理服务器上的许多服务合并为一个的想法是数据中心选择采用该技术的众多原因之一。\n容器有以下几个特点：\n 安全性：容器里可以运行网络服务，这可以限制安全漏洞或违规行为造成的损害。那些成功利用那个容器的一个或多个应用的安全漏洞的入侵者将会被限制在只能在那个容器中做一些操作。 隔离性：容器允许在同一物理机器上部署一个或多个应用程序，即使这些应用程序必须在不同的域下运行，每个域都需要独占访问其各自的资源。例如，通过将每个容器关联的不同IP地址，在不同容器中运行的多个应用程序可以绑定到同一物理网络接口。 虚拟化和透明性：容器为系统提供虚拟化环境，这个环境可以隐藏或限制系统底层的物理设备或系统配置的可见性。容器背后的一般原则是避免更改运行应用程序的环境，但解决安全性或隔离问题除外。  使用LXC的工具 对于大多数现代Linux发行版，内核都启用了控制组，但您很可能仍需要安装LXC工具。\n对于Ubuntu或Debian，只需键入：\n$ sudo apt-get install lxc 现在，在开始使用这些工具之前，您需要配置您的环境。在此之前，您需要验证当前用户是否同时在/etc/subuid和/etc/subgid中定义了uid和gid：\n$ cat /etc/subuid petros:100000:65536 $ cat /etc/subgid petros:100000:65536 如果~/.config/lxc不存在，则创建该目录，并且把配置文件/etc/lxc/default.conf复制到~/.config/lxc/default.conf.，将以下两行添加到文件末尾：\nlxc.id_map = u 0 100000 65536 lxc.id_map = g 0 100000 65536 结果如下：\n$ cat ~/.config/lxc/default.conf lxc.network.type = veth lxc.network.link = lxcbr0 lxc.network.flags = up lxc.network.hwaddr = 00:16:3e:xx:xx:xx lxc.id_map = u 0 100000 65536 lxc.id_map = g 0 100000 65536 将以下命令添加到/etc/lxc/lxc-usernet文件末尾（把第一列换成你的username）：\npetros veth lxcbr0 10 最快使这些配置生效的方法是重启或者将用户登出再登入。\n重新登录后，请验证当前是否已加载veth网络驱动程序：\n$ lsmod | grep veth veth 16384 0 如果没有，请输入：\n$ sudo modprobe veth 现在您可以使用LXC工具集来下载，运行，管理Linux容器。\n接下来，下载容器镜像并将其命名为“example-container”。当您键入以下命令时，您将看到一长串许多Linux发行版和版本支持的容器：\n$ sudo lxc-create -t download -n example-container 将会有三个弹出框让您分别选择发行版名称（distribution），版本号（release）以及架构（architecture）。请选择以下三个选项：\nDistribution: ubuntu Release: xenial Architecture: amd64 选择后点击Enter，rootfs将在本地下载并配置。出于安全原因，每个容器不附带OpenSSH服务器或用户帐户。同时也不会提供默认的root密码。要更改root密码并登录，必须在容器目录路径中运行lxc-attach或chroot（在启动之后）。\n启动容器：\n$ sudo lxc-start -n example-container -d -d选项表示隐藏容器，它会在后台运行。如果您想要观察boot的过程，只需要将-d换成-F。那么它将在前台运行，登录框出现时结束。\n你可能会遇到如下错误：\n$ sudo lxc-start -n example-container -d lxc-start: tools/lxc_start.c: main: 366 The container failed to start. lxc-start: tools/lxc_start.c: main: 368 To get more details, run the container in foreground mode. lxc-start: tools/lxc_start.c: main: 370 Additional information can be obtained by setting the --logfile and --logpriority options. 如果你遇到了，您需要通过在前台运行lxc-start服务来调试它：\n$ sudo lxc-start -n example-container -F lxc-start: conf.c: instantiate_veth: 2685 failed to create veth pair (vethQ4NS0B and vethJMHON2): Operation not supported lxc-start: conf.c: lxc_create_network: 3029 failed to create netdev lxc-start: start.c: lxc_spawn: 1103 Failed to create the network. lxc-start: start.c: __lxc_start: 1358 Failed to spawn container \"example-container\". lxc-start: tools/lxc_start.c: main: 366 The container failed to start. lxc-start: tools/lxc_start.c: main: 370 Additional information can be obtained by setting the --logfile and --logpriority options. 从以上示例，你可以看到模块veth没有被引入，在引入之后，将会解决这个问题。\n之后，打开第二个terminal窗口，验证容器的状态。\n$ sudo lxc-info -n example-container Name: example-container State: RUNNING PID: 1356 IP: 10.0.3.28 CPU use: 0.29 seconds BlkIO use: 16.80 MiB Memory use: 29.02 MiB KMem use: 0 bytes Link: vethPRK7YU TX bytes: 1.34 KiB RX bytes: 2.09 KiB Total bytes: 3.43 KiB 也可以通过另一种方式来查看所有安装的容器，运行命令：\n$ sudo lxc-ls -f NAME STATE AUTOSTART GROUPS IPV4 IPV6 example-container RUNNING 0 - 10.0.3.28 - 但是问题是你仍然不能登录进去，你只需要直接attach到正在运行的容器，创建你的用户，使用passwd命令改变相关的密码。\n$ sudo lxc-attach -n example-container root@example-container:/# root@example-container:/# useradd petros root@example-container:/# passwd petros Enter new UNIX password: Retype new UNIX password: passwd: password updated successfully 更改密码后，您将能够从控制台直接登录到容器，而无需使用lxc-attach命令：\n$ sudo lxc-console -n example-container 如果要通过网络连接到此运行容器，请安装OpenSSH服务器：\n# apt-get install openssh-server 抓取容器的本地IP地址：\n# ip addr show eth0|grep inet inet 10.0.3.25/24 brd 10.0.3.255 scope global eth0 inet6 fe80::216:3eff:fed8:53b4/64 scope link 然后在主机的新的控制台窗口中键入：\n$ ssh 10.0.3.25 瞧！您现在可以SSH到正在运行的容器并键入您的用户名和密码。\n在主机系统上，而不是在容器内，可以观察在启动容器后启动和运行的LXC进程：\n$ ps aux | grep lxc | grep -v grep ... 要停止容器，请键入（在主机）：\n$ sudo lxc-stop -n example-container 停止后，验证容器的状态：\n$ sudo lxc-ls -f NAME STATE AUTOSTART GROUPS IPV4 IPV6 example-container STOPPED 0 - - - $ sudo lxc-info -n example-container Name: example-container State: STOPPED 要彻底销毁容器 - 即从主机system—type清除它：\n$ sudo lxc-destroy -n example-container Destroyed container example-container 销毁后，可以验证是否已将其删除：\n$ sudo lxc-info -n example-container example-container doesn't exist $ sudo lxc-ls -f 注意：如果您尝试销毁正在运行的容器，该命令将失败并告知您容器仍在运行：\n$ sudo lxc-destroy -n example-container example-container is running 在销毁容器前必须先停止它。\n高级配置 有时，可能需要配置一个或多个容器来完成一个或多个任务。 LXC通过让管理员修改位于/var/lib/lxc中的容器配置文件来简化这一过程：\n$ sudo su # cd /var/lib/lxc # ls example-container 容器的父目录将包含至少两个文件：1）容器配置文件和 2）容器的整个rootfs：\n# cd example-container/ # ls config rootfs 假设您想要在主机系统启动时自动启动名称为example-container的容器。那么您需要将以下行添加到容器的配置文件/var/lib/lxc/example-container/config的尾部：\n# Enable autostart lxc.start.auto = 1 重新启动容器或重新启动主机系统后，您应该看到如下内容：\n$ sudo lxc-ls -f NAME STATE AUTOSTART GROUPS IPV4 IPV6 example-container RUNNING 1 - 10.0.3.25 - 注意 AUTOSTART 字段现在被设置为“1”。\n如果在容器启动时，您希望容器绑定装载主机上的目录路径，请将以下行添加到同一文件的尾部：\n# 将挂载系统路径绑定到本地路径 lxc.mount.entry = /mnt mnt none bind 0 0 通过上面的示例，当容器重新启动时，您将看到容器本地的 / mnt目录可访问的主机/ mnt目录的内容。\n特权与非特权容器 您经常会发现在与LXC相关的内容中讨论特权容器和非特权容器的概念。但它们究竟是什么呢？这个概念非常简单，并且LXC容器可以在任一配置下运行。\n根据设计，无特权容器被认为比特权容器更安全，更保密。无特权容器运行时，容器的root UID映射到主机系统上的非root UID。这使得攻击者即使破解了容器，也难以获得对底层主机的root权限。简而言之，如果攻击者设法通过已知的软件漏洞破坏了您的容器，他们会立即发现自己无法获取任何主机权限。\n特权容器可能使系统暴露于此类攻击。这就是为什么我们最好在特权模式下运行尽量少的容器。确定需要特权访问的容器，并确保付出额外的努力来定期更新并以其他方式锁定它们。\n然而，Docker又是什么呢？ 我花了相当多的时间谈论Linux容器，但是Docker呢？它是生产中部署最多的容器解决方案。自首次推出以来，Docker已经风靡Linux计算世界。 Docker是一种Apache许可的开源容器化技术，旨在自动化在容器内创建和部署微服务这类重复性任务。 Docker将容器视为非常轻量级和模块化的虚拟机。最初，Docker是在LXC之上构建的，但它已经远离了这种依赖，从而带来了更好的开发人员和用户体验。与LXC非常相似，Docker继续使用内核cgroup子系统。该技术不仅仅是运行容器，还简化了创建容器，构建映像，共享构建的映像以及对其进行版本控制的过程。\nDocker主要关注于：\n 可移植性：Docker提供基于镜像的部署模型。这种类型的可移植性允许更简单的方式在多个环境中共享应用程序或服务集合（以及它们的所有依赖）。 版本控制：单个Docker镜像由一系列组合层组成。每当镜像被更改时，都会创建一个新层。例如，每次用户指定命令（例如运行或复制）时，都会创建一个新层。 Docker将重用这些层用于新的容器构建。分层到Docker是它自己的版本控制方法。 回滚：再次，每个Docker镜像都有很多层。如果您不想使用当前运行的层，则可以回滚到以前的版本。这种敏捷性使软件开发人员可以更轻松地持续集成和部署他们的软件技术。 快速部署：配置新硬件通常需要数天时间。并且，安装和配置它的工作量和开销是非常繁重的。使用Docker，您可以在几秒钟将镜像启动并运行，相比于之前，节省了大量的时间。当你使用完一个容器时，你可以轻松地销毁它。  从本质上说，Docker和LXC都非常相似。它们都是用户空间和轻量级虚拟化平台，它们利用cgroup和命名空间来管理资源隔离。但是，两者之间也存在许多明显的差异。\n进程管理 Docker将容器限制为单个进程运行。如果您的应用程序包含X个并发进程，Docker将要求您运行X个容器，每个容器都有自己单独的进程。 LXC不是这样，LXC运行具有传统init进程的容器，反过来，可以在同一容器内托管多个进程。例如，如果要托管LAMP（Linux + Apache + MySQL + PHP）服务器，每个应用程序的每个进程都需要跨越多个Docker容器。\n状态管理 Docker被设计为无状态，意味着它不支持持久存储。有很多方法可以解决这个问题，但同样，只有在进程需要时才需要它。创建Docker镜像时，它将包含只读层。这不会改变。在运行时，如果容器的进程对其内部状态进行任何更改，则将保持内部状态和镜像的当前状态之间的差异，直到对Docker镜像进行提交（创建新层）或直到容器被删除，差异也会消失。\n可移植性 在讨论Docker时，这个词往往被过度使用——因为它是Docker相对于LXC的最重要的优势。 Docker从应用程序中抽象出网络，存储和操作系统细节方面做得更好。这样就形成了一个真正独立于配置的应用程序，保证应用程序的环境始终保持不变，无论启用它的机器配置环境如何。\nDocker旨在使开发人员和系统管理员都受益。它已成为许多DevOps（开发人员+维护人员）工具链中不可或缺的一部分。开发人员可以专注于编写代码，而无需担心最终托管它的系统是什么。使用Docker，无需安装和配置复杂数据库，也无需担心在不兼容的语言工具链版本之间切换。 Docker为维护人员提供了更多的灵活性，通常可以减少托管一些较小和更基本的应用程序所需的物理系统数量。 Docker简化了软件交付。新功能和错误/安全修复程序可以快速到达客户，无需任何麻烦，意外或停机。\n总结 为了基础设施安全性和系统稳定性而隔离进程并不像听起来那么痛苦。 Linux内核提供了所有必要的工具，使简单易用的用户空间应用程序【如LXC（甚至Docker）】能够在隔离的沙盒环境中管理操作系统的微实例及其本地服务。\n沙箱 在计算机安全领域，沙箱(Sandbox)是一种程序的隔离运行机制，其目的是限制不可信进程的权限。沙箱技术经常被用于执行未经测试的或不可信的客户程序。为了避免不可信程序可能破坏其它程序的运行，沙箱技术通过为不可信客户程序提供虚拟化的磁盘、内存以及网络资源，而这种虚拟化手段对客户程序来说是透明的。由于沙箱里的资源被虚拟化（或被间接化），所以沙箱里的不可信程序的恶意行为往往会被限制在沙箱中。\n沙箱技术一直是系统安全领域的挑战，不存在说哪一种方案是足够安全的。沙箱技术方案通常是需要结合多种系统安全技术来实现，采用防御纵深(Defence in Depth)的设计原则，筑建多道防御屏障，尽可能地将安全风险将为最低。下面我们主要讨论如何利用Linux kernel所提供的安全功能来建立有效的沙箱技术。\n在讨论之前，我们简单回顾一下Linux安全模型相关的内容（假设读者已经非常熟悉）：\n(1) 每个进程都有自己的地址空间；\n(2) MMU硬件机制来保证地址空间的隔离；\n(3) Kernel是系统的TCB(Trusted Computing Base)，是安全策略的制定者和执行者；\n(4) 进程是最小的权限边界；\n(5) root具有最高权限，它能控制一切；\n(6) 其它用户受DAC(Discretionary Access Control)限制，如文件系统的UGO权限控制。\n进程是最小的权限边界，其根本原因是MMU能保证进程地址空间的隔离。\nLinux Kernel还提供了与进程降权(drop privilege)相关的一些功能：\n setuid POSIX.1e capability chroot jail Quota control (eg, cgroup, namespace) Linux Container Linux Security Module (LSM)  下面我们会介绍如何在实践中利用这些诀窍来构建一个有效的sandbox.\n权限 ugo Linux 系统中文件的 ugo 权限是 Linux 进行权限管理的基本方式。\n所有者和组 Linux 文件的 ugo 权限把对文件的访问者划分为三个类别：文件的所有者、组和其他人。所谓的 ugo 就是指 user(也称为 owner)、group 和 other 三个单词的首字母组合。\n用户和组的信息分别记录在 /etc/passwd、/etc/group 文件中，这两个文件的内容是任何人都有权查看的，可以直接以读取文本文件的方式查看其内容，其中的每一行代表一个用户。\n文件的所有者\n文件的所有者一般是创建该文件的用户，对该文件具有完全的权限。在一台允许多个用户访问的 Linux 主机上，可以通过文件的所有者来区分一个文件属于某个用户。当然，一个用户也无权查看或更改其它用户的文件。\n文件所属的组\n假如有几个用户合作开发同一个项目，如果每个用户只能查看和修改自己创建的文件就太不方便了，也就谈不上什么合作了。所以需要一个机制允许一个用户查看和修改其它用户的文件，此时就用到组的概念的。我们可以创建一个组，然后把需要合作的用户都添加都这个组中。在设置文件的访问权限时，允许这个组中的用户对该文件进行读取和修改。\n其他人\n如果我想把一个文件共享给系统中的所有用户该怎么办？通过组的方式显然是不合适的，因为需要把系统中的所有用户都添加到一个组中。并且系统中添加了新用户该怎么办，每添加一个新用户就把他添加到这个组中吗？这个问题可以通过其他人的概念解决。在设置文件的访问权限时，允许其他人户对该文件进行读取和修改。\n文件属性 使用 ll 命令可以查看文件的属性信息：\n$ ll Desktop drwxr-xr-x 2 nick nick 4.0K Mar 2 15:06 Desktop  drwxr-xr-x 指明文件的类型和 ugo 权限信息。 2 是对文件的引用计数。 nick 是文件的所有者，文件的所有者一般是创建该文件的用户，对该文件具有完全的权限。 nick 是文件所属的组，我们通过 adduser 命令创建用户时一般会创建一个同名的组，该用户就属于与他同名的组(比如笔者机器上的用户 nick 就属于 nick 组)。当我们创建文件和目录时，其默认所属的组就是所有者所在的组。  其它的信息我们暂时忽略。\n文件类型\ndrwxr-xr-x 的第一个字符描述文件的类型，常见的类型有如下几种：\n d 表示目录 - 表示普通文件 l 表示链接文件 b 表示块设备文件 c 表示字符设备文件 s 表示 socket 文件  ugo 权限信息\n10 个字符，除去第一个表示文件类型的字符，其它 9 个字符表示文件的 ugo 权限信息\n这 9 个字符以三个为一组，都是 rwx 或 - 的组合。其中，r 代表可读(read)、 w 代表可写(write)、 x 代表可执行(execute)。 这三个权限的位置不会改变，如果没有对应的权限，就会以 -(减号)代替。\n*第一组为文件所有者的权限，第二组为文件所属组的权限，第三组为其他人的权限。*其表示的具体含义为：文件所有者具有对文件的读写权限，文件所属组的用户具有对文件读写的权限，而其他人只有读取文件的权限。\n下面详细的解释一下文件读写执行的权限：\n r (read)：可以读取文件的实际内容，比如读取文本文件内的文字等。 w (write)：可以编辑、增加、删除文件的内容(但不含删除该文件)。 x (execute)：该文件具有可以被系统执行的权限。  可以看出，对于文件来说，rwx 主要针对的是文件的内容。\n对目录而言，目录中存储的主要是目录下文件名称的列表，这与普通文件是有些不同的：\n r (read contents in directory) 表示具有读取目录下文件名称的权限，也就是说你可以通过 ls 命令把目录下的文件列表查询出来。 w (modify contents of directory) 具有 w 权限表明你可以在该目录下执行如下的操作：  创建新的文件和目录 删除已经存在的文件与目录(不论该文件的权限为何!) 重命名已存在的文件或目录 移动该目录内文件、目录的位置   x (access directory) 目录虽然不能被执行，但是却具有可以执行的权限。目录的 x 权限表示用户是否可以进入该目标并成为当前的工作目录。注意，如果用户对目录没有 x 权限，则无法查看该目录下的文件的内容(注意与 r 权限的区别)。  综上，如果要允许目录被其他人浏览时，至少要给予 r 和 x 的权限。\n改变权限 在新建文件时会根据创建者的身份和其它的一些设置为文件生成默认的权限。\n接下来我们介绍如何通过命令修改文件权限相关的信息。\n改变文件所有者\n通过 chown 命令可以改变文件的所有者：\n$ sudo chown tester testfile 改变文件所属的组\n通过 chgrp 命令可以改变文件所属的组：\n$ sudo chgrp tester testfile 改变文件的权限\n通过 chmod 命令可以改变文件的权限。对于文件的 rwx 权限，有两种表示方法，数字表示法和字符表示法。\n以数字表示权限的方式如下：\n r: 4 w: 2 x: 1  如果是 rwx 权限就是 4 + 2 + 1 = 7 ，r-x 就是 4 + 1 = 5 ，— 则为 0。所以 rw-rw-r– 就可以用 664 来表示。如果我们想把文件的权限修改为 rwxrwxrwx，可以使用下面的命令：\n$ chmod 777 testfile 以字符表示权限的方式如下：用字符 u, g, o 分别代表文件所有者(user)、文件所属的组(group)和其他人(other)，这就是 ugo 权限叫法的由来。只不过还有一个 a 可以表示全部的身份(all)。具体更改权限的语法如下：\nchmod [ugoa][+-=][rwx] 文件/目录 比如我们可以通过下面的命令把 testfile 的权限设为 rw-rw-r–：\n$ chmod ug=rw,o=r testfile 如果想去掉组的 w 权限并给其他人添加 x 权限可以执行下面的命令：\n$ chmod g-w,o+x testfile 我们还可通过 a 为全部身份设置权限，比如 rwx：\n$ chmod a=rwx testfile 特殊权限 setuid 和 setgid 分别是 set uid ID upon execution 和 set group ID upon execution 的缩写。我们一般会再次把它们缩写为 suid 和 sgid。它们是控制文件访问的权限标志(flag)，它们分别允许用户以可执行文件的 owner 或 owner group 的权限运行可执行文件。\nSUID 在 Linux 中，所有账号的密码记录在 /etc/shadow 这个文件中，并且只有 root 可以读写入这个文件：\n$ ll /etc/shadow -rw-r----- 1 root shadow 1.5K Feb 25 12:46 /etc/shadow 如果另一个普通账号 tester 需要修改自己的密码，就要访问 /etc/shadow 这个文件。但是明明只有 root 才能访问 /etc/shadow 这个文件，这究竟是如何做到的呢？事实上，tester 用户是可以修改 /etc/shadow 这个文件内的密码的，就是通过 SUID 的功能。让我们看看 passwd 程序文件的权限信息：\n$ ll /usr/bin/passwd -rwsr-xr-x 1 root root 67K Jul 15 2021 /usr/bin/passwd 上图红框中的权限信息有些奇怪，owner 的信息为 rws 而不是 rwx。当 s 出现在文件拥有者的 x 权限上时，就被称为 SETUID BITS 或 SETUID ，其特点如下：\n SUID 权限仅对二进制可执行文件有效 如果执行者对于该二进制可执行文件具有 x 的权限，执行者将具有该文件的所有者的权限 本权限仅在执行该二进制可执行文件的过程中有效  下面我们来看 tester 用户是如何利用 SUID 权限完成密码修改的：\n tester 用户对于 /usr/bin/passwd 这个程序具有执行权限，因此可以执行 passwd 程序 passwd 程序的所有者为 root tester 用户执行 passwd 程序的过程中会暂时获得 root 权限 因此 tester 用户在执行 passwd 程序的过程中可以修改 /etc/shadow 文件  但是如果由 tester 用户执行 cat 命令去读取 /etc/shadow 文件确是不行的：\n$ ll /bin/cat -rwxr-xr-x 1 root root 43K Sep 5 2019 /bin/cat 原因很清楚，tester 用户没有读 /etc/shadow 文件的权限，同时 cat 程序也没有被设置 SUID。我们可以通过下图来理解这两种情况：\nSGID 当 s 标志出现在用户组的 x 权限时称为 SGID。SGID 的特点与 SUID 相同，我们通过 /usr/bin/mlocate 程序来演示其用法。mlocate 程序通过查询数据库文件 /var/lib/mlocate/mlocate.db 实现快速的文件查找。 mlocate 程序的权限如下图所示：\n$ ll /usr/bin/mlocate -rwxr-sr-x 1 root mlocate 39520 Nov 18 2014 /usr/bin/mlocate* 很明显，它被设置了 SGID 权限。下面是数据库文件 /var/lib/mlocate/mlocate.db 的权限信息：\n$ ll /var/lib/mlocate/mlocate.db -rw-r----- 1 root mlocate 12101109 Aug 13 07:35 /var/lib/mlocate/mlocate.db 普通用户 tester 执行 mlocate 命令时，tester 就会获得用户组 mlocate 的执行权限，又由于用户组 mlocate 对 mlocate.db 具有读权限，所以 tester 就可以读取 mlocate.db 了。程序的执行过程如下图所示：\n除二进制程序外，SGID 也可以用在目录上。当一个目录设置了 SGID 权限后，它具有如下功能：\n 用户若对此目录具有 r 和 x 权限，该用户能够进入该目录 用户在此目录下的有效用户组将变成该目录的用户组 若用户在此目录下拥有 w 权限，则用户所创建的新文件的用户组与该目录的用户组相同  SBIT 其实 SBIT 与 SUID 和 SGID 的关系并不大。SBIT 是 the restricted deletion flag or sticky bit 的简称。\nSBIT 目前只对目录有效，用来阻止非文件的所有者删除文件。比较常见的例子就是 /tmp 目录：\n$ ls -ld /tmp drwxrwxrwt 22 root root 4096 Mar 2 20:57 /tmp 权限信息中最后一位 t 表明该目录被设置了 SBIT 权限。SBIT 对目录的作用是：当用户在该目录下创建新文件或目录时，仅有自己和 root 才有权力删除。\n设置权限 以数字的方式设置权限\nSUID、SGID、SBIT 权限对应的数字如下：\nSUID-4 SGID-2 SBIT-1 所以如果要为一个文件权限为 “-rwxr-xr-x” 的文件设置 SUID 权限，需要在原先的 755 前面加上 4，也就是 4755：\n$ chmod 4755 filename 同样，可以用 2 和 1 来设置 SGID 和 SBIT 权限。设置完成后分别会用 s, s, t 代替文件权限中的 x。\n其实，还可能出现 S 和 T 的情况。s 和 t 是替代 x 这个权限的，但是，如果它本身没有 x 这个权限，添加 SUID、SGID、SBIT 权限后就会显示为大写 S 或大写 T。比如我们为一个权限为 666 的文件添加 SUID、SGID、SBIT 权限：\n$ chmod 666 nickfile $ ll nickfile -rw-rw-rw- 1 nick nick 0 Mar 2 21:03 nickfile $ chmod 7666 nickfile $ ll nickfile -rwSrwSrwT 1 nick nick 0 Mar 2 21:03 nickfile 通过符号类型改变权限\n除了使用数字来修改权限，还可以使用符号：\n$ chmod u+s testfile # 为 testfile 文件加上 SUID 权限。 $ chmod g+s testdir # 为 testdir 目录加上 SGID 权限。 $ chmod o+t testdir # 为 testdir 目录加上 SBIT 权限。 umask 默认权限 为了查看用户创建的文件和目录的默认权限，我们用一个普通的用户创建文件 myfile 和目录 mydir 并查看它们的默认权限：\n$ touch myfile $ mkdir mydir $ ll total 4.0K drwxrwxr-x 2 nick nick 4.0K Mar 2 21:09 mydir -rw-rw-r-- 1 nick nick 0 Mar 2 21:09 myfile 目录的权限为 775，文件的权限为 664。默认情况下对于目录来说最大的权限是 777，对于文件来说最大的权限一般为 666(只有可以执行的文件才添加可执行权限)。所以我们创建的文件和目录的共同特点是从最大权限中减其他用户的写权限。而这个被减去的值就是我们常说的 umask。umask 还是 bash 的一个内置命令，默认输出当前用户的 umask 值：\n$ umask 002 注意，umask 显示的值为从默认的最大权限中减去的值。\n默认策略 系统在用户登录时通过 login 程序调用 pam_umask 模块设置用户默认的 umask。从 login 程序的配置文件 /etc/login.defs 中我们可以找到 umask 相关的配置：\n... UMASK 022 ... USERGROUPS_ENAB yes ... 用户的默认 umask 应该是 022，但当 USERGROUPS_ENAB 被设置为 yes 时(默认值)，对于 uid 和 gid 相同且用户名和主组名相同的用户，系统会把其 umask 改为 002。\n于 root 用户的特殊性，它默认的 umask 与其它用户是不同的，其值为 022：\n# umask 0022 第一个 0 表示 8 进制，这里我们可以暂时忽略它。\n命令 umask 是 bash 的一个内置命令，用来显示或设置新建文件/目录的权限掩码(umask)。前面我们以数字的方式输出了用户默认的 umask 值，这次我们以符号的方式进行输出：\n$ umask -S u=rwx,g=rwx,o=rx 以符号输出的就是用户创建目录时的默认权限，也就是 775。\n为了改变用户创建的文件/目录的默认值，我们可以改变 umask 的默认值。\n设置 umask 值\n最简单的方式就是为 umask 命令指定一个数字：\n$ umask 026 026 的含义为：去掉 group 中的写权限，去掉 other 中的读写权限。\n这时创建的文件权限为 640，目录权限为 751。注意，修改 umask 后只有新建的文件和目录受影响，已经存在的文件和目录的权限不会被影响。\n以符号的方式设置 umask 值\n比如下面的命令：\n$ umask u=,g=w,o=rwx 上面的命令表示从 group 中去掉写权限，从 other 中去掉读写执行的权限。\n注意：\"=\" 号在 umask 命令和 chmod 命令中的作用恰恰相反。在 chmod 命令中，利用它来设置指定的权限，而其余权限则被删除。但是在 umask 命令中，将在原有权限的基础上删除指定的权限。\n在 ~/.bashrc 文件中为用户设置默认的 umask\n如果让用户每次登陆后都执行 umask 命令修改默认的 umask 值是不科学的，我们可以在用户的 ~/.bashrc 文件中执行 umask 命令，这样用户登录后 umask 的值自动就变成了设置的值。把下面的命令添加到 ~/.bashrc 文件的最后一行：\numask 026 与 ACL 如果一个目录没有被设置 default ACL，那么将由 umask 决定新文件的 ACL 权限。这种情况其实就是我们常见的没有 ACL 权限时的情况。比如我们设置 umask 为 026，那么创建的文件和目录的权限就是由它决定的。\n如果一个目录被设置了 default ACL，那么将会由文件创建函数的 mode 参数和目录的 default ACL 共通决定新文件的 ACL 权限，此时 umask 被忽略。还以 umask 026 为例，我们创建一个目录 dir2 并设置 default ACL 权限：\n$ setfacl -m d:u:tester:rwx dir2 $ getfacl dir2 # file: dir2 # owner: nick # group: nick user::rwx group::r-x other::--x default:user::rwx default:user:tester:rwx default:group::rwx default😷:rwx default:other::r-x 然后在 dir2 目录中创建文件 testfile：\n$ dir2 touch testfile $ dir2 ll testfile -rw-rw-r--+ 1 nick nick 0 Mar 2 21:26 testfile 这次 testfile 的权限已经不受 umask 的影响了！\nACL ACL的全称是 Access Control List (访问控制列表) ，一个针对文件/目录的访问控制列表。它在UGO权限管理的基础上为文件系统提供一个额外的、更灵活的权限管理机制。它被设计为UNIX文件权限管理的一个补充。ACL允许你给任何特定的用户或用户组设置任何文件/目录的访问权限。\nACL需要Linux内核和文件系统的配合才能工作，大多数Linux发行版本默认都是支持的。但最好还是能够先检查一下：\n$ sudo tune2fs -l /dev/sda1 | grep \"Default mount options:\" Default mount options: user_xattr acl 设置权限 可以使用setfacl和getfacl命令来设置或观察文件/目录的acl权限。\n当前用户是 nick，再创建两个用户 tester 和 tester1 用来进行测试：\n$ sudo adduser tester 创建文件 aclfile，检查其默认的权限信息：\n$ touch aclfile $ ll aclfile -rw-rw-r-- 1 nick nick 0 Mar 2 21:40 aclfile $ getfacl aclfile # file: aclfile # owner: nick # group: nick user::rw- group::rw- other::r-- 把用户切换为 tester，发现没有写文件的权限：\n$ echo \"hello\"  aclfile bash: aclfile: Permission denied 这是因为 other 没有写 aclfile 文件的权限。\n下面我们为 tester 用户赋予读写 aclfile 文件的权限：\n$ setfacl -m u:tester:rw aclfile 修改成功后再次以 tester 用户的身份向 aclfile 文件写入数据，这次已经可以正常写入了。查看 aclfile 文件的权限：\n$ getfacl aclfile # file: aclfile # owner: nick # group: nick user::rw- user:tester:rw- group::rw- mask::rw- other::r-- 多出了一些信息，其中比较重要的是 user:tester:rw-，就是它让用户 tester 具有了读写 aclfile 的权限。\n针对用户组来设置权限和针对用户的设置几乎一样，只是把小写的 u 换成小写的 g 就行了。\n继承权限 acl 能让创建的子文件或者子文件夹继承父文件夹的权限设置！\n$ mkdir mydir $ ll -d mydir drwxrwxr-x 2 nick nick 4.0K Mar 2 21:09 mydir $ setfacl -m d:u:tester:rwx mydir $ getfacl mydir # file: mydir # owner: nick # group: nick user::rwx group::rwx other::r-x default:user::rwx default:user:tester:rwx default:group::rwx default😷:rwx default:other::r-x 这次多出了一些以 default 开头的行，这些 default 权限信息只能在目录上设置，然后会被目录中创建的文件和目录继承。下面分别在 mydir 目录下创建文件 testfile 和目录 testdir，并查看它们的 acl 权限：\n$ touch testfile $ mkdir testdir $ getfacl testfile # file: testfile # owner: nick # group: nick user::rw- user:tester:rwx group::rwx mask::rw- other::r-- 从上面可以看到文件 testfile 继承了父目录的 acl 权限，因此用户 tester 对它有读写权限。下面再看看 testdir 目录：\n$ getfacl testdir # file: testdir # owner: nick # group: nick user::rwx user:nick:rwx group::rwx mask::rwx other::r-x default:user::rwx default:user:tester:rwx default:group::rwx default😷:rwx default:other::r-x 从图中可以看出，testdir 目录不仅继承了 tester 的访问权限，还继承了父目录上的 default 权限。也就是说我们通过这种方式设置在目录上的权限可以被子目录递归的继承下去。\n操作权限 更改 -m 选项其实是在更改文件和目录的 ACL 权限\n 当一个用户或组的 ACL 权限不存在时，-m 选项执行的是添加操作， 如果一个用户或组的 ACL 权限已经存在时，-m 选项执行的是更新操作。  $ setfacl -m u:tester:rwx aclfile $ setfacl -m u:tester:rw aclfile -set 选项会先清除掉原有的 ACL 权限，然后添加新的权限\n$ setfacl --set u::rw,u:tester:rwx,g::r,o::- aclfile $ getfacl aclfile # file: aclfile # owner: nick # group: nick user::rw- user:tester:rwx group::r-- mask::rwx other::--- 需要注意的是一定要包含 UGO 权限的设置，不能象 -m 一样只包含 ACL 权限。o::- 是另一个需要注意的地方，其完整的写法是 other::-，就像 u::rw 的完整写法是 user::rw- 一样。通常我们可以把 “-” 省略，但是当权限位只包含 “-” 时，就至少要保留一个。如果写成了o::，就会报错。\n删除 通过 setfacl 命令的 -x 选项来删除指定用户或组的 ACL 权限，还可以通过 -b 选项来清除文件和目录上所有的 ACL 权限。\n下面通过 -x 选项删除 user tester 的 ACL 权限，注意命令中只指定了用户的名称而没有指定权限信息：\n$ getfacl aclfile # file: aclfile # owner: nick # group: nick user::rw- user:tester:rwx group::rw- mask::rwx other::r-- $ setfacl -x u:tester aclfile $ getfacl aclfile # file: aclfile # owner: nick # group: nick user::rw- group::rw- mask::rw- other::r-- 下面通过 -b 选项一次性删除 aclfile 上所有的 ACL 权限：\n$ setfacl -b aclfile getfacl aclfile # file: aclfile # owner: nick # group: nick user::rw- group::rw- other::r-- 备份和恢复 常见的文件操作命令 cp 和 mv 等都支持 ACL 权限，只是 cp 命令需要加上 -p 参数。但是 tar 等常见的备份工具不会保留目录和文件的 ACL 权限信息。如果希望备份和恢复带有 ACL 权限的文件和目录，可以先把 ACL 权限信息备份到一个文件里，然后再用 -restore 选项来恢复这些信息。\n使用下面的命令导出 acldir 目录的 ACL 权限信息并保存到文件 acldir.acl 文件中：\n$ getfacl -R acldir  acldir.acl 通过下面的命令把它们的 ACL 权限都恢复回来：\n$ setfacl --restore acldir.acl 实现原理 ACL 条目\n进程权限 ugo 权限信息是文件的属性，它指明了用户与文件之间的关系。但是真正操作文件的却是进程，也就是说用户所拥有的文件访问权限是通过进程来体现的。\n概念：\n  用户 对于支持多任务的 Linux 系统来说，用户就是获取资源的凭证。\n  权限 权限用来控制用户对计算机资源(CPU、内存、文件等)的访问，一般会分为认证和授权两步。比如用户先经过认证机制(authentication)登录系统，然后由授权系统(authorization)对用户的操作进行授权。\n  进程 进程是任何支持多道程序设计的操作系统中的基本概念。通常把进程定义为程序执行时的一个实例。因此，如果有 10 个用户同时运行 vi，就会有 10 个独立的进程(尽管它们共享同一份可执行代码)。\n实际上，是进程在帮助我们完成各种任务。进程就是用户访问计算机资源的代理，用户执行的操作其实是带有用户身份信息的进程执行的操作。\n  进程权限 既然是进程在为用户执行具体的操作，那么当用户要访问系统的资源时就必须给进程赋予权限。也就是说进程必须携带发起这个进程的用户的身份信息才能够进行合法的操作。\n  登陆过程 在 Linux 系统启动后，init 系统会 fork 出子进程执行 /sbin/getty 程序等待用户登录。当用户进行登录操作时，该子进程通过 exec 函数开始执行 /bin/login 程序(此时该进程已经变成了 login 进程)。由 login 进程验证我们的用户名和密码并查询 /etc/passwd 和 /etc/shadow 确定其合法性。如果是合法的用户，该进程再次通过 exec 函数执行用户的默认 shell 程序，此时的 login 进程就变成了 shell 进程(笔者机器上是 bash 进程)。并且**该 shell 进程的有效身份被设置成为该用户的身份，之后 fork 此 shell 进程的子进程都会继承该有效身份。**我们可以通过下图来理解用户从 tty 登录系统的过程：\n简单点说就是：用户登录后， shell 进程的有效用户就是该用户。\nuser id 通过 cat /proc//status 命令，我们可以查看到进程所属的用户和组相关的信息：\nUid:\t1000\t1000\t1000\t1000 Gid:\t1000\t1000\t1000\t1000 通过 man proc 可以查询到第一行的四个数字分别是 real user id, effective user id, saved set user id 和 filesystem UID，第二行则是对应的组 ID。\nreal user id\nreal user id 是执行进程者的 user id，一般情况下就是用户登录时的 user id。子进程的 real user id 从父进继承。通常这个是不更改的，也不需要更改。比如我以用户 nick 登录 Linux 系统，我接下来运行的所有命令的进程的 real user id 都是 nick 的 user id。\neffective user id\n如果要判断一个进程是否对某个文件有操作权限，验证的是进程的 effective user id，而不是 real user id。\n通常不建议直接使用 root 用户进行操作的，但是在很多情况下，程序可能需要特殊的权限。比如 passwd 程序需要 root 权限才能够为普通用户修改密码，一些 services 程序的操作也经常需要特殊的权限。为此，Linux 中设计了一些特殊的权限（SUID/SGID/SBIT）。这里我们以 passwd 程序为例，为二进制可执行文件 /usr/bin/passwd 设置 set-user-id bit=ON，这个可执行文件被用 exec 启动之后的进程的 effective user id 就是这个可执行文件的 owner id，而并非父进程的 real user id。如果 set-user-id bit=OFF 的时候，这个被 exec 起来的进程的 effective user id 应该是等于进程的 user id 的。\n其实我们通过 ps aux 查看的结果中，第一列显示的就是进程的 effective user。\nsaved set user id\nsaved set user id 相当于是一个 buffer，在 exec 函数启动之后，它会拷贝 effective user id 位的信息覆盖自己。\n对于非 root 用户来说，可以在未来使用 setuid() 函数将 effective user id 设置成为 real user id 或 saved set user id 中的任何一个。但是不允许非 root 用户用 setuid() 函数把 effective user id 设置成为任何第三个 user id。\n对于 root 用户来说，调用 setuid() 的时候，将会设置所有的这三个 user id。\n外部命令 在 shell 中执行的命令分为内部命令和外部命令两种。\n 内部命令：内建的，相当于 shell 的子函数 外部命令：在文件系统的某个路径下的一个可执行文件  外部命令的执行过程如下：\n Shell 通过 fork() 函数建立一个新的子进程，新的子进程为当前 shell 进程的一个副本。 在新的进程里，从 PATH 变量所列出的目录中寻找指定的命令程序。当命令名称包含有斜杠(/)符号时，将略过路径查找步骤。 在新的进程里，通过 exec 系列函数，以所找到的新程序替换 shell 程序并执行。 子进程退出后，最初的 shell 会接着从终端读取并执行下一条命令。  我们通过下面的例子来理解在 shell 中执行外部命令的过程，例子很简单就是通过 cat 命令查看一个文本文件 test.log：\n$ cat test.log 我们先来检查一下当前用户以及相关文件的权限：\n$ uid=1000(nick) gid=1000(nick) groups=1000(nick),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),120(lpadmin),132(lxd),133(sambashare) $ ll /bin/cat -rwxr-xr-x 1 root root 43K Sep 5 2019 /bin/cat $ ll test.log -rw-rw-r-- 1 nick nick 0 Mar 2 23:25 test.log 当前用户 nick 的 real user id 为 1000，/bin/cat 文件的所有者为 root，但是所有人都有执行权限，test.log 文件的所有者为 nick。我们结合下图来介绍 cat test.log 命令的执行过程：\n当我们在 shell 中执行一个外部程序的时候，默认情况下进程的 effective user ID 等于 real user ID，进程的 effective group ID 等于 real group ID(接下来的介绍中省略 group ID)。当我们以用户 nick 登录系统，并在 bash 中键入 cat test.log 命令并回车后。Bash 先通过 fork() 建立一个新的子进程，这个新的子进程是当前 bash 进程的一个副本。新的进程在 PATH 变量指定的路径中搜索 cat 程序，找到 /bin/cat 程序后检查其权限。/bin/cat 程序的所有者为 root，但是其他人具有读和执行的权限，所以新进程可以通过 exec 函数用 cat 程序的代码段替换当前进程中的代码段(把 /bin/cat 程序加载到了内存中，此时的进程已经变成了 cat 进程，cat 进程会从 _start 函数开始执行)。由于 cat 进程是由用户 nick 启动的，所以 cat 进程的 effective user ID 是 1000(nick)。同时 cat 进程的 effective user ID 和 test.log 文件的 owner ID 相同(都是 1000)，所以 cat 进程拥有对此文件的 rw- 权限，那么顺理成章地就可以读写 test.log 文件的内容了。\n脚本 在 shell 中执行脚本的方式和执行外部命令的方式差不多，比如我们要执行下面的脚本：\n$ /bin/bash ./test.sh 这时同样会 fork 出一个子进程。只不过脚本与程序相比没有代码段，也没有 _start 函数，此时 exec 函数就会执行另外一套机制。比如我们在 test.sh 文件的第一行通过 #!/bin/bash 指定了一个解释器，那么解释器程序的代码段会用来替换当前进程的代码段，并且从解释器的 _start 函数开始执行，而这个文本文件被当作命令行参数传给解释器。所以上面的命令执行过程为：Bash 进程 fork/exec 一个子 bash 进程用于执行脚本，子 bash 进程继承父进程的环境变量、用户信息等内容，父进程等待子 bash 进程终止。\n 权限 cgroub sudo fdisk 自动更新 LVM 进程  Capabilities 为了执行权限检查，Linux 区分两类进程：特权进程(其有效用户标识为 0，也就是超级用户 root)和非特权进程(其有效用户标识为非零)。 特权进程绕过所有内核权限检查，而非特权进程则根据进程凭证(通常为有效 UID，有效 GID 和补充组列表)进行完全权限检查。\n以常用的 passwd 命令为例，修改用户密码需要具有 root 权限，而普通用户是没有这个权限的。但是实际上普通用户又可以修改自己的密码，这是怎么回事？在 Linux 的权限控制机制中，有一类比较特殊的权限设置，比如 SUID(Set User ID on execution)。因为程序文件 /bin/passwd 被设置了 SUID 标识，所以普通用户在执行 passwd 命令时，进程是以 passwd 的所有者，也就是 root 用户的身份运行，从而修改密码。\nSUID 虽然可以解决问题，却带来了安全隐患。当运行设置了 SUID 的命令时，通常只是需要很小一部分的特权，但是 SUID 给了它 root 具有的全部权限。因此一旦 被设置了 SUID 的命令出现漏洞，就很容易被利用。也就是说 SUID 机制在增大了系统的安全攻击面。\nLinux 引入了 capabilities 机制对 root 权限进行细粒度的控制，实现按需授权，从而减小系统的安全攻击面。\n简介 从内核 2.2 开始，Linux 将传统上与超级用户 root 关联的特权划分为不同的单元，称为 capabilites。Capabilites 作为线程(Linux 并不真正区分进程和线程)的属性存在，每个单元可以独立启用和禁用。如此一来，权限检查的过程就变成了：在执行特权操作时，如果进程的有效身份不是 root，就去检查是否具有该特权操作所对应的 capabilites，并以此决定是否可以进行该特权操作。比如要向进程发送信号(kill())，就得具有 capability CAP_KILL；如果设置系统时间，就得具有 capability CAP_SYS_TIME。\n下面是从 capabilities man page 中摘取的 capabilites 列表：\n   capability 名称 描述     CAP_AUDIT_CONTROL 启用和禁用内核审计；改变审计过滤规则；检索审计状态和过滤规则   CAP_AUDIT_READ 允许通过 multicast netlink 套接字读取审计日志   CAP_AUDIT_WRITE 将记录写入内核审计日志   CAP_BLOCK_SUSPEND 使用可以阻止系统挂起的特性   CAP_CHOWN 修改文件所有者的权限   CAP_DAC_OVERRIDE 忽略文件的 DAC 访问限制   CAP_DAC_READ_SEARCH 忽略文件读及目录搜索的 DAC 访问限制   CAP_FOWNER 忽略文件属主 ID 必须和进程用户 ID 相匹配的限制   CAP_FSETID 允许设置文件的 setuid 位   CAP_IPC_LOCK 允许锁定共享内存片段   CAP_IPC_OWNER 忽略 IPC 所有权检查   CAP_KILL 允许对不属于自己的进程发送信号   CAP_LEASE 允许修改文件锁的 FL_LEASE 标志   CAP_LINUX_IMMUTABLE 允许修改文件的 IMMUTABLE 和 APPEND 属性标志   CAP_MAC_ADMIN 允许 MAC 配置或状态更改   CAP_MAC_OVERRIDE 覆盖 MAC(Mandatory Access Control)   CAP_MKNOD 允许使用 mknod() 系统调用   CAP_NET_ADMIN 允许执行网络管理任务   CAP_NET_BIND_SERVICE 允许绑定到小于 1024 的端口   CAP_NET_BROADCAST 允许网络广播和多播访问   CAP_NET_RAW 允许使用原始套接字   CAP_SETGID 允许改变进程的 GID   CAP_SETFCAP 允许为文件设置任意的 capabilities   CAP_SETPCAP 参考 capabilities man page   CAP_SETUID 允许改变进程的 UID   CAP_SYS_ADMIN 允许执行系统管理任务，如加载或卸载文件系统、设置磁盘配额等   CAP_SYS_BOOT 允许重新启动系统   CAP_SYS_CHROOT 允许使用 chroot() 系统调用   CAP_SYS_MODULE 允许插入和删除内核模块   CAP_SYS_NICE 允许提升优先级及设置其他进程的优先级   CAP_SYS_PACCT 允许执行进程的 BSD 式审计   CAP_SYS_PTRACE 允许跟踪任何进程   CAP_SYS_RAWIO 允许直接访问 /devport、/dev/mem、/dev/kmem 及原始块设备   CAP_SYS_RESOURCE 忽略资源限制   CAP_SYS_TIME 允许改变系统时钟   CAP_SYS_TTY_CONFIG 允许配置 TTY 设备   CAP_SYSLOG 允许使用 syslog() 系统调用   CAP_WAKE_ALARM 允许触发一些能唤醒系统的东西(比如 CLOCK_BOOTTIME_ALARM 计时器)    程序文件的 capabilities\n在可执行文件的属性中有三个集合来保存三类 capabilities，它们分别是：\n Permitted Inheritable Effective  在进程执行时，Permitted 集合中的 capabilites 自动被加入到进程的 Permitted 集合中。\nInheritable 集合中的 capabilites 会与进程的 Inheritable 集合执行逻辑与操作，以确定进程在执行 execve 函数后哪些 capabilites 被继承。\nEffective 只是一个 bit。如果设置为开启，那么在执行 execve 函数后，Permitted 集合中新增的 capabilities 会自动出现在进程的 Effective 集合中。\n进程的 capabilities\n进程中有五种 capabilities 集合类型，分别是：\n Permitted Inheritable Effective Bounding Ambient  相比文件的 capabilites，进程的 capabilities 多了两个集合，分别是 Bounding 和 Ambient。\n/proc/[pid]/status 文件中包含了进程的五个 capabilities 集合的信息，我们可以通过下面的命名查看当前进程的 capabilities 信息：\n$ cat /proc/$$/status | grep 'Cap' CapInh:\t0000000000000000 CapPrm:\t0000000000000000 CapEff:\t0000000000000000 CapBnd:\t000003ffffffffff CapAmb:\t0000000000000000 但是这中方式获得的信息无法阅读，我们需要使用 capsh 命令把它们转义为可读的格式：\n$ capsh --decode=0000003fffffffff 使用 getcap 命令和 setcap 命令分别用来查看和设置程序文件的 capabilities 属性。下面我们演示如何使用 capabilities 代替 ping 命令的 SUID。\n因为 ping 命令在执行时需要访问网络，这就需要获得 root 权限，常规的做法是通过 SUID 实现的(和 passwd 命令相同)：\n$ ll /bin/ping -rwsr-xr-x 1 root root 72K Jan 31 2020 /bin/ping $ ll /usr/bin/passwd -rwsr-xr-x 1 root root 67K Jul 15 2021 /usr/bin/passwd 红框中的 s 说明应用程序文件被设置了 SUID，这样普通用户就可以执行这些命令了。\n移除 ping 命令文件上的 SUID 权限：\n$ sudo chmod 755 /bin/ping $ ping baidu.com ping: socket: Operation not permitted 在移除 SUID 权限后，普通用户在执行 ping 命令时碰到了 “ping: socket: Operation not permitted” 错误。\n为 ping 命令文件添加 capabilities\n执行 ping 命令所需的 capabilities 为 cap_net_admin 和 cap_net_raw，通过 setcap 命令可以添加它们：\n$ sudo setcap cap_net_admin,cap_net_raw+ep /bin/ping $ getcap /bin/ping /bin/ping = cap_net_admin,cap_net_raw+ep $ ping baidu.com PING baidu.com (220.181.38.148) 56(84) bytes of data. 64 bytes from 220.181.38.148 (220.181.38.148): icmp_seq=1 ttl=46 time=33.3 ms 64 bytes from 220.181.38.148 (220.181.38.148): icmp_seq=2 ttl=46 time=40.9 ms 被赋予合适的 capabilities 后，ping 命令又可以正常工作了，相比 SUID 它只具有必要的特权，在最大程度上减小了系统的安全攻击面。\n如果要移除刚才添加的 capabilities，执行下面的命令：\n$ sudo setcap cap_net_admin,cap_net_raw-ep /bin/ping $ getcap /bin/ping /bin/ping = 命令中的 ep 分别表示 Effective 和 Permitted 集合，+ 号表示把指定的 capabilities 添加到这些集合中，- 号表示从集合中移除(对于 Effective 来说是设置或者清除位)。\n进程 job control 进程组 执行一个命令会创建一个或多个进程，这些进程被称为一个进程组(process group)。进程组中包含一个或多个进程，每个进程都会属于一个进程组，进程组也叫 job。\n每个进程组都有一个领头进程(process group leader)，领头进程的 PID 就是进程组的 ID(process group ID，PGID)，我们可以通过 ps 命令查看进程的 PGID：\n$ ps -o pid,ppid,pgid,comm | cat PID PPID PGID COMMAND 2646 2638 2646 zsh 16823 2646 16823 ps 16824 2646 16823 cat 16823 16824 两个进程属于同一进程组(通过管道符连接的进程属于相同的进程组)。这个进程组中的领头进程为 16823，因此它的 PID 成了进程组的 PGID。\n领头进程可以先退出，这时进程组依然存在并且 PGID 也不会发生变化。在进程组中的所有进程都退出后，进程组的生命周期结束。\n将进程划分到进程组中的主要原因是可以对它们进行统一的管理，说白了就是同时发信号给组内的所有进程，这就是我们接下来要介绍的 job 管理。\n管理 jobs 命令\n使用 vim 打开文件 test.txt，然后按下 ctrl + z，此时 vim 进入了后台：\n$ vim test.txt [1]+ Stopped vim test.txt 输出的第一列方括号中的数字表示 jobID，第二列 Stopped 表示 job 当前的状态，第三列则表示该 job 执行的命令。 使用 jobs 命令可以查看当前会话中的的所有 jobs，此时执行 jobs 命令，输出的结果和上面一样：\n$ jobs [1]+ Stopped vim test.txt \u0026 符\n在命令的后面加上 \u0026 符号，可以直接让 job 运行在后台：\n$ sleep 1000 \u0026 [2] 26524 $ jobs [1]+ Stopped vim test.txt [2]- Running sleep 1000 \u0026 sleep 命令的 jobID 为 2，状态为 Running。\nfg 命令\nfg 命令是 foreground 的缩写。命令格式为 fg %n，它把当前或指定 ID 的 job 放到前台。下面我们操作一次 job 2：\n$ fg %2 sleep 1000 此时 sleep 命令运行在前台，通过 ctrl + z 我们可以再次把它送回后台：\n$ fg %2 sleep 1000 ^Z [2]+ Stopped sleep 1000 请注意此时 sleep 命令的状态已经变成了 Stopped。\nctrl + z\n严格来说 ctrl + z 并不是一个 job 管理命令，它只是向当前进程发送一个 SIGSTOP 信号，该信号使进程进入暂停(stopped)状态，也就是挂起进程，此状态下，进程状态会被系统保存，此进程会被放置到作业队列中去，从而让出终端。使用 ctrl + z 我们可以暂停正在占用终端的进程而不结束它，然后我们可以使用终端命令来操作此进程。\nbg 命令\nbg 命令是 background 的缩写，命令格式为 bg %n，bg 命令和 ctrl + z 配合可以把前台命令切换到后台去执行。比如刚才我们通过 ctrl + z 把 sleep 命令切到了后台，但变成了 Stopped 状态，此时执行 bg %2 命令可以让 sleep 命令继续在后台执行：\n$ bg %2 [2]+ sleep 1000 \u0026 $ jobs [1]+ Stopped vim test.txt [2]- Running sleep 1000 \u0026 kill 命令\nkill 命令负责向进程发送信号，当然它也可以向 job 发送信号，在 jobID 前面添加 % 就可以了。比如 SIGCONT 是唤醒一个挂起的进程，所以我们也可以使用下面的命令把处于 Stooped 状态的 sleep 命令唤醒：\n$ jobs [1]+ Stopped sleep 1000 $ kill -SIGCONT %1 $ jobs [1]+ Running sleep 1000 \u0026 杀死进程\n有时候使用 ctrl + c 无法杀死一个正在运行的前台进程，这是因为 ctrl + c 的本质是向进程发送 SIGINT 信号。SIGINT 是用来终止进程的，但是这是一个可以被忽略的信号，如果程序忽略了它，我们就无法通过 ctrl + c 来终止该进程。\n此时我们可以先使用 ctrl + z 把进程切换到后台，然后使用 kill %n(n 为进程的 jobID)来终止进程。kill 命令默认向进程发送 SIGTERM 信号，程序一般会在 SIGTERM 信号的处理函数中正常地终止程序并执行资源清理工作。既然 SIGTERM 信号能够被程序处理，那么它也能够被忽略，所以也无法通过这种方式结束那些顽固的进程。\n杀死进程的终极手段是 kill -SIGKILL PID(kill -9 PID)。SIGKILL 信号是不能被忽略的，所以这一招肯定管用。但是由于它过于强硬，使用这种方式杀死进程后往往会有后遗症，比如进程使用的资源没有在退出前清理干净，常见的例子是用这种方法杀死 vim 进程后会遗留下 .swp 文件。\n暂停 tail 命令的输出\n我们一般会使用 tail -f 命令查看实时的日志，但很多程序产生日志的速度非常快以至于我们跟不上节奏。此时使用 ctrl + s 命令可以暂停日志输出到终端，这样我们就可以仔细的分析当前终端中显示的日志。如果要接着输出日志，可以使用 ctrl + q 命令恢复日志的输出。\n这两个命令的原理是：ctrl + s 会告诉终端暂停，阻塞所有读写操作，即不转发任何数据，只有按了 ctrl + q 后，才会继续。这个功能应该是历史遗留的产物，以前终端和服务器之间没有流量控制功能，所以有可能服务器发送数据过快，导致终端处理不过来，于是需要这样一个命令告诉服务器不要再发了，等终端处理完了后再通知服务器继续。\nsession Linux session 一般是指 shell session。Shell session 是终端中当前的状态，在终端中只能有一个 session。当我们打开一个新的终端时，总会创建一个新的 shell session。\n就进程间的关系来说，session 由一个或多个进程组组成。一般情况下，来自单个登录的所有进程都属于同一个 session。我们可以通过下图来理解进程、进程组和 session 之间的关系：\n会话是由会话中的第一个进程创建的，一般情况下是打开终端时创建的 shell 进程。该进程也叫 session 的领头进程。Session 中领头进程的 PID 也就是 session 的 SID。我们可以通过下面的命令查看 SID：\n$ ps -o pid,ppid,pgid,sid,tty,comm PID PPID PGID SID TT COMMAND 14244 29789 14244 29789 pts/2 ps Session 中的每个进程组被称为一个 job，有一个 job 会成为 session 的前台 job(foreground)，其它的 job 则是后台 job(background)。每个 session 连接一个控制终端(control terminal)，控制终端中的输入被发送给前台 job，从前台 job 产生的输出也被发送到控制终端上。同时由控制终端产生的信号，比如 ctrl + z 等都会传递给前台 job。\n一般情况下 session 和终端是一对一的关系，当我们打开多个终端窗口时，实际上就创建了多个 session。\nSession 的意义在于多个工作(job)在一个终端中运行，其中的一个为前台 job，它直接接收该终端的输入并把结果输出到该终端。其它的 job 则在后台运行。\n诞生与消亡 通常，新的 session 由系统登录程序创建，session 中的领头进程是运行用户登录 shell 的进程。新创建的每个进程都会属于一个进程组，当创建一个进程时，它和父进程在同一个进程组、session 中。\n将进程放入不同 session 的惟一方法是使用 setsid 函数使其成为新 session 的领头进程。这还会将 session 领头进程放入一个新的进程组中。\n当 session 中的所有进程都结束时 session 也就消亡了。实际使用中比如网络断开了，session 肯定是要消亡的。另外就是正常的消亡，比如让 session 的领头进程退出。一般情况下 session 的领头进程是 shell 进程，如果它处于前台，我们可以使用 exit 命令或者是 ctrl + d 让它退出。或者我们可以直接通过 kill 命令杀死 session 的领头进程。这里面的原理是：当系统检测到挂断(hangup)条件时，内核中的驱动会将 SIGHUP 信号发送到整个 session。通常情况下，这会杀死 session 中的所有进程。\nsession 与终端的关系\n如果 session 关联的是伪终端，这个伪终端本身就是随着 session 的建立而创建的，session 结束，那么这个伪终端也会被销毁。\n如果 session 关联的是 tty1-6，tty 则不会被销毁。因为该终端设备是在系统初始化的时候创建的，并不是依赖该会话建立的，所以当 session 退出，tty 仍然存在。只是 init 系统在 session 结束后，会重启 getty 来监听这个 tty。\nnohup 如果我们在 session 中执行了 nohup 等类似的命令，当 session 消亡时，相关的进程并不会随着 session 结束，原因是这些进程不再受 SIGHUP 信号的影响。比如我们执行下面的命令：\n$ nohup sleep 1000 /dev/null 2\u00261 \u0026 $ ps -o pid,ppid,pgid,sid,tty,comm PID PPID PGID SID TT COMMAND 7837 7836 7837 7837 pts/0 zsh 7848 7837 7848 7837 pts/0 sleep 7858 7837 7858 7837 pts/0 ps 此时 sleep 进程的 sid 和其它进程是相同的，还可以通过 pstree 命令看到进程间的父子关系。\n$ pstree 如果我们退出当前 session 的领头进程(bash)，sleep 进程并不会退出，这样我们就可以放心的等待该进程运行结果了。\nnohup 并不改变进程的 sid，同时也说明在这种情况中，虽然 session 的领头进程退出了，但是 session 依然没有被销毁(至少 sid 还在被引用)。重新建立连接，通过下面的命令查看 sleep 进程的信息，发现进程的 sid 依然是 7837：\n$ ps -o pid,ppid,pgid,sid,tty,comm PID PPID PGID SID TT COMMAND 7848 1 7848 7837 ? sleep 但是此时的 sleep 已经被系统的 1 号进程 systemd 收养了。\nsetsid setsid 会创建一个新的 session，它的目的是让进程在后台执行命令，实现方式就是让命令进程运行在一个新的与终端脱离的 session 中。看下面的示例：\n$ setsid sleep 1000 查找之下居然没有发现 sleep 进程的踪迹：\n$ ps -o pid,ppid,pgid,sid,tty,comm PID PPID PGID SID TT COMMAND 11162 11161 11162 11162 pts/1 bash 11451 11162 11451 11162 pts/1 ps 通过 grep 查询 sleep 进程的 PID：\n$ ps aux | grep sleep nick 11384 0.0 0.0 6176 840 ? Ss 09:00 0:00 sleep 1000 去查看 sleep 进程所在的 sid，发现是一个新的 session ID，并且没有关联终端：\n$ ps -o pid,ppid,pgid,sid,tty,comm -p 11384 PID PPID PGID SID TT COMMAND 11384 1 11384 11384 ? sleep 当一个进程通过调用 setsid 成为一个新的 session 领头进程时，它会与控制终端断开连接。\n此时通过 pstree 查看进程间的关系，发现 sleep 进程直接被系统的 1 号进程 systemd 收养了。\n控制终端 **控制终端是进程的一个属性。**通过 fork 系统调用创建的子进程会从父进程那里继承控制终端。这样，session 中的所有进程都从 session 领头进程那里继承控制终端。Session 的领头进程称为终端的控制进程(controlling process)。简单点说就是：**一个 session 只能与一个终端关联，这个终端被称为 session 的控制终端(controlling terminal)。**同时只能由 session 的领头进程来建立或者改变终端与 session 的联系。我们可以通过 ps 命令查看进程的控制终端( pts/0 )：\n$ ps -o pid,ppid,pgid,sid,tty,comm PID PPID PGID SID TT COMMAND 17540 17539 17540 17540 pts/0 bash 17550 17540 17540 17540 pts/0 ps 支持 job control 的 shell 必须能够控制在某一时刻由哪个 job 使用终端。否则，可能会有多个 job 试图同时从终端读取数据，这会导致进程在接收用户输入时的混乱。为了防止这种情况发生，shell 必须按照预定的协议与终端驱动程序协作。\nshell 一次只允许一个 job(进程组)访问控制终端。来自控制终端的某些输入会导致信号被发送到与控制终端关联的 job(进程组)中的所有进程。该 job 被称为控制终端上的前台 job。由 shell 管理的其他 job 在不访问终端的情况下，被称为后台 job。\nShell 的职责是通知 job 何时停止何时启动，还要把 job 的信息通知给用户，并提供机制允许用户继续暂停的 job、在前台和后台之间切换 job。比如前台 job 可以无限制的自由使用控制终端，而后台 job 则不可以。当后台 job 中的进程试图从其控制终端读取数据时，通常会向进程组发送 SIGTTIN 信号。这通常会导致该组中的所有进程停止(变成 stopped 状态)。类似地，当后台 job 中的进程试图写入其控制终端时，默认行为是向进程组发送 SIGTTOU 信号，但是否允许写入的控制会更加的复杂。\nTIPS BackupYourSystem Rsync 目的在于恢复系统出现的错误，类似于虚拟机的快照。\n备份\n#!/bin/bash  set -o errexit set -o nounset set -o pipefail readonly SOURCE_DIR=/ readonly BACKUP_DIR=/home/kurome/DataBackup readonly DATETIME=\"$(date '+%Y-%m-%d_%H:%M:%S')\" readonly BACKUP_PATH=\"${BACKUP_DIR}/${DATETIME}\" readonly LATEST_LINK=\"${BACKUP_DIR}/latest\" rsync -av \\ \t--delete \"${SOURCE_DIR}/\" \\ \t--link-dest \"${LATEST_LINK}\" \\ \t--exclude={\"dev\",\"proc\",\"sys\",\"tmp\",\"run\",\"mnt\",\"media\",\"lost+found\",\"Trash\",\"Downloads/*\",\"DataBackup/*\",\"DataPool/*\"} \\ \t\"${BACKUP_PATH}\" rm -rf \"${LATEST_LINK}\" ln -s \"${BACKUP_PATH}\" \"${LATEST_LINK}\" 注意：\n ${SOURCE_DIR}/必须带反斜杠，否则会备份SOURCE_DIR这个目录，而不是这个目录里的内容。 --exclude=\"Trash\"，Trash被认为为目录，而非文件或文件和目录，并且，它不支持路径~/.local/share/Trash  查看备份大小\n$ sudo du -hs /backup/ 16G\t/backup/ 整个备份为16GB，所花时间 12m。\n通过 crontab 使之每周一12点自动备份：\n$ sudo crontab -e 0 12 * * 1 /path/.backup.sh 还原\n还原的时候，如果带 --delete，那么就会删除备份时 --exclude= 不包含的内容。还原的时候，同名文件内容会恢复到备份时候的状态。\n$ rsync -av 备份目录 源目录 $ rsync -av /backup/latest/ / TAR 目的在于迁移系统到新硬盘。\nBackup\n$ cd / # THIS CD IS IMPORTANT THE FOLLOWING LONG COMMAND IS RUN FROM / $ tar -cvpzf backup.tar.gz \\ --exclude=/backup.tar.gz \\ --exclude=/proc \\ --exclude=/tmp \\ --exclude=/mnt \\ --exclude=/dev \\ --exclude=/sys \\ --exclude=/run \\  --exclude=/media \\  --exclude=/var/log \\ --exclude=/var/cache/apt/archives \\ --exclude=/usr/src/linux-headers* \\  --exclude=/home/*/.gvfs \\ --exclude=/home/*/.cache \\  --exclude=/home/*/.local/share/Trash / Restoring\n$ sudo tar -xvpzf /path/to/backup.tar.gz -C /media/whatever --numeric-owner $ cd /media/whatever $ mkdir /proc /sys /mnt /media For the system to boot, you will need to restore grub. To do this, you will need to reconfigure it in a chroot:\n$ sudo -s for f in dev dev/pts proc ; do mount --bind /$f /media/whatever/$f ; done $ chroot /media/whatever $ dpkg-reconfigure grub-pc You will get a menu asking you what drive(s) grub should be installed on. Choose whatever drive(s) the computer will be booting from.\nFor more information on repairing grub, see [GrubHowto](https://help.ubuntu.com/community/GrubHowto#Backup, Repairing and Reinstalling GRUB)\nOthers Does the UEFI partition either “MUST” or “SHOULD” be first for some reason? If so why?\nThe key words “SHOULD”, “MUST” and “MAY” (capitalised) in this answer are to be interpreted as described in RFC 2119.\nAn (U)EFI System Partition (ESP from now on):\n MAY reside at the beginning of the disk and SHOULD be FAT32 because of Windows compatibility.  The only official limit is:\n the ESP MUST reside in the first 2.2 Terabytes of the disk.  So, the ESP MUST reside anywhere in those first 2.2 TB of the disk, but there is absolutely no need for the ESP to be the first partition or reside on the beginning of the disk whatsoever. (It’s just that some large company in Redmond, WA advises system integrators differently)…\nI would put it as the last partition on the disk (if ubuntu 20.04 默认 fstab\n# / was on /dev/sda2 during installation UUID=4b66082e-7982-4056-91c2-39cf9177b20f / ext4 errors=remount-ro 0 1 # /boot/efi was on /dev/sda1 during installation UUID=ACEE-47E4 /boot/efi vfat umask=0077 0 1 /swapfile none swap sw 0 0 /boot/efi 是独立分区，而不是 /boot/，如果是 /boot/ 作为独立分区，还原的时候会报错 cannot create symbolic link ‘./initrd.img’: Operation not permitted\nAdd Boot Option Manually\nIn Boot Option Name, type Ubuntu, and in File Name select the file grubx64.efi and then Click on ‘OK’.\n13 个开源备份解决方案\n  Cronopete\n  Deja Dup\n  Rclone\n  Rdiff-backup\n  Restic\n  Rsync\n  BorgBackup：带有压缩和加密特性以用具有数据去重功能的备份解决方案。它基于 BSD 许可证，支持 Linux、MacOS 和 BSD。\n  UrBackup：它可以做镜像和文件的完整和增量备份；你可以保存整个分区或单个目录。它有 Windows、Linux、和 MacOS 客户端，并且采用 GNU Affero 公共许可证。\n  LuckyBackup：根据其网站介绍，“它是一个易于使用、快速（只传输变化部分，而不是全部数据）、安全（在做任何数据操作之前，先检查所有需要备份的目录，以确保数据安全）、可靠和完全可定制的备份解决方案。它在 GPL 许可证下发行。\n  Casync ：一个可寻址内容的同步解决方案 —— 它设计用于备份、同步、存储和检索大文件系统的多个相关版本。它使用 GNU Lesser 公共许可证。\n  Syncthing：用于在两台计算机之间同步文件。它基于 Mozilla 公共许可证使用，根据其网站介绍，它是安全和私密的。它可以工作于 MacOS、Windows、Linux、FreeBSD、Solaris 和 OpenBSD。\n  Duplicati：一个可工作于 Windows、MacOS 和 Linux 上的、并且支持多种标准协议（比如 FTP、SSH、WebDAV 和云服务）、免费的备份解决方案。它的特性是强大的加密功能，并且它使用 GPL 许可证。\n  Dirvish ：一个基于磁盘的虚拟镜像备份系统，它使用 OSL-3.0 许可证。它要求必须安装有 Rsync、Perl5、SSH。\n  Bacula：允许系统管理员去管理备份、恢复、和跨网络的不同种类计算机上的多种数据的一套计算机程序，它支持在 Linux、FreeBSD、Windows、MacOS、OpenBSD 和 Solaris 上运行，并且它的大部分源代码都是基于 AGPLv3 许可证的。\n  BackupPC：一个高性能的、企业级的、可以备份 Linux、Windows 和 MacOS 系统的 PC 和笔记本电脑上的数据到服务器磁盘上的备份解决方案。它是基于 GPLv3 许可证的。\n  Amanda ：一个使用 C 和 Perl 写的备份系统，它允许系统管理员去备份整个网络中的客户端到一台服务器上的磁带、磁盘或基于云的系统。它是由马里兰大学于 1991 年开发并拥有版权，并且它有一个 BSD 式的许可证。\n  Back in Time ：一个为 Linux 设计的简单的备份实用程序。它提供了命令行和图形用户界面，它们都是用 Python 写的。去执行一个备份，只需要指定存储快照的位置、需要备份的文件夹，和备份频率即可。它使用的是 GPLv2 许可证。\n  Timeshift ：一个 Linux 上的备份实用程序，它类似于 Windows 上的系统恢复和 MacOS 上的时间胶囊。它的 GitHub 仓库上介绍说：“Timeshift 通过定期递增的文件系统快照来保护你的系统。这些快照可以在日后用于数据恢复，以撤销某些对文件系统的修改。”\n  Kup ：一个能够帮助用户备份它们的文件到 USB 驱动器上的备份解决方案，但它也可以用于执行网络备份。它的 GitHub 仓库上介绍说：”当插入你的外部硬盘时，Kup 将自动启动并复制你的最新的修改。“\n  How to make a disk image and restore from it later?/Moving entire Linux installation to another drive\nIt’s Clonezilla Live: http://clonezilla.org/\nThe tutorial for Clonezilla can be found here.\nEasy backup/restore of installed system?\nYes you can use remastersys for that.You can see a complete tutorial here\n清理系统 删除不再需要的包 $ sudo apt autoremove APT cache # see the size of this cache $ sudo du -sh /var/cache/apt # remove only the outdated packages $ sudo apt-get autoclean # delete apt cache in its entirety $ sudo apt-get clean apt-get 和软件中心下载的软件包一般放在 /var/cache/apt/archives/ 目录，一般都安装在 /usr/\nJournal logs # check the log size $ journalctl --disk-usage # clear the logs that are older than a certain days $ journalctl --vacuum-time=3d Thumbnails cache # check the size of thumbnail cache $ du -sh ~/.cache/thumbnails $ rm -rf ~/.cache/thumbnails/* Duplicate files Find and remove duplicate files：You can use a GUI tool like FSlint or a command line tool like FDUPES for this task\nOld Linux kernels Remove old Linux kernels\n# List all installed Linux kernels $ sudo dpkg --list 'linux-image*' $ apt-get remove linux-image-VERSION 清理 Snap 与 snap 有关的系统文件都存放在 /var/lib/snapd 目录下。根据你所安装的 Snap 包的数量，这个目录的大小可能在几 GB。\n$ sudo du -sh /var/lib/snapd 根据设计，Snap 至少会在你的系统上保留一个你所安装的软件包的旧版本。你可以通过使用 Snap 命令看到这种行为：\n$ snap list --all 你应该看到同一个软件包被列了两次，而且版本和修订号都不同。\n为了释放磁盘空间，你可以删除额外的软件包版本。你怎么知道要删除哪一个呢？你可以看到，这些较旧的软件包被标记为“禁用”。\n#!/bin/bash # Removes old revisions of snaps # CLOSE ALL SNAPS BEFORE RUNNING THIS set -eu snap list --all | awk '/disabled/{print $1, $3}' | while read snapname revision; do snap remove \"$snapname\" --revision=\"$revision\" done 命令行技巧 Bash 快捷键 编辑命令\n Ctrl + a ：移到命令行首 Ctrl + e ：移到命令行尾 Ctrl + f ：按字符前移（右向） Ctrl + b ：按字符后移（左向） Alt + f ：按单词前移（右向） Alt + b ：按单词后移（左向） Ctrl + xx：在命令行首和光标之间移动 Ctrl + u ：从光标处删除至命令行首 Ctrl + k ：从光标处删除至命令行尾 Ctrl + w ：从光标处删除至字首 Alt + d ：从光标处删除至字尾 Ctrl + d ：删除光标处的字符 Ctrl + h ：删除光标前的字符 Ctrl + y ：粘贴至光标后 Alt + c ：从光标处更改为首字母大写的单词 Alt + u ：从光标处更改为全部大写的单词 Alt + l ：从光标处更改为全部小写的单词 Ctrl + t ：交换光标处和之前的字符 Alt + t ：交换光标处和之前的单词 Alt + Backspace：与 Ctrl + w 类似，分隔符有些差别  重新执行命令\n Ctrl + r：逆向搜索命令历史 Ctrl + g：从历史搜索模式退出 Ctrl + p：历史中的上一条命令 Ctrl + n：历史中的下一条命令 Alt + .：使用上一条命令的最后一个参数  控制命令\n Ctrl + l：清屏 Ctrl + o：执行当前命令，并选择上一条命令 Ctrl + s：阻止屏幕输出 Ctrl + q：允许屏幕输出 Ctrl + c：终止命令 Ctrl + z：挂起命令  Bang (!) 命令\n !!：执行上一条命令 !blah：执行最近的以 blah 开头的命令，如 !ls !blah:p：仅打印输出，而不执行 !$：上一条命令的最后一个参数，与 Alt + . 相同 !$:p：打印输出 !$ 的内容 !*：上一条命令的所有参数 !*:p：打印输出 !* 的内容 ^blah：删除上一条命令中的 blah ^blah^foo：将上一条命令中的 blah 替换为 foo ^blah^foo^：将上一条命令中所有的 blah 都替换为 foo  你可能不知道的SHELL Shell也叫做命令行界面，它是*nix操作系统下用户和计算机的交互界面。Shell这个词是指操作系统中提供访问内核服务的程序。\n这篇文章向大家介绍Shell一些非广为人知、但却实用有趣的知识，权当品尝shell主食后的甜点吧。\n科普\n先科普几个你可能不知道的事实：\n  Shell几乎是和Unix操作系统一起诞生，第一个Unix Shell是肯·汤普逊（Ken Thompson）以Multics上的Shell为模范在1971年改写而成，并命名Thompson sh。即便是后来流行的bash（shell的一种变体），它的年龄实际上比当前流行的所有的Linux kernel都大，可谓在Linux系统上是先有Shell再有Kernel。\n  当前绝大部分*nix和MacOS操作系统里的默认的Shell都是bash，bash由Brian Fox在1987年创造，全称Bourne Again shell ( bash)。\n  你或许听说除了bash之外，还有Bourne shell ( sh)，Korn shell ( ksh)，C shell （包括 csh and tcsh），但是你知道这个星球上一共存在着大约50多种不同的shell么？想了解他们，请参考 http://www.freebsd.org/ports/shells.html。\n  一些强大的命令\n  在命令行前加空格，该命令不会进入history里。\n  ctrl-x e\n快速启动你的默认编辑器（由变量$EDITOR设置）。\n  为什么说 zsh 是 shell 中的极品？ 色彩高亮\n并不是传统基于正则表达式的色彩高亮，而是真的会判断你输入的是啥的色彩高亮。\n比如一个主题白色代表普通命令或者程序，红色代表错误命令，青色的代表内建命令或者 alias （echo 和 ls ），这些都不是正则判断出来的，是真的去检查的。非零的错误码（上一条命令错误），也可以高亮显示。\n命令提示\n注意，命令提示和补全是两个完全不同的系统，很多时候提示比补全更有用。你输入命令，后面就用灰色给你提示命令的参数，而且是随着你动态输入完每一个字母不断修正变化。\n这个命令提示是基于你的历史命令数据库进行分析的，随着你输入的命令越来越多，提示将会越来越准确和顺手。\n如果你觉得它提示的正确，你可以 CTRL+F 表示采纳，后面就会自动帮你一次性全部输入完了。\n智能补全\n缩写路径补全：\n$ cd /v/w/h 敲一个TAB\n$ cd /var/www/html/ 补全目录、命令参数补全连敲两次TAB进入选择模式，除了 tab/shift+tab 可以前后切换外，你还可以使用光标键上下左右移动。回车表示确认选择，用 CTRL+G 表示退出。\n快速跳转\n输入 cd 后面加一个减号后，按一次 tab 马上就列出本次登陆后去过的最近几次路径，接着根据下面的提示输入数字按回车就过去了，比如输入：\n$ cd -5  当然你还可以不输入数字，而是再按一次 tab 进入选择模式，上下键或者 ctrl+n/p 来选择，回车确认，ctrl+g 返回。\n自动跳转\n敲入 z 命令，列出了自从我开始用zsh进入过的目录和他们的权重，进入次数越多，权重越大。z 后面加一个关键词就能跳转到所有匹配的历史路径中权重最高的那个了。空格分隔多个关键字，z会先匹配出第一个来，然后再匹配第二个…\n使用：“z -l foo\" 可以列出包含 foo 的所有历史路径。\n# 按下ALT+O 就执行 cd .. 命令 bindkey -s '\\eo' 'cd ..\\n' # 按下 ALT+; 就执行 ls -l 命令 bindkey -s '\\e;' 'ls -l\\n' 热键绑定\nzsh 里面使用 bindkey 命令可以设置一系列热键，用来运行某一个 zsh 内部命令或者某个 shell 命令。\n应该知道的LINUX技巧 首先，我想告诉大家，在Unix/Linux下，最有效率技巧的不是操作图形界面，而是命令行操作，因为命令行意味着自动化。\n日常\n  请man bash后查找Readline Key Bindings一节来看看bash的默认热键，比如：Alt-. 把上一次命令的最后一个参数打出来，而Alt-* 则列出你可以输入的命令。\n  回到上一次的工作目录： cd – （回到home是 cd ~）\n  pstree -p 可以帮你显示进程树。\n  使用 pgrep 和 pkill 来找到或是kill 某个名字的进程。 (-f 选项很有用).\n  通过  在 bash中，使用重定向到标准输出和标准错误。如： some-command logfile 2\u00261。\n  使用 man ascii 来查看 ASCII 表。\n  系统调试\n  如果你想知道磁盘、CPU、或网络状态，你可以使用 iostat, netstat, top (或更好的 htop), 还有 dstat 命令。你可以很快地知道你的系统发生了什么事。关于这方面的命令，还有iftop, iotop等。\n  要了解内存的状态，你可以使用free和vmstat命令。具体来说，你需要注意 “cached” 的值，这个值是Linux内核占用的内存。还有free的值。\n  如果你要找到哪个socket或进程在使用网络带宽，你可以使用 iftop 或 nethogs。\n  如果你要抓网络包的话，试试 wireshark 或 tshark。\n  了解 strace 和 ltrace。这两个命令可以让你查看进程的系统调用，这有助于你分析进程的hang在哪了，怎么crash和failed的。你还可以用其来做性能profile，使用 -c 选项，你可以使用-p选项来attach上任意一个进程。\n  了解用ldd命令来检查相关的动态链接库。注意：ldd的安全问题\n  使用gdb来调试一个正在运行的进程或分析core dump文件。参看我写的《GDB中应该知道的几个调试方法》\n  学会到 /proc 目录中查看信息。这是一个Linux内核运行时记录的整个操作系统的运行统计和信息，比如： /proc/cpuinfo, /proc/xxx/cwd, /proc/xxx/exe, /proc/xxx/fd/, /proc/xxx/smaps.\n  如果你调试某个东西为什么出错时，sar命令会有用。它可以让你看看 CPU, 内存, 网络, 等的统计信息。\n  使用 dmesg 来查看一些硬件或驱动程序的信息或问题。\n  powerline-shell 不想每次都安装 zsh 与 ohmyzsh？\n$ pip install powerline-shell Add the following to your .bashrc file:\nfunction _update_ps1() { PS1=$(powerline-shell $?) } if [[ $TERM != linux \u0026\u0026 ! $PROMPT_COMMAND =~ _update_ps1 ]]; then PROMPT_COMMAND=\"_update_ps1; $PROMPT_COMMAND\" fi 默认的话，路径会完整显示，会很长\ngenerate the default config at this location using:\n$ mkdir -p ~/.config/powerline-shell \u0026\u0026 \\ powerline-shell --generate-config  ~/.config/powerline-shell/config.json Segment Configuration\n{ \"segments\": [ \"virtual_env\", \"username\", \"hostname\", \"ssh\", \"cwd\", \"git\", \"hg\", \"jobs\", \"root\" ], + \"cwd\": + { + \"max_depth\": 1 +\t} } 检测硬盘坏道和坏块 硬盘坏道分为物理坏道和逻辑坏道。\n 物理坏道：就是硬盘实体有坏的地方，物理坏道推荐换硬盘，当然也有办法重新分区来隔离坏道，不过可能也用不久，所以不推荐。 逻辑坏道：是磁盘磁道上面的校验信息（ECC）跟磁道的数据对不上号所致。出现这一故障的原因，通常都是因为一些程序的错误操作或是该处扇区的磁介质开始出现不稳定的先兆。物理坏道也是逻辑坏道产生的一种原因。  发现 dmesg：当有硬盘坏道时，通常在dmesg输出的信息中会有 Buffer I/O Error，所以经常检查dmesg的输出可以及时发现是否存在硬盘问题。\n检测 通过fdisk 查看显示所有磁盘或闪存的信息\n$ sudo fdisk -l /dev/sd* 使用 badlocks检查 linux 硬盘上的坏道/坏块\n$ sudo badblocks -s -v /dev/sdb  badsectors.txt 修复 查看上述分区检查出来的坏道信息\n$ tail -f badsectors.txt 先备份数据再修复磁盘。硬盘在使用时不能修复，否则可能存在写并发的问题，所以修复前需要umount对应分区,或使用 Live CD\n$ sudo umount MountPoint umount 分区成功后，修复命令如下，其中-w表示写入修复的，后面是结束（END）和开始（START）块号，注意END在前，START在后。\n$ sudo badblocks -s -w /dev/sdb 205971590 205971595 修复后再次检查\n$ sudo badblocks -s -v /dev/sdb 205971590 205971595 屏蔽 执行e2fsck（针对 ext2/ext3/ext4 文件系统）或fsck命令，命令中还需要用到 badsectors.txt 文件和设备文件。\n# for ext2/ext3/ext4 $ sudo e2fsck -l badsectors.txt /dev/sdb # others $ sudo fsck -l badsectors.txt /dev/sdb 如何探索 從「指令」找到「使用說明」\n找使用說明\n$ man -f ls 閱讀使用說明\n$ man ls $ man 1 ls # 若是「bash」內建的指令，則是可以使用「help」 $ help if 上面的「man 1 ls」，「1」指的是「Manpage Sections」。\n執行下面指令可以看到各個「Section」的簡介。\n$ whatis intro 然後分別執行下面的指令，可以閱讀更詳細的說明\n$ man 1 intro $ man 2 intro $ man 3 intro $ man 4 intro $ man 5 intro $ man 6 intro $ man 7 intro $ man 8 intro 從「指令」找到「所屬套件」\n先透過「whereis」來找到「ls」所在的確切路徑。\n$ whereis ls ls: /bin/ls 然後根據這個結果，再執行下面的指令\n$ rpm -qf /bin/ls $ dpkg -S /bin/ls coreutils-8.32-1.2.x86_64 找「已安裝套件」的「檔案列表」\n$ rpm -ql coreutils $ dpkg -L coreutils Transfer files between Linux and Android  Connect Using USB Cable Apps  KDE Connect/GSConnect Android File Transfer AirDroid   Bluetooth  Xorg vs Wayland X即X11、X Window System，是用于在类UNIX的操作系统上的位图显示的窗口系统，提供了GUI环境的基本框架。X由X.Org Foundation维护，遵守MIT协议，当前参考实现为X.Org Server。在架构方面，X使用了C/S模型，客户端和服务器可以在同一个机器上，也可以在不同的机器上，X作为Server为应用程序这个Client提供显示和I/O服务。\nWayland是一个显示服务协议，服务端为Wayland Compositor，把X的X Server和Compositor合二为一，旨在替换X，作为类Unix操作系统上更现代、简介的窗口系统，遵守MIT协议，提供了Wayland Compositor的参考C语言实现Weston。\n时至今日，原本在X Server中做的事很多已被移到kernel或者单独的库中，因此X Server就显得比较累赘了。Wayland在架构上去掉了这个中间层，将compositor作为display server，使client与compositor直接通信，从而在灵活性和性能等方面上能够比前辈更加出色。\n查看是否使用 wayland\n$ echo $XDG_SESSION_TYPE Fedora、openSUSE 群讨论\nAppImage的制造者就是其中一个。主要反对的是Wayland声称自己取代X11，但在功能集合上二者完全不在一个层面，后者比前者强太多了。\n而他反对红帽的东西主要是因为红帽一直就是Linux桌面领域比较强权的那个企业，比如早期PulseAudio，比如SystemD，早期多灾多难制造了很多麻烦。\n推出一个新技术，在其不完善的前提下就想着取代旧技术，对于旧技术存在的但新技术不存在的功能却完全不考虑过渡方案，导致技术迭代的过程中用户就一次又一次地被抛弃。尤其和微软对比起来，微软在砍掉很重要的旧功能的时候会有完备的过渡方案，并且对于旧技术依然保持极长的支持周期。不过毕竟Windows 8那时候用户啥反应大家也不是不知道。\n能理解，并且我有时候也会有同样的抱怨，刚学会一个新软件，结果过半年这个软件就被下一次更新抛弃了。AppImage的制造者可能是希望Linux桌面能学习一下微软的一些策略。\n至于为什么反对Flatpak，因为Flatpak是红帽随同Wayland、Gnome一起强推的技术。\nX11 为什么强?\n远程应用，只把远程系统的一个应用程序在本机打开。X下面非常轻松，这就是X功能的一部分。微软的RDP也有同样的功能。并且渲染工作是在发起远程连接的那一段完成的。Wayland下面，没有，完全依赖窗口管理器自己提供的功能，而目前能做到的极限就是个VNC。\n统一的图形库，Xlib，Windows下与之对应的是Win32的UI部分。所有X11的窗口管理器都提供稳定且统一的图形库。在Wayland下面，没有，只能给你push一堆像素点，这就意味着Wayland的应用程序的向下兼容性会比原先X的程序更差。\n统一的窗口管理方式，也是X服务器的标准功能之一，在Windows下面我也不知道对标啥，但只要一个桌面环境用了X，那么应用程序就能确保自己使用一个标准的方法就能管理程序窗口，在Windows下也有同样的保障。Wayland下面，没有，完全依赖窗口管理器暴露的API或者无障碍API。\n接上述，统一的自动化工具实现方式。Windows下面的AutoHotkey不知道多少人用过，在X11下面对应的软件是xdotool。在Wayland下面，没有。ydotool先不说它已经被半弃坑了，最主要的是ydotool调用uinput，只能输入不能获得窗口状态。\n程序的可靠性。在X下面，桌面环境或者渲染器崩溃，应用程序依然健在。并且Windows也是如此的。Wayland下面就不是这么一回事了，至少对于Gnome来讲，shell崩溃就会连着所有程序全部崩溃。KDE的Kwin实现了自己的程序留活机制，但这样便从“所有X11桌面都支持”变成了“只有KDE支持”。\nWayland没有上述所有功能的原因很简单，Wayland不是软件、不是具体实现，它只是个标准，用来显示画面的标准。\n是的，没错，这些本来确实应该交给窗口管理器和渲染器完成。但是，Wayland在不支持这些功能的前提下却表示自己是X11的替代品/延续发展，这就非常地有问题，因为Wayland并没有做到功能上的延续。\n而且，Linux桌面下面的向下兼容性问题极度严重，我不想在这再重复一遍。桌面在用X11的时候，至少还能确保X的功能是一致的，无论跑在什么桌面组合上都不用担心兼容性问题，Wayland的出现，只会让原本离散的桌面更加离散。\nwlroots被称作有希望统一Wayland渲染器的实现方式，可惜在此之前Gnome和KDE已经开始做自己的Wayland实现了，这就意味着从X11转向Wayland，至少分裂成了Gnome、KDE和wlroots，其它桌面会不会突然想不开自己做Wayland实现我们也不知道。而且，三家的分裂，难道还不够折磨吗？\n看看Flameshot的Wayland支持，因为发现Gnome和KDE的运行表现不同，于是放弃了Portals API打算等待wlroots的标准，然而wlroots的标准和Gnome的不互通，于是它的支持计划被延期，无ETA。\n再看看Barrier的Wayland支持，它fork的项目是symless的synergy，这是个商业开源软件。Ubuntu 17.04的时候曾经短暂切换到Wayland，那时候symless就计划开始适配Wayland，之后Ubuntu换回X11，于是Wayland适配计划就被放弃。当一部分软件只跟着一部分发行版走、而不考虑整个Linux桌面生态的时候，Linux桌面便从事实上消失了。接下来便只剩Ubuntu桌面、openSUSE桌面、Fedora桌面了，至少对于ISV来讲是这样的，因为不然的话指数级别的适配难度会把开发者累死。\n我并不是在吹X11诋毁Wayland。只是指出现状。我知道这不是Wayland该做的事情，只是问题是：有谁能来做？\n用户关心的是能不能用上对应的功能，Wayland之后功能少了，那用户就会把锅甩给Wayland。\n这也是AppImage创造者一直反感Wayland的原因之一。\n为什么执行自己的程序要在前面加./ shell是如何运行程序的：如果不给出相对路径，或者绝对路径，那么它会经历下面的查找过程。\n alias中查找 内置命令中查找 PATH中查找  $ cd /temp $ ./ls_bak 等同于\n$ /temp/ls_bak shell通常可以执行两种程序，一种是二进制程序，一种是脚本程序。如果是文本程序，且开头没有指定解释程序，则按照shell脚本处理，如果指定了解释程序，则使用解释程序来解释运行；对于二进制程序，则直接创建新的进程即可。\nLTS There is a new release every 6 months (in April and October), with the version number being year.month (e.g.: 16.04 was released in April 2016). Every two years, the April release is a Long Term Support version.\nLTS releases are the ‘enterprise grade’ releases of Ubuntu and are used the most. An estimated 95% of all Ubuntu installations are LTS releases.\nInterim releases (normal releases) will introduce new capabilities from Canonical and upstream open source projects, they serve as a proving ground for these new capabilities.\n All Interim releases (13.04 and later) are only supported for 9 months. All LTS releases (12.04 and later) are supported for five years (now is ten years) on both the desktop and the server.  Now, support means:\n Updates for potential security problems and bugs (not new versions of software) Availability of Commercial support contracts from Canonical Support by Landscape, Canonical’s enterprise oriented server management tool set  Ubuntu releases additional versions of the last LTS between releases—such as 14.04.1, that incorporate all of the updates up to this point. This is called a Point-Release (or sometimes snapshot). Those are released every quarter to half year, as needed.\nThe most important thing (for most people) is how long you get to use an install without having to do a release upgrade. A non-LTS version of Ubuntu only gets updates for 9 months from its release so to stay up-to-date —which is critically important— you need to upgrade twice a year; you need to upgrade through every Ubuntu version…\nConversely an Ubuntu LTS release is supported for 5 years and you can upgrade directly from LTS to LTS. This gives you long-lived, solid base to target and test on that makes it super-easy to release-upgrade when you decide to. It’s therefore ideal for mass deployment, high-availability systems, and just people who don’t like doing release-upgrades.\n设计shell脚本选项 getopt 写shell脚本的时候，通过while、case、shift来设计脚本的命令行选项是一件比较麻烦的事，因为Unix命令行的选项和参数自由度很高，支持短选项和长选项，参数可能是可选的，选项顺序可能是无所谓的，等等。\nbash下的getopt命令可以解析命令行的选项和参数，将散乱、自由的命令行选项和参数进行改造，得到一个完整的、规范化的参数列表，这样再使用while、case和shift进行处理就简单的太多了。\ngetopt有不同的版本，本文介绍的是它的增强版(enhanced)，相比传统的getopt(也称为兼容版本的getopt)，它提供了引号保护的能力。另外，除了不同版本的getopt，bash还有一个内置命令getopts(注意，有个尾随的字符s)，也用来解析命令行选项，但只能解析短选项。\n要验证安装的getopt是增强版的还是传统版的，使用getopt -T判断即可。如果它什么都不输出，则是增强版，此时它的退出状态码为4。如果输出\"–\"，则是传统版的getopt，此时它的退出状态码为0。如果想在脚本中进行版本检查，可以参考如下代码：\n$ getopt -T \u0026/dev/null;[ $? -ne 4 ] \u0026\u0026 { echo \"not enhanced version\";exit 1; } …\n在中文介面下，如何只用英文目錄名稱？  先切到英文介面再重新開機，此時 Fedora 會問你要不要將子目錄換為英文名稱（選 Yes），再切回中文介面重新開機，Fedora 會再問你一次要不要更改子目錄為中文名稱（選 No），收工！ LANG=C xdg-user-dirs-gtk-update # 同意更新 xdg-user-dirs-gtk-update # 保留且不再問 手動修正配置文件~/.config/user-dirs.dirs ,然後在主目錄下創建對應目錄,重啟即可解決.  dd 制作U盘启动盘 $ dd bs=4M if=fileName.iso of=/dev/sdx status=progress \u0026\u0026 sync Windows 下用 Rufus 且 dd 写入模式\n为什么 Linux 要用 tar.gz，很少用 7Z 或 ZIP？ 因为 7z 和 zip 压缩格式都不能保留 unix 风格的文件权限，比如解压出个可执行文件要重新 chmod chown 才能恢复正常。而 tar 格式可以。而 tar 本身不提供压缩，无非就是把包括所有文件的內容和权限拼成一个文件而己，所以用另外如 gzip 格式压缩。为什么是 gzip，因为几乎所有 linux 都支持而已。\n置默认编辑器 visudo 等操作会打开默认编辑器，在linux中默认编辑器读取EDITOR环境变量，可通过一下命令设置\nexport EDITOR=nano 可将其加入~/.bashrc文件，使得每次登录都可使用\n$ nano ~/.bashrc export EDITOR=nano $ . ~/.bashrc debian系统提供了一个管理工具来设置默认编辑器\n$ sudo update-alternatives --config editor 有两个相似选项\n /usr/bin/vim.basic /usr/bin/vim.tiny  它们的区别：\nim.basic is just plain vanilla Vim (as you can check with apt-file vim.basic or dpkg -S /usr/bin/vim.basic).\nWhile vim.tiny, as the name implies, is a trimmed-down version of Vim (this question explains it further).\n$ vim.tiny --version 通过Linux系统进入 BIOS $ sudo systemctl reboot --firmware-setup 5 Ways to Check CPU Info in Linux  lscpu /proc/cpuinfo lshw hwinfo dmidecodes hardinfo: gui  exFAT 文件系统\n所谓文件系统，就是文件的储存方式。通过文件系统可以准确找到存储在硬盘中的数据。储存设备都需要指定文件系统，计算机才能读写。\nWindows 的文件系统\n  FAT32：是最老的文件系统，所有操作系统都支持，兼容性最好。但是，它是为 32 位计算机设计的，文件不能超过 232 - 1 个字节，也就是不能超过 4GB，分区不能超过 8TB。\n  NTFS：是 Windows 的默认文件系统，用来替换 FAT32。Linux 下有如下方法创建 NTFS 文件系统\n# gparted $ sudo apt-get install gparted # mkntfs $ sudo apt-get install ntfs-3g $ sudo mkntfs --fast --label myUsbDrive /dev/sdb1 # mkfs $ mkfs.ntfs -f -L DiskLabel /dev/sdb1   exFAT：是 FAT32 的 64位升级版，ex 就是 extended 的缩写（表示\"扩展的 FAT32\"），功能不如 NTFS，但是解决了文件和分区的大小问题，两者最大都可以到 128PB。\n  Linux 的 exFAT 格式化\n$ sudo mkfs.exfat /dev/sdX1 分区表\n所谓硬盘分区，就是指一块硬盘上面，同时存在多个文件系统。每个文件系统管理的区域，就称为一个分区（partition）。\n分区大小、起始位置、结束位置、文件系统等信息，都储存在分区表里面。\n分区表也分成两种格式：MBR 和 GPT。前者是传统格式，兼容性好；后者更现代，功能更强大。\nLogging in as Root in Ubuntu with Live CD $ sudo passwd root How To Download A Large File Faster From Google Drive? Step 1: Fetching Your File ID\n Open your browser and go to your google drive, open login with the account that has the file you wish to download. Locate the file that you wish to download and select it. Right click the file and click on “get shareable link” You don’t need to copy the entire link here; you only need the file ID that we will be using later.  The link will look like this: https://drive.google.com/file/d/XXXXX/view?usp=sharing\nIn this link, you only need to pay attention to the alphanumeric file ID, displayed by XXXXX here.\nStep 2: Getting an OAuth Code\n Visit OAuth 2.0 Playground by clicking here. On the developer’s webpage, in the “Select \u0026 authorize APIs” click on the “Drive API v3” option, and select the: https://www.googleapis.com/auth/drive.readonly option from the available options. Once selected click Authorize APIs button on the bottom right corner of the tab. After you click on the Authorize APIs button you will be transferred to the google account login screen. Select the same google account in which you have your file stored. Allow Google OAuth 2.0 to access your drive if asked. When you get redirected back to the OAuth 2.0 playground screen click on the “Exchange Authorization Code for Tokens” button as shown. Copy the newly generated Access Token and save it on your notepad. You will be needing this in the next step.  Step 3: Downloading The File Using A Command Line Script\n$ curl -H \"Authorization: Bearer YYYYY\" https://www.googleapis.com/drive/v3/files/XXXXX?alt=media -o ZZZZZ In your command, replace “XXXXX” with the file ID from above, “YYYYY” with the access token from above, and “ZZZZZ” with the file name that will be saved (for example, “myFile.mp4” if you’re downloading an mp4 file).\nPress Enter and let the download begin.\nUSB插槽鬆動怎麼辦  手机  充电宝  笔记本  笔记本  nmcheck.gnome.org nmcheck.gnome.org is not malware. It is the gnome network manager connectivity check (for captive portals/hotspots). Click the link and you will see a single text file with a text in it. It should be “NetworkManager is online”.\nCheck /etc/NetworkManager/NetworkManager.conf. There probably is a section with this in it:\n[Connectivity] uri=http://nmcheck.gnome.org/check_network_status.txt on Ubuntu 20.04 no [Connectivity]  line like accepted answer in /etc/NetworkManager/NetworkManager.conf.\nBut you can disable the auto connectivity check by:\n Go to Settings app Go to Privacy menu On Connectivity tab, uncheck Connectivity Checking  XDG_TEMPLATES_DIR If you drop any files in “Templates” folder. Then when you right-click and create a new document, you can select any of these files as a basis for the new file.\nIf you have deleted the folder and need to restore this functionality:\n$ gedit ~/.config/user-dirs.dirs Check that there is a line containing the following - if not, add this line.\nXDG_TEMPLATES_DIR=\"$HOME/Templates\" 软件的稳定性 软件的稳定性其实往往来源于：足够多的使用者与足够多的反馈跟改进。\nLinux系统，在服务器端的大多数常用软件都有足够多的使用者，所以就足够稳定，由于它在服务器端市场占有率远高于微软，所以服务器端就是比微软稳定，很正常的事。\n在桌面端，市场占用率远低于微软，不稳定也是自然的。\n为什么Linux下命令行程序往往又好用又稳定？是因为用户喜欢装逼吗？不是，因为命令行程序是服务器端跟桌面端通用的，而服务器端程序经过了足够多用户的使用，经过了足够的反馈开发迭代，所以稳定。而图形界面只有桌面用户用，桌面占有率那么低，这些程序往往缺乏足够的测试人力也缺乏足够的开发维护人力，所以并不会非常稳定。\n那么，你要想体验Linux稳定，怎么办？答案就是只使用市场占有率高，用户量大，因而获得了充分测试的软件，这就稳定了。比方说只使用服务器端。或者桌面端只使用最常用的那些，例如终端仿真器，浏览器，输入法，gcc编译器之类，肯定是稳定的。\n你看我就用浏览器，输入法，xterm，screen，编程ide，vim，以及一堆命令行的东西，稳定得很啊，六个月才重启一次电脑，重启的那一次还是因为ubuntu升级。\n如何将Google搜索限制为特定语言的结果 只是想在Google搜索中添加有关语言参数的更全面的答案。\n有4种与语言相关的选项。\nWeb界面语言： hl=\n例： www.google.com/search?q=vilnius\u0026hl=lt\nWeb Interface Language Codes hl=zh-CN Chinese (Simplified) hl=zh-TW Chinese (Traditional) hl=en English hl=ja Japanese 指定语言的页面： lr=lang_\n例： www.google.com/search?q=vilnius\u0026lr=lang_lt\nSearch Language Codes lr=lang_zh-CN Chinese (Simplified) lr=lang_zh-TW Chinese (Traditional) lr=lang_en English lr=lang_ja Japanese 来自指定国家/地区的页面： cr=country\n示例：www.google.com/search?q=vilnius\u0026cr=countryLT 请注意，两个国家/地区代码字符必须大写！否则，Google会忽略该参数（自2017年1月3日起）（即使小写字母对于hl=和都适用lr=lang_）。\n还有另一个参数– gl=用于搜索结果，因为它们将显示在指定的国家/地区。我尝试对其进行测试，但对我而言，不同参数值的结果没有不同。浏览器或我的Google帐户的某些其他参数/设置可能已过时或覆盖了该设置。\nTwo Options to Recover Your PC With Android If your PC is out of action, you can install a new operating system or run a recovery environment thanks to Android. Two solid options are available:\n ISO 2 USB: Lets you burn an ISO file directly to a USB flash drive over USB-OTG. DriveDroid: Enables you to store bootable ISO files on Android. With the paid version, support for Windows 10 installation images is added.  good practice to avoid using sudo su It is good practice to avoid performing more actions as root than you need to. sudo facilitates this by allowing you to run individual commands as root without having to log in as root and without needing an interactive root shell for tasks you would otherwise not run a shell to do. But sudo su is not a “backdoor,” it is simply a somewhat less elegant way to do what sudo is designed to allow you to do with sudo -s. Similarly, sudo -i is the more elegant way to achieve what sudo su - would get you: a simulated initial login shell whose environment is like what you would get if you could log in as root on the command line. See man sudo.\nSSHFS: How to Mount Remote File Systems Over SSH SSHFS (SSH File System) is a client for mounting a file system located on a remote machine onto your local system through an SSH connection. Using the SFTP (SSH file transfer protocol), the SSHFS command-line tool mounts a physical or virtual disk locally, allowing file transfer between a local and remote machine.\nThis article demonstrates the installation and usage of SSHFS to mount a remote folder or file system over SSH.\nInstall SSHFS $ sudo apt install sshfs Mount a Remote File System on Linux Step 1: Create Mount Point\nCreate a mount point directory in the mnt folder where the remote file system will be mounted:\n$ sudo mkdir /mnt/Step 2: Mount the Remote File System Using SSHFS\nMount the remote file system to the created mount point using the SSHFS tool:\n$ sudo sshfs [-o ] @://mnt// Enter the login password when requested if using password authentication. If the remote server uses SSH key authorization, provide the path of the private key. For example:\n$ sudo sshfs -o allow_other,IdentityFile=/home/kb/.ssh/id_rsa ubuntu@131.153.142.254:/home/ubuntu/ /mnt/test/ The allow_other option allows access to users other than root.\nStep 3: Unmount a Remote File System on Linux\nLastly, when finished with the mount point, unmount the remote file system with:\n$ sudo umount /mnt/img转化成iso IMG是一种文件归档格式（archive format），主要是为了创建磁盘的映像文件（disk image），它可以用来封装存储整个磁盘（通常指软磁盘，Floppy Disk或Diskette）或整片光盘的内容，使用\".IMG\"这个扩展名的文件就是利用这种文件格式来创建的。\n.IMG这个文件格式可视为.ISO格式的一种超集合。由于.ISO只能封存使用ISO9660和UDF这两种文件系统的存储介质，意即.ISO只能拿来封存CD或DVD，因此才发展出了.IMG，它是以.ISO格式为基础另外新增可封存使用其它文件系统的存储介质的能力，.IMG可向后兼容于.ISO，如果是拿来封存CD或DVD，则使用.IMG和.ISO这两种格式所产生出来的内容是一样的。\n将img 转化成iso的有 nrg2iso 或 ccd2iso，分别下载如下：\n$ sudo apt-get install nrg2iso $ sudo apt-get install ccd2iso 使用如下：\n$ nrg2iso image.nrg image.iso $ ccd2iso HWE The Ubuntu LTS enablement (also called HWE or Hardware Enablement) stacks provide newer kernel and X support for existing Ubuntu LTS releases.\nThe 20.04 LTS HWE Stacks continue to follow Rolling Update Model, as has been in use since 16.04 LTS.\nMicrocode 每当听到有人说“这个问题更新一下微码就好了”，就觉得这个哥哥怎么这么迷人，好像在哪里见过。为了也让自己变成这种迷人的哥哥，我也研究了一下到底什么是微码。\n这里说的是跑在CPU处理器上的微码，不是IBM那群人嘴里说的那个微码。如果你之前没和IBM打过交道那就当这段话不存在。\n计算机体系结构是一层又一层的抽象，典型的比如操作系统对底层硬件的抽象。但鲜有人知的是，操作系统和底层硬件，尤其是CPU之间还存在着几层抽象。什么叫抽象，当然有很多种学术流的解释，但我土气一点的解释就是“不关心”，就是“Don’t care”，就是爱咋地咋地。\n用这个模式套用一下我们熟悉的抽象：操作系统要将数据写入磁盘，它不关心怎么操作磁盘；应用要给某个服务器发个数据包，它也不关心怎么操作网卡。\n回到我们的微码上来。我们现在常见的操作系统都是用C语言编写，它相对于汇编语言来说，也算是一种“高级语言”。编译器会将这种高级语言编译成汇编语言。只要C语言编写时“不关心”汇编指令是啥，那么就是相对汇编语言做了一次抽象。\n马上就到微码了。我们知道汇编指令是执行在CPU上的，那么汇编指令会关心在某个具体型号的CPU上是怎么执行的吗？肯定不会的。汇编的一条ADD指令在80286上可以执行，在最新的Icelake上也能执行，但这两个CPU内部早已发生了天翻地覆的变化，执行ADD的操作已经完全不同了。\n换句话说，就是汇编指令并“不关心”是如何在CPU上执行的。\n操作系统不关心如何操作磁盘和网卡，是因为这些都有对应的设备驱动操心。汇编指令不关心具体如何在CPU中执行，这个就是由微码来操心了。所以用类比的方式，可以把微码类比成汇编指令针对某一型号CPU的驱动。\n同样的汇编指令，会由该型号CPU的微码转成可以跑在该CPU上的微操作（Micro-ops/uops）。这些微操作指导CPU的电路完成汇编指令要求的意图。\n在大家还在编写汇编语言代码的时代，微码为汇编语言的编写提供了方便：\n 只关心汇编逻辑，而不用关心CPU内部电路设计和具体的执行方式 方便设计出新的汇编指令，由微码翻译成具体的执行逻辑，比如循环中“变量自减若大于零则转跳”，可以用一条汇编指令代替，脏活累活都交给微码去干 修复或绕过一些很难修复的处理器数字电路中的Bug  上述第二点也为CISC指令集的实现提供了技术基础。因为不可能所有复杂的指令都是由专门的执行复杂指令的硬件来完成的，也是由简单的数字逻辑模块组合而成的。\n在现代CPU里，是存在专门的将汇编指令翻译成微操作的硬件解码器的。但微码依旧存在（就是CPU微架构图中前端那个Microcode sequencer），它作为一个Lookup Table保存在一块ROM中，用来解码复杂的指令，比如浮点运算的指令等。一般是硬件解码器解码得比较快，而用微码解码会比较慢。\n理论上，如果你能更改某一个处理器的微码，那么经它翻译的指令可以变成任意其他的指令。因为它关心指令如何在CPU电路中执行。所以现在升级微码主要是用来解决处理器的稳定和安全性的问题。\n当然你也可以用它模拟自己没有的汇编指令，比如AVX系列，我只要在看到AVX512的汇编之后，把它翻译成两个“SIMD256”或者四个“SIMD128”指令就好了。\n看到这里，你给自己就又加了一层微码的buff。最后贴心地推荐一篇详细说明Microcode怎么执行的文章：Microprocessor Microcode Simple Example\n安装/更新微码 微码就是由 Intel/AMD 提供的 CPU 固件。Linux 的内核可以在引导时更新 CPU 固件，而无需 BIOS 更新。处理器的微码保存在内存中，在每次启动系统时，内核可以更新这个微码。这些来自 Intel/AMD 的微码的更新可以去修复 bug 或者使用补丁来防范 bug。\n查看当前的微码状态：\n$ sudo dmesg | grep microcode 使用包管理器\n$ sudo apt install intel-microcode 必须重启以激活微码更新：\n$ sudo reboot 手动\n只有在你的 CPU 制造商建议这么做的时候，才可以使用下列的方法去更新/安装微码，除此之外，都应该使用上面的方法去更新。大多数 Linux 发行版都可以通过包管理器来维护、更新微码。使用包管理器的方法是经过测试的，对大多数用户来说是最安全的方式。\nAutomatic Light / Dark Mode for GNOME, this shell extension exists: Night Theme Switcher\n将du的输出按文件大小排序 sdu () { du -sk $@ | sort -n | awk ' BEGIN { split(\"K,M,G,T\", Units, \",\"); FS=\"\\t\"; OFS=\"\\t\"; } { u = 1; while ($1 = 1024) { $1 = $1 / 1024; u += 1 } $1 = sprintf(\"%.1f%s\", $1, Units[u]); sub(/\\.0/, \"\", $1); print $0; }' } 改善触摸板体验 众所周知，Macbook 的触摸板是体验最好的，很多果粉都吹 Macbook 的触摸板用了之后“就不再想要去用鼠标”。\n有一群人搞了一个项目：「Linux Touchpad like Macbook Update」。顾名思义，就是“把 Linux 的触摸板搞的像 Macbook 一样”。\n这个项目的主要作用就是针对现在 Linux 下对于触摸板管理的相关驱动进行一些修改和优化，以提升触摸的使用体验，尤其是包括“多点触摸”等等等。\n$ sudo add-apt-repository ppa:p12/xorg-gestures $ sudo apt-get update 当然，尽管如此，我们也只是在驱动层面改善了触摸，在应用层面还需要另一个工具的帮忙：touchegg\n安装完毕之后你的三指上滑和三指下滑都可以正常使用了，譬如三指上滑是窗口最大化，三指下滑是窗口最小化。\nReset lost root password 警告： 攻击者都可以使用上述方法修改系统，要保证系统安全，请限制物理上的访问，或者使用全磁盘加密。\n使用 LiveCD 通过 LiveCD 可以使用好几种方法：chroot并且使用passwd命令或者擦除密码域条目。任何Linux的LiveCD都可以使用，chroot时它必须匹配已经安装的架构类型。这里仅介绍 chroot 方式，因为这个方法更不容易出错。\n  启动LiveCD，挂载根文件系统.\n  然后通过下列命令重置密码：\n$ passwd --root MOUNT_POINT USER_NAME   卸载根文件系统。\n  重启，记下你的密码。\n  用 Bash 作为 Init   将 init=/bin/bash 内核参数加入启动加载器的启动项.\n  启动后可以看到 Bash 提示符。\n  根文件系统应该是只读挂载，需要以可读写模式重新挂载：\nmount -n -o remount,rw /   用 passwd 创建新的管理员密码。\n  通过 reboot -f 重启，不要再次忘记你的密码。\n  注意： 使用此法时有的键盘不能被初始系统正确加载，你可能不能在bash提示符后输入任何东西。如果出现这种情况，你不得不使用其他方法。\nHow to block internet access to certain programs on Linux The solution for me happened to be straight forward.\n  Create, validate new group; add required users to this group:\n  Create: groupadd no-internet\n  Validate: grep no-internet /etc/group\n  Add user: useradd -g no-internet username\nNote: If you’re modifying already existing user you should run: usermod -a -G no-internet userName check with : sudo groups userName\n    Create a script in your path and make it executable:\n  Create: nano /home/username/.local/bin/no-internet\n  Executable: chmod 755 /home/username/.local/bin/no-internet\n  Content:\n#!/bin/bash sg no-internet \"$@\"     Add iptables rule for dropping network activity for group no-internet:\n  iptables -I OUTPUT 1 -m owner --gid-owner no-internet -j DROP\nNote: Don’t forget to make the changes permanent, so it would be applied automatically after reboot. Doing it, depends on your Linux distribution.\n    Check it, for example on Firefox by running: no-internet \"firefox\"\n  In case you would want to make an exception and allow a program to access local network:\n iptables -A OUTPUT -m owner --gid-owner no-internet -d 192.168.1.0/24 -j ACCEPT iptables -A OUTPUT -m owner --gid-owner no-internet -d 127.0.0.0/8 -j ACCEPT iptables -A OUTPUT -m owner --gid-owner no-internet -j DROP  NOTE: In case of spawning the rules will be maintained. For example, if you run a program with no-internet rule and that program will open browser window, still the rules will be applied.\nHow does Ubuntu make money? Firstly a lot of people work on Ubuntu in their free time (many of them programming, but also those of here for instance answering people’s questions). Also some people donate to Ubuntu.\nHowever there is more to the story. Canonical Ltd. is a private company that created and continues to pay for Ubuntu. We know Canonical hadn’t been making a profit, but Canonical was initially founded by multi-millionaire Mark Shuttleworth which meant it didn’t have to focus on making money right away.\nHowever Canonical is now looking towards to making Ubuntu profitable. (After all, they have 600+ employees to pay every month!) There are some indications this has been successful. Their key revenue streams offer services around Ubuntu:\n Support services (mostly to business) alongside which they sell Landscape Contracting services to businesses (for instance working with OEMs such as Dell, or helping Google with Chrome OS). As Ubuntu makes its way onto mobile phones and TVs then this will grow. Ubuntu Software Centre’s paid section (Canonical takes a cut of purchases) The Canonical Store (selling physical Ubuntu branded items) - discontinued Closed-source projects wishing to use Launchpad.net can purchase a license Ubuntu One (online file storage and synchronization service) and Music Store (selling music from within Ubuntu) - discontinued. Amazon referrals. When you search the Ubuntu Dash, you may see Amazon products (unless you have turned it off). Ubuntu takes a cut of these.[ref]  All of these are areas that Canonical hopes will grow.\n启用 TRIM 当我在运行 Linux 的计算机上安装我的第一块固态驱动器（SSD）后，我开始探索如何用好它们。SSD 在操作方式上与传统磁性驱动器不同，并且它们需要在软件上另行处理以达到功能优化。\n在传统磁盘驱动器上，删除时所删除的文件不会从磁盘中完全删除。这就是为什么你可以恢复已删除的文件的原因。基本上，文件系统仅引用磁盘上文件的位置，并且当文件被删除时，该引用被擦除，以允许你在这些空间中写入新数据覆盖原来的数据。然而，对于 SSD，新数据只能写在驱动器上完全新的或已擦除的单元上。因为必须在写入之前清除空间，如果在写入文件时尚未有足够的可用空间，则必须首先擦除该空间。这可能会对性能产生负面影响。\n如果操作系统在写入新数据之前就擦除了未使用的空间，而不是在写入时同时进行擦除，则可以提高文件保存性能。这种做法就是 TRIM。 TRIM 命令本质上允许你的操作系统告诉驱动器哪些区域的数据不再使用，以便擦除它们，加快驱动器将来的写入，可以 SSD 的用户提供更佳的体验。\n在 Linux 中，fstrim 提供此功能，它可以为写入新数据而准备驱动器，并延长驱动器的使用寿命。由于在我使用的 Linux 发行版上 SSD 的 trim 不是自动的，所以必须去调度该操作，否则 SSD 的性能会随着时间的推移而降低。\n为了在驱动器上运行 fstrim，驱动器本身以及其上的文件系统必须支持 TRIM。TRIM SSD 可以在命令行或 cron 任务中手动完成。作为超级用户（使用 su 或 sudo），运行 fstrim / -v 以完成手动 trim，或者设置 cron 任务以在计算机未使用时定期为你运行此命令。对于 fstrim 的完整选项列表请参考它的 man 手册。\n注：可以定期执行fstrim命令，但是不建议在mount / fstab 中使用discard 选项。因为这个选项要求SSD每次删除文件都进行trim操作，比较耗资源，尤其是在文件操作很频繁的时候。所以可以考虑用cron来定期trim。\n硬件支持根据使用的驱动器接口类型如 PCI、ATA、SCSI 还是 SD/MMC 而有所不同。你需要咨询你的 Linux 供应商以了解你的特定发行版是如何支持 TRIM 的。\n例如，红帽提供以下 SSD 磁盘指南。“性能随着所使用的块数接近磁盘容量而降低，性能影响程度因供应商而异，但是所有设备都会遇到一些性能降低。为了解决性能降低问题，主机系统（例如 Linux 内核）使用丢弃请求以通知存储器给定范围的块不再使用。”\nDebian wiki 提供了 SSD 使用的一些基本注意事项：使用 Linux 3.2 或更高版本内核，使用 SSD 的最新固件，使用 EXT4 文件系统，并且“在正常工作负载下有足够的 DRAM 用来操作而不用使用交换空间“。\nreserve 5% of the space By default, ext2/3/4 filesystems reserve 5% of the space to be useable only by root. This is to avoid a normal user completely filling the disk which would then cause system components to fail whenever they next needed to write to the disk.\nYou can see the number of reserved blocks (and lots of other information about the filesystem) by doing:\n$ sudo tune2fs -l /dev/sda8 For a /home partition, it is probably safe to set the reserved fraction to zero:\n$ sudo tune2fs -m 0 /dev/sda8 Which should make an additional ~5GB available.\nChange Partition Label e2label or tune2fs The commands e2label or tune2fs used for changing label of ext2, ext3 and ext4 type partitions.\n# e2label /dev/sda1 ROOT OR # tune2fs –L ROOT_PART /dev/sda1 Here, ROOT and ROOT_PART are the labels to be added to /dev/sda1 which is ext4 formatted partition.\nntfslabel The ntfslabel command used for changing label of NTFS partitions.\n# ntfslabel /dev/sda5 NTFS_DIR mkswap The mkswap command used for changing label of SWAP partition.\nAfter unmounting the filesystem, following command needs to be executed to change the label of swap partition.\n# mkswap -L SWAP_PART /dev/sda5 Where, /dev/sda5 is the SWAP formatted partition.\nexfatlabel The exfatlabel command used for changing the label of exFAT formatted partition.\n# exfatlabel /dev/sda3 EX_PART Disable usb automount $ gsettings get org.gnome.desktop.media-handling automount $ gsettings set org.gnome.desktop.media-handling automount false or use dconf-editor\nCreate an ISO File   Mkisofs\n$ mkisofs -o [filename.iso] [ directory_path] $ mkisofs –o backup.iso /home/tin/Documents/backup   dd\n$ dd if=[source] of=[target.iso] $ sudo dd if= /dev/sdb of= diskimage.iso   Brasero\n$ sudo apt-get install brasero   keychain Squeezing the last drop of convenience out of ssh-agent: Keychain will allow to reuse an ssh-agent between logins, and optionally prompt for passphrases each time the user logs in.\n$ sudo apt install keychain $ vi ~/.bashrc . ~/.keychain/${HOSTNAME}-sh $ keychain ~/.ssh/id_rsa Default .bashrc You don’t need to trust this random gist on Github. Heck, it’s ~10 years old. Don’t you want the latest default - or the default that’s specific to your version of Ubuntu?\nYou can find the “skeleton” file used to initialize new users in ls -a /etc/skel.\nTo copy someone else’s comment: just run cp /etc/skel/.bashrc ~/ to copy from that “skeleton” to your current bashrc.\nuse ‘cp’ to exclude a specific directory $ shopt -s extglob $ echo images/* images/004.bmp images/033.jpg images/1276338351183.jpg images/2252.png $ echo images/!(*.jpg) images/004.bmp images/2252.png regenerate initramfs To create/recreate/update the initramfs file means to update the initrd.img-* ramdisk files in /boot.\nNote: I prefer to create a totally fresh version by using the -c option, instead of just updating the existing file by using the -u option.\nThe proper command would be:\n$ sudo update-initramfs -c -k $(uname -r) This will create a fresh initrd.img-* file for your currently booted version of Ubuntu.\nHowever, if you can’t boot to the current version of Ubuntu, you may have to modify this command, and by booting to an older version of Ubuntu, you can do it this way:\nsudo update-initramfs -c -k 5.11.0-22-generic where the 5.11.0-22-generic part should be replaced with the version of the desired boot kernel.\nTo get more detailed information, type:\n$ man update-initramfs extract a specific file from a tar archive Yes, just give the full stored path of the file after the tarball name.\nExample: suppose you want file etc/apt/sources.list from etc.tar:\n$ tar -xf etc.tar etc/apt/sources.list repair grub When you install Windows, Windows assumes it is the only operating system (OS) on the machine, or at least it does not account for Linux. So it replaces GRUB with its own boot loader. What you have to do is replace the Windows boot loader with GRUB. I’ve seen various instructions for replacing GRUB by mucking around with GRUB commands or some such, but to me the easiest way is to simply chroot into your install and run update-grub. chroot is great because it allows you to work on your actual install, instead of trying to redirect things here and there. It is really clean.\nDNS缓存 使用以下命令来检查其状态。\n$ sudo systemctl status systemd-resolved 运行以下命令来检查DNS缓存统计信息。\n$ sudo systemd-resolve --statistics 运行以下命令来清除Ubuntu上的DNS缓存。\n$ sudo systemd-resolve --flush-caches DNS刷新命令不会清除缓存命中和未命中统计信息。 如果要清除所有缓存统计信息，则必须重新启动systemd解析的服务。\n$ sudo systemctl restart systemd-resolved change my username Unix-like operating systems decouple the user name from the user identity, so you may safely change the name without affecting the ID. All permissions, files, etc are tied to your identity (uid), not your username.\nTo manage every aspect of the user database, you use the usermod tool.\nTo change username (it is probably best to do this without being logged in):\nsudo usermod -l newUsername oldUsername This however, doesn’t rename the home folder.\nTo change home-folder, use\nsudo usermod -d /home/newHomeDir -m newUsername after you changed the username.\nFor instance, you could logout, drop to a console (Ctrl+Alt+F1), and sudo su - to become true root (as opposed to sudo -s, where $HOME is still /home/yourname.) Maybe you also have to kill some still running processes from this user first. To do so, enter ps -u username, look for the matching PID and kill them by kill PID-number.\nUpdate: as arrange mentioned, some files may reference your old home directory. You can either keep a symlink for backward compatibility, e g ln -s /home/newname /home/oldname or you can change the file contents with sed -i.bak 's/*oldname*/*newname*/g' *list of files* It creates a backup for each file with a .bak extension.\nSome additional information for not so experienced users like me: As I only have ONE user account (administrator), it would not let me change the username (“you are already logged in” was the response in TTY1 (Ctrl+Alt+F1). To get around this:\n  Login with your old credentials and add a new user, e.g. “temporary” in TTY1:\nsudo adduser temporary set the password.\n  Allow the temporary user to run sudo by adding the user to sudo group:\nsudo adduser temporary sudo   Log out with the command exit.\n  Return to tty1: Login with the ‘temporary’ user account and password. Change your username and folder as mentioned above. exit (until you get the login prompt)\n  Go back to TTY7 (Ctrl+Alt+F7) to login on the GUI/normal desktop screen and see if this works.\n  Delete temporary user and folder:\nsudo deluser temporary sudo rm -r /home/temporary   Test Network Speed $ sudo apt install speedtest-cli $ speedtest 蓝牙与WiFi信号干扰 蓝牙和WIFI干扰？把蓝牙掐死就行了\n蓝牙和Wi-Fi信号干扰问题可能你也遇到过，两者主要都是使用2.4GHz频段，导致同时开启时，蓝牙的数据吞吐量会急剧下降，配对设备困难，Wi-Fi间歇性中断，网络受到限制。目前基本没什么办法可以根治这个问题，但你可以下面的方案临时帮你解决一些问题。本文提供了4种方法，可以参考下。\n方法1：连接至5GHz无线网络\n既然知道了问题出在频段冲突上，那么可以考虑购买一个双频（2.4GHz + 5GHz）路由器，并连接至5GHz的Wi-Fi网络。该方法可以彻底解决干扰问题，但银子也是必不可少的。\n方法2：更换Wi-Fi信道\n以TP-Link路由器为例，登录路由器Web管理页，在无线设置-基本设置中找到信道选项，将其改为1、6、11中的任何一个。这些为2.4GHz的不重叠传输信道，相较于其他信道更稳定一些。\n方法3：开启网卡蓝牙共存功能\n在近几年生产的无线网卡中，都支持蓝牙共存功能，方法是在网络适配器属性的高级选项卡中，找到Bluetooth Collaboration或Bluetooth Coexistence Mode（名称可能有所不同），将其设为启用（Enable）。Windows会自动重新连接Wi-Fi，干扰蓝牙的情况也会有所缓解。\n对于 Linux\n$ lspci -knn | grep Net -A3; lsusb ... Kernel driver in use: ath9k Kernel modules: ath9k ... $ sudo tee /etc/modprobe.d/ath9k.conf  \"options ath9k btcoex_enable=1\" 方法4：远离干扰源\n将蓝牙终端与路由器、微波炉、无绳电话机等使用2.4GHz频段的设备隔开使用。\n然而蓝牙与WIFI干扰确实是头疼的问题：蓝牙鼠标会受到WIFI干扰经常反应迟缓，而蓝牙音箱则会导致WIFI断网，经常上传失败的绝望。。。。\n总之，无线信道的改进还在进行着。。。\nRAM \u0026 VRAM VRAM as RAM  MTD vramfs  RAM as VRAM Basically the answer is the operating system threats the whole memory pool for the graphics card, and ram as a virtual memory.\nVirtual memory is paged two ways through a partition like swap, or a image file like in windows.\nThe virtual memory then maps the references to memory when you call int* or \u0026memory. To a physical address on your ram or vram depending on where it’s meant to go.\nThe game cannot force the kernel or operating system to allocate virtual memory to a certain place.\nThe kernel will dynamically decide where everything goes, and will write to your hard drive if you overflow the current physical limit.\nThere are tons of articles on virtual memory on windows, bsd and linux. Mac is technically a bsd fork and does use the same methods, and so does the ps4 os.\ntl;dr Basically what you are saying doesn’t make sense in terms of virtual memory and this is done automatically( Games automatically use RAM as VRAM when you run out of VRAM. That’s why, when you go over your VRAM limit, your FPS drops like a rock ).\nAlso some people in this thread are confusing video memory and virtual memory.\nOptimizing for Gaming This guide is only for Arch and Ubuntu. Any derivatives like Manjaro, Mint, PopOS, etc should also work.\nEnable Multilib Multilib is required by Steam, So if you are running Steam you can skip this step, If you can not find Steam in your repositories this is your issue.\nAdd the architecture.\n$ sudo dpkg --add-architecture i386 Update the package manager\n$ sudo apt-get update Upgrade to newer packages\n$ sudo apt-get dist-upgrade GPU Drivers Having the right GPU drivers is imporant, else games won’t run properly.\nManually check which driver you need: https://www.nvidia.com/Download/index.aspx?lang=en-us\nFor Nvidia you need to add a repository\n$ sudo add-apt-repository ppa:graphics-drivers/ppa \u0026\u0026 sudo apt-get upgrade For Nvidia 440 you need these packages so install them.\n$ sudo apt install nvidia-graphics-drivers-440 nvidia-settings vulkan vulkan-utils Now reboot\n$ sudo reboot If you use Gnome or GDM you might need to disable Wayland, This is not always the case, But I include it here just in case, If your System won’t reboot you can try this\n$ sudo nano /etc/gdm/custom.conf Remove the # in front of the #WaylandEnable=false line and it should force Xorg.\nLinux kernel Installing the newest kernel is generally the easiest kernel switch, There are other kernels available, I will include them later.\nThe easiest way is to use ukuu, First we need to install it.\n$ sudo add-apt-repository ppa:cappelikan/ppa $ sudo apt update $ sudo apt install mainline Now ukuu is installed, in this program you can select the newest stable kernel click install and when you reboot the new kernel is used. Do not remove your old kernel. If anything goes wrong you can select which kernel to boot in the grub screen at startup and remove the kernel that gives you trouble.\nFeral Gamemode gamemode 基本上是一组守护进程/库，它可以按需优化 Linux 系统的游戏性能。它实际上只是让 CPU 在用户玩游戏时自动运行在高性能模式下并帮助 Linux 用户从游戏中获得最佳性能。\n$ sudo apt install gamemode Manual\nInstall the dependencies\n$ sudo apt install meson libsystemd-dev pkg-config ninja-build git libdbus-1-dev libinih-dev Clone the repository\n$ git clone https://github.com/FeralInteractive/gamemode.git Change the directory into the just downloaded folder\n$ cd gamemode Change the tree to the newest version\n$ git checkout 1.5.1 Run the install script\n$ ./bootstrap.sh Usage\nNow that it is installed we need to enable the service with this command\n$ systemctl --user enable gamemoded \u0026\u0026 systemctl --user start gamemoded To use gamemode for supertuxkart for example, run this terminal\n$ gamemoderun supertuxkart To use it in Steam edit the launch option for the desired game to\n$ gamemoderun %command% If gamemode does not run try to make it executable:\n$ sudo chmod +x /usr/bin/gamemoderun If gamemoderun does not work for you try this as a launch command:\n$ LD_PRELOAD=$LD_PRELOAD:/usr/lib/x86_64-linux-gnu/libgamemodeauto.so.0 %command% Nvidia Improvements Nvidia users might want to enable all options listed here to improve performance in games\n Force Full Composition Pipeline avoids screen tearing by letting the GPU do all the scaling. Triple Buffer avoids stuttering gameplay It allows for a stream of data instead of chunks of data. IndirectGLXProtocol forces the game to directly communicate with the Nvidia drivers. Coolbits enables your card to be overclocked which gamemode will make use of.  Create a Xorg Config file:\n$ sudo nvidia-xconfig Edit the file with the following command\n$ sudo nano /etc/X11/xorg.conf Add in these lines under the “Device” section between the other options\nOption \"TripleBuffer\" \"on\" Option \"Coolbits\" \"28\" Add in these lines under the “Screen” section between the other options.\nOption \"metamodes\" \"nvidia-auto-select +0+0 {ForceCompositionPipeline=On, ForceFullCompositionPipeline=On}\" Option \"AllowIndirectGLXProtocol\" \"off\" Try this one with risk, It will be sure to crash GNOME, I am not sure about other DEs\njust add it to the end of the file\nSection \"Extensions\" Option \"Composite\" \"Disable\" EndSection If you run into any problems, just hit CTRL ALT F3 to switch to a different tty login, run the command to edit the file again and put a # in front of the options that are giving you trouble, Most likely the last one\nAlternatively you can just completely remove the file with the following command\n$ sudo rm /etc/X11/xorg.conf Libstrangle Libstrangle is a tool that helps you control framerates but also vsync settings. This is especially handy for games that do not support these features, You would like to half your framerate to make it run better save some power or just give your hardware a break.\nLibstrangle can be used in multiple ways depending on what you want to achieve.\nTo use libstrangle you can simply type strangle and then the amount of frames you want to run. There are some examples below, But the features you will probably use are Vsync which you use by using the -v option, the rules for OpenGL and Vulkan are different, Here is what each number does for the different apis.\n OpenGL 0 Force off, 1 Force on, n - Sync to refresh rate Vulkan 0 Force off, 1 Mailbox mode, 2 Traditional vsync, 3 Adaptive vsync  You can also limit the game depending on the power state of your device, Set it to 60 while charging and on 30 while discharging for example. You do this by adding a second number right after a colon. in example, strangle 60:30. There are more features but they are not that commonly used, you can check the gitlab link above or simply type strangle -h for more information.\nTo limit the framerate of supertuxkart to 30 simply run\n$ strangle 30 supertuxkart To Force enable vsync on 60 fps for an OpenGL Steam game set the launch option to\n$ strangle -v 1 60 %command% To set the framerate of a vulkan game on Steam to 120 fps but 60 on battery power with adaptive vsync set this as your launch command\n$ strangle -v 3 120:60 %command% Mangohud Mangohud is a monitoring tool for Vulkan and OpenGL applications. It can show CPU and GPU usage, temps, But also framerates, frametimes and a lot more.\n$ sudo add-apt-repository ppa:flexiondotorg/mangohud $ sudo apt update $ sudo apt install mangohud To configure it with a GUI you can check out GOverlay below. For a manual configuration you can edit\n$ ~/.config/MangoHud/MangoHud.conf If you want exactly my configuration you can just copy this into it without the need for GOverlay.\nbackground_alpha=0.3 font_size=20 background_color=020202 text_color=ffffff position=top-right no_display toggle_hud=F11 cpu_stats cpu_temp cpu_color=007AFA gpu_stats gpu_temp gpu_color=00BD00 ram ram_color=B3000A vram vram_color=00801B io_read io_write io_color=B84700 arch engine_color=B200B0 frame_timing=1 frametime_color=00ff00 #output_file=/home/houtworm/mangohud_log_  #fps_limit 120 #media_player #toggle_logging=F10 You can tweak all the little things you want here. You can also create different configurations per game by adding a MangoHud.conf file to the game directory.\nTo use it for any game change its launch option to\n$ mangohud %command% To use it with non Steam games use the following command\n$ mangohud supertuxkart Some games might need the 32 bit version, try this if the normal command fails.\n$ mangohud.x86 %command% VKBasalt VKBasalt is a post processing layer for Vulkan which enables you to enhance graphics further. It only works with Vulkan, This includes all Proton games.\n$ git clone https://github.com/DadSchoorse/vkBasalt.git \u0026\u0026 cd vkBasalt \u0026\u0026 meson --buildtype=release builddir \u0026\u0026 ninja -C builddir install To configure it first you need to create a config file, Run the following command to copy the example to a folder you can edit as the user.\n$ mkdir ~/.config/vkBasalt \u0026\u0026 cp /usr/share/vkBasalt/vkBasalt.conf.example ~/.config/vkBasalt/vkBasalt.conf You can tweak all the little things you want here. You can also create different configurations per game by adding a vkBasalt.conf file to the game directory.\nTo use VKBasalt for any particular game enter this as a launch option.\nENABLE_VKBASALT=1 %command% You can also start non Steam games this way by typing the following command\nENABLE_VKBASALT=1 supertuxkart GOverlay GOverlay is a Graphical User Interface for managing MangoHud and VKBasalt\n$ sudo apt-get install lazarus git $ git clone https://github.com/benjamimgois/goverlay.git $ cd goverlay $ lazbuild -B goverlay.lpi mesa-demos and vulkan-tools are optional, You need them if you want to show the previews. You can find them in your distros repository\nXbox One Controller xpad works great, is the default on modern Linux distros and supports a wide range of controllers, But if you are like me and you only Xbox One controllers then using xpadneo is much better.\nFor Bluetooth to work with xpad and the Xbox One controllers you need to disable ertm (This is not needed for xpadneo)\ncreate the config file\n$ sudo nano /etc/modprobe.d/xbox_bt.conf Add the following line to the document and save and exit with CTRL + X.\noptions bluetooth disable_ertm=1 xpadneo supports Xbox One controllers wired and over bluetooth, It enables Force Feedback even the vibration inside the triggers, It supports battery level indication, It also fixes the mapping in many many games that where previously unplayable with a Xbox One controller on Linux.\nInstall the dependencies\n$ sudo apt-get install dkms linux-headers-`uname -r` Install xpadneo from Github\n$ git clone https://github.com/atar-axis/xpadneo.git \u0026\u0026 cd xpadneo \u0026\u0026 sudo ./install.sh Now you should be able to reboot and it should be all good, Having the controllers vibrate for a second when connected is a good indicator that it works.\n认证硬件  Ubuntu certified hardware Red Hat certified hardware  如果不怎么玩游戏的话，建议是直接考虑那些不带独立显卡的笔记本电脑。因为在Linux下双显卡装驱动问题很多。\n说到牌子的话，建议是考虑戴尔笔记本。因为戴尔台式机和笔记本，都是尽可能地去兼容Ubuntu来设计的。这个不是说假话做广告。我也就这个问题，看过了几乎所有戴尔系列产品的技术文档了。基本上都是在支持的操作系统列表中，无一例外地包含了Ubuntu。如果是想买能完美使用Ubuntu的本子，戴尔是首选。戴尔绝大部分笔记本机型都能很好完美兼容Ubuntu。\n还有一个重要原因就是，ubuntu的所属公司，与戴尔公司是有合作的。也正因为如此，Ubuntu默认就包含了dell的大部分硬件通用驱动，甚至硬件底层管理模块都囊括其中。\n功耗控制 针对散热不好的设备或者续航能力不佳的笔记本，功耗控制显得非常必要\n使用 TLP 延长电池寿命及续航  如有需要可参阅 TLP 官方文档 和 archwiki TLP。\n 多年来，Linux 在电池优化方面取得了很大进步，但仍然有一些可选步骤改善笔记本电脑的电池寿命并且延长续航。\nTLP 作为一款自由开源的高级电源管理工具提供开箱即用的默认配置。同时也可以高度定制化，以满足特定需求。\n电压下探  以下方法仅适用于 Intel 四代酷睿 ™ Haswell 及更新 CPU。有关 AMD CPU 和 Intel 四代酷睿 ™ Haswell 之前的 CPU 请参考 archWiki Undervolting CPU。\n 对处理器的电压进行最大限度的下探，在挖掘 CPU 体质的极限的同时，起到既能降低发热，又能最大限度保持性能的效果。\n如果正常操作，降低电压一般不会损害 CPU，一般建议从 50 毫伏进行尝试，每次降压尝试多增加 10 毫伏。只要确保在降低电压前，系统中任务均被正确保存即可。\n降低功率墙 除了电压的下探，同时也可以尝试对处理器的功率墙（TDP）做出降低的限制。比如考虑这种情况 —— 在 CPU 满睿频时，其实不需要默认的那么多功耗来维持，也许在默认功耗的基础上减几瓦，也能维持满睿频，这样就又可以进一步降低温度。对功率墙进行限制不同于对电压进行下探，若限制功率墙的参数较低，这会不可避免的损失较多的性能，但是在散热过差的设备上这也是一个好办法。\n对于功率墙的调整，有些主板在 BIOS 中提供了设置项可以直接调整。对于没有设置项的主板，有的主板是锁定了瞬时和长时功率墙，这种情况就无法调整功率墙了。有的主板 BIOS 随没有提供功率墙调整项，但依旧可以通过命令行设置。\n通过以下的命令可以查看主板是否可以调整功率墙：\ngrep . /sys/class/powercap/intel-rapl/intel-rapl:0/* 2 /dev/null 如果在输出中看到了如下的 enabled 值为 1，即可以调整。第一行的数字代表现有的功率墙限制：\n/sys/class/powercap/intel-rapl/intel-rapl:0/constraint_0_power_limit_uw:100000000 /sys/class/powercap/intel-rapl/intel-rapl:0/enabled:1 具体的调整步骤参考 Set Max TDP of Intel H-series CPU。\n交换文件 在桌面环境中，交换分区或文件用来实现休眠(hibernate)的功能，即将当前环境保存在磁盘的交换文件或分区部分。除此之外，某些特定软件需要 swap 才可以正确运行。交换文件与分区性能相同，且交换文件更为灵活，可随时变更大小，增加与删除。\n$ dd if=/dev/zero of=/swapfile bs=1M count=4096 status=progress #创建4G的交换空间 大小根据需要自定 $ chmod 600 /swapfile #设置正确的权限 $ mkswap /swapfile #格式化swap文件 $ swapon /swapfile #启用swap文件 最后，向/etc/fstab 中追加如下内容：\n/swapfile none swap defaults 0 0 KDE 自身提供开箱即用的睡眠功能(suspend)，即将系统挂起到内存，消耗少量的电量。休眠(hibernate)会将系统挂起到交换分区或文件，几乎不消耗电量。\nQUESTIONS Ubuntu 无法关机 $ sudo vim /etc/systemd/system.conf DefaultTimeoutStartSec=5s DefaultTimeoutStopSec=5s $ sudo systemctl reload DefaultTimeoutStartSec=, DefaultTimeoutStopSec= 设置启动/停止一个单元所允许的最大时长。若仅设置一个整数而没有单位，那么单位是秒。 也可以在整数后面加上时间单位后缀： “ms”(毫秒), “s”(秒), “min”(分钟), “h”(小时), “d”(天), “w”(周) 。 对于 Type=oneshot 类型的 service 单元， 这些选项没有意义(相当于全部被禁用)。 对于其他类型的 service 单元，可以在单元文件中设置 TimeoutStartSec=, TimeoutStopSec=, RestartSec= 以覆盖此处设置的默认值 (参见systemd.service(5))。 对于其他非 service 类型的单元， DefaultTimeoutStartSec= 是 TimeoutSec= 的默认值。\n注1：尽量不要使用上面更改。应该在完全清楚自己的更改造成的影响、产生的作用的前提下，做出更改。\n注2：作为桌面操作系统，如果有硬件驱动或其他各种莫名问题，可以尝试升级到最新版本来解决。\nACPI ERROR: AE_ALREADY_EXISTS These kinds of “errors” have been discussed ad nauseam, it’s simply the kernel telling you that the ACPI information received from the system seems to be incomplete in some way, update your BIOS/UEFI in hopes for a proper fix or ignore the error if you don’t notice anything off with your system.\n(And please don’t do something dumb like setting acpi=off just to get rid of these messages)\n解压zip乱码 $ unzip -O CP936 xxx.zip 用GBK, GB18030也可以\nCan’t run CS:GO at fullscreen  Open Steam Go to the “Library” Right-click the game which needs to be reconfigured Select “Properties” from the menu Click the “Set launch options…” button type: -full and save  How To Disable Lock In Kubuntu open Workspace  Desktop Behavior  Screen Locking  uncheck Lock screen option\nGnome 3 displays two icons for same app No, there’s nothing wrong with your system.\nThe duplicated launcher icons explained:\nThe different icons are different commandline options. Some context applications with call the associated *.desktop icon. The exec option of the icon will depend on how the application is called.\nSome of the Icons you show in your image may be obvious because of the difference in the way they are named. You can see the difference in the way the app is called by right clicking and clicking on properties to see other differences.\nSome of the *.desktop files have a %U argument, used so the application will accept arguments.\nSome of the Launchers are different commands that are called differently and are named differently often by a symbolic link.\nSome exampes from the list in you image are:\nName: Online Accounts Command: unity-control-center credentials Name: Online Accounts Command: Online account credentials and settings Name: Personal File Sharing Command: gnome-file-share-properties Name: Rhythmbox Command: rhythmbox %U Name: Rhythmbox Command rhythmbox-client --select-source %U ssh_exchange_identification: Connection closed by remote host 原因是 Clash 开了 TUN 模式。关闭掉就好了。\nDisk show 129986 TB  (=ↀωↀ=)橘外猫, [2/7/22 11:16 AM] 这个是怎么回事啊\n雪梨, [2/7/22 11:21 AM] 分区表坏了？\n(=ↀωↀ=)橘外猫, [2/7/22 11:21 AM] 直接再分区吗？\n雪梨, [2/7/22 11:21 AM] 请鸽鱼老师看看诶\n雪梨, [2/7/22 11:22 AM] 还能挂载就先备份数据好了\n(=ↀωↀ=)橘外猫, [2/7/22 11:22 AM] 好的\nPegion Fish, [2/7/22 11:25 AM] JMS炸了？ 建议备份数据重建分区表 先重新插一次USB和硬盘\n(=ↀωↀ=)橘外猫, [2/7/22 11:27 AM] 重插了 用fdisk 重建吗？\nPegion Fish, [2/7/22 11:28 AM] 还是不正常？ 硬盘也重新插一下\n(=ↀωↀ=)橘外猫, [2/7/22 11:28 AM] 恩\n雪梨, [2/7/22 11:28 AM] 重建分区表，不是删掉分区再新增分区\n(=ↀωↀ=)橘外猫, [2/7/22 11:30 AM] 断电后自动好了 这是怎么回事啊\nThor Luo Bing-, [2/7/22 11:31 AM] 硬盘清空了\n(=ↀωↀ=)橘外猫, [2/7/22 11:32 AM] 没有，东西还在\nPegion Fish, [2/7/22 11:32 AM] 啊 这不是争产的吗 1T啊 这就是JMS主控抽风\n No Caching mode page found during early boot, I get following error message:\n[sdb] No Caching mode page found [sdb] Assuming drive cache: write through If I understand correctly, this is actually just a harmless info message and not an actual error. sdb is my USB disk, and it does not use caching .\nHard disks have a small amount of RAM cache to speed up write operations. The system can write a chunk of data to the disk cache without actually waiting for it to be written to the disk. This is sometimes called “write-back” mode. If there is no cache on the disk, data is directly written to it in “write-through” mode. The Asking for cache data failed warning usually occurs with devices such as USB flash drives, USB card readers, etc. which present themselves as SCSI devices to the system (sdX), but have no cache. The system asks the device: “Do you have a cache?” and gets no response. So it assumes there is no cache and puts it in “write-through” mode.\nCertificate verification failed 首先更改源文件，将所有的 https 改成 http ：\n$ sudo vi /etc/apt/sources.list deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse 1234 然后安装/更新证书 ca-certificates：\n$ sudo apt-get update $ sudo apt-get install --reinstall ca-certificates 最后将镜像源文件改回 https：\n$ sudo vi /etc/apt/sources.list deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse $ sudo apt-get update Move and overwrite subdirectories (and files) to parent directory You will have to copy them to the destination and then delete the source, using the commands cp -r * .. followed by rm -rf *.\nI don’t think you can “merge” directories using mv.\nSystem program problem detected The error “System program problem detected” comes up when a certain application crashes. Ubuntu has a program called Apport that is responsible for detecting such crashes and upon user consent, report these crashes to developers. This process intends to get the problem fixed by the developers.\nHowever it can be very annoying to common users, and there is no point in showing errors to users when they cannot do anything about it themselves. So you might want to disable them.\nRemove crash report files\nThe apport system creates crash report files in the /var/crash directory. These crash report files cause the error message to appear everytime Ubuntu boots.\n$ cd /var/crash $ ls _opt_google_chrome_chrome.1000.crash _usr_lib_chromium-browser_chromium-browser.1000.crash _usr_sbin_ulatencyd.0.crash _usr_share_apport_apport-gtk.1000.crash Just remove the crash report files\n$ sudo rm /var/crash/* After removing all the crash report files, the error message should stop popping up. However if a new crash takes place then it would appear again in future.\nTurn off apport\nAfter removing the old crash reports, if you still get the same error message, then you can completely turn off apport to get rid. Edit the configuration file at /etc/default/apport.\n$ gksudo gedit /etc/default/apport The file would contain something like this\n# set this to 0 to disable apport, or to 1 to enable it # you can temporarily override this with # sudo service apport start force_start=1 enabled=1 Just set the value of enabled to 0, and this will disable apport.\nenabled=0 Save the file and close it. From the next boot onwards, there should be no error messages ever. If you do not want to restart the system then restart apport from the command line.\n$ sudo restart apport ",
  "wordCount" : "290567",
  "inLanguage": "en",
  "datePublished": "2021-12-12T16:52:44+08:00",
  "dateModified": "2021-12-12T16:52:44+08:00",
  "author":{
    "@type": "Person",
    "name": "Sakamoto Kurome"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://sakamotokurome.github.io/posts/ubuntu/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Sakamoto Kurome",
    "logo": {
      "@type": "ImageObject",
      "url": "https://sakamotokurome.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://sakamotokurome.github.io/" accesskey="h" title="Sakamoto Kurome (Alt + H)">Sakamoto Kurome</a>
            <span class="logo-switches">
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://sakamotokurome.github.io/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://sakamotokurome.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://sakamotokurome.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Ubuntu
    </h1>
    <div class="post-meta"><span title='2021-12-12 16:52:44 +0800 CST'>December 12, 2021</span>&nbsp;·&nbsp;580 min&nbsp;·&nbsp;Sakamoto Kurome

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e5%ad%a6%e4%b9%a0-linux-%e5%87%a0%e7%82%b9%e5%bf%a0%e5%91%8ahttpswikiubuntuorgcne5ada6e4b9a0_linux_e587a0e782b9e5bfa0e5918a" aria-label="学习 Linux 几点忠告"><a href="https://wiki.ubuntu.org.cn/%E5%AD%A6%E4%B9%A0_Linux_%E5%87%A0%E7%82%B9%E5%BF%A0%E5%91%8A">学习 Linux 几点忠告</a></a></li>
                <li>
                    <a href="#settings" aria-label="Settings">Settings</a><ul>
                        
                <li>
                    <a href="#dns" aria-label="DNS">DNS</a></li>
                <li>
                    <a href="#others" aria-label="Others">Others</a></li></ul>
                </li>
                <li>
                    <a href="#softwareupdates" aria-label="SoftWare&amp;amp;Updates">SoftWare&amp;Updates</a></li>
                <li>
                    <a href="#input-method-editor" aria-label="Input Method Editor">Input Method Editor</a><ul>
                        
                <li>
                    <a href="#ibus" aria-label="IBus">IBus</a></li>
                <li>
                    <a href="#fcitx-4" aria-label="Fcitx 4">Fcitx 4</a></li>
                <li>
                    <a href="#fcitx-5httpsfcitx-imorgwikifcitx_5" aria-label="Fcitx 5"><a href="https://fcitx-im.org/wiki/Fcitx_5">Fcitx 5</a></a></li></ul>
                </li>
                <li>
                    <a href="#automatically-switch-wallpapers" aria-label="Automatically switch wallpapers">Automatically switch wallpapers</a><ul>
                        
                <li>
                    <a href="#apps" aria-label="Apps">Apps</a></li>
                <li>
                    <a href="#unsplashhttpsyounessnetlinuxset-random-wallpapers-unsplash-com-ubuntu" aria-label="unsplash"><a href="https://youness.net/linux/set-random-wallpapers-unsplash-com-ubuntu">unsplash</a></a></li>
                <li>
                    <a href="#wallhaven" aria-label="wallhaven">wallhaven</a></li>
                <li>
                    <a href="#astronomyhttpsapinasagov" aria-label="Astronomy"><a href="https://api.nasa.gov/">Astronomy</a></a></li></ul>
                </li>
                <li>
                    <a href="#social" aria-label="Social">Social</a><ul>
                        
                <li>
                    <a href="#telegramhttpswwwnotionsotelegram-95a6c23f0bb1466892b55f9ec8c755fd" aria-label="Telegram"><a href="https://www.notion.so/Telegram-95a6c23f0bb1466892b55f9ec8c755fd">Telegram</a></a><ul>
                        
                <li>
                    <a href="#%e7%ae%80%e4%bb%8b" aria-label="简介">简介</a></li>
                <li>
                    <a href="#%e6%8e%a8%e8%8d%90%e8%ae%be%e7%bd%ae" aria-label="推荐设置">推荐设置</a></li>
                <li>
                    <a href="#%e9%9a%90%e7%a7%81%e4%bf%9d%e6%8a%a4%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9" aria-label="隐私保护注意事项">隐私保护注意事项</a></li>
                <li>
                    <a href="#%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98%e5%8f%8a%e8%a7%a3%e7%ad%94" aria-label="常见问题及解答">常见问题及解答</a></li>
                <li>
                    <a href="#%e8%bf%9b%e9%98%b6%e7%9f%a5%e8%af%86" aria-label="进阶知识">进阶知识</a></li>
                <li>
                    <a href="#%e4%b8%bb%e9%a2%98%e4%b8%8e%e7%be%8e%e5%8c%96" aria-label="主题与美化">主题与美化</a></li>
                <li>
                    <a href="#sticker-packhttpsblogphoenixlzxcom20150606make-telegram-sticker-the-lazy-way" aria-label="Sticker Pack"><a href="https://blog.phoenixlzx.com/2015/06/06/make-telegram-sticker-the-lazy-way/">Sticker Pack</a></a></li>
                <li>
                    <a href="#%e5%9c%a8telegram%e4%b8%8a%e4%bd%bf%e7%94%a8efb%e5%90%8c%e6%97%b6%e6%8e%a8%e9%80%81qq%e4%b8%8e%e5%be%ae%e4%bf%a1%e6%b6%88%e6%81%afhttpswwwshawnleettttxyzpostsf1bc687a" aria-label="在Telegram上使用EFB同时推送QQ与微信消息"><a href="https://www.shawnleetttt.xyz/posts/f1bc687a/">在Telegram上使用EFB同时推送QQ与微信消息</a></a><ul>
                        
                <li>
                    <a href="#%e4%ba%8b%e5%89%8d%e5%87%86%e5%a4%87" aria-label="事前准备">事前准备</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8efb%e8%bd%ac%e5%8f%91%e5%be%ae%e4%bf%a1%e6%b6%88%e6%81%af" aria-label="使用EFB转发微信消息">使用EFB转发微信消息</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8efb%e8%bd%ac%e5%8f%91qq%e6%b6%88%e6%81%af" aria-label="使用EFB转发QQ消息">使用EFB转发QQ消息</a></li>
                <li>
                    <a href="#%e9%97%ae%e9%a2%98%e5%8f%91%e7%8e%b0%e5%8f%8a%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88" aria-label="问题发现及解决方案">问题发现及解决方案</a></li>
                <li>
                    <a href="#%e5%8f%82%e8%80%83%e9%93%be%e6%8e%a5" aria-label="参考链接">参考链接</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#mutthttpssegmentfaultcoma1190000018131615" aria-label="Mutt"><a href="https://segmentfault.com/a/1190000018131615">Mutt</a></a><ul>
                        
                <li>
                    <a href="#%e6%a8%a1%e5%9d%97%e6%90%ad%e9%85%8d%e6%96%b9%e6%a1%88" aria-label="模块搭配方案">模块搭配方案</a></li>
                <li>
                    <a href="#%e6%94%b6%e4%bb%b6%e9%85%8d%e7%bd%aefetchmailhttpswwwlinodecomdocsguidesusing-fetchmail-to-retrieve-email" aria-label="收件：配置Fetchmail"><a href="https://www.linode.com/docs/guides/using-fetchmail-to-retrieve-email/">收件：配置Fetchmail</a></a></li>
                <li>
                    <a href="#%e9%82%ae%e4%bb%b6%e8%bf%87%e6%bb%a4%e9%85%8d%e7%bd%aeprocmailhttpslifegoopluskidorgwikiprocmailhtml" aria-label="邮件过滤：配置Procmail"><a href="https://lifegoo.pluskid.org/wiki/Procmail.html">邮件过滤：配置Procmail</a></a></li>
                <li>
                    <a href="#%e5%8f%91%e4%bb%b6%e9%85%8d%e7%bd%aemsmtp" aria-label="发件：配置msmtp">发件：配置msmtp</a></li>
                <li>
                    <a href="#%e4%b8%bb%e7%95%8c%e9%9d%a2%e9%85%8d%e7%bd%aemutt" aria-label="主界面：配置Mutt">主界面：配置Mutt</a></li>
                <li>
                    <a href="#%e7%a1%ae%e8%ae%a4%e9%82%ae%e7%ae%b1%e6%9c%8d%e5%8a%a1%e5%99%a8" aria-label="确认邮箱服务器">确认邮箱服务器</a></li>
                <li>
                    <a href="#%e5%9f%ba%e6%9c%ac%e6%93%8d%e4%bd%9chttpslifehackercomhow-to-use-the-fast-and-powerful-mutt-email-client-with-5574557" aria-label="基本操作"><a href="https://lifehacker.com/how-to-use-the-fast-and-powerful-mutt-email-client-with-5574557">基本操作</a></a></li></ul>
                </li>
                <li>
                    <a href="#irchttpswwwcnblogscomsztomp11173404html" aria-label="IRC"><a href="https://www.cnblogs.com/sztom/p/11173404.html">IRC</a></a><ul>
                        
                <li>
                    <a href="#%e7%ae%80%e4%bb%8bhttpsenwikipediaorgwikiinternet_relay_chat" aria-label="简介"><a href="https://en.wikipedia.org/wiki/Internet_Relay_Chat">简介</a></a></li>
                <li>
                    <a href="#%e6%9c%8d%e5%8a%a1%e5%99%a8" aria-label="服务器">服务器</a></li>
                <li>
                    <a href="#%e5%ae%a2%e6%88%b7%e7%ab%af" aria-label="客户端">客户端</a></li>
                <li>
                    <a href="#irssihttpssegmentfaultcoma1190000018120591" aria-label="Irssi"><a href="https://segmentfault.com/a/1190000018120591">Irssi</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#multimedia" aria-label="Multimedia">Multimedia</a><ul>
                        
                <li>
                    <a href="#pipewirehttpspipewireorg" aria-label="Pipewire"><a href="https://pipewire.org/">Pipewire</a></a></li>
                <li>
                    <a href="#rhythmbox" aria-label="Rhythmbox">Rhythmbox</a><ul>
                        
                <li>
                    <a href="#feeluownhttpsgithubcomfeeluownfeeluown" aria-label="FeelUOwn"><a href="https://github.com/feeluown/FeelUOwn">FeelUOwn</a></a></li></ul>
                </li>
                <li>
                    <a href="#spotify" aria-label="Spotify">Spotify</a><ul>
                        
                <li>
                    <a href="#spotifydhttpsgithubcomspotifydspotifyd" aria-label="Spotifyd"><a href="https://github.com/Spotifyd/spotifyd">Spotifyd</a></a></li></ul>
                </li>
                <li>
                    <a href="#neteasemusichttpsmusic163com" aria-label="NeteaseMusic"><a href="https://music.163.com/">NeteaseMusic</a></a><ul>
                        
                <li>
                    <a href="#yesplaymusichttpsgithubcomqier222yesplaymusic" aria-label="YesPlayMusic"><a href="https://github.com/qier222/YesPlayMusic">YesPlayMusic</a></a></li>
                <li>
                    <a href="#netease-musicboxhttpsgithubcomdarknessomimusicbox" aria-label="NetEase-MusicBox"><a href="https://github.com/darknessomi/musicbox">NetEase-MusicBox</a></a></li>
                <li>
                    <a href="#lx-music-desktophttpsgithubcomlyswhutlx-music-desktop" aria-label="lx-music-desktop"><a href="https://github.com/lyswhut/lx-music-desktop">lx-music-desktop</a></a></li>
                <li>
                    <a href="#listen1_desktophttpsgithubcomlisten1listen1_desktop" aria-label="listen1_desktop"><a href="https://github.com/listen1/listen1_desktop">listen1_desktop</a></a></li>
                <li>
                    <a href="#qqmusichttpsyqqcom" aria-label="QQMusic"><a href="https://y.qq.com/">QQMusic</a></a></li></ul>
                </li>
                <li>
                    <a href="#pulseaudiohttpswikiarchlinuxorgtitlepulseaudio_e7ae80e4bd93e4b8ade69687" aria-label="PulseAudio"><a href="https://wiki.archlinux.org/title/PulseAudio_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">PulseAudio</a></a><ul>
                        
                <li>
                    <a href="#%e9%85%8d%e7%bd%ae" aria-label="配置">配置</a></li>
                <li>
                    <a href="#%e5%90%af%e5%8a%a8" aria-label="启动">启动</a><ul>
                        
                <li>
                    <a href="#%e5%9c%a8%e4%b8%8d%e6%94%af%e6%8c%81%e7%9a%84%e6%a1%8c%e9%9d%a2%e7%8e%af%e5%a2%83%e4%b8%ad%e8%87%aa%e5%8a%a8%e5%90%af%e5%8a%a8" aria-label="在不支持的桌面环境中自动启动">在不支持的桌面环境中自动启动</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%90%8e%e7%ab%af%e8%ae%be%e7%bd%ae" aria-label="后端设置">后端设置</a><ul>
                        
                <li>
                    <a href="#alsa" aria-label="ALSA">ALSA</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%9d%87%e8%a1%a1%e5%99%a8" aria-label="均衡器">均衡器</a><ul>
                        
                <li>
                    <a href="#%e5%8a%a0%e8%bd%bd%e5%9d%87%e8%a1%a1%e5%99%a8%e9%80%9a%e9%81%93%e5%92%8cdbus%e5%8d%8f%e8%ae%ae%e6%a8%a1%e5%9d%97" aria-label="加载均衡器通道和dbus协议模块">加载均衡器通道和dbus协议模块</a></li>
                <li>
                    <a href="#%e5%ae%89%e8%a3%85%e5%b9%b6%e8%bf%90%e8%a1%8c%e5%9b%be%e5%bd%a2%e5%89%8d%e7%ab%af" aria-label="安装并运行图形前端">安装并运行图形前端</a></li>
                <li>
                    <a href="#%e6%af%8f%e6%ac%a1%e5%90%af%e5%8a%a8%e6%97%b6%e5%8a%a0%e8%bd%bd%e5%9d%87%e8%a1%a1%e5%99%a8%e5%92%8cdbus%e6%a8%a1%e5%9d%97" aria-label="每次启动时加载均衡器和dbus模块">每次启动时加载均衡器和dbus模块</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#ffmpeghttpswwwruanyifengcomblog202001ffmpeghtml" aria-label="FFmpeg"><a href="https://www.ruanyifeng.com/blog/2020/01/ffmpeg.html">FFmpeg</a></a><ul>
                        
                <li>
                    <a href="#%e5%b8%b8%e7%94%a8%e5%8f%82%e6%95%b0" aria-label="常用参数">常用参数</a></li>
                <li>
                    <a href="#%e6%9f%a5%e7%9c%8b%e8%a7%86%e9%a2%91%e6%96%87%e4%bb%b6%e7%9a%84%e5%85%83%e4%bf%a1%e6%81%af" aria-label="查看视频文件的元信息">查看视频文件的元信息</a></li>
                <li>
                    <a href="#%e8%bd%ac%e6%8d%a2%e7%bc%96%e7%a0%81%e6%a0%bc%e5%bc%8f" aria-label="转换编码格式">转换编码格式</a></li>
                <li>
                    <a href="#%e8%bd%ac%e6%8d%a2%e5%ae%b9%e5%99%a8%e6%a0%bc%e5%bc%8f" aria-label="转换容器格式">转换容器格式</a></li>
                <li>
                    <a href="#%e6%94%b9%e5%8f%98%e5%88%86%e8%be%a8%e7%8e%87" aria-label="改变分辨率">改变分辨率</a></li>
                <li>
                    <a href="#%e6%8f%90%e5%8f%96%e8%a7%86%e9%a2%91" aria-label="提取视频">提取视频</a></li>
                <li>
                    <a href="#%e6%8f%90%e5%8f%96%e9%9f%b3%e9%a2%91" aria-label="提取音频">提取音频</a></li>
                <li>
                    <a href="#%e6%b7%bb%e5%8a%a0%e9%9f%b3%e8%bd%a8" aria-label="添加音轨">添加音轨</a></li>
                <li>
                    <a href="#%e9%9f%b3%e8%a7%86%e9%a2%91%e5%90%88%e6%88%90" aria-label="音视频合成">音视频合成</a></li>
                <li>
                    <a href="#%e6%88%aa%e5%9b%be" aria-label="截图">截图</a></li>
                <li>
                    <a href="#%e8%a3%81%e5%89%aa" aria-label="裁剪">裁剪</a></li>
                <li>
                    <a href="#%e6%b7%bb%e5%8a%a0%e5%ad%97%e5%b9%95httpswwwjianshucompf33910818a1c" aria-label="添加字幕"><a href="https://www.jianshu.com/p/f33910818a1c">添加字幕</a></a></li>
                <li>
                    <a href="#%e4%b8%8b%e8%bd%bd-m3u8httpswww51ctocomarticle558658html" aria-label="下载 m3u8"><a href="https://www.51cto.com/article/558658.html">下载 m3u8</a></a></li></ul>
                </li>
                <li>
                    <a href="#mpvhttpsmpviomanual" aria-label="MPV"><a href="https://mpv.io/manual/">MPV</a></a><ul>
                        
                <li>
                    <a href="#osc-%e7%95%8c%e9%9d%a2" aria-label="OSC 界面">OSC 界面</a></li>
                <li>
                    <a href="#%e5%bf%ab%e6%8d%b7%e9%94%aehttpswwwiplaysoftcommpvhtml" aria-label="快捷键"><a href="https://www.iplaysoft.com/mpv.html">快捷键</a></a></li>
                <li>
                    <a href="#%e9%85%8d%e7%bd%aehttpshooke007githubiompv-lazympvhtml" aria-label="配置"><a href="https://hooke007.github.io/mpv-lazy/mpv.html">配置</a></a></li></ul>
                </li>
                <li>
                    <a href="#shotcuthttpswwwshotcutorgdownload" aria-label="Shotcut"><a href="https://www.shotcut.org/download/">Shotcut</a></a></li>
                <li>
                    <a href="#davinci-resolvehttpwwwblackmagicdesigncomcnproductsdavinciresolve" aria-label="DaVinci Resolve"><a href="http://www.blackmagicdesign.com/cn/products/davinciresolve/">DaVinci Resolve</a></a></li>
                <li>
                    <a href="#mkvtoolnixhttpsmkvtoolnixdownloaddownloadshtml" aria-label="MKVToolNix"><a href="https://mkvtoolnix.download/downloads.html">MKVToolNix</a></a></li>
                <li>
                    <a href="#vlchttpswwwvideolanorg" aria-label="VLC"><a href="https://www.videolan.org/">VLC</a></a></li></ul>
                </li>
                <li>
                    <a href="#download" aria-label="Download">Download</a><ul>
                        
                <li>
                    <a href="#aria2httpsaria2githubio" aria-label="Aria2"><a href="https://aria2.github.io/">Aria2</a></a><ul>
                        
                <li>
                    <a href="#usage" aria-label="Usage">Usage</a></li>
                <li>
                    <a href="#configurat-ionhttparia2ccomusagehtml" aria-label="Configurat ion"><a href="http://aria2c.com/usage.html">Configurat ion</a></a></li>
                <li>
                    <a href="#protocolhttpszhuanlanzhihucomp85652893" aria-label="Protocol"><a href="https://zhuanlan.zhihu.com/p/85652893">Protocol</a></a></li>
                <li>
                    <a href="#others-1" aria-label="Others">Others</a></li></ul>
                </li>
                <li>
                    <a href="#youtube-dlhttpsgithubcomytdl-orgyoutube-dl" aria-label="youtube-dl"><a href="https://github.com/ytdl-org/youtube-dl">youtube-dl</a></a><ul>
                        
                <li>
                    <a href="#usagehttpszhuanlanzhihucomp105141332" aria-label="Usage"><a href="https://zhuanlan.zhihu.com/p/105141332">Usage</a></a></li>
                <li>
                    <a href="#configurationhttpswwwjianshucomp5143faa6056d" aria-label="Configuration"><a href="https://www.jianshu.com/p/5143faa6056d">Configuration</a></a></li></ul>
                </li>
                <li>
                    <a href="#curlhttpwwwruanyifengcomblog201909curl-referencehtml" aria-label="curl"><a href="http://www.ruanyifeng.com/blog/2019/09/curl-reference.html">curl</a></a><ul>
                        
                <li>
                    <a href="#%e7%ae%80%e4%bb%8b-1" aria-label="简介">简介</a></li>
                <li>
                    <a href="#%e4%b8%bb%e8%a6%81%e5%91%bd%e4%bb%a4%e8%a1%8c%e5%8f%82%e6%95%b0" aria-label="主要命令行参数">主要命令行参数</a></li>
                <li>
                    <a href="#httpiehttpsgithubcomhttpiehttpie" aria-label="HTTPie"><a href="https://github.com/httpie/httpie">HTTPie</a></a></li>
                <li>
                    <a href="#axelhttpsgithubcomaxel-download-acceleratoraxel" aria-label="axel"><a href="https://github.com/axel-download-accelerator/axel">axel</a></a></li></ul>
                </li>
                <li>
                    <a href="#usenethttpswwwruanyifengcomblogusenet" aria-label="USENET"><a href="https://www.ruanyifeng.com/blog/usenet/">USENET</a></a><ul>
                        
                <li>
                    <a href="#%e8%b5%b7%e6%ba%90" aria-label="起源">起源</a></li>
                <li>
                    <a href="#%e8%bf%90%e8%a1%8c%e6%9c%ba%e5%88%b6" aria-label="运行机制">运行机制</a></li>
                <li>
                    <a href="#%e5%86%85%e5%ae%b9%e7%bb%93%e6%9e%84" aria-label="内容结构">内容结构</a></li>
                <li>
                    <a href="#%e4%ba%8c%e8%bf%9b%e5%88%b6%e5%86%85%e5%ae%b9" aria-label="二进制内容">二进制内容</a></li>
                <li>
                    <a href="#%e6%94%b6%e8%b4%b9%e6%9c%8d%e5%8a%a1" aria-label="收费服务">收费服务</a></li>
                <li>
                    <a href="#google-groups" aria-label="Google Groups">Google Groups</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#editor" aria-label="Editor">Editor</a><ul>
                        
                <li>
                    <a href="#vscode" aria-label="VSCode">VSCode</a></li>
                <li>
                    <a href="#google-keep" aria-label="Google Keep">Google Keep</a></li>
                <li>
                    <a href="#joplintyporaonedrivehttpscomputetechnologydailycom20210212cf916cdb6cfb498aac38d4fa50d785a2" aria-label="Joplin&#43;Typora&#43;OneDrive"><a href="https://computetechnologydaily.com/2021/02/12/cf916cdb6cfb498aac38d4fa50d785a2/">Joplin+Typora+OneDrive</a></a><ul>
                        
                <li>
                    <a href="#joplin" aria-label="Joplin">Joplin</a></li>
                <li>
                    <a href="#marktexthttpsgithubcommarktextmarktext" aria-label="MarkText"><a href="https://github.com/marktext/marktext">MarkText</a></a></li></ul>
                </li>
                <li>
                    <a href="#foxit-pdf-readerhttpswwwfoxitcompdf-reader" aria-label="Foxit PDF Reader"><a href="https://www.foxit.com/pdf-reader/">Foxit PDF Reader</a></a><ul>
                        
                <li>
                    <a href="#portable-pdf-unlockerhttpssourceforgenetprojectsportablepdfunlockerfileslatestdownload" aria-label="Portable PDF Unlocker"><a href="https://sourceforge.net/projects/portablepdfunlocker/files/latest/download">Portable PDF Unlocker</a></a></li>
                <li>
                    <a href="#pdfcrackhttppdfcracksourceforgenet" aria-label="PDFCrack"><a href="http://pdfcrack.sourceforge.net/">PDFCrack</a></a></li>
                <li>
                    <a href="#pdftkhttpsaskubuntucomquestions828720how-to-remove-the-password-from-a-pdf" aria-label="pdftk"><a href="https://askubuntu.com/questions/828720/how-to-remove-the-password-from-a-pdf">pdftk</a></a></li>
                <li>
                    <a href="#ocrmypdfhttpsgithubcomocrmypdfocrmypdf" aria-label="OCRmyPDF"><a href="https://github.com/ocrmypdf/OCRmyPDF">OCRmyPDF</a></a></li></ul>
                </li>
                <li>
                    <a href="#wpshttpswwwwpscomdownload" aria-label="WPS"><a href="https://www.wps.com/download/">WPS</a></a></li>
                <li>
                    <a href="#sublime-texthttpwwwsublimetextcom" aria-label="Sublime Text"><a href="http://www.sublimetext.com/">Sublime Text</a></a></li>
                <li>
                    <a href="#atomhttpsatomio" aria-label="Atom"><a href="https://atom.io/">Atom</a></a></li>
                <li>
                    <a href="#vim" aria-label="Vim">Vim</a><ul>
                        
                <li>
                    <a href="#vi-%e4%b8%8e-vimtiny" aria-label="vi 与 vim.tiny">vi 与 vim.tiny</a></li>
                <li>
                    <a href="#vim-clear-last-search-highlightinghttpsstackoverflowcomquestions657447vim-clear-last-search-highlighting" aria-label="Vim clear last search highlighting"><a href="https://stackoverflow.com/questions/657447/vim-clear-last-search-highlighting">Vim clear last search highlighting</a></a></li>
                <li>
                    <a href="#vimrchttpsgithubcomamixvimrc" aria-label="VIMRC"><a href="https://github.com/amix/vimrc">VIMRC</a></a></li>
                <li>
                    <a href="#copilotvimhttpsgithubcomgithubcopilotvim" aria-label="copilot.vim"><a href="https://github.com/github/copilot.vim">copilot.vim</a></a></li>
                <li>
                    <a href="#neovimhttpsneovimio" aria-label="Neovim"><a href="https://neovim.io/">Neovim</a></a></li></ul>
                </li>
                <li>
                    <a href="#%e6%9c%80%e9%80%82%e5%90%88%e7%a8%8b%e5%ba%8f%e5%91%98%e7%9a%84%e7%ac%94%e8%ae%b0%e8%bd%af%e4%bb%b6httpswwwruanyifengcomblog202108best-note-taking-software-for-programmershtml" aria-label="最适合程序员的笔记软件"><a href="https://www.ruanyifeng.com/blog/2021/08/best-note-taking-software-for-programmers.html">最适合程序员的笔记软件</a></a></li></ul>
                </li>
                <li>
                    <a href="#shell" aria-label="Shell">Shell</a><ul>
                        
                <li>
                    <a href="#tmuxhttpswwwruanyifengcomblog201910tmuxhtml" aria-label="Tmux"><a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html">Tmux</a></a><ul>
                        
                <li>
                    <a href="#%e7%ae%80%e4%bb%8b-2" aria-label="简介">简介</a></li>
                <li>
                    <a href="#%e5%9f%ba%e6%9c%ac%e7%94%a8%e6%b3%95" aria-label="基本用法">基本用法</a></li>
                <li>
                    <a href="#%e4%bc%9a%e8%af%9d%e7%ae%a1%e7%90%86" aria-label="会话管理">会话管理</a></li>
                <li>
                    <a href="#%e6%9c%80%e7%ae%80%e6%93%8d%e4%bd%9c%e6%b5%81%e7%a8%8b" aria-label="最简操作流程">最简操作流程</a></li>
                <li>
                    <a href="#%e7%aa%97%e6%a0%bc%e6%93%8d%e4%bd%9c" aria-label="窗格操作">窗格操作</a></li>
                <li>
                    <a href="#%e7%aa%97%e5%8f%a3%e7%ae%a1%e7%90%86" aria-label="窗口管理">窗口管理</a></li>
                <li>
                    <a href="#%e5%85%b6%e4%bb%96%e5%91%bd%e4%bb%a4" aria-label="其他命令">其他命令</a></li></ul>
                </li>
                <li>
                    <a href="#fishhttpswwwruanyifengcomblog201705fish_shellhtml" aria-label="Fish"><a href="https://www.ruanyifeng.com/blog/2017/05/fish_shell.html">Fish</a></a><ul>
                        
                <li>
                    <a href="#%e7%ae%80%e4%bb%8b-3" aria-label="简介">简介</a></li>
                <li>
                    <a href="#%e5%ae%89%e8%a3%85" aria-label="安装">安装</a></li>
                <li>
                    <a href="#%e5%90%af%e5%8a%a8%e4%b8%8e%e5%b8%ae%e5%8a%a9" aria-label="启动与帮助">启动与帮助</a></li>
                <li>
                    <a href="#%e5%bd%a9%e8%89%b2%e6%98%be%e7%a4%ba" aria-label="彩色显示">彩色显示</a></li>
                <li>
                    <a href="#%e8%87%aa%e5%8a%a8%e5%bb%ba%e8%ae%ae" aria-label="自动建议">自动建议</a></li>
                <li>
                    <a href="#%e8%87%aa%e5%8a%a8%e8%a1%a5%e5%85%a8" aria-label="自动补全">自动补全</a></li>
                <li>
                    <a href="#%e6%98%93%e6%87%82%e7%9a%84%e8%af%ad%e6%b3%95" aria-label="易懂的语法">易懂的语法</a></li>
                <li>
                    <a href="#%e5%87%bd%e6%95%b0" aria-label="函数">函数</a></li>
                <li>
                    <a href="#%e6%8f%90%e7%a4%ba%e7%ac%a6" aria-label="提示符">提示符</a></li>
                <li>
                    <a href="#%e9%85%8d%e7%bd%ae-1" aria-label="配置">配置</a></li></ul>
                </li>
                <li>
                    <a href="#zsh" aria-label="Zsh">Zsh</a><ul>
                        
                <li>
                    <a href="#oh-my-zshhttpsgithubcomohmyzshohmyzsh" aria-label="Oh My Zsh"><a href="https://github.com/ohmyzsh/ohmyzsh">Oh My Zsh</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#proxy" aria-label="Proxy">Proxy</a><ul>
                        
                <li>
                    <a href="#v2rayhttpsarchlinuxstudiogithubioarchlinuxtutorialrookiefxckgfw" aria-label="v2ray"><a href="https://archlinuxstudio.github.io/ArchLinuxTutorial/#/rookie/fxckGFW">v2ray</a></a><ul>
                        
                <li>
                    <a href="#%e8%8a%82%e7%82%b9%e5%87%86%e5%a4%87" aria-label="节点准备">节点准备</a></li>
                <li>
                    <a href="#%e5%ae%89%e8%a3%85-1" aria-label="安装">安装</a></li>
                <li>
                    <a href="#%e4%bb%a3%e7%90%86%e9%85%8d%e7%bd%ae" aria-label="代理配置">代理配置</a></li>
                <li>
                    <a href="#%e9%80%8f%e6%98%8e%e4%bb%a3%e7%90%86httpsarchicekylinonlinerookietransparenthtml" aria-label="透明代理"><a href="https://arch.icekylin.online/rookie/transparent.html">透明代理</a></a><ul>
                        
                <li>
                    <a href="#dns-1" aria-label="dns"><strong>dns</strong></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#clashhttpszhuanlanzhihucomp369344633" aria-label="Clash"><a href="https://zhuanlan.zhihu.com/p/369344633">Clash</a></a><ul>
                        
                <li>
                    <a href="#%e8%84%9a%e6%9c%ac%e4%b8%80" aria-label="脚本一">脚本一</a></li>
                <li>
                    <a href="#%e8%84%9a%e6%9c%ac%e4%ba%8c" aria-label="脚本二">脚本二</a></li>
                <li>
                    <a href="#tun-%e6%a8%a1%e5%bc%8fhttpslancellcgitbookioclashstart-clashclash-tun-mode" aria-label="TUN 模式"><a href="https://lancellc.gitbook.io/clash/start-clash/clash-tun-mode">TUN 模式</a></a><ul>
                        
                <li>
                    <a href="#clash-for-windowshttpsgithubcomfndroidclash_for_windows_pkgreleases" aria-label="Clash for Windows"><a href="https://github.com/Fndroid/clash_for_windows_pkg/releases">Clash for Windows</a></a></li>
                <li>
                    <a href="#setup-system-stack-in-fake-ip-mode" aria-label="Setup System stack in Fake-IP mode">Setup System stack in Fake-IP mode</a></li></ul>
                </li>
                <li>
                    <a href="#tproxy-modehttpslancellcgitbookioclashstart-clashclash-udp-tproxy-support" aria-label="TProxy Mode"><a href="https://lancellc.gitbook.io/clash/start-clash/clash-udp-tproxy-support">TProxy Mode</a></a></li>
                <li>
                    <a href="#%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6httpswwwcfmemcom202108clashhtml" aria-label="配置文件"><a href="https://www.cfmem.com/2021/08/clash.html">配置文件</a></a><ul>
                        
                <li>
                    <a href="#proxies" aria-label="proxies">proxies</a></li>
                <li>
                    <a href="#proxy-groups" aria-label="proxy-groups">proxy-groups</a></li>
                <li>
                    <a href="#rules" aria-label="rules">rules</a></li></ul>
                </li>
                <li>
                    <a href="#dns%e6%b1%a1%e6%9f%93httpsblogrssinsnetarchives1379" aria-label="DNS污染"><a href="https://blog.rssins.net/archives/1379">DNS污染</a></a><ul>
                        
                <li>
                    <a href="#%e5%af%b9%e6%8a%97dns%e5%8a%ab%e6%8c%81" aria-label="对抗DNS劫持">对抗DNS劫持</a></li>
                <li>
                    <a href="#%e4%bd%95%e6%97%b6%e4%bd%bf%e7%94%a8" aria-label="何时使用">何时使用</a></li>
                <li>
                    <a href="#dns%e9%85%8d%e7%bd%aehttpswwwxkww3ncyou20220208use-clash-dns-anti-dns-hijacking" aria-label="DNS配置"><a href="https://www.xkww3n.cyou/2022/02/08/use-clash-dns-anti-dns-hijacking/">DNS配置</a></a></li></ul>
                </li>
                <li>
                    <a href="#%e4%bb%a3%e7%90%86%e7%8e%af%e5%a2%83%e4%b8%ad%e7%9a%84-dns-%e8%a7%a3%e6%9e%90%e8%a1%8c%e4%b8%bahttpsblogskkmoepostwhat-happend-to-dns-in-proxy" aria-label="代理环境中的 DNS 解析行为"><a href="https://blog.skk.moe/post/what-happend-to-dns-in-proxy">代理环境中的 DNS 解析行为</a></a><ul>
                        
                <li>
                    <a href="#%e4%b8%8d%e4%bd%bf%e7%94%a8%e4%bb%a3%e7%90%86" aria-label="不使用代理">不使用代理</a></li>
                <li>
                    <a href="#%e8%ae%be%e7%bd%ae%e4%bb%a3%e7%90%86%e5%b9%b6%e4%bd%bf%e7%94%a8%e7%9b%b4%e8%bf%9e" aria-label="设置代理并使用直连">设置代理并使用直连</a></li>
                <li>
                    <a href="#%e8%ae%be%e7%bd%ae%e4%bb%a3%e7%90%86%e5%b9%b6%e5%b0%86%e6%b5%81%e9%87%8f%e8%bd%ac%e5%8f%91%e5%88%b0%e8%bf%9c%e7%ab%af%e6%9c%8d%e5%8a%a1%e5%99%a8" aria-label="设置代理并将流量转发到远端服务器">设置代理并将流量转发到远端服务器</a></li>
                <li>
                    <a href="#%e8%ae%be%e7%bd%ae%e4%bb%a3%e7%90%86%e5%b9%b6%e4%bd%bf%e7%94%a8-ip-%e8%a7%84%e5%88%99%e5%92%8c%e5%9f%9f%e5%90%8d%e8%a7%84%e5%88%99%e8%bf%9b%e8%a1%8c%e5%88%86%e6%b5%81" aria-label="设置代理并使用 IP 规则和域名规则进行分流">设置代理并使用 IP 规则和域名规则进行分流</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8-redir--tun2socks-%e5%ae%9e%e7%8e%b0%e5%85%a8%e5%b1%80%e6%b5%81%e9%87%8f%e7%bb%8f%e8%bf%87%e4%bb%a3%e7%90%86" aria-label="使用 redir / tun2socks 实现全局流量经过代理">使用 redir / tun2socks 实现全局流量经过代理</a></li>
                <li>
                    <a href="#%e5%9c%a8-redir--tun2socks-%e4%b8%ad%e4%bd%bf%e7%94%a8-fake-ip" aria-label="在 redir / tun2socks 中使用 Fake IP">在 redir / tun2socks 中使用 Fake IP</a></li>
                <li>
                    <a href="#fancyss-%e5%92%8c-surge--clash-%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="FancySS 和 Surge / Clash 的区别">FancySS 和 Surge / Clash 的区别</a></li>
                <li>
                    <a href="#%e5%a6%82%e6%9e%9c%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e6%88%96%e8%80%85%e6%b5%8f%e8%a7%88%e5%99%a8%e7%bc%93%e5%ad%98%e4%ba%86-dns-%e8%a7%a3%e6%9e%90%e7%bb%93%e6%9e%9c" aria-label="如果操作系统或者浏览器缓存了 DNS 解析结果">如果操作系统或者浏览器缓存了 DNS 解析结果</a></li>
                <li>
                    <a href="#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99" aria-label="参考资料">参考资料</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#wireguardhttpsfuckcloudnativeiopostswireguard-docs-practice" aria-label="WireGuard"><a href="https://fuckcloudnative.io/posts/wireguard-docs-practice/">WireGuard</a></a><ul>
                        
                <li>
                    <a href="#%e6%9c%af%e8%af%ad" aria-label="术语">术语</a></li>
                <li>
                    <a href="#%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86" aria-label="工作原理">工作原理</a></li>
                <li>
                    <a href="#%e6%90%ad%e5%bb%ba%e4%bd%bf%e7%94%a8%e4%b8%8e%e9%85%8d%e7%bd%ae%e8%af%a6%e8%a7%a3" aria-label="搭建使用与配置详解">搭建使用与配置详解</a><ul>
                        
                <li>
                    <a href="#%e5%bf%ab%e9%80%9f%e5%bc%80%e5%a7%8b" aria-label="快速开始">快速开始</a></li>
                <li>
                    <a href="#%e9%85%8d%e7%bd%ae%e8%af%a6%e8%a7%a3" aria-label="配置详解">配置详解</a></li></ul>
                </li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#gui-utilities" aria-label="GUI Utilities">GUI Utilities</a><ul>
                        
                <li>
                    <a href="#gnome" aria-label="Gnome">Gnome</a><ul>
                        
                <li>
                    <a href="#%e6%b5%8f%e8%a7%88" aria-label="浏览">浏览</a></li>
                <li>
                    <a href="#%e9%81%97%e7%95%99%e5%90%8d%e7%a7%b0" aria-label="遗留名称">遗留名称</a></li>
                <li>
                    <a href="#%e4%bf%ae%e6%94%b9%e6%96%87%e4%bb%b6%e9%bb%98%e8%ae%a4%e5%85%b3%e8%81%94%e7%9a%84%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f" aria-label="修改文件默认关联的应用程序">修改文件默认关联的应用程序</a></li>
                <li>
                    <a href="#gedit-%e7%bc%96%e7%a0%81" aria-label="Gedit 编码">Gedit 编码</a></li>
                <li>
                    <a href="#nvidia-optimushttpswikiarchlinuxorgtitlenvidia_optimus_e7ae80e4bd93e4b8ade69687" aria-label="NVIDIA Optimus"><a href="https://wiki.archlinux.org/title/NVIDIA_Optimus_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">NVIDIA Optimus</a></a></li>
                <li>
                    <a href="#%e6%a1%8c%e9%9d%a2%e5%8d%a1%e6%ad%bbhttpsblogcsdnnetsonggu1996articledetails87712546" aria-label="桌面卡死"><a href="https://blog.csdn.net/SongGu1996/article/details/87712546">桌面卡死</a></a></li>
                <li>
                    <a href="#prime-synchronizationhttpswikidebianorgnvidia20optimusprime_synchronization" aria-label="PRIME synchronization"><a href="https://wiki.debian.org/NVIDIA%20Optimus#PRIME_synchronization">PRIME synchronization</a></a></li>
                <li>
                    <a href="#permanently-set-nvidia-powermizer-settingshttpsrastatinggithubiohow-to-permanently-set-nvidia-powermizer-settings-in-ubuntu" aria-label="Permanently Set NVIDIA PowerMizer Settings"><a href="https://rastating.github.io/how-to-permanently-set-nvidia-powermizer-settings-in-ubuntu/">Permanently Set NVIDIA PowerMizer Settings</a></a></li>
                <li>
                    <a href="#%e5%af%86%e9%92%a5%e7%8e%afhttpslinuxcnarticle-12093-1html" aria-label="密钥环"><a href="https://linux.cn/article-12093-1.html">密钥环</a></a><ul>
                        
                <li>
                    <a href="#%e5%af%86%e9%92%a5%e7%8e%af%e6%98%af%e4%bb%80%e4%b9%88%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e5%ae%83" aria-label="密钥环是什么，为什么需要它？">密钥环是什么，为什么需要它？</a></li>
                <li>
                    <a href="#%e4%bf%ae%e6%94%b9%e5%af%86%e9%92%a5%e7%8e%af%e5%af%86%e7%a0%81" aria-label="修改密钥环密码">修改密钥环密码</a></li>
                <li>
                    <a href="#%e7%a6%81%e7%94%a8%e5%af%86%e9%92%a5%e7%8e%af%e5%af%86%e7%a0%81" aria-label="禁用密钥环密码">禁用密钥环密码</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#gnome-tweaks" aria-label="Gnome Tweaks">Gnome Tweaks</a><ul>
                        
                <li>
                    <a href="#ubuntu-dockhttpsblogcsdnneta6864657articledetails103606669" aria-label="Ubuntu Dock"><a href="https://blog.csdn.net/a6864657/article/details/103606669/">Ubuntu Dock</a></a></li>
                <li>
                    <a href="#kde-connecthttpskdeconnectkdeorggsconnecthttpsgithubcomgsconnectgnome-shell-extension-gsconnect" aria-label="KDE Connect/GSConnect"><a href="https://kdeconnect.kde.org/">KDE Connect</a>/<a href="https://github.com/GSConnect/gnome-shell-extension-gsconnect">GSConnect</a></a></li>
                <li>
                    <a href="#netspeedhttpsextensionsgnomeorgextension104netspeed" aria-label="NetSpeed"><a href="https://extensions.gnome.org/extension/104/netspeed/">NetSpeed</a></a></li>
                <li>
                    <a href="#clipboard-indicatorhttpsextensionsgnomeorgextension779clipboard-indicator" aria-label="Clipboard Indicator"><a href="https://extensions.gnome.org/extension/779/clipboard-indicator/">Clipboard Indicator</a></a></li>
                <li>
                    <a href="#coverflow-alt-tabhttpsextensionsgnomeorgextension97coverflow-alt-tab" aria-label="Coverflow Alt-Tab"><a href="https://extensions.gnome.org/extension/97/coverflow-alt-tab/">Coverflow Alt-Tab</a></a></li>
                <li>
                    <a href="#bluetooth-quick-connecthttpsextensionsgnomeorgextension1401bluetooth-quick-connect" aria-label="Bluetooth Quick Connect"><a href="https://extensions.gnome.org/extension/1401/bluetooth-quick-connect/">Bluetooth Quick Connect</a></a></li>
                <li>
                    <a href="#desktop-icons-ng-dinghttpsextensionsgnomeorgextension2087desktop-icons-ng-ding" aria-label="Desktop Icons NG (DING)"><a href="https://extensions.gnome.org/extension/2087/desktop-icons-ng-ding/">Desktop Icons NG (DING)</a></a></li>
                <li>
                    <a href="#frippery-move-clockhttpsextensionsgnomeorgextension2move-clock" aria-label="Frippery Move Clock"><a href="https://extensions.gnome.org/extension/2/move-clock/">Frippery Move Clock</a></a></li>
                <li>
                    <a href="#input-method-panelhttpsextensionsgnomeorgextension261kimpanel" aria-label="Input Method Panel"><a href="https://extensions.gnome.org/extension/261/kimpanel/">Input Method Panel</a></a></li>
                <li>
                    <a href="#lock-keyshttpsextensionsgnomeorgextension36lock-keys" aria-label="Lock Keys"><a href="https://extensions.gnome.org/extension/36/lock-keys/">Lock Keys</a></a></li>
                <li>
                    <a href="#openweatherhttpsextensionsgnomeorgextension750openweather" aria-label="OpenWeather"><a href="https://extensions.gnome.org/extension/750/openweather/">OpenWeather</a></a></li>
                <li>
                    <a href="#panel-date-formathttpsextensionsgnomeorgextension1462panel-date-format" aria-label="Panel Date Format"><a href="https://extensions.gnome.org/extension/1462/panel-date-format/">Panel Date Format</a></a></li>
                <li>
                    <a href="#refresh-wifi-connectionshttpsextensionsgnomeorgextension905refresh-wifi-connections" aria-label="Refresh Wifi Connections"><a href="https://extensions.gnome.org/extension/905/refresh-wifi-connections/">Refresh Wifi Connections</a></a></li>
                <li>
                    <a href="#screenshot-toolhttpsextensionsgnomeorgextension1112screenshot-tool" aria-label="Screenshot Tool"><a href="https://extensions.gnome.org/extension/1112/screenshot-tool/">Screenshot Tool</a></a></li>
                <li>
                    <a href="#sound-input--output-device-chooserlivepatchhttpsextensionsgnomeorgextension906sound-output-device-chooser" aria-label="Sound Input &amp;amp; Output Device ChooserLivepatch"><a href="https://extensions.gnome.org/extension/906/sound-output-device-chooser/">Sound Input &amp; Output Device ChooserLivepatch</a></a></li>
                <li>
                    <a href="#status-area-horizontal-spacinghttpsextensionsgnomeorgextension355status-area-horizontal-spacing" aria-label="Status Area Horizontal Spacing"><a href="https://extensions.gnome.org/extension/355/status-area-horizontal-spacing/">Status Area Horizontal Spacing</a></a></li>
                <li>
                    <a href="#unitehttpsextensionsgnomeorgextension1287unite" aria-label="Unite"><a href="https://extensions.gnome.org/extension/1287/unite/">Unite</a></a></li>
                <li>
                    <a href="#user-themeshttpsextensionsgnomeorgextension19user-themes" aria-label="User Themes"><a href="https://extensions.gnome.org/extension/19/user-themes/">User Themes</a></a></li>
                <li>
                    <a href="#vitalshttpsextensionsgnomeorgextension1460vitals" aria-label="Vitals"><a href="https://extensions.gnome.org/extension/1460/vitals/">Vitals</a></a></li>
                <li>
                    <a href="#papirus-icon-themehttpsgithubcompapirusdevelopmentteampapirus-icon-theme" aria-label="Papirus Icon Theme"><a href="https://github.com/PapirusDevelopmentTeam/papirus-icon-theme">Papirus Icon Theme</a></a></li>
                <li>
                    <a href="#materia-themehttpsgithubcomnana-4materia-theme" aria-label="Materia Theme"><a href="https://github.com/nana-4/materia-theme">Materia Theme</a></a></li></ul>
                </li>
                <li>
                    <a href="#chromehttpswwwgooglecomlinuxrepositories" aria-label="Chrome"><a href="https://www.google.com/linuxrepositories/">Chrome</a></a><ul>
                        
                <li>
                    <a href="#tampermonkeyhttpsgreasyforkorgzh-cn" aria-label="Tampermonkey"><a href="https://greasyfork.org/zh-CN">Tampermonkey</a></a></li>
                <li>
                    <a href="#download-all-images" aria-label="Download All Images">Download All Images</a></li>
                <li>
                    <a href="#ublock-origin" aria-label="uBlock Origin">uBlock Origin</a></li>
                <li>
                    <a href="#%e6%b2%99%e6%8b%89%e6%9f%a5%e8%af%8dhttpssaladictcrimxcom" aria-label="沙拉查词"><a href="https://saladict.crimx.com/">沙拉查词</a></a></li>
                <li>
                    <a href="#infinity-new-tabhttpschromegooglecomwebstoredetailinfinity-new-tabdbfmnekepjoapopniengjbcpnbljalfghlen-us" aria-label="Infinity New Tab"><a href="https://chrome.google.com/webstore/detail/infinity-new-tab/dbfmnekepjoapopniengjbcpnbljalfg?hl=en-US">Infinity New Tab</a></a></li>
                <li>
                    <a href="#questions" aria-label="Questions">Questions</a></li>
                <li>
                    <a href="#chromium" aria-label="Chromium">Chromium</a></li>
                <li>
                    <a href="#firefox" aria-label="Firefox">Firefox</a></li></ul>
                </li>
                <li>
                    <a href="#flameshothttpsflameshotorg" aria-label="Flameshot"><a href="https://flameshot.org/">Flameshot</a></a></li>
                <li>
                    <a href="#ppsspphttpsapkcabalcomngbest-ppsspp-settings" aria-label="PPSSPP"><a href="https://apkcabal.com.ng/best-ppsspp-settings/">PPSSPP</a></a></li>
                <li>
                    <a href="#yuzuhttpswwwbilibilicomreadcv4973631" aria-label="yuzu"><a href="https://www.bilibili.com/read/cv4973631">yuzu</a></a><ul>
                        
                <li>
                    <a href="#%e5%ae%89%e8%a3%85-2" aria-label="安装">安装</a></li>
                <li>
                    <a href="#%e8%ae%be%e7%bd%aehttpswwwjianshucompd55e015fbcb6" aria-label="设置"><a href="https://www.jianshu.com/p/d55e015fbcb6">设置</a></a></li>
                <li>
                    <a href="#%e7%ae%a1%e7%90%86" aria-label="管理">管理</a></li></ul>
                </li>
                <li>
                    <a href="#rubickhttpsgithubcomrubickcenterrubick" aria-label="rubick"><a href="https://github.com/rubickCenter/rubick">rubick</a></a><ul>
                        
                <li>
                    <a href="#utoolshttpsutools" aria-label="uTools"><a href="https://u.tools/">uTools</a></a></li></ul>
                </li>
                <li>
                    <a href="#lifereahttpslzonedeliferea" aria-label="Liferea"><a href="https://lzone.de/liferea/">Liferea</a></a></li>
                <li>
                    <a href="#calibrehttpscalibre-ebookcom" aria-label="Calibre"><a href="https://calibre-ebook.com/">Calibre</a></a></li>
                <li>
                    <a href="#ventoyhttpswwwventoynetcnindexhtml" aria-label="Ventoy"><a href="https://www.ventoy.net/cn/index.html">Ventoy</a></a><ul>
                        
                <li>
                    <a href="#balenaetcherhttpsgithubcombalena-ioetcher" aria-label="balenaEtcher"><a href="https://github.com/balena-io/etcher">balenaEtcher</a></a></li>
                <li>
                    <a href="#unetbootinhttpsgithubcomunetbootinunetbootin" aria-label="UNetbootin"><a href="https://github.com/unetbootin/unetbootin">UNetbootin</a></a></li>
                <li>
                    <a href="#woeusb-nghttpsgithubcomwoeusbwoeusb-ng" aria-label="WoeUSB-ng"><a href="https://github.com/WoeUSB/WoeUSB-ng">WoeUSB-ng</a></a></li></ul>
                </li>
                <li>
                    <a href="#goldendicthttpgoldendictorg" aria-label="GoldenDict"><a href="http://goldendict.org/">GoldenDict</a></a></li>
                <li>
                    <a href="#timeshifthttpsgithubcomteejee2008timeshift" aria-label="Timeshift"><a href="https://github.com/teejee2008/timeshift">Timeshift</a></a></li>
                <li>
                    <a href="#todoisthttpssnapcraftioinstalltodoistubuntuinstall" aria-label="Todoist"><a href="https://snapcraft.io/install/todoist/ubuntu#install">Todoist</a></a></li>
                <li>
                    <a href="#plankhttpslaunchpadnetplank" aria-label="Plank"><a href="https://launchpad.net/plank">Plank</a></a></li>
                <li>
                    <a href="#motrixhttpsgithubcomagalwoodmotrix" aria-label="Motrix"><a href="https://github.com/agalwood/Motrix">Motrix</a></a></li>
                <li>
                    <a href="#steamhttpsstoresteampoweredcom" aria-label="Steam"><a href="https://store.steampowered.com/">Steam</a></a></li>
                <li>
                    <a href="#yacreaderhttpsyacreadercom" aria-label="YACReader"><a href="https://yacreader.com/">YACReader</a></a></li>
                <li>
                    <a href="#work_crawlerhttpsgithubcomkanasimiwork_crawler" aria-label="work_crawler"><a href="https://github.com/kanasimi/work_crawler">work_crawler</a></a></li>
                <li>
                    <a href="#dingtalkhttpsgithubcomnashaofudingtalk" aria-label="dingtalk"><a href="https://github.com/nashaofu/dingtalk">dingtalk</a></a></li>
                <li>
                    <a href="#howdyhttpsgithubcomboltgolthowdy" aria-label="howdy"><a href="https://github.com/boltgolt/howdy">howdy</a></a></li>
                <li>
                    <a href="#%e5%90%91%e6%97%a5%e8%91%b5httpssunloginoraycom" aria-label="向日葵"><a href="https://sunlogin.oray.com/">向日葵</a></a></li>
                <li>
                    <a href="#keepassxchttpskeepassxcorg" aria-label="KeePassXC"><a href="https://keepassxc.org/">KeePassXC</a></a></li></ul>
                </li>
                <li>
                    <a href="#cli-utilities" aria-label="CLI Utilities">CLI Utilities</a><ul>
                        
                <li>
                    <a href="#ansiblehttpsansible-tranreadthedocsioenlatestindexhtml" aria-label="Ansible"><a href="https://ansible-tran.readthedocs.io/en/latest/index.html">Ansible</a></a></li>
                <li>
                    <a href="#fdupeshttpsaskubuntucomquestions3865how-to-find-and-delete-duplicate-files" aria-label="fdupes"><a href="https://askubuntu.com/questions/3865/how-to-find-and-delete-duplicate-files">fdupes</a></a><ul>
                        
                <li>
                    <a href="#digikamhttpswwwdigikamorg" aria-label="digiKam"><a href="https://www.digikam.org/">digiKam</a></a></li></ul>
                </li>
                <li>
                    <a href="#bypyhttpscdnjsdelivrnetghhoutianzebypymaster" aria-label="bypy"><a href="https://cdn.jsdelivr.net/gh/houtianze/bypy@master/">bypy</a></a></li>
                <li>
                    <a href="#frphttpsgofrporg" aria-label="FRP"><a href="https://gofrp.org/">FRP</a></a></li>
                <li>
                    <a href="#git" aria-label="Git">Git</a><ul>
                        
                <li>
                    <a href="#github-desktophttpsdesktopgithubcom" aria-label="GitHub Desktop"><a href="https://desktop.github.com/">GitHub Desktop</a></a></li></ul>
                </li>
                <li>
                    <a href="#libguestfs" aria-label="libguestfs">libguestfs</a></li>
                <li>
                    <a href="#oracle-jdk" aria-label="Oracle JDK">Oracle JDK</a></li>
                <li>
                    <a href="#snapper" aria-label="Snapper">Snapper</a></li>
                <li>
                    <a href="#fail2banhttpszhuanlanzhihucomp33546122" aria-label="Fail2Ban"><a href="https://zhuanlan.zhihu.com/p/33546122">Fail2Ban</a></a></li>
                <li>
                    <a href="#syncthinghttpszhuanlanzhihucomp69267020" aria-label="Syncthing"><a href="https://zhuanlan.zhihu.com/p/69267020">Syncthing</a></a></li>
                <li>
                    <a href="#masscanhttpscloudtencentcomdeveloperarticle1707983" aria-label="masscan"><a href="https://cloud.tencent.com/developer/article/1707983">masscan</a></a></li>
                <li>
                    <a href="#imagemagickhttpswwwimagemagickorgscriptindexphp" aria-label="ImageMagick"><a href="https://www.imagemagick.org/script/index.php">ImageMagick</a></a></li>
                <li>
                    <a href="#p7ziphttpswww7-ziporg" aria-label="p7zip"><a href="https://www.7-zip.org/">p7zip</a></a><ul>
                        
                <li>
                    <a href="#differences-between-7z-7za-and-7zr-binarieshttpswikiarchlinuxorgtitlep7zip" aria-label="Differences between 7z, 7za and 7zr binaries"><a href="https://wiki.archlinux.org/title/p7zip">Differences between 7z, 7za and 7zr binaries</a></a></li>
                <li>
                    <a href="#%e5%88%86%e5%8d%b7%e5%8e%8b%e7%bc%a9%e4%b8%8e%e8%a7%a3%e5%8e%8b%e7%bc%a9httpsdeveloperaliyuncomarticle506654" aria-label="分卷压缩与解压缩"><a href="https://developer.aliyun.com/article/506654">分卷压缩与解压缩</a></a></li></ul>
                </li>
                <li>
                    <a href="#wudao-dicthttpsgithubcomchestnuthengwudao-dict" aria-label="Wudao-dict"><a href="https://github.com/ChestnutHeng/Wudao-dict">Wudao-dict</a></a></li>
                <li>
                    <a href="#-ascii-image-converterhttpsgithubcomthezoraizascii-image-converter" aria-label="ascii-image-converter"><a href="https://github.com/TheZoraiz/ascii-image-converter"> ascii-image-converter</a></a></li>
                <li>
                    <a href="#ttydhttpsgithubcomtsl0922ttyd" aria-label="ttyd"><a href="https://github.com/tsl0922/ttyd">ttyd</a></a></li>
                <li>
                    <a href="#progresshttpsgithubcomxfennecprogress" aria-label="progress"><a href="https://github.com/Xfennec/progress">progress</a></a></li>
                <li>
                    <a href="#vosk-apihttpsgithubcomalphacepvosk-api" aria-label="vosk-api"><a href="https://github.com/alphacep/vosk-api">vosk-api</a></a><ul>
                        
                <li>
                    <a href="#convert-mp3-to-texthttpsaskubuntucomquestions161515speech-recognition-app-to-convert-mp3-to-text" aria-label="convert MP3 to text"><a href="https://askubuntu.com/questions/161515/speech-recognition-app-to-convert-mp3-to-text">convert MP3 to text</a></a></li></ul>
                </li>
                <li>
                    <a href="#inxihttpslinuxcnarticle-14089-1html" aria-label="inxi"><a href="https://linux.cn/article-14089-1.html">inxi</a></a></li>
                <li>
                    <a href="#busyboxhttpslinuxcnarticle-13840-1html" aria-label="BusyBox"><a href="https://linux.cn/article-13840-1.html">BusyBox</a></a><ul>
                        
                <li>
                    <a href="#%e6%9e%81%e7%ae%80%e4%b8%bb%e4%b9%89" aria-label="极简主义">极简主义</a></li></ul>
                </li>
                <li>
                    <a href="#lynishttpslinuxcnarticle-12696-1html" aria-label="Lynis"><a href="https://linux.cn/article-12696-1.html">Lynis</a></a><ul>
                        
                <li>
                    <a href="#%e5%ae%89%e8%a3%85-lynis" aria-label="安装 Lynis">安装 Lynis</a></li>
                <li>
                    <a href="#%e8%bf%90%e8%a1%8c-lynis" aria-label="运行 Lynis">运行 Lynis</a></li>
                <li>
                    <a href="#%e5%ae%a1%e8%ae%a1-linux-%e7%b3%bb%e7%bb%9f" aria-label="审计 Linux 系统">审计 Linux 系统</a></li>
                <li>
                    <a href="#%e6%8e%a2%e7%b4%a2%e6%8a%a5%e5%91%8a" aria-label="探索报告">探索报告</a></li>
                <li>
                    <a href="#%e8%af%95%e8%af%95%e5%90%a7" aria-label="试试吧">试试吧</a></li>
                <li>
                    <a href="#how-can-i-protect-against-single-user-modehttpsaskubuntucomquestions1011368how-can-i-protect-against-single-user-mode" aria-label="How can I protect against single user mode"><a href="https://askubuntu.com/questions/1011368/how-can-i-protect-against-single-user-mode">How can I protect against single user mode</a></a></li></ul>
                </li>
                <li>
                    <a href="#checkinstallhttpslinuxcnarticle-4090-1html" aria-label="CheckInstall"><a href="https://linux.cn/article-4090-1.html">CheckInstall</a></a></li>
                <li>
                    <a href="#gksudokdesudohttpsaskubuntucomquestions11760what-is-the-difference-between-gksudo-nautilus-and-sudo-nautilus" aria-label="gksudo/kdesudo"><a href="https://askubuntu.com/questions/11760/what-is-the-difference-between-gksudo-nautilus-and-sudo-nautilus">gksudo/kdesudo</a></a></li>
                <li>
                    <a href="#manhttpslinuxcnarticle-13478-1html" aria-label="man"><a href="https://linux.cn/article-13478-1.html">man</a></a><ul>
                        
                <li>
                    <a href="#%e5%85%a5%e9%97%a8" aria-label="入门">入门</a></li>
                <li>
                    <a href="#%e8%8a%82" aria-label="节">节</a></li>
                <li>
                    <a href="#%e6%89%8b%e5%86%8c%e9%a1%b5%e7%9a%84%e8%8a%82" aria-label="手册页的节">手册页的节</a></li>
                <li>
                    <a href="#%e6%89%8b%e5%86%8c%e7%9a%84%e8%8a%82" aria-label="手册的节">手册的节</a></li>
                <li>
                    <a href="#%e6%90%9c%e7%b4%a2%e4%b8%80%e4%b8%aa%e7%89%b9%e5%ae%9a%e7%9a%84%e8%8a%82" aria-label="搜索一个特定的节">搜索一个特定的节</a></li>
                <li>
                    <a href="#%e6%90%9c%e7%b4%a2%e5%8c%85%e5%90%ab%e6%9f%90%e4%b8%aa%e5%85%b3%e9%94%ae%e8%af%8d%e7%9a%84%e6%89%80%e6%9c%89%e6%89%8b%e5%86%8c%e9%a1%b5" aria-label="搜索包含某个关键词的所有手册页">搜索包含某个关键词的所有手册页</a></li>
                <li>
                    <a href="#%e4%ba%86%e8%a7%a3%e6%89%8b%e5%86%8c%e7%9a%84%e5%90%84%e4%b8%aa%e8%8a%82" aria-label="了解手册的各个节">了解手册的各个节</a></li>
                <li>
                    <a href="#%e7%bb%93%e8%ae%ba" aria-label="结论">结论</a></li>
                <li>
                    <a href="#tldrhttpsgithubcomtldr-pagestldr" aria-label="tldr"><a href="https://github.com/tldr-pages/tldr">tldr</a></a></li></ul>
                </li>
                <li>
                    <a href="#lshttpslinuxcnarticle-11159-1html" aria-label="ls"><a href="https://linux.cn/article-11159-1.html">ls</a></a><ul>
                        
                <li>
                    <a href="#gnu-%e8%bf%98%e6%98%af-bsd" aria-label="GNU 还是 BSD？">GNU 还是 BSD？</a></li>
                <li>
                    <a href="#%e5%88%86%e7%b1%bb" aria-label="分类">分类</a></li>
                <li>
                    <a href="#%e9%95%bf%e5%88%97%e8%a1%a8" aria-label="长列表">长列表</a></li>
                <li>
                    <a href="#%e6%97%b6%e9%97%b4%e5%92%8c%e6%97%a5%e6%9c%9f%e6%a0%bc%e5%bc%8f" aria-label="时间和日期格式">时间和日期格式</a></li>
                <li>
                    <a href="#%e6%8c%89%e6%97%b6%e9%97%b4%e6%8e%92%e5%ba%8f" aria-label="按时间排序">按时间排序</a></li>
                <li>
                    <a href="#%e5%88%97%e5%87%ba%e6%96%b9%e5%bc%8f" aria-label="列出方式">列出方式</a></li>
                <li>
                    <a href="#%e9%9a%90%e8%97%8f%e6%9d%82%e9%a1%b9" aria-label="隐藏杂项">隐藏杂项</a></li>
                <li>
                    <a href="#%e9%80%92%e5%bd%92%e5%9c%b0%e5%88%97%e5%87%ba%e7%9b%ae%e5%bd%95" aria-label="递归地列出目录">递归地列出目录</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8%e5%88%ab%e5%90%8d%e4%bd%bf%e5%85%b6%e6%b0%b8%e4%b9%85%e5%8c%96" aria-label="使用别名使其永久化">使用别名使其永久化</a></li>
                <li>
                    <a href="#%e5%81%9a%e4%b8%80%e4%bb%b6%e4%ba%8b%e6%8a%8a%e5%ae%83%e5%81%9a%e5%a5%bd" aria-label="做一件事，把它做好">做一件事，把它做好</a></li>
                <li>
                    <a href="#exahttpsgithubcomoghamexa" aria-label="exa"><a href="https://github.com/ogham/exa">exa</a></a></li></ul>
                </li>
                <li>
                    <a href="#du-disk-usagehttpslinuxcnarticle-11503-1html" aria-label="du (Disk Usage)"><a href="https://linux.cn/article-11503-1.html">du (Disk Usage)</a></a><ul>
                        
                <li>
                    <a href="#ncurses-disk-usagehttpsdevyorhelnlncdu" aria-label="NCurses Disk Usage"><a href="https://dev.yorhel.nl/ncdu">NCurses Disk Usage</a></a></li>
                <li>
                    <a href="#gduhttpsgithubcomdundeegdu" aria-label="gdu"><a href="https://github.com/dundee/gdu">gdu</a></a></li></ul>
                </li>
                <li>
                    <a href="#diffhttpswwwruanyifengcomblog201208how_to_read_diffhtml" aria-label="Diff"><a href="https://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html">Diff</a></a><ul>
                        
                <li>
                    <a href="#%e4%b8%89%e7%a7%8d%e6%a0%bc%e5%bc%8f" aria-label="三种格式">三种格式</a></li>
                <li>
                    <a href="#%e7%a4%ba%e4%be%8b%e6%96%87%e4%bb%b6" aria-label="示例文件">示例文件</a></li>
                <li>
                    <a href="#%e6%ad%a3%e5%b8%b8%e6%a0%bc%e5%bc%8f" aria-label="正常格式">正常格式</a></li>
                <li>
                    <a href="#%e4%b8%8a%e4%b8%8b%e6%96%87%e6%a0%bc%e5%bc%8f" aria-label="上下文格式">上下文格式</a></li>
                <li>
                    <a href="#%e5%90%88%e5%b9%b6%e6%a0%bc%e5%bc%8f" aria-label="合并格式">合并格式</a></li>
                <li>
                    <a href="#git%e6%a0%bc%e5%bc%8f" aria-label="git格式">git格式</a></li></ul>
                </li>
                <li>
                    <a href="#crontabhttpcbianchengnetview1092html" aria-label="Crontab"><a href="http://c.biancheng.net/view/1092.html">Crontab</a></a><ul>
                        
                <li>
                    <a href="#installing" aria-label="Installing">Installing</a></li>
                <li>
                    <a href="#running" aria-label="Running">Running</a></li>
                <li>
                    <a href="#%e5%91%bd%e4%bb%a4%e8%af%a6%e8%a7%a3" aria-label="命令详解">命令详解</a><ul>
                        
                <li>
                    <a href="#%e5%b8%b8%e7%94%a8%e9%80%89%e9%a1%b9" aria-label="常用选项">常用选项</a></li>
                <li>
                    <a href="#crontab-%e6%96%87%e4%bb%b6%e6%a0%bc%e5%bc%8f" aria-label="crontab 文件格式">crontab 文件格式</a></li></ul>
                </li>
                <li>
                    <a href="#run-a-script-on-startuphttpsunixstackexchangecomquestions416137how-can-i-run-a-script-on-startup-on-ubuntu-server-17-10" aria-label="run a script on startup"><a href="https://unix.stackexchange.com/questions/416137/how-can-i-run-a-script-on-startup-on-ubuntu-server-17-10">run a script on startup</a></a></li></ul>
                </li>
                <li>
                    <a href="#pshttpslinuxtools-rstreadthedocsiozh_cnlatesttoolpshtml" aria-label="ps"><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/ps.html">ps</a></a><ul>
                        
                <li>
                    <a href="#%e7%ae%80%e4%bb%8b-4" aria-label="简介">简介</a></li>
                <li>
                    <a href="#%e5%91%bd%e4%bb%a4%e5%8f%82%e6%95%b0httpswwwjianshucomp943b90150c10" aria-label="命令参数"><a href="https://www.jianshu.com/p/943b90150c10">命令参数</a></a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8%e5%ae%9e%e4%be%8bhttpcbianchengnetview1062html" aria-label="使用实例"><a href="http://c.biancheng.net/view/1062.html">使用实例</a></a></li></ul>
                </li>
                <li>
                    <a href="#tophttpcbianchengnetview1065html" aria-label="top"><a href="http://c.biancheng.net/view/1065.html">top</a></a><ul>
                        
                <li>
                    <a href="#%e7%ae%80%e4%bb%8bhttpslinuxtools-rstreadthedocsiozh_cnlatesttooltophtml" aria-label="简介"><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/top.html">简介</a></a></li>
                <li>
                    <a href="#%e5%91%bd%e4%bb%a4%e5%8f%82%e6%95%b0" aria-label="命令参数">命令参数</a></li>
                <li>
                    <a href="#%e4%ba%a4%e4%ba%92%e6%93%8d%e4%bd%9c%e6%8c%87%e4%bb%a4" aria-label="交互操作指令">交互操作指令</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8%e5%ae%9e%e4%be%8b" aria-label="使用实例">使用实例</a></li>
                <li>
                    <a href="#htophttpsgithubcomhtop-devhtop" aria-label="htop"><a href="https://github.com/htop-dev/htop/">htop</a></a></li>
                <li>
                    <a href="#bpytophttpsgithubcomaristocratosbpytop" aria-label="bpytop"><a href="https://github.com/aristocratos/bpytop">bpytop</a></a></li></ul>
                </li>
                <li>
                    <a href="#lsofhttpslinuxtools-rstreadthedocsiozh_cnlatesttoollsofhtml" aria-label="lsof"><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/lsof.html">lsof</a></a><ul>
                        
                <li>
                    <a href="#%e7%ae%80%e4%bb%8bhttpcbianchengnetview1088html" aria-label="简介"><a href="http://c.biancheng.net/view/1088.html">简介</a></a></li>
                <li>
                    <a href="#%e5%91%bd%e4%bb%a4%e5%8f%82%e6%95%b0-1" aria-label="命令参数">命令参数</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8%e5%ae%9e%e4%be%8b-1" aria-label="使用实例">使用实例</a></li></ul>
                </li>
                <li>
                    <a href="#write" aria-label="write">write</a></li>
                <li>
                    <a href="#xargs" aria-label="xargs">xargs</a><ul>
                        
                <li>
                    <a href="#%e6%a0%87%e5%87%86%e8%be%93%e5%85%a5%e4%b8%8e%e7%ae%a1%e9%81%93%e5%91%bd%e4%bb%a4" aria-label="标准输入与管道命令">标准输入与管道命令</a></li>
                <li>
                    <a href="#xargs-%e5%91%bd%e4%bb%a4%e7%9a%84%e4%bd%9c%e7%94%a8" aria-label="xargs 命令的作用">xargs 命令的作用</a></li>
                <li>
                    <a href="#xargs-%e7%9a%84%e5%8d%95%e7%8b%ac%e4%bd%bf%e7%94%a8" aria-label="xargs 的单独使用">xargs 的单独使用</a></li>
                <li>
                    <a href="#-d-%e5%8f%82%e6%95%b0%e4%b8%8e%e5%88%86%e9%9a%94%e7%ac%a6" aria-label="-d 参数与分隔符">-d 参数与分隔符</a></li>
                <li>
                    <a href="#-p-%e5%8f%82%e6%95%b0-t-%e5%8f%82%e6%95%b0" aria-label="-p 参数，-t 参数">-p 参数，-t 参数</a></li>
                <li>
                    <a href="#-0-%e5%8f%82%e6%95%b0%e4%b8%8e-find-%e5%91%bd%e4%bb%a4" aria-label="-0 参数与 find 命令">-0 参数与 find 命令</a></li>
                <li>
                    <a href="#-l-%e5%8f%82%e6%95%b0" aria-label="-L 参数">-L 参数</a></li>
                <li>
                    <a href="#-n-%e5%8f%82%e6%95%b0" aria-label="-n 参数">-n 参数</a></li>
                <li>
                    <a href="#-i-%e5%8f%82%e6%95%b0" aria-label="-I 参数">-I 参数</a></li>
                <li>
                    <a href="#--max-procs-%e5%8f%82%e6%95%b0" aria-label="&amp;ndash;max-procs 参数">&ndash;max-procs 参数</a></li></ul>
                </li>
                <li>
                    <a href="#awkhttpswwwruanyifengcomblog201811awkhtml" aria-label="awk"><a href="https://www.ruanyifeng.com/blog/2018/11/awk.html">awk</a></a><ul>
                        
                <li>
                    <a href="#%e5%9f%ba%e6%9c%ac%e7%94%a8%e6%b3%95-1" aria-label="基本用法">基本用法</a></li>
                <li>
                    <a href="#%e5%8f%98%e9%87%8f" aria-label="变量">变量</a></li>
                <li>
                    <a href="#%e5%87%bd%e6%95%b0-1" aria-label="函数">函数</a></li>
                <li>
                    <a href="#%e6%9d%a1%e4%bb%b6" aria-label="条件">条件</a></li>
                <li>
                    <a href="#if-%e8%af%ad%e5%8f%a5" aria-label="if 语句">if 语句</a></li></ul>
                </li>
                <li>
                    <a href="#findhttpslinuxcnarticle-14071-1html" aria-label="find"><a href="https://linux.cn/article-14071-1.html">find</a></a><ul>
                        
                <li>
                    <a href="#%e5%b8%b8%e7%94%a8%e9%80%89%e9%a1%b9httpslinuxcnarticle-1672-1html" aria-label="常用选项"><a href="https://linux.cn/article-1672-1.html">常用选项</a></a></li>
                <li>
                    <a href="#%e6%8c%89%e5%90%8d%e7%a7%b0%e6%9f%a5%e6%89%be%e6%96%87%e4%bb%b6" aria-label="按名称查找文件">按名称查找文件</a></li>
                <li>
                    <a href="#%e9%80%9a%e9%85%8d%e7%ac%a6" aria-label="通配符">通配符</a></li>
                <li>
                    <a href="#%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f" aria-label="正则表达式">正则表达式</a></li>
                <li>
                    <a href="#%e6%9f%a5%e6%89%be%e8%bf%91%e4%b8%80%e5%91%a8%e4%bf%ae%e6%94%b9%e8%bf%87%e7%9a%84%e6%96%87%e4%bb%b6" aria-label="查找近一周修改过的文件">查找近一周修改过的文件</a></li>
                <li>
                    <a href="#%e6%9f%a5%e6%89%be%e8%bf%91%e5%87%a0%e5%a4%a9%e4%bf%ae%e6%94%b9%e7%9a%84%e6%96%87%e4%bb%b6" aria-label="查找近几天修改的文件">查找近几天修改的文件</a></li>
                <li>
                    <a href="#%e6%8c%89%e6%96%87%e4%bb%b6%e7%b1%bb%e5%9e%8b%e9%99%90%e5%88%b6%e6%90%9c%e7%b4%a2" aria-label="按文件类型限制搜索">按文件类型限制搜索</a></li>
                <li>
                    <a href="#%e8%b0%83%e6%95%b4%e8%8c%83%e5%9b%b4" aria-label="调整范围">调整范围</a></li>
                <li>
                    <a href="#%e4%b8%8e-xargs" aria-label="与 xargs">与 xargs</a></li>
                <li>
                    <a href="#fdhttpsgithubcomsharkdpfd" aria-label="fd"><a href="https://github.com/sharkdp/fd">fd</a></a></li></ul>
                </li>
                <li>
                    <a href="#grephttpslinuxcnarticle-6927-1html" aria-label="grep"><a href="https://linux.cn/article-6927-1.html">grep</a></a><ul>
                        
                <li>
                    <a href="#%e5%9f%ba%e6%9c%ac%e9%9b%86httpslinuxcnarticle-1672-1html" aria-label="基本集"><a href="https://linux.cn/article-1672-1.html">基本集</a></a></li>
                <li>
                    <a href="#%e5%b8%b8%e7%94%a8%e9%80%89%e9%a1%b9-1" aria-label="常用选项">常用选项</a></li>
                <li>
                    <a href="#%e6%80%8e%e4%b9%88%e6%a0%b7%e4%bd%bf%e7%94%a8-grep-%e6%9d%a5%e6%90%9c%e7%b4%a2%e4%b8%80%e4%b8%aa%e6%96%87%e4%bb%b6" aria-label="怎么样使用 grep 来搜索一个文件">怎么样使用 grep 来搜索一个文件</a></li>
                <li>
                    <a href="#%e9%80%92%e5%bd%92%e4%bd%bf%e7%94%a8-grep" aria-label="递归使用 grep">递归使用 grep</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8-grep-%e5%8e%bb%e6%90%9c%e7%b4%a2%e6%96%87%e6%9c%ac" aria-label="使用 grep 去搜索文本">使用 grep 去搜索文本</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8-grep-%e5%91%bd%e4%bb%a4%e5%8e%bb%e6%90%9c%e7%b4%a2%e4%b8%a4%e4%b8%aa%e4%b8%8d%e5%90%8c%e7%9a%84%e5%8d%95%e8%af%8d" aria-label="使用 grep 命令去搜索两个不同的单词">使用 grep 命令去搜索两个不同的单词</a></li>
                <li>
                    <a href="#%e7%bb%9f%e8%ae%a1%e6%96%87%e6%9c%ac%e5%8c%b9%e9%85%8d%e5%88%b0%e7%9a%84%e8%a1%8c%e6%95%b0" aria-label="统计文本匹配到的行数">统计文本匹配到的行数</a></li>
                <li>
                    <a href="#%e5%8f%8d%e8%bd%ac%e5%8c%b9%e9%85%8d%e4%b8%8d%e5%8c%b9%e9%85%8d" aria-label="反转匹配（不匹配）">反转匹配（不匹配）</a></li>
                <li>
                    <a href="#unixlinux-%e7%ae%a1%e9%81%93%e4%b8%8e-grep-%e5%91%bd%e4%bb%a4" aria-label="UNIX/Linux 管道与 grep 命令">UNIX/Linux 管道与 grep 命令</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e4%bb%85%e4%bb%85%e6%98%be%e7%a4%ba%e5%8c%b9%e9%85%8d%e5%88%b0%e5%86%85%e5%ae%b9%e7%9a%84%e6%96%87%e4%bb%b6%e5%90%8d%e5%ad%97" aria-label="如何仅仅显示匹配到内容的文件名字?">如何仅仅显示匹配到内容的文件名字?</a></li>
                <li>
                    <a href="#%e6%9f%a5%e6%89%be%e6%96%87%e4%bb%b6%e5%86%85%e5%ae%b9httpswwwrunoobcomnote48437" aria-label="查找文件内容"><a href="https://www.runoob.com/note/48437">查找文件内容</a></a></li></ul>
                </li>
                <li>
                    <a href="#cat" aria-label="cat">cat</a><ul>
                        
                <li>
                    <a href="#bathttpsgithubcomsharkdpbat" aria-label="bat"><a href="https://github.com/sharkdp/bat">bat</a></a></li></ul>
                </li>
                <li>
                    <a href="#iphttpslinuxcnarticle-3144-1html" aria-label="ip"><a href="https://linux.cn/article-3144-1.html">ip</a></a><ul>
                        
                <li>
                    <a href="#%e8%ae%be%e7%bd%ae%e5%92%8c%e5%88%a0%e9%99%a4ip%e5%9c%b0%e5%9d%80" aria-label="设置和删除Ip地址">设置和删除Ip地址</a></li>
                <li>
                    <a href="#%e5%88%97%e5%87%ba%e8%b7%af%e7%94%b1%e8%a1%a8%e6%9d%a1%e7%9b%ae" aria-label="列出路由表条目">列出路由表条目</a></li>
                <li>
                    <a href="#%e6%9b%b4%e6%94%b9%e9%bb%98%e8%ae%a4%e8%b7%af%e7%94%b1" aria-label="更改默认路由">更改默认路由</a></li>
                <li>
                    <a href="#%e6%98%be%e7%a4%ba%e7%bd%91%e7%bb%9c%e7%bb%9f%e8%ae%a1%e6%95%b0%e6%8d%ae" aria-label="显示网络统计数据">显示网络统计数据</a></li>
                <li>
                    <a href="#arp%e6%9d%a1%e7%9b%ae" aria-label="ARP条目">ARP条目</a></li>
                <li>
                    <a href="#%e7%9b%91%e6%8e%a7netlink%e6%b6%88%e6%81%af" aria-label="监控netlink消息">监控netlink消息</a></li>
                <li>
                    <a href="#%e6%bf%80%e6%b4%bb%e5%92%8c%e5%81%9c%e6%ad%a2%e7%bd%91%e7%bb%9c%e6%8e%a5%e5%8f%a3" aria-label="激活和停止网络接口">激活和停止网络接口</a></li>
                <li>
                    <a href="#%e8%8e%b7%e5%8f%96%e5%b8%ae%e5%8a%a9" aria-label="获取帮助">获取帮助</a></li>
                <li>
                    <a href="#%e5%b0%8f%e7%bb%93" aria-label="小结">小结</a></li></ul>
                </li>
                <li>
                    <a href="#dighttpslinuxcnarticle-14051-1html" aria-label="dig"><a href="https://linux.cn/article-14051-1.html">dig</a></a><ul>
                        
                <li>
                    <a href="#%e5%8f%82%e6%95%b0%e7%b1%bb%e5%9e%8b%e6%9f%a5%e8%af%a2%e5%92%8c%e6%a0%bc%e5%bc%8f%e5%8c%96" aria-label="参数类型：查询和格式化">参数类型：查询和格式化</a></li>
                <li>
                    <a href="#%e4%b8%bb%e8%a6%81%e7%9a%84%e6%9f%a5%e8%af%a2%e9%80%89%e9%a1%b9" aria-label="主要的查询选项">主要的查询选项</a></li>
                <li>
                    <a href="#%e6%a0%bc%e5%bc%8f%e5%8c%96%e5%93%8d%e5%ba%94%e7%9a%84%e9%80%89%e9%a1%b9" aria-label="格式化响应的选项">格式化响应的选项</a></li>
                <li>
                    <a href="#digrc" aria-label="digrc"><code>digrc</code></a></li>
                <li>
                    <a href="#dig-trace" aria-label="dig &#43;trace">dig +trace</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8-dig" aria-label="为什么要用 dig">为什么要用 dig</a></li></ul>
                </li>
                <li>
                    <a href="#sambahttpswwwcnblogscomgzdaijiep5194033html" aria-label="Samba"><a href="https://www.cnblogs.com/gzdaijie/p/5194033.html">Samba</a></a><ul>
                        
                <li>
                    <a href="#%e5%ae%89%e8%a3%85-3" aria-label="安装">安装</a></li>
                <li>
                    <a href="#%e5%88%9b%e5%bb%ba%e5%85%b1%e4%ba%ab" aria-label="创建共享">创建共享</a></li>
                <li>
                    <a href="#%e7%94%a8%e6%88%b7%e7%ae%a1%e7%90%86" aria-label="用户管理">用户管理</a></li>
                <li>
                    <a href="#which-is-faster-samba-or-scphttpsarstechnicacomcivisviewtopicphpf16t365900" aria-label="Which is faster-Samba or scp?"><a href="https://arstechnica.com/civis/viewtopic.php?f=16&amp;t=365900">Which is faster-Samba or scp?</a></a></li></ul>
                </li>
                <li>
                    <a href="#sudohttpswwwcnblogscomsparkdevp6189196html" aria-label="sudo"><a href="https://www.cnblogs.com/sparkdev/p/6189196.html">sudo</a></a><ul>
                        
                <li>
                    <a href="#%e5%91%bd%e4%bb%a4%e8%af%ad%e6%b3%95" aria-label="命令语法">命令语法</a></li>
                <li>
                    <a href="#%e5%9f%ba%e6%9c%ac%e9%85%8d%e7%bd%ae" aria-label="基本配置">基本配置</a></li>
                <li>
                    <a href="#%e8%af%a6%e7%bb%86%e9%85%8d%e7%bd%ae" aria-label="详细配置">详细配置</a></li>
                <li>
                    <a href="#%e6%97%a5%e5%bf%97" aria-label="日志">日志</a></li>
                <li>
                    <a href="#%e4%b8%8e%e8%be%93%e5%87%ba%e9%87%8d%e5%ae%9a%e5%90%91httpswwwcnblogscomsparkdevp10287164html" aria-label="与输出重定向"><a href="https://www.cnblogs.com/sparkdev/p/10287164.html">与输出重定向</a></a></li></ul>
                </li>
                <li>
                    <a href="#fdiskhttpswwwcnblogscomsparkdevp10095916html" aria-label="fdisk"><a href="https://www.cnblogs.com/sparkdev/p/10095916.html">fdisk</a></a><ul>
                        
                <li>
                    <a href="#%e7%a3%81%e7%9b%98%e5%88%86%e7%b1%bb" aria-label="磁盘分类">磁盘分类</a></li>
                <li>
                    <a href="#%e8%a1%a8%e7%a4%ba%e6%96%b9%e6%b3%95" aria-label="表示方法">表示方法</a></li>
                <li>
                    <a href="#%e7%a3%81%e7%9b%98%e5%88%86%e5%8c%ba" aria-label="磁盘分区">磁盘分区</a></li>
                <li>
                    <a href="#%e5%88%92%e5%88%86%e7%a3%81%e7%9b%98%e5%88%86%e5%8c%ba" aria-label="划分磁盘分区">划分磁盘分区</a></li></ul>
                </li>
                <li>
                    <a href="#fuserhttpswwwcnblogscomsungeekp11857549html" aria-label="fuser"><a href="https://www.cnblogs.com/Sungeek/p/11857549.html">fuser</a></a><ul>
                        
                <li>
                    <a href="#%e6%8f%8f%e8%bf%b0" aria-label="描述">描述</a></li>
                <li>
                    <a href="#%e9%80%89%e9%a1%b9" aria-label="选项">选项</a></li>
                <li>
                    <a href="#%e7%a4%ba%e4%be%8b" aria-label="示例">示例</a></li></ul>
                </li>
                <li>
                    <a href="#tcpdumphttpssegmentfaultcoma1190000018944427" aria-label="tcpdump"><a href="https://segmentfault.com/a/1190000018944427">tcpdump</a></a><ul>
                        
                <li>
                    <a href="#%e5%91%bd%e4%bb%a4%e9%80%89%e9%a1%b9" aria-label="命令选项">命令选项</a></li>
                <li>
                    <a href="#%e8%bf%87%e6%bb%a4%e5%99%a8" aria-label="过滤器">过滤器</a></li>
                <li>
                    <a href="#%e5%b8%b8%e7%94%a8%e6%93%8d%e4%bd%9c" aria-label="常用操作">常用操作</a><ul>
                        
                <li>
                    <a href="#%e6%8a%93%e5%8f%96%e6%9f%90%e4%b8%bb%e6%9c%ba%e7%9a%84%e6%95%b0%e6%8d%ae%e5%8c%85" aria-label="抓取某主机的数据包">抓取某主机的数据包</a></li>
                <li>
                    <a href="#%e6%8a%93%e5%8f%96%e6%9f%90%e7%ab%af%e5%8f%a3%e7%9a%84%e6%95%b0%e6%8d%ae%e5%8c%85" aria-label="抓取某端口的数据包">抓取某端口的数据包</a></li>
                <li>
                    <a href="#%e6%8a%93%e5%8f%96%e6%9f%90%e7%bd%91%e7%bb%9c%e7%bd%91%e6%ae%b5%e7%9a%84%e6%95%b0%e6%8d%ae%e5%8c%85" aria-label="抓取某网络（网段）的数据包">抓取某网络（网段）的数据包</a></li>
                <li>
                    <a href="#%e6%8a%93%e5%8f%96%e6%9f%90%e5%8d%8f%e8%ae%ae%e7%9a%84%e6%95%b0%e6%8d%ae%e5%8c%85" aria-label="抓取某协议的数据包">抓取某协议的数据包</a></li>
                <li>
                    <a href="#%e5%a4%8d%e6%9d%82%e7%9a%84%e8%bf%87%e6%bb%a4%e6%9d%a1%e4%bb%b6" aria-label="复杂的过滤条件">复杂的过滤条件</a></li></ul>
                </li>
                <li>
                    <a href="#%e4%b8%8e%e5%85%b6%e4%bb%96%e5%b7%a5%e5%85%b7%e7%9a%84%e9%85%8d%e5%90%88" aria-label="与其他工具的配合">与其他工具的配合</a></li>
                <li>
                    <a href="#tcpdump-%e7%9a%84%e8%be%93%e5%87%ba%e6%a0%bc%e5%bc%8f" aria-label="tcpdump 的输出格式">tcpdump 的输出格式</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#others-2" aria-label="Others">Others</a><ul>
                        
                <li>
                    <a href="#ubuntu-packages-searchhttpspackagesubuntucom" aria-label="Ubuntu Packages Search"><a href="https://packages.ubuntu.com/">Ubuntu Packages Search</a></a></li>
                <li>
                    <a href="#list-of-applicationsarchhttpswikiarchlinuxorgtitlelist_of_applications" aria-label="List of applications—Arch"><a href="https://wiki.archlinux.org/title/List_of_applications">List of applications—Arch</a></a></li>
                <li>
                    <a href="#%e5%b8%b8%e7%94%a8%e8%bd%af%e4%bb%b6opensusehttpszhopensuseorge5b8b8e794a8e8bdafe4bbb6" aria-label="常用软件—openSUSE"><a href="https://zh.opensuse.org/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6">常用软件—openSUSE</a></a></li>
                <li>
                    <a href="#%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8fubuntuhttpswikiubuntucomcne9a696e9a1b5" aria-label="应用程序—Ubuntu"><a href="https://wiki.ubuntu.com.cn/%E9%A6%96%E9%A1%B5">应用程序—Ubuntu</a></a></li>
                <li>
                    <a href="#%e7%94%9f%e6%80%81%e9%80%82%e9%85%8d%e6%b8%85%e5%8d%95uoshttpswwwchinauoscomecologyadapt" aria-label="生态适配清单—UOS"><a href="https://www.chinauos.com/ecology/adapt">生态适配清单—UOS</a></a></li></ul>
                </li>
                <li>
                    <a href="#qemu-kvmhttpswikiarchlinuxorgtitleqemu_e7ae80e4bd93e4b8ade69687" aria-label="QEMU KVM"><a href="https://wiki.archlinux.org/title/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">QEMU KVM</a></a><ul>
                        
                <li>
                    <a href="#qemu-%e7%9a%84%e5%9b%be%e5%bd%a2%e5%89%8d%e7%ab%af" aria-label="QEMU 的图形前端">QEMU 的图形前端</a></li>
                <li>
                    <a href="#%e5%88%9b%e5%bb%ba%e6%96%b0%e8%99%9a%e6%8b%9f%e7%b3%bb%e7%bb%9f" aria-label="创建新虚拟系统">创建新虚拟系统</a><ul>
                        
                <li>
                    <a href="#%e5%88%9b%e5%bb%ba%e7%a1%ac%e7%9b%98%e9%95%9c%e5%83%8f" aria-label="创建硬盘镜像">创建硬盘镜像</a></li>
                <li>
                    <a href="#%e5%ae%89%e8%a3%85%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f" aria-label="安装操作系统">安装操作系统</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%bf%90%e8%a1%8c%e8%99%9a%e6%8b%9f%e5%8c%96%e7%9a%84%e7%b3%bb%e7%bb%9f" aria-label="运行虚拟化的系统">运行虚拟化的系统</a><ul>
                        
                <li>
                    <a href="#%e5%90%af%e7%94%a8-kvm" aria-label="启用 KVM">启用 KVM</a></li>
                <li>
                    <a href="#%e5%90%af%e7%94%a8-iommu-intel-vt-damd-vi-%e7%9a%84%e6%94%af%e6%8c%81" aria-label="启用 IOMMU (Intel VT-d/AMD-Vi) 的支持">启用 IOMMU (Intel VT-d/AMD-Vi) 的支持</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%ae%bf%e4%b8%bb%e6%9c%ba%e5%92%8c%e8%99%9a%e6%8b%9f%e6%9c%ba%e6%95%b0%e6%8d%ae%e4%ba%a4%e4%ba%92" aria-label="宿主机和虚拟机数据交互">宿主机和虚拟机数据交互</a><ul>
                        
                <li>
                    <a href="#%e7%bd%91%e7%bb%9c" aria-label="网络">网络</a></li>
                <li>
                    <a href="#qemu-%e7%ab%af%e5%8f%a3%e8%bd%ac%e5%8f%91" aria-label="QEMU 端口转发">QEMU 端口转发</a></li>
                <li>
                    <a href="#qemu-%e7%9a%84%e5%86%85%e7%bd%aesmb%e6%9c%8d%e5%8a%a1%e5%99%a8" aria-label="QEMU 的内置SMB服务器">QEMU 的内置SMB服务器</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%bd%91%e7%bb%9c-1" aria-label="网络">网络</a><ul>
                        
                <li>
                    <a href="#%e5%85%b3%e4%ba%8e%e9%93%be%e8%b7%af%e5%b1%82%e5%9c%b0%e5%9d%80%e7%9a%84%e9%99%90%e5%88%b6" aria-label="关于链路层地址的限制">关于链路层地址的限制</a></li>
                <li>
                    <a href="#%e7%94%a8%e6%88%b7%e6%a8%a1%e5%bc%8f" aria-label="用户模式">用户模式</a></li>
                <li>
                    <a href="#tap-%e7%bd%91%e7%bb%9c" aria-label="Tap 网络">Tap 网络</a></li>
                <li>
                    <a href="#%e9%80%9a%e8%bf%87-vde2-%e9%85%8d%e7%bd%ae%e7%bd%91%e7%bb%9c" aria-label="通过 VDE2 配置网络">通过 VDE2 配置网络</a></li>
                <li>
                    <a href="#vde2-%e7%bd%91%e6%a1%a5" aria-label="VDE2 网桥">VDE2 网桥</a></li>
                <li>
                    <a href="#%e7%ae%80%e5%8c%96%e9%85%8d%e7%bd%ae%e5%8f%82%e6%95%b0" aria-label="简化配置参数">简化配置参数</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%9b%be%e5%bd%a2" aria-label="图形">图形</a><ul>
                        
                <li>
                    <a href="#std" aria-label="std">std</a></li>
                <li>
                    <a href="#qxl" aria-label="qxl">qxl</a></li>
                <li>
                    <a href="#vmware" aria-label="vmware">vmware</a></li>
                <li>
                    <a href="#virtio" aria-label="virtio">virtio</a></li>
                <li>
                    <a href="#cirrus" aria-label="cirrus">cirrus</a></li>
                <li>
                    <a href="#none" aria-label="none">none</a></li></ul>
                </li>
                <li>
                    <a href="#spice" aria-label="SPICE">SPICE</a></li>
                <li>
                    <a href="#vnc" aria-label="VNC">VNC</a></li>
                <li>
                    <a href="#%e9%9f%b3%e9%a2%91" aria-label="音频">音频</a><ul>
                        
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8%e9%9f%b3%e9%a2%91%e8%ae%be%e5%a4%87" aria-label="使用音频设备">使用音频设备</a></li>
                <li>
                    <a href="#%e6%97%a0%e9%9f%b3%e9%a2%91%e8%ae%be%e5%a4%87" aria-label="无音频设备">无音频设备</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%ae%89%e8%a3%85-virtio-%e9%a9%b1%e5%8a%a8" aria-label="安装 virtio 驱动">安装 virtio 驱动</a><ul>
                        
                <li>
                    <a href="#%e5%9d%97%e8%ae%be%e5%a4%87%e9%a9%b1%e5%8a%a8" aria-label="块设备驱动">块设备驱动</a></li>
                <li>
                    <a href="#%e7%bd%91%e7%bb%9c%e9%a9%b1%e5%8a%a8" aria-label="网络驱动">网络驱动</a></li>
                <li>
                    <a href="#balloon-%e9%a9%b1%e5%8a%a8" aria-label="Balloon 驱动">Balloon 驱动</a></li></ul>
                </li>
                <li>
                    <a href="#qemu-%e7%9b%91%e8%a7%86%e5%99%a8" aria-label="QEMU 监视器">QEMU 监视器</a><ul>
                        
                <li>
                    <a href="#%e8%ae%bf%e9%97%aeqemu%e7%9b%91%e8%a7%86%e5%99%a8console" aria-label="访问QEMU监视器Console">访问QEMU监视器Console</a></li>
                <li>
                    <a href="#%e5%9c%a8monitor-conosle%e4%b8%8b%e5%90%91%e8%99%9a%e6%8b%9f%e6%9c%ba%e5%8f%91%e9%80%81%e6%8c%89%e9%94%ae%e8%a1%8c%e4%b8%ba" aria-label="在Monitor conosle下向虚拟机发送按键行为">在Monitor conosle下向虚拟机发送按键行为</a></li>
                <li>
                    <a href="#%e9%80%9a%e8%bf%87-monitor-console-%e5%88%9b%e5%bb%ba%e5%bf%ab%e7%85%a7%e5%92%8c%e7%ae%a1%e7%90%86%e5%bf%ab%e7%85%a7" aria-label="通过 monitor console 创建快照和管理快照">通过 monitor console 创建快照和管理快照</a></li>
                <li>
                    <a href="#%e4%bb%a5%e5%86%bb%e7%bb%93%e6%a8%a1%e5%bc%8f%e8%bf%90%e8%a1%8c%e8%99%9a%e6%8b%9f%e6%9c%ba" aria-label="以冻结模式运行虚拟机">以冻结模式运行虚拟机</a></li>
                <li>
                    <a href="#monitor-console%e4%b8%ad%e7%9a%84%e5%bc%80%e6%9c%ba%e5%92%8c%e6%9a%82%e5%81%9c%e5%91%bd%e4%bb%a4" aria-label="monitor console中的开机和暂停命令">monitor console中的开机和暂停命令</a></li>
                <li>
                    <a href="#%e8%99%9a%e6%8b%9f%e6%9c%ba%e6%88%aa%e5%b1%8f" aria-label="虚拟机截屏">虚拟机截屏</a></li></ul>
                </li>
                <li>
                    <a href="#qemu-%e6%9c%ba%e5%99%a8%e5%8d%8f%e8%ae%ae" aria-label="QEMU 机器协议">QEMU 机器协议</a></li>
                <li>
                    <a href="#%e6%8a%80%e5%b7%a7" aria-label="技巧">技巧</a><ul>
                        
                <li>
                    <a href="#%e6%94%b9%e5%96%84%e8%99%9a%e6%8b%9f%e6%9c%ba%e7%9a%84%e6%80%a7%e8%83%bd%e8%a1%a8%e7%8e%b0" aria-label="改善虚拟机的性能表现">改善虚拟机的性能表现</a></li>
                <li>
                    <a href="#%e5%bc%80%e6%9c%ba%e6%97%b6%e5%90%af%e5%8a%a8qemu%e8%99%9a%e6%8b%9f%e6%9c%ba" aria-label="开机时启动QEMU虚拟机">开机时启动QEMU虚拟机</a></li>
                <li>
                    <a href="#%e9%bc%a0%e6%a0%87%e6%95%b4%e5%90%88" aria-label="鼠标整合">鼠标整合</a></li>
                <li>
                    <a href="#%e5%ae%bf%e4%b8%bb%e6%9c%ba%e7%9a%84usb%e8%ae%be%e5%a4%87%e4%bc%a0%e9%80%92%e8%87%b3%e8%99%9a%e6%8b%9f%e6%9c%ba" aria-label="宿主机的USB设备传递至虚拟机">宿主机的USB设备传递至虚拟机</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8spice%e8%bf%9b%e8%a1%8cusb%e9%87%8d%e5%ae%9a%e5%90%91" aria-label="使用SPICE进行USB重定向">使用SPICE进行USB重定向</a></li>
                <li>
                    <a href="#%e5%bc%80%e5%90%afksm" aria-label="开启KSM">开启KSM</a></li>
                <li>
                    <a href="#%e5%a4%9a%e5%b1%8f%e6%94%af%e6%8c%81" aria-label="多屏支持">多屏支持</a></li>
                <li>
                    <a href="#%e5%a4%8d%e5%88%b6%e5%92%8c%e7%b2%98%e8%b4%b4" aria-label="复制和粘贴">复制和粘贴</a></li></ul>
                </li>
                <li>
                    <a href="#qemu-kvm-win7httpswwwcnblogscomsammyliup5740129html" aria-label="QEMU-KVM Win7"><a href="https://www.cnblogs.com/sammyliu/p/5740129.html">QEMU-KVM Win7</a></a><ul>
                        
                <li>
                    <a href="#%e7%8e%af%e5%a2%83%e5%87%86%e5%a4%87" aria-label="环境准备">环境准备</a></li>
                <li>
                    <a href="#%e5%ae%89%e8%a3%85-win-7" aria-label="安装 Win 7">安装 Win 7</a></li>
                <li>
                    <a href="#%e5%ae%89%e8%a3%85-virtio-%e7%bd%91%e7%bb%9c%e9%a9%b1%e5%8a%a8" aria-label="安装 Virtio 网络驱动">安装 Virtio 网络驱动</a></li>
                <li>
                    <a href="#qemu-%e7%9a%84%e5%86%85%e7%bd%aesmb%e6%9c%8d%e5%8a%a1%e5%99%a8qemu-%e7%9a%84%e5%86%85%e7%bd%aesmb%e6%9c%8d%e5%8a%a1%e5%99%a8" aria-label="[QEMU 的内置SMB服务器](#QEMU 的内置SMB服务器)">[QEMU 的内置SMB服务器](#QEMU 的内置SMB服务器)</a></li>
                <li>
                    <a href="#%e5%ae%bf%e4%b8%bb%e6%9c%ba%e7%9a%84usb%e8%ae%be%e5%a4%87%e4%bc%a0%e9%80%92%e8%87%b3%e8%99%9a%e6%8b%9f%e6%9c%ba%e5%ae%bf%e4%b8%bb%e6%9c%ba%e7%9a%84usb%e8%ae%be%e5%a4%87%e4%bc%a0%e9%80%92%e8%87%b3%e8%99%9a%e6%8b%9f%e6%9c%ba" aria-label="宿主机的USB设备传递至虚拟机"><a href="#%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%9A%84USB%E8%AE%BE%E5%A4%87%E4%BC%A0%E9%80%92%E8%87%B3%E8%99%9A%E6%8B%9F%E6%9C%BA">宿主机的USB设备传递至虚拟机</a></a></li></ul>
                </li>
                <li>
                    <a href="#qemu-kvm-winxp-sp3" aria-label="QEMU-KVM WinXP SP3">QEMU-KVM WinXP SP3</a><ul>
                        
                <li>
                    <a href="#windows_xpshhttpsgistgithubcomandrusha1000766" aria-label="windows_xp.sh"><a href="https://gist.github.com/andrusha/1000766">windows_xp.sh</a></a><ul>
                        
                <li>
                    <a href="#windows-xp-cannot-connect-to-samba-sharehttpsaskubuntucomquestions1268132windows-xp-cannot-connect-to-samba-share-linux-server-20-04" aria-label="Windows XP cannot connect to samba share"><a href="https://askubuntu.com/questions/1268132/windows-xp-cannot-connect-to-samba-share-linux-server-20-04">Windows XP cannot connect to samba share</a></a></li>
                <li>
                    <a href="#windows-xp-%e4%b8%8a%e7%bd%91%e6%8f%90%e7%a4%ba%e6%82%a8%e7%9a%84%e6%97%b6%e9%92%9f%e5%bf%ab%e4%ba%86%e6%85%a2%e4%ba%86httpsblogcsdnnetjohnnysun2015articledetails104888159" aria-label="Windows XP 上网提示：您的时钟快了/慢了"><a href="https://blog.csdn.net/JohnnySun2015/article/details/104888159">Windows XP 上网提示：您的时钟快了/慢了</a></a></li></ul>
                </li>
                <li>
                    <a href="#virtual-machine-manager" aria-label="Virtual Machine Manager">Virtual Machine Manager</a><ul>
                        
                <li>
                    <a href="#%e9%94%ae%e7%9b%98%e4%b8%8d%e8%83%bd%e8%be%93%e5%85%a5%e7%9a%84%e9%97%ae%e9%a2%98httpsblog51ctocomwsxxsl1914181" aria-label="键盘不能输入的问题"><a href="https://blog.51cto.com/wsxxsl/1914181">键盘不能输入的问题</a></a></li>
                <li>
                    <a href="#%e6%97%a0%e7%bd%91%e7%bb%9c" aria-label="无网络">无网络</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#qemu-kvm-gentoohttpswikigentooorgwikiqemulinux_guest" aria-label="QEMU-KVM Gentoo"><a href="https://wiki.gentoo.org/wiki/QEMU/Linux_guest">QEMU-KVM Gentoo</a></a><ul>
                        
                <li>
                    <a href="#configuration" aria-label="Configuration">Configuration</a><ul>
                        
                <li>
                    <a href="#host" aria-label="Host">Host</a></li>
                <li>
                    <a href="#using-uefi-with-qemuhttpsfedoraprojectorgwikiusing_uefi_with_qemu" aria-label="Using UEFI with QEMU"><a href="https://fedoraproject.org/wiki/Using_UEFI_with_QEMU">Using UEFI with QEMU</a></a></li></ul>
                </li>
                <li>
                    <a href="#bdsdxe-failed-to-load-boot0001httpsgithubcomutmapputmissues2333" aria-label="&amp;ldquo;BdsDxe: failed to load Boot0001&amp;rdquo;"><a href="https://github.com/utmapp/UTM/issues/2333">&ldquo;BdsDxe: failed to load Boot0001&rdquo;</a></a></li></ul>
                </li>
                <li>
                    <a href="#tips" aria-label="Tips">Tips</a><ul>
                        
                <li>
                    <a href="#%e9%80%9a%e8%bf%87-qemu-%e5%ae%89%e8%a3%85-windows-%e5%88%b0%e7%a1%ac%e7%9b%98" aria-label="通过 Qemu 安装 Windows 到硬盘">通过 Qemu 安装 Windows 到硬盘</a></li>
                <li>
                    <a href="#looking-glasshttpslooking-glassiodocs" aria-label="Looking Glass"><a href="https://looking-glass.io/docs">Looking Glass</a></a></li>
                <li>
                    <a href="#xrdphttpsgithubcomneutrinolabsxrdp" aria-label="xrdp"><a href="https://github.com/neutrinolabs/xrdp">xrdp</a></a></li>
                <li>
                    <a href="#qemukvm-vs-virtualbox" aria-label="QEMU/KVM VS Virtualbox">QEMU/KVM VS Virtualbox</a></li></ul>
                </li>
                <li>
                    <a href="#libvirthttpswikiarchlinuxorgtitlelibvirt_e7ae80e4bd93e4b8ade69687" aria-label="libvirt"><a href="https://wiki.archlinux.org/title/Libvirt_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">libvirt</a></a><ul>
                        
                <li>
                    <a href="#%e5%ae%89%e8%a3%85httpsubuntucomserverdocsvirtualization-libvirt" aria-label="安装"><a href="https://ubuntu.com/server/docs/virtualization-libvirt">安装</a></a></li>
                <li>
                    <a href="#%e9%85%8d%e7%bd%ae-2" aria-label="配置">配置</a><ul>
                        
                <li>
                    <a href="#%e8%ae%be%e7%bd%ae%e6%8e%88%e6%9d%83" aria-label="设置授权">设置授权</a></li>
                <li>
                    <a href="#%e5%ae%88%e6%8a%a4%e8%bf%9b%e7%a8%8b" aria-label="守护进程">守护进程</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%b5%8b%e8%af%95" aria-label="测试">测试</a></li>
                <li>
                    <a href="#%e7%ae%a1%e7%90%86-1" aria-label="管理">管理</a><ul>
                        
                <li>
                    <a href="#virsh" aria-label="virsh">virsh</a></li>
                <li>
                    <a href="#%e5%ad%98%e5%82%a8%e6%b1%a0" aria-label="存储池">存储池</a></li>
                <li>
                    <a href="#%e5%ad%98%e5%82%a8%e5%8d%b7" aria-label="存储卷">存储卷</a></li>
                <li>
                    <a href="#%e5%9f%9f" aria-label="域">域</a></li>
                <li>
                    <a href="#%e7%bd%91%e7%bb%9c-2" aria-label="网络">网络</a></li></ul>
                </li>
                <li>
                    <a href="#uefi-%e6%94%af%e6%8c%81" aria-label="UEFI 支持">UEFI 支持</a></li></ul>
                </li>
                <li>
                    <a href="#vm-%e7%9b%b8%e5%85%b3" aria-label="VM 相关">VM 相关</a><ul>
                        
                <li>
                    <a href="#virtualbox" aria-label="VirtualBox">VirtualBox</a><ul>
                        
                <li>
                    <a href="#%e5%a2%9e%e5%8a%a0%e7%8e%b0%e6%9c%89%e8%99%9a%e6%8b%9f%e6%9c%ba%e7%9a%84%e7%a3%81%e7%9b%98%e5%a4%a7%e5%b0%8fhttpslinuxcnarticle-12869-1html" aria-label="增加现有虚拟机的磁盘大小"><a href="https://linux.cn/article-12869-1.html">增加现有虚拟机的磁盘大小</a></a></li>
                <li>
                    <a href="#seamless-modehttpswwwtl80cnarticle43389" aria-label="Seamless Mode"><a href="https://www.tl80.cn/article/43389">Seamless Mode</a></a></li>
                <li>
                    <a href="#vboxwinxp-sp3" aria-label="VBox&#43;WinXP SP3">VBox+WinXP SP3</a></li>
                <li>
                    <a href="#vs-vmwarehttpswwwzhihucomquestion33701295" aria-label="vs VMWare"><a href="https://www.zhihu.com/question/33701295">vs VMWare</a></a></li>
                <li>
                    <a href="#%e8%99%9a%e6%8b%9f%e6%9c%ba%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%bc%8fhttpswwwcnblogscomggjuchengarchive201208192646007html" aria-label="虚拟机网络模式"><a href="https://www.cnblogs.com/ggjucheng/archive/2012/08/19/2646007.html">虚拟机网络模式</a></a></li></ul>
                </li>
                <li>
                    <a href="#podmanhttpsgithubcomcontainerspodman" aria-label="podman"><a href="https://github.com/containers/podman">podman</a></a></li>
                <li>
                    <a href="#android-x86httpslinuxcnarticle-11711-1html" aria-label="Android-x86"><a href="https://linux.cn/article-11711-1.html">Android-x86</a></a></li>
                <li>
                    <a href="#anboxhttpslinuxcnarticle-10843-1html" aria-label="Anbox"><a href="https://linux.cn/article-10843-1.html">Anbox</a></a><ul>
                        
                <li>
                    <a href="#anbox-%e7%ae%80%e4%bb%8b" aria-label="Anbox 简介">Anbox 简介</a></li>
                <li>
                    <a href="#%e5%ae%89%e8%a3%85%e4%bd%bf%e7%94%a8" aria-label="安装使用">安装使用</a></li></ul>
                </li>
                <li>
                    <a href="#waydroidhttpswaydroid" aria-label="Waydroid"><a href="https://waydro.id/">Waydroid</a></a></li>
                <li>
                    <a href="#genymotionhttpswwwgenymotioncom" aria-label="Genymotion"><a href="https://www.genymotion.com/">Genymotion</a></a></li>
                <li>
                    <a href="#looking-glasshttpslooking-glassio" aria-label="Looking Glass"><a href="https://looking-glass.io/">Looking Glass</a></a></li>
                <li>
                    <a href="#libvfiohttpsarccomputecombloglibvfio-commodity-gpu-multiplexing" aria-label="LibVF.IO"><a href="https://arccompute.com/blog/libvfio-commodity-gpu-multiplexing/">LibVF.IO</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#winehttpswikiarchlinuxorgtitlewine_e7ae80e4bd93e4b8ade69687" aria-label="Wine"><a href="https://wiki.archlinux.org/title/Wine_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Wine</a></a><ul>
                        
                <li>
                    <a href="#%e7%ae%80%e4%bb%8bhttpszhmwikipediaorgwikiwine" aria-label="简介"><a href="https://zh.m.wikipedia.org/wiki/Wine">简介</a></a></li>
                <li>
                    <a href="#%e5%ae%89%e8%a3%85httpswikiwinehqorgubuntu" aria-label="安装"><a href="https://wiki.winehq.org/Ubuntu">安装</a></a></li>
                <li>
                    <a href="#%e9%85%8d%e7%bd%ae-3" aria-label="配置">配置</a><ul>
                        
                <li>
                    <a href="#%e5%88%9d%e5%a7%8b%e8%ae%be%e7%bd%aehttpswikiubuntuorgcnubuntuhelpwinezh" aria-label="初始设置"><a href="https://wiki.ubuntu.org.cn/UbuntuHelp:Wine/zh">初始设置</a></a></li>
                <li>
                    <a href="#wineprefix" aria-label="WINEPREFIX">WINEPREFIX</a></li>
                <li>
                    <a href="#winearch" aria-label="WINEARCH">WINEARCH</a></li>
                <li>
                    <a href="#%e5%9b%be%e5%bd%a2%e9%a9%b1%e5%8a%a8" aria-label="图形驱动">图形驱动</a></li>
                <li>
                    <a href="#%e5%a3%b0%e9%9f%b3" aria-label="声音">声音</a></li>
                <li>
                    <a href="#%e5%ad%97%e4%bd%93" aria-label="字体">字体</a></li>
                <li>
                    <a href="#%e5%90%af%e5%8a%a8%e5%99%a8%e5%92%8c%e8%8f%9c%e5%8d%95" aria-label="启动器和菜单">启动器和菜单</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%ae%89%e8%a3%85%e8%bf%90%e8%a1%8c%e5%8d%b8%e8%bd%bd-windows-%e7%a8%8b%e5%ba%8f" aria-label="安装/运行/卸载 Windows 程序">安装/运行/卸载 Windows 程序</a></li>
                <li>
                    <a href="#%e6%8a%80%e5%b7%a7-1" aria-label="技巧">技巧</a><ul>
                        
                <li>
                    <a href="#opengl-%e6%a8%a1%e5%bc%8f" aria-label="OpenGL 模式">OpenGL 模式</a></li>
                <li>
                    <a href="#wine-%e6%8e%a7%e5%88%b6%e5%8f%b0" aria-label="Wine 控制台">Wine 控制台</a></li>
                <li>
                    <a href="#winetrickshttpswikiwinehqorgwinetricks" aria-label="winetricks"><a href="https://wiki.winehq.org/Winetricks">winetricks</a></a></li>
                <li>
                    <a href="#monohttpswikiwinehqorgmono--geckohttpswikiwinehqorggecko" aria-label="Mono &amp;amp; Gecko"><a href="https://wiki.winehq.org/Mono">Mono</a> &amp; <a href="https://wiki.winehq.org/Gecko">Gecko</a></a></li></ul>
                </li>
                <li>
                    <a href="#crossoverhttpswwwcodeweaverscom" aria-label="CrossOver"><a href="https://www.codeweavers.com">CrossOver</a></a><ul>
                        
                <li>
                    <a href="#tutorialshttpswwwcodeweaverscomsupportwikilinuxlinuxtutorial" aria-label="Tutorials"><a href="https://www.codeweavers.com/support/wiki/linux/linuxtutorial">Tutorials</a></a></li>
                <li>
                    <a href="#dxvkhttpswwwcodeweaverscomsupportwikilinuxlinuxtutorialdxvk" aria-label="DXVK"><a href="https://www.codeweavers.com/support/wiki/linux/linuxtutorial/dxvk">DXVK</a></a></li>
                <li>
                    <a href="#esynchttpsgithubcomzfigurawineblobesyncreadmeesync" aria-label="Esync"><a href="https://github.com/zfigura/wine/blob/esync/README.esync">Esync</a></a><ul>
                        
                <li>
                    <a href="#howtoesynchttpsgithubcomlutrisdocsblobmasterhowtoesyncmd" aria-label="HowToEsync"><a href="https://github.com/lutris/docs/blob/master/HowToEsync.md">HowToEsync</a></a></li></ul>
                </li>
                <li>
                    <a href="#%e4%b8%ad%e6%96%87%e4%b9%b1%e7%a0%81httpsblogcsdnnetqq_35503971articledetails107296647" aria-label="中文乱码"><a href="https://blog.csdn.net/qq_35503971/article/details/107296647">中文乱码</a></a></li></ul>
                </li>
                <li>
                    <a href="#%e5%ae%9e%e4%be%8b" aria-label="实例">实例</a><ul>
                        
                <li>
                    <a href="#cemuhttpsgithubcomleomaurodesenvcemu-linux" aria-label="Cemu"><a href="https://github.com/leomaurodesenv/cemu-linux">Cemu</a></a></li>
                <li>
                    <a href="#office-2013-prohttpsaskubuntucomquestions879304wine-2-0-says-it-supports-office-2013-how-do-i-actually-install-it" aria-label="Office 2013 Pro"><a href="https://askubuntu.com/questions/879304/wine-2-0-says-it-supports-office-2013-how-do-i-actually-install-it">Office 2013 Pro</a></a></li>
                <li>
                    <a href="#wechathttpswwwtechgrowcnpostsa1930361html" aria-label="WeChat"><a href="https://www.techgrow.cn/posts/a1930361.html">WeChat</a></a></li>
                <li>
                    <a href="#genshin-impact" aria-label="Genshin Impact">Genshin Impact</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#fstabhttpswwwcnblogscomfenggeblogp10178824html" aria-label="fstab"><a href="https://www.cnblogs.com/FengGeBlog/p/10178824.html">fstab</a></a><ul>
                        
                <li>
                    <a href="#uuid-of-storage-deviceshttpslinuxhintcomuuid_storage_devices_linux" aria-label="UUID of Storage Devices"><a href="https://linuxhint.com/uuid_storage_devices_linux/">UUID of Storage Devices</a></a></li></ul>
                </li>
                <li>
                    <a href="#package-management" aria-label="Package Management">Package Management</a><ul>
                        
                <li>
                    <a href="#dpkg" aria-label="dpkg">dpkg</a><ul>
                        
                <li>
                    <a href="#%e7%ae%a1%e7%90%86%e8%bd%af%e4%bb%b6%e5%8c%85httpslinuxcnarticle-7953-1html" aria-label="管理软件包"><a href="https://linux.cn/article-7953-1.html">管理软件包</a></a><ul>
                        
                <li>
                    <a href="#%e5%b8%b8%e8%a7%81%e5%91%bd%e4%bb%a4%e5%8f%8a%e6%96%87%e4%bb%b6%e4%bd%8d%e7%bd%ae" aria-label="常见命令及文件位置">常见命令及文件位置</a></li>
                <li>
                    <a href="#%e5%ae%89%e8%a3%85%e5%8d%87%e7%ba%a7%e8%bd%af%e4%bb%b6" aria-label="安装/升级软件">安装/升级软件</a></li>
                <li>
                    <a href="#%e4%bb%8e%e6%96%87%e4%bb%b6%e5%a4%b9%e9%87%8c%e5%ae%89%e8%a3%85%e8%bd%af%e4%bb%b6" aria-label="从文件夹里安装软件">从文件夹里安装软件</a></li>
                <li>
                    <a href="#%e6%98%be%e7%a4%ba%e5%b7%b2%e5%ae%89%e8%a3%85%e8%bd%af%e4%bb%b6%e5%88%97%e8%a1%a8" aria-label="显示已安装软件列表">显示已安装软件列表</a></li>
                <li>
                    <a href="#%e6%9f%a5%e7%9c%8b%e6%8c%87%e5%ae%9a%e7%9a%84%e5%b7%b2%e5%ae%89%e8%a3%85%e8%bd%af%e4%bb%b6" aria-label="查看指定的已安装软件">查看指定的已安装软件</a></li>
                <li>
                    <a href="#%e6%9f%a5%e7%9c%8b%e8%bd%af%e4%bb%b6%e5%ae%89%e8%a3%85%e7%9b%ae%e5%bd%95" aria-label="查看软件安装目录">查看软件安装目录</a></li>
                <li>
                    <a href="#%e6%9f%a5%e7%9c%8b-deb-%e5%8c%85%e5%86%85%e5%ae%b9" aria-label="查看 deb 包内容">查看 deb 包内容</a></li>
                <li>
                    <a href="#%e6%98%be%e7%a4%ba%e8%bd%af%e4%bb%b6%e7%9a%84%e8%af%a6%e7%bb%86%e4%bf%a1%e6%81%af" aria-label="显示软件的详细信息">显示软件的详细信息</a></li>
                <li>
                    <a href="#%e6%9f%a5%e7%9c%8b%e6%96%87%e4%bb%b6%e5%b1%9e%e4%ba%8e%e5%93%aa%e4%b8%aa%e8%bd%af%e4%bb%b6" aria-label="查看文件属于哪个软件">查看文件属于哪个软件</a></li>
                <li>
                    <a href="#%e7%a7%bb%e9%99%a4%e5%88%a0%e9%99%a4%e8%bd%af%e4%bb%b6" aria-label="移除/删除软件">移除/删除软件</a></li>
                <li>
                    <a href="#%e6%b8%85%e9%99%a4%e8%bd%af%e4%bb%b6" aria-label="清除软件">清除软件</a></li></ul>
                </li>
                <li>
                    <a href="#debian-%e6%89%93%e5%8c%85%e5%85%a5%e9%97%a8httpslinuxcnarticle-9878-1html" aria-label="Debian 打包入门"><a href="https://linux.cn/article-9878-1.html">Debian 打包入门</a></a><ul>
                        
                <li>
                    <a href="#build-essentialhttpslinuxcnarticle-13953-1html" aria-label="build-essential"><a href="https://linux.cn/article-13953-1.html">build-essential</a></a></li></ul>
                </li>
                <li>
                    <a href="#package-converter" aria-label="Package converter">Package converter</a></li></ul>
                </li>
                <li>
                    <a href="#apt" aria-label="APT">APT</a><ul>
                        
                <li>
                    <a href="#%e5%88%97%e5%87%ba%e6%89%80%e6%9c%89%e6%89%8b%e5%8a%a8%e5%ae%89%e8%a3%85%e8%bd%af%e4%bb%b6" aria-label="列出所有手动安装软件">列出所有手动安装软件</a></li>
                <li>
                    <a href="#%e6%9f%a5%e7%9c%8b%e8%bd%af%e4%bb%b6%e5%8c%85%e4%be%9d%e8%b5%96" aria-label="查看软件包依赖">查看软件包依赖</a></li>
                <li>
                    <a href="#repository-mirror" aria-label="Repository Mirror">Repository Mirror</a></li>
                <li>
                    <a href="#apt-fasthttpsvituxcomhow-to-speed-up-package-downloads-and-updates-with-apt-fast-on-ubuntu" aria-label="apt-fast"><a href="https://vitux.com/how-to-speed-up-package-downloads-and-updates-with-apt-fast-on-ubuntu/">apt-fast</a></a></li>
                <li>
                    <a href="#apt-aria2httplinuxundertheskyblogspotcom201109accelerate-download-of-apt-get-viahtml" aria-label="apt-aria2"><a href="http://linuxunderthesky.blogspot.com/2011/09/accelerate-download-of-apt-get-via.html">apt-aria2</a></a></li></ul>
                </li>
                <li>
                    <a href="#ppahttpslinuxcnarticle-10456-1html" aria-label="PPA"><a href="https://linux.cn/article-10456-1.html">PPA</a></a></li>
                <li>
                    <a href="#snap--flatpak" aria-label="Snap &amp;amp; Flatpak">Snap &amp; Flatpak</a><ul>
                        
                <li>
                    <a href="#%e8%ae%a8%e8%ae%ba" aria-label="讨论">讨论</a></li>
                <li>
                    <a href="#%e5%9c%a8-ubuntu-%e4%b8%8a%e4%bd%bf%e7%94%a8-flatpakhttpsflatpakorgsetupubuntu" aria-label="在 Ubuntu 上使用 Flatpak"><a href="https://flatpak.org/setup/Ubuntu/">在 Ubuntu 上使用 Flatpak</a></a></li>
                <li>
                    <a href="#questions-1" aria-label="Questions">Questions</a></li></ul>
                </li>
                <li>
                    <a href="#tasksel-install-group-softwarehttpswwwcybercitibizfaqtasksel-install-group-software-in-command-line" aria-label="tasksel: Install Group Software"><a href="https://www.cyberciti.biz/faq/tasksel-install-group-software-in-command-line/">tasksel: Install Group Software</a></a></li>
                <li>
                    <a href="#pacstallhttpsgithubcompacstallpacstall" aria-label="pacstall"><a href="https://github.com/pacstall/pacstall">pacstall</a></a></li>
                <li>
                    <a href="#appimagehttpsappimageorg" aria-label="AppImage"><a href="https://appimage.org/">AppImage</a></a></li>
                <li>
                    <a href="#%e5%8c%85%e7%ae%a1%e7%90%86%e5%99%a8%e7%9a%84%e8%bf%9b%e5%8c%96httpslinuxcnarticle-9931-1html" aria-label="包管理器的进化"><a href="https://linux.cn/article-9931-1.html">包管理器的进化</a></a><ul>
                        
                <li>
                    <a href="#%e6%89%8b%e5%8a%a8%e5%ae%89%e8%a3%85%e8%bd%af%e4%bb%b6" aria-label="手动安装软件">手动安装软件</a></li>
                <li>
                    <a href="#%e8%bd%af%e4%bb%b6%e5%8c%85" aria-label="软件包">软件包</a></li>
                <li>
                    <a href="#%e8%bd%af%e4%bb%b6%e4%bb%93%e5%ba%93" aria-label="软件仓库">软件仓库</a></li>
                <li>
                    <a href="#%e5%8c%85%e7%ae%a1%e7%90%86%e5%99%a8" aria-label="包管理器">包管理器</a><ul>
                        
                <li>
                    <a href="#%e5%9f%ba%e4%ba%8e-prm-%e5%8c%85%e6%a0%bc%e5%bc%8f%e7%9a%84%e5%8c%85%e7%ae%a1%e7%90%86%e5%99%a8" aria-label="基于 PRM 包格式的包管理器">基于 PRM 包格式的包管理器</a></li>
                <li>
                    <a href="#%e5%9f%ba%e4%ba%8e-debian-%e7%9a%84%e5%8c%85%e7%ae%a1%e7%90%86%e5%99%a8" aria-label="基于 Debian 的包管理器">基于 Debian 的包管理器</a></li>
                <li>
                    <a href="#%e5%9f%ba%e4%ba%8e-arch-%e7%9a%84%e5%8c%85%e7%ae%a1%e7%90%86%e5%99%a8" aria-label="基于 Arch 的包管理器">基于 Arch 的包管理器</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#condahttpswwwjianshucompedaa744ea47d" aria-label="conda"><a href="https://www.jianshu.com/p/edaa744ea47d">conda</a></a><ul>
                        
                <li>
                    <a href="#%e7%ae%80%e4%bb%8b-5" aria-label="简介">简介</a></li>
                <li>
                    <a href="#%e5%ae%89%e8%a3%85-4" aria-label="安装">安装</a></li>
                <li>
                    <a href="#%e6%b7%bb%e5%8a%a0%e9%a2%91%e9%81%93" aria-label="添加频道">添加频道</a></li>
                <li>
                    <a href="#%e8%bd%af%e4%bb%b6%e5%8c%85%e7%ae%a1%e7%90%86" aria-label="软件包管理">软件包管理</a><ul>
                        
                <li>
                    <a href="#%e6%90%9c%e7%b4%a2%e5%ae%89%e8%a3%85%e5%8c%85" aria-label="搜索安装包">搜索安装包</a></li>
                <li>
                    <a href="#%e5%ae%89%e8%a3%85%e7%89%b9%e5%ae%9a%e7%89%88%e6%9c%ac" aria-label="安装特定版本">安装特定版本</a></li>
                <li>
                    <a href="#%e6%9f%a5%e7%9c%8b%e5%b7%b2%e5%ae%89%e8%a3%85%e8%bd%af%e4%bb%b6" aria-label="查看已安装软件">查看已安装软件</a></li>
                <li>
                    <a href="#%e6%9b%b4%e6%96%b0%e6%8c%87%e5%ae%9a%e8%bd%af%e4%bb%b6" aria-label="更新指定软件">更新指定软件</a></li>
                <li>
                    <a href="#%e5%8d%b8%e8%bd%bd%e6%8c%87%e5%ae%9a%e8%bd%af%e4%bb%b6" aria-label="卸载指定软件">卸载指定软件</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%8e%af%e5%a2%83%e7%ae%a1%e7%90%86" aria-label="环境管理">环境管理</a><ul>
                        
                <li>
                    <a href="#%e9%80%80%e5%87%baconda%e7%8e%af%e5%a2%83" aria-label="退出conda环境">退出conda环境</a></li>
                <li>
                    <a href="#%e5%88%9b%e5%bb%baconda%e7%8e%af%e5%a2%83" aria-label="创建conda环境">创建conda环境</a></li>
                <li>
                    <a href="#%e5%88%a0%e9%99%a4%e7%8e%af%e5%a2%83" aria-label="删除环境">删除环境</a></li>
                <li>
                    <a href="#%e9%87%8d%e5%91%bd%e5%90%8d%e7%8e%af%e5%a2%83" aria-label="重命名环境">重命名环境</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e8%87%aa%e5%8a%a8%e6%9b%b4%e6%96%b0httpswwwcnblogscomsparkdevp11376560html" aria-label="自动更新"><a href="https://www.cnblogs.com/sparkdev/p/11376560.html">自动更新</a></a><ul>
                        
                <li>
                    <a href="#%e6%9b%b4%e6%96%b0%e6%9c%ba%e5%88%b6" aria-label="更新机制">更新机制</a></li>
                <li>
                    <a href="#aptsystemddaily" aria-label="apt.systemd.daily">apt.systemd.daily</a></li>
                <li>
                    <a href="#unattended-upgrades" aria-label="unattended-upgrades">unattended-upgrades</a></li>
                <li>
                    <a href="#%e5%85%b3%e9%97%ad%e8%87%aa%e5%8a%a8%e6%9b%b4%e6%96%b0" aria-label="关闭自动更新">关闭自动更新</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#lvmhttpswwwcnblogscomsparkdevp10130934html" aria-label="LVM"><a href="https://www.cnblogs.com/sparkdev/p/10130934.html">LVM</a></a><ul>
                        
                <li>
                    <a href="#lvm-%e6%98%af%e4%bb%80%e4%b9%88" aria-label="LVM 是什么">LVM 是什么</a></li>
                <li>
                    <a href="#lvm-%e4%b8%ad%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5" aria-label="LVM 中的基本概念">LVM 中的基本概念</a></li>
                <li>
                    <a href="#lvm-%e5%b7%a5%e5%85%b7" aria-label="LVM 工具">LVM 工具</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8-gdisk-%e5%af%b9%e7%89%a9%e7%90%86%e7%a3%81%e7%9b%98%e8%bf%9b%e8%a1%8c%e5%88%86%e5%8c%ba" aria-label="使用 gdisk 对物理磁盘进行分区">使用 gdisk 对物理磁盘进行分区</a></li>
                <li>
                    <a href="#%e5%88%9b%e5%bb%ba%e7%89%a9%e7%90%86%e5%8d%b7-pv" aria-label="创建物理卷 PV">创建物理卷 PV</a></li>
                <li>
                    <a href="#%e5%88%9b%e5%bb%ba%e5%8d%b7%e7%bb%84-vg" aria-label="创建卷组 VG">创建卷组 VG</a></li>
                <li>
                    <a href="#%e5%88%9b%e5%bb%ba%e9%80%bb%e8%be%91%e5%8d%b7-lv" aria-label="创建逻辑卷 LV">创建逻辑卷 LV</a></li>
                <li>
                    <a href="#%e6%a0%bc%e5%bc%8f%e5%8c%96%e9%80%bb%e8%be%91%e5%8d%b7%e5%88%9b%e5%bb%ba%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f" aria-label="格式化逻辑卷(创建文件系统)">格式化逻辑卷(创建文件系统)</a></li>
                <li>
                    <a href="#%e5%bc%80%e6%9c%ba%e8%87%aa%e5%8a%a8%e6%8c%82%e8%bd%bd" aria-label="开机自动挂载">开机自动挂载</a></li>
                <li>
                    <a href="#%e8%b0%83%e6%95%b4%e9%80%bb%e8%be%91%e5%8d%b7httpswikiarchlinuxorgtitlelvm_e7ae80e4bd93e4b8ade69687e980bbe8be91e58db7" aria-label="调整逻辑卷"><a href="https://wiki.archlinux.org/title/LVM_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E9%80%BB%E8%BE%91%E5%8D%B7">调整逻辑卷</a></a></li>
                <li>
                    <a href="#%e9%87%8d%e5%91%bd%e5%90%8d%e5%8d%b7" aria-label="重命名卷">重命名卷</a></li>
                <li>
                    <a href="#%e7%a7%bb%e9%99%a4%e9%80%bb%e8%be%91%e5%8d%b7" aria-label="移除逻辑卷">移除逻辑卷</a></li>
                <li>
                    <a href="#lvm-%e5%bf%ab%e7%85%a7httpswwwcnblogscomsparkdevp10232567html" aria-label="LVM 快照"><a href="https://www.cnblogs.com/sparkdev/p/10232567.html">LVM 快照</a></a></li></ul>
                </li>
                <li>
                    <a href="#zfshttpslinuxcnarticle-10034-1html" aria-label="ZFS"><a href="https://linux.cn/article-10034-1.html">ZFS</a></a><ul>
                        
                <li>
                    <a href="#%e5%8e%86%e5%8f%b2" aria-label="历史">历史</a></li>
                <li>
                    <a href="#%e7%89%b9%e6%80%a7httpslinuxcnarticle-7422-1html" aria-label="特性"><a href="https://linux.cn/article-7422-1.html">特性</a></a><ul>
                        
                <li>
                    <a href="#%e5%ad%98%e5%82%a8%e6%b1%a0-1" aria-label="存储池">存储池</a></li>
                <li>
                    <a href="#%e5%86%99%e6%97%b6%e6%8b%b7%e8%b4%9d" aria-label="写时拷贝">写时拷贝</a></li>
                <li>
                    <a href="#%e5%bf%ab%e7%85%a7" aria-label="快照">快照</a></li>
                <li>
                    <a href="#%e6%95%b0%e6%8d%ae%e5%ae%8c%e6%95%b4%e6%80%a7%e9%aa%8c%e8%af%81%e5%92%8c%e8%87%aa%e5%8a%a8%e4%bf%ae%e5%a4%8d" aria-label="数据完整性验证和自动修复">数据完整性验证和自动修复</a></li>
                <li>
                    <a href="#raid-z" aria-label="RAID-Z">RAID-Z</a></li>
                <li>
                    <a href="#%e5%b7%a8%e5%a4%a7%e7%9a%84%e5%ad%98%e5%82%a8%e6%bd%9c%e5%8a%9b" aria-label="巨大的存储潜力">巨大的存储潜力</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e5%ae%89%e8%a3%85-zfs" aria-label="如何安装 ZFS？">如何安装 ZFS？</a></li>
                <li>
                    <a href="#%e5%9c%a8-ubuntu-%e4%b8%8a%e4%bd%bf%e7%94%a8-zfshttpslinuxcnarticle-9346-1html" aria-label="在 Ubuntu 上使用 ZFS"><a href="https://linux.cn/article-9346-1.html">在 Ubuntu 上使用 ZFS</a></a><ul>
                        
                <li>
                    <a href="#%e5%88%9b%e5%bb%ba%e6%b1%a0" aria-label="创建池">创建池</a><ul>
                        
                <li>
                    <a href="#raid0" aria-label="RAID0">RAID0</a></li>
                <li>
                    <a href="#raid1%e9%95%9c%e5%83%8f" aria-label="RAID1（镜像）">RAID1（镜像）</a></li>
                <li>
                    <a href="#raid5raidz1" aria-label="RAID5/RAIDZ1">RAID5/RAIDZ1</a></li>
                <li>
                    <a href="#raid6raidz2" aria-label="RAID6/RAIDZ2">RAID6/RAIDZ2</a></li>
                <li>
                    <a href="#raid10%e6%9d%a1%e5%b8%a6%e5%8c%96%e9%95%9c%e5%83%8f" aria-label="RAID10（条带化镜像）">RAID10（条带化镜像）</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%b1%a0%e7%9a%84%e6%93%8d%e4%bd%9c" aria-label="池的操作">池的操作</a><ul>
                        
                <li>
                    <a href="#%e6%9b%b4%e6%96%b0" aria-label="更新">更新</a></li>
                <li>
                    <a href="#%e6%b7%bb%e5%8a%a0%e9%a9%b1%e5%8a%a8%e5%99%a8" aria-label="添加驱动器">添加驱动器</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%ae%9e%e4%be%8b-1" aria-label="实例">实例</a></li></ul>
                </li>
                <li>
                    <a href="#systemd" aria-label="Systemd">Systemd</a><ul>
                        
                <li>
                    <a href="#linux-pid-1-%e5%92%8c-systemdhttpscoolshellcnarticles17998htmlsysv_init" aria-label="LINUX PID 1 和 SYSTEMD"><a href="https://coolshell.cn/articles/17998.html#SysV_Init">LINUX PID 1 和 SYSTEMD</a></a><ul>
                        
                <li>
                    <a href="#sysv-init" aria-label="SysV Init">SysV Init</a></li>
                <li>
                    <a href="#upstart" aria-label="UpStart">UpStart</a></li>
                <li>
                    <a href="#systemd-1" aria-label="Systemd">Systemd</a></li>
                <li>
                    <a href="#systemd-%e4%ba%89%e8%ae%ba%e5%92%8c%e5%85%ab%e5%8d%a6" aria-label="Systemd 争论和八卦">Systemd 争论和八卦</a></li>
                <li>
                    <a href="#%e5%85%b6%e5%ae%83" aria-label="其它">其它</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%91%bd%e4%bb%a4httpswwwruanyifengcomblog201603systemd-tutorial-commandshtml" aria-label="命令"><a href="https://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html">命令</a></a><ul>
                        
                <li>
                    <a href="#%e7%b3%bb%e7%bb%9f%e7%ae%a1%e7%90%86" aria-label="系统管理">系统管理</a></li>
                <li>
                    <a href="#unit" aria-label="Unit">Unit</a></li>
                <li>
                    <a href="#unit-%e7%9a%84%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6" aria-label="Unit 的配置文件">Unit 的配置文件</a></li>
                <li>
                    <a href="#target" aria-label="Target">Target</a></li>
                <li>
                    <a href="#%e6%97%a5%e5%bf%97%e7%ae%a1%e7%90%86" aria-label="日志管理">日志管理</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%ae%9a%e6%97%b6%e5%99%a8%e7%a4%ba%e4%be%8bhttpwwwruanyifengcomblog201803systemd-timerhtml" aria-label="定时器示例"><a href="http://www.ruanyifeng.com/blog/2018/03/systemd-timer.html">定时器示例</a></a><ul>
                        
                <li>
                    <a href="#%e9%82%ae%e4%bb%b6%e8%84%9a%e6%9c%ac" aria-label="邮件脚本">邮件脚本</a></li>
                <li>
                    <a href="#service-%e5%8d%95%e5%85%83" aria-label="Service 单元">Service 单元</a></li>
                <li>
                    <a href="#timer-%e5%8d%95%e5%85%83" aria-label="Timer 单元">Timer 单元</a></li></ul>
                </li>
                <li>
                    <a href="#system-timehttpswikiarchlinuxorgtitlesystem_time_e7ae80e4bd93e4b8ade69687" aria-label="System time"><a href="https://wiki.archlinux.org/title/System_time_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">System time</a></a><ul>
                        
                <li>
                    <a href="#%e7%a1%ac%e4%bb%b6%e6%97%b6%e9%92%9f%e5%92%8c%e7%b3%bb%e7%bb%9f%e6%97%b6%e9%92%9f" aria-label="硬件时钟和系统时钟">硬件时钟和系统时钟</a></li>
                <li>
                    <a href="#%e8%af%bb%e5%8f%96%e6%97%b6%e9%97%b4" aria-label="读取时间">读取时间</a></li>
                <li>
                    <a href="#%e8%ae%be%e7%bd%ae%e6%97%b6%e9%97%b4" aria-label="设置时间">设置时间</a></li>
                <li>
                    <a href="#%e6%97%b6%e9%97%b4%e6%a0%87%e5%87%86" aria-label="时间标准">时间标准</a></li>
                <li>
                    <a href="#windows-%e7%b3%bb%e7%bb%9f%e4%bd%bf%e7%94%a8-utc" aria-label="Windows 系统使用 UTC">Windows 系统使用 UTC</a></li>
                <li>
                    <a href="#utc-%e5%9c%a8ubuntu%e7%9a%84%e8%ae%be%e7%bd%ae" aria-label="UTC 在Ubuntu的设置">UTC 在Ubuntu的设置</a></li>
                <li>
                    <a href="#%e6%97%b6%e5%8c%ba" aria-label="时区">时区</a></li>
                <li>
                    <a href="#%e6%97%b6%e9%92%9f%e5%81%8f%e7%a7%bb" aria-label="时钟偏移">时钟偏移</a></li>
                <li>
                    <a href="#%e6%97%b6%e9%92%9f%e5%90%8c%e6%ad%a5" aria-label="时钟同步">时钟同步</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e9%98%b2%e7%81%ab%e5%a2%99httpswwwlinuxprobecombasic-learning-08html" aria-label="防火墙"><a href="https://www.linuxprobe.com/basic-learning-08.html">防火墙</a></a><ul>
                        
                <li>
                    <a href="#%e9%98%b2%e7%81%ab%e5%a2%99%e7%ae%a1%e7%90%86%e5%b7%a5%e5%85%b7" aria-label="防火墙管理工具">防火墙管理工具</a></li>
                <li>
                    <a href="#iptables" aria-label="Iptables">Iptables</a><ul>
                        
                <li>
                    <a href="#%e7%ad%96%e7%95%a5%e4%b8%8e%e8%a7%84%e5%88%99%e9%93%be" aria-label="策略与规则链">策略与规则链</a></li>
                <li>
                    <a href="#%e5%9f%ba%e6%9c%ac%e7%9a%84%e5%91%bd%e4%bb%a4%e5%8f%82%e6%95%b0httpswwwjianshucomp5a604b4ef342" aria-label="基本的命令参数"><a href="https://www.jianshu.com/p/5a604b4ef342">基本的命令参数</a></a><ul>
                        
                <li>
                    <a href="#%e5%91%bd%e4%bb%a4%e6%a0%bc%e5%bc%8f" aria-label="命令格式">命令格式</a></li>
                <li>
                    <a href="#%e5%8f%82%e6%95%b0%e8%af%b4%e6%98%8e" aria-label="参数说明">参数说明</a></li>
                <li>
                    <a href="#%e5%8a%a8%e4%bd%9c%e8%af%b4%e6%98%8e" aria-label="动作说明">动作说明</a></li>
                <li>
                    <a href="#%e4%be%8b%e5%ad%90" aria-label="例子">例子</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5httpswikiarchlinuxorgtitleiptables_e7ae80e4bd93e4b8ade69687e59fbae69cace6a682e5bfb5" aria-label="基本概念"><a href="https://wiki.archlinux.org/title/iptables_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">基本概念</a></a><ul>
                        
                <li>
                    <a href="#%e8%a1%a8tables" aria-label="表(Tables)">表(Tables)</a></li>
                <li>
                    <a href="#%e9%93%bechains" aria-label="链(Chains)">链(Chains)</a></li>
                <li>
                    <a href="#%e8%a7%84%e5%88%99-rules" aria-label="规则 (Rules)">规则 (Rules)</a></li>
                <li>
                    <a href="#%e9%81%8d%e5%8e%86%e9%93%betraversing-chains" aria-label="遍历链(Traversing Chains)">遍历链(Traversing Chains)</a></li>
                <li>
                    <a href="#%e6%a8%a1%e5%9d%97modules" aria-label="模块(Modules)">模块(Modules)</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#firewalld" aria-label="Firewalld">Firewalld</a><ul>
                        
                <li>
                    <a href="#%e7%bb%88%e7%ab%af%e7%ae%a1%e7%90%86%e5%b7%a5%e5%85%b7" aria-label="终端管理工具">终端管理工具</a></li>
                <li>
                    <a href="#%e5%9b%be%e5%bd%a2%e7%ae%a1%e7%90%86%e5%b7%a5%e5%85%b7" aria-label="图形管理工具">图形管理工具</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%9c%8d%e5%8a%a1%e7%9a%84%e8%ae%bf%e9%97%ae%e6%8e%a7%e5%88%b6%e5%88%97%e8%a1%a8" aria-label="服务的访问控制列表">服务的访问控制列表</a></li>
                <li>
                    <a href="#cockpit-%e9%a9%be%e9%a9%b6%e8%88%b1%e7%ae%a1%e7%90%86%e5%b7%a5%e5%85%b7" aria-label="Cockpit 驾驶舱管理工具">Cockpit 驾驶舱管理工具</a></li>
                <li>
                    <a href="#%e5%9c%a8-ubuntu-%e4%b8%8a%e4%bd%bf%e7%94%a8-ufwgufwhttpswwwmyfreaxcomhow-to-setup-a-firewall-with-ufw-on-ubuntu-20-04" aria-label="在 Ubuntu 上使用 UFW&amp;amp;GUFW"><a href="https://www.myfreax.com/how-to-setup-a-firewall-with-ufw-on-ubuntu-20-04/">在 Ubuntu 上使用 UFW&amp;GUFW</a></a><ul>
                        
                <li>
                    <a href="#%e6%a3%80%e6%9f%a5ufw%e7%8a%b6%e6%80%81" aria-label="检查UFW状态">检查UFW状态</a></li>
                <li>
                    <a href="#ufw%e9%bb%98%e8%ae%a4%e7%ad%96%e7%95%a5" aria-label="UFW默认策略">UFW默认策略</a></li>
                <li>
                    <a href="#%e5%ba%94%e7%94%a8%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6" aria-label="应用配置文件">应用配置文件</a></li>
                <li>
                    <a href="#%e5%90%af%e7%94%a8ufw" aria-label="启用UFW">启用UFW</a></li>
                <li>
                    <a href="#%e6%89%93%e5%bc%80%e7%ab%af%e5%8f%a3" aria-label="打开端口">打开端口</a></li>
                <li>
                    <a href="#%e6%8b%92%e7%bb%9d%e8%bf%9e%e6%8e%a5" aria-label="拒绝连接">拒绝连接</a></li>
                <li>
                    <a href="#%e5%88%a0%e9%99%a4ufw%e8%a7%84%e5%88%99" aria-label="删除UFW规则">删除UFW规则</a></li>
                <li>
                    <a href="#%e7%a6%81%e7%94%a8ufw" aria-label="禁用UFW">禁用UFW</a></li>
                <li>
                    <a href="#%e9%87%8d%e8%ae%beufw" aria-label="重设UFW">重设UFW</a></li>
                <li>
                    <a href="#ip%e4%bc%aa%e8%a3%85" aria-label="IP伪装">IP伪装</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#udevhttpswwwjianshucompf9385d5703a7" aria-label="udev"><a href="https://www.jianshu.com/p/f9385d5703a7">udev</a></a><ul>
                        
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%bf%e7%94%a8udev" aria-label="为什么使用udev">为什么使用udev</a></li>
                <li>
                    <a href="#udev%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6" aria-label="udev配置文件">udev配置文件</a></li>
                <li>
                    <a href="#%e4%bf%ae%e6%94%b9%e4%bd%a0%e7%9a%84udev%e9%85%8d%e7%bd%ae" aria-label="修改你的udev配置">修改你的udev配置</a></li>
                <li>
                    <a href="#mounting-usb-automatically--having-usbs-label-as-mountpointhttpsunixstackexchangecomquestions119973mounting-usb-automatically-having-usbs-label-as-mountpoint" aria-label="Mounting usb automatically &amp;amp; having usb&amp;rsquo;s label as mountpoint"><a href="https://unix.stackexchange.com/questions/119973/mounting-usb-automatically-having-usbs-label-as-mountpoint">Mounting usb automatically &amp; having usb&rsquo;s label as mountpoint</a></a><ul>
                        
                <li>
                    <a href="#udev-references" aria-label="UDEV references">UDEV references</a></li>
                <li>
                    <a href="#background-udev-whuzzat" aria-label="Background (UDEV? Whuzzat?)">Background (UDEV? Whuzzat?)</a></li>
                <li>
                    <a href="#udev-rules" aria-label="Udev Rules">Udev Rules</a></li>
                <li>
                    <a href="#script-actually-2-scripts" aria-label="Script! Actually, 2 Scripts&amp;hellip;">Script! Actually, 2 Scripts&hellip;</a></li>
                <li>
                    <a href="#super-bonus-cleanup-script" aria-label="Super Bonus Cleanup Script!">Super Bonus Cleanup Script!</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#gpghttpsruanyifengcomblog201307gpghtml" aria-label="GPG"><a href="https://ruanyifeng.com/blog/2013/07/gpg.html">GPG</a></a><ul>
                        
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%afgpg" aria-label="什么是GPG">什么是GPG</a></li>
                <li>
                    <a href="#%e5%ae%89%e8%a3%85-5" aria-label="安装">安装</a></li>
                <li>
                    <a href="#%e9%85%8d%e7%bd%ae-4" aria-label="配置">配置</a><ul>
                        
                <li>
                    <a href="#%e7%9b%ae%e5%bd%95%e4%bd%8d%e7%bd%ae" aria-label="目录位置">目录位置</a></li>
                <li>
                    <a href="#%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6" aria-label="配置文件">配置文件</a></li>
                <li>
                    <a href="#%e6%96%b0%e7%94%a8%e6%88%b7%e7%9a%84%e9%bb%98%e8%ae%a4%e9%80%89%e9%a1%b9" aria-label="新用户的默认选项">新用户的默认选项</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%94%9f%e6%88%90%e5%af%86%e9%92%a5" aria-label="生成密钥">生成密钥</a></li>
                <li>
                    <a href="#%e5%af%86%e9%92%a5%e7%ae%a1%e7%90%86" aria-label="密钥管理">密钥管理</a></li>
                <li>
                    <a href="#%e5%8a%a0%e5%af%86%e5%92%8c%e8%a7%a3%e5%af%86" aria-label="加密和解密">加密和解密</a></li>
                <li>
                    <a href="#%e7%ad%be%e5%90%8d" aria-label="签名">签名</a></li></ul>
                </li>
                <li>
                    <a href="#linux-kernel" aria-label="Linux Kernel">Linux Kernel</a><ul>
                        
                <li>
                    <a href="#kernel-modulehttpswikiarchlinuxorgtitlekernel_module_e7ae80e4bd93e4b8ade69687" aria-label="Kernel module"><a href="https://wiki.archlinux.org/title/Kernel_module_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Kernel module</a></a><ul>
                        
                <li>
                    <a href="#%e8%8e%b7%e5%8f%96%e4%bf%a1%e6%81%af" aria-label="获取信息">获取信息</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8systemd%e8%87%aa%e5%8a%a8%e5%8a%a0%e8%bd%bd%e6%a8%a1%e5%9d%97" aria-label="使用systemd自动加载模块">使用systemd自动加载模块</a></li>
                <li>
                    <a href="#%e6%89%8b%e5%8a%a8%e5%8a%a0%e8%bd%bd%e5%8d%b8%e8%bd%bd" aria-label="手动加载卸载">手动加载卸载</a></li>
                <li>
                    <a href="#%e9%85%8d%e7%bd%ae%e6%a8%a1%e5%9d%97%e5%8f%82%e6%95%b0" aria-label="配置模块参数">配置模块参数</a><ul>
                        
                <li>
                    <a href="#%e6%89%8b%e5%8a%a8%e5%8a%a0%e8%bd%bd%e6%97%b6%e8%ae%be%e7%bd%ae" aria-label="手动加载时设置">手动加载时设置</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8-etcmodprobed%e4%b8%ad%e7%9a%84%e6%96%87%e4%bb%b6" aria-label="使用 /etc/modprobe.d/中的文件">使用 /etc/modprobe.d/中的文件</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8%e5%86%85%e6%a0%b8%e5%91%bd%e4%bb%a4%e8%a1%8c" aria-label="使用内核命令行">使用内核命令行</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%88%ab%e5%90%8d" aria-label="别名">别名</a></li>
                <li>
                    <a href="#%e9%bb%91%e5%90%8d%e5%8d%95" aria-label="黑名单">黑名单</a><ul>
                        
                <li>
                    <a href="#%e7%a6%81%e7%94%a8%e5%86%85%e6%a0%b8%e6%a8%a1%e5%9d%97" aria-label="禁用内核模块">禁用内核模块</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8-etcmodprobed-%e4%b8%ad%e7%9a%84%e6%96%87%e4%bb%b6" aria-label="使用 /etc/modprobe.d/ 中的文件">使用 /etc/modprobe.d/ 中的文件</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8%e5%86%85%e6%a0%b8%e5%91%bd%e4%bb%a4%e8%a1%8c-1" aria-label="使用内核命令行">使用内核命令行</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#kernel-parameters" aria-label="Kernel parameters">Kernel parameters</a><ul>
                        
                <li>
                    <a href="#%e9%85%8d%e7%bd%ae-5" aria-label="配置">配置</a><ul>
                        
                <li>
                    <a href="#systemd-boot" aria-label="systemd-boot">systemd-boot</a></li>
                <li>
                    <a href="#grub" aria-label="GRUB">GRUB</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%8f%91%e5%b8%83%e6%97%b6%e9%97%b4%e8%a1%a8httpslinuxcnarticle-13963-1html" aria-label="发布时间表"><a href="https://linux.cn/article-13963-1.html">发布时间表</a></a><ul>
                        
                <li>
                    <a href="#%e5%86%85%e6%a0%b8%e5%8f%91%e5%b8%83%e6%97%b6%e9%97%b4%e8%a1%a8%e6%9c%89%e5%90%97" aria-label="内核发布时间表：有吗？">内核发布时间表：有吗？</a></li>
                <li>
                    <a href="#%e4%b8%80%e4%b8%aa%e5%86%85%e6%a0%b8%e7%89%88%e6%9c%ac%e6%94%af%e6%8c%81%e5%a4%9a%e9%95%bf%e6%97%b6%e9%97%b4" aria-label="一个内核版本支持多长时间？">一个内核版本支持多长时间？</a></li>
                <li>
                    <a href="#lts-%e5%86%85%e6%a0%b8%e5%ae%83%e6%94%af%e6%8c%81%e5%a4%9a%e9%95%bf%e6%97%b6%e9%97%b4" aria-label="LTS 内核：它支持多长时间？">LTS 内核：它支持多长时间？</a></li>
                <li>
                    <a href="#%e4%bd%a0%e7%9a%84%e5%8f%91%e8%a1%8c%e7%89%88%e5%8f%af%e8%83%bd%e6%b2%a1%e6%9c%89%e8%b7%9f%e9%9a%8f%e9%80%9a%e5%b8%b8%e7%9a%84-linux-%e5%86%85%e6%a0%b8%e7%89%88%e6%9c%ac" aria-label="你的发行版可能没有跟随通常的 Linux 内核版本">你的发行版可能没有跟随通常的 Linux 内核版本</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%ae%89%e8%a3%85%e5%86%85%e6%a0%b8httpslinuxcnarticle-12125-1html" aria-label="安装内核"><a href="https://linux.cn/article-12125-1.html">安装内核</a></a><ul>
                        
                <li>
                    <a href="#xanmod-kernelhttpsplumzmearchives12014" aria-label="XanMod Kernel"><a href="https://plumz.me/archives/12014/">XanMod Kernel</a></a></li>
                <li>
                    <a href="#zenhttpswikiubuntucomzenkernelliquorix-kernelhttpsliquorixnet" aria-label="Zen/Liquorix Kernel"><a href="https://wiki.ubuntu.com/ZenKernel">Zen</a>/<a href="https://liquorix.net/">Liquorix Kernel</a></a></li>
                <li>
                    <a href="#%e5%8f%af%e9%80%89%e5%86%85%e6%a0%b8httpswikiarchlinuxorgtitlekernel" aria-label="可选内核"><a href="https://wiki.archlinux.org/title/kernel">可选内核</a></a></li></ul>
                </li>
                <li>
                    <a href="#%e5%88%87%e6%8f%9b%e5%86%85%e6%a0%b8httpsmeetrixioblogawschanging-default-ubuntu-kernelhtml" aria-label="切換内核"><a href="https://meetrix.io/blog/aws/changing-default-ubuntu-kernel.html">切換内核</a></a></li>
                <li>
                    <a href="#%e5%88%a0%e9%99%a4%e6%97%a7%e5%86%85%e6%a0%b8httpslinuxcnarticle-6245-1html" aria-label="删除旧内核"><a href="https://linux.cn/article-6245-1.html">删除旧内核</a></a></li>
                <li>
                    <a href="#%e7%bc%96%e5%86%99%e7%ac%ac%e4%b8%80%e4%b8%aa%e5%86%85%e6%a0%b8%e6%a8%a1%e5%9d%97httpslinuxcnarticle-3251-1html" aria-label="编写第一个内核模块"><a href="https://linux.cn/article-3251-1.html">编写第一个内核模块</a></a></li></ul>
                </li>
                <li>
                    <a href="#%e5%ae%b9%e5%99%a8" aria-label="容器">容器</a><ul>
                        
                <li>
                    <a href="#namespacehttpswwwcnblogscomsparkdevp9365405html" aria-label="Namespace"><a href="https://www.cnblogs.com/sparkdev/p/9365405.html">Namespace</a></a><ul>
                        
                <li>
                    <a href="#%e6%a6%82%e5%bf%b5" aria-label="概念">概念</a></li>
                <li>
                    <a href="#%e7%94%a8%e9%80%94" aria-label="用途">用途</a></li>
                <li>
                    <a href="#%e5%8f%91%e5%b1%95%e5%8e%86%e5%8f%b2" aria-label="发展历史">发展历史</a></li>
                <li>
                    <a href="#clone-%e5%87%bd%e6%95%b0" aria-label="clone() 函数">clone() 函数</a></li>
                <li>
                    <a href="#setns-%e5%87%bd%e6%95%b0" aria-label="setns() 函数">setns() 函数</a></li>
                <li>
                    <a href="#unshare-%e5%87%bd%e6%95%b0" aria-label="unshare() 函数">unshare() 函数</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%8e%a7%e5%88%b6%e7%bb%84httpdockoneioarticle8433" aria-label="控制组"><a href="http://dockone.io/article/8433">控制组</a></a><ul>
                        
                <li>
                    <a href="#%e7%ae%80%e4%bb%8b-6" aria-label="简介">简介</a></li>
                <li>
                    <a href="#%e6%a6%82%e5%bf%b5httpswwwcnblogscomsparkdevp8296063html" aria-label="概念"><a href="https://www.cnblogs.com/sparkdev/p/8296063.html">概念</a></a></li>
                <li>
                    <a href="#%e6%8e%a5%e5%8f%a3" aria-label="接口">接口</a></li>
                <li>
                    <a href="#%e6%89%8b%e5%8a%a8%e6%96%b9%e6%b3%95" aria-label="手动方法">手动方法</a></li>
                <li>
                    <a href="#%e5%bd%93%e8%bf%9b%e7%a8%8b%e8%bf%b7%e8%b7%af%e6%97%b6" aria-label="当进程“迷路”时">当进程“迷路”时</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8libcgroup" aria-label="使用libcgroup">使用libcgroup</a></li>
                <li>
                    <a href="#%e6%8c%81%e4%b9%85%e7%bb%84" aria-label="持久组">持久组</a></li>
                <li>
                    <a href="#%e6%80%bb%e7%bb%93" aria-label="总结">总结</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8-systemdhttpswwwcnblogscomsparkdevp9523194html" aria-label="使用 Systemd"><a href="https://www.cnblogs.com/sparkdev/p/9523194.html">使用 Systemd</a></a></li></ul>
                </li>
                <li>
                    <a href="#lxchttpdockoneioarticle8631" aria-label="LXC"><a href="http://dockone.io/article/8631">LXC</a></a><ul>
                        
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8lxc%e7%9a%84%e5%b7%a5%e5%85%b7" aria-label="使用LXC的工具">使用LXC的工具</a></li>
                <li>
                    <a href="#%e9%ab%98%e7%ba%a7%e9%85%8d%e7%bd%ae" aria-label="高级配置">高级配置</a></li>
                <li>
                    <a href="#%e7%89%b9%e6%9d%83%e4%b8%8e%e9%9d%9e%e7%89%b9%e6%9d%83%e5%ae%b9%e5%99%a8" aria-label="特权与非特权容器">特权与非特权容器</a></li>
                <li>
                    <a href="#%e7%84%b6%e8%80%8cdocker%e5%8f%88%e6%98%af%e4%bb%80%e4%b9%88%e5%91%a2" aria-label="然而，Docker又是什么呢？">然而，Docker又是什么呢？</a><ul>
                        
                <li>
                    <a href="#%e8%bf%9b%e7%a8%8b%e7%ae%a1%e7%90%86" aria-label="进程管理">进程管理</a></li>
                <li>
                    <a href="#%e7%8a%b6%e6%80%81%e7%ae%a1%e7%90%86" aria-label="状态管理">状态管理</a></li>
                <li>
                    <a href="#%e5%8f%af%e7%a7%bb%e6%a4%8d%e6%80%a7" aria-label="可移植性">可移植性</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%80%bb%e7%bb%93-1" aria-label="总结">总结</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%b2%99%e7%ae%b1httpshyperjnet20162016-11-23-linux-sandbox" aria-label="沙箱"><a href="https://hyperj.net/2016/2016-11-23-linux-sandbox/">沙箱</a></a></li></ul>
                </li>
                <li>
                    <a href="#%e6%9d%83%e9%99%90" aria-label="权限">权限</a><ul>
                        
                <li>
                    <a href="#ugohttpswwwcnblogscomsparkdevp9573355html" aria-label="ugo"><a href="https://www.cnblogs.com/sparkdev/p/9573355.html">ugo</a></a><ul>
                        
                <li>
                    <a href="#%e6%89%80%e6%9c%89%e8%80%85%e5%92%8c%e7%bb%84" aria-label="所有者和组">所有者和组</a></li>
                <li>
                    <a href="#%e6%96%87%e4%bb%b6%e5%b1%9e%e6%80%a7" aria-label="文件属性">文件属性</a></li>
                <li>
                    <a href="#%e6%94%b9%e5%8f%98%e6%9d%83%e9%99%90" aria-label="改变权限">改变权限</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%89%b9%e6%ae%8a%e6%9d%83%e9%99%90suidsgidsbit" aria-label="特殊权限"><a href="SUID/SGID/SBIT">特殊权限</a></a><ul>
                        
                <li>
                    <a href="#suid" aria-label="SUID">SUID</a></li>
                <li>
                    <a href="#sgid" aria-label="SGID">SGID</a></li>
                <li>
                    <a href="#sbit" aria-label="SBIT">SBIT</a></li>
                <li>
                    <a href="#%e8%ae%be%e7%bd%ae%e6%9d%83%e9%99%90" aria-label="设置权限">设置权限</a></li></ul>
                </li>
                <li>
                    <a href="#umaskhttpswwwcnblogscomsparkdevp9651890html" aria-label="umask"><a href="https://www.cnblogs.com/sparkdev/p/9651890.html">umask</a></a><ul>
                        
                <li>
                    <a href="#%e9%bb%98%e8%ae%a4%e6%9d%83%e9%99%90" aria-label="默认权限">默认权限</a></li>
                <li>
                    <a href="#%e9%bb%98%e8%ae%a4%e7%ad%96%e7%95%a5" aria-label="默认策略">默认策略</a></li>
                <li>
                    <a href="#%e5%91%bd%e4%bb%a4" aria-label="命令">命令</a></li>
                <li>
                    <a href="#%e4%b8%8e-acl" aria-label="与 ACL">与 ACL</a></li></ul>
                </li>
                <li>
                    <a href="#aclhttpswwwcnblogscomsparkdevp5536868html" aria-label="ACL"><a href="https://www.cnblogs.com/sparkdev/p/5536868.html">ACL</a></a><ul>
                        
                <li>
                    <a href="#%e8%ae%be%e7%bd%ae%e6%9d%83%e9%99%90-1" aria-label="设置权限">设置权限</a></li>
                <li>
                    <a href="#%e7%bb%a7%e6%89%bf%e6%9d%83%e9%99%90" aria-label="继承权限">继承权限</a></li>
                <li>
                    <a href="#%e6%93%8d%e4%bd%9c%e6%9d%83%e9%99%90" aria-label="操作权限">操作权限</a><ul>
                        
                <li>
                    <a href="#%e6%9b%b4%e6%94%b9" aria-label="更改">更改</a></li>
                <li>
                    <a href="#%e5%88%a0%e9%99%a4" aria-label="删除">删除</a></li>
                <li>
                    <a href="#%e5%a4%87%e4%bb%bd%e5%92%8c%e6%81%a2%e5%a4%8d" aria-label="备份和恢复">备份和恢复</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86httpswwwcnblogscomsparkdevp9694015html" aria-label="实现原理"><a href="https://www.cnblogs.com/sparkdev/p/9694015.html">实现原理</a></a></li></ul>
                </li>
                <li>
                    <a href="#%e8%bf%9b%e7%a8%8b%e6%9d%83%e9%99%90httpswwwcnblogscomsparkdevp9694103html" aria-label="进程权限"><a href="https://www.cnblogs.com/sparkdev/p/9694103.html">进程权限</a></a><ul>
                        
                <li>
                    <a href="#%e7%99%bb%e9%99%86%e8%bf%87%e7%a8%8b" aria-label="登陆过程">登陆过程</a></li>
                <li>
                    <a href="#user-id" aria-label="user id">user id</a></li>
                <li>
                    <a href="#%e5%a4%96%e9%83%a8%e5%91%bd%e4%bb%a4" aria-label="外部命令">外部命令</a></li>
                <li>
                    <a href="#%e8%84%9a%e6%9c%ac" aria-label="脚本">脚本</a></li></ul>
                </li>
                <li>
                    <a href="#capabilitieshttpswwwcnblogscomsparkdevp11417781html" aria-label="Capabilities"><a href="https://www.cnblogs.com/sparkdev/p/11417781.html">Capabilities</a></a><ul>
                        
                <li>
                    <a href="#%e7%ae%80%e4%bb%8b-7" aria-label="简介">简介</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8" aria-label="使用">使用</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e8%bf%9b%e7%a8%8b" aria-label="进程">进程</a><ul>
                        
                <li>
                    <a href="#job-controlhttpswwwcnblogscomsparkdevp11980732html" aria-label="job control"><a href="https://www.cnblogs.com/sparkdev/p/11980732.html">job control</a></a><ul>
                        
                <li>
                    <a href="#%e8%bf%9b%e7%a8%8b%e7%bb%84" aria-label="进程组">进程组</a></li>
                <li>
                    <a href="#%e7%ae%a1%e7%90%86-2" aria-label="管理">管理</a></li></ul>
                </li>
                <li>
                    <a href="#sessionhttpswwwcnblogscomsparkdevp12146305html" aria-label="session"><a href="https://www.cnblogs.com/sparkdev/p/12146305.html">session</a></a><ul>
                        
                <li>
                    <a href="#%e8%af%9e%e7%94%9f%e4%b8%8e%e6%b6%88%e4%ba%a1" aria-label="诞生与消亡">诞生与消亡</a></li>
                <li>
                    <a href="#nohup" aria-label="nohup">nohup</a></li>
                <li>
                    <a href="#setsid" aria-label="setsid">setsid</a></li>
                <li>
                    <a href="#%e6%8e%a7%e5%88%b6%e7%bb%88%e7%ab%af" aria-label="控制终端">控制终端</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#tips-1" aria-label="TIPS">TIPS</a><ul>
                        
                <li>
                    <a href="#backupyoursystemhttpshelpubuntucomcommunitybackupyoursystem" aria-label="BackupYourSystem"><a href="https://help.ubuntu.com/community/BackupYourSystem">BackupYourSystem</a></a><ul>
                        
                <li>
                    <a href="#rsync" aria-label="Rsync">Rsync</a></li>
                <li>
                    <a href="#tarhttpshelpubuntucomcommunitybackupyoursystemtar" aria-label="TAR"><a href="https://help.ubuntu.com/community/BackupYourSystem/TAR">TAR</a></a></li>
                <li>
                    <a href="#others-3" aria-label="Others">Others</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%b8%85%e7%90%86%e7%b3%bb%e7%bb%9f" aria-label="清理系统">清理系统</a><ul>
                        
                <li>
                    <a href="#%e5%88%a0%e9%99%a4%e4%b8%8d%e5%86%8d%e9%9c%80%e8%a6%81%e7%9a%84%e5%8c%85" aria-label="删除不再需要的包">删除不再需要的包</a></li>
                <li>
                    <a href="#apt-cache" aria-label="APT cache">APT cache</a></li>
                <li>
                    <a href="#journal-logs" aria-label="Journal logs">Journal logs</a></li>
                <li>
                    <a href="#thumbnails-cache" aria-label="Thumbnails cache">Thumbnails cache</a></li>
                <li>
                    <a href="#duplicate-files" aria-label="Duplicate files">Duplicate files</a></li>
                <li>
                    <a href="#old-linux-kernels" aria-label="Old Linux kernels">Old Linux kernels</a></li>
                <li>
                    <a href="#%e6%b8%85%e7%90%86-snaphttpslinuxcnarticle-14302-1html" aria-label="清理 Snap"><a href="https://linux.cn/article-14302-1.html">清理 Snap</a></a></li></ul>
                </li>
                <li>
                    <a href="#%e5%91%bd%e4%bb%a4%e8%a1%8c%e6%8a%80%e5%b7%a7" aria-label="命令行技巧">命令行技巧</a><ul>
                        
                <li>
                    <a href="#bash-%e5%bf%ab%e6%8d%b7%e9%94%ae" aria-label="Bash 快捷键">Bash 快捷键</a></li>
                <li>
                    <a href="#%e4%bd%a0%e5%8f%af%e8%83%bd%e4%b8%8d%e7%9f%a5%e9%81%93%e7%9a%84shellhttpscoolshellcnarticles8619html" aria-label="你可能不知道的SHELL"><a href="https://coolshell.cn/articles/8619.html">你可能不知道的SHELL</a></a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%af%b4-zsh-%e6%98%af-shell-%e4%b8%ad%e7%9a%84%e6%9e%81%e5%93%81httpswwwzhihucomquestion21418449" aria-label="为什么说 zsh 是 shell 中的极品？"><a href="https://www.zhihu.com/question/21418449">为什么说 zsh 是 shell 中的极品？</a></a></li>
                <li>
                    <a href="#%e5%ba%94%e8%af%a5%e7%9f%a5%e9%81%93%e7%9a%84linux%e6%8a%80%e5%b7%a7httpscoolshellcnarticles8883html" aria-label="应该知道的LINUX技巧"><a href="https://coolshell.cn/articles/8883.html">应该知道的LINUX技巧</a></a></li>
                <li>
                    <a href="#powerline-shellhttpsgithubcomb-ryanpowerline-shell" aria-label="powerline-shell"><a href="https://github.com/b-ryan/powerline-shell">powerline-shell</a></a></li></ul>
                </li>
                <li>
                    <a href="#%e6%a3%80%e6%b5%8b%e7%a1%ac%e7%9b%98%e5%9d%8f%e9%81%93%e5%92%8c%e5%9d%8f%e5%9d%97httpsblog51ctocompengjc2417004" aria-label="检测硬盘坏道和坏块"><a href="https://blog.51cto.com/pengjc/2417004">检测硬盘坏道和坏块</a></a><ul>
                        
                <li>
                    <a href="#%e5%8f%91%e7%8e%b0" aria-label="发现">发现</a></li>
                <li>
                    <a href="#%e6%a3%80%e6%b5%8b" aria-label="检测">检测</a></li>
                <li>
                    <a href="#%e4%bf%ae%e5%a4%8d" aria-label="修复">修复</a></li>
                <li>
                    <a href="#%e5%b1%8f%e8%94%bd" aria-label="屏蔽">屏蔽</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e6%8e%a2%e7%b4%a2httpssamwhelpgithubiobook-ubuntu-qnareadhowtoexplore" aria-label="如何探索"><a href="https://samwhelp.github.io/book-ubuntu-qna/read/howto/explore/">如何探索</a></a></li>
                <li>
                    <a href="#transfer-files-between-linux-and-androidhttpsmashtipscomtransfer-images-android-linuxtext120connect20your20android20smartphone20and20your20linuxselectede2809d20or20e2809cimport20alle2809d20if20you20want20" aria-label="Transfer files between Linux and Android"><a href="https://mashtips.com/transfer-images-android-linux/#:~:text=1%20Connect%20your%20Android%20smartphone%20and%20your%20Linux,Selected%E2%80%9D%20or%20%E2%80%9CImport%20All%E2%80%9D%20if%20you%20want%20">Transfer files between Linux and Android</a></a></li>
                <li>
                    <a href="#xorg-vs-wayland" aria-label="Xorg vs Wayland">Xorg vs Wayland</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e6%89%a7%e8%a1%8c%e8%87%aa%e5%b7%b1%e7%9a%84%e7%a8%8b%e5%ba%8f%e8%a6%81%e5%9c%a8%e5%89%8d%e9%9d%a2%e5%8a%a0httpszhuanlanzhihucomp85833766" aria-label="为什么执行自己的程序要在前面加./"><a href="https://zhuanlan.zhihu.com/p/85833766">为什么执行自己的程序要在前面加./</a></a></li>
                <li>
                    <a href="#ltshttpsaskubuntucomquestions16366whats-the-difference-between-a-long-term-support-release-and-a-normal-release" aria-label="LTS"><a href="https://askubuntu.com/questions/16366/whats-the-difference-between-a-long-term-support-release-and-a-normal-release">LTS</a></a></li>
                <li>
                    <a href="#%e8%ae%be%e8%ae%a1shell%e8%84%9a%e6%9c%ac%e9%80%89%e9%a1%b9-getopthttpswwwcnblogscomf-ck-need-up9758075html" aria-label="设计shell脚本选项 getopt"><a href="https://www.cnblogs.com/f-ck-need-u/p/9758075.html">设计shell脚本选项 getopt</a></a></li>
                <li>
                    <a href="#%e5%9c%a8%e4%b8%ad%e6%96%87%e4%bb%8b%e9%9d%a2%e4%b8%8b%e5%a6%82%e4%bd%95%e5%8f%aa%e7%94%a8%e8%8b%b1%e6%96%87%e7%9b%ae%e9%8c%84%e5%90%8d%e7%a8%b1httpsaskfedoraprojectorgttopic11528" aria-label="在中文介面下，如何只用英文目錄名稱？"><a href="https://ask.fedoraproject.org/t/topic/11528">在中文介面下，如何只用英文目錄名稱？</a></a></li>
                <li>
                    <a href="#dd-%e5%88%b6%e4%bd%9cu%e7%9b%98%e5%90%af%e5%8a%a8%e7%9b%98" aria-label="dd 制作U盘启动盘">dd 制作U盘启动盘</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88-linux-%e8%a6%81%e7%94%a8-targz%e5%be%88%e5%b0%91%e7%94%a8-7z-%e6%88%96-ziphttpswwwzhihucomquestion335911358answer755424668" aria-label="为什么 Linux 要用 tar.gz，很少用 7Z 或 ZIP？"><a href="https://www.zhihu.com/question/335911358/answer/755424668">为什么 Linux 要用 tar.gz，很少用 7Z 或 ZIP？</a></a></li>
                <li>
                    <a href="#%e7%bd%ae%e9%bb%98%e8%ae%a4%e7%bc%96%e8%be%91%e5%99%a8httpswwwcnblogscomwswindp10164052html" aria-label="置默认编辑器"><a href="https://www.cnblogs.com/wswind/p/10164052.html">置默认编辑器</a></a></li>
                <li>
                    <a href="#%e9%80%9a%e8%bf%87linux%e7%b3%bb%e7%bb%9f%e8%bf%9b%e5%85%a5-bios" aria-label="通过Linux系统进入 BIOS">通过Linux系统进入 BIOS</a></li>
                <li>
                    <a href="#5-ways-to-check-cpu-info-in-linuxhttpslinuxhandbookcomcheck-cpu-info-linux" aria-label="5 Ways to Check CPU Info in Linux"><a href="https://linuxhandbook.com/check-cpu-info-linux/">5 Ways to Check CPU Info in Linux</a></a></li>
                <li>
                    <a href="#exfathttpwwwruanyifengcomblog201810exfathtmlhmsrtoutiaoioutm_mediumtoutiaoioutm_sourcetoutiaoio" aria-label="exFAT"><a href="http://www.ruanyifeng.com/blog/2018/10/exfat.html?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io">exFAT</a></a></li>
                <li>
                    <a href="#logging-in-as-root-in-ubuntu-with-live-cd" aria-label="Logging in as Root in Ubuntu with Live CD">Logging in as Root in Ubuntu with Live CD</a></li>
                <li>
                    <a href="#how-to-download-a-large-file-faster-from-google-drivehttpsyantraascomdownload-large-file-faster-from-google-drive" aria-label="How To Download A Large File Faster From Google Drive?"><a href="https://yantraas.com/download-large-file-faster-from-google-drive/">How To Download A Large File Faster From Google Drive?</a></a></li>
                <li>
                    <a href="#usb%e6%8f%92%e6%a7%bd%e9%ac%86%e5%8b%95%e6%80%8e%e9%ba%bc%e8%be%a6httpswwwyoutubecomwatchvwud4i6gzcpk" aria-label="USB插槽鬆動怎麼辦"><a href="https://www.youtube.com/watch?v=WUd4I6GZcpk">USB插槽鬆動怎麼辦</a></a></li>
                <li>
                    <a href="#nmcheckgnomeorghttpsaskubuntucomquestions1070823some-suspicious-software-making-request-to-nmcheck-gnome-org" aria-label="nmcheck.gnome.org"><a href="https://askubuntu.com/questions/1070823/some-suspicious-software-making-request-to-nmcheck-gnome-org">nmcheck.gnome.org</a></a></li>
                <li>
                    <a href="#xdg_templates_dirhttpsaskubuntucomquestions94734what-is-the-templates-folder-in-the-home-directory-for" aria-label="XDG_TEMPLATES_DIR"><a href="https://askubuntu.com/questions/94734/what-is-the-templates-folder-in-the-home-directory-for">XDG_TEMPLATES_DIR</a></a></li>
                <li>
                    <a href="#%e8%bd%af%e4%bb%b6%e7%9a%84%e7%a8%b3%e5%ae%9a%e6%80%a7httpswwwzhihucomquestion301581684answer547761587" aria-label="软件的稳定性"><a href="https://www.zhihu.com/question/301581684/answer/547761587">软件的稳定性</a></a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e5%b0%86google%e6%90%9c%e7%b4%a2%e9%99%90%e5%88%b6%e4%b8%ba%e7%89%b9%e5%ae%9a%e8%af%ad%e8%a8%80%e7%9a%84%e7%bb%93%e6%9e%9chttpsqastackcnwebapps16047how-to-restrict-a-google-search-to-results-of-a-specific-language" aria-label="如何将Google搜索限制为特定语言的结果"><a href="https://qastack.cn/webapps/16047/how-to-restrict-a-google-search-to-results-of-a-specific-language">如何将Google搜索限制为特定语言的结果</a></a></li>
                <li>
                    <a href="#two-options-to-recover-your-pc-with-androidhttpswwwmakeuseofcomtagrecover-pc-using-android" aria-label="Two Options to Recover Your PC With Android"><a href="https://www.makeuseof.com/tag/recover-pc-using-android/">Two Options to Recover Your PC With Android</a></a></li>
                <li>
                    <a href="#good-practice-to-avoid-using-sudo-suhttpsaskubuntucomquestions962021is-it-considered-good-practice-to-avoid-using-sudo-su" aria-label="good practice to avoid using sudo su"><a href="https://askubuntu.com/questions/962021/is-it-considered-good-practice-to-avoid-using-sudo-su">good practice to avoid using <code>sudo su</code></a></a></li>
                <li>
                    <a href="#sshfs-how-to-mount-remote-file-systems-over-sshhttpsphoenixnapcomkbsshfs" aria-label="SSHFS: How to Mount Remote File Systems Over SSH"><a href="https://phoenixnap.com/kb/sshfs">SSHFS: How to Mount Remote File Systems Over SSH</a></a><ul>
                        
                <li>
                    <a href="#install-sshfs" aria-label="Install SSHFS">Install SSHFS</a></li>
                <li>
                    <a href="#mount-a-remote-file-system-on-linux" aria-label="Mount a Remote File System on Linux">Mount a Remote File System on Linux</a></li></ul>
                </li>
                <li>
                    <a href="#img%e8%bd%ac%e5%8c%96%e6%88%90isohttpsos51ctocomarticle290012html" aria-label="img转化成iso"><a href="https://os.51cto.com/article/290012.html">img转化成iso</a></a></li>
                <li>
                    <a href="#hwehttpswikiubuntucomkernelltsenablementstack" aria-label="HWE"><a href="https://wiki.ubuntu.com/Kernel/LTSEnablementStack">HWE</a></a></li>
                <li>
                    <a href="#microcodehttpsdecodezpgithubio20200712quickwords44-microcode" aria-label="Microcode"><a href="https://decodezp.github.io/2020/07/12/quickwords44-microcode/">Microcode</a></a><ul>
                        
                <li>
                    <a href="#%e5%ae%89%e8%a3%85%e6%9b%b4%e6%96%b0%e5%be%ae%e7%a0%81httpslinuxcnarticle-9411-1html" aria-label="安装/更新微码"><a href="https://linux.cn/article-9411-1.html">安装/更新微码</a></a></li></ul>
                </li>
                <li>
                    <a href="#automatic-light--dark-modehttpsaskubuntucomquestions1234742automatic-light-dark-mode" aria-label="Automatic Light / Dark Mode"><a href="https://askubuntu.com/questions/1234742/automatic-light-dark-mode">Automatic Light / Dark Mode</a></a></li>
                <li>
                    <a href="#%e5%b0%86du%e7%9a%84%e8%be%93%e5%87%ba%e6%8c%89%e6%96%87%e4%bb%b6%e5%a4%a7%e5%b0%8f%e6%8e%92%e5%ba%8fhttpsbloglilydjwgmeposts18368html" aria-label="将du的输出按文件大小排序"><a href="https://blog.lilydjwg.me/posts/18368.html">将du的输出按文件大小排序</a></a></li>
                <li>
                    <a href="#%e6%94%b9%e5%96%84%e8%a7%a6%e6%91%b8%e6%9d%bf%e4%bd%93%e9%aa%8chttpsplumzmearchives12343" aria-label="改善触摸板体验"><a href="https://plumz.me/archives/12343/">改善触摸板体验</a></a></li>
                <li>
                    <a href="#reset-lost-root-passwordhttpswikiarchlinuxorgtitlereset_lost_root_password_e7ae80e4bd93e4b8ade69687" aria-label="Reset lost root password"><a href="https://wiki.archlinux.org/title/Reset_lost_root_password_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Reset lost root password</a></a><ul>
                        
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8-livecd" aria-label="使用 LiveCD">使用 LiveCD</a></li>
                <li>
                    <a href="#%e7%94%a8-bash-%e4%bd%9c%e4%b8%ba-init" aria-label="用 Bash 作为 Init">用 Bash 作为 Init</a></li></ul>
                </li>
                <li>
                    <a href="#how-to-block-internet-access-to-certain-programs-on-linuxhttpsserverfaultcomquestions550276how-to-block-internet-access-to-certain-programs-on-linux" aria-label="How to block internet access to certain programs on Linux"><a href="https://serverfault.com/questions/550276/how-to-block-internet-access-to-certain-programs-on-linux">How to block internet access to certain programs on Linux</a></a></li>
                <li>
                    <a href="#how-does-ubuntu-make-moneyhttpsaskubuntucomquestions21730how-does-ubuntu-make-money" aria-label="How does Ubuntu make money?"><a href="https://askubuntu.com/questions/21730/how-does-ubuntu-make-money">How does Ubuntu make money?</a></a></li>
                <li>
                    <a href="#%e5%90%af%e7%94%a8-trimhttpslinuxcnarticle-8177-1html" aria-label="启用 TRIM"><a href="https://linux.cn/article-8177-1.html">启用 TRIM</a></a></li>
                <li>
                    <a href="#reserve-5-of-the-spacehttpsaskubuntucomquestions249387df-h-used-space-avail-free-space-is-less-than-the-total-size-of-home" aria-label="reserve 5% of the space"><a href="https://askubuntu.com/questions/249387/df-h-used-space-avail-free-space-is-less-than-the-total-size-of-home">reserve 5% of the space</a></a></li>
                <li>
                    <a href="#change-partition-labelhttpswwwtecmintcomchange-modify-linux-disk-partition-label-names" aria-label="Change Partition Label"><a href="https://www.tecmint.com/change-modify-linux-disk-partition-label-names/">Change Partition Label</a></a><ul>
                        
                <li>
                    <a href="#e2label-or-tune2fs" aria-label="e2label or tune2fs">e2label or tune2fs</a></li>
                <li>
                    <a href="#ntfslabel" aria-label="ntfslabel">ntfslabel</a></li>
                <li>
                    <a href="#mkswap" aria-label="mkswap">mkswap</a></li>
                <li>
                    <a href="#exfatlabel" aria-label="exfatlabel">exfatlabel</a></li></ul>
                </li>
                <li>
                    <a href="#disable-usb-automounthttpsaskubuntucomquestions89244how-to-disable-automount-in-nautiluss-preferences" aria-label="Disable usb automount"><a href="https://askubuntu.com/questions/89244/how-to-disable-automount-in-nautiluss-preferences">Disable usb automount</a></a></li>
                <li>
                    <a href="#create-an-iso-filehttpsvituxcomhow-to-create-an-iso-file-in-ubuntu" aria-label="Create an ISO File"><a href="https://vitux.com/how-to-create-an-iso-file-in-ubuntu/">Create an ISO File</a></a></li>
                <li>
                    <a href="#keychainhttpswwwcybercitibizfaqubuntu-debian-linux-server-install-keychain-apt-get-command" aria-label="keychain"><a href="https://www.cyberciti.biz/faq/ubuntu-debian-linux-server-install-keychain-apt-get-command/">keychain</a></a></li>
                <li>
                    <a href="#default-bashrchttpsgistgithubcommariobonales1637696" aria-label="Default .bashrc"><a href="https://gist.github.com/marioBonales/1637696">Default .bashrc</a></a></li>
                <li>
                    <a href="#use-cp-to-exclude-a-specific-directoryhttpsstackoverflowcomquestions4585929how-to-use-cp-command-to-exclude-a-specific-directory1478940014789400" aria-label="use &amp;lsquo;cp&amp;rsquo; to exclude a specific directory"><a href="https://stackoverflow.com/questions/4585929/how-to-use-cp-command-to-exclude-a-specific-directory/14789400#14789400">use &lsquo;cp&rsquo; to exclude a specific directory</a></a></li>
                <li>
                    <a href="#regenerate-initramfshttpsaskubuntucomquestions1351911what-does-regenerate-your-initramfs-mean" aria-label="regenerate initramfs"><a href="https://askubuntu.com/questions/1351911/what-does-regenerate-your-initramfs-mean">regenerate initramfs</a></a></li>
                <li>
                    <a href="#extract-a-specific-file-from-a-tar-archivehttpsaskubuntucomquestions168795how-do-i-extract-a-specific-file-from-a-tar-archive" aria-label="extract a specific file from a tar archive"><a href="https://askubuntu.com/questions/168795/how-do-i-extract-a-specific-file-from-a-tar-archive">extract a specific file from a tar archive</a></a></li>
                <li>
                    <a href="#repair-grubhttpsaskubuntucomquestions88384how-can-i-repair-grub-how-to-get-ubuntu-back-after-installing-windows" aria-label="repair grub"><a href="https://askubuntu.com/questions/88384/how-can-i-repair-grub-how-to-get-ubuntu-back-after-installing-windows">repair grub</a></a></li>
                <li>
                    <a href="#dns%e7%bc%93%e5%ad%98httpsblogcsdnnetcunchi4221articledetails107470928" aria-label="DNS缓存"><a href="https://blog.csdn.net/cunchi4221/article/details/107470928">DNS缓存</a></a></li>
                <li>
                    <a href="#change-my-usernamehttpsaskubuntucomquestions34074how-do-i-change-my-username" aria-label="change my username"><a href="https://askubuntu.com/questions/34074/how-do-i-change-my-username">change my username</a></a></li>
                <li>
                    <a href="#test-network-speedhttpsphoenixnapcomkblinux-network-speed-test" aria-label="Test Network Speed"><a href="https://phoenixnap.com/kb/linux-network-speed-test">Test Network Speed</a></a></li>
                <li>
                    <a href="#%e8%93%9d%e7%89%99%e4%b8%8ewifi%e4%bf%a1%e5%8f%b7%e5%b9%b2%e6%89%b0httpswwwbilibilicomreadcv218058" aria-label="蓝牙与WiFi信号干扰"><a href="https://www.bilibili.com/read/cv218058">蓝牙与WiFi信号干扰</a></a></li>
                <li>
                    <a href="#ram--vram" aria-label="RAM &amp;amp; VRAM">RAM &amp; VRAM</a><ul>
                        
                <li>
                    <a href="#vram-as-ramhttpswikiarchlinuxorgtitleswap_on_video_ram" aria-label="VRAM as RAM"><a href="https://wiki.archlinux.org/title/Swap_on_video_RAM">VRAM as RAM</a></a></li>
                <li>
                    <a href="#ram-as-vramhttpswwwredditcomrpcmasterracecomments4bj7f7is_there_any_way_to_use_ram_memory_as_vram" aria-label="RAM as VRAM"><a href="https://www.reddit.com/r/pcmasterrace/comments/4bj7f7/is_there_any_way_to_use_ram_memory_as_vram/">RAM as VRAM</a></a></li></ul>
                </li>
                <li>
                    <a href="#optimizing-for-gaminghttpssteamcommunitycomsharedfilesfiledetailsid1787799592" aria-label="Optimizing for Gaming"><a href="https://steamcommunity.com/sharedfiles/filedetails/?id=1787799592">Optimizing for Gaming</a></a><ul>
                        
                <li>
                    <a href="#enable-multilib" aria-label="Enable Multilib">Enable Multilib</a></li>
                <li>
                    <a href="#gpu-drivers" aria-label="GPU Drivers">GPU Drivers</a></li>
                <li>
                    <a href="#linux-kernel-1" aria-label="Linux kernel">Linux kernel</a></li>
                <li>
                    <a href="#feral-gamemodehttpslinuxhintcomgamemode-improve-gaming-performance-in-linux" aria-label="Feral Gamemode"><a href="https://linuxhint.com/gamemode-improve-gaming-performance-in-linux/">Feral Gamemode</a></a></li>
                <li>
                    <a href="#nvidia-improvements" aria-label="Nvidia Improvements">Nvidia Improvements</a></li>
                <li>
                    <a href="#libstrangle" aria-label="Libstrangle">Libstrangle</a></li>
                <li>
                    <a href="#mangohud" aria-label="Mangohud">Mangohud</a></li>
                <li>
                    <a href="#vkbasalt" aria-label="VKBasalt">VKBasalt</a></li>
                <li>
                    <a href="#goverlay" aria-label="GOverlay">GOverlay</a></li>
                <li>
                    <a href="#xbox-one-controller" aria-label="Xbox One Controller">Xbox One Controller</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%ae%a4%e8%af%81%e7%a1%ac%e4%bb%b6httpswwwzhihucomquestion286150644" aria-label="认证硬件"><a href="https://www.zhihu.com/question/286150644">认证硬件</a></a></li>
                <li>
                    <a href="#%e5%8a%9f%e8%80%97%e6%8e%a7%e5%88%b6httpsarchicekylinonlineadvancedpower-ctlhtml" aria-label="功耗控制"><a href="https://arch.icekylin.online/advanced/power-ctl.html">功耗控制</a></a><ul>
                        
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8-tlp-%e5%bb%b6%e9%95%bf%e7%94%b5%e6%b1%a0%e5%af%bf%e5%91%bd%e5%8f%8a%e7%bb%ad%e8%88%aa" aria-label="使用 TLP 延长电池寿命及续航">使用 TLP 延长电池寿命及续航</a></li>
                <li>
                    <a href="#%e7%94%b5%e5%8e%8b%e4%b8%8b%e6%8e%a2" aria-label="电压下探">电压下探</a></li>
                <li>
                    <a href="#%e9%99%8d%e4%bd%8e%e5%8a%9f%e7%8e%87%e5%a2%99" aria-label="降低功率墙">降低功率墙</a></li></ul>
                </li>
                <li>
                    <a href="#%e4%ba%a4%e6%8d%a2%e6%96%87%e4%bb%b6httpsarchlinuxstudiogithubioarchlinuxtutorialrookiedeappid_5e8aebee7bdaee4baa4e68da2e69687e4bbb6-swape58fafe98089" aria-label="交换文件"><a href="https://archlinuxstudio.github.io/ArchLinuxTutorial/#/rookie/DE&amp;App?id=_5%e8%ae%be%e7%bd%ae%e4%ba%a4%e6%8d%a2%e6%96%87%e4%bb%b6-swap%e5%8f%af%e9%80%89">交换文件</a></a></li></ul>
                </li>
                <li>
                    <a href="#questions-2" aria-label="QUESTIONS">QUESTIONS</a><ul>
                        
                <li>
                    <a href="#ubuntu-%e6%97%a0%e6%b3%95%e5%85%b3%e6%9c%ba" aria-label="Ubuntu 无法关机">Ubuntu 无法关机</a></li>
                <li>
                    <a href="#acpi-error-ae_already_existshttpsaskubuntucomquestions1064528cant-install-ubuntu-from-an-usb-stick-ae-not-found-ae-already-exists" aria-label="ACPI ERROR: AE_ALREADY_EXISTS"><a href="https://askubuntu.com/questions/1064528/cant-install-ubuntu-from-an-usb-stick-ae-not-found-ae-already-exists">ACPI ERROR: AE_ALREADY_EXISTS</a></a></li>
                <li>
                    <a href="#%e8%a7%a3%e5%8e%8bzip%e4%b9%b1%e7%a0%81httpsforumubuntuorgcnviewtopicphpf122t175405p1343326" aria-label="解压zip乱码"><a href="https://forum.ubuntu.org.cn/viewtopic.php?f=122&amp;t=175405&amp;p=1343326">解压zip乱码</a></a></li>
                <li>
                    <a href="#cant-run-csgo-at-fullscreenhttpsaskubuntucomquestions1114857cant-run-csgo-at-fullscreen-ubuntu-18-10" aria-label="Can&amp;rsquo;t run CS:GO at fullscreen"><a href="https://askubuntu.com/questions/1114857/cant-run-csgo-at-fullscreen-ubuntu-18-10">Can&rsquo;t run CS:GO at fullscreen</a></a></li>
                <li>
                    <a href="#how-to-disable-lock-in--kubuntuhttpswwwubuntubuzzcom201604how-to-disable-suspend-lock-ubuntu-kubuntuhtmlm1textto20disable20kde20lock20behavior2c20in20the20sameactions20post20tags203a20kde2c20kubuntu2c20ubuntu2c20unity" aria-label="How To Disable Lock In Kubuntu"><a href="https://www.ubuntubuzz.com/2016/04/how-to-disable-suspend-lock-ubuntu-kubuntu.html?m=1#:~:text=To%20disable%20KDE%20lock%20behavior%2C%20in%20the%20same,actions.%20Post%20Tags%20%3A%20KDE%2C%20Kubuntu%2C%20Ubuntu%2C%20unity">How To Disable Lock In  Kubuntu</a></a></li>
                <li>
                    <a href="#gnome-3-displays-two-icons-for-same-apphttpsaskubuntucomquestions898474why-do-some-applications-have-two-icons-in-usr-share-application" aria-label="Gnome 3 displays two icons for same app"><a href="https://askubuntu.com/questions/898474/why-do-some-applications-have-two-icons-in-usr-share-application">Gnome 3 displays two icons for same app</a></a></li>
                <li>
                    <a href="#ssh_exchange_identification-connection-closed-by-remote-hosthttpswwwzhihucomquestion20023544" aria-label="ssh_exchange_identification: Connection closed by remote host"><a href="https://www.zhihu.com/question/20023544">ssh_exchange_identification: Connection closed by remote host</a></a></li>
                <li>
                    <a href="#disk-show-129986-tb" aria-label="Disk show 129986 TB">Disk show 129986 TB</a></li>
                <li>
                    <a href="#no-caching-mode-page-found" aria-label="No Caching mode page found">No Caching mode page found</a></li>
                <li>
                    <a href="#certificate-verification-failedhttpsblogcsdnnetchaowanqarticledetails121559709" aria-label="Certificate verification failed"><a href="https://blog.csdn.net/Chaowanq/article/details/121559709">Certificate verification failed</a></a></li>
                <li>
                    <a href="#move-and-overwrite-subdirectories-and-files-to-parent-directoryhttpsunixstackexchangecomquestions9899how-to-move-and-overwrite-subdirectories-and-files-to-parent-directory" aria-label="Move and overwrite subdirectories (and files) to parent directory"><a href="https://unix.stackexchange.com/questions/9899/how-to-move-and-overwrite-subdirectories-and-files-to-parent-directory">Move and overwrite subdirectories (and files) to parent directory</a></a></li>
                <li>
                    <a href="#system-program-problem-detectedhttpswwwcnblogscomcrazyackingp5451861html" aria-label="System program problem detected"><a href="https://www.cnblogs.com/crazyacking/p/5451861.html">System program problem detected</a></a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p><code>友邦拓</code> <code>乌班图</code></p>
<blockquote>
<p>During the first ten years of this HOWTO&rsquo;s life, I reported that from a new user&rsquo;s point of view, all Linux distributions are almost equivalent. But in 2006-2007, an actual best choice emerged: <a href="http://www.ubuntu.com/">Ubuntu</a>. While other distros have their own areas of strength, Ubuntu is far and away the most accessible to Linux newbies. Beware, though, of the hideous and nigh-unusable &ldquo;Unity&rdquo; desktop interface that Ubuntu introduced as a default a few years later; the Xubuntu or Kubuntu variants are better.</p>
<p>Eric Steven Raymond - How To Become A Hacker</p>
</blockquote>
<h2 id="学习-linux-几点忠告httpswikiubuntuorgcne5ada6e4b9a0_linux_e587a0e782b9e5bfa0e5918a"><a href="https://wiki.ubuntu.org.cn/%E5%AD%A6%E4%B9%A0_Linux_%E5%87%A0%E7%82%B9%E5%BF%A0%E5%91%8A">学习 Linux 几点忠告</a><a hidden class="anchor" aria-hidden="true" href="#学习-linux-几点忠告httpswikiubuntuorgcne5ada6e4b9a0_linux_e587a0e782b9e5bfa0e5918a">#</a></h2>
<p><strong>不要當“傳教士”</strong></p>
<p><em>(這點有一個重大弊端：開放軟體沒有商業軟件那樣的宣傳，如果使用者都如此低調，用戶群不會大幅擴展。)</em></p>
<p>很多人在討論區不斷的引起的Linux對比Windows之類的討論，甚至爭的面紅耳赤，這是沒有必要的</p>
<p>這種爭論是浪費時間而沒有任何用處的。對，你花了一下午，用許多事實“捍衛”了Linux比Windows好這個說法。但是Windows的支持者並不會喜歡上Linux的，他們只是稍微退縮一下，然後找一些新的證據來跟你辯論。</p>
<p>世界上的人們都在利用Linux的研究最前沿的科學，我們還在這裡討論“要不要用Linux的這種無聊的問題，什麼時候才能趕上時代前進的步伐？</p>
<p>什麼叫做Window支持者，什麼叫做Linux的支持者？我們為什麼要支持某一個而反對另外一個？你不需要為 Linux的護法，不需要成為 Linux的支持者“或者”GNU的傳教士“ GNU / Linux的已經用事實向世界證明了它們的威力，已經被大多數人接受。你只需要安安靜靜享受的GNU / Linux的給你的樂趣和自由。</p>
<p>你需要關心的不是你的工具是什麼，而是你用它做了什麼。精通的Linux並不說明任何問題，因為它只是一個工具而已。如果你用的Windows能很好的完成你的任務，那你就沒有必要費時間去熟悉Linux操作系統。直到有一天你發現一項任務只有Linux操作系統才能完成的時候再換也不遲，因為你身邊的的Linux的愛好者一定會很樂意的幫助你。</p>
<p>如果你在使用Linux操作系統的過程中對它產生了感情，那麼你應該明白那些習慣於使用Windows的人也會對Windows產生依賴。類似的爭論還有很多：微軟 Office Word和TeX，Emacs和Vim，Wolfram Mathematica和Maple，侏儒，fvwm的和KDE的時候，狗派&hellip; &hellip;和冷靜地對自己說：“我不站在它們任何一邊。”儘管這有些不容易辦到。</p>
<p>各人的需要不同，生活的環境不同。對你來說好的東西，對別人來說不一定好，我們需要尊重別人的選擇。如果你當面說別人正在用的程序不好，沒有必要。</p>
<p><strong>不要強迫自己”</strong></p>
<p>喜歡電腦的人總是有某些心理強迫傾向。有的人說：“鍵盤比滑鼠快。我不要用滑鼠。這樣才有高效率。”所以他在編輯器裡無論什麼時候總是用20W的，大於 10J這樣的命令到達目的點。他甚至覺得圖形界面是多餘的，乾脆都不裝 Xwindow。</p>
<p>全部用鍵盤看起來的確比讓手離開鍵盤去拿鼠標，再回來“快”多了，但是快的擊鍵頻率不等於工作的高效率，對你的健康更沒有什麼好處。這只能把你變成打鍵盤的機器。</p>
<p>當你正在檢查你的文章或者程序，思維正在隨著字符的含義流動，突然為 20W，大於 10J這樣的東西出現在你的腦子裡，是不是會打斷思路？不？那說明你當時思考的問題比較簡單，這些干擾還不會起到副作用。</p>
<p>其實很多人用電腦的時候，思想都受到某種教學的束縛，上面這個只是教多數種類中的一種。某些人創造了很多這種數學，用他的工作方式來要求別人，嘲笑方式跟他不一樣的人。比如有的人嘲笑其它人寫程序不按ç 8字符縮進，嘲笑別人在六裡用方向鍵，嘲笑別人不知道是什麼增值稅，嘲笑其它人用在Java，C＃這種由地方選區回收內存語言 &hellip; &hellip;</p>
<p>你不用管各種各樣的教學，電腦只是你的工具，你想怎麼用就怎麼用。沒有人能夠約束你，沒有人可以嘲笑你的工作方式。電腦明天就不再是這個樣子，所以今天你不用完全了解它。你沒有必要知道別人創造的一切，因為你需要留點時間自己創造些東西。只要有樂趣！</p>
<p>當你下次修改文章的時候，不妨試試悠閒的用滑鼠在你眼睛看到的地方輕輕點一下。</p>
<blockquote>
<p>如果你發現自己有類似的強迫症，建議去諮詢一下心理醫生。</p>
</blockquote>
<p><strong>不要“玩”Linux</strong></p>
<p>Linux的很多人用的時候會感覺很迷茫，該用哪個發行版本呢？是不是我少裝了什麼？怎麼升級這麼快啊！怎麼這麼不穩定！每當遇到新的軟件他就想試用，每當新的版本出現，他就更新，然後用鼠標在新的菜單裡選擇從來沒見過的程序來用用。</p>
<p>其實你是為了玩Linux而使用Linux操作系統的，而沒有找到正確的理由來利用Linux操作系統。你首先要明確用電腦的目的，你用它是為了解決你的實際問題，而不是為了學習安裝操作系統，不是為了測試哪個版本好用，不是為了“趕上潮流，更不是因為你硬盤太大了，你想多佔點空間。</p>
<p>如果你啟動了電腦之後不知道應該幹什麼，那麼最好先不要用電腦，因為你可能有更重要的事情需要做。這沒什麼說的。</p>
<p><strong>不用挑剔發行版本</strong></p>
<p>很多人剛開始用linux的時候，總是在懷疑別的發行版本是否比自己正在用的這個好，總是懷疑自己以後什麼時候會失去支持，不得不換用別的發行。所以很多人今天是紅帽，明天又換成了Debian的，一會兒又是巴布亞&hellip; &hellip;甚至有的人在一台機器上裝了兩個版本的Linux操作系統，然後比較哪一個好。</p>
<p>其實你完全沒有必要這樣做，任何發行，只要你熟悉了，你在上面的工作方式幾乎不會受到任何影響。我以前一直用的紅帽，當我有一天在我的一台新機器上安裝Debian時，我發現使用紅帽的經驗完全沒有浪費。我用了一個下午就配置好了Debian，使它服服貼貼的聽我的話，就跟沒有換發行版本一樣。</p>
<p>Debian，拓林思，SuSE，紅帽，Gentoo&hellip; &hellip;任何一個版本都是不錯的。很多人認為自己攢一個 LFS的是高水平黑客的象徵，但是不是每個人都有精力去了解所有細節。</p>
<p><strong>不要盲目升級</strong></p>
<p>不知道這是心理作用還是什麼，有的人看到比較大的版本號，就會很想換成那個。很多人的Redhat的本來配置的很舒服了，可是一旦Redhat的發行新的版本，他們就會盡快下載過來，然後選擇升級安裝。結果很多時候把自己原來修改得很好的配置文件給沖掉了。新的軟件又帶來了新的問題，比如有一次我的rxvt的就升級到2.7.8跟miniChinput衝突了，升級到Redhat的8.0，xmms的發現居然缺省不能放了MP3播放，XFree86的是i810的模塊在啟動上有新的漏洞，Mozilla中，會導致突然退出。</p>
<p>如果你已經配置好了一切，千萬別再整體升級了，這會浪費你很多很多時間的，不值得。有句話說得好：“如果沒有打破，不解決它。”如果你的程序能夠完成你需要做的事情，你何必升級呢？？？？</p>
<blockquote>
<p>是的，不論是從論壇還是其他的地方反映出來的大部分都是這個問題，要么比较SUSE和Ubuntu的好，要么比Ubuntu或者Mandriva的好等等的言論。很多人還是把Linux操作系統看成了一個表面的東西。並沒有塌下心來學習 Linux系統。</p>
</blockquote>
<p><strong>不要配置你不需要的東西</strong></p>
<p>如果你只想做一個像我這樣的普通用戶，主要目的是用的Linux來完成自己的科研任務和日常工作，那就可以不用系統管理員或者網絡管理員的標準來要求自己，因為當一個系統和網絡管理員確實很辛苦。普通用戶學習那些不經常用到的複雜的維護系統的工具，其實是浪費時間，學了不用是會很快忘記的！</p>
<p>我不是一個合格的網絡管理員，我的服務器都只設置了我自己需要的功能，設置好ssh連接的ftp已經足夠了，那樣可以省去我很多麻煩。我從來不過度考慮“安全，因為 Linux操作系統缺省已經很安全了。我沒有磁帶機，就不用管tar的那些稀奇古怪的參數了，czf，xzf，ztf已經可以滿足我所有的需要。桑達，awk的，&hellip;我也只會幾種常用的命令行。</p>
<p><strong>不要習慣的使用根帳號。在需要的時候才用！</strong></p>
<p>這是很多剛接觸的UNIX類操作系統的人常見的現象，他們不喜歡在管理系統的時候才用，而是一直用根帳號幹所有事情，配置系統，安裝程序，瀏覽網頁，玩遊戲，編程 &hellip; &hellip;</p>
<p>結果有一天，他不小心在某個系統目錄使用了del * &hellip;後果不堪設想 &hellip; &hellip;</p>
<p><strong>不要用商業的眼光來看待Linux</strong></p>
<p>Linux不是商業軟件，所以不要用要求Solaris操作系統，視窗那樣的眼光來看 Linux操作系統。自由軟件的作者們從來不拉攏用戶，他們對用戶不負有任何責任。實際上在自由軟件的世界裡，開發者“和”用戶“並沒有明確的界限，大家是朋友。</p>
<p>自由軟件很可能只是滿足作者和他的朋友的需要，甚至是為了好玩而創造的。自由軟件不是完美的，自由軟件承認自己有缺點，它不會自吹自擂，蒙蔽“用戶”的耳目。這種對作者責任的解脫激發了作者的創造力，他們不用過分考慮“向上兼容，他們往往比背上重重包袱的商業軟件結構更合理，技術更先進。</p>
<p>所以當你用某個自由軟件遇到困難的時候，不應該埋怨軟件的作者，因為他們對你並沒有義務。你不應該把自己當成一個挑剔的顧客，而要把自己作為這個軟件的顧問和一個和藹的建議者，這樣你才能理解作者寫這個程序時的快樂，在遇到問題時向作者反映，幫助他完善這個軟件，成為一個快樂的參與者。就像你的哥哥送你一個他用舊了的自行車，你應該珍惜這份友情，而不要在車壞了，或者騎車摔了一跤的時候大罵你的哥哥。如果你真的不能使用這種合作的心態，那麼最好不要使用這個軟件。</p>
<p>這是一種先進的文化，它包含了互相合作，科學創新的精神。理解這一點不是很容易，很多人往往是因為不能理解這種文化而離開自由軟件。這對於作者來說並沒有什麼損失。</p>
<p><strong>幹你的正事去</strong></p>
<p>很多人跟我說，你的網頁浪費我好多時間來配置這配置那，一會兒是fvwm的，一會兒是Mutt中&hellip; &hellip;</p>
<p>嗯&hellip; &hellip;那些東西都是我有空的時候一點一點積累的，如果你想一次性搞定所有那些東西，恐怕得花你幾個星期甚至幾個月的時間！並不是一定要搞定所有這些東西你才能正常工作的。除非你真的非得利用某個程序，或者你閒著沒事，否則你可以不管這些東西。</p>
<p><strong>上面幾條僅供參考</strong></p>
<p>以上只是個人意見，不一定適合所有人。取捨由你了！</p>
<h2 id="settings">Settings<a hidden class="anchor" aria-hidden="true" href="#settings">#</a></h2>
<h3 id="dns">DNS<a hidden class="anchor" aria-hidden="true" href="#dns">#</a></h3>
<p><strong><a href="https://cloud.tencent.com/developer/article/1626778#:~:text=%E4%B8%80%E3%80%81%E5%9C%A8%20Ubuntu%20%E6%A1%8C%E9%9D%A2%E7%89%88%E8%AE%BE%E7%BD%AE%20DNS%20%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E6%9C%8D%E5%8A%A1%E5%99%A8.%20%E5%9C%A8%20Ubuntu%20%E6%A1%8C%E9%9D%A2%E7%89%88%E8%AE%BE%E7%BD%AE,DNS%20%E7%9A%84%20IP%20%E5%9C%B0%E5%9D%80%EF%BC%8C%E7%94%A8%E9%80%97%E5%8F%B7%E9%9A%94%E5%BC%80%E3%80%82.%20%E6%88%91%E4%BB%AC%E4%BD%BF%E7%94%A8%20Google%20DNS%20%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%82.">GUI</a></strong></p>
<ol>
<li>打开设置窗口</li>
<li>如果你连接到了 WiFi 网络，点击“Wi-FI”标签栏。否则，如果你有一个有线连接，点击『Network』标签栏。</li>
<li>选择你要设置 DNS 的网络连接，并且点击齿轮状的按钮，打开网络管理器。</li>
<li>选择 IPv4 设置标签栏。</li>
<li>禁用自动开关，并且输入 DNS 的 IP 地址，用逗号隔开。我们使用 Google DNS 域名解析服务器。</li>
<li>点击“Apply”按钮，保存修改。</li>
</ol>
<p>这个修改应该会立即有效，除非那些已经缓存了的 DNS 条目。如果你想切换回旧的设置，打开网络管理器，IPv4 设置，并且启用自动开关。</p>
<p><strong><a href="https://www.cnblogs.com/baihuitestsoftware/articles/9519724.html">CLI</a></strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 显示当前网络连接</span>
$ nmcli connection show
<span style="color:#75715e"># 修改当前网络连接对应的DNS服务器，这里的网络连接可以用名称或者UUID来标识</span>
$ nmcli con mod ens160 ipv4.dns <span style="color:#e6db74">&#34;114.114.114.114 8.8.4.4&#34;</span>
<span style="color:#75715e"># 配置生效</span>
$ nmcli con up ens160
</code></pre></div><p><a href="https://phoenixnap.com/kb/ubuntu-dns-nameservers">或者</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># Config File</span>
$ vi /etc/netplan/01-network-manager-all.yaml
network:
  version: <span style="color:#ae81ff">2</span>
  renderer: NetworkManager
  ethernets:
    ens3:
      dhcp4: no
      addresses:
        - 192.168.100.199/24
      gateway4: 192.168.100.1
      nameservers:
        address: <span style="color:#f92672">[</span>114.114.114.114, 8.8.4.4<span style="color:#f92672">]</span>
  wifis:
    ...
<span style="color:#75715e"># Apply the changes you made in the config file</span>
$ sudo netplan apply
<span style="color:#75715e"># To check if the system successfully applied the changes</span>
$ systemd-resolve --status | grep <span style="color:#e6db74">&#39;DNS Servers&#39;</span> -A2
         DNS Servers: 114.114.114.114
                      8.8.8.8        
                      8.8.4.4   
</code></pre></div><p>注意：您系统上的文件可能缺少整个以太网或 wifi 部分。 在这种情况下，添加缺少的行，确保遵守示例中提供的缩进。</p>
<p><strong><a href="https://www.fosslinux.com/45397/opendns-vs-google-dns.htm">Testing the Domain Name Resolution Speed</a></strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ time dig @114.114.114.114
</code></pre></div><h3 id="others">Others<a hidden class="anchor" aria-hidden="true" href="#others">#</a></h3>
<ul>
<li>Bluetooth: OFF</li>
<li>Formats: United States</li>
<li>Blank screen: 10</li>
<li>Night Light: On</li>
<li>Touchpad: OFF</li>
<li><a href="https://linuxhint.com/enable-fractional-scaling-on-ubuntu/">Fractional Scaling</a></li>
</ul>
<h2 id="softwareupdates">SoftWare&amp;Updates<a hidden class="anchor" aria-hidden="true" href="#softwareupdates">#</a></h2>
<p><code>software-properties-gtk</code> or <code>software-properties-kde</code></p>
<ul>
<li>
<p>Ubuntu Software 栏 Download from 选择 <a href="https://mirrors.ustc.edu.cn/">USTC MIRRORS</a>。</p>
</li>
<li>
<p>Other Software 栏下开启 Canonical Partner Repositories (The partner repositories offer access to proprietary and closed-source software)。</p>
</li>
<li>
<p>Ubuntu 自动下载并安装对你的系统至关重要的安全更新。而这个自动更新经常导致你<a href="https://itsfoss.com/could-not-get-lock-error/">“无法锁定管理目录”</a>错误。在 Updates 栏下选择</p>
<ul>
<li>For other packages, subscribe to: All updates</li>
<li>Automatically check for updates: Every two weeks</li>
<li>When there are security updates: Download and Install automatically</li>
<li>When there are other updates: Display immediately</li>
<li>Notify me of a new Ubuntu version: For long-term support versions</li>
</ul>
</li>
<li>
<p>更新系统:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt update
$ sudo apt upgrade
$ sudo apt autoremove
</code></pre></div></li>
<li>
<p><a href="https://ubuntu.com/livepatch">Livepatch</a>: 更新内核不需要 Reboot required 了</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ua attach &lt;subscription&gt;
</code></pre></div></li>
</ul>
<p><strong>Ubuntu Software &amp; Update 卡在 cache refresh</strong></p>
<p>通过 <code>apt update</code> 可以看见是 Connecting to security.ubuntu.com Failed，解决办法是更改 /etc/hosts 文件添加其 IP，可通过 <a href="https://www.easycounter.com/">EASYCOUNTER</a> 查找：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">## security.ubuntu.com</span>
91.189.88.142 security.ubuntu.com
91.189.88.152 security.ubuntu.com
91.189.91.38 security.ubuntu.com
91.189.91.39 security.ubuntu.com
<span style="color:#75715e">## archive.canonical.com</span>
91.189.92.150 archive.canonical.com
91.189.92.191 archive.canonical.com
91.189.91.15 archive.canonical.com
<span style="color:#75715e">## downloads.sourceforge.net</span>
216.105.38.13 downloads.sourceforge.net
</code></pre></div><p><strong>ubuntu下如何获取源码包和源码</strong></p>
<ul>
<li>
<p>在 Software &amp; Updates 中选中 Source code，不要 Reload，因为很慢，在命令行中 update。或者在软件源配置文件 /etc/apt/sources.list 中添加 deb-src 项。</p>
</li>
<li>
<p>获取 xxx 源码包的详细信息</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt-cache showsrc xxx
</code></pre></div></li>
<li>
<p>获取源码包，并将源码包解压到同名目录</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt-get source  xxx 
</code></pre></div></li>
</ul>
<p><strong><a href="https://vitux.com/how-to-upgrade-ubuntu-20-04-to-21-04/">Upgrade Ubuntu version</a></strong></p>
<ul>
<li>打开 Software Updater 更新软件</li>
<li>打开 Software &amp; Updates 选择 Updates 栏，在 Notify me of a new Ubuntu Version 中选择 For any new version 。</li>
<li>打开 Software Updater 更新到新 Ubuntu 版本。</li>
<li>使用 <code>lsb_release -a</code> 确认 Ubuntu 版本。</li>
</ul>
<h2 id="input-method-editor">Input Method Editor<a hidden class="anchor" aria-hidden="true" href="#input-method-editor">#</a></h2>
<p>首先在 Language Support 中下载语言包</p>
<h3 id="ibus">IBus<a hidden class="anchor" aria-hidden="true" href="#ibus">#</a></h3>
<p>ubuntu libpinyin 输入法支持云拼音，只需要开启就可以了。</p>
<p><strong><a href="https://forum.ubuntu.com.cn/viewtopic.php?t=252407">搜狗细胞词库</a></strong></p>
<p>到<a href="https://code.google.com/archive/p/hslinuxextra/downloads">hslinuxextra</a>下载<a href="https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/hslinuxextra/sougou-phrases-full.7z">sougou-phrases-full.7z</a>。</p>
<p>经过与ibus开发者协商，ibus-pinyin的词库查找规则做了一些更改，只要在词库目录（就是有一个.db文件的那个目录，一般是<code>/usr/share/ibus-libpinyin/db/</code>目录）把新词库复制过来并改名为local.db就可以使用了，如果感觉词库不好，直接删除掉local.db，就可以让ibus使用原来的词库。</p>
<p>覆盖以后，你把ibus重启一下<code>ibus-daemon -d -x -r</code>，如果你能打出下面的这个词组，说明生效了：</p>
<pre tabindex="0"><code class="language-把" data-lang="把">弗雷德霍姆行列式
</code></pre><p>这个词库，基于ibus原有的android词库文件，另外增加了搜狗的细胞词库。</p>
<h3 id="fcitx-4">Fcitx 4<a hidden class="anchor" aria-hidden="true" href="#fcitx-4">#</a></h3>
<p><a href="https://www.sinocalife.com/ubuntu-20-04-chinese-ime-selection">在Ubuntu Wayland 桌面中使用fictx管理中文输入法</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install fcitx -y
</code></pre></div><p>设置 fcitx：</p>
<ul>
<li>
<p>在 Language Support 中选择 fcitx，全局应用，并恢复 ibus 自定义切换语言快捷键设置。</p>
</li>
<li>
<p>(可选）<strong>wayland</strong>桌面默认不读取/etc/profile中的环境变量，而是从/etc/environment文件中读取，这是导致fcitx不能正常工作的原因。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo vim /etc/environment
INPUT_METHOD<span style="color:#f92672">=</span>fcitx
GTK_IM_MODULE<span style="color:#f92672">=</span>fcitx
QT_IM_MODULE<span style="color:#f92672">=</span>fcitx
XMODIFIERS<span style="color:#f92672">=</span>@im<span style="color:#f92672">=</span>fcitx
</code></pre></div></li>
</ul>
<p>输入法框架：</p>
<ul>
<li><a href="https://pinyin.sogou.com/linux/?r=pinyin">搜狗输入法 for Linux</a></li>
<li><a href="https://srf.baidu.com/site/guanwang_linux/index.html">百度输入法Linux版</a></li>
<li><a href="https://www.ubuntuupdates.org/package/core/focal/universe/base/fcitx-googlepinyin">Google拼音</a></li>
</ul>
<p>其他：</p>
<ul>
<li>百度输入法不能安装用于更换皮肤的 fcitx-ui-qimpanel，否则乱码。需要手动安装 fcitx-libs，否则开机不自动启动。</li>
<li>在 fcitx 与 sogoupinyin 安装完之后，需要重启才能使用。</li>
</ul>
<p>皮肤：</p>
<ul>
<li><a href="https://forum.ubuntu.com.cn/viewtopic.php?t=391755">fcitx 皮肤</a>：/usr/share/fcitx/skin</li>
<li><a href="https://www.cnblogs.com/chilono/p/9203041.html">sogoupinyin 皮肤</a>：/usr/share/sogou-qimpanel/skin。
<ul>
<li><a href="https://pinyin.sogou.com/skins/skin_use.php">旧</a>：可以改名为 zip 解压</li>
<li><a href="https://linux.zone/5616">新</a>：受版权保护</li>
</ul>
</li>
</ul>
<h3 id="fcitx-5httpsfcitx-imorgwikifcitx_5"><a href="https://fcitx-im.org/wiki/Fcitx_5">Fcitx 5</a><a hidden class="anchor" aria-hidden="true" href="#fcitx-5httpsfcitx-imorgwikifcitx_5">#</a></h3>
<p><strong><a href="https://plumz.me/archives/11740/">安装</a></strong></p>
<p>配置工具 KDE 下使用 <code>kde-config-fcitx5</code>， Gnome 下使用 <code>fcitx5-config-qt</code>。</p>
<p>20.04 (20220122) 官方仓库里没有 Gnome 的配置工具 kcm-fcitx5（内含 fcitx5-config-qt），因此通过 <strong><a href="https://launchpad.net/~zhsj/+archive/ubuntu/fcitx5">ppa:zhsj/fcitx5</a></strong> 来安装</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo add-apt-repository ppa:zhsj/fcitx5
$ sudo apt-get update
$ sudo apt install fcitx5 fcitx5-chinese-addons
</code></pre></div><p>或者也可以通过**<a href="https://plumz.me/archives/12285/">通过 flatpak 安装</a>**。</p>
<p>安装后在 Ubuntu 在 Language Support 里修改输入法系统为 fcitx5，记得点击 Apply System-Wide。</p>
<p>安装报如下错</p>
<pre tabindex="0"><code>E: Failed to fetch http://103.95.217.6/ppa.launchpad.net/zhsj/fcitx5/ubuntu/pool/main/f/fcitx5-chinese-addons/fcitx5-module-cloudpinyin_5.0.4-1~ubuntu20.04.1~ppa1_amd64.deb  503  Service Unavailable [IP: 103.95.217.6 80]
E: Aborting install.
</code></pre><p>可以在浏览器中打开链接直接下载。</p>
<p><strong><a href="https://github.com/felixonmars/fcitx5-pinyin-zhwiki">肥猫百万大词库</a></strong></p>
<p>Download latest version of &ldquo;<strong>zhwiki.dict</strong>&rdquo; from <a href="https://github.com/felixonmars/fcitx5-pinyin-zhwiki/releases">https://github.com/felixonmars/fcitx5-pinyin-zhwiki/releases</a></p>
<p>Copy into <code>~/.local/share/fcitx5/pinyin/dictionaries/</code> (create the folder if it does not exist)</p>
<p>可以在设置中看到是否启用，或者输入 “jinjinjin” 会出现 “鑫”。</p>
<h2 id="automatically-switch-wallpapers">Automatically switch wallpapers<a hidden class="anchor" aria-hidden="true" href="#automatically-switch-wallpapers">#</a></h2>
<h3 id="apps">Apps<a hidden class="anchor" aria-hidden="true" href="#apps">#</a></h3>
<ul>
<li>Shotwell：在侧边栏 Photos 中 Ctrl + A，在菜单栏 File 中选择 Set as Desktop SlideShow&hellip;；这会把图片复制到 <code>.local/share/shotwell/wallpaper</code>，并在该目录生成 wallpaper.xml，wallpaper.xml 定义自动切换壁纸动画。</li>
<li>替代软件： Variety、BingWall 等。</li>
<li>脚本分享：<a href="https://github.com/thevinter/styli.sh"> styli.sh</a>、<a href="https://github.com/LittleSimpleWallpaperChanger/lswc">lswc</a></li>
<li>动态壁纸：<a href="https://github.com/cheesecakeufo/komorebi">komorebi</a>、<a href="https://launchpad.net/livewallpaper">LiveWallpaper</a></li>
</ul>
<h3 id="unsplashhttpsyounessnetlinuxset-random-wallpapers-unsplash-com-ubuntu"><a href="https://youness.net/linux/set-random-wallpapers-unsplash-com-ubuntu">unsplash</a><a hidden class="anchor" aria-hidden="true" href="#unsplashhttpsyounessnetlinuxset-random-wallpapers-unsplash-com-ubuntu">#</a></h3>
<ul>
<li>
<p><code>gsettings set org.gnome.desktop.background picture-uri file://$HOME/Wallpaper</code></p>
</li>
<li>
<p>添加脚本</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ vi $HOME/.unsplash.sh
<span style="color:#75715e">#!/bin/bash</span>

SAVE_DIR<span style="color:#f92672">=</span>$HOME/DataOne/Unsplash
FILE_NAME<span style="color:#f92672">=</span>daily<span style="color:#66d9ef">$(</span>date <span style="color:#e6db74">&#39;+%Y%m%d&#39;</span><span style="color:#66d9ef">)</span>.jpeg
wget -O $SAVE_DIR/$FILE_NAME https://source.unsplash.com/1920x1080/daily
cp $SAVE_DIR/$FILE_NAME $HOME/Wallpaper
</code></pre></div><p>在 <a href="https://source.unsplash.com/">Unsplash Source</a> 查看更多 API。</p>
</li>
<li>
<p><code>crontab -e</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#ae81ff">0</span> <span style="color:#ae81ff">12</span> * * * /home/vane/.unsplash.sh
</code></pre></div></li>
<li>
<p>除了使用 crontab 外，还可以使用 Startup Applications Preferences 添加一个启动项。</p>
</li>
</ul>
<h3 id="wallhaven">wallhaven<a hidden class="anchor" aria-hidden="true" href="#wallhaven">#</a></h3>
<ul>
<li>
<p><code>gsettings set org.gnome.desktop.background picture-uri $HOME/Wallpaper</code></p>
<p>一般文件内容开头都会有一个<a href="https://www.zhihu.com/question/28161418">文件类型的标记</a>，根据文件名后缀只是一个快捷的方法，不用读取文件内容就判断文件类型，但不是唯一的方法。</p>
</li>
<li>
<p><code>vi $HOME/.wallhaven/wallhaven.sh</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">#!/bin/bash
</span><span style="color:#75715e"></span>
WORK_DIR<span style="color:#f92672">=</span>$HOME/.wallhaven
SAVE_DIR<span style="color:#f92672">=</span>$HOME/Pictures/wallhaven
IMG_URL<span style="color:#f92672">=</span>https://w.wallhaven.cc/full

<span style="color:#66d9ef">function</span> GetListing<span style="color:#f92672">()</span>
<span style="color:#f92672">{</span>
  echo <span style="color:#e6db74">&#39;get listing&#39;</span>
  listing<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>curl https://wallhaven.cc/api/v1/search?apikey<span style="color:#f92672">=</span>&lt;API KEY&gt;&amp;categories<span style="color:#f92672">=</span>010&amp;purity<span style="color:#f92672">=</span>111&amp;atleast<span style="color:#f92672">=</span>1920x1080&amp;ratios<span style="color:#f92672">=</span>16x9&amp;sorting<span style="color:#f92672">=</span>random&amp;order<span style="color:#f92672">=</span>desc&amp;page<span style="color:#f92672">=</span>1<span style="color:#66d9ef">)</span>
  echo <span style="color:#e6db74">&#39;save listing&#39;</span>
  echo $listing | jq -r <span style="color:#e6db74">&#39;.data[].path&#39;</span> | awk -F <span style="color:#e6db74">&#39;/&#39;</span> <span style="color:#e6db74">&#39;{print $NF}&#39;</span> &gt; $WORK_DIR/listing
  echo <span style="color:#e6db74">&#39;save res&#39;</span>
  cat $WORK_DIR/listing | wc -l &gt; $WORK_DIR/res
  SetWallpaper
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">function</span> SetWallpaper<span style="color:#f92672">()</span>
<span style="color:#f92672">{</span>
  <span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> -a $WORK_DIR/res <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
    echo <span style="color:#e6db74">&#39;read res&#39;</span>
    read res  &lt; $WORK_DIR/res
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> $res -ne <span style="color:#ae81ff">0</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span> 
      echo <span style="color:#e6db74">&#39;get img&#39;</span>
      img<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>cat $WORK_DIR/listing | tail -<span style="color:#e6db74">${</span>res<span style="color:#e6db74">}</span> | head -1<span style="color:#66d9ef">)</span>
      echo <span style="color:#e6db74">&#34;down </span>$img<span style="color:#e6db74"> from </span>$IMG_URL<span style="color:#e6db74">/</span><span style="color:#e6db74">${</span>img:10:2<span style="color:#e6db74">}</span><span style="color:#e6db74">/</span>$img<span style="color:#e6db74">&#34;</span>
      curl -o $SAVE_DIR/$img $IMG_URL/<span style="color:#e6db74">${</span>img:10:2<span style="color:#e6db74">}</span>/$img
      <span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> $? -eq <span style="color:#ae81ff">0</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
        echo <span style="color:#e6db74">&#39;set wallpaper&#39;</span>
        cp $SAVE_DIR/$img $HOME/Wallpaper
        echo <span style="color:#e6db74">&#39;res-1&#39;</span>
        echo <span style="color:#66d9ef">$((</span>$res <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span><span style="color:#66d9ef">))</span> &gt; $WORK_DIR/res
        echo <span style="color:#e6db74">&#39;exit&#39;</span>
        exit <span style="color:#ae81ff">0</span>
      <span style="color:#66d9ef">else</span>
        echo <span style="color:#e6db74">&#39;download error&#39;</span>
        SetWallpaper
      <span style="color:#66d9ef">fi</span>
    <span style="color:#66d9ef">else</span>
      echo <span style="color:#e6db74">&#39;res=0&#39;</span>
      GetListing
    <span style="color:#66d9ef">fi</span>
  <span style="color:#66d9ef">else</span>
    echo <span style="color:#e6db74">&#39;no res&#39;</span>
    GetListing
  <span style="color:#66d9ef">fi</span>
<span style="color:#f92672">}</span>

SetWallpaper
</code></pre></div><p><a href="https://www.tomczhen.com/2017/10/15/parsing-json-with-shell-script/">使用 Shell 脚本来处理 JSON</a>，<a href="https://stedolan.github.io/jq/manual/">jq Manual</a>，<a href="https://wallhaven.cc/help/api">wallhaven API v1 Documentation</a></p>
</li>
<li>
<p><code>crontab -e</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#ae81ff">0</span> <span style="color:#ae81ff">12</span> * * * /home/vane/.wallhaven/wallhaven.sh
</code></pre></div><p><a href="https://stackoverflow.com/questions/10374520/gsettings-with-cron">Gsettings 无法在 Cron 中使用</a>：出现此问题是因为 cron 仅使用一组非常有限的环境变量。 唯一一个负责在将其设置为 cron 作业时以正确方式运行问题脚本的环境变量是 DBUS_SESSION_BUS_ADDRESS。</p>
</li>
</ul>
<h3 id="astronomyhttpsapinasagov"><a href="https://api.nasa.gov/">Astronomy</a><a hidden class="anchor" aria-hidden="true" href="#astronomyhttpsapinasagov">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">#!/bin/bash
</span><span style="color:#75715e"></span>API_KEY<span style="color:#f92672">=</span>zTL5rJmctXwHcsjfCSalfDRNFTeaVYa9FxgINVVU
HTTP_REQUEST<span style="color:#f92672">=</span>https://api.nasa.gov/planetary/apod?api_key<span style="color:#f92672">=</span>$API_KEY
HTTP_RESPONSE<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>curl $HTTP_REQUEST<span style="color:#66d9ef">)</span>
IMG_HDURL<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>echo $HTTP_RESPONSE | jq -r <span style="color:#e6db74">&#39;.hdurl&#39;</span><span style="color:#66d9ef">)</span>
IMG_FILENAME<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>echo <span style="color:#e6db74">${</span>IMG_HDURL##*/<span style="color:#e6db74">}</span><span style="color:#66d9ef">)</span>
curl -o $HOME/DataOne/Images/Astronomy/$IMG_FILENAME $IMG_HDURL
cp -av $HOME/DataOne/Images/Astronomy/$IMG_FILENAME $HOME/Wallpaper
</code></pre></div><h2 id="social">Social<a hidden class="anchor" aria-hidden="true" href="#social">#</a></h2>
<h3 id="telegramhttpswwwnotionsotelegram-95a6c23f0bb1466892b55f9ec8c755fd"><a href="https://www.notion.so/Telegram-95a6c23f0bb1466892b55f9ec8c755fd">Telegram</a><a hidden class="anchor" aria-hidden="true" href="#telegramhttpswwwnotionsotelegram-95a6c23f0bb1466892b55f9ec8c755fd">#</a></h3>
<p>先通过手机登录，再在电脑端登录。电脑先登录，手机老是收不到验证码。</p>
<h4 id="简介">简介<a hidden class="anchor" aria-hidden="true" href="#简介">#</a></h4>
<ul>
<li>
<p>Telegram —— 中文名又称&quot;电报&quot;，或简称&quot;TG&quot;。</p>
</li>
<li>
<p>Telegram 是跨平台的即时通信软件，其客户端是自由及开放源代码软件，但服务器是专有软件。</p>
</li>
<li>
<p>Telegram 在中国大陆境内无法直接连接，注册和使用都需要科学上网，请自备节点和工具。</p>
</li>
<li>
<p>下载：Telegram 有官方版和第三方版本，但出于安全和隐私的考虑，推荐大家使用 Telegram 官方版客户端</p>
</li>
</ul>
<h4 id="推荐设置">推荐设置<a hidden class="anchor" aria-hidden="true" href="#推荐设置">#</a></h4>
<ul>
<li>Privacy and Security
<ul>
<li>Phone Number
<ul>
<li>谁能看见我的手机号码：Nobody</li>
<li>谁能通过手机号码找到我：My Contacts</li>
</ul>
</li>
<li>Forwarded Messages：Nobody</li>
<li>Calls：Nobody</li>
<li>Groups：My Contacts</li>
</ul>
</li>
<li>Local Passcode：本地密码只是本设备打开 Telegram 的应用密码</li>
<li>Two-Step Verification：为了账号安全，强烈推荐您设置两步验证密码。</li>
<li>Delete my account：推荐您设置为一年</li>
</ul>
<h4 id="隐私保护注意事项">隐私保护注意事项<a hidden class="anchor" aria-hidden="true" href="#隐私保护注意事项">#</a></h4>
<ul>
<li>资料设置
<ul>
<li>昵称及用户名：避免使用与其他社交平台相同或相似的昵称及用户名</li>
<li>手机号码：在&quot;设置——隐私——电话号码&quot;中设置&quot;不允许任何人查看我的手机号码&quot;和&quot;仅允许联系人通过手机号码找到我&quot;。</li>
</ul>
</li>
<li>群组聊天：Telegram 的群聊是&quot;不安全&quot;的。  公开群组的所有聊天内容都可被其他人查看，即使他人并未注册 Telegram； 对于群组内的机器人，它们可以收集群组内的绝大部分消息。</li>
<li>媒体文件：在分享照片时，请注意使用专业修图软件打码处理关键信息，并清除照片包含的地理位置信息</li>
<li>分享链接：从其他平台分享内容至 Telegram 时，请注意清除分享链接中的用户 UserID 识别信息，他人完全有可能从您的分享链接中获取您的用户信息。</li>
<li>第三方客户端：如无特殊需要，请使用官方 Telegram 客户端。第三方客户端有能力获取和控制您的账户，读取您全部的聊天记录，收集您设备的可识别信息，包括但不限于：手机号、设备型号、IMEI码、MAC码等。</li>
</ul>
<h4 id="常见问题及解答">常见问题及解答<a hidden class="anchor" aria-hidden="true" href="#常见问题及解答">#</a></h4>
<ul>
<li>无法给他人发送私聊：“Sorry, you can only send messages to mutual contacts at the momet.”
<ul>
<li>@SpamBot</li>
<li>But I can&rsquo;t message non-contacts！</li>
<li>No，I&rsquo;ll never do any of this</li>
</ul>
</li>
<li>群组和频道有什么类型？有什么特点？
<ul>
<li>群组(Group)或者频道(Channel)有两种类型。
<ul>
<li>一种是公开群组(Public Group/Channel)</li>
<li>一种是私有群组(Private Group/Channel)</li>
</ul>
</li>
<li>公开群组(Public Group/Channel) 有自定义设置的ID，所有人可以通过搜索功能，输入id查询到相应的群组。公开群组的历史消息对所有人可见，即使没加入公开群组，也可以查看群组历史消息。</li>
<li>私有群组(Private Group/Channel) 没有自定义的ID，要加入只能通过点击邀请链接或者被邀请入群，
在私有群组，群主可以设定历史消息的可见性。而对于没有加入群组的人，则不可以查看群组的消息。</li>
</ul>
</li>
<li>Telegram 用户名是什么？
<ul>
<li>其他用户可以通过用户名找到您，您将出现在“全局结果”下的联系人搜索中。这样人们就可以在不知道您的电话号码的情况下通过 Telegram 与您联系。</li>
<li>由于用户名的唯一性，可以防止他人盗用你的头像和昵称冒充你。</li>
</ul>
</li>
<li>如何添加联系人？：添加和删除联系人都是单向操作，对方设备并不会同步。</li>
<li>添加非手机号码联系人后，对方能知道自己的手机号码吗？：如果想取消分享你的手机号，请到隐私设置(Privacy and Security)中找到手机号码(Phone Number)的设置，在里面移除对方即可。</li>
<li>不登陆 Telegram 如何查看频道消息？：Telegram 公开频道可以直接通过浏览器输入 <code>https://t.me/s/频道id</code> 访问，不需要拥有TG账号。</li>
</ul>
<h4 id="进阶知识">进阶知识<a hidden class="anchor" aria-hidden="true" href="#进阶知识">#</a></h4>
<p>什么是 MTProxy 代理？</p>
<ul>
<li><a href="https://github.com/TelegramMessenger/MTProxy">MTProxy</a> 是 Telegram 的官方项目，仅能用于代理 Telegram 软件</li>
<li>MTP 代理是在 Telegram 中内置的代理程序，可以直接在软件内配置，而不需要下载任何其他 App 来配置代理</li>
</ul>
<h4 id="主题与美化">主题与美化<a hidden class="anchor" aria-hidden="true" href="#主题与美化">#</a></h4>
<p>美化主题频道</p>
<ul>
<li>官方 Desktop 桌面版主题频道 @themes</li>
<li>官方 Android 安卓主题频道 @Androidthemes</li>
</ul>
<h4 id="sticker-packhttpsblogphoenixlzxcom20150606make-telegram-sticker-the-lazy-way"><a href="https://blog.phoenixlzx.com/2015/06/06/make-telegram-sticker-the-lazy-way/">Sticker Pack</a><a hidden class="anchor" aria-hidden="true" href="#sticker-packhttpsblogphoenixlzxcom20150606make-telegram-sticker-the-lazy-way">#</a></h4>
<p>用现成的图片集来制作 stickers pack。Linux 可以方便地使用 ImageMagick 来操作。</p>
<p>Telegram 要求 Sticker 图片为 PNG 格式，并且要有透明层，至少一边为 512 像素，另一边则不超过 512 像素。最大文件大小为 350KB。透明层就算了，我不会玩 PS。那么直接偷懒(死)来批量把当前目录下 JPG 和 PNG 混杂的图片们统一转换为 PNG 好了。</p>
<p>几条命令发给 <a href="https://telegram.me/stickers">stickers bot</a>：</p>
<ol>
<li><code>/newstickerpack</code></li>
<li>发送表情包的名字…</li>
<li>在内置的 emoji 中发送一个最符合你要发送图片的表情…</li>
<li>然后把对应的图片<strong>作为文件</strong>发送</li>
<li>如果还有其他图片的话重复 3-4</li>
<li>全部表情图片设置完毕，发送 <code>/publish</code> 命令</li>
<li>为你的 stickers pack 取一个短名字 (用于 URL)</li>
</ol>
<h4 id="在telegram上使用efb同时推送qq与微信消息httpswwwshawnleettttxyzpostsf1bc687a"><a href="https://www.shawnleetttt.xyz/posts/f1bc687a/">在Telegram上使用EFB同时推送QQ与微信消息</a><a hidden class="anchor" aria-hidden="true" href="#在telegram上使用efb同时推送qq与微信消息httpswwwshawnleettttxyzpostsf1bc687a">#</a></h4>
<p>众所周知,待机耗电两巨头皆出自TX,但其对于工作人群和大学生而言又是不可或缺的通讯手段.Telegram作为一款合格的IM支持Android众多特性(TX出来挨打),通知栏回复、消息再提醒、自定义震动以及最关键的FCM推送(FCM的特性和优势可以在Google上查询).使用插件利用Telegram来完成QQ微信的消息代收是目前Android系统较优秀的解决方案</p>
<h5 id="事前准备">事前准备<a hidden class="anchor" aria-hidden="true" href="#事前准备">#</a></h5>
<p><strong>物品准备</strong></p>
<ul>
<li>墙外VPS一枚</li>
<li>Telegram账号一枚</li>
<li>稳定的飞机</li>
<li>Xshell(注意不要下载成<strong>苏杰马克丁</strong>版)/PUTTY</li>
<li>可联网设备一枚,推荐电脑</li>
<li>基本的Linux和vim知识</li>
</ul>
<p>本教程基于EFB v2.0.0, efb-qq-slave v2.0.0b2, efb-wechat-slave v2.0.0制作,方案为MASTER SLAVE处于同一系统且QQ微信各使用一个 Bot ,使用 Debian 10</p>
<p><strong>获取 Telegram ID</strong></p>
<p>向 <strong>@get_id_bot</strong> 发起会话,击 <strong>/start</strong> 即可获得你的 Telegram ID</p>
<h5 id="使用efb转发微信消息">使用EFB转发微信消息<a hidden class="anchor" aria-hidden="true" href="#使用efb转发微信消息">#</a></h5>
<p><strong>申请 Telegram Bot</strong></p>
<p>向 <strong>@BotFather</strong> 发起会话，发送命令 <code>/newbot</code> 以创建Bot（用户名须以Bot为结尾）</p>
<p>设置好后还须对bot进行权限设置</p>
<p>发送 <code>/setprivacy</code> 到 @BotFather，选择刚刚创建好的 Bot 用户名，然后选择 “Disable”.</p>
<p>发送 <code>/setjoingroups</code> 到 @BotFather，选择刚刚创建好的 Bot 用户名，然后选择 “Enable”.</p>
<p>发送 <code>/setcommands</code> 到 @BotFather，选择刚刚创建好的 Bot 用户名，然后发送如下内容：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">help - 显示命令列表.
link - 将聊天链接到群组.
unlink_all - 取消所有聊天与群组的链接.
info - 显示当前Telegram聊天的信息.
chat - 生成聊天对话框.
update_info - 更新组名称和资料图片.
</code></pre><p><strong>安装 EFB 及其从端</strong></p>
<p>安装相关依赖:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ apt install python3 python3-pip python3-pil python3-setuptools python3-numpy python3-yaml python3-requests ffmpeg libmagic-dev libwebp-dev vim -y
</code></pre></div><p>安装 EFB :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ pip3 install ehforwarderbot efb-telegram-master efb-wechat-slave
</code></pre></div><p><strong>创建配置文件</strong></p>
<p>创建 EFB 配置文件:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ mkdir -p ~/.ehforwarderbot/profiles/wx/
$ vim ~/.ehforwarderbot/profiles/wx/config.yaml
master_channel: blueset.telegram
slave_channels:
- blueset.wechat
</code></pre></div><p>创建 ETM 配置文件:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ mkdir -p ~/.ehforwarderbot/profiles/wx/blueset.telegram
$ vim ~/.ehforwarderbot/profiles/wx/blueset.telegram/config.yaml 
token: <span style="color:#e6db74">&#34;123456&#34;</span> <span style="color:#75715e">#值为你在 @BotFather 处获得的 bot token</span>
admins:
- <span style="color:#ae81ff">123456</span> <span style="color:#75715e">#值为你在 @get_id_bot 处获得的 chat id</span>
</code></pre></div><p>创建 EWS 配置文件:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ mkdir -p ~/.ehforwarderbot/profiles/wx/blueset.wechat
$ vim ~/.ehforwarderbot/profiles/wx/blueset.wechat/config.yaml
</code></pre></div><p>其内容参见<a href="https://github.com/blueset/efb-wechat-slave#%E5%8F%AF%E9%80%89%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">可选的配置文件</a>，根据文档配置即可。</p>
<p>输入<code>ehforwarderbot --profile wx</code>,扫码登录即可收发消息,使用<code>screen</code>命令保存后台</p>
<h5 id="使用efb转发qq消息">使用EFB转发QQ消息<a hidden class="anchor" aria-hidden="true" href="#使用efb转发qq消息">#</a></h5>
<p><strong>申请 Telegram Bot</strong></p>
<p>向 <strong>@BotFather</strong> 发起会话，发送命令 <code>/newbot</code> 以创建Bot（用户名须以Bot为结尾）</p>
<p>设置好后还须对bot进行权限设置</p>
<p>发送 <code>/setprivacy</code> 到 @BotFather，选择刚刚创建好的 Bot 用户名，然后选择 “Disable”.</p>
<p>发送 <code>/setjoingroups</code> 到 @BotFather，选择刚刚创建好的 Bot 用户名，然后选择 “Enable”.</p>
<p>发送 <code>/setcommands</code> 到 @BotFather，选择刚刚创建好的 Bot 用户名，然后发送如下内容：</p>
<pre tabindex="0"><code class="language-none" data-lang="none">link - 将会话绑定到 Telegram 群组.
chat - 生成会话头.
recog - 回复语音消息以进行识别.
extra - 获取更多功能.
</code></pre><p><strong>安装 EFB 及其从端</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ apt-get install libopus0 ffmpeg libmagic1 python3-pip git nano docker.io libssl-dev python3-dev build-essential <span style="color:#75715e">#安装相关依赖</span>
$ pip3 install efb-telegram-master   <span style="color:#75715e">#安装 EFB</span>
$ pip3 install -U git+https://github.com/milkice233/efb-qq-slave
$ pip3 install git+https://github.com/milkice233/efb-qq-plugin-iot
</code></pre></div><p><strong>创建配置文件</strong></p>
<p>创建 EFB 配置文件:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ mkdir -p ~/.ehforwarderbot/profiles/qq/
$ vim ~/.ehforwarderbot/profiles/qq/config.yaml
master_channel: blueset.telegram
slave_channels:
- milkice.qq
</code></pre></div><p>创建 ETM 配置文件:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ mkdir -p ~/.ehforwarderbot/profiles/qq/blueset.telegram
$ vim ~/.ehforwarderbot/profiles/qq/blueset.telegram/config.yaml
token: <span style="color:#e6db74">&#34;123456&#34;</span> <span style="color:#75715e">#值为你在 @BotFather 处获得的 bot token</span>
admins:
- <span style="color:#ae81ff">123456</span> <span style="color:#75715e">#值为你在 @get_id_bot 处获得的 chat id</span>
</code></pre></div><p>IOT 部分:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ wget https://github.com/opq-osc/OPQ/releases/download/v6.0.20/OPQBot_6.0.20_darwin_amd64.tar.gz  <span style="color:#75715e">#根据需要版本自行更改链</span>
</code></pre></div><p>启动需要到<a href="https://developer.gitter.im/apps">Gitter</a>获取token并填入<code>CoreConf.conf</code>文件</p>
<p>如果需要更改API的端口请更改Port (例如更改成2333端口,就改成Port = “0.0.0.0:2333”)</p>
<p>进入到文件目录 执行命令</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">screen -S iot
./OPQBot  <span style="color:#75715e">#输入完毕后 Ctrl+A+D </span>
</code></pre></div><p>登录请 等待控制台输出<code>Everything is ok!</code>后 再用浏览器访问 http://IP:PORT/v1/Login/GetQRcode
(IP为你机子的内网ip或者公网ip,PORT为你上一步更改的端口,默认8888</p>
<p>然后用手机扫码登录,不支持帐号密码登陆</p>
<p>创建 EQS 配置文件</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ mkdir -p ~/.ehforwarderbot/profiles/qq/milkice.qq
$ vim ~/.ehforwarderbot/profiles/qq/milkice.qq/config.yaml
Client: iot
iot:
  qq: <span style="color:#ae81ff">1234567890</span>              <span style="color:#75715e"># 此处填写登录的QQ号</span>
  host: <span style="color:#e6db74">&#34;http://127.0.0.1&#34;</span>    <span style="color:#75715e"># 默认IP为本地</span>
  port: <span style="color:#ae81ff">8888</span>                  <span style="color:#75715e"># 默认端口为 8888</span>
  receive_self_msg: False     <span style="color:#75715e"># 不接收自己发出的消息</span>
</code></pre></div><p>输入<code>ehforwarderbot --profile qq</code> 即可,同样可以使用<code>screen</code>命令保存后台</p>
<h5 id="问题发现及解决方案">问题发现及解决方案<a hidden class="anchor" aria-hidden="true" href="#问题发现及解决方案">#</a></h5>
<ul>
<li>
<p>提示错误: <code>efb-wechat-slave 2.0.0 has requirement requests&gt;=2.22.0, but you'll have requests 2.21.0 which is incompatible.</code></p>
<p>输入 <code>pip3 install requests==2.22.0</code> 解决</p>
</li>
<li>
<p>升级相关组件输入 <code>pip3 install --upgrade efb-qq-slave efb-wechat-slave efb-telegram-master</code></p>
</li>
</ul>
<h5 id="参考链接">参考链接<a hidden class="anchor" aria-hidden="true" href="#参考链接">#</a></h5>
<p><a href="https://milkice.me/2018/09/17/efb-how-to-send-and-receive-messages-from-qq-on-telegram/">安装并使用 EFB：在 Telegram 收发 QQ 消息 - Milkice’s IceBox</a></p>
<p><a href="https://test482.github.io/install-efb-v2-on-VPS/">在 Telegram 上实现微信收发，EHForwarderBot 搭建记录 - Eliot’s Blog</a></p>
<p><a href="https://github.com/blueset/efb-wechat-slave#efb-wechat-slave-channelefb-%E5%BE%AE%E4%BF%A1%E4%BB%8E%E7%AB%AF-ews">EFB WeChat Slave Channel：EFB 微信从端 (EWS) - blueset</a><a href="https://linux.cn/article-12826-1.html">https://linux.cn/article-12826-1.html</a></p>
<h3 id="mutthttpssegmentfaultcoma1190000018131615"><a href="https://segmentfault.com/a/1190000018131615">Mutt</a><a hidden class="anchor" aria-hidden="true" href="#mutthttpssegmentfaultcoma1190000018131615">#</a></h3>
<p><a href="https://wiki.archlinux.org/title/Mutt">Mutt</a> 是一个基于文本的邮件客户端，因其强大的功能而闻名。 Mutt虽然已诞生二十多年了，但仍然是大量用户的首选邮件客户端。</p>
<p>Mutt主要侧重于作为邮件用户代理（MUA），最初是为了查看邮件而编写的。 与其他邮件应用程序相比，稍后实现的功能（检索，发送和过滤邮件）比较简单，因此用户可能希望使用外部应用程序来扩展Mutt的功能。</p>
<h4 id="模块搭配方案">模块搭配方案<a hidden class="anchor" aria-hidden="true" href="#模块搭配方案">#</a></h4>
<p>就像穿衣搭配一样，收件发件过滤邮件转发邮件各种功能都有很多种程序可以用，mutt怎么搭配呢？</p>
<p>常用选项有这些(User/Transport/Delivery)：</p>
<ul>
<li>MUA 收件：<code>fetchmail</code>或<code>getmail</code>或<code>OfflineIMAP</code></li>
<li>MTA 发件：<code>sendmail</code>或<code>msmtp</code>或<code>postfix</code>。其中<code>msmtp</code>兼容强，<code>postfix</code>对国内不友好</li>
<li>MDA 分类: <code>procmail</code>或<code>maildrop</code></li>
<li>邮件编辑：VIM。</li>
</ul>
<p>一般搭配是：</p>
<ul>
<li>老式搭配：mutt + getmail + sendmail + procmail</li>
<li>新式搭配：mutt + fetchmail + msmtp + maildrop</li>
</ul>
<p>这里我们用：<code>mutt + fetchmail + msmtp + procmail</code></p>
<p>安装：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install mutt fetchmail msmtp procmail -y
</code></pre></div><p>Mutt或各个写协作程序在配置前都是不能使用的，学习曲线还是比较陡峭的，所以要做好准备去花好一段去了解和学习各个部件。</p>
<p>大概的配置流程是：</p>
<ul>
<li>配置收件：<code>~/.fetchmailrc</code></li>
<li>配置过滤：<code>~/.procmailrc</code></li>
<li>配置发件：<code>~/.msmtprc</code></li>
<li>配置mutt框架本身：<code>~/.muttrc</code></li>
</ul>
<p>注意：初学过程中，不要一上来就配置mutt。最好是先从各个部件开始：<code>收件-&gt;过滤邮件-&gt;阅读邮件-&gt;发件-&gt;mutt界面</code>，按照这种顺序。</p>
<h4 id="收件配置fetchmailhttpswwwlinodecomdocsguidesusing-fetchmail-to-retrieve-email"><a href="https://www.linode.com/docs/guides/using-fetchmail-to-retrieve-email/">收件：配置Fetchmail</a><a hidden class="anchor" aria-hidden="true" href="#收件配置fetchmailhttpswwwlinodecomdocsguidesusing-fetchmail-to-retrieve-email">#</a></h4>
<blockquote>
<p>Fetchmail是由著名的《大教堂与集市》作者 Eric Steven Raymond 编写的。</p>
</blockquote>
<p>Fetchmail是一个非常简单的收件程序，而且是<code>前台运行</code>、<code>一次性运行</code>的，意思是：你每次手动执行<code>fetchmail</code>命令，都是在前台一次收取完，程序就自动退出了，不是像一般邮件客户端一直在后台运行。</p>
<p>注意：fetchmail只负责收件，而不负责存储！所以它是要调用另一个程序如<code>procmail</code>来进行存储的。</p>
<p>fetchmail的配置文件为<code>~/.fetchmailrc</code>。然后文件权限最少要设置<code>chmod 600 ~/.fetchmailrc</code></p>
<p>比如我们要设置多个邮箱账户同时收取，那么配置如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">poll pop.AAA.com protocol POP3 user <span style="color:#e6db74">&#34;me@AAA.com&#34;</span> password <span style="color:#e6db74">&#34;123&#34;</span>

poll pop.BBB.com protocol POP3 user <span style="color:#e6db74">&#34;me&#34;</span> there with password <span style="color:#e6db74">&#34;123&#34;</span> is falko here fetchall

poll pop.CCC.com protocol POP3 user <span style="color:#e6db74">&#34;me&#34;</span> there with password <span style="color:#e6db74">&#34;123&#34;</span> is till here keep

poll pop.DDD.com
  protocol POP3
  user <span style="color:#e6db74">&#34;me&#34;</span>
  password <span style="color:#e6db74">&#34;123&#34;</span>
  
<span style="color:#75715e">## QQ 邮箱</span>
poll pop.qq.com
  port <span style="color:#ae81ff">995</span>
  protocol POP3
  user <span style="color:#e6db74">&#34;1664548605@qq.com&#34;</span>
  password <span style="color:#f92672">[</span>授权码<span style="color:#f92672">]</span>
  ssl
  keep
  
<span style="color:#75715e"># 全局选项</span>
mimedecode
<span style="color:#75715e"># 不加 -d %T 就会报 ~/Mail/inbox is not a mailbox. 错误</span>
mda <span style="color:#e6db74">&#34;/usr/bin/procmail -d %T&#34;</span>
</code></pre></div><p>其中：</p>
<ul>
<li>各种参数可以不按顺序，也可以不在一行。 <code>空格</code>隔开每个参数，<code>poll</code>隔开每个账户。</li>
<li><code>here</code>, <code>there</code>, <code>with</code>, <code>is</code>等等，都不是关键词，随便写不影响参数。</li>
<li>以下是必填
<ul>
<li><code>poll</code>后面是邮件服务器的地址，一般是<code>pop.xxx.com</code></li>
<li><code>protocol</code>后面是收件协议，一般是<code>pop</code>或<code>pop3</code></li>
<li><code>user</code>后面是用户名，可以是username，也可以是邮箱地址</li>
<li><code>password</code>后面是密码</li>
</ul>
</li>
<li><a href="https://zhuanlan.zhihu.com/p/376290375"><code>sslproto</code></a>：可能会报错 <code>fetchmail: pop.qq.com: upgrade to TLS failed.</code>，故可以禁掉SSL，同 man 手册查到
<ul>
<li>加上option <code>--nosslcertck</code>，虽然有报错，但至少可以收邮件了。</li>
<li>加<code>--sslprotocl ''</code>, 注意要用空字符串</li>
</ul>
</li>
<li>四选一：
<ul>
<li><code>nofetchall</code> ：仅检索新消息（默认）。</li>
<li><code>fetchall</code> ：获取所有消息，无论是否看到。</li>
<li><code>keep</code> ：不要从服务器上删除看到的消息。</li>
<li><code>nokeep</code> ：从服务器中删除看到的消息。</li>
</ul>
</li>
<li><code>mimedecode</code>用来自动解码MIME</li>
<li><code>mda</code>后面指定本机安装的邮件过滤分类程序。如果不填，则收取的邮件在本地不会保存。注意用<code>which procmail</code>查一下路径。</li>
<li><a href="https://service.mail.qq.com/cgi-bin/help?id=28">QQ 邮箱客户端设置</a></li>
<li><a href="https://support.microsoft.com/en-us/office/pop-imap-and-smtp-settings-for-outlook-com-d088b986-291d-42b8-9564-9c414e2aa040?ui=en-us&amp;rs=en-us&amp;ad=us#:~:text=If%20you%20want%20to%20add%20your%20Outlook.com%20account%2c587%209%20SMTP%20encryption%20method%20STARTTLS%20See%20More">Outlook 设置</a>：失败了</li>
</ul>
<p>配置完成后，可以运行<code>fetcmail -v</code>来看看是否有错误信息，如果能够正常显示很多行的收取信息，那么就能正确登录邮箱收取了。</p>
<p>一般收取的命令如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 只收取未读邮件</span>
$ fetchmai

<span style="color:#75715e"># 收取所有邮件</span>
$ fetchmail -a

<span style="color:#75715e"># （重要）收取新邮件，但不在服务器端删除已经收取的邮件</span>
$ fetchmail -k
</code></pre></div><p>但是fetchmail只负责收取，不负责“下载”部分，你找不到邮件存在哪了。
所以还需要配置MDA分类器，如<code>procmail</code>，才能看到下载后的邮件。</p>
<p>注意：Fetch其实不是在Mutt“里”使用的，而是脱离mutt之外的！也就是说，Mutt只负责读取本地存储邮件的文件夹更新，而不会自动帮你去执行<code>fetchmail</code>命令。</p>
<p>你必须自己手动执行，或者用Crontab定期收取，或者设为Daemon守护进程，还可以在Mutt中设置快捷键执行Shell命令：</p>
<ul>
<li>
<p><a href="https://www.howtoing.com/debian_etch_fetchmail/">要使fetchmail作为守护进程运行</a>，我们必须编辑<code>/etc/default/fetchmail</code>并将START_DAEMON设置为yes</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ vi /etc/default/fetchmail
START_DAEMON<span style="color:#f92672">=</span>yes
</code></pre></div><p>接下来，必须创建配置文件<code>/etc/fetchmailrc</code>并设置 <code>set daemon 300</code> （这意味着fetchmail应该每300秒检索一次电子邮件）。</p>
</li>
<li>
<p>设置Mutt快捷键收取邮件的方法是在<code>~/.muttrc</code>中加入macro：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-crystal" data-lang="crystal"><span style="color:#66d9ef">macro</span> <span style="color:#a6e22e">index</span>,pager I <span style="color:#960050;background-color:#1e0010">&#39;</span><span style="color:#f92672">&lt;</span>shell<span style="color:#f92672">-</span>escape<span style="color:#f92672">&gt;</span> fetchmail <span style="color:#f92672">-</span>vk<span style="color:#f92672">&lt;</span>enter<span style="color:#f92672">&gt;</span><span style="color:#960050;background-color:#1e0010">&#39;</span>
</code></pre></div><p>这样的话，你就可以在index邮件列表中按<code>I</code>执行外部shell命令收取邮件了。</p>
</li>
</ul>
<h4 id="邮件过滤配置procmailhttpslifegoopluskidorgwikiprocmailhtml"><a href="https://lifegoo.pluskid.org/wiki/Procmail.html">邮件过滤：配置Procmail</a><a hidden class="anchor" aria-hidden="true" href="#邮件过滤配置procmailhttpslifegoopluskidorgwikiprocmailhtml">#</a></h4>
<p>Procmail是单纯负责邮件的存储、过滤和分类的，一般配合<code>fetchmail</code>收件使用。</p>
<p>在Pipline中，fetchmail把收到的邮件全部传送到Procmail进行过滤筛选处理，然后Procmail就会把邮件存到本地形成文件，然后给邮件分类为工作、生活、重要、垃圾等。</p>
<p>当然，分类规则是自己可以指定的。可以根据发信人、主题、长度以及关键字 等对邮件进行排序、分类、整理。</p>
<p>Procmail 的配置文件是 <code>~/.procmailrc</code> ，记得改权限：<code>chmod 600 ~/.procmailrc</code>。</p>
<p>内容也非常简单，前面是邮件位置、日志等默认选项，后面则是一块一块的过滤规则。</p>
<p>基本配置：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 邮件存储地址</span>
MAILDIR<span style="color:#f92672">=</span>$HOME/Mail   
<span style="color:#75715e"># 默认：收件箱</span>
DEFAULT<span style="color:#f92672">=</span>$MAILDIR/inbox   
VERBOSE<span style="color:#f92672">=</span>off
LOGFILE<span style="color:#f92672">=</span>/tmp/procmaillog

<span style="color:#75715e"># 某个垃圾邮件规则</span>
:0
* ^From: webmaster@st<span style="color:#ae81ff">\.</span>zju<span style="color:#ae81ff">\.</span>edu<span style="color:#ae81ff">\.</span>cn
<span style="color:#75715e"># 垃圾文件的存储位置</span>
/dev/null    

<span style="color:#75715e"># 其它所有都存到收件箱中</span>
:0:
inbox/
</code></pre></div><p>其中，<code>$HOME/Mail</code>是设定的邮件存储位置。</p>
<p>我们需要手动创建<code>mkdir ~/Mail</code>，否则程序会报错。</p>
<p>配置好后，我们再测试一下就会看到：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ fetchmail -a
<span style="color:#ae81ff">78</span> messages <span style="color:#66d9ef">for</span> 1664548605@qq.com at pop.qq.com <span style="color:#f92672">(</span><span style="color:#ae81ff">2843793</span> octets<span style="color:#f92672">)</span>.
reading message 1664548605@qq.com@pop.qq.com:1 of <span style="color:#ae81ff">78</span> <span style="color:#f92672">(</span><span style="color:#ae81ff">36692</span> octets<span style="color:#f92672">)</span> not flushed
...

$ tree ~/Mail
/home/vane/Mail
└── inbox

<span style="color:#ae81ff">0</span> directories, <span style="color:#ae81ff">1</span> file

$ du -h Mail/inbox 
2.1M	Mail/inbox
</code></pre></div><p>可以看到，所有邮件都保存在了inbox这个单一文件中。这个文件可以打开看到MIME格式(协议)的邮件源码。就像HTML一样，展示给我们的和背后的源码不一样。</p>
<p>那么怎么把这个类似HTML的MIME格式邮件解析为我们人能读懂的内容呢？——这个我们就要靠<code>mutt</code>自己了，mutt自身具备基本的MIME邮件解析功能（不包括HTML格式邮件读取）。</p>
<h4 id="发件配置msmtp">发件：配置msmtp<a hidden class="anchor" aria-hidden="true" href="#发件配置msmtp">#</a></h4>
<p><code>msmtp</code>是作为<code>sendmail</code>发邮件程序更好的替代品。</p>
<p>msmtp的配置文件为<code>~/.msmtprc</code>，记得改权限：<code>chmod 600 ~/.msmtprc</code></p>
<p>配置内容比收件还简单，因为发件永远比收件简单。</p>
<p>基本配置：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">account default
  auth login
  host smtp.XXX.com
  port <span style="color:#ae81ff">587</span>
  from ME@XXX.com
  user ME
  password passwd
  <span style="color:#75715e"># 关于tls，如果是阿里云则不用写，如果是Outlook的话，必须写</span>
  tls on
  tls_starttls off
  tls_certcheck off

<span style="color:#75715e"># QQ 邮箱例子</span>
account default
  <span style="color:#75715e"># QQ邮箱这里必须是 on，否则会 535 Login Fail</span>
  auth on
  host smtp.qq.com
  port <span style="color:#ae81ff">587</span>
  from 1664548605@qq.com
  <span style="color:#75715e"># user 必须是 @ 之前的部分，不能自定义，否则会 535 Login Fail</span>
  user <span style="color:#ae81ff">1664548605</span>
  password <span style="color:#f92672">[</span>授权码<span style="color:#f92672">]</span>
  tls on
  tls_starttls off
  tls_certcheck off

logfile /tmp/msmtp.log
</code></pre></div><p>QQ 邮箱例子：<a href="https://www.cnblogs.com/IvanChen/p/5987928.html">使用mutt+msmtp在Linux命令行界面下发邮件</a>。</p>
<p>总之，哪怕QQ 邮箱设置对了，也要多试几次才能发送成功。</p>
<h4 id="主界面配置mutt">主界面：配置Mutt<a hidden class="anchor" aria-hidden="true" href="#主界面配置mutt">#</a></h4>
<p>Mutt的配置文件为<code>~/.muttrc</code>，记得改权限：<code>chmod 600 ~/.muttrc</code></p>
<p>另外：mutt的配置文件还可以放在<code>~/.mutt/muttrc</code>。这种方法有一个好处，即<code>~/.mutt/</code>目录下可以放很多主题、插件等文件。</p>
<p>基本配置：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 通用设定</span>
set use_from<span style="color:#f92672">=</span>yes
set envelope_from<span style="color:#f92672">=</span>yes
<span style="color:#75715e">#移动已读邮件</span>
set move<span style="color:#f92672">=</span>yes    
<span style="color:#75715e">#回复的时候调用原文</span>
set include 
set charset<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;utf-8&#34;</span>
<span style="color:#75715e">#自动显示HTML</span>
auto_view text/html   

<span style="color:#75715e"># 发送者账号</span>
set realname<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Vane Hsiung&#34;</span>
set from<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;1664548605@qq.com&#34;</span>

<span style="color:#75715e"># 分类邮箱</span>
<span style="color:#75715e">#Mail box type</span>
set mbox_type <span style="color:#f92672">=</span> Maildir 
set folder <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span>$HOME<span style="color:#e6db74">/Mail&#34;</span>
<span style="color:#75715e">#INBOX</span>
set spoolfile <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span>$HOME<span style="color:#e6db74">/Mail/inbox&#34;</span> 
<span style="color:#75715e">#Seen box</span>
set mbox<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$HOME<span style="color:#e6db74">/Mail/seen&#34;</span> 
<span style="color:#75715e">#Sent box</span>
set record<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$HOME<span style="color:#e6db74">/Mail/sent&#34;</span>  
<span style="color:#75715e">#Draft box</span>
set postponed<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$HOME<span style="color:#e6db74">/Mail/draft&#34;</span>  

<span style="color:#75715e"># 关联程序（需要自己用which命令确定一下）</span>
<span style="color:#75715e"># 默认使用 nano</span>
set editor<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;vim&#34;</span>
set sendmail<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;/usr/bin/msmtp&#34;</span>
</code></pre></div><p>以上如果有什么问题，可参考<a href="https://gist.github.com/iharsuvorau/45a078ecb597eb916fdf">etchmail + proc + msmtp + mutt configuration samples</a>。</p>
<h4 id="确认邮箱服务器">确认邮箱服务器<a hidden class="anchor" aria-hidden="true" href="#确认邮箱服务器">#</a></h4>
<p>即使上面配置一切OK，也不一定能正常收发邮件。因为你用的Gmail、QQ、网易、阿里云等等，后台都有一系列的第三方收取设置。这是各不相同的。</p>
<p>除了第三方客户端的允许，我们还要设置POP。最好放开全部邮件或者最近30天，然后禁止客户端删信。这是什么意思呢？POP默认客户端在收件后，服务器上的邮件就自动删除了！这个不太合适，所以必须要禁止。</p>
<h4 id="基本操作httpslifehackercomhow-to-use-the-fast-and-powerful-mutt-email-client-with-5574557"><a href="https://lifehacker.com/how-to-use-the-fast-and-powerful-mutt-email-client-with-5574557">基本操作</a><a hidden class="anchor" aria-hidden="true" href="#基本操作httpslifehackercomhow-to-use-the-fast-and-powerful-mutt-email-client-with-5574557">#</a></h4>
<p>邮件列表操作：</p>
<ul>
<li>基本：<code>q</code>:Quit, <code>d</code>:删除当前邮件, <code>s</code>:将邮件移动至指定文件夹, <code>m</code>:创建新邮件, <code>r</code>:回复当前邮件, <code>?</code>:帮助</li>
<li>移动：<code>j/k</code> 上下移动邮件, <code>z/Z</code>上下翻页, <code>&lt;Number&gt;</code> 跳至序号处（不进入邮件）</li>
<li><code>&lt;Enter&gt;</code> 打开选中的邮件</li>
<li><code>/</code>在当前文件夹搜索</li>
<li><code>d</code> 将选中邮件标记为删除, <code>N</code> 将选中邮件标记为未读, <code>$</code> 让标记的东西生效，如删除、未读等。</li>
<li><code>f</code> 转发选中邮件, <code>e</code> 编辑选中邮件</li>
<li><code>c</code>切换文件夹(inbox/seen/draft等), 需要输入文件夹名称，或按<code>?</code>在列表里选择，<code>j/k</code>上下移动。</li>
</ul>
<p>在邮件中的操作：</p>
<ul>
<li><code>j/k</code> 上一封／下一封邮件, <code>&lt;Space&gt;</code>: 向下翻页, <code>&lt;Enter&gt;</code>: 向下滚动</li>
<li><code>e</code> 编辑当前邮件, <code>t</code>编辑TO，<code>c</code>编辑CC，<code>b</code>编辑BCC，<code>y</code>发送邮件，<code>a</code>添加附件，<code>Return</code>查看附件，<code>E</code>编辑附件，<code>D</code>删除附件</li>
</ul>
<p><a href="https://gitlab.com/muttmua/mutt/-/wikis/MuttFaq/Action">使用命令操作</a>：</p>
<p>Mutt如同Vim一样，不光可以把命令绑定为快捷键，还能直接输入<code>:</code>直接输入命令。
但是稍有不同的是，Mutt称之为<code>Action</code>，而且需要用<code>:exec &lt;命令&gt;</code>这样格式执行。</p>
<p>比如sidebar侧边栏的移动，命令是：<code>sidebar-next</code>, <code>sidebar-prev</code>。
那么我们可以直接输入<code>:exec sidebar-next</code>，按下回车执行。</p>
<h3 id="irchttpswwwcnblogscomsztomp11173404html"><a href="https://www.cnblogs.com/sztom/p/11173404.html">IRC</a><a hidden class="anchor" aria-hidden="true" href="#irchttpswwwcnblogscomsztomp11173404html">#</a></h3>
<h4 id="简介httpsenwikipediaorgwikiinternet_relay_chat"><a href="https://en.wikipedia.org/wiki/Internet_Relay_Chat">简介</a><a hidden class="anchor" aria-hidden="true" href="#简介httpsenwikipediaorgwikiinternet_relay_chat">#</a></h4>
<p>芬兰人雅尔可·欧伊卡利宁（Jarkko Oikarinen）于1988年8月创造了IRC来取代一个叫做MUT的程序。</p>
<ul>
<li>IRC（Internet Relay Chat的缩写，“因特网中继聊天”）是一个位于应用层的协议。</li>
<li>其主要用于群体聊天，但同样也可以用于个人对个人的聊天。</li>
<li>一个IRC服务器可以连接其他的IRC服务器以扩展为一个IRC网络。</li>
<li>IRC 不强制注册；但如果你注册了，就可以强制把占用自己唯一 ID 的人踢下线。</li>
<li>IRC 协议简单，开源实现多，其第三方机器人程序非常众多，几乎每种语言都有一个实现。</li>
<li>IRC 是开源社区会议标准；因此，许多开源世界的技术大牛混在那里。</li>
</ul>
<p><a href="https://www.irchelp.org/">irchelp</a>：一个致力于帮助用户了解IRC的网站。</p>
<p><a href="http://tldp.org/HOWTO/IRC/index.html">IRC</a>：Linux文档项目的IRC HOWTO</p>
<h4 id="服务器">服务器<a hidden class="anchor" aria-hidden="true" href="#服务器">#</a></h4>
<p>首先要区分一些概念：</p>
<ul>
<li>Networks：是指的互相隔离的网络，如Freenode和DALnet这些是世界知名的网络，但互相隔离，频道不共享。</li>
<li>Servers：Network网络中的某一台电脑服务器，你加入世界上任何一个server都能加入这个Network。IRC是一个分布式的客户端/服务器结构。通过连接到一个IRC服务器，我们可以访问这个服务器以及它所连接的其他服务器上的频道（即这个 Network 中所有频道）。</li>
</ul>
<p>频道存在于一个IRC服务器上。一个频道类似于一个聊天室，频道名称必须以<code>#</code>符号开始，例如<code>#irchelp</code>。</p>
<p>要使用IRC，必须先登录到一个IRC服务器上，最常见的为<a href="https://freenode.net/">irc.freenode.net</a>——最大的IRC网络，为免费和开源软件社区，非营利组织和相关社区提供讨论设施。</p>
<p>Freenode <a href="https://freenode.net/kb/answer/usermodes">用户模式</a>。</p>
<p>IRC使用的服务器端口有:</p>
<ul>
<li>6667（明文传输，如irc://irc.freenode.net）</li>
<li>6697（SSL加密传输，如ircs://irc.freenode.net:6697）。</li>
</ul>
<p><a href="https://en.wikipedia.org/wiki/IRCd">IRCD</a>: 简称互联网中继聊天守护，是服务器软件实现了IRC 协议，使人们通过上网彼此交谈（交换文本即时消息）。</p>
<h4 id="客户端">客户端<a hidden class="anchor" aria-hidden="true" href="#客户端">#</a></h4>
<p>IRC用户透过客户端软件和服务器相连。</p>
<p><a href="https://en.wikipedia.org/wiki/Comparison_of_Internet_Relay_Chat_clients">Internet Relay Chat客户端的比较</a>：</p>
<table>
<thead>
<tr>
<th>Client</th>
<th>Homepage</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Irssi</td>
<td><a href="https://irssi.org/">https://irssi.org/</a></td>
<td>支持IPv6的模块化文本UI IRC客户端。轻量级流行客户端。</td>
</tr>
<tr>
<td>WeeChat</td>
<td><a href="https://weechat.org/">https://weechat.org/</a></td>
<td>便携式和多接口（文本，Web和GUI）IRC客户端。</td>
</tr>
</tbody>
</table>
<h4 id="irssihttpssegmentfaultcoma1190000018120591"><a href="https://segmentfault.com/a/1190000018120591">Irssi</a><a hidden class="anchor" aria-hidden="true" href="#irssihttpssegmentfaultcoma1190000018120591">#</a></h4>
<p><strong>安装</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ apt install irssi
</code></pre></div><p>命令行输入<code>irssi</code>即进入了聊天室。</p>
<p>和一般Linux程序的一般命令、格式都不同，IRC客户端一般有自己的命令。窗口右下方<code>[(status)]</code>是输入命令的地方。</p>
<p>一般命令(不区分大小写)：</p>
<ul>
<li><code>/quit</code>，退出程序。一般的ctrl-c, ctrl-d, esc, q之类的都不管用</li>
<li><code>/help</code>，帮助</li>
<li><code>/network list</code> 查看已保存的服务器列表</li>
<li><code>/connect xxx.xxx.xxx</code> 连接某服务器。连接 freenode，需要到 <a href="https://irc.com/login/sso">https://irc.com/login/sso</a> 注册，然后按照 <a href="https://freenode.net/kb/answer/sasl">https://freenode.net/kb/answer/sasl</a> 进行设置。</li>
<li><code>/join xxx</code> 加入某channel</li>
<li><code>/leave</code>或<code>/part</code> 离开当前channel</li>
<li><code>/normal</code>或<code>/n</code> 查看当前channel的人数</li>
<li><code>/list -YES</code> 查看当前服务器的所有chennels (慎用)</li>
<li><code>/nick NewNickName</code> 更改当前昵称</li>
<li><code>/msg NickName Content</code> 给某人发送消息，一般都是给<code>/msg nickserv</code>管理人NPC发送消息</li>
</ul>
<p>常用快捷键：</p>
<ul>
<li><code>Alt + 1/2/3/4...</code>，切换window窗口，一般一个channel一个窗口</li>
<li><code>Alt + n/p</code>，上下滚动屏幕</li>
</ul>
<p><a href="http://www.ircbeginner.com/ircinfo/abbreviations.html">IRC 常用缩写词</a></p>
<p><strong>配置</strong></p>
<p>如果想长期保存、备份一个固定的程序配置，那么就需要修改配置文件。</p>
<p><code>irssi</code>默认的配置文件为<code>~/.irssi/config</code>。</p>
<p>配置中，会在第一次运行时就自动设置了一些，包括根据当前电脑账户的用户名设置<code>nickname</code>等。整个配置，是一直“类似”JSON的格式。</p>
<p><code>settings</code> ：记录自己的名字：nick, real_name, user_name</p>
<p><code>servers</code> ：这是指的Network而不是具体某台server，如Freenode、Dal、ESPer、EFnet等大型网络。服务器配置案例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">servers <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>
  <span style="color:#f92672">{</span> address <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;irc.dal.net&#34;</span>; chatnet <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;DALnet&#34;</span>; port <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;6667&#34;</span>; <span style="color:#f92672">}</span>,
  <span style="color:#f92672">{</span>
      address <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;路径&#34;</span>;
      chatnet <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;下面chatnet对应的名称&#34;</span>;
      port <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;端口&#34;</span>;
      autoconnect <span style="color:#f92672">=</span> true;
      use_ssl <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;yes&#34;</span>;
      password <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;用户名:密码&#34;</span>;
  <span style="color:#f92672">}</span>
<span style="color:#f92672">)</span>;
</code></pre></div><p><code>chatnets</code>：记录各个网络的登录信息，也可以作为“别名”，这样每次<code>/connect</code>不用输入全路径了。配置完每个服务器后，还要配置相应的<code>chatnets</code>，每一条的名称都要与<code>servers</code>中的对应。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">chatnets <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
    DALnet <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
        type <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;IRC&#34;</span>;
        max_kicks <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;4&#34;</span>; max_msgs <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;20&#34;</span>;max_whois <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;30&#34;</span>;
    <span style="color:#f92672">}</span>;
    Freenode <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
        type <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;IRC&#34;</span>;
        max_kicks <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;4&#34;</span>; max_msgs <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;20&#34;</span>;max_whois <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;30&#34;</span>;
        autosendcmd <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;/msg nickserv identify MyName MyPassword&#34;</span>;
    <span style="color:#f92672">}</span>;
<span style="color:#f92672">}</span>;
</code></pre></div><p><code>channels</code> ：记录自己收藏的频道名。RC的频道不是用URL之类很复杂的东西，全都是用<code>#tag</code>这种简单一个标签来区分的，非常好记。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">channels <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>
  <span style="color:#f92672">{</span> name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;#lobby&#34;</span>; chatnet <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;EsperNet&#34;</span>; autojoin <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;No&#34;</span>; <span style="color:#f92672">}</span>,
  <span style="color:#f92672">{</span> name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;#freenode&#34;</span>; chatnet <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Freenode&#34;</span>; autojoin <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;No&#34;</span>; <span style="color:#f92672">}</span>,
<span style="color:#f92672">)</span>;
</code></pre></div><p><code>statusbar</code>：界面美化的设置。目前IRSSI的世界里，唯一知名的主题只有<a href="https://github.com/ronilaukkarinen/weed">weed</a>。</p>
<h2 id="multimedia">Multimedia<a hidden class="anchor" aria-hidden="true" href="#multimedia">#</a></h2>
<h3 id="pipewirehttpspipewireorg"><a href="https://pipewire.org/">Pipewire</a><a hidden class="anchor" aria-hidden="true" href="#pipewirehttpspipewireorg">#</a></h3>
<p>从 Pulseaudio 切换到 Pipewire 的理由是对于蓝牙的“LDAC”“APTX”之类编码格式的支持</p>
<h3 id="rhythmbox">Rhythmbox<a hidden class="anchor" aria-hidden="true" href="#rhythmbox">#</a></h3>
<p><strong>Music</strong></p>
<p>搜 &ldquo;无损音乐&rdquo; &ldquo;车载音乐&rdquo; 打包下载。</p>
<p><strong>电台</strong></p>
<p>很多电台是基于mms协议的，如果rhythmbox无法播放mms协议的电台，则需要安装支持mms协议的gstreamer插件——因为rhymbox使用gstreamer做后台解码。支持mms协议的插件为gstreamer bad插件，所以执行命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt-get install gstreamer0.10-plugins-bad
</code></pre></div><p>同样的，如果需要播放mp3文件则安装ugly插件，需要播放wma文件则安装ffmpeg插件。</p>
<p><a href="https://forum.ubuntu.org.cn/viewtopic.php?t=219155">电视台和电台MMS地址</a></p>
<p><a href="https://forum.ubuntu.org.cn/viewtopic.php?t=183787">分享Rhythmbox电台列表</a></p>
<p>最终还是没什么无法播放mms，因为 Rhythmbox 报错了。</p>
<h4 id="feeluownhttpsgithubcomfeeluownfeeluown"><a href="https://github.com/feeluown/FeelUOwn">FeelUOwn</a><a hidden class="anchor" aria-hidden="true" href="#feeluownhttpsgithubcomfeeluownfeeluown">#</a></h4>
<p>FeelUOwn 是一个稳定、用户友好以及高度可定制的音乐播放器。</p>
<h3 id="spotify">Spotify<a hidden class="anchor" aria-hidden="true" href="#spotify">#</a></h3>
<p>作为世界上最大的音乐流媒体服务商，Spotify 因优秀的设计和精准的音乐推荐算法让不少人为之倾心。</p>
<p>在正式注册 Spotify 之前，我们先来看一看曲库的问题。由于不同地区的歌曲版权差异，Spotify 在不同地区提供服务时，其相应的曲库也有所不同。例如港区的曲库中，粤语歌就要比美区多，相反美区的英文歌就要比港区多。同理，若你喜欢听其他语种的歌，注册当地的 Spotify 则是最好的选择。</p>
<p>注册后要是发现当前的地区选择并不是很理想，想要换区也是可行的。首先要挂上自己想要换到地区的代理，然后进入自己的「Profile/资料」界面，点击「Edit Profile/修改资料」，「Country/国家」这个选项就会出现你当前所挂代理地区，保存更改即可换区成功。</p>
<p>登录的话，需要先在登录界面设置Proxy重启。登录后在设置里改回来，不再需要Proxy了。</p>
<h4 id="spotifydhttpsgithubcomspotifydspotifyd"><a href="https://github.com/Spotifyd/spotifyd">Spotifyd</a><a hidden class="anchor" aria-hidden="true" href="#spotifydhttpsgithubcomspotifydspotifyd">#</a></h4>
<p>An open source Spotify client running as a UNIX daemon.</p>
<h3 id="neteasemusichttpsmusic163com"><a href="https://music.163.com/">NeteaseMusic</a><a hidden class="anchor" aria-hidden="true" href="#neteasemusichttpsmusic163com">#</a></h3>
<p>Linux 下官方只发布了 deb 包，flatpak 直接安装</p>
<h4 id="yesplaymusichttpsgithubcomqier222yesplaymusic"><a href="https://github.com/qier222/YesPlayMusic">YesPlayMusic</a><a hidden class="anchor" aria-hidden="true" href="#yesplaymusichttpsgithubcomqier222yesplaymusic">#</a></h4>
<p>高颜值的第三方网易云播放器</p>
<h4 id="netease-musicboxhttpsgithubcomdarknessomimusicbox"><a href="https://github.com/darknessomi/musicbox">NetEase-MusicBox</a><a hidden class="anchor" aria-hidden="true" href="#netease-musicboxhttpsgithubcomdarknessomimusicbox">#</a></h4>
<p>网易云音乐命令行版</p>
<h4 id="lx-music-desktophttpsgithubcomlyswhutlx-music-desktop"><a href="https://github.com/lyswhut/lx-music-desktop">lx-music-desktop</a><a hidden class="anchor" aria-hidden="true" href="#lx-music-desktophttpsgithubcomlyswhutlx-music-desktop">#</a></h4>
<p>一个基于 electron 的音乐软件</p>
<h4 id="listen1_desktophttpsgithubcomlisten1listen1_desktop"><a href="https://github.com/listen1/listen1_desktop">listen1_desktop</a><a hidden class="anchor" aria-hidden="true" href="#listen1_desktophttpsgithubcomlisten1listen1_desktop">#</a></h4>
<p>one for all free music in china</p>
<h4 id="qqmusichttpsyqqcom"><a href="https://y.qq.com/">QQMusic</a><a hidden class="anchor" aria-hidden="true" href="#qqmusichttpsyqqcom">#</a></h4>
<h3 id="pulseaudiohttpswikiarchlinuxorgtitlepulseaudio_e7ae80e4bd93e4b8ade69687"><a href="https://wiki.archlinux.org/title/PulseAudio_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">PulseAudio</a><a hidden class="anchor" aria-hidden="true" href="#pulseaudiohttpswikiarchlinuxorgtitlepulseaudio_e7ae80e4bd93e4b8ade69687">#</a></h3>
<p><a href="https://en.wikipedia.org/wiki/PulseAudio">PulseAudio</a> 是在<a href="https://wiki.archlinux.org/title/GNOME">GNOME</a> 或 <a href="https://wiki.archlinux.org/title/KDE">KDE</a>等桌面环境中广泛使用的音频服务。它在内核音频组件（比如<a href="https://wiki.archlinux.org/title/ALSA">ALSA</a> 和 <a href="https://wiki.archlinux.org/title/OSS">OSS</a>）和应用程序之间充当代理的角色。</p>
<h4 id="配置">配置<a hidden class="anchor" aria-hidden="true" href="#配置">#</a></h4>
<p>Pulseaudio 支持通过多种模块扩展其功能。在这里可以找到PulseAudio可用的模块的详细信息： <a href="https://www.freedesktop.org/wiki/Software/PulseAudio/Documentation/User/Modules/">Pulseaudio Loadable Modules</a>。增加 <code>load-module &lt;module-name-from-list&gt;</code> 到文件 <code>/etc/pulse/default.pa</code>就可以启用对应的模块。</p>
<h4 id="启动">启动<a hidden class="anchor" aria-hidden="true" href="#启动">#</a></h4>
<p><strong>警告：</strong> 如果你给每个用户拷贝了配置文件（例如<code>client.conf</code>, <code>daemon.conf</code> 或者 <code>default.pa</code>）到<code>~/.config/pulse/</code> 或者 <code>~/.pulse/</code>目录下，确定这些文件的修改与<code>/etc/pulse/</code>下的文件修改同步，否则PulseAudio可能由于配置文件错误而拒绝启动。</p>
<p><strong>注意：</strong> 大多数X11环境会在启动X11会话时自动启动PulseAudio。</p>
<p>少数情况下PulseAudio在启动X11时没有自动启动，可运行下面的命令启动：</p>
<pre tabindex="0"><code>$ pulseaudio --start
</code></pre><p>运行下面的命令可以终止PulseAudio：</p>
<pre tabindex="0"><code>$ pulseaudio --kill
</code></pre><h5 id="在不支持的桌面环境中自动启动">在不支持的桌面环境中自动启动<a hidden class="anchor" aria-hidden="true" href="#在不支持的桌面环境中自动启动">#</a></h5>
<p><strong>注意：</strong> 正如之前所说, 如果用户安装了桌面环境，PulseAudio很可能通过 <code>/etc/X11/xinit/xinitrc.d/pulseaudio</code>文件或者 <code>/etc/xdg/autostart/</code>目录下的文件自动启动</p>
<p>查看PulseAudio是否正在运行：</p>
<pre tabindex="0"><code>$ pgrep -af pulseaudio
369 /usr/bin/pulseaudio
</code></pre><p>如果PulseAudio未运行而且用户正在使用X11，运行下面的命令可以在启动PulseAudio的同时加载需要的X11插件：</p>
<pre tabindex="0"><code>$ start-pulseaudio-x11
</code></pre><p>如果你没有运行GNOME, KDE或者Xfce，并且你的<code>~/.xinitrc</code>文件并未引用<code>/etc/X11/xinit/xinitrc.d</code>目录下的文件内容，为了让PulseAudio自动启动，你可以这样做：</p>
<pre tabindex="0"><code>~/.xinitrc
/usr/bin/start-pulseaudio-x11
</code></pre><h4 id="后端设置">后端设置<a hidden class="anchor" aria-hidden="true" href="#后端设置">#</a></h4>
<h5 id="alsa">ALSA<a hidden class="anchor" aria-hidden="true" href="#alsa">#</a></h5>
<p>配置ALSA与PulseAudio共同工作必须的文件<code>/etc/asound.conf</code>。</p>
<p>为了防止应用程序使用ALSA的OSS模拟功能而忽略PulseAudio（从而导致其他应用程序无法播放声音），确定<code>snd_pcm_oss</code>模块没有在系统启动时自动加载。如果该模块已经被加载(<code>lsmod | grep oss</code>)，运行下面命令以卸载该模块：</p>
<pre tabindex="0"><code># rmmod snd_pcm_oss
</code></pre><h4 id="均衡器">均衡器<a hidden class="anchor" aria-hidden="true" href="#均衡器">#</a></h4>
<p>PulseAudio内置了10段均衡器系统，按下列步骤操作以启用均衡器：</p>
<h5 id="加载均衡器通道和dbus协议模块">加载均衡器通道和dbus协议模块<a hidden class="anchor" aria-hidden="true" href="#加载均衡器通道和dbus协议模块">#</a></h5>
<pre tabindex="0"><code>$ pactl load-module module-equalizer-sink
$ pactl load-module module-dbus-protocol
</code></pre><h5 id="安装并运行图形前端">安装并运行图形前端<a hidden class="anchor" aria-hidden="true" href="#安装并运行图形前端">#</a></h5>
<pre tabindex="0"><code>$ sudo apt install pulseaudio-equalizer
$ qpaeq
</code></pre><h5 id="每次启动时加载均衡器和dbus模块">每次启动时加载均衡器和dbus模块<a hidden class="anchor" aria-hidden="true" href="#每次启动时加载均衡器和dbus模块">#</a></h5>
<p>编辑 <code>/etc/pulse/default.pa</code> 并加入下面几行：</p>
<pre tabindex="0"><code>### Load the integrated PulseAudio equalizer and D-Bus module
load-module module-equalizer-sink
load-module module-dbus-protocol
</code></pre><h3 id="ffmpeghttpswwwruanyifengcomblog202001ffmpeghtml"><a href="https://www.ruanyifeng.com/blog/2020/01/ffmpeg.html">FFmpeg</a><a hidden class="anchor" aria-hidden="true" href="#ffmpeghttpswwwruanyifengcomblog202001ffmpeghtml">#</a></h3>
<ul>
<li>powershell 执行与在 cmd 执行不一样，poweshell 某些 <code>-c:v</code> 会报错</li>
<li>ffmpeg 输出参数含义
<ul>
<li>frame: 编码的帧数量</li>
<li>fps：每秒编码的帧数</li>
<li>q：质量因子</li>
<li>size/ Lsize：视频和音频编码后的大小，即基本等于视频和音频 之和</li>
<li>time：输出帧的显示时间</li>
<li>bitrate：输出视频的比特率</li>
<li>dup：输入帧重复（duplicate）的数量</li>
<li>drop：输入帧丢弃（drop）的个数</li>
<li>speed：编码速度</li>
</ul>
</li>
</ul>
<p>视频文件本身其实是一个容器（container），里面包括了视频和音频，也可能有字幕等其他内容。</p>
<p>视频和音频都需要经过编码，才能保存成文件。不同的编码格式（CODEC），有不同的压缩率，会导致文件大小和清晰度的差异。</p>
<p>编码器（encoders）是实现某种编码格式的库文件。只有安装了某种格式的编码器，才能实现该格式视频/音频的编码和解码。</p>
<p>FFmpeg 的命令行参数非常多，可以分成五个部分：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ffmpeg <span style="color:#f92672">[</span>全局参数<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>输入文件参数<span style="color:#f92672">]</span> -i 输入文件 <span style="color:#f92672">[</span>输出文件参数<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>输出文件<span style="color:#f92672">]</span>
</code></pre></div><h4 id="常用参数">常用参数<a hidden class="anchor" aria-hidden="true" href="#常用参数">#</a></h4>
<ul>
<li><code>-c</code>：指定编码器</li>
<li><code>-c copy</code>：直接复制，不经过重新编码（这样比较快）</li>
<li><code>-c:v</code>：指定视频编码器</li>
<li><code>-c:a</code>：指定音频编码器</li>
<li><code>-i</code>：指定输入文件</li>
<li><code>-an</code>：去除音频流</li>
<li><code>-vn</code>： 去除视频流</li>
<li><code>-preset</code>：指定输出的视频质量，会影响文件的生成速度，有以下几个可用的值 ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow。</li>
<li><code>-y</code>：不经过确认，输出时直接覆盖同名文件。</li>
</ul>
<h4 id="查看视频文件的元信息">查看视频文件的元信息<a hidden class="anchor" aria-hidden="true" href="#查看视频文件的元信息">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ffmpeg -i input.mp4 -hide_banner
</code></pre></div><h4 id="转换编码格式">转换编码格式<a hidden class="anchor" aria-hidden="true" href="#转换编码格式">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ffmpeg -i <span style="color:#f92672">[</span>input.file<span style="color:#f92672">]</span> -c:v libx264 output.mp4
</code></pre></div><p>转成 H.264 编码，一般使用编码器 libx264</p>
<h4 id="转换容器格式">转换容器格式<a hidden class="anchor" aria-hidden="true" href="#转换容器格式">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ffmpeg -i input.mp4 -c copy output.mkv
</code></pre></div><h4 id="改变分辨率">改变分辨率<a hidden class="anchor" aria-hidden="true" href="#改变分辨率">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ffmpeg -i input.mp4 -vf scale<span style="color:#f92672">=</span>720:-1 output.mp4
</code></pre></div><h4 id="提取视频">提取视频<a hidden class="anchor" aria-hidden="true" href="#提取视频">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ffmpeg -i input.mp4 -an -c:v copy ouput.mp4
</code></pre></div><p><code>-vcodec codec</code> 强制使用codec编解码方式。如果用copy表示原始编解码数据必须被拷贝。</p>
<h4 id="提取音频">提取音频<a hidden class="anchor" aria-hidden="true" href="#提取音频">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ffmpeg -i input.mp4 -vn -c:a copy output.aac
</code></pre></div><p><code>-c:a copy</code>表示不改变音频编码，直接拷贝。</p>
<h4 id="添加音轨">添加音轨<a hidden class="anchor" aria-hidden="true" href="#添加音轨">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ffmpeg -i input.aac -i input.mp4 output.mp4
</code></pre></div><h4 id="音视频合成">音视频合成<a hidden class="anchor" aria-hidden="true" href="#音视频合成">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ffmpeg -i video.mp4 -i audio.aac -c:v copy -c:a copy output.mp4
</code></pre></div><h4 id="截图">截图<a hidden class="anchor" aria-hidden="true" href="#截图">#</a></h4>
<p>从指定时间开始，连续对1秒钟的视频进行截图</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ffmpeg -y -i input.mp4 -ss 00:01:24 -t 00:00:01 output_%3d.jpg
</code></pre></div><p>指定只截取一帧</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ffmpeg -ss 01:23:45 -i input.mp4 -vframes <span style="color:#ae81ff">1</span> -q:v <span style="color:#ae81ff">2</span> output.jpg
</code></pre></div><p><code>-vframes 1</code>指定只截取一帧，<code>-q:v 2</code>表示输出的图片质量，一般是1到5之间（1 为质量最高）。</p>
<h4 id="裁剪">裁剪<a hidden class="anchor" aria-hidden="true" href="#裁剪">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ffmpeg -ss <span style="color:#f92672">[</span>start<span style="color:#f92672">]</span> -i <span style="color:#f92672">[</span>input<span style="color:#f92672">]</span> -t <span style="color:#f92672">[</span>duration<span style="color:#f92672">]</span> -c copy <span style="color:#f92672">[</span>output<span style="color:#f92672">]</span>
$ ffmpeg -ss <span style="color:#f92672">[</span>start<span style="color:#f92672">]</span> -i <span style="color:#f92672">[</span>input<span style="color:#f92672">]</span> -to <span style="color:#f92672">[</span>end<span style="color:#f92672">]</span> -c copy <span style="color:#f92672">[</span>output<span style="color:#f92672">]</span>
</code></pre></div><p>裁剪（cutting）指的是，截取原始视频里面的一个片段，输出为一个新视频。可以指定开始时间（start）和持续时间（duration），也可以指定结束时间（end）。</p>
<h4 id="添加字幕httpswwwjianshucompf33910818a1c"><a href="https://www.jianshu.com/p/f33910818a1c">添加字幕</a><a hidden class="anchor" aria-hidden="true" href="#添加字幕httpswwwjianshucompf33910818a1c">#</a></h4>
<ul>
<li>外挂字幕：一个单独的外部字幕文件，格式类型一般有srt、vtt、ass等等。播放视频时，需要把外挂字幕和视频放在同一目录下，并在播放器中选择字幕文件才可以在视频中看到字幕。</li>
<li>软字幕：也叫内挂字幕、封装字幕、内封字幕，字幕流等，就是把前面的外挂字幕的字幕文件嵌入到视频中作为流的一部分，如果一个视频有多个字幕流那么播放视频是还得选择对应的字幕流</li>
<li>硬字幕：是嵌入到视频帧里面的字幕，它就像视频水印一样作为视频帧的一分部分了，不管再任何平台字幕看起来都是一样的，而且也不再要求播放器单独对字母进行渲染</li>
</ul>
<p>常见的字幕格式有：</p>
<ul>
<li>SRT（标准外挂字幕格式）：只包含文字和时间码，没有样式，显示效果由播放器决定，不同的播放器显示出的效果可能差别很大。</li>
<li>ASS（高级外挂字幕格式）：支持样式、字体、字幕定位、淡入淡出、简单的特效。如果不缺字体，不同的播放器显示效果基本一致。</li>
</ul>
<p>ffmpeg字幕处理流程(容器是否支持字幕流指的是输出容器)</p>
<p><img loading="lazy" src="/Distributions/ffmpeg.webp" alt=""  />
</p>
<p>添加软字幕：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ffmpeg -i video.mp4 -i subtitle.srt -c copy output.mkv
</code></pre></div><p>软字幕只有部分容器格式比如(mkv)才支持，MP4/MOV等不支持，而且也只有部分播放器支持软字幕或者外挂字幕(如VLC播放器)。</p>
<p>添加多个字幕：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">ffmpeg -i input.mp4 -i zh_CN.srt -i en_US.srt -map 0:v -map 0:a -map <span style="color:#ae81ff">1</span> -map <span style="color:#ae81ff">2</span>  -c:v copy -c:a copy -metadata:s:s:0 language<span style="color:#f92672">=</span>chn -metadata:s:s:1 language<span style="color:#f92672">=</span>eng <span style="color:#e6db74">&#34;output.mp4&#34;</span>
</code></pre></div><ul>
<li><code>-map</code> 是轨道参数，如果只有一个字幕，就不需要这个参数。<code>-map 0:v</code> 表示第一个文件输入视频轨道，<code>-map 0:a</code> 表示第二个轨道是第一个文件输入的音频轨道，<code>-map 1</code> 建立第三个轨道，<code>-map 2</code> 建立第四个轨道。如果没添加 map 参数，默认就只有一个字幕轨道，第二个英文字幕会覆盖第一个中文字幕轨道。</li>
<li><code>-metadata:s:s:0 language=chn</code> 第一条字幕的语言设置为中文，<code>-metadata:s:s:1 language=eng</code> 第二条字幕的语言设置为英文。 <code>language</code> 不能自定义，只能设置成固定的缩写。</li>
</ul>
<p>添加硬字幕：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ffmpeg -i video.mkv -vf subtitles<span style="color:#f92672">=</span>subtitle.srt out.mp4
</code></pre></div><h4 id="下载-m3u8httpswww51ctocomarticle558658html"><a href="https://www.51cto.com/article/558658.html">下载 m3u8</a><a hidden class="anchor" aria-hidden="true" href="#下载-m3u8httpswww51ctocomarticle558658html">#</a></h4>
<p>现在比较常见的视频流媒体，大部分都是 m3u8 格式的，而对于 m3u8 格式的视频而言，如果你下载过，你会发现它就是一个文本文件，大概也就只有几十 kb，从磁盘大小来看，应该也知道它并不是一个直接的视频文件。</p>
<p><strong>什么是 m3u8</strong></p>
<p>说到 m3u8 就要先说说 HLS（HTTP Live Streaming）。HLS 是 Apple 公司针对 iPhone、iPod、iTouch 等移动设备，而研发的基于 HTTP 协议的流媒体解决方案。在 HLS 技术中，Web 服务器可以向客户端提供接近实时的音视频流，但是它又是使用的标准的 HTTP 协议。所以基本上，比较大型的点播直播类服务，都是基于 HLS 的。</p>
<p>而该技术的原理，就是将视频文件或者视频流，进行切片（ts文件），并建立索引文件（m3u8），它支持的视频流编码为 H.264，音频流编码为 AAC。</p>
<p>简单来说，基于 HLS 的视频流，会将完整的视频，切割成一个个比较小的视频片段（ts 文件），然后根据协议组合成一个 m3u8 文件。这些比较小的 ts 文件，是可以单独播放的。而视频播放器，拿到 m3u8 文件之后，根据对其内 ts 片段的索引，连续播放不同的视频片段，来达到流畅的播放效果。</p>
<p><strong>下载的 m3u8 文件</strong></p>
<p>说这些概念都没用，我们来看两个真实的被下载的 m3u8 文件。</p>
<p><img loading="lazy" src="/Distributions/4dda38f226d35487c838575d86125b9b.jpg" alt="img"  />
</p>
<p>这种 m3u8 文件就还是比较清晰的，能看到它一个个的片段。但是需要注意的是，这里的片段，全部是基于域名的相对地址，也就是说，这样一个 m3u8 文件，你丢到播放器里，是无法播放的，但是如果你记录了原始下载这个 m3u8 的链接，它在播放器里是可以正常播放的。</p>
<p>当然，如果你修改这个 m3u8 文件，将它相对路径拼接上域名地址，也是可以达到播放的效果的。</p>
<p>再来看看另外一种 m3u8 文件，它其内的 ts 片段，都是完整地址。</p>
<p><img loading="lazy" src="/Distributions/231561a1c6ac4f063f05c72257701e35.jpg" alt="img"  />
</p>
<p>像这种具有完整地址的 ts 片段，哪怕你将它保存成一个本地的文件，播放器依然是可以直接播放的，不过这里本质上依然是在在线播放。</p>
<p>这两中 m3u8 文件，虽然有细微的差别，但是它们都是基于标准的协议。</p>
<p>简单总结一下：</p>
<ol>
<li>m3u8 不是视频内容的文件，它占用的磁盘空间非常的小。</li>
<li>m3u8 文件，如果其内的 ts 片段，是完整地址，则可以保存后播放，否者只能在线播放。</li>
<li>播放器播放 m3u8 文件的时候，实际上，还是在线从线上获取的视频流进行播放，所以是存在失效的情况的。</li>
</ol>
<p>暂时知道这三点就可以了，接下来我们再看如何将一个 m3u8 文件，下载成一个 mp4 视频文件。</p>
<p><strong>使用 fmpeg 下载 m3u8</strong></p>
<p>ffmpeg 是一套可以用来记录、转换音视频，并将其转化为流的开源程序，采用 LGPL 或 GPL 协议许可证书，很多大型的音视频软件，内部都是基于 ffmpeg 的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ffmpeg -i <span style="color:#e6db74">&#34;m3u8_file_uri&#34;</span> <span style="color:#e6db74">&#34;save_video.mp4&#34;</span> 
</code></pre></div><p>到此，如果 m3u8 的链接正确可播放，就会开始下载，等待下载完成就可以了，最终会在指定目录下，保存 save_video.mp4 文件，它就是最终我们下载的离线视频文件。</p>
<h3 id="mpvhttpsmpviomanual"><a href="https://mpv.io/manual/">MPV</a><a hidden class="anchor" aria-hidden="true" href="#mpvhttpsmpviomanual">#</a></h3>
<p>MPV 是一个基于 <a href="http://www.mplayerhq.hu/DOCS/man/zh_CN/mplayer.1.html">MPlayer</a> 和 mplayer2 的开源极简全能播放器。支持各种视频格式、音频解码、支持特效字幕（电影动漫的ass特效字幕都没啥问题），不仅支持本地播放，同样支持网络播放（mpv 集成了 <code>youtube-dl</code>）。重点是 MPV 具有多系统平台支持、命令行、自定义、GPU 解码、脚本支持等特点……</p>
<h4 id="osc-界面">OSC 界面<a hidden class="anchor" aria-hidden="true" href="#osc-界面">#</a></h4>
<p>由于默认情况下，MPV 播放器简约到连 GUI 界面都没有提供，因此需要通过命令行或配置文件设置。</p>
<p>虽然 MPV 并没有提供官方的 GUI 界面，没有菜单，但它提供 OSC 操作界面和快捷键用于操作，只要关联好文件格式，使用 mpv 打开视频后，使用上其实也非常的简单方便。</p>
<p><img loading="lazy" src="Distributions/mpv-control.webp" alt="mpv 界面说明"  />
</p>
<h4 id="快捷键httpswwwiplaysoftcommpvhtml"><a href="https://www.iplaysoft.com/mpv.html">快捷键</a><a hidden class="anchor" aria-hidden="true" href="#快捷键httpswwwiplaysoftcommpvhtml">#</a></h4>
<p>操作主要通过键盘快捷键（区分大小写）调整。下面介绍一些常用的 mpv 快捷键（更多的快捷键请阅读官方参考手册）。</p>
<p><strong>鼠标操作</strong></p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>鼠标左键双击</td>
<td>进入/退出全屏</td>
</tr>
<tr>
<td>鼠标右键单击</td>
<td>暂停/继续播放</td>
</tr>
<tr>
<td>鼠标滚轮</td>
<td>快进/快退</td>
</tr>
</tbody>
</table>
<p><strong>播放控制</strong></p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th></th>
<th>作用说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>p</td>
<td>Space</td>
<td>暂停、继续播放</td>
</tr>
<tr>
<td>/</td>
<td>*</td>
<td>减少/增加音量</td>
</tr>
<tr>
<td>9</td>
<td>0</td>
<td>减少/增加音量（数字键盘区的9、0不可用）</td>
</tr>
<tr>
<td>m</td>
<td></td>
<td>静音</td>
</tr>
<tr>
<td>←</td>
<td>→</td>
<td>快退/快进5秒</td>
</tr>
<tr>
<td>↑</td>
<td>↓</td>
<td>快进/快退1分钟</td>
</tr>
<tr>
<td>&lt;</td>
<td>&gt;</td>
<td>上一个/下一个（播放列表中）</td>
</tr>
<tr>
<td>Enter</td>
<td></td>
<td>下一个（播放列表中）</td>
</tr>
<tr>
<td>l</td>
<td></td>
<td>设定/清除 A-B循环点</td>
</tr>
<tr>
<td>L</td>
<td></td>
<td>循环播放</td>
</tr>
<tr>
<td>s</td>
<td></td>
<td>截屏</td>
</tr>
<tr>
<td>q</td>
<td></td>
<td>停止播放并退出</td>
</tr>
<tr>
<td>Q</td>
<td></td>
<td>保存当前播放进度并退出，播放同样文件从上次保存进度继续播放。</td>
</tr>
</tbody>
</table>
<p><strong>视频控制</strong></p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>_(下划线)</td>
<td>循环切换可用视频轨</td>
</tr>
<tr>
<td>A</td>
<td>循环切换视频画面比例</td>
</tr>
<tr>
<td>Alt+0</td>
<td>0.5倍源视频画面大小</td>
</tr>
<tr>
<td>Alt+1</td>
<td>1倍源视频画面大小</td>
</tr>
<tr>
<td>Alt+2</td>
<td>2倍源视频画面大小</td>
</tr>
</tbody>
</table>
<p><strong>音频控制</strong></p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th></th>
<th>作用说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>#</td>
<td></td>
<td>循环切换可用音频轨</td>
</tr>
<tr>
<td>Ctrl +</td>
<td>Ctrl -</td>
<td>音轨延迟+/- 0.1秒</td>
</tr>
</tbody>
</table>
<p><strong>字幕控制</strong></p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th></th>
<th>作用说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>V</td>
<td></td>
<td>关闭/开启字幕</td>
</tr>
<tr>
<td>j</td>
<td>J</td>
<td>循环切换可用字幕轨</td>
</tr>
<tr>
<td>x</td>
<td>z</td>
<td>字幕延迟 +/- 0.1秒</td>
</tr>
<tr>
<td>r</td>
<td>t</td>
<td>上移/下移字幕位置</td>
</tr>
</tbody>
</table>
<p><strong>窗口控制</strong></p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>T</td>
<td>窗口始终置顶</td>
</tr>
<tr>
<td>f</td>
<td>进入/退出全屏</td>
</tr>
<tr>
<td>ESC</td>
<td>退出全屏</td>
</tr>
</tbody>
</table>
<h4 id="配置httpshooke007githubiompv-lazympvhtml"><a href="https://hooke007.github.io/mpv-lazy/mpv.html">配置</a><a hidden class="anchor" aria-hidden="true" href="#配置httpshooke007githubiompv-lazympvhtml">#</a></h4>
<p>因为mpv本身不具有图形化前端，绝大多数的设置选项都是靠在主设置文件 <code>~/.config/mpv/mpv.conf</code> 中输入参数实现的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">## 部分选项之间有关联作用，MPV读取参数时由上往下读，所以注意书写通用参数的顺序，可查看手册[02]的顺序逻辑部分的错误示范</span>

<span style="color:#75715e">## 基础 ##</span>

<span style="color:#75715e"># 视频硬件解码API选择</span>
<span style="color:#75715e"># 因系统环境、显卡、驱动等差异硬件解码API方式（阅读官方参考手册查询）各有不同，建议实际测试验证后再填入可用API。</span>
<span style="color:#75715e"># 默认值为 no（使用软件解码），auto 为自动。</span>
hwdec<span style="color:#f92672">=</span>auto                       

<span style="color:#75715e"># 尽可能所有格式先尝试上面指定视频硬件解码API</span>
<span style="color:#75715e">#hwdec-codecs=all </span>

<span style="color:#75715e"># 输出log，</span>
<span style="color:#75715e"># ~~/ 意思是 mpv config dir(for example ~/.config/mpv/)</span>
log-file<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;~~/mpv.log&#34;</span>                             

<span style="color:#75715e">## 功能 ##</span>

<span style="color:#75715e"># --fs 等效 --fullscreen。运行MPV自动进入全屏</span>
<span style="color:#75715e">#fs=yes    </span>

<span style="color:#75715e"># 默认为系统原生窗口界面，启用此项使用无边框界面</span>
<span style="color:#75715e">#border=no</span>

<span style="color:#75715e"># 窗口置顶</span>
<span style="color:#75715e">#ontop=yes         </span>

<span style="color:#75715e"># 窗口模式下最大占屏幕的百分比</span>
<span style="color:#75715e"># 例如在FHD屏上打开4k视频初始窗口过大</span>
<span style="color:#75715e">#autofit-larger=80%x80%  </span>

<span style="color:#75715e"># 窗口模式下最小占屏幕的百分比</span>
<span style="color:#75715e"># 例如在4k屏上打开720p视频初始窗口过小</span>
<span style="color:#75715e">#autofit-smaller=50%x50%     </span>

<span style="color:#75715e"># 默认yes，默认情况下MPV的窗口比例锁定为视频比例。启用此项以实现窗口自由拉伸行为</span>
<span style="color:#75715e"># 当 keepaspect=yes 时四周填充黑边</span>
<span style="color:#75715e"># keepaspect-window=no          </span>

<span style="color:#75715e"># 以暂停状态启动播放器</span>
<span style="color:#75715e">#pause=yes      </span>

<span style="color:#75715e"># 始终循环播放当前文件&lt;N|inf|no&gt;</span>
<span style="color:#75715e">#loop=inf    </span>

<span style="color:#75715e"># 播放列表循环&lt;N|inf|force|no&gt;</span>
<span style="color:#75715e">#loop-playlist=no  </span>

<span style="color:#75715e"># 默认情况下播完列表所有文件MPV自动关闭，设置为 yes 所有播放完毕不退出，设置为 always 可以实现类似“每个文件播完都暂停”的效果&lt;yes|默认no|always&gt; </span>
keep-open<span style="color:#f92672">=</span>yes         

<span style="color:#75715e"># 退出时记住播放状态。缓存目录默认在设置文件夹中的 &#34;watch_later&#34;</span>
save-position-on-quit<span style="color:#f92672">=</span>yes

<span style="color:#75715e"># 播放网络视频时的向后缓存大小（KiB或MiB）</span>
demuxer-max-bytes<span style="color:#f92672">=</span>20MiB      

<span style="color:#75715e">## OSD ##</span>
<span style="color:#75715e">## OSD 即 On-Screen-Display ，通常为屏幕上弹出显示的信息。 </span>
<span style="color:#75715e">## OSC 即 on-screen-controller ，MPV中指的是简易操控界面</span>

<span style="color:#75715e"># &lt;no,bar,msg,msg-bar&gt; 在跳转时间轴时显示的信息类型</span>
osd-on-seek<span style="color:#f92672">=</span>msg-bar     

<span style="color:#75715e"># 更改OSD字体大小（全局，影响多个功能显示的文本）（默认值：55）</span>
<span style="color:#75715e">#osd-font-size=40  </span>

<span style="color:#75715e"># 以秒为单位显示OSD时间（毫秒精度），有助于查看视频帧的确切时间戳</span>
osd-fractions<span style="color:#f92672">=</span>yes  
 
 <span style="color:#75715e"># 开始播放时短暂显示的信息：文件名</span>
osd-playing-msg<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>filename<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>
                                
<span style="color:#75715e"># 设置OSD文本信息的持续时间（毫秒）（默认值：1000）</span>
osd-duration<span style="color:#f92672">=</span><span style="color:#ae81ff">2000</span> 

<span style="color:#75715e">## 音频 ##</span>
 
<span style="color:#75715e"># 最大音量。默认值130（130的响度约为100的两倍）&lt;100.0-1000.0&gt;</span>
volume-max<span style="color:#f92672">=</span><span style="color:#ae81ff">120</span>  

<span style="color:#75715e"># 播放器启动音量。0为静音，默认100</span>
<span style="color:#75715e">#volume=100 </span>

<span style="color:#75715e"># 自动加载同名外挂音轨（fuzzy为模糊名，exact为精确名）&lt;默认no|exact|fuzzy|all&gt; </span>
audio-file-auto<span style="color:#f92672">=</span>fuzzy  

<span style="color:#75715e">## 视频 ##</span>

<span style="color:#75715e"># 如果做过专业校色应开启（系统目录存在对应的icm校色文档）。未做校色的广色域屏应手动指定 --target-prim=&lt;value&gt;</span>
<span style="color:#75715e">#icc-profile-auto=yes </span>

<span style="color:#75715e">## 脚本 滤镜 着色器 ##</span>
<span style="color:#75715e">## 内置脚本开关（如果没有必要的目的，那就不要屏蔽mpv内建的功能</span>

<span style="color:#75715e"># 控制台</span>
<span style="color:#75715e">#load-osd-console=no</span>

<span style="color:#75715e"># 统计信息</span>
<span style="color:#75715e">#load-stats-overlay=no  </span>

<span style="color:#75715e">## 字幕 ##</span>
 
<span style="color:#75715e"># 自动加载当前播放文件的同名外挂字幕</span>
sub-auto<span style="color:#f92672">=</span>fuzzy 

<span style="color:#75715e"># 在指定的额外目录中寻找匹配的字幕，支持相对和绝对路径。</span>
<span style="color:#75715e"># 示例即自动搜索当前文件路径下名为&#34;sub&#34;,&#34;subtitles&#34;,&#34;字幕&#34;和C盘的&#34;字幕库&#34;文件夹内</span>
<span style="color:#75715e">#sub-file-paths=sub;subtitles;字幕;C:/字幕库</span>

<span style="color:#75715e"># 字幕首选语言为中文，但MPV优先加载外挂轨道，此项参数可能实际用处不大</span>
slang<span style="color:#f92672">=</span>chs,sc,zh,chi,zho

<span style="color:#75715e"># 在插值和颜色管理之前，将字幕混合到视频帧上&lt;yes|video|默认no&gt;。值video类似于yes，但是以视频的原始分辨率绘制字幕，并与视频一起缩放</span>
<span style="color:#75715e"># 启用此功能会将字幕限制在视频的可见部分（不能出现在视频下方的黑色空白处）</span>
<span style="color:#75715e"># 还会让字幕受 --icc-profile --target-prim --target-trc --interpolation --gamma-factor --glsl-shaders 的影响   # 与 --interpolation 一起使用时，可提高字幕渲染性能  </span>
<span style="color:#75715e">#blend-subtitles=video </span>

<span style="color:#75715e"># [当 --blend-subtitles=yes/video 时无效] 使ASS字幕尽可能输出在黑边上</span>
sub-ass-force-margins<span style="color:#f92672">=</span>yes  

<span style="color:#75715e">## 截图 ##</span>
<span style="color:#75715e">## 以下预设参数只是为了截取最高质量的图片（高质量截图处理效率较低）</span>

<span style="color:#75715e"># &lt;默认 jpg|png|webp&gt;</span>
screenshot-format<span style="color:#f92672">=</span>png  

<span style="color:#75715e"># JPEG的最高质量，默认为90&lt;0-100&gt; </span>
<span style="color:#75715e">#screenshot-jpeg-quality=100 </span>

<span style="color:#75715e"># 用与源视频相同的色度半采样写入JPEG，默认yes</span>
<span style="color:#75715e">#screenshot-jpeg-source-chroma=yes  </span>

<span style="color:#75715e"># PNG压缩等级，过高的等级影响性能，默认为7&lt;0-9&gt; </span>
<span style="color:#75715e">#screenshot-png-compression=5  </span>

<span style="color:#75715e"># PNG的压缩过滤器。默认5即可实现最佳压缩率&lt;0-5&gt; </span>
<span style="color:#75715e">#screenshot-png-filter=5   </span>

<span style="color:#75715e"># 使用适当的色彩空间标记屏幕截图（并非所有格式受支持）默认no</span>
<span style="color:#75715e">#screenshot-tag-colorspace=yes  </span>

<span style="color:#75715e"># 主要影响PNG，尽可能使用和视频输出时相同的位深，默认yes</span>
<span style="color:#75715e">#screenshot-high-bit-depth=yes</span>

<span style="color:#75715e"># 若直接在模板中设置路径，此时无需 --screenshot-directory</span>
screenshot-template<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;MPV-%P-N%n&#34;</span>

<span style="color:#75715e"># 截屏文件保存路径</span>
<span style="color:#75715e"># ~/ 意思是 user home directory root (similar to shell, $HOME)</span>
screenshot-directory<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;~/Pictures&#34;</span>
</code></pre></div><h3 id="shotcuthttpswwwshotcutorgdownload"><a href="https://www.shotcut.org/download/">Shotcut</a><a hidden class="anchor" aria-hidden="true" href="#shotcuthttpswwwshotcutorgdownload">#</a></h3>
<p>Shotcut is a free, open source, cross-platform video editor.</p>
<h3 id="davinci-resolvehttpwwwblackmagicdesigncomcnproductsdavinciresolve"><a href="http://www.blackmagicdesign.com/cn/products/davinciresolve/">DaVinci Resolve</a><a hidden class="anchor" aria-hidden="true" href="#davinci-resolvehttpwwwblackmagicdesigncomcnproductsdavinciresolve">#</a></h3>
<p>专业的剪辑、调色、特效和音频后期制作！</p>
<h3 id="mkvtoolnixhttpsmkvtoolnixdownloaddownloadshtml"><a href="https://mkvtoolnix.download/downloads.html">MKVToolNix</a><a hidden class="anchor" aria-hidden="true" href="#mkvtoolnixhttpsmkvtoolnixdownloaddownloadshtml">#</a></h3>
<p><em>MKVToolNix</em> is a set of tools to create, alter and inspect <a href="http://www.matroska.org/">Matroska</a>(mkv) files under Linux, other Unices and Windows.</p>
<p>轨道提取模式：</p>
<pre tabindex="0"><code>mkvextract 输入文件名 tracks [选项] TID1:目标文件名1 [TID2:目标文件名2 ...]
</code></pre><p>TID:输出文件名	如果输入文件中存在 ID 为 TID 的轨道，则将其提取为文件 输出文件名。轨道 ID 与 <code>mkvmerge --identify 文件</code> 选项所输出的相同。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ mkvextract <span style="color:#e6db74">&#34;Another Movie.mkv&#34;</span> tracks 0:video.h265 <span style="color:#e6db74">&#34;1:main audio.aac&#34;</span>
</code></pre></div><h3 id="vlchttpswwwvideolanorg"><a href="https://www.videolan.org/">VLC</a><a hidden class="anchor" aria-hidden="true" href="#vlchttpswwwvideolanorg">#</a></h3>
<p>VLC is a free and open source cross-platform multimedia player and framework that plays most multimedia files, and various streaming protocols.</p>
<h2 id="download">Download<a hidden class="anchor" aria-hidden="true" href="#download">#</a></h2>
<h3 id="aria2httpsaria2githubio"><a href="https://aria2.github.io/">Aria2</a><a hidden class="anchor" aria-hidden="true" href="#aria2httpsaria2githubio">#</a></h3>
<p>Aria2是一款开源下载工具，可帮助简化不同设备和服务器之间的下载过程。它支持磁力链接、BT种子、http等类型的文件下载，与迅雷相比，Aria2有着优秀的性能及较低的资源占用，架构本身非常轻巧，通常只需要4兆字节（HTTP下载）到9兆字节（用于BitTorrent交互）之间。最重要的一点是Aria2完全免费！</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt-get install aria2
</code></pre></div><p>下载安装完成之后，可以通过输入 <code>aria2c -v</code> 来验证是否安装成功。</p>
<h4 id="usage">Usage<a hidden class="anchor" aria-hidden="true" href="#usage">#</a></h4>
<p><strong>命令行使用</strong></p>
<p>使用Aria2下载文件，只需在命令后附加地址即可：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ aria2c URL
</code></pre></div><p>下载后以其他名称保存文件</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ aria2c -o fileName URL
</code></pre></div><p>下载多个文件</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ aria2c -Z URL URL
</code></pre></div><p>从列表下载文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ aria2c -i URLs.txt
</code></pre></div><p>限制下载速度：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 单个文件</span>
aria2c –max-download-limit<span style="color:#f92672">=</span>500k URL
<span style="color:#75715e"># 全局</span>
aria2c –max-overall-download-limit<span style="color:#f92672">=</span>500k URL 
</code></pre></div><p>断点续传：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ aria2c -c URL
</code></pre></div><p>下载磁力链接文件：要下载磁力链接文件，如果下载没有速度，可以添加<code>--bt-tracker=</code>选项，tracker 中用 <code>,</code> 隔开：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ aria2c --bt-tracker<span style="color:#f92672">=</span>tracker,tracker torrent
</code></pre></div><p>tracker 服务器：</p>
<ul>
<li>
<p><a href="https://github.com/ngosang/trackerslist">trackerslist</a>：trackers_best (20 trackers) =&gt; <a href="https://raw.githubusercontent.com/ngosang/trackerslist/master/trackers_best.txt">link</a> / <a href="https://ngosang.github.io/trackerslist/trackers_best.txt">mirror</a> / <a href="https://cdn.jsdelivr.net/gh/ngosang/trackerslist@master/trackers_best.txt">mirror 2</a></p>
</li>
<li>
<p><a href="https://github.com/XIU2/TrackersListCollection">TrackersListCollection</a>：BEST Tracker list (78 trackers)=&gt; <a href="https://trackerslist.com/best.txt">link</a> / <a href="https://cdn.jsdelivr.net/gh/XIU2/TrackersListCollection/best.txt">mirror</a></p>
</li>
<li>
<p><a href="https://gitee.com/harvey520/www.yaozuopan.top/raw/master/blacklist.txt">中国可用的 BT Tracker 服务器列表</a></p>
</li>
<li>
<p>将多行文本转换成一行并用逗号隔开</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat tracker | xargs | tr <span style="color:#e6db74">&#39; &#39;</span> <span style="color:#e6db74">&#39;,&#39;</span>
</code></pre></div></li>
</ul>
<p>分段下载：可以加快文件的下载速度，对于下载大文件时特别有用，<code>-s</code> 后面的参数值介于1~5之间，你可以根据实际情况选择。下面命令将使用2连接来下载该文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ aria2c -s <span style="color:#ae81ff">2</span> URL
</code></pre></div><p>后台下载：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ aria2c -D url
$ aria2c –deamon<span style="color:#f92672">=</span>true url
</code></pre></div><p>验证文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ aria2c –checksum<span style="color:#f92672">=</span>md5<span style="color:#f92672">=</span>提供的md5
</code></pre></div><p>设置dht端口：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ aria2c –dht-listen-port<span style="color:#f92672">=</span><span style="color:#ae81ff">1234</span> torrent
</code></pre></div><p>下载需要引用页的文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ aria2c –referer<span style="color:#f92672">=</span>referurl URL
</code></pre></div><p>下载需要Cookie验证的文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ aria2c –essay-header<span style="color:#f92672">=</span>’Cookie:key<span style="color:#f92672">=</span>value’ URL
$ aria2c –load-cookies<span style="color:#f92672">=</span>cookie文件 URL
</code></pre></div><p>从密码保护的网站下载一个文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ aria2c --http-user<span style="color:#f92672">=</span>xxx --http-password<span style="color:#f92672">=</span>xxx URL
$ aria2c --ftp-user<span style="color:#f92672">=</span>xxx --ftp-password<span style="color:#f92672">=</span>xxx URL
</code></pre></div><p>注意：当源地址存在诸如&amp;,*等shell的特殊字符，请使用单引号或双引号把URI包含起来。</p>
<p><strong>RPC Server 模式</strong></p>
<p>该模式可以配合 Web UI 进行图形管理。默认启动是 6800 端口，怕别人盗用，可以设置用户名和密码(1.18.4以上版本支持密钥)。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ aria2c --enable-rpc --rpc-listen-all --rpc-allow-origin-all -c  --dir ~/Download
</code></pre></div><h4 id="configurat-ionhttparia2ccomusagehtml"><a href="http://aria2c.com/usage.html">Configurat ion</a><a hidden class="anchor" aria-hidden="true" href="#configurat-ionhttparia2ccomusagehtml">#</a></h4>
<p>默认情况下，aria2 检查旧路径 <code>$HOME/.aria2/aria2.conf</code> 是否存在，否则它会将 <code>$XDG_CONFIG_HOME/aria2/aria2.conf</code> 解析为它的配置文件。 您可以使用 <code>--conf-path</code> 选项指定配置文件的路径。 如果您不想使用配置文件，请使用 <code>--no-conf</code> 选项。</p>
<p><a href="http://www.senra.me/aria2-conf-file-parameters-translation-and-explanation/">配置详解</a>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># Description: Awesome Aria2 configuration file</span>
<span style="color:#75715e"># Version: 2021.09.15</span>

<span style="color:#75715e">## &#39;#&#39;开头为注释内容, 选项都有相应的注释说明, 根据需要修改 ##</span>
<span style="color:#75715e">## 被注释的选项填写的是默认值, 如为空则无默认设置，请自行选取需要更改的添加到你的配置文件中 ##</span>

<span style="color:#75715e">## 文件保存设置 ##</span>

<span style="color:#75715e"># 下载路径(可使用绝对路径或相对路径), 默认: 当前启动位置</span>
<span style="color:#75715e">#dir=</span>
dir<span style="color:#f92672">=</span>/home/kurome/Downloads

<span style="color:#75715e"># 磁盘缓存</span>
<span style="color:#75715e"># 启用磁盘缓存. 如果设置为 0, 将禁用磁盘缓存. 此功能将下载的数据缓存在内存中, 最多占用此选项设置的字节数. 缓存存储由 aria2 实例创建并对所有下载共享. 由于数据以较大的单位写入并按文件的偏移重新排序, 所以磁盘缓存的一个优点是减少磁盘的 I/O. 如果调用哈希检查时并且数据缓存在内存中时, 将不需要从磁盘中读取. 大小可以包含 K 或 M (1K = 1024, 1M = 1024K).</span>
disk-cache<span style="color:#f92672">=</span>64M

<span style="color:#75715e"># 文件预分配方式, 可选：none, prealloc, trunc, falloc, 默认:prealloc</span>
<span style="color:#75715e"># 预分配对于机械硬盘可有效降低磁盘碎片、提升磁盘读写性能、延长磁盘寿命。</span>
<span style="color:#75715e"># 机械硬盘使用 ext4（具有扩展支持），btrfs，xfs 或 NTFS（仅 MinGW 编译版本）等文件系统建议设置为 falloc</span>
<span style="color:#75715e"># 若无法下载，提示 fallocate failed.cause：Operation not supported 则说明不支持，请设置为 none</span>
<span style="color:#75715e"># prealloc 分配速度慢, trunc 无实际作用，不推荐使用。</span>
<span style="color:#75715e"># 固态硬盘不需要预分配，只建议设置为 none ，否则可能会导致双倍文件大小的数据写入，从而影响寿命。</span>
file-allocation<span style="color:#f92672">=</span>none

<span style="color:#75715e"># 文件分配限制</span>
<span style="color:#75715e"># 不对比此参数设置大小小的分配文件. 您可以增加数值的单位 K 或 M (1K = 1024, 1M = 1024K).</span>
no-file-allocation-limit<span style="color:#f92672">=</span>64M

<span style="color:#75715e"># 断点续传</span>
<span style="color:#75715e"># 继续下载部分完成的文件. 启用此选项可以继续下载从浏览器或其他程序按顺序下载的文件. 此选项目前只支持 HTTP(S)/FTP 下载的文件.</span>
<span style="color:#66d9ef">continue</span><span style="color:#f92672">=</span>true

<span style="color:#75715e"># 始终断点续传</span>
<span style="color:#75715e"># 始终断点续传. 如果设置为&#34;是&#34;, aria2 始终尝试断点续传, 如果无法恢复, 则中止下载. 如果设置为&#34;否&#34;, 对于不支持断点续传的 URI 或 aria2 遇到 N 个不支持断点续传的 URI (N 为 --max-resume-failure-tries 选项设置的值), aria2 会从头下载文件. 参见 --max-resume-failure-tries 参数.</span>
always-resume<span style="color:#f92672">=</span>false

<span style="color:#75715e"># 最大断点续传尝试次数</span>
<span style="color:#75715e"># 当 --always-resume 选项设置为&#34;否&#34;时, 如果 aria2 检测到有 N 个 URI 不支持断点续传时, 将从头开始下载文件. 如果 N 设置为 0, 当所有 URI 都不支持断点续传时才会从头下载文件. 参见 --always-resume 选项.</span>
max-resume-failure-tries<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>

<span style="color:#75715e"># 获取服务器文件时间</span>
<span style="color:#75715e"># 从 HTTP/FTP 服务获取远程文件的时间戳, 如果可用将设置到本地文件</span>
remote-time<span style="color:#f92672">=</span>true

<span style="color:#75715e">## 进度保存设置 ##</span>

<span style="color:#75715e"># 从会话文件中读取下载任务</span>
input-file<span style="color:#f92672">=</span>/home/kurome/.aria2/aria2.session

<span style="color:#75715e"># 会话文件保存路径</span>
<span style="color:#75715e"># 当退出时保存错误及未完成的任务到指定的文件中. 必须用绝对路径</span>
<span style="color:#75715e"># 您可以在重启 aria2 时使用 --input-file 选项重新加载. 如果您希望输出的内容使用 GZip 压缩, 您可以在文件名后增加 .gz 扩展名. 请注意, 通过 aria2.addTorrent() 和 aria2.addMetalink() RPC 方法添加的下载, 其元数据没有保存到文件的将不会保存. 通过 aria2.remove() 和 aria2.forceRemove() 删除的下载将不会保存.</span>
<span style="color:#75715e">#save-session=</span>
save-session<span style="color:#f92672">=</span>/home/kurome/.aria2/aria2.session

<span style="color:#75715e"># 任务状态改变后保存会话的间隔时间（秒）, 0 为仅在进程正常退出时保存, 默认:0</span>
<span style="color:#75715e"># 为了及时保存任务状态、防止任务丢失，此项值只建议设置为 1</span>
save-session-interval<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>

<span style="color:#75715e"># 自动保存任务进度到控制文件(*.aria2)的间隔时间（秒），0 为仅在进程正常退出时保存，默认：60</span>
<span style="color:#75715e"># 不论设置的值为多少, aria2 会在任务结束时保存控制文件. 可以设置的值为 0 到 600.</span>
<span style="color:#75715e"># 此项值也会间接影响从内存中把缓存的数据写入磁盘的频率</span>
<span style="color:#75715e"># 想降低磁盘 IOPS (每秒读写次数)则提高间隔时间</span>
<span style="color:#75715e"># 想在意外非正常退出时尽量保存更多的下载进度则降低间隔时间</span>
<span style="color:#75715e"># 非正常退出：进程崩溃、系统崩溃、SIGKILL 信号、设备断电等</span>
auto-save-interval<span style="color:#f92672">=</span><span style="color:#ae81ff">20</span>

<span style="color:#75715e"># 强制保存，即使任务已完成也保存信息到会话文件, 默认:false</span>
<span style="color:#75715e"># 即使任务完成或删除时使用 --save-session 选项时也保存该任务. 此选项在这种情况下还会保存控制文件. 此选项可以保存被认为已经完成但正在做种的 BT 任务.</span>
<span style="color:#75715e"># 开启后会在任务完成后保留 .aria2 文件，文件被移除且任务存在的情况下重启后会重新下载。</span>
<span style="color:#75715e"># 关闭后已完成的任务列表会在重启后清空。</span>
force-save<span style="color:#f92672">=</span>false


<span style="color:#75715e">## 下载连接设置 ##</span>

<span style="color:#75715e"># 文件未找到重试次数</span>
<span style="color:#75715e"># 如果 aria2 从远程 HTTP/FTP 服务器收到 &#34;文件未找到&#34; 的状态超过此选项设置的次数后下载将会失败. 设置为 0 将会禁用此选项. 此选项仅影响 HTTP/FTP 服务器. 重试时同时会记录重试次数, 所以也需要设置 --max-tries 这个选项.</span>
max-file-not-found<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>

<span style="color:#75715e"># 最大尝试次数</span>
<span style="color:#75715e"># 设置最大尝试次数. 0 表示不限制，默认:5</span>
max-tries<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>

<span style="color:#75715e"># 重试等待时间, 默认:0 (禁用)</span>
<span style="color:#75715e"># 设置重试间隔时间(秒). 当此选项的值大于 0 时, aria2 在 HTTP 服务器返回 503 响应时将会重试.</span>
retry-wait<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>

<span style="color:#75715e"># 连接超时时间</span>
<span style="color:#75715e"># 设置建立 HTTP/FTP/代理服务器 连接的超时时间(秒). 当连接建立后, 此选项不再生效, 请使用 --timeout 选项.</span>
connect-timeout<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>

<span style="color:#75715e"># 超时时间。默认：60</span>
timeout<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>

<span style="color:#75715e"># 最大同时下载任务数, 运行时可修改, 默认:5</span>
max-concurrent-downloads<span style="color:#f92672">=</span><span style="color:#ae81ff">5</span>

<span style="color:#75715e"># 单服务器最大连接线程数, 任务添加时可指定, 默认:1</span>
<span style="color:#75715e"># 最大值为 16 (增强版无限制), 且受限于单任务最大连接线程数(split)所设定的值。</span>
max-connection-per-server<span style="color:#f92672">=</span><span style="color:#ae81ff">16</span>

<span style="color:#75715e"># 单任务最大连接线程数, 任务添加时可指定, 默认:5</span>
<span style="color:#75715e"># 下载时使用 N 个连接. 如果提供超过 N 个 URI 地址, 则使用前 N 个地址, 剩余的地址将作为备用. 如果提供的 URI 地址不足 N 个, 这些地址多次使用以保证同时建立 N 个连接. 同一服务器的连接数会被 --max-connection-per-server 选项限制.</span>
split<span style="color:#f92672">=</span><span style="color:#ae81ff">64</span>

<span style="color:#75715e"># 文件最小分段大小, 添加时可指定, 默认:20M</span>
<span style="color:#75715e"># aria2 不会分割小于 2*SIZE 字节的文件. 例如, 文件大小为 20MB, 如果 SIZE 为 10M, aria2 会把文件分成 2 段 [0-10MB) 和 [10MB-20MB), 并且使用 2 个源进行下载 (如果 --split &gt;= 2). 如果 SIZE 为 15M, 由于 2*15M &gt; 20MB, 因此 aria2 不会分割文件并使用 1 个源进行下载. 您可以增加数值的单位 K 或 M (1K = 1024, 1M = 1024K). 可以设置的值为: 1M-1024M.</span>
<span style="color:#75715e"># 理论上值越小使用下载分段就越多，所能获得的实际线程数就越大，下载速度就越快，但受限于所下载文件服务器的策略。</span>
min-split-size<span style="color:#f92672">=</span>4M

<span style="color:#75715e"># 文件分片大小，最小值为 1M，默认：1M</span>
<span style="color:#75715e"># 设置 HTTP/FTP 下载的分配大小. aria2 根据这个边界分割文件. 所有的分割都是这个长度的倍数. 此选项不适用于 BitTorrent 下载. 如果 Metalink 文件中包含分片哈希的结果此选项也不适用.</span>
piece-length<span style="color:#f92672">=</span>1M

<span style="color:#75715e"># 允许分片大小变化。默认：false</span>
<span style="color:#75715e"># 如果设置为&#34;否&#34;, 当分片长度与控制文件中的不同时, aria2 将会中止下载. 如果设置为&#34;是&#34;, 您可以继续, 但部分下载进度将会丢失.</span>
allow-piece-length-change<span style="color:#f92672">=</span>true

<span style="color:#75715e"># 分片选择算法</span>
<span style="color:#75715e"># 指定 HTTP/FTP 下载使用的分片选择算法. 分片表示的是并行下载时固定长度的分隔段. 如果设置为&#34;默认&#34;, aria2 将会按减少建立连接数选择分片. 由于建立连接操作的成本较高, 因此这是合理的默认行为. 如果设置为&#34;顺序&#34;, aria2 将选择索引最小的分片. 索引为 0 时表示为文件的第一个分片. 这将有助于视频的边下边播. --enable-http-pipelining 选项有助于减少重连接的开销. 请注意, aria2 依赖于 --min-split-size 选项, 所以有必要对 --min-split-size 选项设置一个合理的值. 如果设置为&#34;随机&#34;, aria2 将随机选择一个分片. 就像&#34;顺序&#34;一样, 依赖于 --min-split-size 选项. 如果设置为&#34;几何&#34;, aria2 会先选择索引最小的分片, 然后会为之前选择的分片保留指数增长的空间. 这将减少建立连接的次数, 同时文件开始部分将会先行下载. 这也有助于视频的边下边播.</span>
<span style="color:#75715e">#stream-piece-selector=default</span>

<span style="color:#75715e"># 最小速度限制</span>
<span style="color:#75715e"># 当下载速度低于此选项设置的值(B/s) 时将会关闭连接. 0 表示不设置最小速度限制. 您可以增加数值的单位 K 或 M (1K = 1024, 1M = 1024K). 此选项不会影响 BT 下载.</span>
lowest-speed-limit<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>

<span style="color:#75715e"># 全局最大下载速度</span>
<span style="color:#75715e"># 设置全局最大下载速度 (字节/秒). 0 表示不限制. 您可以增加数值的单位 K 或 M (1K = 1024, 1M = 1024K).</span>
max-overall-download-limit<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>

<span style="color:#75715e"># 最大下载速度</span>
<span style="color:#75715e"># 设置每个任务的最大下载速度 (字节/秒). 0 表示不限制. 您可以增加数值的单位 K 或 M (1K = 1024, 1M = 1024K).</span>
max-download-limit<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>

<span style="color:#75715e"># 禁用 IPv6, 默认:false</span>
disable-ipv6<span style="color:#f92672">=</span>true

<span style="color:#75715e"># 支持 GZip</span>
<span style="color:#75715e"># 如果远程服务器的响应头中包含 Content-Encoding: gzip 或 Content-Encoding: deflate , 将发送包含 Accept: deflate, gzip 的请求头并解压缩响应.</span>
http-accept-gzip<span style="color:#f92672">=</span>true

<span style="color:#75715e"># URI 复用</span>
<span style="color:#75715e"># 当所有给定的 URI 地址都已使用, 继续使用已经使用过的 URI 地址.</span>
reuse-uri<span style="color:#f92672">=</span>false

<span style="color:#75715e"># URI 选择算法</span>
<span style="color:#75715e"># 指定 URI 选择的算法. 可选的值包括 &#34;按顺序&#34;, &#34;反馈&#34; 和 &#34;自适应&#34;. 如果设置为&#34;按顺序&#34;, URI 将按列表中出现的顺序使用. 如果设置为&#34;反馈&#34;, aria2 将根据之前的下载速度选择 URI 列表中下载速度最快的服务器. 同时也将有效跳过无效镜像. 之前统计的下载速度将作为服务器状态文件的一部分, 参见 --server-stat-of 和 --server-stat-if 选项. 如果设置为&#34;自适应&#34;, 将从最好的镜像和保留的连接里选择一项. 补充说明, 其返回的镜像没有被测试过, 同时如果每个镜像都已经被测试过时, 返回的镜像还会被重新测试. 否则, 其将不会选择其他镜像. 例如&#34;反馈&#34;, 其使用服务器状态文件.</span>
<span style="color:#75715e">#uri-selector=feedback</span>

<span style="color:#75715e"># 禁用 netrc，默认:false</span>
no-netrc<span style="color:#f92672">=</span>true

<span style="color:#75715e"># .netrc 文件路径</span>
<span style="color:#75715e">#netrc-path=$(HOME)/.netrc</span>

<span style="color:#75715e"># 允许覆盖</span>
<span style="color:#75715e"># 如果相应的控制文件不存在时从头重新下载文件. 参见 --auto-file-renaming 选项.</span>
allow-overwrite<span style="color:#f92672">=</span>false

<span style="color:#75715e"># 文件自动重命名。默认:true</span>
<span style="color:#75715e"># 重新命名已经存在的文件. 此选项仅对 HTTP(S)/FTP 下载有效. 新的文件名后会在文件名后、扩展名 (如果有) 前追加句点和数字(1..9999).</span>
auto-file-renaming<span style="color:#f92672">=</span>true

<span style="color:#75715e"># 使用 UTF-8 处理 Content-Disposition，默认:false</span>
<span style="color:#75715e"># 处理 &#34;Content-Disposition&#34; 头中的字符串时使用 UTF-8 字符集来代替 ISO-8859-1, 例如, 文件名参数, 但不是扩展版本的文件名.</span>
content-disposition-default-utf8<span style="color:#f92672">=</span>true

<span style="color:#75715e"># 最低 TLS 版本，可选：TLSv1.1、TLSv1.2、TLSv1.3 默认:TLSv1.2</span>
<span style="color:#75715e">#min-tls-version=TLSv1.2</span>


<span style="color:#75715e">## BT/PT 下载设置 ##</span>

<span style="color:#75715e"># BT 监听端口(TCP), 默认:6881-6999</span>
<span style="color:#75715e"># 设置 BT 下载的 TCP 端口. 多个端口可以使用逗号 &#34;,&#34; 分隔, 例如: 6881,6885. 您还可以使用短横线 &#34;-&#34; 表示范围: 6881-6999, 或可以一起使用: 6881-6889, 6999.</span>
<span style="color:#75715e"># 直通外网的设备，比如 VPS ，务必配置防火墙和安全组策略允许此端口入站</span>
<span style="color:#75715e"># 内网环境的设备，比如 NAS ，除了防火墙设置，还需在路由器设置外网端口转发到此端口</span>
listen-port<span style="color:#f92672">=</span><span style="color:#ae81ff">51413</span>

<span style="color:#75715e"># DHT 网络与 UDP tracker 监听端口(UDP), 默认:6881-6999</span>
<span style="color:#75715e"># 设置 DHT (IPv4, IPv6) 和 UDP 服务器使用的 UCP 端口. 多个端口可以使用逗号 &#34;,&#34; 分隔, 例如: 6881,6885. 您还可以使用短横线 &#34;-&#34; 表示范围: 6881-6999, 或可以一起使用: 6881-6889, 6999.</span>
<span style="color:#75715e"># 因协议不同，可以与 BT 监听端口使用相同的端口，方便配置防火墙和端口转发策略。</span>
dht-listen-port<span style="color:#f92672">=</span><span style="color:#ae81ff">51413</span>

<span style="color:#75715e"># 启用 DHT (IPv4), 默认:true</span>
<span style="color:#75715e"># 启用 IPv4 DHT 功能. 此选项同时会启用 UDP 服务器支持. PT 下载(私有种子)会自动禁用</span>
enable-dht<span style="color:#f92672">=</span>true

<span style="color:#75715e"># 启用 DHT (IPv6)，默认:false</span>
<span style="color:#75715e"># 启用 IPv6 DHT 功能. 如果种子设置为私有, 即使此选项设置为&#34;是&#34;, aria2 也不会启用 DHT. 使用 --dht-listen-port 选项设置监听的端口.</span>
<span style="color:#75715e"># 在没有 IPv6 支持的环境开启可能会导致 DHT 功能异常</span>
enable-dht6<span style="color:#f92672">=</span>false

<span style="color:#75715e"># 外部 IP 地址</span>
<span style="color:#75715e"># 指定用在 BitTorrent 下载和 DHT 中的外部 IP 地址. 它可能被发送到 BitTorrent 服务器. 对于 DHT, 此选项将会报告本地节点正在下载特定的种子. 这对于在私有网络中使用 DHT 非常关键. 虽然这个方法叫外部, 但其可以接受各种类型的 IP 地址.</span>
<span style="color:#75715e"># 使用场景：在家庭宽带没有公网 IP 的情况下可以把 BT 和 DHT 监听端口转发至具有公网 IP 的服务器，在此填写服务器的 IP ，可以提升 BT 下载速率。</span>
<span style="color:#75715e">#bt-external-ip=</span>

<span style="color:#75715e"># DHT (IPv4) 文件，默认：$HOME/.aria2/dht.dat</span>
<span style="color:#75715e"># 修改 IPv4 DHT 路由表文件路径.</span>
dht-file-path<span style="color:#f92672">=</span>/home/kurome/.aria2/dht.dat

<span style="color:#75715e"># DHT (IPv6) 文件，默认：$HOME/.aria2/dht6.dat</span>
<span style="color:#75715e"># 修改 IPv6 DHT 路由表文件路径.</span>
dht-file-path6<span style="color:#f92672">=</span>/home/kurome/.aria2/dht6.dat

<span style="color:#75715e"># IPv4 DHT 网络引导节点</span>
dht-entry-point<span style="color:#f92672">=</span>dht.transmissionbt.com:6881

<span style="color:#75715e"># IPv6 DHT 网络引导节点</span>
dht-entry-point6<span style="color:#f92672">=</span>dht.transmissionbt.com:6881

<span style="color:#75715e"># 启用本地节点发现(LPD),PT 下载(私有种子)会自动禁用,默认:false</span>
bt-enable-lpd<span style="color:#f92672">=</span>true

<span style="color:#75715e"># 指定用于本地节点发现的接口，可能的值：接口，IP地址</span>
<span style="color:#75715e"># 如果未指定此选项，则选择默认接口。</span>
<span style="color:#75715e">#bt-lpd-interface=</span>

<span style="color:#75715e"># 启用节点交换, 默认:true</span>
<span style="color:#75715e"># 启用节点交换扩展. 如果种子设置为私有, 即使此选项设置为&#34;是&#34;, aria2 也不会启用此功能.</span>
enable-peer-exchange<span style="color:#f92672">=</span>true

<span style="color:#75715e"># BT 下载最大连接数（单任务），运行时可修改。0 为不限制，默认:55</span>
<span style="color:#75715e"># 理想情况下连接数越多下载越快，但在实际情况是只有少部分连接到的做种者上传速度快，其余的上传慢或者不上传。</span>
<span style="color:#75715e"># 如果不限制，当下载非常热门的种子或任务数非常多时可能会因连接数过多导致进程崩溃或网络阻塞。</span>
<span style="color:#75715e"># 进程崩溃：如果设备 CPU 性能一般，连接数过多导致 CPU 占用过高，因资源不足 Aria2 进程会强制被终结。</span>
<span style="color:#75715e"># 网络阻塞：在内网环境下，即使下载没有占满带宽也会导致其它设备无法正常上网。因远古低性能路由器的转发性能瓶颈导致。</span>
bt-max-peers<span style="color:#f92672">=</span><span style="color:#ae81ff">128</span>

<span style="color:#75715e"># BT 下载期望速度值（单任务），运行时可修改。单位 K 或 M 。默认:50K</span>
<span style="color:#75715e"># BT 下载速度低于此选项值时会临时提高连接数来获得更快的下载速度，不过前提是有更多的做种者可供连接。</span>
<span style="color:#75715e"># 实测临时提高连接数没有上限，但不会像不做限制一样无限增加，会根据算法进行合理的动态调节。</span>
bt-request-peer-speed-limit<span style="color:#f92672">=</span>10M

<span style="color:#75715e"># 全局最大上传速度, 运行时可修改, 默认:0 (无限制)</span>
<span style="color:#75715e"># 设置全局最大上传速度 (字节/秒). 0 表示不限制. 您可以增加数值的单位 K 或 M (1K = 1024, 1M = 1024K).</span>
<span style="color:#75715e"># 设置过低可能影响 BT 下载速度</span>
max-overall-upload-limit<span style="color:#f92672">=</span>2M

<span style="color:#75715e"># 单任务上传速度限制, 默认:0 (无限制)</span>
<span style="color:#75715e"># 设置每个任务的最大上传速度 (字节/秒). 0 表示不限制. 您可以增加数值的单位 K 或 M (1K = 1024, 1M = 1024K).</span>
max-upload-limit<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>

<span style="color:#75715e"># 最小分享率, 0 为一直做种, 默认:1.0</span>
<span style="color:#75715e"># 指定分享率. 当分享率达到此选项设置的值时会完成做种. 强烈建议您将此选项设置为大于等于 1.0. 如果您想不限制分享比率, 可以设置为 0.0. 如果同时设置了 --seed-time 选项, 当任意一个条件满足时将停止做种.</span>
seed-ratio<span style="color:#f92672">=</span>1.0

<span style="color:#75715e"># 最小做种时间（分钟）</span>
<span style="color:#75715e"># 此选项设置为 0 时, 将在 BT 任务下载完成后不进行做种.</span>
seed-time<span style="color:#f92672">=</span><span style="color:#ae81ff">30</span>

<span style="color:#75715e"># 做种前检查文件哈希, 默认:true</span>
<span style="color:#75715e"># 如果设置为&#34;是&#34;, 当使用 --check-integrity 选项完成哈希检查及文件完成后才继续做种. 如果您希望仅当文件损坏或未完成时检查文件, 请设置为&#34;否&#34;. 此选项仅对 BT 下载有效</span>
bt-hash-check-seed<span style="color:#f92672">=</span>true

<span style="color:#75715e"># 继续之前的BT任务时, 无需再次校验, 默认:false</span>
<span style="color:#75715e"># 不检查之前下载文件中每个分片的哈希值.</span>
bt-seed-unverified<span style="color:#f92672">=</span>false

<span style="color:#75715e"># BT tracker 服务器连接超时时间（秒）。默认：60</span>
<span style="color:#75715e"># 建立连接后，此选项无效，将使用 bt-tracker-timeout 选项的值</span>
bt-tracker-connect-timeout<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>

<span style="color:#75715e"># BT tracker 服务器超时时间（秒）。默认：60</span>
bt-tracker-timeout<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>

<span style="color:#75715e"># BT 服务器连接间隔时间。默认：0 (自动)</span>
<span style="color:#75715e"># 设置请求 BT 服务器的间隔时间 (秒). 此选项将完全覆盖服务器返回的最小间隔时间和间隔时间, aria2 仅使用此选项的值.如果设置为 0, aria2 将根据服务器的响应情况和下载进程决定时间间隔.</span>
<span style="color:#75715e">#bt-tracker-interval=0</span>

<span style="color:#75715e"># BT 下载优先下载文件开头或结尾</span>
<span style="color:#75715e"># 尝试先下载每个文件开头或结尾的分片. 此选项有助于预览文件. 参数可以包括两个关键词: head 和 tail. 如果包含两个关键词, 需要使用逗号分隔. 每个关键词可以包含一个参数, SIZE. 例如, 如果指定 head=SIZE, 每个文件的最前 SIZE 数据将会获得更高的优先级. tail=SIZE 表示每个文件的最后 SIZE 数据. SIZE 可以包含 K 或 M (1K = 1024, 1M = 1024K).</span>
bt-prioritize-piece<span style="color:#f92672">=</span>head<span style="color:#f92672">=</span>32M,tail<span style="color:#f92672">=</span>32M

<span style="color:#75715e"># 保存通过 WebUI(RPC) 上传的种子文件(.torrent)，默认:true</span>
<span style="color:#75715e"># 在 dir 选项设置的目录中保存上传的种子文件或 Metalink 文件. 文件名包括 SHA-1 哈希后的元数据和扩展名两部分. 对于种子文件, 扩展名为 &#39;.torrent&#39;. 对于 Metalink 为 &#39;.meta4&#39;. 如果此选项设置为&#34;否&#34;, 通过 aria2.addTorrent() 或 aria2.addMetalink() 方法添加的下载将无法通过 --save-session 选项保存.</span>
<span style="color:#75715e"># 所有涉及种子文件保存的选项都建议开启，不保存种子文件有任务丢失的风险。</span>
<span style="color:#75715e"># 通过 RPC 自定义临时下载目录可能不会保存种子文件。</span>
rpc-save-upload-metadata<span style="color:#f92672">=</span>true

<span style="color:#75715e"># 下载种子文件(.torrent)自动开始下载, 默认:true，可选：false|mem</span>
<span style="color:#75715e"># true：保存种子文件</span>
<span style="color:#75715e"># false：仅下载种子文件</span>
<span style="color:#75715e"># mem：将种子保存在内存中</span>
<span style="color:#75715e"># 如果设置为&#34;是&#34;或&#34;仅内存&#34;, 当后缀为 .torrent 或内容类型为 application/x-bittorrent 的文件下载完成时, aria2 将按种子文件读取并下载该文件中提到的文件. 如果设置为&#34;仅内存&#34;, 该种子文件将不会写入到磁盘中, 而仅会存储在内存中. 如果设置为&#34;否&#34;, 则 .torrent 文件会下载到磁盘中, 但不会按种子文件读取并且其中的文件不会进行下载.</span>
follow-torrent<span style="color:#f92672">=</span>true

<span style="color:#75715e"># 种子文件下载完后暂停任务，默认：false</span>
<span style="color:#75715e"># 在开启 follow-torrent 选项后下载种子文件或磁力会自动开始下载任务进行下载，而同时开启当此选项后会建立相关任务并暂停。</span>
pause-metadata<span style="color:#f92672">=</span>false

<span style="color:#75715e"># 保存磁力链接元数据为种子文件(.torrent), 默认:false</span>
<span style="color:#75715e"># 保存种子文件为 &#34;.torrent&#34; 文件. 此选项仅对磁链生效. 文件名为十六进制编码后的哈希值及 &#34;.torrent&#34;后缀. 保存的目录与下载文件的目录相同. 如果相同的文件已存在, 种子文件将不会保存.</span>
bt-save-metadata<span style="color:#f92672">=</span>true

<span style="color:#75715e"># 加载已保存的元数据文件(.torrent)，默认:false</span>
<span style="color:#75715e"># 当使用磁链下载时, 在从 DHT 获取种子元数据之前, 首先尝试加载使用 --bt-save-metadata 选项保存的文件. 如果文件加载成功, 则不会从 DHT 下载元数据.</span>
bt-load-saved-metadata<span style="color:#f92672">=</span>true

<span style="color:#75715e"># 删除 BT 下载任务中未选择文件，默认:false</span>
<span style="color:#75715e"># 当 BT 任务完成后删除未选择的文件. 要选择需要下载的文件, 请使用 --select-file 选项. 如果没有选择, 则所有文件都默认为需要下载. 此选项会从磁盘上直接删除文件, 请谨慎使用此选项.</span>
bt-remove-unselected-file<span style="color:#f92672">=</span>true

<span style="color:#75715e"># BT强制加密, 默认: false</span>
<span style="color:#75715e"># 启用后将拒绝旧的 BT 握手协议并仅使用混淆握手及加密。可以解决部分运营商对 BT 下载的封锁，且有一定的防版权投诉与迅雷吸血效果。</span>
<span style="color:#75715e"># 此选项相当于后面两个选项(bt-require-crypto=true, bt-min-crypto-level=arc4)的快捷开启方式，但不会修改这两个选项的值。</span>
bt-force-encryption<span style="color:#f92672">=</span>true

<span style="color:#75715e"># BT加密需求，默认：false</span>
<span style="color:#75715e"># 启用后拒绝与旧的 BitTorrent 握手协议(\19BitTorrent protocol)建立连接，始终使用混淆处理握手。</span>
<span style="color:#75715e">#bt-require-crypto=true</span>

<span style="color:#75715e"># BT最低加密等级，可选：plain（明文），arc4（加密），默认：plain</span>
<span style="color:#75715e"># 设置加密方法的最小级别. 如果节点提供多种加密方法, aria2 将选择满足给定级别的最低级别.</span>
<span style="color:#75715e">#bt-min-crypto-level=arc4</span>

<span style="color:#75715e"># 分离仅做种任务，默认：false</span>
<span style="color:#75715e"># 从正在下载的任务中排除已经下载完成且正在做种的任务，并开始等待列表中的下一个任务。</span>
<span style="color:#75715e"># 统计当前活动下载任务(参见 -j 选项) 时排除仅做种的任务. 这意味着, 如果参数设置为 -j3, 此选项打开并且当前有 3 个正在活动的任务, 并且其中有 1 个进入做种模式, 那么其会从正在下载的数量中排除(即数量会变为 2), 在队列中等待的下一个任务将会开始执行. 但要知道, 在 RPC 方法中, 做种的任务仍然被认为是活动的下载任务.</span>
bt-detach-seed-only<span style="color:#f92672">=</span>true

<span style="color:#75715e">## 客户端伪装 ##</span>

<span style="color:#75715e"># 自定义 User Agent</span>
user-agent<span style="color:#f92672">=</span>Mozilla/5.0 <span style="color:#f92672">(</span>Windows NT 10.0; Win64; x64<span style="color:#f92672">)</span> AppleWebKit/537.36 <span style="color:#f92672">(</span>KHTML, like Gecko<span style="color:#f92672">)</span> Chrome/93.0.4577.63 Safari/537.36 Edg/93.0.961.47

<span style="color:#75715e"># BT 客户端伪装</span>
<span style="color:#75715e"># PT 下载需要保持 user-agent 和 peer-agent 两个参数一致</span>
<span style="color:#75715e"># 部分 PT 站对 Aria2 有特殊封禁机制，客户端伪装不一定有效，且有封禁账号的风险。</span>
<span style="color:#75715e"># 自定义 User Agent，默认：aria2/$VERSION</span>
<span style="color:#75715e">#user-agent=Deluge 1.3.15</span>
<span style="color:#75715e"># Peer Agent</span>
<span style="color:#75715e"># 指定 BT 扩展握手期间用于节点客户端版本的字符串.</span>
peer-agent<span style="color:#f92672">=</span>Deluge 1.3.15
<span style="color:#75715e"># 节点 ID 前缀</span>
<span style="color:#75715e"># 指定节点 ID 的前缀. BT 中节点 ID 长度为 20 字节. 如果超过 20 字节, 将仅使用前 20 字节. 如果少于 20 字节, 将在其后不足随机的数据保证为 20 字节.</span>
peer-id-prefix<span style="color:#f92672">=</span>-DE13F0-

<span style="color:#75715e">## 执行额外命令 ##</span>

<span style="color:#75715e"># 下载停止后执行的命令</span>
<span style="color:#75715e"># 从 正在下载 到 删除、错误、完成 时触发。暂停被标记为未开始下载，故与此项无关。</span>
<span style="color:#75715e">#on-download-stop=/home/kurome/.aria2/delete.sh</span>

<span style="color:#75715e"># 下载完成后执行的命令</span>
<span style="color:#75715e"># 此项未定义则执行 下载停止后执行的命令 (on-download-stop)</span>
<span style="color:#75715e">#on-download-complete=/home/kurome/.aria2/clean.sh</span>

<span style="color:#75715e"># 下载错误后执行的命令</span>
<span style="color:#75715e"># 此项未定义则执行 下载停止后执行的命令 (on-download-stop)</span>
<span style="color:#75715e">#on-download-error=</span>

<span style="color:#75715e"># 下载暂停后执行的命令</span>
<span style="color:#75715e">#on-download-pause=</span>

<span style="color:#75715e"># 下载开始后执行的命令</span>
<span style="color:#75715e">#on-download-start=</span>

<span style="color:#75715e"># BT 下载完成后执行的命令</span>
<span style="color:#75715e">#on-bt-download-complete=</span>


<span style="color:#75715e">## RPC 设置 ##</span>

<span style="color:#75715e"># 启用 JSON-RPC/XML-RPC 服务器, 默认:false</span>
enable-rpc<span style="color:#f92672">=</span>true

<span style="color:#75715e"># 接受所有远程请求, 默认:false</span>
<span style="color:#75715e"># 在 RPC 响应头增加 Access-Control-Allow-Origin 字段, 值为 * .web界面跨域权限需要</span>
rpc-allow-origin-all<span style="color:#f92672">=</span>true

<span style="color:#75715e"># 允许外部访问, 默认:false</span>
rpc-listen-all<span style="color:#f92672">=</span>true

<span style="color:#75715e"># RPC 监听端口, 默认:6800</span>
rpc-listen-port<span style="color:#f92672">=</span><span style="color:#ae81ff">6800</span>

<span style="color:#75715e"># RPC 密钥, v1.18.4新增功能, 取代 --rpc-user 和 --rpc-passwd 选项</span>
rpc-secret<span style="color:#f92672">=</span>SetForYourself

<span style="color:#75715e"># RPC 最大请求大小</span>
<span style="color:#75715e"># 设置 JSON-RPC/XML-RPC 最大的请求大小. 如果 aria2 检测到请求超过设定的字节数, 会直接取消连接.</span>
rpc-max-request-size<span style="color:#f92672">=</span>10M

<span style="color:#75715e"># RPC 服务 SSL/TLS 加密, 默认：false</span>
<span style="color:#75715e"># RPC 将通过 SSL/TLS 加密传输. RPC 客户端需要使用 https 协议连接服务器. 对于 WebSocket 客户端, 使用 wss 协议. 使用 --rpc-certificate 和 --rpc-private-key 选项设置服务器的证书和私钥.</span>
<span style="color:#75715e"># 不推荐开启，建议使用 web server 反向代理，比如 Nginx、Caddy ，灵活性更强。</span>
<span style="color:#75715e">#rpc-secure=</span>

<span style="color:#75715e"># 在 RPC 服务中启用 SSL/TLS 加密时的证书文件,</span>
<span style="color:#75715e"># 使用 PEM 格式时，您必须通过 --rpc-private-key 指定私钥</span>
<span style="color:#75715e">#rpc-certificate=/path/to/certificate.pem</span>

<span style="color:#75715e"># 在 RPC 服务中启用 SSL/TLS 加密时的私钥文件</span>
<span style="color:#75715e">#rpc-private-key=/path/to/certificate.key</span>

<span style="color:#75715e"># 事件轮询方式, 可选：epoll, kqueue, port, poll, select, 不同系统默认值不同</span>
<span style="color:#75715e"># 设置事件轮训的方法. 对于 epoll, kqueue, port 和 poll, 只有系统支持时才可用. 最新的 Linux 支持 epoll. 各种 *BSD 系统包括 Mac OS X 支持 kqueue. Open Solaris 支持 port. 默认值根据您使用的操作系统不同而不同.</span>
<span style="color:#75715e">#event-poll=select</span>

<span style="color:#75715e">## 高级选项 ##</span>

<span style="color:#75715e"># 启用异步 DNS 功能。默认：true</span>
<span style="color:#75715e">#async-dns=true</span>

<span style="color:#75715e"># 指定异步 DNS 服务器列表，未指定则从 /etc/resolv.conf 中读取。</span>
<span style="color:#75715e">#async-dns-server=119.29.29.29,223.5.5.5,8.8.8.8,1.1.1.1</span>

<span style="color:#75715e"># 指定单个网络接口，可能的值：接口，IP地址，主机名</span>
<span style="color:#75715e"># 如果接口具有多个 IP 地址，则建议指定 IP 地址。</span>
<span style="color:#75715e"># 已知指定网络接口会影响依赖本地 RPC 的连接的功能场景，即通过 localhost 和 127.0.0.1 无法与 Aria2 服务端进行讯通。</span>
<span style="color:#75715e">#interface=</span>

<span style="color:#75715e"># 指定多个网络接口，多个值之间使用逗号(,)分隔。</span>
<span style="color:#75715e"># 使用 interface 选项时会忽略此项。</span>
<span style="color:#75715e">#multiple-interface=</span>

<span style="color:#75715e">## 日志设置 ##</span>

<span style="color:#75715e"># 日志文件保存路径，默认：不保存</span>
<span style="color:#75715e"># 如果设置为 &#34;-&#34;, 日志则写入到 stdout. 如果忽略或设置为空字符串(&#34;&#34;), 日志将不会记录到磁盘上.</span>
<span style="color:#75715e">#log=</span>

<span style="color:#75715e"># 日志级别，可选 debug, info, notice, warn, error 。默认：debug</span>
<span style="color:#75715e">#log-level=warn</span>

<span style="color:#75715e"># 控制台日志级别，可选 debug, info, notice, warn, error ，默认：notice</span>
console-log-level<span style="color:#f92672">=</span>notice

<span style="color:#75715e"># 安静模式，禁止在控制台输出日志，默认：false</span>
quiet<span style="color:#f92672">=</span>false

<span style="color:#75715e"># 下载进度摘要输出间隔时间（秒），0 为禁止输出。默认：60</span>
summary-interval<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>

<span style="color:#75715e">## BitTorrent trackers ##</span>

<span style="color:#75715e"># BT 服务器地址 2022/02/26</span>
<span style="color:#75715e"># 逗号分隔的 BT 服务器地址. 如果服务器地址在 --bt-exclude-tracker 选项中, 其将不会生效.</span>
bt-tracker<span style="color:#f92672">=</span>udp://open.tracker.cl:1337/announce,udp://tracker.opentrackr.org:1337/announce,udp://9.rarbg.com:2810/announce,udp://www.torrent.eu.org:451/announce,udp://tracker2.dler.org:80/announce,udp://tracker.torrent.eu.org:451/announce,udp://tracker.moeking.me:6969/announce,udp://tracker.bitsearch.to:1337/announce,udp://tracker.0x.tf:6969/announce,udp://tracker-udp.gbitt.info:80/announce,udp://tr.cili001.com:8070/announce,udp://retracker.lanta-net.ru:2710/announce,udp://open.stealth.si:80/announce,udp://ipv4.tracker.harry.lu:80/announce,udp://explodie.org:6969/announce,udp://exodus.desync.com:6969/announce,udp://bt2.archive.org:6969/announce,udp://bt1.archive.org:6969/announce,https://tracker.nanoha.org:443/announce,https://tracker.lilithraws.org:443/announce
</code></pre></div><p>更多：<a href="https://github.com/P3TERX/aria2.conf">Aria2 完美配置</a></p>
<p><strong>Aria2 Web 控制台</strong></p>
<p>Aira2 没有软件界面，程序员可以用代码执行任务，但普通用户怎样添加下载任务呢？——打开浏览器，输入网址<code>aria2c.com</code>（<a href="https://github.com/binux/yaaw">YAAW</a> 的中文版）就可以打开 Aria2 Web 控制台。</p>
<p><code>JSON-RPC Path</code> 默认为: <code>http://localhost:6800/jsonrpc</code>，如果提示 “Aria2 RPC 服务器错误”，按照以下方法修改：</p>
<ul>
<li>普通情况设置为: <code>http://host:port/jsonrpc</code>
<ul>
<li><code>host</code>: 指运行 Aria2 所在机器的 IP 或者名字</li>
<li><code>port</code>: 使用 <code>--rpc-listen-port</code> 选项设置的端口, 未设置则是 <code>6800</code>；可通过 <code>lsof -i:6800</code> 查看端口是否被占用</li>
</ul>
</li>
<li>使用 <code>--rpc-secret=xxxxxx</code> 选项设置为: <code>http://token:xxxxxx@host:port/jsonrpc</code></li>
<li>使用 <code>--rpc-user=user --rpc-passwd=pwd </code>选项设置为: <code>http://user:pwd@host:port/jsonrpc</code></li>
<li>以上<code>JSON-RPC Path</code> 中的 <code>http</code> 可以用 <code>ws</code> 替代, 代表使用 <code>WebSocket 协议</code>。换用  <code>ws</code>  也可能解决 “Aria2 RPC 服务器错误”。</li>
<li>当使用 <a href="https://aria2c.com/">https://aria2c.com</a> 访问时, 可能需要使用 <code>https</code> 或 <code>wss</code> 协议。</li>
</ul>
<p>在 Web UI  中对 Aria2 的设置会在 Aria2 重启后丢失,，必要的设置请写入配置文件。</p>
<p>已经下载完成的任务会在 Aria2 重启后消失, 除非启用了 <code>--force-save</code> 选项。</p>
<h4 id="protocolhttpszhuanlanzhihucomp85652893"><a href="https://zhuanlan.zhihu.com/p/85652893">Protocol</a><a hidden class="anchor" aria-hidden="true" href="#protocolhttpszhuanlanzhihucomp85652893">#</a></h4>
<p>**HTTP / HTTPS / FTP / SFTP **</p>
<p>超文本传输协议（HTTP / HTTPS）和 文件传输协议（FTP / SFTP）将文件放到服务器上，然后由服务器传送到不同的用户机器上，称为Client-Server Model简称C/S模式，或者叫一对多模式。</p>
<p><img loading="lazy" src="/Distributions/ClientServerModel.png" alt="img"  />
</p>
<p>缺点是：当非常多的用户同时访问和下载服务器上的文件时，由于服务器处理能力和带宽的限制，下载速度会急剧下降，有的用户可能访问不了服务器。</p>
<p><a href="https://www.cnblogs.com/wpjamer/articles/10788222.html"><strong>BitTorrent 协议</strong></a></p>
<p>BitTorrent(简称BT)是一个文件分发协议，每个下载者在下载的同时不断向其他下载者上传已下载的数据。BT协议与FTP协议不同，特点是下载的人越多，下载速度越快，原因在于每个下载者将已下载的数据提供给其他下载者下载，充分利用了用户的上载带宽。通过一定的策略保证上传速度越快，下载速度也越快。在很短时间内，BitTorrent协议成为一种新的变革技术。</p>
<p>BitTorrent 的发展依赖于对等网络 (Peer - to - Peer 简称 P2P)。P2P技术体现了互联网最根本的内涵——自由和免费，它的主要优点如下：</p>
<ul>
<li>对等性高：非中心化，互联网回归本色——联系和传输；</li>
<li>扩展性强：用户扩展与资源、服务、系统同步扩展；</li>
<li>健壮性高：服务分散和自适应，耐攻击、高容错性；</li>
<li>性价比高：P2P成本低、存储和技术能力强；</li>
<li>负载均衡：分布存储和技术，整个网络负载得以均衡。</li>
</ul>
<p>在P2P网络中，每个参与的节点既是服务器又是客户端，既是信息的提供者又是信息的消费者。P2P信息检索的目的就是网络中的任意节点都可以提交检索的请求，然后这些检索通过相关信息的节点将会回应请求，按照某种路由机制路由到本地相关的内容，以对等的形式直接传送到请求节点上。</p>
<p>检索过程分为以下几个阶段：每个节点在加入网络的时候，会对存储在本节点上的内容进行索引，以满足本地内容检索的目的。然后按某种预定的规则选择一些节点作为自己的邻居，加入到P2P网络当中。发起者P提出检索请求q，并将q发送给自己的邻居，P的邻居收到q后，再按照某种策略转发给它在网络中的其它邻居节点。这样，q就在整个网络中传播开来。收到请求q的节点如果存储有相应内容信息 , 则将对应的内容返回。</p>
<p><img loading="lazy" src="/Distributions/P2PModel.png" alt="img"  />
</p>
<p>普通的HTTP/FTP下载使用TCP/IP协议，BitTorrent协议是架构于TCP/IP协议之上的一个P2P文件传输协议，处于TCP/IP结构的应用层。 BitTorrent协议本身也包含了很多具体的内容协议和扩展协议，并在不断扩充中。</p>
<p>根据BitTorrent协议，文件发布者会根据要发布的文件生成提供一个.torrent文件，即种子文件，也简称为“种子”。</p>
<p>种子还有如下相关概念：</p>
<ul>
<li>发布BT种子的人，做种多少天指的就是持续多少天不撤种。这期间如果有别人下完了，就叫出种。下完的人可以继续做种。这时发布种子的人就可以不做种了，叫撤种。</li>
<li>一个资源只要有一个人在做种，那就其他人就可以继续下。如果没人做种了，叫断种，这是资源就死了，下不了了。某人长时间一直做种，叫保种。</li>
</ul>
<p>.torrent文件本质上是文本文件，包含<a href="https://github.com/XIU2/TrackersListCollection">Tracker信息</a>和文件信息两部分。Tracker信息主要是BT下载中需要用到的Tracker服务器的地址和针对Tracker服务器的设置，文件信息是根据对目标文件的计算生成的，计算结果根据BitTorrent协议内的B编码规则进行编码。它的主要原理是需要把提供下载的文件虚拟分成大小相等的块，块大小必须为2k的整数次方（由于是虚拟分块，硬盘上并不产生各个块文件），并把每个块的索引信息和Hash验证码写入种子文件（.torrent）中。所以，种子文件（.torrent）就是被下载文件的“索引”。</p>
<p>下载者要下载文件内容，需要先得到相应的.torrent文件，然后使用BT客户端软件进行下载。</p>
<p>下载时，BT客户端首先解析.torrent文件得到Tracker地址，然后连接Tracker服务器。Tracker服务器回应下载者的请求，提供下载者其他下载者（包括发布者）的IP。下载者再连接其他下载者，根据.torrent文件，两者分别对方告知自己已经有的块，然后交换对方没有的数据。此时不需要其他服务器参与，分散了单个线路上的数据流量，因此减轻了服务器负担。</p>
<p>下载者每得到一个块，需要算出下载块的Hash验证码与.torrent文件中的对比，如果一样则说明块正确，不一样则需要重新下载这个块。这种规定是为了解决下载内容准确性的问题。</p>
<p>从 BT 客户端角度考虑，下载原理分为以下几步：</p>
<ol>
<li>根据 BitTorrent 协议，文件发布者会根据要发布的文件生成提供一个 .torrent 文件。客户端可从 Web 服务器上下载种子文件，并从中得到 Tracker 服务器 URL。</li>
<li>根据 Tracker URL 与 Tracker 服务器建立连接，并从服务器上得到 Peers 信息。</li>
<li>根据 Peers 信息与一个 Peer 建立连接，依据 Peer wire 协议完成握手，并从 Peer 端下载数据文件。同时监听 Peer 的连接，并给 Peer 上传数据文件。</li>
</ol>
<p>迅雷，俗称吸血雷：</p>
<ul>
<li>吸血就是指一些客户端在进行P2P下载时，从其它客户端下载的数据量非常多，但是分享给其它客户端的数据非常少，下载完成后立即关机走人的行为</li>
<li>而迅雷就是这样的一个下载器，迅雷的服务器疯狂索取资源，但自己又不上传资源给别人），当收集了大量资源后，进而下载限速，开启付费会员制度</li>
</ul>
<p>BT下载讲究共享精神，这跟互联网的共享精神一脉相承，所以请不要在BT下载器设置里面限制上传速度。</p>
<p>鉴于这类自私行为对其它合理使用P2P网络的用户的伤害，现在的很多P2P软件都加入反吸血功能。就是说检测到特定用户的吸血行为或者吸血软件时自动对这些用户降权处理，简单来说就是你的上传速度低的话，你的下载速度也不会特别快。</p>
<p>这里又要多嘴一句</p>
<ul>
<li>迅雷靠着自身在国内多年的发展，服务器里囤积了大量资源，所以很多其他BT下载器下载不动的资源，可能只有迅雷下载的动（因为它原来从别人那里下载了后存在了它的服务器上）</li>
<li>同理，很多文件可能只有115才能能离线下载，也是因为当年的115就存储了大量的资源在它服务器上</li>
<li>这里顺便可以说一下，所谓的百度云秒离线功能，不过是在你离线下载之前，已经有人把这个文件离线下载到百度云服务器中了</li>
</ul>
<p>BT下载带来的好处</p>
<ul>
<li>快。减少了网路传输节点。</li>
<li>减轻服务器压力。如果某公司有新版本软件推出（如LOL游戏更新时），服务器必定会人山人海，而使用BT能大大减轻服务器的负担，节约服务器的购置成本。</li>
<li>保护隐私。与有http那种中央服务器的网络系统不同，BT下载节点能遍布整个互联网（每个人都是分享者与下载者），给包括开发者在内的任何人、组织、或政府带来监控难题。</li>
</ul>
<p>坏处当然也有，从上面第3点不难得出，BT下载很容易导致一个问题：盗版泛滥——海盗湾。</p>
<p>上面说过了，想加入BT下载的无中心网络，首先需要找Tracker服务器问路，于是Tracker服务器成为了版权组织打击的重点，他们的想法很明确，只要除掉了Tracker，BT下载就完了。</p>
<p>然而魔高一尺道高一丈，需求带动发展，这反而促使了BT技术的一次大升级，这带来了磁力链接。</p>
<p><strong>MagNet 协议</strong></p>
<p>MagNet协议，也就是磁力链接，简称磁链。 Magnet不需要Tracker服务器，也不需要.torrent文件，仅需要一串字符就可以进行文件下载。</p>
<p>磁力链接基于的是DHT网络技术，因此可以在无固定Tracker服务器的情况下下载，实际过程是把所有下载者都变成一个小型Tracker服务。</p>
<p>DHT技术：2002年，纽约大学的两个教授Petar Maymounkov和David Mazières发表了一篇论文，提出了一种真正去中心化的“点对点”下载模型，他们将其称为Kademlia方法。2005年，BT软件开始引入这种技术，在BT中被称为DHT协议（Distributed Hash Table，分布式哈希表）。</p>
<p>DHT是一种分布式存储方法。DHT的作用是找到那些与本机正在下载（上传）相同文件的对端主机（Peer），当然，实现这一过程并不依赖Tracker服务器。在DHT网络中的每个客户端负责一个小范围的路由，并负责存储一小部分数据，从而实现整个DHT网络的寻址和存储。这种信息获取方式保证了整个网络没有单个的中心，即使一个节点下线，依然可以通过其他节点来获取文件，因此也就不需要Tracker服务器来告诉你，其他节点在什么地方。</p>
<p>PEX：是Peer Exchange的简写，我们可以将其理解为“节点信息交换”。虽然DHT解决了去中心化的问题，但要在没有“中心协调员”（Tracker）的情况下实现高效寻址，就要借助PEX。PEX所提供的功能有点类似于以前的Tracker服务器，但工作方式却非常不同，我们可以打个比方来说明：</p>
<ul>
<li>当你得到一个磁力链接并进行下载时，使用比如迅雷，迅雷就会实例化出一个DHT节点，加入DHT网络</li>
<li>把DHT网络比作一个朋友圈子，当你被A带进这个朋友圈，此刻你就只认识A而已</li>
<li>但是你的目的是想找唐纳德·特朗普（川普）总统，所以你就问A要川普的联系方式，但是A也没有川普的联系方式， 他介绍了一个美国朋友B给你认识</li>
<li>于是你去问B要川普的联系方式，B其实也没有川普的联系方式，但是B认识一个美国州长C</li>
<li>于是你又得到了C的联系方式，C把川普的联系方式告诉你之后，你就可以写信或者致电给川普了</li>
</ul>
<p>这里相关的有个有趣的理论「六度分隔理论」（也叫六度空间理论）：简单来说，就是最多通过6个中间人你就能够认识世界上任何一个陌生人。</p>
<p>Magnet links（磁力链接）示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">magnet:?xt<span style="color:#f92672">=</span>urn:btih:36684b463ca2aa2f9347b18e9f6b1a9090bdb073&amp;dn<span style="color:#f92672">=</span>Microsoft+iSCSI+Initiator
</code></pre></div><ul>
<li>magnet：协议名。</li>
<li>xt：exact topic的缩写，表示资源定位点。BTIH（BitTorrent Info Hash）表示哈希方法名，这里还可以使用SHA1和MD5。这个值是文件的标识符，是不可缺少的。</li>
<li>dn：display name的缩写，表示向用户显示的文件名。这是一个可选项。</li>
<li>tr：tracker的缩写，表示tracker服务器的地址。这是一个可选项，本例中并未出现。</li>
</ul>
<p>可能看出了DHT+PEX+Magnet Link模式中的一个问题——BT客户端的“第一步是如何迈出的”，套用在介绍PEX时使用的例子，那就是你怎怎么进入A的这个朋友圈的（即DHT节点如何进入DHT网络）？这确实是个问题。解决这个问题依然需要一台服务器（bootstrap node），不过这台服务器所起的作用与Tracker不同，它仅负责接纳DHT节点如何进入DHT网络，当DHT节点与其它DHT节点“搭上了话”，之后这台服务器就没有什么用处了。bootstrap node可以是不同BT客户端厂商独立运营的，也可以是几家联合共用，总之，它是分散的，只要在客户端软件中内置一张表单，那客户端就将有非常多的入口可供选择。</p>
<p><strong>eD2k 协议</strong></p>
<p>BT / 磁力 / eD2k都是P2P技术 。eD2k链接对应的客户端，如eMule电骡是共享软件，而Magnet磁链对应的BT软件则是下载软件。这让它们在使用上，有着很多根本性的区别：</p>
<ul>
<li>BT使用的时候，只要你不下载东西你就不会上传</li>
<li>eMule电骡不同，比如，开启eMule电骡后，第一件事做的并不是什么下载，而是设置共享目录，该目录中的所有文件，都会实时共享到eD2k网络和KAD网络中。</li>
<li>目录中共享了的文件都会生成eD2k链接，所有人通过相应的eD2k链接，都能够拿到你共享的文件，一旦有人下载相应文件，那么你的eMule客户端就会上传数据，换言之，你想下载别人的文件，需要别人开着eMule客户端</li>
<li>我们平时使用eD2k链接下载，资源也是来自他人eMule所共享的文件的。当然，共享目录中也可以啥都不放，但很多eMule客户端都拥有队列优先级机制，上传得少，下载速度也会被限制。</li>
</ul>
<p>电驴可以说是进化版的BT，用户不需要下载什么种子文件了，直接在“电驴”软件上输入eD2k开头的一长串代码一样的链接，就能下载。</p>
<p>电驴以及后来的电骡、VERYCD电驴还有各种类似的软件，采用的eD2k网络仍是基于服务器的，你需要连接到服务器并从服务器索引 / 查找用户或者文件</p>
<p>重要的是电驴提供的其中一种模式——KAD网络（类似磁力下载中的DHT网络），能够脱离中央服务器，直接实现网络来用户之间的点对点传输</p>
<p>历史证明，这个脱离中央服务器的革新，真的十分十分的重要——这是电驴软件在面对盗版问题时，能够生存下来的主要原因，因为他们可以说，那是用户之间的自发传输行为，没有经过服务器</p>
<p>但是，尽管电驴做了如此多的革新，但还是逃不过被时代淘汰的命运，客户端对于大部分人来说配置起来十分复杂，愿意一直开着服务器上传资源的人越来越少，更多人只想单纯的索取（类似上文提到的迅雷吸血行为），如今使用eD2k分享资源的人实在算少数，远不如磁力下载。</p>
<h4 id="others-1">Others<a hidden class="anchor" aria-hidden="true" href="#others-1">#</a></h4>
<p><strong><a href="https://github.com/mayswind/AriaNg">AriaNg</a></strong></p>
<p>AriaNg 是一个让 aria2 更容易使用的现代 Web 前端</p>
<ul>
<li>使用很简单，将文件下载解压即可，可以本地打开 <code>index.html</code> 文件，也可上传到服务器。</li>
<li>如果您懒得部署 AriaNg ，可以直接访问现成的 <a href="http://a2.ssss.fun/">http://a2.ssss.fun</a> 。</li>
<li>打开后需要配置 AriaNg，打开 <code>AriaNg 设置</code> - <code>RPC</code>，修改 <code>Aria2 RPC 地址</code> 和 <code>Aria2 RPC 密钥</code> ，点击 <code>重新加载 AriaNg</code> 即可。</li>
</ul>
<p><strong><a href="https://github.com/ziahamza/webui-aria2">WebUI-Aria2</a></strong></p>
<p>这个项目的目标是创建世界上最好和最热门的界面来与 aria2 交互。</p>
<p>使用非常简单，只需在任何网络浏览器中下载并打开 index.html。</p>
<p><a href="http://www.senra.me/awesome-downloader-series-aria2-almost-the-best-all-platform-downloader/"><strong>Aria2 for &hellip;.</strong></a></p>
<p>比如 <a href="https://github.com/acgotaku/YAAW-for-Chrome">YAAW for Chrome</a>、<a href="https://github.com/alexhua/Aria2-for-chrome">Aria2 for Chrome</a> 、Aria2 for Edge 之类的。</p>
<p>在浏览器中直接内置一个 AriaNg，用于直接管理 Aria2。</p>
<p><strong><a href="https://wiki.archlinux.org/title/Aria2#Using_Aria2_as_a_Daemon">Using Aria2 as a Daemon</a></strong></p>
<p>运行 <code>gnome-session-properties</code>打开应用程序首选项管理，添加：</p>
<ul>
<li>Name: Aria2 Daemon</li>
<li>Command: <code>/usr/bin/aria2c --conf-path=/home/kurome/.aria2/aria2.conf -D</code></li>
</ul>
<p>会建立 <code>.config/autostart/aria2c.desktop</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>Desktop Entry<span style="color:#f92672">]</span>
Type<span style="color:#f92672">=</span>Application
Exec<span style="color:#f92672">=</span>/usr/bin/aria2c --conf-path<span style="color:#f92672">=</span>/home/vane/.aria2/aria2.conf -D
Hidden<span style="color:#f92672">=</span>false
NoDisplay<span style="color:#f92672">=</span>false
X-GNOME-Autostart-enabled<span style="color:#f92672">=</span>true
Name<span style="color:#f92672">[</span>en_US<span style="color:#f92672">]=</span>Aria2 Daemon
Name<span style="color:#f92672">=</span>Aria2 Daemon
Comment<span style="color:#f92672">[</span>en_US<span style="color:#f92672">]=</span>
Comment<span style="color:#f92672">=</span>
</code></pre></div><p><strong><a href="http://www.senra.me/solutions-to-aria2-bt-metalink-download-slowly/">BT 下载预热</a></strong></p>
<p>是这样滴，和很多BT客户端一样，Aria2有个dht.dat文件(开启ipv6还有个dht6.dat)，这玩意用于存储一种叫做DHT Routing Table的东西，DHT网络由无数节点组成，你接触到一个后能通过它接触到更多的节点，Aria2我记得是有内置的节点，但是！如果你在Aria2第一次运行的时候直接下载磁力链接或者冷门种子，你很可能遇到连MetaData都无法获取的情况，这就是因为第一次只是初始化dht.dat文件，你本地不存在DHT Routing Table的缓存，所以你无法从DHT网络中获取足够的数据。</p>
<p>那么怎么办？我的建议是，找个热门种子(千万建议是种子，而不是磁力链接)，然后下一波，挂着做种，过几个小时后退出Aria2，或者等Aria2会话自动保存，你会发现dht.dat从空文件变成有数据了，这时候你下载就会正常很多。</p>
<p><strong><a href="https://www.cnblogs.com/wpjamer/p/4417174.html">什么是PT，PT和BT有什么不同？</a></strong></p>
<p>答：PT（Private Tracker）下载其实也是Bt下载的一种，但有两个明显的改进：一是私密的小范围下载，二是进行流量统计，根据上载量决定你的权限。</p>
<p>BT下载时，软件会分析.torrent种子文件得到Tracker地址，然后连接Tracker服务器，服务器返回其他下载者的IP，下载者再与这些IP联系进行下载，从而减轻了服务器的负担，BT下载的Tracker是公开的，而Private Tracker 下载(PT下载)的Tracker则是私有的，每个人的Tracker是不同的，即passkey不同，passkey对PT下载者很重要，所以不要轻易泄露出去。</p>
<p>其实和通常BT相比，PT就是多了一个passkey验证，这样就能保证未注册的用户不能下载。所以passkey很重要，一旦发现有问题，就要到站点上去重置passkey。Tracker Server根据passkey把BT客户端上传量和下载量进行计算，从而算出分享率(上传量/下载量)。如果分享率太小，将会被删除帐号，从而不能下载。</p>
<p>这样Private Tracker 下载(PT下载)是一种小范围的BT下载，通过禁用DHT有要求地选择并控制用户数量，这样，在有限的范围内，下载的用户基本上都可以达到自己的宽带上限，Private Tracker 下载(PT下载)下载还通过论坛等方式的约束机制将BT下载的理念现实化，真正让用户做到下载的过程中努力上传。因此，Private Tracker 下载(PT下载)的速度很快，能够让用户款待得到最大程度的使用。</p>
<p>PT通过对做种时间和流量的要求在一定程度上避免了BT中存在的下完不做种的现象，因此在网络上，尤其是需要大文件（如高清）资源交换的时候广受欢迎，在PT站里，“水管”代表上传带宽的大小，大水管可以通过快速的上传获得积分，PT站点也会采取措施（比如做种时间，优惠等）使上传较慢的小水管能够参与贡献和共享资源。</p>
<p><strong><a href="https://www.zhihu.com/question/25536695">RPC</a></strong></p>
<p>首先了解什么叫RPC，为什么要RPC，RPC是指远程过程调用，也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。</p>
<p>比如说，一个方法可能是这样定义的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Employee <span style="color:#a6e22e">getEmployeeByName</span><span style="color:#f92672">(</span>String fullName<span style="color:#f92672">)</span>
</code></pre></div><p>那么：</p>
<ul>
<li>首先，要解决通讯的问题，主要是通过在客户端和服务器之间建立TCP连接，远程过程调用的所有交换的数据都在这个连接里传输。连接可以是按需连接，调用结束后就断掉，也可以是长连接，多个远程过程调用共享同一个连接。</li>
<li>第二，要解决寻址的问题，也就是说，A服务器上的应用怎么告诉底层的RPC框架，如何连接到B服务器（如主机或IP地址）以及特定的端口，方法的名称名称是什么，这样才能完成调用。比如基于Web服务协议栈的RPC，就要提供一个endpoint URI，或者是从UDDI服务上查找。如果是RMI调用的话，还需要一个RMI Registry来注册服务的地址。</li>
<li>第三，当A服务器上的应用发起远程过程调用时，方法的参数需要通过底层的网络协议如TCP传递到B服务器，由于网络协议是基于二进制的，内存中的参数的值要序列化成二进制的形式，也就是序列化（Serialize）或编组（marshal），通过寻址和传输将序列化的二进制发送给B服务器。</li>
<li>第四，B服务器收到请求后，需要对参数进行反序列化（序列化的逆操作），恢复为内存中的表达方式，然后找到对应的方法（寻址的一部分）进行本地调用，然后得到返回值。</li>
<li>第五，返回值还要发送回服务器A上的应用，也要经过序列化的方式发送，服务器A接到后，再反序列化，恢复为内存中的表达方式，交给A服务器上的应用</li>
</ul>
<p><img loading="lazy" src="/Distributions/rpc.jpg" alt="img"  />
</p>
<p>为什么RPC呢？就是无法在一个进程内，甚至一个计算机内通过本地调用的方式完成的需求，比如比如不同的系统间的通讯，甚至不同的组织间的通讯。由于计算能力需要横向扩展，需要在多台机器组成的集群上部署应用，</p>
<p>RPC的协议有很多，比如最早的CORBA，Java RMI，Web Service的RPC风格，Hessian，Thrift，甚至Rest API。</p>
<p><strong><a href="http://www.senra.me/tag/%e4%b8%8b%e8%bd%bd%e5%b7%a5%e5%85%b7/">其他下载工具</a></strong></p>
<ul>
<li><a href="https://github.com/qbittorrent/qBittorrent">qBittorrent</a></li>
<li><a href="https://github.com/transmission/transmission">Transmission</a></li>
<li><a href="https://github.com/rakshasa/rtorrent">rTorrent</a></li>
<li><a href="https://github.com/deluge-torrent/deluge">Deluge</a></li>
</ul>
<p><strong><a href="https://github.com/aria2/aria2/issues/986">有支持ed2k的计划吗？</a></strong></p>
<p>真是笑死我了，你们难道真的认为那所谓迅雷等国产BT下载软件会使用真正的<a href="https://zh.wikipedia.org/wiki/EDonkey%E7%BD%91%E7%BB%9C">eDonkey网络</a>？</p>
<p>非也！它们只不过通过ed2k链接所列出的哈希值 <strong>直接链接到它们服务器自身（如迅雷、百度）所存储的文件</strong> 或链接到BitTorrent协议的种子和磁力链接上。你们用的软件不是P2P（Peer to Peer），而是<a href="https://zh.wikipedia.org/wiki/P2SP">P2SP</a>（Peer to <strong>Server</strong> and to Peer）！</p>
<p>如果你们用过<strong>真正</strong>的ed2k下载器（如<a href="https://zh.wikipedia.org/wiki/EMule">eMule</a>、<a href="https://zh.wikipedia.org/wiki/AMule">aMule</a>）的话，你们会发现，真正的eDonkey网络早已消亡，截至目前全球用户也就50-60万的样子。</p>
<p>最后，作为曾经的eMule老用户，我可以说明<strong>真正</strong>的eDonkey网络不仅有繁琐的排队机制，还有文件优先级网络优先级等复杂的设定，远比你们想像中难用的多。</p>
<p><a href="https://zhuanlan.zhihu.com/p/28405896"><strong>warez groups</strong></a></p>
<ul>
<li>
<p>RELOADED</p>
<p>RELOADED成立于2004年，前身是传奇破解组DEVIANCE，曾经在2次重大的政府扫荡中生存下来，由于竞争对手HOODLUM和VENGEANCE被端掉，RELOADED从此称霸PC游戏破解圈，在新游的首发破解上，RELOADED能占据80%。</p>
<p>RELOADED也是国内最常见的PC游戏破解组，你在各个资源站看到标题写着某某游戏“R组”破解，就是他们的“杰作”。</p>
<p>高光时刻：</p>
<p>1、各大破解组都在追求游戏发售前破解游戏，而RELOADED最著名的应该就是2008年对《刺客信条》的破解了，R组在游戏发售1个月之前就放出破解版。</p>
<p>2、修复了《彩虹六号：维加斯2》数字版的BUG，育碧当年对《彩虹六号：维加斯2》数字版无法运行的BUG毫无办法，最终只能给玩家发放RELOADED的游戏破解补丁&hellip;这次事件让育碧颜面扫地，却成就了RELOADED。</p>
<p>3、打破《分裂细胞：混沌理论》424天不被破解的记录。</p>
</li>
<li>
<p>SKIDROW</p>
<p>SKIDROW 是来自美国的游戏破解组，成立时间大概是上个世纪90年代，主要作品有《猎杀潜艇5》、《刺客信条2》等，之后由于人员解散，直到2007年 SKIDROW 才重新开始活跃。</p>
<p>SKIDROW 在同行中的口碑一般，被RELOADED等破解组爆出过盗用其他破解组代码的料。</p>
<p>1、 Skidrow成名于DRM事件，DRM是育碧的反破解系统，Skidrow破解组成功破解了育碧两袋DRM系统，最著名的作品是对《刺客信条2》的破解。</p>
<p>2、2017年，继CPY之后，成功破解了最新的Denuvo64加密技术。并批评CPY只会用Emulation(仿真器)而不是真正的破解。</p>
</li>
<li>
<p>Razor1911</p>
<p>Razor1911 是来自挪威的破解组，成立于1985年，最初由3个年轻的计算机爱好者组成，主要是破解Commodore64和amiga机种的游戏软件，名称中的1911是因为1991在16进制里写作777，代表不朽。</p>
<p>作为老牌破解组之一， Razor1911在2001年和2004年的FBI两次反盗版行动中幸存下来，不知道是不是因为名字带来的好运。在业内，如果说RELOADED是以高产著称，那么Razor1911就是以技术见长。</p>
<p>Razor1911破解组最著名的作品应该是《星际争霸：母巢之战》的硬盘版，间接导致了星际争霸在全世界的流行。</p>
<p>1、制作《星际争霸：母巢之战》硬盘版，在这一版的星际争霸中，所有文件的体积加起来只有100m多一点，而最为经典的地方就在于他们把光盘版中两个600m左右的install.exe文件压缩到了只有22m的大小。</p>
<p>2、破解《GTA4》和该游戏价值20万美元的SecuRom反破解系统。</p>
<p>3、破解EA origin平台的加密技术。</p>
<p>4、破解《孤岛危机》和《上古卷轴5：天际》。</p>
</li>
<li>
<p>CPY</p>
<p>CPY全名 CONSPiR4CY，是来自于意大利的破解组，成立于1999年，相比上面的三大破解组成立较晚。但是最近几年，CPY在破解了Denuvo加密技术（D加密）后名声大噪，俨然已超越了上面三大破解组。</p>
<p>在国内有CPY掌握核心技术的说法，Steam、EA origin、Denuvo等加密技术先后被CPY破解。</p>
<p>高光时刻：</p>
<p>1、2015年，继Steam平台后，EA origin平台加密技术被破解，宣布了这套加密系统彻底完蛋。</p>
<p>2、破解D加密技术，随后一系列热门游戏遭到破解，包括：《合金装备5 幻痛》《古墓丽影 崛起》《毁灭战士4》《看门狗2》等等。</p>
</li>
<li>
<p><a href="https://zh.moegirl.org.cn/index.php?title=%E7%A0%B4%E8%A7%A3%E7%BB%84">CODEX</a></p>
<p>会破解D加密，如今几乎已经垄断破解业。并在.nfo文件招聘栏中提到CODEX什么都不要，只要竞争!</p>
<p>2022年2月，CODEX宣告退休。</p>
<ul>
<li>PLAZA</li>
<li>EMPRESS</li>
</ul>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/List_of_warez_groups">STEAMPUNKS</a></p>
</li>
</ul>
<h3 id="youtube-dlhttpsgithubcomytdl-orgyoutube-dl"><a href="https://github.com/ytdl-org/youtube-dl">youtube-dl</a><a hidden class="anchor" aria-hidden="true" href="#youtube-dlhttpsgithubcomytdl-orgyoutube-dl">#</a></h3>
<p>youtube-dl 是一个命令行程序，用于从 YouTube.com 和<a href="https://ytdl-org.github.io/youtube-dl/supportedsites.html">更多其他网站</a>下载视频。 基于 Python 实现，不限于特定平台。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 安装</span>
$ pip install -i https://pypi.tuna.tsinghua.edu.cn/simple youtube-dl
<span style="color:#75715e"># 使用</span>
$ youtube-dl <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> URL <span style="color:#f92672">[</span>URL...<span style="color:#f92672">]</span>
</code></pre></div><p>当前版本（2021.06.06）<a href="https://stackoverflow.com/questions/60506532/why-can-only-download-the-first-episode-video-on-bilibili-with-youtube-dl">不能下载哔哩哔哩播放列表</a>，可以用类似软件如 <a href="https://github.com/soimort/you-get">you-get</a>， <a href="https://github.com/iawia002/annie">annie</a> 代替。</p>
<h4 id="usagehttpszhuanlanzhihucomp105141332"><a href="https://zhuanlan.zhihu.com/p/105141332">Usage</a><a hidden class="anchor" aria-hidden="true" href="#usagehttpszhuanlanzhihucomp105141332">#</a></h4>
<p><strong>下载视频或整个视频播放列表</strong></p>
<ul>
<li>要从 Youtube 下载视频或整个视频播放列表，只需直接使用 URL 即可：<code>youtube-dl [url]</code>。程序自动选择一个最清晰的格式下载。</li>
<li>如果要指定视频下载之后的名称，可以使用如下方式：<code>youtube-dl -o '名称' [url]</code>。</li>
<li>还可以在下载视频时附加更多详细信息，可用的参数有标题、上传者名称（频道名称）和视频上传日期等：<code>youtube-dl -o '%(title)s by %(uploader)s on %(upload_date)s in %(playlist)s.%(ext)s' [ul]</code>。</li>
</ul>
<p><strong>查看视频的所有类型，只看不下载</strong></p>
<p>命令：<code>youtube-dl -F [url]</code>或者<code>youtube-dl --list-formats [url]</code>。
这是一个列清单参数，执行后并不会下载视频，但能知道这个目标视频都有哪些格式存在，以便有选择的下载。</p>
<p><strong>下载指定质量的视频和音频并自动合并</strong></p>
<p>下载最佳/最差质量的音/视频文件：</p>
<p>默认情况下，youtube-dl将自主选择最佳质量的视频下载。 但是，也可以以特定的质量或格式来下载视频或播放列表</p>
<p>Youtube-dl 支持以下品质：</p>
<ul>
<li><code>best</code>选择最佳质量的音/视频文件</li>
<li><code>worst</code>选择质量最差的格式（视频和音频）</li>
<li><code>bestvideo</code>选择最佳质量的仅视频格式（例如DASH视频），可能无法使用。</li>
<li><code>worstvideo</code>选择质量最差的纯视频格式，可能无法使用。</li>
<li><code>bestaudio</code>选择最优质的音频格式，可能无法使用。</li>
<li><code>worstaudio</code>选择质量最差的音频格式，可能无法使用。</li>
</ul>
<p>例如，如果要自动选择并下载最佳质量格式（音频和视频），只需使用以下命令：<code>youtube-dl -f best [url]</code>。</p>
<p>您还可以组合使用以下不同的格式选项：<code>youtube-dl -f bestvideo+bestaudio [ul]</code>。该命令将分别下载最高质量的仅视频和最高质量的纯音频格式，再用ffmpeg或avconv合并成一个最佳质量的mkv文件；如果您不想合并，请将<code>+</code>（加号）替换为<code>,</code>（逗号）即可分别得到最高质量的音频和视频（两个文件）：<code>youtube-dl -f 'bestvideo,bestaudio' [url]</code>。</p>
<hr>
<p>下载指定质量的音/视频文件：</p>
<p>-F 获取的所有视频格式的清单，最左边一列就是编号对应着不同的格式。由于YouTube的1080p及以上的分辨率都是音视频分离的，所以我们需要分别下载视频和音频，可以使用137+140这样的组合。如果系统中安装了ffmpeg的话，youtube-dl 会自动合并下好的视频和音频，然后自动删除单独的音视频文件：<code>youtube-dl -f [format code] [url]</code>。</p>
<p>从播放列表下载视频时，某些视频可能没有相同的格式。 在这种情况下，可以按首选顺序指定多个格式代码，例如：命令<code>youtube-dl -f 22/17/18 &lt;playlist_url&gt;</code>将以格式 22 下载视频（如果可用）；如果格式 22不可用，则它将下载格式 17（如果可用）；如果格式 22 和 17 都不可用，最后尝试下载格式 18。如果所有格式代码都不匹配，Youtube-dl 会报出提示。还需要注意的是，斜杠是左关联的，即最左侧的格式代码是首选。</p>
<p><strong>下载字幕</strong></p>
<ul>
<li><code>youtube-dl --write-sub [url]</code>这样会下载一个vtt格式的英文字幕和mkv格式的1080p视频下来</li>
<li><code>youtube-dl --write-sub --skip-download [url]</code>下载单独的vtt字幕文件,而不会下载视频</li>
<li><code>youtube-dl --write-sub --all-subs [url]</code>下载所有语言的字幕(如果有的话)</li>
<li><code>youtube-dl --write-auto-sub [url]</code>下载自动生成的字幕(YouTube only)</li>
</ul>
<p><strong>下载多个视频</strong></p>
<ul>
<li><code>youtube-dl &lt;url1&gt; &lt;url2&gt;</code>有时我们需要一次下载多个不同的视频，此时我们只需用空格将多个URL分隔开即可。</li>
<li><code>youtube-dl -a url.txt</code>也可以将要下载视频的URL全部放在文本文件中，并将其作为参数传递给youtube-dl。此命令将下载url.txt文件中所有URL指向的视频。</li>
</ul>
<p><strong>只下载（视频中的）音频</strong></p>
<ul>
<li><code>youtube-dl -x [url]</code>仅从视频网站下载其音频。</li>
<li><code>youtube-dl -x --audio-format mp3 [ul]</code>默认情况下，youtube-dl 将以Ogg （opus）格式保存音频。此命令将从给定的视频/播放列表下载音频，将其转换为 MP3 并将其保存在当前目录中。应注意：您应该安装 ffmpeg 或 avconv 将文件转换为 mp3 格式。</li>
</ul>
<p><strong>下载带有描述、元数据、注释、字幕和缩略图的视频</strong></p>
<p>要下载视频及其他详细信息，如：说明、元数据、注释、字幕和缩略图等，请使用以下命令：
<code>youtube-dl --write-description --write-info-json --write-annotations --write-sub --write-thumbnail [url]</code></p>
<p><strong>通过文件扩展名下载音/视频</strong></p>
<ul>
<li>以您的首选格式下载视频，例如 MP4，只需执行：<code>youtube-dl --format mp4 [url]</code>或者<code>youtube-dl -f mp4 [url]</code>。</li>
<li>某些视频可能无法以您的首选格式提供。 在这种情况下，youtube-dl 将下载其他最佳可用格式。例如：
<code>youtube-dl -f 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best' [ul]</code>
此命令将下载最佳质量的MP4格式文件。如果 MP4 格式不可用，则它将下载其他最佳可用格式。</li>
</ul>
<p><strong>限制下载视频的大小</strong></p>
<p>从YouTube播放列表下载多个视频时，您可能只想下载特定大小的视频。例如：</p>
<ul>
<li>此命令不会下载任何小于指定大小（例如100MB）的视频：<code>youtube-dl --min-filesize 100M &lt;playlist_url&gt;</code>。</li>
<li>如果您不想下载大于给定大小的视频，可以这样：<code>youtube-dl --max-filesize 100M &lt;playlist_url&gt;</code>。</li>
</ul>
<p>我们还可以用组合格式，选择运算符来下载特定大小的视频。例如：</p>
<ul>
<li>以下命令将下载最佳视频格式但不大于 100MB 的视频：<code>youtube-dl -f 'best[filesize&lt;100M]' [url]</code>。</li>
</ul>
<p><strong>按日期下载视频</strong></p>
<p>Youtube-dl 允许我们按照上传日期来筛选和下载视频或播放列表，例如：</p>
<ul>
<li>要下载 2019 年 8 月 1 日上传的视频，可以使用：<code>youtube-dl --date 20190801 [URL]</code>；</li>
<li>下载在特定日期或之前上传的视频：<code>youtube-dl --datebefore 20190801 [URL]</code>；</li>
<li>下载在特定日期或之后上传的视频：<code>youtube-dl --dateafter 20190101 [URL]</code>；</li>
<li>仅下载过去 6 个月内上传的视频：<code>youtube-dl --dateafter now-6months [URL]</code>；</li>
<li>下载特定时间段内（例如 2018 年 1 月 1 日至 2019 年 1 月 1 日）上传的视频：<code>youtube-dl --dateafter 20180101 --datebefore 20190101 [URL]</code>。</li>
</ul>
<p><strong>从播放列表下载特定的视频</strong></p>
<p>从播放列表下载特定的视频，是youtube-dl 的另一个非常有用的功能。例如：</p>
<ul>
<li>要从播放列表下载第 10 个文件，可使用：<code>youtube-dl --playlist-items 10 [playlist_url]</code>；</li>
<li>要下载多个指定的文件，只需用逗号分隔：<code>youtube-dl --playlist-items 2,3,7,10 [playlist_url]</code>；</li>
</ul>
<p>也可以按序号来指定要下载范围，例如：</p>
<ul>
<li>从第 10 个开始，直接下载完整个列表：<code>youtube-dl --playlist-start 10 [playlist_url]</code>；</li>
<li>在播放列表中仅下载从第 2 到第 5 的文件：<code>youtube-dl --playlist-start 2 --playlist-end 5 [playlist_url]</code>。</li>
</ul>
<h4 id="configurationhttpswwwjianshucomp5143faa6056d"><a href="https://www.jianshu.com/p/5143faa6056d">Configuration</a><a hidden class="anchor" aria-hidden="true" href="#configurationhttpswwwjianshucomp5143faa6056d">#</a></h4>
<p>在 Linux 和 macOS 上，系统配置文件位于 /<code>etc/youtube-dl.conf</code>，用户配置文件位于 <code>~/.config/youtube-dl/config</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># Continue on download errors, for example to skip unavailable videos in a playlist</span>
--ignore-errors

<span style="color:#75715e"># Time to wait before giving up, in seconds</span>
--socket-timeout <span style="color:#ae81ff">10</span>

<span style="color:#75715e"># Download only videos not listed in the archive file. Record the IDs of all downloaded videos in it.</span>
<span style="color:#75715e">#--download-archive   /path/archive.txt</span>

<span style="color:#75715e"># Number of retries (default is 10), or &#34;infinite&#34;.</span>
--retries infinite

<span style="color:#75715e"># Give these arguments to the external downloader</span>
--external-downloader aria2c  --external-downloader-args <span style="color:#e6db74">&#34;--no-conf -c&#34;</span>

<span style="color:#75715e"># Output filename template, see the &#34;OUTPUT TEMPLATE&#34; for all the info</span>
-o <span style="color:#e6db74">&#39;~/Videos/%(id)s.%(ext)s&#39;</span>

<span style="color:#75715e"># Write thumbnail image to disk</span>
<span style="color:#75715e">#--write-thumbnail</span>

<span style="color:#75715e"># download best 30hz mp4 file , h264+aac ,use http or https protocol,because we can use aria2c downloader to have a faster speed</span>
--format <span style="color:#e6db74">&#39;(bestvideo[ext=mp4][fps&lt;31]+bestaudio[ext=m4a]/best[ext=mp4]/bestvideo+bestaudio/best)[protocol^=http]&#39;</span>

<span style="color:#75715e"># Embed thumbnail in the audio as cover art</span>
<span style="color:#75715e">#--embed-thumbnail</span>

<span style="color:#75715e"># Write metadata to the video file</span>
--add-metadata
</code></pre></div><h3 id="curlhttpwwwruanyifengcomblog201909curl-referencehtml"><a href="http://www.ruanyifeng.com/blog/2019/09/curl-reference.html">curl</a><a hidden class="anchor" aria-hidden="true" href="#curlhttpwwwruanyifengcomblog201909curl-referencehtml">#</a></h3>
<h4 id="简介-1">简介<a hidden class="anchor" aria-hidden="true" href="#简介-1">#</a></h4>
<p>curl 是常用的命令行工具，用来请求 Web 服务器。它的名字就是客户端（client）的 URL 工具的意思。</p>
<p>它的功能非常强大，命令行参数多达几十种。如果熟练的话，完全可以取代 Postman 这一类的图形界面工具。</p>
<p>本文介绍它的主要命令行参数，作为日常的参考，方便查阅。</p>
<p>不带有任何参数时，curl 就是发出 GET 请求。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl https://www.example.com
</code></pre></div><p>上面命令向<code>www.example.com</code>发出 GET 请求，服务器返回的内容会在命令行输出。</p>
<h4 id="主要命令行参数">主要命令行参数<a hidden class="anchor" aria-hidden="true" href="#主要命令行参数">#</a></h4>
<p><strong>-A</strong></p>
<p><code>-A</code>参数指定客户端的用户代理标头，即<code>User-Agent</code>。curl 的默认用户代理字符串是<code>curl/[version]</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl -A <span style="color:#e6db74">&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36&#39;</span> https://google.com
</code></pre></div><p>上面命令将<code>User-Agent</code>改成 Chrome 浏览器。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl -A <span style="color:#e6db74">&#39;&#39;</span> https://google.com
</code></pre></div><p>上面命令会移除<code>User-Agent</code>标头。</p>
<p>也可以通过<code>-H</code>参数直接指定标头，更改<code>User-Agent</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl -H <span style="color:#e6db74">&#39;User-Agent: php/1.0&#39;</span> https://google.com
</code></pre></div><p><strong>-b</strong></p>
<p><code>-b</code>参数用来向服务器发送 Cookie。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl -b <span style="color:#e6db74">&#39;foo=bar&#39;</span> https://google.com
</code></pre></div><p>上面命令会生成一个标头<code>Cookie: foo=bar</code>，向服务器发送一个名为<code>foo</code>、值为<code>bar</code>的 Cookie。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl -b <span style="color:#e6db74">&#39;foo1=bar;foo2=bar2&#39;</span> https://google.com
</code></pre></div><p>上面命令发送两个 Cookie。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl -b cookies.txt https://www.google.com
</code></pre></div><p>上面命令读取本地文件<code>cookies.txt</code>，里面是服务器设置的 Cookie（参见<code>-c</code>参数），将其发送到服务器。</p>
<p><strong>-c</strong></p>
<p><code>-c</code>参数将服务器设置的 Cookie 写入一个文件。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl -c cookies.txt https://www.google.com
</code></pre></div><p>上面命令将服务器的 HTTP 回应所设置 Cookie 写入文本文件<code>cookies.txt</code>。</p>
<p><strong>-d</strong></p>
<p><code>-d</code>参数用于发送 POST 请求的数据体。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl -d <span style="color:#e6db74">&#39;login=emma＆password=123&#39;</span>-X POST https://google.com/login
<span style="color:#75715e"># 或者</span>
$ curl -d <span style="color:#e6db74">&#39;login=emma&#39;</span> -d <span style="color:#e6db74">&#39;password=123&#39;</span> -X POST  https://google.com/login
</code></pre></div><p>使用<code>-d</code>参数以后，HTTP 请求会自动加上标头<code>Content-Type : application/x-www-form-urlencoded</code>。并且会自动将请求转为 POST 方法，因此可以省略<code>-X POST</code>。</p>
<p><code>-d</code>参数可以读取本地文本文件的数据，向服务器发送。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl -d <span style="color:#e6db74">&#39;@data.txt&#39;</span> https://google.com/login
</code></pre></div><p>上面命令读取<code>data.txt</code>文件的内容，作为数据体向服务器发送。</p>
<p><strong>&ndash;data-urlencode</strong></p>
<p><code>--data-urlencode</code>参数等同于<code>-d</code>，发送 POST 请求的数据体，区别在于会自动将发送的数据进行 URL 编码。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl --data-urlencode <span style="color:#e6db74">&#39;comment=hello world&#39;</span> https://google.com/login
</code></pre></div><p>上面代码中，发送的数据<code>hello world</code>之间有一个空格，需要进行 URL 编码。</p>
<p><strong>-e</strong></p>
<p><code>-e</code>参数用来设置 HTTP 的标头<code>Referer</code>，表示请求的来源。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">curl -e <span style="color:#e6db74">&#39;https://google.com?q=example&#39;</span> https://www.example.com
</code></pre></div><p>上面命令将<code>Referer</code>标头设为<code>https://google.com?q=example</code>。</p>
<p><code>-H</code>参数可以通过直接添加标头<code>Referer</code>，达到同样效果。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">curl -H <span style="color:#e6db74">&#39;Referer: https://google.com?q=example&#39;</span> https://www.example.com
</code></pre></div><p><strong>-F</strong></p>
<p><code>-F</code>参数用来向服务器上传二进制文件。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl -F <span style="color:#e6db74">&#39;file=@photo.png&#39;</span> https://google.com/profile
</code></pre></div><p>上面命令会给 HTTP 请求加上标头<code>Content-Type: multipart/form-data</code>，然后将文件<code>photo.png</code>作为<code>file</code>字段上传。</p>
<p><code>-F</code>参数可以指定 MIME 类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl -F <span style="color:#e6db74">&#39;file=@photo.png;type=image/png&#39;</span> https://google.com/profile
</code></pre></div><p>上面命令指定 MIME 类型为<code>image/png</code>，否则 curl 会把 MIME 类型设为<code>application/octet-stream</code>。</p>
<p><code>-F</code>参数也可以指定文件名。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl -F <span style="color:#e6db74">&#39;file=@photo.png;filename=me.png&#39;</span> https://google.com/profile
</code></pre></div><p>上面命令中，原始文件名为<code>photo.png</code>，但是服务器接收到的文件名为<code>me.png</code>。</p>
<p><strong>-G</strong></p>
<p><code>-G</code>参数用来构造 URL 的查询字符串。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl -G -d <span style="color:#e6db74">&#39;q=kitties&#39;</span> -d <span style="color:#e6db74">&#39;count=20&#39;</span> https://google.com/search
</code></pre></div><p>上面命令会发出一个 GET 请求，实际请求的 URL 为<code>https://google.com/search?q=kitties&amp;count=20</code>。如果省略<code>--G</code>，会发出一个 POST 请求。</p>
<p>如果数据需要 URL 编码，可以结合<code>--data--urlencode</code>参数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl -G --data-urlencode <span style="color:#e6db74">&#39;comment=hello world&#39;</span> https://www.example.com
</code></pre></div><p><strong>-H</strong></p>
<p><code>-H</code>参数添加 HTTP 请求的标头。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl -H <span style="color:#e6db74">&#39;Accept-Language: en-US&#39;</span> https://google.com
</code></pre></div><p>上面命令添加 HTTP 标头<code>Accept-Language: en-US</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl -H <span style="color:#e6db74">&#39;Accept-Language: en-US&#39;</span> -H <span style="color:#e6db74">&#39;Secret-Message: xyzzy&#39;</span> https://google.com
</code></pre></div><p>上面命令添加两个 HTTP 标头。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl -d <span style="color:#e6db74">&#39;{&#34;login&#34;: &#34;emma&#34;, &#34;pass&#34;: &#34;123&#34;}&#39;</span> -H <span style="color:#e6db74">&#39;Content-Type: application/json&#39;</span> https://google.com/login
</code></pre></div><p>上面命令添加 HTTP 请求的标头是<code>Content-Type: application/json</code>，然后用<code>-d</code>参数发送 JSON 数据。</p>
<p><strong>-i</strong></p>
<p><code>-i</code>参数打印出服务器回应的 HTTP 标头。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl -i https://www.example.com
</code></pre></div><p>上面命令收到服务器回应后，先输出服务器回应的标头，然后空一行，再输出网页的源码。</p>
<p><strong>-I</strong></p>
<p><code>-I</code>参数向服务器发出 HEAD 请求，然会将服务器返回的 HTTP 标头打印出来。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl -I https://www.example.com
</code></pre></div><p>上面命令输出服务器对 HEAD 请求的回应。</p>
<p><code>--head</code>参数等同于<code>-I</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl --head https://www.example.com
</code></pre></div><p><strong>-k</strong></p>
<p><code>-k</code>参数指定跳过 SSL 检测。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl -k https://www.example.com
</code></pre></div><p>上面命令不会检查服务器的 SSL 证书是否正确。</p>
<p><strong>-L</strong></p>
<p><code>-L</code>参数会让 HTTP 请求跟随服务器的重定向。curl 默认不跟随重定向。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl -L -d <span style="color:#e6db74">&#39;tweet=hi&#39;</span> https://api.twitter.com/tweet
</code></pre></div><p><strong>&ndash;limit-rate4</strong></p>
<p><code>--limit-rate</code>用来限制 HTTP 请求和回应的带宽，模拟慢网速的环境。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl --limit-rate 200k https://google.com
</code></pre></div><p>上面命令将带宽限制在每秒 200K 字节。</p>
<p><strong>-o</strong></p>
<p><code>-o</code>参数将服务器的回应保存成文件，等同于<code>wget</code>命令。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl -o example.html https://www.example.com
</code></pre></div><p>上面命令将<code>www.example.com</code>保存成<code>example.html</code>。</p>
<p><strong>-O</strong></p>
<p><code>-O</code>参数将服务器回应保存成文件，并将 URL 的最后部分当作文件名。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl -O https://www.example.com/foo/bar.html
</code></pre></div><p>上面命令将服务器回应保存成文件，文件名为<code>bar.html</code>。</p>
<p><strong>-s</strong></p>
<p><code>-s</code>参数将不输出错误和进度信息。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl -s https://www.example.com
</code></pre></div><p>上面命令一旦发生错误，不会显示错误信息。不发生错误的话，会正常显示运行结果。</p>
<p>如果想让 curl 不产生任何输出，可以使用下面的命令。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl -s -o /dev/null https://google.com
</code></pre></div><p><strong>-S</strong></p>
<p><code>-S</code>参数指定只输出错误信息，通常与<code>-s</code>一起使用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl -s -o /dev/null https://google.com
</code></pre></div><p>上面命令没有任何输出，除非发生错误。</p>
<p><strong>-u</strong></p>
<p><code>-u</code>参数用来设置服务器认证的用户名和密码。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl -u <span style="color:#e6db74">&#39;bob:12345&#39;</span> https://google.com/login
</code></pre></div><p>上面命令设置用户名为<code>bob</code>，密码为<code>12345</code>，然后将其转为 HTTP 标头<code>Authorization: Basic Ym9iOjEyMzQ1</code>。</p>
<p>curl 能够识别 URL 里面的用户名和密码。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl https://bob:12345@google.com/login
</code></pre></div><p>上面命令能够识别 URL 里面的用户名和密码，将其转为上个例子里面的 HTTP 标头。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl -u <span style="color:#e6db74">&#39;bob&#39;</span> https://google.com/login
</code></pre></div><p>上面命令只设置了用户名，执行后，curl 会提示用户输入密码。</p>
<p><strong>-v</strong></p>
<p><code>-v</code>参数输出通信的整个过程，用于调试。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl -v https://www.example.com
</code></pre></div><p><code>--trace</code>参数也可以用于调试，还会输出原始的二进制数据。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl --trace - https://www.example.com
</code></pre></div><p><strong>-x</strong></p>
<p><code>-x</code>参数指定 HTTP 请求的代理。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl -x socks5://james:cats@myproxy.com:8080 https://www.example.com
</code></pre></div><p>上面命令指定 HTTP 请求通过<code>myproxy.com:8080</code>的 socks5 代理发出。</p>
<p>如果没有指定代理协议，默认为 HTTP。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl -x james:cats@myproxy.com:8080 https://www.example.com
</code></pre></div><p>上面命令中，请求的代理使用 HTTP 协议。</p>
<p><strong>-X</strong></p>
<p><code>-X</code>参数指定 HTTP 请求的方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl -X POST https://www.example.com
</code></pre></div><p>上面命令对<code>https://www.example.com</code>发出 POST 请求。</p>
<h4 id="httpiehttpsgithubcomhttpiehttpie"><a href="https://github.com/httpie/httpie">HTTPie</a><a hidden class="anchor" aria-hidden="true" href="#httpiehttpsgithubcomhttpiehttpie">#</a></h4>
<p>HTTPie（<code>http</code>）以一种更人性化的方式做同样的工作。你会看到彩色的、格式化的输出，这使得它更容易理解和调试。</p>
<h4 id="axelhttpsgithubcomaxel-download-acceleratoraxel"><a href="https://github.com/axel-download-accelerator/axel">axel</a><a hidden class="anchor" aria-hidden="true" href="#axelhttpsgithubcomaxel-download-acceleratoraxel">#</a></h4>
<p>Lightweight CLI download accelerator</p>
<h3 id="usenethttpswwwruanyifengcomblogusenet"><a href="https://www.ruanyifeng.com/blog/usenet/">USENET</a><a hidden class="anchor" aria-hidden="true" href="#usenethttpswwwruanyifengcomblogusenet">#</a></h3>
<h4 id="起源">起源<a hidden class="anchor" aria-hidden="true" href="#起源">#</a></h4>
<p>简单地说，USENET是一个巨大无比的网上讨论组，一般也称为&quot;新闻组&quot;（newsgroups）。你可以将它想象成一个包罗万象、无所不有的网上论坛，但是它又不同于我们通常看到的普通论坛。这要从它的起源说起。</p>
<p>上个世纪70年代末，当时还没有互联网和浏览器，它们都要在十多年后才会出现。那时所谓&quot;上网&quot;，就是用modem（调制解调器），拨一个电话号码，将自己的电脑连到另一台电脑（也称&quot;主机&quot;），收收邮件，看看上面系统管理员发的通告。如果想换一台主机看看，那就必须先挂断，再拨另外一个电话号码。</p>
<p>这样的上网方式，很不利于开展多人的讨论。由于是拨号上网，只有地理位置相近的用户，才会登录同一台主机。很难想象，同一台机器的登录用户，既有东岸的纽约人，也有西岸的洛杉矶人。即使长途电话费不是问题，当时的主机也没有能力同时负担太多的远程终端。因此，迫切需要一种大规模的、分布式的、多中心的远程信息交换手段。</p>
<p>1979年，Duke大学的两个研究生Tom Truscott和Jim Ellis，提出一种分布式的网上讨论组的构想。这种讨论组创建之初，主要是供UNIX爱好者协会（USENIX）的成员使用，因此就被定名为USENET。当然，后来全世界的用户都在使用它。</p>
<h4 id="运行机制">运行机制<a hidden class="anchor" aria-hidden="true" href="#运行机制">#</a></h4>
<p>USENET的运行机制其实非常简单。对于用户来说，只有三步。</p>
<p>1）网络服务提供商（ISP）在一个网络中，设定一台服务器作为USENET专用服务器，再将它的网址告诉用户。</p>
<p>2）用户想要发言的时候，就向这个网址发送帖子（post），这与发送Email很相似，但是两者格式不一样，在USENET上发言必须使用专用的客户端。不过，现在大多数的Email客户端都带有新闻组功能，最常见的Outlook Express的设置可以参考网上的说明。</p>
<p>3）查看其他人的发言时，就必须从服务器上下载其他人的帖子。下载完成后，如果想回复某人的帖子，就再重复第二步。</p>
<p>可以看到，这个过程同邮件列表的运行几乎一模一样，不同之处在于，USENET服务器每天会同其他USENET服务器交换帖子。这就是说，全世界所有的USENET服务器最终都可以互相交换帖子，保持内容的同步。所以理论上，不管你的帖子是发到哪一台服务器上，最终全世界的人们都会看到，并且会从世界各地给你回复。</p>
<p>因此，USENET就有一个其他交流机制所没有的优点，即这是一个真正的全世界参与的讨论组。</p>
<h4 id="内容结构">内容结构<a hidden class="anchor" aria-hidden="true" href="#内容结构">#</a></h4>
<p>由于USENET中的讨论内容无所不包，所以必须根据主题分类。每一个主题就是一个&quot;频道&quot;，对这个主题感兴趣的用户就订阅这个频道。</p>
<p>USENET中的主题分类采用等级制（hierarchies），在形式上同域名很相似，即&quot;一级主题.二级主题.三级主题&hellip;.&quot;，中间以小数点分隔。</p>
<p>一级主题有9个。</p>
<blockquote>
<p>* comp.*: 与计算机相关的讨论。（computer-related discussions，比如comp.software, comp.sys.amiga）</p>
<p>* misc.*: 各种不属于其他分类的主题。（Miscellaneous topics，比如misc.education, misc.forsale, misc.kids）</p>
<p>* news.*: 对USENET本身的讨论（比如news.groups, news.admin）</p>
<p>* rec.*: 休闲和娱乐（Recreation and entertainment，比如rec.music, rec.arts.movies）</p>
<p>* sci.*: 与科学相关的讨论。（Science related discussions，比如sci.psychology, sci.research）</p>
<p>* soc.*: 与社会相关的讨论。（Social discussions，比如soc.college.org, soc.culture.african）</p>
<p>* talk.*: 各种争议性话题的讨论。（Talk about various controversial topics，比如talk.religion, talk.politics, talk.origins）</p>
<p>* humanities.*: 艺术、文学、哲学方面的讨论。（Fine arts, literature, and philosophy，比如humanities.classics, humanities.design.misc）</p>
<p>* alt.*: 自由讨论区。（alternative）</p>
</blockquote>
<p>这9个一级主题中，除了alt.*以外，都不能自行设立讨论区。只有在alt主题区中，可以自己发起主题&quot;频道&quot;。</p>
<h4 id="二进制内容">二进制内容<a hidden class="anchor" aria-hidden="true" href="#二进制内容">#</a></h4>
<p>USENET最初设计的时候，只打算用来传递文本信息，没有考虑传递二进制数据（也就是&quot;文件&quot;）。但是，随着互联网的发展，不传递二进制数据看上去是不可能的。</p>
<p>于是，专门的编码方式被设计了出来，使得二进制文件可以转换成文本文件，在USENET上传递，用户下载以后再传换成原来的格式。这时，USENET就不仅是一个讨论组了，而成了传递文件的一种手段，图片、音频和视频都可以通过USENET传播。</p>
<p>事实上，如今USENET上的流量，99%都已经是二进制文件了。它们大部分都在alt.binaries这个主题中传播。由于不受监管，所以各种各样的文件都有。</p>
<h4 id="收费服务">收费服务<a hidden class="anchor" aria-hidden="true" href="#收费服务">#</a></h4>
<p>根据一项统计，2007年4月USENET上一天的流量为3.12TB，且还在快速增加中。这么大的流量，使得世界上提供USENET的服务商肯定不会很多。大家可以查看这个<a href="http://www.exit109.com/~jeremy/news/providers/providers.html">网页</a>，上面有USENET提供商的不完全列表。</p>
<p>这些服务商，又分为免费和收费两种。免费的USENET绝大多数都不提供二进制文件下载，查看<a href="https://groups.google.com/group/alt.free.newsservers">alt.free.newsservers</a>主题可以获得最新的免费USENET服务器的信息。</p>
<p>在收费服务商中，名气比较大的是<a href="https://www.giganews.com/?a=ruanyf">GIGANEWS</a>，它提供多种收费账户供用户选择。其中白金用户每月费用为19.99美元，可以无限量下载，14天内不满意可以退款。如果你是一个狂热的下载爱好者，我强烈推荐去购买一个账户。</p>
<h4 id="google-groups">Google Groups<a hidden class="anchor" aria-hidden="true" href="#google-groups">#</a></h4>
<p><a href="https://groups.google.com/">Google Groups</a>也提供免费USENET服务。（当然，没有二进制文件下载。）我会另写文章专门介绍，这里就省略了。</p>
<h2 id="editor">Editor<a hidden class="anchor" aria-hidden="true" href="#editor">#</a></h2>
<h3 id="vscode">VSCode<a hidden class="anchor" aria-hidden="true" href="#vscode">#</a></h3>
<p><a href="https://cyhour.com/1638/#:~:text=%E4%B8%8D%E8%BF%87%E8%BA%AB%E5%A4%84%E5%B1%80%E5%9F%9F%E7%BD%91%E5%86%85%EF%BC%8C%E4%B8%AD%E5%9B%BD%E5%9B%BD%E5%86%85%E4%B8%8B%E8%BD%BD%20VSCode%20%E9%80%9F%E5%BA%A6%E6%AD%A3%E5%B8%B8%E6%83%85%E5%86%B5%E4%B8%8B%E6%AF%94%E8%BE%83%E6%85%A2%EF%BC%8C%E4%B8%BB%E8%A6%81%E6%9C%89%E4%B8%A4%E4%B8%AA%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%EF%BC%9A%E4%B8%80%E6%98%AF%E8%B5%B0%20%E5%A4%96%E8%B4%B8%E5%B7%A5%E4%BD%9C%20%E4%B8%96%E7%95%8C%E4%BA%92%E8%81%94%E7%BD%91%E7%BB%9C%EF%BC%9B%E4%BA%8C%E6%98%AF%E4%BD%BF%E7%94%A8%E4%B8%AD%E5%9B%BD%20cdn%20%E9%95%9C%E5%83%8F%E5%9C%B0%E5%9D%80%E4%B8%8B%E8%BD%BD%E3%80%82.%20%E6%96%B9%E6%B3%95%E4%BA%8C%E4%BD%BF%E7%94%A8,%E9%95%9C%E5%83%8F%E5%9C%B0%E5%9D%80%E4%B8%8B%E8%BD%BD%E6%AF%94%E8%BE%83%E7%AE%80%E5%8D%95%EF%BC%9A.%20%E6%AF%94%E5%A6%82%EF%BC%8C%E7%82%B9%E5%87%BB%E4%B8%8B%E8%BD%BD%20VSCodeUserSetup-x64-1.52.1.exe%EF%BC%8C%E4%BC%9A%E5%BE%97%E5%88%B0%E8%BF%99%E4%B8%AA%E5%9C%B0%E5%9D%80%EF%BC%9A.%20https%3A%2F%2Faz764295.vo.msecnd.net%2Fstable%2Fea3859d4ba2f3e577a159bc91e3074c5d85c0523%2FVSCodeUserSetup-x64-1.52.1.exe.%20%E6%8A%8A%20stable%20%E5%89%8D%E5%9C%B0%E5%9D%80%E6%9B%BF%E6%8D%A2%E6%88%90%20vscode.cdn.azure.cn%EF%BC%8C%E4%B8%8B%E9%9D%A2%E6%98%AF%E6%9B%BF%E6%8D%A2%E5%90%8E%E5%9C%B0%E5%9D%80%EF%BC%9A.">中国国内下载 VSCode 速度慢问题解决</a>：使用 azure 中国 cdn 镜像地址加速下载 VSCode</p>
<p>将默认下载地址</p>
<pre tabindex="0"><code class="language-url" data-lang="url">https://az764295.vo.msecnd.net/stable/
</code></pre><p>替换为 <code>vscode.cdn.azure.cn</code></p>
<pre tabindex="0"><code class="language-url" data-lang="url">https://vscode.cdn.azure.cn/stable/
</code></pre><p><strong>自动换行</strong></p>
<p>将word wrap的off改成on</p>
<p><strong><a href="https://www.ruanyifeng.com/blog/2021/08/best-note-taking-software-for-programmers.html">最适合程序员的笔记软件</a></strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">https://github.dev/<span style="color:#f92672">[</span>用户名<span style="color:#f92672">]</span>/<span style="color:#f92672">[</span>仓库名<span style="color:#f92672">]</span>
</code></pre></div><p><strong>大小写转换快捷键</strong></p>
<ul>
<li><strong>File</strong>-&gt;<strong>Preference</strong>-&gt;<strong>Keybord Shortcuts</strong> 或直接按<code>ctrl+k</code>+<code>ctrl+s</code></li>
<li>在上面的搜索栏中，输入 <strong>Transform</strong> 就可以看到有<strong>Transform to Uppercase</strong>和<strong>Trasnfrom to Lowercase</strong>的命令</li>
<li>设置快捷键</li>
</ul>
<h3 id="google-keep">Google Keep<a hidden class="anchor" aria-hidden="true" href="#google-keep">#</a></h3>
<p>Now I am using Google Keep.</p>
<p><a href="https://www.makeuseof.com/google-keep-keyboard-shortcuts/"><strong>Google Keep键盘快捷键</strong></a></p>
<table>
<thead>
<tr>
<th style="text-align:left">hortcut</th>
<th style="text-align:left">Action</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">J/K</td>
<td style="text-align:left">Next/previous note</td>
</tr>
<tr>
<td style="text-align:left">Shift + J/K</td>
<td style="text-align:left">Move note to next/previous position</td>
</tr>
<tr>
<td style="text-align:left">N/P</td>
<td style="text-align:left">Next/previous list item</td>
</tr>
<tr>
<td style="text-align:left">Shift + N/P</td>
<td style="text-align:left">Move list item to next/previous position</td>
</tr>
<tr>
<td style="text-align:left">C</td>
<td style="text-align:left">New note</td>
</tr>
<tr>
<td style="text-align:left">L</td>
<td style="text-align:left">New list</td>
</tr>
<tr>
<td style="text-align:left">/</td>
<td style="text-align:left">Search</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + A</td>
<td style="text-align:left">Select all</td>
</tr>
<tr>
<td style="text-align:left">E</td>
<td style="text-align:left">Archive</td>
</tr>
<tr>
<td style="text-align:left">#</td>
<td style="text-align:left">Delete</td>
</tr>
<tr>
<td style="text-align:left">F</td>
<td style="text-align:left">Pin/unpin</td>
</tr>
<tr>
<td style="text-align:left">X</td>
<td style="text-align:left">Select</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + G</td>
<td style="text-align:left">Toggle list and grid view</td>
</tr>
<tr>
<td style="text-align:left">Esc</td>
<td style="text-align:left">Close editor</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Shift + 8</td>
<td style="text-align:left">Toggle checkboxes</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + ] / [</td>
<td style="text-align:left">Indent/dedent list item</td>
</tr>
<tr>
<td style="text-align:left">?</td>
<td style="text-align:left">Open shortcut list</td>
</tr>
<tr>
<td style="text-align:left">@</td>
<td style="text-align:left">Send feedback</td>
</tr>
</tbody>
</table>
<h3 id="joplintyporaonedrivehttpscomputetechnologydailycom20210212cf916cdb6cfb498aac38d4fa50d785a2"><a href="https://computetechnologydaily.com/2021/02/12/cf916cdb6cfb498aac38d4fa50d785a2/">Joplin+Typora+OneDrive</a><a hidden class="anchor" aria-hidden="true" href="#joplintyporaonedrivehttpscomputetechnologydailycom20210212cf916cdb6cfb498aac38d4fa50d785a2">#</a></h3>
<h4 id="joplin">Joplin<a hidden class="anchor" aria-hidden="true" href="#joplin">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ wget -O - https://raw.githubusercontent.com/laurent22/joplin/dev/Joplin_install_and_update.sh | bash
</code></pre></div><h4 id="marktexthttpsgithubcommarktextmarktext"><a href="https://github.com/marktext/marktext">MarkText</a><a hidden class="anchor" aria-hidden="true" href="#marktexthttpsgithubcommarktextmarktext">#</a></h4>
<h3 id="foxit-pdf-readerhttpswwwfoxitcompdf-reader"><a href="https://www.foxit.com/pdf-reader/">Foxit PDF Reader</a><a hidden class="anchor" aria-hidden="true" href="#foxit-pdf-readerhttpswwwfoxitcompdf-reader">#</a></h3>
<p>Industry’s most powerful PDF reader.</p>
<h4 id="portable-pdf-unlockerhttpssourceforgenetprojectsportablepdfunlockerfileslatestdownload"><a href="https://sourceforge.net/projects/portablepdfunlocker/files/latest/download">Portable PDF Unlocker</a><a hidden class="anchor" aria-hidden="true" href="#portable-pdf-unlockerhttpssourceforgenetprojectsportablepdfunlockerfileslatestdownload">#</a></h4>
<h4 id="pdfcrackhttppdfcracksourceforgenet"><a href="http://pdfcrack.sourceforge.net/">PDFCrack</a><a hidden class="anchor" aria-hidden="true" href="#pdfcrackhttppdfcracksourceforgenet">#</a></h4>
<h4 id="pdftkhttpsaskubuntucomquestions828720how-to-remove-the-password-from-a-pdf"><a href="https://askubuntu.com/questions/828720/how-to-remove-the-password-from-a-pdf">pdftk</a><a hidden class="anchor" aria-hidden="true" href="#pdftkhttpsaskubuntucomquestions828720how-to-remove-the-password-from-a-pdf">#</a></h4>
<h4 id="ocrmypdfhttpsgithubcomocrmypdfocrmypdf"><a href="https://github.com/ocrmypdf/OCRmyPDF">OCRmyPDF</a><a hidden class="anchor" aria-hidden="true" href="#ocrmypdfhttpsgithubcomocrmypdfocrmypdf">#</a></h4>
<p>OCRmyPDF adds an OCR text layer to scanned PDF files, allowing them to be searched</p>
<h3 id="wpshttpswwwwpscomdownload"><a href="https://www.wps.com/download/">WPS</a><a hidden class="anchor" aria-hidden="true" href="#wpshttpswwwwpscomdownload">#</a></h3>
<p>WPS Office is a lightweight, feature-rich comprehensive office suite with high compatibility.</p>
<p>最好用 snap 或者 flatpak 版本，因为很久没更新了，只有 WPS 2019，没有适配新的 KDE 5 和 Gnome 40。</p>
<h3 id="sublime-texthttpwwwsublimetextcom"><a href="http://www.sublimetext.com/">Sublime Text</a><a hidden class="anchor" aria-hidden="true" href="#sublime-texthttpwwwsublimetextcom">#</a></h3>
<h3 id="atomhttpsatomio"><a href="https://atom.io/">Atom</a><a hidden class="anchor" aria-hidden="true" href="#atomhttpsatomio">#</a></h3>
<h3 id="vim">Vim<a hidden class="anchor" aria-hidden="true" href="#vim">#</a></h3>
<h4 id="vi-与-vimtiny">vi 与 vim.tiny<a hidden class="anchor" aria-hidden="true" href="#vi-与-vimtiny">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ whereis vi
vi: /usr/bin/vi /usr/share/man/man1/vi.1.gz
$ ls -al /usr/bin/vi
lrwxrwxrwx <span style="color:#ae81ff">1</span> root root <span style="color:#ae81ff">20</span> Oct <span style="color:#ae81ff">26</span> 20:31 /usr/bin/vi -&gt; /etc/alternatives/vi
$ ls -al /etc/alternatives/vi
lrwxrwxrwx <span style="color:#ae81ff">1</span> root root <span style="color:#ae81ff">17</span> Oct <span style="color:#ae81ff">26</span> 20:31 /etc/alternatives/vi -&gt; /usr/bin/vim.tiny
</code></pre></div><p>可见，在Ubuntu上，vi是vim.tiny的软连接，但是执行命令vi与vim.tiny后是不一样，比如vi是：在编辑模式下使用方向键的时候，并不会使光标移动，而是在命令行中出现[A [B [C [D之类的字母；并且编辑错误的话，退格键(Backspace键)是使用不了的。</p>
<p><a href="https://unix.stackexchange.com/questions/150217/methods-to-find-out-which-configuration-files-are-read-by-executable-when-star">Methods to find out which (configuration) files are read by executable when started</a>-&gt;<a href="https://stackoverflow.com/questions/60404347/strace-vim-nano-ubuntu">&lsquo;strace vim/nano&rsquo; (Ubuntu)</a>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ strace -o $HOME/tracefile vi
$ cat tracefile | grep vimrc
stat<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;/usr/share/vim/vimrc.tiny&#34;</span>, <span style="color:#f92672">{</span>st_mode<span style="color:#f92672">=</span>S_IFREG|0644, st_size<span style="color:#f92672">=</span>662, ...<span style="color:#f92672">})</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
openat<span style="color:#f92672">(</span>AT_FDCWD, <span style="color:#e6db74">&#34;/usr/share/vim/vimrc.tiny&#34;</span>, O_RDONLY<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>
stat<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;/home/vane/.vimrc&#34;</span>, 0x7fff3e755550<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> -1 ENOENT <span style="color:#f92672">(</span>No such file or directory<span style="color:#f92672">)</span>
openat<span style="color:#f92672">(</span>AT_FDCWD, <span style="color:#e6db74">&#34;/home/vane/.vimrc&#34;</span>, O_RDONLY<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> -1 ENOENT <span style="color:#f92672">(</span>No such file or directory<span style="color:#f92672">)</span>
openat<span style="color:#f92672">(</span>AT_FDCWD, <span style="color:#e6db74">&#34;/home/vane/_vimrc&#34;</span>, O_RDONLY<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> -1 ENOENT <span style="color:#f92672">(</span>No such file or directory<span style="color:#f92672">)</span>
stat<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;/home/vane/.vim/vimrc&#34;</span>, 0x7fff3e755550<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> -1 ENOENT <span style="color:#f92672">(</span>No such file or directory<span style="color:#f92672">)</span>
openat<span style="color:#f92672">(</span>AT_FDCWD, <span style="color:#e6db74">&#34;/home/vane/.vim/vimrc&#34;</span>, O_RDONLY<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> -1 ENOENT <span style="color:#f92672">(</span>No such file or directory<span style="color:#f92672">)</span>
</code></pre></div><p>可以看到 vi，加载的是 <code>/usr/share/vim/vimrc.tiny</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ strace -o $HOME/tracefile vim.tiny
$ cat tracefile | grep vimrc
stat<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;/usr/share/vim/vimrc&#34;</span>, <span style="color:#f92672">{</span>st_mode<span style="color:#f92672">=</span>S_IFREG|0644, st_size<span style="color:#f92672">=</span>2266, ...<span style="color:#f92672">})</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
openat<span style="color:#f92672">(</span>AT_FDCWD, <span style="color:#e6db74">&#34;/usr/share/vim/vimrc&#34;</span>, O_RDONLY<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>
stat<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;/home/vane/.vimrc&#34;</span>, 0x7fff7c99cc30<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> -1 ENOENT <span style="color:#f92672">(</span>No such file or directory<span style="color:#f92672">)</span>
openat<span style="color:#f92672">(</span>AT_FDCWD, <span style="color:#e6db74">&#34;/home/vane/.vimrc&#34;</span>, O_RDONLY<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> -1 ENOENT <span style="color:#f92672">(</span>No such file or directory<span style="color:#f92672">)</span>
openat<span style="color:#f92672">(</span>AT_FDCWD, <span style="color:#e6db74">&#34;/home/vane/_vimrc&#34;</span>, O_RDONLY<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> -1 ENOENT <span style="color:#f92672">(</span>No such file or directory<span style="color:#f92672">)</span>
stat<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;/home/vane/.vim/vimrc&#34;</span>, 0x7fff7c99cc30<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> -1 ENOENT <span style="color:#f92672">(</span>No such file or directory<span style="color:#f92672">)</span>
openat<span style="color:#f92672">(</span>AT_FDCWD, <span style="color:#e6db74">&#34;/home/vane/.vim/vimrc&#34;</span>, O_RDONLY<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> -1 ENOENT <span style="color:#f92672">(</span>No such file or directory<span style="color:#f92672">)</span>
</code></pre></div><p>可以看到 vim.tiny，加载的是 <code>/usr/share/vim/vimrc</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ diff -u /etc/vim/vimrc /etc/vim/vimrc.tiny
--- /etc/vim/vimrc	2020-01-30 19:11:47.000000000 +0800
+++ /etc/vim/vimrc.tiny	2020-04-15 14:40:31.000000000 +0800
@@ -1,55 +1,13 @@
...
+<span style="color:#e6db74">&#34; Vim configuration file, in effect when invoked as &#34;</span>vi<span style="color:#e6db74">&#34;. The aim of this
</span><span style="color:#e6db74">+&#34;</span> configuration file is to provide a Vim environment as compatible with the
+<span style="color:#e6db74">&#34; original vi as possible. Note that ~/.vimrc configuration files as other
</span><span style="color:#e6db74">+&#34;</span> configuration files in the runtimepath are still sourced.
+<span style="color:#e6db74">&#34; When Vim is invoked differently (&#34;</span>vim<span style="color:#e6db74">&#34;, &#34;</span>view<span style="color:#e6db74">&#34;, &#34;</span>evim<span style="color:#e6db74">&#34;, ...) this file is
</span><span style="color:#e6db74">+&#34;</span> _not_ sourced; /etc/vim/vimrc and/or /etc/vim/gvimrc are.
...
</code></pre></div><p>可以看到，上面什么说明白了。</p>
<h4 id="vim-clear-last-search-highlightinghttpsstackoverflowcomquestions657447vim-clear-last-search-highlighting"><a href="https://stackoverflow.com/questions/657447/vim-clear-last-search-highlighting">Vim clear last search highlighting</a><a hidden class="anchor" aria-hidden="true" href="#vim-clear-last-search-highlightinghttpsstackoverflowcomquestions657447vim-clear-last-search-highlighting">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">:noh
</code></pre></div><h4 id="vimrchttpsgithubcomamixvimrc"><a href="https://github.com/amix/vimrc">VIMRC</a><a hidden class="anchor" aria-hidden="true" href="#vimrchttpsgithubcomamixvimrc">#</a></h4>
<p>The ultimate Vim configuration (vimrc)</p>
<h4 id="copilotvimhttpsgithubcomgithubcopilotvim"><a href="https://github.com/github/copilot.vim">copilot.vim</a><a hidden class="anchor" aria-hidden="true" href="#copilotvimhttpsgithubcomgithubcopilotvim">#</a></h4>
<p>Neovim plugin for GitHub Copilot</p>
<h4 id="neovimhttpsneovimio"><a href="https://neovim.io/">Neovim</a><a hidden class="anchor" aria-hidden="true" href="#neovimhttpsneovimio">#</a></h4>
<p>Neovim 提出了将 Vim 扩展为一个 IDE 的想法。</p>
<p>它增加了现代终端的功能，如光标样式、焦点事件、括号内粘贴等，并内置了一个终端模拟器。最重要的是，你不需要忘却 Vim 的习惯就可以开始使用 Neovim。</p>
<h3 id="最适合程序员的笔记软件httpswwwruanyifengcomblog202108best-note-taking-software-for-programmershtml"><a href="https://www.ruanyifeng.com/blog/2021/08/best-note-taking-software-for-programmers.html">最适合程序员的笔记软件</a><a hidden class="anchor" aria-hidden="true" href="#最适合程序员的笔记软件httpswwwruanyifengcomblog202108best-note-taking-software-for-programmershtml">#</a></h3>
<p>程序员的笔记软件，应该满足下面几个条件。</p>
<ul>
<li>跨平台，同时支持桌面电脑（Windows，Mac，Linux）和手机（Android，iOS）。</li>
<li>随时同步，打开任何一台机器，都能接着上一次的工作继续写。</li>
<li>实时存储，如果软件突然关闭，也不会丢失内容。</li>
<li>支持 Markdown 格式，便于后期直接发布。</li>
<li>支持推送到远程 Git 仓库，产生历史版本，同时作为远程备份。</li>
</ul>
<p><a href="https://stackedit.io/">Stackedit.io</a> 和 <a href="https://hackmd.io/">HackMD.io</a>，都不是很理想。</p>
<p>GitHub 官方推出的 <a href="https://docs.github.com/en/codespaces/developing-in-codespaces/web-based-editor">github.dev</a>。只要访问 <code>https://github.dev/[用户名]/[仓库名]</code>，你就能在浏览器里面，使用 VS Code 编辑指定仓库。它实际上就是 VS Code 编辑器的 Web 版，并且与 Git 高度集成。GitHub 提供了一个快捷入口。 打开 GitHub 仓库主页，按一下小数点（<code>.</code>）这个键， 页面就会自动跳转到 VS Code 编辑环境。</p>
<p>如果你更希望使用手机原生 App，我推荐 <a href="https://obsidian.md/">Obsidian</a>。它有全平台的客户端，并且可以参考<a href="https://forum.obsidian.md/t/mobile-setting-up-ios-git-based-syncing-with-mobile-app-using-working-copy/16499">这篇文章</a>设置 Git 集成。</p>
<p>评论里还有很多推荐，选择一个合适的就行。</p>
<h2 id="shell">Shell<a hidden class="anchor" aria-hidden="true" href="#shell">#</a></h2>
<h3 id="tmuxhttpswwwruanyifengcomblog201910tmuxhtml"><a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html">Tmux</a><a hidden class="anchor" aria-hidden="true" href="#tmuxhttpswwwruanyifengcomblog201910tmuxhtml">#</a></h3>
<p>Tmux 是一个终端复用器（terminal multiplexer），非常有用，属于常用的开发工具。</p>
<h4 id="简介-2">简介<a hidden class="anchor" aria-hidden="true" href="#简介-2">#</a></h4>
<p><strong>会话与进程</strong></p>
<p>命令行的典型使用方式是，打开一个终端窗口（terminal window，以下简称&quot;窗口&quot;），在里面输入命令。用户与计算机的这种临时的交互，称为一次&quot;会话&quot;（session） 。</p>
<p>会话的一个重要特点是，窗口与其中启动的进程是连在一起的。打开窗口，会话开始；关闭窗口，会话结束，会话内部的进程也会随之终止，不管有没有运行完。</p>
<p>一个典型的例子就是，SSH 登录远程计算机，打开一个远程窗口执行命令。这时，网络突然断线，再次登录的时候，是找不回上一次执行的命令的。因为上一次 SSH 会话已经终止了，里面的进程也随之消失了。</p>
<p>为了解决这个问题，会话与窗口可以&quot;解绑&quot;：窗口关闭时，会话并不终止，而是继续运行，等到以后需要的时候，再让会话&quot;绑定&quot;其他窗口。</p>
<p><strong>Tmux 的作用</strong></p>
<p>Tmux 就是会话与窗口的&quot;解绑&quot;工具，将它们彻底分离。</p>
<ol>
<li>它允许在单个窗口中，同时访问多个会话。这对于同时运行多个命令行程序很有用。</li>
<li>它可以让新窗口&quot;接入&quot;已经存在的会话。</li>
<li>它允许每个会话有多个连接窗口，因此可以多人实时共享会话。</li>
<li>它还支持窗口任意的垂直和水平拆分。</li>
</ol>
<p>类似的终端复用器还有 GNU Screen。Tmux 与它功能相似，但是更易用，也更强大。</p>
<h4 id="基本用法">基本用法<a hidden class="anchor" aria-hidden="true" href="#基本用法">#</a></h4>
<p><strong>安装</strong></p>
<p>Tmux 一般需要自己安装。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt-get install tmux
</code></pre></div><p><strong>启动与退出</strong></p>
<p>安装完成后，键入<code>tmux</code>命令，就进入了 Tmux 窗口。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ tmux
</code></pre></div><p>Tmux 窗口，底部有一个状态栏。状态栏的左侧是窗口信息（编号和名称），右侧是系统信息。</p>
<p>按下<code>Ctrl+d</code>或者显式输入<code>exit</code>命令，就可以退出 Tmux 窗口。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ exit
</code></pre></div><p><strong>前缀键</strong></p>
<p>Tmux 窗口有大量的快捷键。所有快捷键都要通过前缀键唤起。默认的前缀键是<code>Ctrl+b</code>，即先按下<code>Ctrl+b</code>，快捷键才会生效。</p>
<p>举例来说，帮助命令的快捷键是<code>Ctrl+b ?</code>。它的用法是，在 Tmux 窗口中，先按下<code>Ctrl+b</code>，再按下<code>?</code>，就会显示帮助信息。</p>
<p>然后，按下 ESC 键或<code>q</code>键，就可以退出帮助。</p>
<h4 id="会话管理">会话管理<a hidden class="anchor" aria-hidden="true" href="#会话管理">#</a></h4>
<p><strong>新建会话</strong></p>
<p>第一个启动的 Tmux 窗口，编号是<code>0</code>，第二个窗口的编号是<code>1</code>，以此类推。这些窗口对应的会话，就是 0 号会话、1 号会话。</p>
<p>使用编号区分会话，不太直观，更好的方法是为会话起名。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ tmux new -s &lt;session-name&gt;
</code></pre></div><p>上面命令新建一个指定名称的会话。</p>
<p><strong>分离会话</strong></p>
<p>在 Tmux 窗口中，按下<code>Ctrl+b d</code>或者输入<code>tmux detach</code>命令，就会将当前会话与窗口分离。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ tmux detach
</code></pre></div><p>上面命令执行后，就会退出当前 Tmux 窗口，但是会话和里面的进程仍然在后台运行。</p>
<p><code>tmux ls</code>命令或<code>Ctrl+b s</code>可以查看当前所有的 Tmux 会话。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ tmux ls
<span style="color:#75715e"># or</span>
$ tmux list-session
</code></pre></div><p><strong>接入会话</strong></p>
<p><code>tmux attach</code>命令用于重新接入某个已存在的会话。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 使用会话编号</span>
$ tmux attach -t <span style="color:#ae81ff">0</span>
<span style="color:#75715e"># 使用会话名称</span>
$ tmux attach -t &lt;session-name&gt;
</code></pre></div><p><strong>杀死会话</strong></p>
<p><code>tmux kill-session</code>命令用于杀死某个会话。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 使用会话编号</span>
$ tmux kill-session -t <span style="color:#ae81ff">0</span>
<span style="color:#75715e"># 使用会话名称</span>
$ tmux kill-session -t &lt;session-name&gt;
</code></pre></div><p><strong>切换会话</strong></p>
<p><code>tmux switch</code>命令用于切换会话。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 使用会话编号</span>
$ tmux switch -t <span style="color:#ae81ff">0</span>
<span style="color:#75715e"># 使用会话名称</span>
$ tmux switch -t &lt;session-name&gt;
</code></pre></div><p><strong>重命名会话</strong></p>
<p><code>tmux rename-session</code>命令或<code>Ctrl+b $</code>用于重命名会话。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ tmux rename-session -t <span style="color:#ae81ff">0</span> &lt;new-name&gt;
</code></pre></div><p>上面命令将0号会话重命名。</p>
<h4 id="最简操作流程">最简操作流程<a hidden class="anchor" aria-hidden="true" href="#最简操作流程">#</a></h4>
<p>综上所述，以下是 Tmux 的最简操作流程。</p>
<ol>
<li>在服务器端新建会话<code>tmux new -s my_session</code>。</li>
<li>在 Tmux 窗口运行所需的程序。</li>
<li>按下快捷键<code>Ctrl+b d</code>将会话分离。</li>
<li>下次使用时，重新连接到会话<code>tmux attach-session -t my_session</code>。</li>
</ol>
<h4 id="窗格操作">窗格操作<a hidden class="anchor" aria-hidden="true" href="#窗格操作">#</a></h4>
<p>Tmux 可以将窗口分成多个窗格（pane），每个窗格运行不同的命令。以下命令都是在 Tmux 窗口中执行。</p>
<p><strong>划分窗格</strong></p>
<p><code>tmux split-window</code>命令用来划分窗格。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 划分上下两个窗格，或 Ctrl+b &#34;</span>
$ tmux split-window
<span style="color:#75715e"># 划分左右两个窗格，或 Ctrl+b %</span>
$ tmux split-window -h
</code></pre></div><p><strong>移动光标</strong></p>
<p><code>tmux select-pane</code>命令或<code>Ctrl+b &lt;arrow key&gt;</code>用来移动光标位置。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 光标切换到上方窗格，或 Ctrl+b ;</span>
$ tmux <span style="color:#66d9ef">select</span>-pane -U
<span style="color:#75715e"># 光标切换到下方窗格，或 Ctrl+b o</span>
$ tmux <span style="color:#66d9ef">select</span>-pane -D
<span style="color:#75715e"># 光标切换到左边窗格</span>
$ tmux <span style="color:#66d9ef">select</span>-pane -L
<span style="color:#75715e"># 光标切换到右边窗格</span>
$ tmux <span style="color:#66d9ef">select</span>-pane -R
</code></pre></div><ul>
<li><code>Ctrl+b x</code>：关闭当前窗格。</li>
<li><code>Ctrl+b !</code>：将当前窗格拆分为一个独立窗口。</li>
<li><code>Ctrl+b z</code>：当前窗格全屏显示，再使用一次会变回原来大小。</li>
<li><code>Ctrl+b Ctrl+&lt;arrow key&gt;</code>：按箭头方向调整窗格大小。</li>
<li><code>Ctrl+b q</code>：显示窗格编号。</li>
</ul>
<p><strong>交换窗格位置</strong></p>
<p><code>tmux swap-pane</code>命令用来交换窗格位置。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 当前窗格上移，或 Ctrl+b {</span>
$ tmux swap-pane -U
<span style="color:#75715e"># 当前窗格下移，或 Ctrl+b }</span>
$ tmux swap-pane -D
</code></pre></div><ul>
<li><code>Ctrl+b Ctrl+o</code>：所有窗格向前移动一个位置，第一个窗格变成最后一个窗格。</li>
<li><code>Ctrl+b Alt+o</code>：所有窗格向后移动一个位置，最后一个窗格变成第一个窗格。</li>
</ul>
<h4 id="窗口管理">窗口管理<a hidden class="anchor" aria-hidden="true" href="#窗口管理">#</a></h4>
<p>除了将一个窗口划分成多个窗格，Tmux 也允许新建多个窗口。</p>
<p><strong>新建窗口</strong></p>
<p><code>tmux new-window</code>命令用来创建新窗口。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ tmux new-window
<span style="color:#75715e"># 新建一个指定名称的窗口</span>
$ tmux new-window -n &lt;window-name&gt;
</code></pre></div><p><code>Ctrl+b c</code>：创建一个新窗口，状态栏会显示多个窗口的信息。</p>
<p><strong>切换窗口</strong></p>
<p><code>tmux select-window</code>命令用来切换窗口。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 切换到指定编号的窗口</span>
$ tmux <span style="color:#66d9ef">select</span>-window -t &lt;window-number&gt;
<span style="color:#75715e"># 切换到指定名称的窗口</span>
$ tmux <span style="color:#66d9ef">select</span>-window -t &lt;window-name&gt;
</code></pre></div><ul>
<li><code>Ctrl+b p</code>：切换到上一个窗口（按照状态栏上的顺序）。</li>
<li><code>Ctrl+b n</code>：切换到下一个窗口。</li>
<li><code>Ctrl+b &lt;number&gt;</code>：切换到指定编号的窗口，其中的<code>&lt;number&gt;</code>是状态栏上的窗口编号。</li>
<li><code>Ctrl+b w</code>：从列表中选择窗口。</li>
</ul>
<p><strong>重命名窗口</strong></p>
<p><code>tmux rename-window</code>命令或<code>Ctrl+b ,</code>用于为当前窗口起名（或重命名）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ tmux rename-window &lt;new-name&gt;
</code></pre></div><h4 id="其他命令">其他命令<a hidden class="anchor" aria-hidden="true" href="#其他命令">#</a></h4>
<p>下面是一些其他命令。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 列出所有快捷键，及其对应的 Tmux 命令</span>
$ tmux list-keys
<span style="color:#75715e"># 列出所有 Tmux 命令及其参数</span>
$ tmux list-commands
<span style="color:#75715e"># 列出当前所有 Tmux 会话的信息</span>
$ tmux info
<span style="color:#75715e"># 重新加载当前的 Tmux 配置</span>
$ tmux source-file ~/.tmux.conf
</code></pre></div><h3 id="fishhttpswwwruanyifengcomblog201705fish_shellhtml"><a href="https://www.ruanyifeng.com/blog/2017/05/fish_shell.html">Fish</a><a hidden class="anchor" aria-hidden="true" href="#fishhttpswwwruanyifengcomblog201705fish_shellhtml">#</a></h3>
<p><a href="https://zh.wikipedia.org/wiki/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2">命令行</a>是程序员的必备技能。图形界面虽然好看，解决问题还是要靠命令行。</p>
<p>命令行由 Shell 提供。各种命令通过 Shell，传递给操作系统的内核。学习命令行就是在学习 Shell。</p>
<p>Shell 有好几种，目前最常用是 <a href="https://en.wikipedia.org/wiki/Bash_(Unix_shell)">Bash</a> 和 <a href="https://en.wikipedia.org/wiki/Z_shell">zsh</a>。但是，在我看来，它们都不如 <a href="https://fishshell.com/">Fish Shell</a> 好用。</p>
<p>五年前，我第一次尝试 Fish，感到很惊艳，一直用到现在。本文介绍 Fish 的主要特点，希望你也来尝试它。</p>
<h4 id="简介-3">简介<a hidden class="anchor" aria-hidden="true" href="#简介-3">#</a></h4>
<p>Fish 是&quot;the <strong>f</strong>riendly <strong>i</strong>nteractive <strong>sh</strong>ell&quot;的简称，最大特点就是方便易用。很多其他 Shell 需要配置才有的功能，Fish 默认提供，不需要任何配置。</p>
<p>如果你想拥有一个方便好用的 Shell，又不想学习一大堆语法，或者花费很多时间配置，那么你一定要尝试一下 Fish。</p>
<h4 id="安装">安装<a hidden class="anchor" aria-hidden="true" href="#安装">#</a></h4>
<p>Ubuntu 的安装方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install fish
</code></pre></div><p>其他系统的安装请参考<a href="https://fishshell.com/#platform_tabs">官方网站</a>。</p>
<h4 id="启动与帮助">启动与帮助<a hidden class="anchor" aria-hidden="true" href="#启动与帮助">#</a></h4>
<p>安装完成后，就可以启动 Fish。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ fish
</code></pre></div><p>由于 Fish 的语法与 Bash 有很大差异，Bash 脚本一般不兼容。因此，我建议不要将 Fish 设为默认 Shell，而是每次手动启动它。</p>
<p>使用过程中，如果需要帮助，可以输入<code>help</code>命令。浏览器就会自动打开，显示在线文档。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ help
</code></pre></div><h4 id="彩色显示">彩色显示<a hidden class="anchor" aria-hidden="true" href="#彩色显示">#</a></h4>
<p>进入 Fish 以后，你注意到的第一件事，可能就是它默认彩色显示。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 无效命令为红色</span>
$ mkd

<span style="color:#75715e"># 有效命令为蓝色</span>
$ mkdir
</code></pre></div><p>有效路径会有下划线。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat ~/somefi 
</code></pre></div><p>上面代码表示，存在以<code>~/somefi</code>开头的路径。如果没有下划线，你就知道这个路径不存在。</p>
<h4 id="自动建议">自动建议<a hidden class="anchor" aria-hidden="true" href="#自动建议">#</a></h4>
<p>Fish 会自动在光标后面给出建议，表示可能的选项，颜色为灰色。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 命令建议</span>
$ /bin/hostname

<span style="color:#75715e"># 参数建议</span>
$ grep --ignore-case

<span style="color:#75715e"># 路径建议</span>
$ ls node_modules
</code></pre></div><p>如果采纳建议，可以按下<code>→</code>或<code>Control + F</code>。如果只采纳一部分，可以按下<code>Alt + →</code>。</p>
<h4 id="自动补全">自动补全<a hidden class="anchor" aria-hidden="true" href="#自动补全">#</a></h4>
<p>输入命令时，Fish 会自动显示匹配的上一条历史记录。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git commit -m <span style="color:#e6db74">&#34;feat: first commit&#34;</span>
</code></pre></div><p>如果没有匹配的历史记录，Fish 会猜测可能的结果，自动补全各种输入。比如，输入<code>pyt</code>再按下<code>Tab</code>，就会自动补全为<code>python</code>命令。</p>
<p>如果有多个可能的结果，Fish 会把它们都列出，还带有简要介绍。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ vi<span style="color:#f92672">[</span>按下 Tab 键<span style="color:#f92672">]</span>

vi <span style="color:#f92672">(</span>Executable link, 2.7MB<span style="color:#f92672">)</span>
view <span style="color:#f92672">(</span>Vi IMproved, 一个程序员的文本编辑器<span style="color:#f92672">)</span>
viewer.py <span style="color:#f92672">(</span>Executable, 967B<span style="color:#f92672">)</span>
viewres  <span style="color:#f92672">(</span>Graphical class browser <span style="color:#66d9ef">for</span> Xt<span style="color:#f92672">)</span>
...and <span style="color:#ae81ff">12</span> more rows
</code></pre></div><p>这时，再按一次<code>tab</code>，就可以在这些命令之中选择。</p>
<p>除了补全命令，Fish 还可以补全参数。比如，<code>ls</code>命令的<code>-l</code>参数后面按下<code>Tab</code>键，就会显示可以连用的其他参数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ls -l<span style="color:#f92672">[</span>按下 Tab 键<span style="color:#f92672">]</span>

-l1  <span style="color:#f92672">(</span>List one file per line<span style="color:#f92672">)</span>
-lA  <span style="color:#f92672">(</span>Show hidden except . and ..<span style="color:#f92672">)</span>  
-la  <span style="color:#f92672">(</span>Show hidden<span style="color:#f92672">)</span>
-lB  <span style="color:#f92672">(</span>Ignore files ending with ~<span style="color:#f92672">)</span>
...and <span style="color:#ae81ff">16</span> more rows<span style="color:#e6db74">```</span>
</code></pre></div><p>Fish 还可以自动补全 Git 分支。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git checkout master
</code></pre></div><h4 id="易懂的语法">易懂的语法<a hidden class="anchor" aria-hidden="true" href="#易懂的语法">#</a></h4>
<p>Fish 的语法非常自然，一眼就能看懂。</p>
<p><code>if</code>语句：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#66d9ef">if</span> grep fish /etc/shells
    echo Found fish
<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> grep bash /etc/shells
    echo Found bash
<span style="color:#66d9ef">else</span>
    echo Got nothing
end
</code></pre></div><p><code>switch</code>语句：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">switch <span style="color:#f92672">(</span>uname<span style="color:#f92672">)</span>
<span style="color:#66d9ef">case</span> Linux
    echo Hi Tux!
<span style="color:#66d9ef">case</span> Darwin
    echo Hi Hexley!
<span style="color:#66d9ef">case</span> FreeBSD NetBSD DragonFly
    echo Hi Beastie!
<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;*&#39;</span>
    echo Hi, stranger!
end
</code></pre></div><p><code>while</code>循环：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#66d9ef">while</span> true
    echo <span style="color:#e6db74">&#34;Loop forever&#34;</span>
end
</code></pre></div><p><code>for</code>循环：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#66d9ef">for</span> file in *.txt
    cp $file $file.bak
end
</code></pre></div><h4 id="函数">函数<a hidden class="anchor" aria-hidden="true" href="#函数">#</a></h4>
<p>Fish 的函数用来封装命令，或者为现有的命令起别名。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#66d9ef">function</span> ll
    ls -lhG $argv
end
</code></pre></div><p>上面代码定义了一个<code>ll</code>函数。命令行执行这个函数以后，就可以用<code>ll</code>命令替代<code>ls -lhG</code>。其中，变量<code>$argv</code>表示函数的参数。</p>
<p>下面是另一个例子。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#66d9ef">function</span> ls
    command ls -hG $argv
end
</code></pre></div><p>上面的代码重新定义<code>ls</code>命令。注意，函数体内的<code>ls</code>之前，要加上<code>command</code>，否则会因为无限循环而报错。</p>
<h4 id="提示符">提示符<a hidden class="anchor" aria-hidden="true" href="#提示符">#</a></h4>
<p><code>fish_prompt</code>函数用于定义命令行提示符（prompt）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#66d9ef">function</span> fish_prompt
    set_color purple
    date <span style="color:#e6db74">&#34;+%m/%d/%y&#34;</span>
    set_color FF0
    echo <span style="color:#f92672">(</span>pwd<span style="color:#f92672">)</span> <span style="color:#e6db74">&#39;&gt;&#39;</span>
    set_color normal
end
</code></pre></div><p>执行上面的函数以后，你的命令行提示符就会变成下面这样。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">02/06/13
/home/tutorial &gt; 
</code></pre></div><h4 id="配置-1">配置<a hidden class="anchor" aria-hidden="true" href="#配置-1">#</a></h4>
<p>Fish 的配置文件是<code>~/.config/fish/config.fish</code>，每次 Fish 启动，就会自动加载这个文件。</p>
<p>我们可以在这个文件里面写入各种自定义函数，它们会被自动加载。比如，上面的<code>fish_prompt</code>函数就可以写在这个文件里面，这样每次启动 Fish，就会出现自定义的提示符。</p>
<p>Fish 还提供 Web 界面配置该文件。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ fish_config
</code></pre></div><p>输入上面的命令以后，浏览器就会自动打开本机的 8000 端口，用户可以在网页上对 Fish 进行配置，比如选择提示符和配色主题。</p>
<h3 id="zsh">Zsh<a hidden class="anchor" aria-hidden="true" href="#zsh">#</a></h3>
<h4 id="oh-my-zshhttpsgithubcomohmyzshohmyzsh"><a href="https://github.com/ohmyzsh/ohmyzsh">Oh My Zsh</a><a hidden class="anchor" aria-hidden="true" href="#oh-my-zshhttpsgithubcomohmyzshohmyzsh">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sh -c <span style="color:#e6db74">&#34;</span><span style="color:#66d9ef">$(</span>wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -<span style="color:#66d9ef">)</span><span style="color:#e6db74">&#34;</span>
</code></pre></div><p>oh-my-zsh应该对通配符作了限制，需要用跳脱字符</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">sudo apt remove fcitx<span style="color:#ae81ff">\*</span>
</code></pre></div><p>Zsh theme：<a href="https://www.slant.co/topics/7553/~theme-for-oh-my-zsh">What&rsquo;s the best theme for Oh My Zsh?</a></p>
<h2 id="proxy">Proxy<a hidden class="anchor" aria-hidden="true" href="#proxy">#</a></h2>
<h3 id="v2rayhttpsarchlinuxstudiogithubioarchlinuxtutorialrookiefxckgfw"><a href="https://archlinuxstudio.github.io/ArchLinuxTutorial/#/rookie/fxckGFW">v2ray</a><a hidden class="anchor" aria-hidden="true" href="#v2rayhttpsarchlinuxstudiogithubioarchlinuxtutorialrookiefxckgfw">#</a></h3>
<h4 id="节点准备">节点准备<a hidden class="anchor" aria-hidden="true" href="#节点准备">#</a></h4>
<p>简单来讲节点是形如如下的神秘链接：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-txt" data-lang="txt">ss://xxxxxxxxxxxxxxxxxxxxxxxxxxxx
vmess://xxxxxxxxxxxxxxxxxxxxxxxxxxxx
</code></pre></div><p>如果你没有这些连接：</p>
<ul>
<li>自行部署，你则需要自行购买处于自由互联网的服务器并进行节点搭建，这不在本文讨论范围内。如果你需要购买服务器，推荐一个 VPS 提供商：<a href="https://justhost.ru/">justhost.ru</a>。</li>
<li>购买机场的订阅服务，可以参考它们的订阅流程以获取节点。需要提醒的是，机场服务属于灰色产业，随时有停止服务的可能，购买建议以月付进行购买以避免过大损失。关于机场审计规则，我们的观点是&quot;我可以不看，但是你不可以封禁&quot;。对于机场审计程度，读者可根据自身实际情况自行评估。</li>
<li>如果你不想花任何费用，可安装<a href="https://psiphon3.com/zh/index.html">赛风</a>这类软件。它是自由软件。如果你使用赛风，可以非常方便的发送空邮件到<a href="mailto:get@psiphon3.com">get@psiphon3.com</a>以获取赛风下载链接。赛风应用目前只支持 Windows\Android\IOS\MacOS 平台。当你在这些平台上能够访问自由互联网时，可以去各个渠道搜索可用的节点和代理资源。注意，使用公共节点需要自行承担可能的风险。</li>
</ul>
<h4 id="安装-1">安装<a hidden class="anchor" aria-hidden="true" href="#安装-1">#</a></h4>
<p><a href="https://github.com/v2fly/v2ray-core">v2ray</a>/<a href="https://github.com/XTLS/Xray-core"> Xray-core</a> 是使用 <a href="https://github.com/Qv2ray/Qv2ray/">Qv2ray</a>（原项目已停止开发） 以及 <a href="https://github.com/v2rayA/v2rayA">V2rayA</a> 的前提，需要先进行安装。</p>
<p>Qv2ray 和 V2rayA 是两款非常优秀的在 Linux 上可用的科学上网通用客户端：</p>
<ul>
<li>Qv2ray：安装后在 Plugins 中，选择 V2ray Core Plugin，并进行 V2ray 的设置。现在你已经可以使用，你需要按照<a href="https://qv2ray.net/">官方文档</a>导入已有的链接或订阅。</li>
<li>V2rayA：2rayA 是一个浏览器客户端，使用非常方便。更多使用方法请看<a href="https://v2raya.org/">官方文档</a></li>
</ul>
<h4 id="代理配置">代理配置<a hidden class="anchor" aria-hidden="true" href="#代理配置">#</a></h4>
<p>在经过上述步骤后，你应该已经有了 SOCKS5 代理以及 HTTP 代理的地址和端口。接下来进行设置：</p>
<ul>
<li>
<p>系统代理：在节点链接后，你可在<code>系统设置</code> -&gt; <code>网络设置</code> -&gt; <code>代理</code>中设置代理。注意，<strong><code>系统设置</code>中的代理配置在 KDE 桌面环境中并不是所有应用都会遵守</strong>。没有遵循系统设置代理的应用还需要单独进行代理配置。</p>
</li>
<li>
<p>终端</p>
<p>可以通过 export 命令设置当前终端的代理方式。比如使用 tldr 或 github raw 等资源需要设置 https 代理。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">export https_proxy<span style="color:#f92672">=</span>http://127.0.0.1:8889
export http_proxy<span style="color:#f92672">=</span>http://127.0.0.1:8889
export all_proxy<span style="color:#f92672">=</span>http://127.0.0.1:8889
</code></pre></div><p>不同终端命令所识别的环境变量名不同，如 all_proxy 对 curl 生效，而对 wget 则不生效，具体可查看各个命令的 man page。</p>
</li>
<li>
<p><a href="https://github.com/haad/proxychains">proxychains</a>/<a href="https://github.com/rofl0r/proxychains-ng">proxychains-ng</a></p>
<p>如果对于一个应用，KDE 的系统代理不生效，在终端 export 了 ALL_PROXY 变量再用终端启动此应用代理也不生效，并且这个应用自身也没有配置代理的选项（即应用不支持代理）。此时可以使用 proxychains，它可以为单行命令配置代理，它是一个预加载的 hook，允许通过一个或多个 SOCKS 或 HTTP 代理重定向现有动态链接程序的 TCP 流量（即强制应用走代理）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install proxychains
$ sudo vim /etc/proxychains.conf
socks5 127.0.0.1 <span style="color:#ae81ff">1089</span>
</code></pre></div></li>
</ul>
<h4 id="透明代理httpsarchicekylinonlinerookietransparenthtml"><a href="https://arch.icekylin.online/rookie/transparent.html">透明代理</a><a hidden class="anchor" aria-hidden="true" href="#透明代理httpsarchicekylinonlinerookietransparenthtml">#</a></h4>
<p>全局代理，也即透明代理。之所以叫做透明代理，是因为这代理对于操作系统中的各个应用相当于是透明的，应用们感知不到代理的存在。之所以叫做全局代理，很明显意为全局所有流量都走代理。</p>
<ul>
<li>
<p>在 Qv2ray 的“首选项-入站设置”的下方启用任意门设置选项。</p>
<ul>
<li>监听 ipv4 地址可填<code>127.0.0.1</code> 或 <code>0.0.0.0</code>，建议前者。若需双栈代理，则在监听 ipv6 地址填上<code>::1</code>（如果监听 ipv4 填了 0.0.0.0 则可不填）。</li>
<li>嗅探选择 Full，Destination Override 的三项均勾选。</li>
<li>模式选择“tproxy”。</li>
</ul>
</li>
<li>
<p>安装<a href="https://github.com/springzfx/cgproxy#introduction">cgproxy</a>软件，编辑<code>/etc/cgproxy/config.json</code>：</p>
<ul>
<li>在<code>cgroup_proxy</code>中括号里加上<code>&quot;/&quot;</code>，<code>port</code>改为 Qv2ray 首选项里的透明代理的端口。</li>
<li>cgproxy默认配置是代理所有 tcp 和 udp，ipv4 和 ipv6 的流量，如果不希望代理其中的某种（些）流量，则将对应的<code>enable_xxx</code>改为 <code>false</code>。注意这里的配置要和 Qv2ray 选项里的配置一致，如 Qv2ray 选项里没有勾选 udp，则这里务必把<code>enable_udp</code>改为 false。</li>
<li>如果希望当本机作为网关设备时为连接到本机的其他设备（如连接到本机开设的 wifi 热点的设备）也提供透明代理，则把<code>enable_gateway</code>改为 <code>true</code></li>
</ul>
</li>
<li>
<p>透明代理的基本原理是拦截系统发出的所有流量，并将这些流量转到代理工具里，从而实现让系统所有流量都走代理的目的。此时，为了避免流量出现死循环（即代理工具发出的流量又转回到代理工具里），需要将代理工具排除在透明代理环境外面。有两种方式可以实现这一点：</p>
<ul>
<li>
<p>通过execsnoop监控代理工具的启动，并自动将其移至透明代理环境外面：</p>
<ul>
<li>cgproxy软件自带execsnoop支持，以上cgproxy测试过的发行版均可支持。</li>
<li>编辑<code>/etc/cgproxy/config.json</code>，在<code>program_noproxy</code>中括号里加上<code>&quot;v2ray&quot;</code>、<code>&quot;qv2ray&quot;</code>，以使qv2ray和v2ray发出的流量不经过透明代理。如果你的v2ray或qv2ray不在PATH里，则需要填写它们的绝对路径。</li>
</ul>
</li>
<li>
<p>在每次连接代理节点时，让qv2ray自己把自己移到透明代理环境外面：</p>
<p>安装 Qvplugin-Command 插件，在插件设置里的“pre-connection”栏里加上一句</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">sh -c <span style="color:#e6db74">&#34;cgnoproxy --pid </span><span style="color:#66d9ef">$(</span>pgrep -x qv2ray<span style="color:#66d9ef">)</span><span style="color:#e6db74">&#34;</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p>如果启用了 udp 的透明代理（dns 也是 udp），则给 v2ray 二进制文件加上相应的特权：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">sudo setcap <span style="color:#e6db74">&#34;cap_net_admin,cap_net_bind_service=ep&#34;</span> /usr/bin/v2ray
</code></pre></div><p>否则 udp 的透明代理可能会出问题。如果每次更新了 v2ray 二进制文件，都需要重新执行此命令。</p>
</li>
<li>
<p>启动透明代理服务：<code>systemctl start cgproxy.service</code>或<code>systemctl enable --now cgproxy.service</code>。</p>
</li>
</ul>
<p>以上步骤完成后，透明代理应该能正常使用了。</p>
<h5 id="dns-1"><strong>dns</strong><a hidden class="anchor" aria-hidden="true" href="#dns-1">#</a></h5>
<p>如果勾选了“dns 拦截”，且启用了 dns 和 udp 的透明代理，则 v2ray 会拦截对系统 dns 的请求，并将其转发到 v2ray 的内置 dns 里，即让 v2ray 内置 dns 接管系统 dns。但 v2ray 内置 dns 是会遵循路由规则的。</p>
<p>如果没勾选“dns 拦截”，则 v2ray 虽然不会让内置 dns 接管系统 dns，但如果启用了 dns 和 udp 的透明代理，则系统 dns 也会走透明代理进 v2ray，并遵循 v2ray 的路由规则。</p>
<p>因此，在启用了 dns 和 udp 的透明代理时，若系统 dns 或 v2ray 的内置 dns 配置不当，可能导致 dns 请求发不出去，从而影响正常上网。</p>
<p>由于 qv2ray 常见的路由规则是绕过国内 ip，国外 ip 均走代理。在这个情形中，以下两个配置是典型的有问题的 dns 配置方式：</p>
<ul>
<li>配置了国外普通 dns 作为首选，但代理本身不支持 udp（此时 dns 查询的 udp 流量出不去，dns 无法查询）</li>
<li>配置了使用域名的 doh 作为首选。此时 doh 的域名无法被解析，从而 doh 也无法使用。</li>
</ul>
<p>一般而言，如果并不在意将 dns 查询发给谁，那么，在绕过国内 ip 的情况下，只需要配置一个国内普通 dns 作为首选即可保证不会出问题。若代理本身不支持 udp，又希望使用国外 dns，则可以考虑使用使用 ip 的 doh（如<code>https://1.1.1.1/dns-query</code>等）。</p>
<p>如果需要更复杂的 dns 配置，建议参考<a href="https://www.v2ray.com/chapter_02/04_dns.html">上游文档</a>，并选择合适的不会影响正常上网的 dns 配置。</p>
<h3 id="clashhttpszhuanlanzhihucomp369344633"><a href="https://zhuanlan.zhihu.com/p/369344633">Clash</a><a hidden class="anchor" aria-hidden="true" href="#clashhttpszhuanlanzhihucomp369344633">#</a></h3>
<p><a href="https://github.com/Dreamacro/clash">下载 clash</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ gzip -d clash-v1.6.5.gz
$ mkdir ~/.clash <span style="color:#f92672">&amp;&amp;</span> mv clash-v1.6.5 ~/.clash/clash
</code></pre></div><p>下载配置</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ wget -O config.yaml <span style="color:#f92672">[</span>订阅链接<span style="color:#f92672">]</span>
</code></pre></div><p>运行 clash</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ chmod <span style="color:#ae81ff">770</span> clash./clash -d .
</code></pre></div><p>使用 <a href="http://clash.razord.top">clash dashboard</a> 选择节点</p>
<p>设置系统代理：</p>
<ul>
<li>
<p>GUI：打开系统设置，点击网络代理右边的 ⚙ 按钮，选择手动</p>
<ul>
<li>HTTP 和 HTTPS 代理为 127.0.0.1:7890</li>
<li>Socks 主机为 127.0.0.1:7891</li>
</ul>
</li>
<li>
<p>CLI：<a href="https://www.xmodulo.com/change-system-proxy-settings-command-line-ubuntu-desktop.html">change system proxy settings from the command line</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># To modify a DConf setting:</span>
$ gsettings set &lt;schema&gt; &lt;key&gt; &lt;value&gt;

<span style="color:#75715e"># To read a DConf setting:</span>
$ gsettings get &lt;schema&gt; &lt;key&gt;
</code></pre></div></li>
</ul>
<p>相关软件：</p>
<ul>
<li><a href="https://github.com/nadoo/glider">glider</a></li>
<li><a href="https://github.com/getlantern/lantern">Lantern</a></li>
<li><a href="https://www.privoxy.org/">Privoxy</a></li>
<li><a href="https://github.com/OpenVPN/openvpn">openvpn</a></li>
<li><a href="https://shadowsocks.org/en/index.html">Shadowsocks</a></li>
<li><a href="https://www.torproject.org/download/download.html.en">Tor</a></li>
<li><a href="https://github.com/trojan-gfw/trojan">trojan</a>：<a href="https://tlanyan.pp.ua/trojan-tutorial/">trojan教程</a></li>
</ul>
<h4 id="脚本一">脚本一<a hidden class="anchor" aria-hidden="true" href="#脚本一">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ vi ~/.clash/run-clash.sh
<span style="color:#75715e">#!/bin/bash</span>
CLASH_HOME<span style="color:#f92672">=</span>/home/vane/.clash
subscription<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;订阅连接&#34;</span>

<span style="color:#75715e"># 设置系统代理</span>
<span style="color:#66d9ef">function</span> setting
<span style="color:#f92672">{</span>
  gsettings set org.gnome.system.proxy.http host <span style="color:#e6db74">&#39;127.0.0.1&#39;</span>
  gsettings set org.gnome.system.proxy.http port <span style="color:#e6db74">&#39;7890&#39;</span>
  gsettings set org.gnome.system.proxy.https host <span style="color:#e6db74">&#39;127.0.0.1&#39;</span>
  gsettings set org.gnome.system.proxy.https port <span style="color:#e6db74">&#39;7890&#39;</span>
  gsettings set org.gnome.system.proxy.socks host <span style="color:#e6db74">&#39;127.0.0.1&#39;</span>
  gsettings set org.gnome.system.proxy.socks port <span style="color:#e6db74">&#39;7891&#39;</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e"># 更新订阅</span>
<span style="color:#66d9ef">function</span> update
<span style="color:#f92672">{</span>
  wget -O $CLASH_HOME/config.yaml $subscription
<span style="color:#f92672">}</span>

<span style="color:#75715e"># 运行 clash</span>
<span style="color:#66d9ef">function</span> run
<span style="color:#f92672">{</span>  
  <span style="color:#75715e"># 打开系统代理（之前已经设置了）</span>
  gsettings set org.gnome.system.proxy mode <span style="color:#e6db74">&#39;manual&#39;</span> 
  $CLASH_HOME/clash -d $CLASH_HOME/
<span style="color:#f92672">}</span>

<span style="color:#75715e"># 停止运行 clash</span>
<span style="color:#66d9ef">function</span> stop
<span style="color:#f92672">{</span> 
  <span style="color:#75715e"># 关闭系统代理  </span>
  gsettings set org.gnome.system.proxy mode <span style="color:#e6db74">&#39;none&#39;</span>
<span style="color:#f92672">}</span>
  
<span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> <span style="color:#e6db74">&#34;</span>$1<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;-u&#34;</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>  
  update
<span style="color:#66d9ef">elif</span> <span style="color:#f92672">[</span> <span style="color:#e6db74">&#34;</span>$1<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;-r&#34;</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span> 
  run
<span style="color:#66d9ef">elif</span> <span style="color:#f92672">[</span> <span style="color:#e6db74">&#34;</span>$1<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;-s&#34;</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
  setting
<span style="color:#66d9ef">else</span>  
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> <span style="color:#e6db74">&#34;</span>$1<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span> 
      $CLASH_HOME/clash $1 
    <span style="color:#66d9ef">else</span>  
      echo Plese run clash -r  
    <span style="color:#66d9ef">fi</span>
<span style="color:#66d9ef">fi</span>

trap stop EXIT
</code></pre></div><p><a href="https://www.xmodulo.com/change-system-proxy-settings-command-line-ubuntu-desktop.html">How to change system proxy settings from the command line on Ubuntu desktop</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ chmod <span style="color:#ae81ff">700</span> run-clash.sh
</code></pre></div><h4 id="脚本二">脚本二<a hidden class="anchor" aria-hidden="true" href="#脚本二">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ vi ~/.clash/rc.sh
<span style="color:#75715e">#!/bin/bash</span>
/usr/bin/wget -O home/kurome/.clash/config.yaml <span style="color:#e6db74">&#34;订阅连接&#34;</span>
/home/kurome/.clash/clash -d /home/kurome/.clash/
</code></pre></div><p><a href="https://github.com/Dreamacro/clash/wiki/clash-as-a-daemon">clash as a daemon</a>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo vi /usr/lib/systemd/system/clash.service
<span style="color:#f92672">[</span>Unit<span style="color:#f92672">]</span>
Description<span style="color:#f92672">=</span>Clash daemon, A rule-based proxy in Go.
After<span style="color:#f92672">=</span>network.target

<span style="color:#f92672">[</span>Service<span style="color:#f92672">]</span>
Type<span style="color:#f92672">=</span>simple
Restart<span style="color:#f92672">=</span>always
RestartSec<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>
ExecStart<span style="color:#f92672">=</span>/bin/bash /home/kurome/.clash/rc.sh

<span style="color:#f92672">[</span>Install<span style="color:#f92672">]</span>
WantedBy<span style="color:#f92672">=</span>multi-user.target
</code></pre></div><p>运行</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ systemctl enable clash.service
$ systemctl start clash.service
$ systemctl status clash.service
</code></pre></div><p>如果不想代理了，可以直接在  <a href="http://clash.razord.top">clash dashboard</a> 的 Proxy （如果有的话）或者 Settting 里选择 DIRECT，而不是关闭 clash.service。根据设置的规则，有的流量会走代理，有的流量直接走。</p>
<h4 id="tun-模式httpslancellcgitbookioclashstart-clashclash-tun-mode"><a href="https://lancellc.gitbook.io/clash/start-clash/clash-tun-mode">TUN 模式</a><a hidden class="anchor" aria-hidden="true" href="#tun-模式httpslancellcgitbookioclashstart-clashclash-tun-mode">#</a></h4>
<p>“系统代理”一般只是桌面环境下的约定，需要 app 遵循约定才行。也就是说 HTTP_PROXY 这种环境变量只是约定俗成的，大家都从这里面读取代理地址，但是程序里必须要有读取这个变量的相关代码才行。</p>
<p>因此某些软件&amp;命令行软件不支持系统代理。</p>
<h5 id="clash-for-windowshttpsgithubcomfndroidclash_for_windows_pkgreleases"><a href="https://github.com/Fndroid/clash_for_windows_pkg/releases">Clash for Windows</a><a hidden class="anchor" aria-hidden="true" href="#clash-for-windowshttpsgithubcomfndroidclash_for_windows_pkgreleases">#</a></h5>
<p>tun 模式对全部 app 生效——对于不遵循系统代理的软件，TUN 模式可以接管其流量并交由 CFW 处理。<a href="https://docs.cfw.lbyczf.com/contents/tun.html#linux">启动 TUN 模式</a>需要进行如下操作：</p>
<ol>
<li>
<p>安装 nftables 和 iproute2 并重启</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install nftables iproute2
$ sudo reboot
</code></pre></div></li>
<li>
<p>点击<code>General</code>中<code>Service Mode</code>右边<code>Manage</code>，在打开窗口中安装服务模式，安装完成应用会自动重启（某些系统需要手动重启 APP），Service Mode 右边地球图标变为<code>绿色</code>即安装成功</p>
</li>
<li>
<p>点击<code>General</code>中<code>TUN Mode</code>右边开关启动 TUN 模式</p>
</li>
<li>
<p>无法安装<a href="https://docs.cfw.lbyczf.com/contents/questions.html#linux">参考</a>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl https://gist.githubusercontent.com/Fndroid/2119fcb5ccb5a543a8f6a609418ae43f/raw/592eba4f480c7ccb4f29c9b8e80d24bfd5dda8cf/linux.sh &gt; cfw-tun.sh <span style="color:#f92672">&amp;&amp;</span> chmod +x cfw-tun.sh <span style="color:#f92672">&amp;&amp;</span> sudo ./cfw-tun.sh install &lt;cfw安装目录&gt;
</code></pre></div><p>如要卸载则将 install 改为 uninstall，最后一部分位 CFW 安装目录</p>
</li>
</ol>
<h5 id="setup-system-stack-in-fake-ip-mode">Setup System stack in Fake-IP mode<a hidden class="anchor" aria-hidden="true" href="#setup-system-stack-in-fake-ip-mode">#</a></h5>
<p><strong>Edit config</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">dns</span>:
  <span style="color:#f92672">enable</span>: <span style="color:#66d9ef">true</span>
  <span style="color:#f92672">listen</span>: <span style="color:#ae81ff">0.0.0.0</span>:<span style="color:#ae81ff">1053</span>
  <span style="color:#f92672">fake-ip-range</span>: <span style="color:#ae81ff">198.18.0.1</span><span style="color:#ae81ff">/16</span>
  <span style="color:#f92672">enhanced-mode</span>: <span style="color:#ae81ff">fake-ip</span>
  <span style="color:#f92672">nameserver</span>:
    - <span style="color:#ae81ff">114.114.114.114</span>

<span style="color:#f92672">tun</span>:
  <span style="color:#f92672">enable</span>: <span style="color:#66d9ef">true</span>
  <span style="color:#f92672">stack</span>: <span style="color:#ae81ff">system</span>
  <span style="color:#f92672">dns-hijack</span>:
    - <span style="color:#ae81ff">tcp://8.8.8.8:53</span>
  
<span style="color:#f92672">interface-name</span>: <span style="color:#ae81ff">en0</span>
</code></pre></div><p><strong>Run Clash</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">sudo ./clash
</code></pre></div><p><strong>Set Route</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># Based on https://github.com/Kr328/kr328-clash-setup-scripts/blob/master/setup-clash-tun.sh</span>
ipset create localnetwork hash:net
ipset add localnetwork 127.0.0.0/8
ipset add localnetwork 10.0.0.0/8
ipset add localnetwork 169.254.0.0/16
ipset add localnetwork 192.168.0.0/16
ipset add localnetwork 224.0.0.0/4
ipset add localnetwork 240.0.0.0/4
ipset add localnetwork 172.16.0.0/12

ip tuntap add user root mode tun utun0
ip link set utun0 up

ip route replace default dev utun0 table 0x162

ip rule add fwmark 0x162 lookup 0x162

iptables -t mangle -N CLASH
iptables -t mangle -F CLASH
iptables -t mangle -A CLASH -p tcp --dport <span style="color:#ae81ff">53</span> -j MARK --set-mark 0x162
iptables -t mangle -A CLASH -p udp --dport <span style="color:#ae81ff">53</span> -j MARK --set-mark 0x162
iptables -t mangle -A CLASH -m addrtype --dst-type BROADCAST -j RETURN
iptables -t mangle -A CLASH -m set --match-set localnetwork dst -j RETURN
iptables -t mangle -A CLASH -d 198.18.0.0/16 -j MARK --set-mark 0x162
iptables -t mangle -A CLASH -j MARK --set-mark 0x162

iptables -t mangle -I OUTPUT -j CLASH
iptables -t mangle -I PREROUTING -m set ! --match-set localnetwork dst -j MARK --set-mark 0x162


sysctl -w net/ipv4/ip_forward<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
sysctl -w net.ipv4.conf.utun0.rp_filter<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>
</code></pre></div><p><strong>Set Gateway and DNS server in other devices</strong></p>
<p>Set the gateway and DNS server, then enjoy the clash</p>
<h4 id="tproxy-modehttpslancellcgitbookioclashstart-clashclash-udp-tproxy-support"><a href="https://lancellc.gitbook.io/clash/start-clash/clash-udp-tproxy-support">TProxy Mode</a><a hidden class="anchor" aria-hidden="true" href="#tproxy-modehttpslancellcgitbookioclashstart-clashclash-udp-tproxy-support">#</a></h4>
<p>Transparent proxies act as intermediaries between a user and a web service. When a user connects to a service, the transparent proxy intercepts the request before passing it on to the provider. Transparent proxies are considered transparent because the user isn’t aware of them. On the other hand, the servers hosting the service recognize that the proxied traffic is coming from a proxy and not directly from the user.</p>
<p>And Tproxy is first choice of realize transparent proxy with NAT on Linux. In the past, Clash TProxy mode only support TCP traffic. After version 0.19, Clash TProxy mode also support UDP traffic, it will solve a NAT problem.</p>
<p><strong>What&rsquo;s different between TProxy mode and TUN mode?</strong></p>
<p>There&rsquo;s no big difference in user-side.</p>
<p>In developer side, Tproxy is a proxy, although it is not perceived by the application. And TUN is a gatway, application knows there is a gateway, and traffic must pass through it.</p>
<p><strong>Check your config</strong></p>
<p>Make sure you config have no <code>tun</code> field.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">dns:
  enable: true
  listen: 0.0.0.0:1053
  enhanced-mode: redir-host <span style="color:#75715e"># or fake-ip</span>
  nameserver:
    - 114.114.114.114
</code></pre></div><p><strong>Add Rules in iptable</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">iptables -t nat -N clash
iptables -t nat -A clash -d 0.0.0.0/8 -j RETURN
iptables -t nat -A clash -d 10.0.0.0/8 -j RETURN
iptables -t nat -A clash -d 127.0.0.0/8 -j RETURN
iptables -t nat -A clash -d 169.254.0.0/16 -j RETURN
iptables -t nat -A clash -d 172.16.0.0/12 -j RETURN
iptables -t nat -A clash -d 192.168.0.0/16 -j RETURN
iptables -t nat -A clash -d 224.0.0.0/4 -j RETURN
iptables -t nat -A clash -d 240.0.0.0/4 -j RETURN
iptables -t nat -A clash -d <span style="color:#e6db74">&#34;</span>$local_ipv4<span style="color:#e6db74">&#34;</span> -j RETURN
iptables -t nat -A clash -p tcp -j REDIRECT --to-port <span style="color:#e6db74">&#34;</span>$proxy_port<span style="color:#e6db74">&#34;</span>
iptables -t nat -I PREROUTING -p tcp -d 8.8.8.8 -j REDIRECT --to-port <span style="color:#e6db74">&#34;</span>$proxy_port<span style="color:#e6db74">&#34;</span>
iptables -t nat -I PREROUTING -p tcp -d 8.8.4.4 -j REDIRECT --to-port <span style="color:#e6db74">&#34;</span>$proxy_port<span style="color:#e6db74">&#34;</span>
iptables -t nat -A PREROUTING -p tcp -j clash
iptables -t nat -A OUTPUT -p tcp -d 198.18.0.0/16 -j REDIRECT --to-port <span style="color:#e6db74">&#34;</span>$proxy_port<span style="color:#e6db74">&#34;</span> <span style="color:#75715e"># use it just for fake-ip</span>
iptables -t nat -N CLASH_DNS
iptables -t nat -F CLASH_DNS 
iptables -t nat -A CLASH_DNS -p udp -j REDIRECT --to-port <span style="color:#ae81ff">1053</span>
iptables -t nat -I OUTPUT -p udp --dport <span style="color:#ae81ff">53</span> -j CLASH_DNS
iptables -t nat -I PREROUTING -p udp --dport <span style="color:#ae81ff">53</span> -j REDIRECT --to <span style="color:#ae81ff">1053</span>
</code></pre></div><h4 id="配置文件httpswwwcfmemcom202108clashhtml"><a href="https://www.cfmem.com/2021/08/clash.html">配置文件</a><a hidden class="anchor" aria-hidden="true" href="#配置文件httpswwwcfmemcom202108clashhtml">#</a></h4>
<p><strong>Clash</strong> 是基于 Go 语言写的科学上网工具，目前支持 windows, mac, android, openwrt, linux 平台，支持 ss, trojan, vmess, snell 协议，支持分流规则。</p>
<p>clash 配置文件格式为 yaml 格式，格式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">port</span>: <span style="color:#ae81ff">7890</span>
<span style="color:#f92672">socks-port</span>: <span style="color:#ae81ff">7891</span>
<span style="color:#f92672">allow-lan</span>: <span style="color:#66d9ef">true</span>
<span style="color:#f92672">mode</span>: <span style="color:#ae81ff">Rule</span>
<span style="color:#f92672">log-level</span>: <span style="color:#ae81ff">info</span>
<span style="color:#f92672">external-controller</span>: :<span style="color:#ae81ff">9090</span>
<span style="color:#f92672">proxies</span>:
  - {<span style="color:#f92672">name</span>: <span style="color:#ae81ff">cfmem.com - 🇭🇰 gq - 香港Amazon数据中心 20-1}</span>
<span style="color:#f92672">proxy-groups</span>:
  - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">🔰 节点选择</span>
    <span style="color:#f92672">type</span>: <span style="color:#ae81ff">select</span>
    <span style="color:#f92672">proxies</span>:
      - <span style="color:#ae81ff">♻️ 自动选择</span>
      - <span style="color:#ae81ff">🎯 全球直连</span>
      - <span style="color:#ae81ff">cfmem.com - 🇭🇰 gq - 香港Amazon数据中心 20-1</span>
<span style="color:#f92672">rules</span>:
  - <span style="color:#ae81ff">DOMAIN-SUFFIX,local,🎯 全球直连</span>
</code></pre></div><h5 id="proxies">proxies<a hidden class="anchor" aria-hidden="true" href="#proxies">#</a></h5>
<p>proxies 代表节点数据，所有的分流规则都是按照这些节点数据来的，这里可以有很多个节点数据，可以是 trojan, ss, vmess 类型都可以，我们来看个例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">{<span style="color:#f92672">name: cfmem.com - 🇭🇰 gq - 香港Amazon数据中心 20-1, server: xxxx, port: 59113, type: vmess, uuid: 1111111, alterId: 0, cipher: auto, tls</span>: <span style="color:#66d9ef">false</span>}
</code></pre></div><p>clash 用统一的格式来定义不同的节点类型，用 type 来进行区分，特有的属性只需要在这个结构体加上自己属性就可以， clash 客户端会根据 type 不同而来读数据</p>
<h5 id="proxy-groups">proxy-groups<a hidden class="anchor" aria-hidden="true" href="#proxy-groups">#</a></h5>
<p>可以把 <strong>proxy-groups</strong> 理解为一道又道的过滤网，当你发出一个请求时，这个请求将会被在哪一层的过滤网给拦截下来，取决于你的 <strong>rules</strong> 与 请求匹配。我们来解析一下 proxy-groups 里面的参数。</p>
<p><strong>name</strong></p>
<p>代表组的名称，组的名称可以随意命名，但建议取有意义的名称，组的名称可以被其它的组引用，也可以放在规则里面</p>
<p><strong>type</strong></p>
<p>type 代表这个组的类型，有下面四种情况</p>
<ul>
<li>
<p>select 手动选择，该组在节点列表上，手动选择列表或者 proxy-group</p>
</li>
<li>
<p>url-test 延迟最低节点，测试该组所有节点的延迟</p>
</li>
<li>
<p>fallback 回落，连接该组第一个节点，不可用时切换到下一个节点</p>
</li>
<li>
<p>load-balance 负载均衡，由该组2个以上的节点提供链接</p>
</li>
</ul>
<p><strong>proxies</strong></p>
<p>这里可以是组名称或者节点名称，依次从上到下进行选择，比如看下面这个</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">  - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">🔰 节点选择</span>
    <span style="color:#f92672">type</span>: <span style="color:#ae81ff">select</span>
    <span style="color:#f92672">proxies</span>:
      - <span style="color:#ae81ff">♻️ 自动选择</span>
      - <span style="color:#ae81ff">🎯 全球直连</span>
      - <span style="color:#ae81ff">cfmem.com - 🇭🇰 gq - 香港Amazon数据中心 20-1</span>
      - <span style="color:#ae81ff">cfmem.com - 🇭🇰 gq - 香港Amazon数据中心 26-2</span>
      - <span style="color:#ae81ff">cfmem.com - 🇭🇰 gq - 香港Amazon数据中心 28-3</span>
      - <span style="color:#ae81ff">cfmem.com - 🇭🇰 香港-4</span>
      - <span style="color:#ae81ff">cfmem.com - 🇭🇰 香港 2-5</span>
      - <span style="color:#ae81ff">cfmem.com - 🇭🇰 香港 3-6</span>
      - <span style="color:#ae81ff">cfmem.com - 🇭🇰 香港 4-7</span>
      - <span style="color:#ae81ff">cfmem.com - 🇭🇰 香港 10-8</span>
      - <span style="color:#ae81ff">cfmem.com - 🇭🇰 香港 11-9</span>
  - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">♻️ 自动选择</span>
    <span style="color:#f92672">type</span>: <span style="color:#ae81ff">url-test</span>
    <span style="color:#f92672">url</span>: <span style="color:#ae81ff">http://www.gstatic.com/generate_204</span>
    <span style="color:#f92672">interval</span>: <span style="color:#ae81ff">300</span>
    <span style="color:#f92672">proxies</span>:
      - <span style="color:#ae81ff">cfmem.com - 🇭🇰 gq - 香港Amazon数据中心 20-1</span>
      - <span style="color:#ae81ff">cfmem.com - 🇭🇰 gq - 香港Amazon数据中心 26-2</span>
      - <span style="color:#ae81ff">cfmem.com - 🇭🇰 gq - 香港Amazon数据中心 28-3</span>
      - <span style="color:#ae81ff">cfmem.com - 🇭🇰 香港-4</span>
      - <span style="color:#ae81ff">cfmem.com - 🇭🇰 香港 2-5</span>
      - <span style="color:#ae81ff">cfmem.com - 🇭🇰 香港 3-6</span>
      - <span style="color:#ae81ff">cfmem.com - 🇭🇰 香港 4-7</span>
      - <span style="color:#ae81ff">cfmem.com - 🇭🇰 香港 10-8</span>
      - <span style="color:#ae81ff">cfmem.com - 🇭🇰 香港 11-9</span>
      - <span style="color:#ae81ff">cfmem.com - 🇭🇰 香港 12-10</span>
  - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">🌍 国外媒体</span>
    <span style="color:#f92672">type</span>: <span style="color:#ae81ff">select</span>
    <span style="color:#f92672">proxies</span>:
      - <span style="color:#ae81ff">🔰 节点选择</span>
      - <span style="color:#ae81ff">♻️ 自动选择</span>
      - <span style="color:#ae81ff">🎯 全球直连</span>
      - <span style="color:#ae81ff">cfmem.com - 🇭🇰 gq - 香港Amazon数据中心 20-1</span>
</code></pre></div><p>名称为自动选择的组会每间隔 300 毫秒去 ping 节点数据，测试的地址是：http://www.gstatic.com/generate_204</p>
<p>而 国外媒体这一项是手动选择默认选择第一个 节点选择，节点选择的第一个是自动选择，所以默认是根据 ping 值来选择节点的</p>
<h5 id="rules">rules<a hidden class="anchor" aria-hidden="true" href="#rules">#</a></h5>
<p>rules 也就是具体的分发规则了，规则一般由 <code>[规则前缀],[域名或地址],[组名]</code> 组成。我们来看下，其中 no-resolve 表示不要解析这条规则，只处理直接 ip 访问请求</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">rules</span>:
  - <span style="color:#ae81ff">DOMAIN-SUFFIX,local,🎯 全球直连</span>
  - <span style="color:#ae81ff">IP-CIDR,192.168.0.0/16,🎯 全球直连,no-resolve</span>
  - <span style="color:#ae81ff">IP-CIDR,10.0.0.0/8,🎯 全球直连,no-resolve</span>
  - <span style="color:#ae81ff">IP-CIDR,172.16.0.0/12,🎯 全球直连,no-resolve</span>
  - <span style="color:#ae81ff">IP-CIDR,127.0.0.0/8,🎯 全球直连,no-resolve</span>
  - <span style="color:#ae81ff">IP-CIDR,100.64.0.0/10,🎯 全球直连,no-resolve</span>
  - <span style="color:#ae81ff">IP-CIDR6,::1/128,🎯 全球直连,no-resolve</span>
  - <span style="color:#ae81ff">IP-CIDR6,fc00::/7,🎯 全球直连,no-resolve</span>
  - <span style="color:#ae81ff">IP-CIDR6,fe80::/10,🎯 全球直连,no-resolve</span>
  - <span style="color:#ae81ff">IP-CIDR6,fd00::/8,🎯 全球直连,no-resolve</span>
  - <span style="color:#ae81ff">DOMAIN-KEYWORD,1drv,Ⓜ️ 微软服务</span>
</code></pre></div><p>规则前缀有这些内容</p>
<ul>
<li>
<p>DOMAIN-SUFFIX 表示包含什么后缀的域名</p>
</li>
<li>
<p>IP-CIDR IPV4匹配</p>
</li>
<li>
<p>IP-CIDR6 IPV6匹配</p>
</li>
<li>
<p>DOMAIN-KEYWORD,xxx 表示包含 xxx域名关键字的链接</p>
</li>
<li>
<p>DOMAIN abc.hello.com 表示包含完整的域名</p>
</li>
<li>
<p>PROCESS-NAME 表示进程名称</p>
</li>
<li>
<p>GEOIP 数据库（国家代码）匹配</p>
</li>
<li>
<p>MATCH 全匹配（一般放在最后）</p>
</li>
</ul>
<h4 id="dns污染httpsblogrssinsnetarchives1379"><a href="https://blog.rssins.net/archives/1379">DNS污染</a><a hidden class="anchor" aria-hidden="true" href="#dns污染httpsblogrssinsnetarchives1379">#</a></h4>
<p>DNS服务器即是将用户请求的域名(网站URL)转换为IP地址的服务器。当年中国长城防火墙开始部署时就是通过DNS污染来屏蔽网站的。这项名为DNS污染的技术，就是对用户请求的域名回应一个错误的IP地址，使用户无法访问某个网站。至此，国内几乎所有的公共DNS服务器都被污染，用户无法请求到被屏蔽网站的正确IP地址。但是目前，防火墙的屏蔽功能早已不止DNS污染那么简单了，可以针对IP/域名直接阻断连接，甚至屏蔽了国外未受污染的DNS服务器，因此仅靠国内的DNS是不够翻墙的。</p>
<h5 id="对抗dns劫持">对抗DNS劫持<a hidden class="anchor" aria-hidden="true" href="#对抗dns劫持">#</a></h5>
<p>早期的DNS服务器（我们日常使用的基本也是）都是明文传输数据的，这就意味着防火墙可以探测出你访问的网站，并且直接篡改DNS服务器回应的IP地址。这不仅仅存在于长城防火墙，还存在于某些无良网络运营商，把用户的请求的网站劫持到某个假的网站上。</p>
<p>于是目前出现了DoH与DoT，可使用https/tls 加密传输DNS请求，这使得DNS不再容易被劫持了。国内的许多公共DNS也都提供了这项服务。以下是我所推荐的国内DNS。</p>
<ul>
<li><code>https://223.5.5.5/dns-query</code></li>
<li><code>https://223.6.6.6/dns-query</code></li>
<li><code>https://doh.pub/dns-query</code></li>
</ul>
<p>或许可以参考 <a href="https://blog.skk.moe/post/which-public-dns-to-use/">如何选择适合的公共 DNS？</a></p>
<h5 id="何时使用">何时使用<a hidden class="anchor" aria-hidden="true" href="#何时使用">#</a></h5>
<p>Clash只会在域名匹配为直连时使用配置文件的DNS，其余时刻均交给节点进行远程解析。当然，节点域名也会使用配置文件的DNS。</p>
<p>举个例子，访问 <code>google.com</code> 时，匹配到代理规则，那么这个流量将直接被发送至节点服务器，交给节点处理（通常是节点服务器的DNS解析，这个不用管了）。访问 <code>microsoft.com</code> 时，匹配到直连规则，Clash将使用配置文件的DNS设定进行解析。</p>
<h5 id="dns配置httpswwwxkww3ncyou20220208use-clash-dns-anti-dns-hijacking"><a href="https://www.xkww3n.cyou/2022/02/08/use-clash-dns-anti-dns-hijacking/">DNS配置</a><a hidden class="anchor" aria-hidden="true" href="#dns配置httpswwwxkww3ncyou20220208use-clash-dns-anti-dns-hijacking">#</a></h5>
<p>首先，打开你的 Clash 配置文件（如果你使用 Clash for Windows 或 Clash for Android, 可以使用软件自带的“覆写/Mixin”功能），添加以下段落：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">dns</span>:
  <span style="color:#f92672">enable</span>: <span style="color:#66d9ef">true</span>
  <span style="color:#f92672">listen</span>: <span style="color:#ae81ff">0.0.0.0</span>:<span style="color:#ae81ff">53Copy</span>
</code></pre></div><p>这一段的意思是启用 Clash 的 DNS 服务并让其在 53 端口（这是绝大多数操作系统将 DNS 解析报文发送到的端口）监听来自任意网络界面的 DNS 请求。如果你的设备并不需要向其他设备提供解析服务，或你的设备常常需要接入不安全的网络（如手机，笔记本电脑），应当将第三行的 <code>0.0.0.0:53</code> 改为 <code>127.0.0.1:53</code> 让 Clash 仅监听本机的 DNS 解析报文。</p>
<p>（Clash 默认会同时监听 IPv4 和 IPv6 界面，如果你不需要后者，可以添加一行 <code>ipv6: false</code>）</p>
<p>由于连接到加密 DNS 服务时，需要解析服务器本身的域名，因此需要指定一些相对干净的国内 <strong>明文</strong> DNS 服务器地址。继续添加以下部分（注意缩进）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#75715e">#--omitted--</span>
<span style="color:#f92672">default-nameserver</span>:
   - <span style="color:#ae81ff">119.29.29.29</span>
   - <span style="color:#ae81ff">223.5.5</span><span style="color:#ae81ff">.5Copy</span>
</code></pre></div><p>当收到 DNS 解析请求时，Clash 会使用以上 DNS 服务器解析加密 DNS 服务器地址并建立连接。</p>
<p>接下来，指定解析国内域名时使用的加密 DNS 服务器地址：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#75715e">#--omitted--</span>
<span style="color:#f92672">nameserver</span>:
   - <span style="color:#ae81ff">https://doh.pub/dns-query</span>
   - <span style="color:#ae81ff">https://dns.alidns.com/dns-queryCopy</span>
</code></pre></div><p>Clash 支持 DoH（<code>https://domain.tld/dns-query</code> 形式） 和 DoT（<code>tls://domain.tld</code> 形式）两种加密 DNS 协议，不支持 DoQ.（当然也支持在此指定备用的明文 DNS）</p>
<p>然后，指定解析国外域名时使用的加密 DNS 服务器地址，并设置分流规则：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#75715e">#--omitted--</span>
<span style="color:#f92672">fallback</span>:
   - <span style="color:#ae81ff">https://1.1.1.1/dns-query</span>
   - <span style="color:#ae81ff">https://dns.google/dns-query</span>
<span style="color:#f92672">fallback-filter</span>:
   <span style="color:#f92672">geoip</span>: <span style="color:#66d9ef">true</span>
   <span style="color:#f92672">geoip-code</span>: <span style="color:#ae81ff">CN</span>
   <span style="color:#f92672">ipcidr</span>:
     - <span style="color:#ae81ff">240.0.0.0</span><span style="color:#ae81ff">/4Copy</span>
</code></pre></div><p>“fallback” 字段指定的 DNS 服务器将被用于解析非国外域名，而 “fallback-filter” 字段则实现我们想要的分流规则——当请求解析的域名在 GeoIP 数据库内的国家代码不是 <code>CN</code> 时，或是域名在前文设置的 DNS 服务器内的解析结果位于 <code>240.0.0.0/4</code> 这一 IP 段内时（被屏蔽的域名解析常常会被污染到这一段），使用 “fallback” 字段指定的 DNS 服务器解析域名。</p>
<p>最后，修改系统 DNS 服务器为 <code>127.0.0.1</code> 即可。</p>
<h4 id="代理环境中的-dns-解析行为httpsblogskkmoepostwhat-happend-to-dns-in-proxy"><a href="https://blog.skk.moe/post/what-happend-to-dns-in-proxy">代理环境中的 DNS 解析行为</a><a hidden class="anchor" aria-hidden="true" href="#代理环境中的-dns-解析行为httpsblogskkmoepostwhat-happend-to-dns-in-proxy">#</a></h4>
<p>虽然 Fake IP 这个概念早在 2001 年就被提出来了，但是到 Clash 提供 fake-ip 增强模式以后，依然有很多人对 Fake IP 这个概念以及其作用知之甚少。本文就简单谈谈在代理环境中，TCP 连接建立之前发生的事。由于移动设备操作系统中网络栈相对复杂，本文的例子也并不一定适用于移动端环境。文章中也许会存在很多错误，也希望各路大佬的勘误和斧正。</p>
<h5 id="不使用代理">不使用代理<a hidden class="anchor" aria-hidden="true" href="#不使用代理">#</a></h5>
<p>如果在不使用任何代理的情况下，打开一个没有命中 DNS 缓存的网站（比如 <code>blog.skk.moe</code>）的时候，浏览器和操作系统大概会执行这么一些操作：</p>
<ol>
<li>浏览器自己都有 DNS 缓存机制，因此浏览器会先开始寻找自己的缓存，不过没有找到 <code>blog.skk.moe</code> 的解析结果</li>
<li>浏览器通过调用操作系统的 <code>getaddrinfo</code> 方法，向操作系统寻求解析结果</li>
<li>操作系统自己也有一层 DNS 缓存，但是现在操作系统从自己的缓存中依然找不到这一结果</li>
<li>在系统的网络设置之中有设置上游 DNS 地址，假设操作系统中设置的是 <code>119.29.29.29</code>，那么操作系统会向 <code>119.29.29.29</code> 发起解析请求（UDP 流量）拿到 <code>blog.skk.moe</code> 的 IP</li>
<li>当然如果 <code>119.29.29.29</code> 自己没有 <code>blog.skk.moe</code> 的解析结果会找它的上游去要。不过我们不关心这一点，反正最后 <code>119.29.29.29</code> 会把 <code>blog.skk.moe</code> 的解析结果返回给设备的操作系统</li>
<li>现在，浏览器已经可以开始向 <code>blog.skk.moe</code> 的 IP 发起 HTTPS 连接了</li>
</ol>
<p>以上是打开一个网页常见的 DNS 解析流程，对于其它非 HTTP 的 TCP 连接（比如 SMTP）也都差不多是这个流程——由于 TCP/IP 的协议特性，在应用发起 TCP 连接时，会先发出一个 DNS question（发一个 IP Packet），获取要连接的服务器的 IP 地址，然后直接向这个 IP 地址发起连接。</p>
<h5 id="设置代理并使用直连">设置代理并使用直连<a hidden class="anchor" aria-hidden="true" href="#设置代理并使用直连">#</a></h5>
<p>现在，我们在应用程序（比如我们的浏览器、或者其它应用）中设置了代理，但是这个代理不涉及到任何远端服务器（直连模式）。接下来以设置了 SOCKS5 代理的浏览器为例。</p>
<ol>
<li>浏览器不再需要从自己的 DNS 缓存中寻找 <code>blog.skk.moe</code>，因为已经有了 SOCKS5 代理，浏览器可以直接将域名封装在 SOCKS5 流量之中发往代理客户端</li>
<li>代理客户端从 SOCKS5 流量中抽出 <code>blog.skk.moe</code> 这个域名并设法获得解析结果</li>
<li>代理客户端将你的 SOCKS5 流量还原成标准的 TCP 请求</li>
<li>代理客户端将这个 TCP 连接建立起来，在这个例子之中 TCP 连接承载的是 HTTPS</li>
</ol>
<p>之前由于获取解析结果是浏览器在操作，而大部分浏览器都会选择调用系统的 <code>getaddrinfo</code> 方法，因此如果你想要在 DNS 上做一些黑魔法就只能在操作系统层面实现，比如在本机或者别处架设一个带黑魔法的 DNS 服务器，然后你系统中设置使用这个 DNS 服务器。现在 DNS 解析是由代理客户端执行，因此在代理客户端上就可以实现一些黑魔法。比如 Surge 自己实现了一个 DNS Server 可以并发向多个上游同时发起查询、比如 V2Ray 可以实现不同域名的查询分流，等等。当然代理客户端也可以使用操作系统的 <code>getaddrinfo</code> 方法。</p>
<h5 id="设置代理并将流量转发到远端服务器">设置代理并将流量转发到远端服务器<a hidden class="anchor" aria-hidden="true" href="#设置代理并将流量转发到远端服务器">#</a></h5>
<p>现在在上一步的基础之上，我们为代理服务器设置了一个远端服务器，这个代理会使用 某种协议 和远端服务器通信，并且这种协议和 SOCKS5 一样支持将域名封装在传输中。浏览器和代理客户端之间依然使用 SOCKS5 通信。</p>
<ol>
<li>因为已经有了 SOCKS5 代理，浏览器可以直接将域名 <code>blog.skk.moe</code> 和整个请求封装在 SOCKS5 流量之中发往代理客户端</li>
<li>代理客户端从 SOCKS5 流量中抽出 <code>blog.skk.moe</code> 这个域名以及其它数据</li>
<li>代理客户端使用 某种协议 将浏览器发出的 SOCKS5 的流量重组并发给远端服务器</li>
<li>远端服务器使用相同的 某种协议 从流量中获得其中的域名 <code>blog.skk.moe</code></li>
<li>远端服务器的代理服务端发起了一次 DNS 解析请求试图解析 <code>blog.skk.moe</code>。绝大部分情况下，代理的服务端都会直接使用操作系统的 <code>getaddrinfo</code> 方法、也就是由远端服务器的操作系统负责 DNS</li>
</ol>
<p>这一次，不论是代理客户端还是你的浏览器都没有进行 DNS 解析，DNS 解析是在远端服务器上进行的。因为 某种协议 支持封装域名，然后这一次和 <code>blog.skk.moe</code> 连接的是远端服务器，考虑到针对 CDN 优化，DNS 解析自然需要在远端服务器上执行。</p>
<p>现在我已经介绍了通过代理直连和通过代理发送给远端服务器了。但是毫无疑问，我相信本文所有的读者自己使用的上网方式都不会是全面直连或者全面代理。这就是接下来要讲的：</p>
<h5 id="设置代理并使用-ip-规则和域名规则进行分流">设置代理并使用 IP 规则和域名规则进行分流<a hidden class="anchor" aria-hidden="true" href="#设置代理并使用-ip-规则和域名规则进行分流">#</a></h5>
<p>分流是一个麻烦事。一般情况下，你可能会需要使用域名进行分流（不论是白名单还是黑名单）。不过更多情况下你会使用到基于 IP 的规则来进行分流。</p>
<p>先来看第一个例子：使用域名规则进行分流。</p>
<ol>
<li>浏览器将带有域名 <code>blog.skk.moe</code> 的 HTTPS 请求封装在 SOCKS5 流量之中发往代理客户端</li>
<li>代理客户端从 SOCKS5 流量中抽取出域名 <code>blog.skk.moe</code></li>
<li>代理客户端开始将<code>blog.skk.moe</code> 和域名规则列表开始比较。这个列表可以是白名单或黑名单，域名可能也没有匹配上。反正最终比较得出的结果就是 <code>blog.skk.moe</code> 是否需要走代理。</li>
<li>如果不需要走代理，代理客户端剩下会做的事情和本文第二部分「设置代理并使用直连」就完全一样了；同理，需要走代理的话就需要进行本文第三部分的那个流程</li>
</ol>
<p>使用域名规则分流很简单，除非 <code>blog.skk.moe</code> 最终是直连，否则代理客户端不需要进行 DNS 解析。</p>
<p>现在来看第二个例子：使用 IP 规则分流。</p>
<ol>
<li>浏览器将带有域名 <code>blog.skk.moe</code> 的 HTTPS 请求封装在 SOCKS5 流量之中发往代理客户端</li>
<li>代理客户端从 SOCKS5 流量中抽取出域名 <code>blog.skk.moe</code></li>
<li>代理客户端得到 <code>blog.skk.moe</code> 的解析结果</li>
<li>代理客户端开始将<code>blog.skk.moe</code> 的解析结果和 IP 规则列表开始比较。这个列表可以是 cnlist 或者 MaxMind IP 数据库。反正最终得出的结果就是 <code>blog.skk.moe</code> 解析结果的 IP 是否需要走代理。</li>
<li>如果不需要走代理，代理客户端剩下会做的事情和本文第二部分「设置代理并使用直连」就完全一样了；同理，需要走代理的话就需要进行本文第三部分的那个流程。</li>
</ol>
<p>使用 IP 规则分流，前提首先你得有一个 IP 拿来比较。所以代理客户端必须先进行一次 DNS 解析。使用什么方法进行 DNS 解析并不重要，之前已经说过代理客户端甚至可以使用自己的黑魔法，而我们只需要关心最终代理客户端拿到了一个 IP 并且可以用于规则判定。</p>
<p>此时需要注意的是，虽然代理客户端获得了一个 IP，但是你只有在直连的时候，代理客户端可能（并且基本上都会）复用这个 IP；如果是将流量交给远程服务器，由于 某种协议 支持封装域名，因此远程服务器拿到的还是域名不是 IP、还需要进行一次解析。也就是说，远端服务器连接的 IP 与 代理客户端解析得到的 IP 毫无关系。</p>
<h5 id="使用-redir--tun2socks-实现全局流量经过代理">使用 redir / tun2socks 实现全局流量经过代理<a hidden class="anchor" aria-hidden="true" href="#使用-redir--tun2socks-实现全局流量经过代理">#</a></h5>
<p>在开始之前，我们先复习一下 TCP/IP 协议怎么说的——「在应用发起 TCP 连接时，会先发出一个 DNS question（发一个 IP Packet），获取要连接的服务器的 IP 地址，然后直接向这个 IP 地址发起连接」</p>
<p>全局流量代理可能会出现在路由器上或者 TUN/TAP 型的支持全局代理客户端上。用户不再主动为每个应用程序设置代理。此时应用程序是不会感知到代理客户端的存在，它们会正常的发起 TCP 连接，并且由于 TCP/IP 协议，在拿到 DNS 解析结果之前，连接是不能建立的。</p>
<ol>
<li>浏览器自己都有 DNS 缓存机制，因此浏览器会先开始寻找自己的缓存，不过没有找到 <code>blog.skk.moe</code> 的解析结果</li>
<li>浏览器通过调用操作系统的 <code>getaddrinfo</code> 方法，向操作系统寻求解析结果</li>
<li>操作系统自己也有一层 DNS 缓存，但是现在操作系统从自己的缓存中依然找不到这一结果</li>
<li>在系统的网络设置之中有设置上游 DNS 地址。代理客户端可能会修改系统设置中的 DNS 到 127.0.0.1 或者别的 IP、也可能保留用户之前的设置，这无所谓，因为&hellip;</li>
<li>操作系统发出的 DNS 解析请求会经过代理客户端并最终被截获</li>
<li>代理客户端可以将这个解析请求原样发出去、或者用自己的黑魔法，总之代理客户端都会拿到一个解析结果</li>
<li>代理客户端将这个解析结果返回回去，操作系统拿到了这个解析结果并返回给浏览器</li>
<li>浏览器对这个解析结果的 IP 建立一个 TCP 连接并发送出去</li>
<li>这个 TCP 连接被代理客户端截获。由于之前代理客户端进行的 DNS 解析请求这一动作，代理客户端可以找到这个只包含目标 IP 的 TCP 连接原来的目标域名</li>
<li>如果是支持 redir 的代理客户端，那么代理客户端就会直接将域名和 TCP 连接中的其它数据封装成 某种协议 发给远端服务器；或者封装成 SOCKS5 后交给支持 SOCKS5 的代理客户端</li>
</ol>
<p>如果代理客户端需要按照域名进行分流，一般会在第 6 步代理客户端解析出一个 IP 或者第 9 步代理客户端拿到域名以后。FancySS、KoolSS、SSTap 的流程大抵都是如此。</p>
<p>和应用程序直接将流量封装成 SOCKS5 大有不同，在类似于透明代理的环境下浏览器和其它应用程序是正常地发起 TCP 连接。因此除非得到一个 DNS 解析结果，否则 TCP 连接不会建立；代理客户端也会需要通过这个 DNS 查询动作，才能找到之后的 TCP 连接的域名。
你大概能够发现，浏览器、应用程序直接设置 SOCKS5 代理的话，可以不在代理客户端发起 DNS 解析请求就能将流量发送给远端服务器；而在透明代理模式下，不论是否需要 IP 规则分流都需要先进行一次 DNS 解析才能建立连接。</p>
<p>有没有办法能像直接设置 SOCKS5 代理一样省掉一次 DNS 解析呢？有，就是代理客户端自己不先执行查询动作，丢一个 Fake IP 回去让浏览器、应用程序立刻建立 TCP 连接：</p>
<h5 id="在-redir--tun2socks-中使用-fake-ip">在 redir / tun2socks 中使用 Fake IP<a hidden class="anchor" aria-hidden="true" href="#在-redir--tun2socks-中使用-fake-ip">#</a></h5>
<p>Fake IP 的定义出自 <a href="https://tools.ietf.org/rfc/rfc3089">RFC3089</a>。这个 RFC 定义了一种新的将 TCP 连接封装成 SOCKS 协议的方法。</p>
<ol>
<li>浏览器自己都有 DNS 缓存机制，因此浏览器会先开始寻找自己的缓存，不过并没有找到 <code>blog.skk.moe</code> 的解析结果</li>
<li>浏览器通过调用操作系统的 <code>getaddrinfo</code> 方法，向操作系统寻求解析结果</li>
<li>操作系统自己也有一层 DNS 缓存，但是现在操作系统从自己的缓存中依然找不到这一结果</li>
<li>在系统的网络设置之中设置了一个专门的上游 DNS 地址，可能是用户手动设置的也可能是代理客户端设置的。不论如何，这个设置最终会使操作系统向代理客户端发起 DNS 请求</li>
<li>操作系统发出的 DNS 解析请求会经过代理客户端并最终被截获</li>
<li>代理客户端从解析请求中获得域名，从 Fake IP 池中选取一个 IP 建立映射</li>
<li>代理客户端将这个 Fake IP 返回回去，操作系统拿到了这个 Fake IP 并返回给浏览器</li>
<li>浏览器对 Fake IP 建立一个 TCP 连接并发送出去</li>
<li>这个 TCP 连接被代理客户端截获。代理客户端抽取出 Fake IP 并反查出这个 TCP 连接中对应的域名</li>
<li>有了 TCP 连接和域名，代理客户端可以轻易地将其使用 SOSCKS5 或者 某种协议 进行封装</li>
</ol>
<p>有了 Fake IP，代理客户端无需进行 DNS 解析。最后不论是浏览器、代理客户端还是远端服务器都不会去和 Fake IP 进行连接，因为在代理客户端这里就已经完成了截获、重新封装。</p>
<p>即使按照域名规则分流，代理客户端都没有进行 DNS 解析的需要。只有在遇到了按照 IP 进行分流的规则时，代理客户端才需要进行一次解析拿到一个 IP 用于判断。即便如此，这个 IP 只用于分流规则的匹配，不会被用于实际的连接。</p>
<h5 id="fancyss-和-surge--clash-的区别">FancySS 和 Surge / Clash 的区别<a hidden class="anchor" aria-hidden="true" href="#fancyss-和-surge--clash-的区别">#</a></h5>
<p>FancySS 是使用的 redir，Surge 的增强模式使用的是 Fake IP，Clash 的增强模式既有 redir-host 也有 Fake IP。首先把 FancySS 等路由器上常见的代理客户端和 Clash 的 redir-host 分为一类，Surge 的增强模式和 Clash 的 fake-ip 模式分为另一类。</p>
<p>路由器上常见的代理客户端一般内置了 dns2socks、dnscryp-proxy、PCap_DNSProxy 等等 DNS 方案、也支持按照一定的规则进行分流，但是都是用于答复应用程序的 DNS question 使其建立 TCP 连接的，除非直连，否则通过这些 DNS 方案拿到的解析结果的 IP 并不会被用上。
大部分路由器上的代理客户端，DNS 解析请求都是通过路由器本机发出（或转发到单一远端服务器进行解析），因此解析结果只能说「至少能用」（不一定是有 CDN 优化的，甚至有可能会有 DNS 污染），如果流量不经过代理客户端直接发往这些 IP 地址，一般也不会影响浏览器、应用程序的正常使用。因此路由器上的代理客户端可以实现通过 iptables 控制让某些端口、某些设备的流量不经过代理客户端。
而在 Fake IP 模式下，浏览器、应用程序都是对 Fake IP 发起连接，如果没有代理客户端对连接进行重新封转，那么这部分流量就不能被发往真实的目的 IP，因此所有流量都必须经过代理客户端，而根据端口、设备的分流就需要由代理客户端自己实现。</p>
<h5 id="如果操作系统或者浏览器缓存了-dns-解析结果">如果操作系统或者浏览器缓存了 DNS 解析结果<a hidden class="anchor" aria-hidden="true" href="#如果操作系统或者浏览器缓存了-dns-解析结果">#</a></h5>
<p>之前的透明代理的两个例子中，我们都假定浏览器和操作系统都没有缓存 DNS 解析结果。但是，如果操作系统或者应用程序缓存了 DNS 解析结果会发生什么？</p>
<p>如果是不使用 Fake IP 的 redir / tun2socks 情况下，由于操作系统、浏览器或者应用程序中的任何一个缓存了 DNS 解析结果，因此 TCP 连接可以直接根据缓存的解析结果的 IP 建立，代理客户端并没有预先收到对应的 DNS question。在这种情况下，代理客户端有可能直接将这个连接视为和 IP 连接而不是和域名连接，根据域名规则的分流可能就会因此失效，不过根据 IP 分流的规则没有失效。
如果为了避免域名分流规则失效，你可以设法阻止操作系统或者浏览器缓存 DNS 解析结果，这样每次建立 TCP 连接之前都会发送 DNS question 使代理客户端探测到域名。但是这意味着每次 TCP 连接建立都需要代理客户端进行一次 DNS 解析请求（当然代理客户端可以对 DNS 解析进行缓存避免出现延时激增）。</p>
<p>而对于 Fake IP 模式来说，由于代理客户端内存储有 Fake IP 和真实域名之间的映射表，因此即使操作系统或应用程序缓存了 Fake IP，在之后的 TCP 连接中，代理客户端收到流量后依然可以抽取出 Fake IP 反查出域名，因此不受 DNS 缓存的影响。</p>
<p>我在这里留几个问题给大家思考一下：</p>
<ul>
<li>如果使用了 Fake IP，代理客户端不论域名是否真实存在都会返回一个 Fake IP 给浏览器，那么浏览器在试图访问一个不存在的域名时，错误信息应该是什么样的？会不会出现 DNS 解析失败的错误信息？</li>
<li>如果操作系统或者浏览器缓存了 Fake IP，但是代理客户端中 Fake IP 和域名的映射表丢失以后，会出现什么状况？可能会出现什么错误信息？</li>
</ul>
<p>第二个问题很有趣。因为如果你找到了第二个问题的答案，你就会意识到 Clash 在 Fake IP 模式下偶发的无法上网的原因了。</p>
<h5 id="参考资料">参考资料<a hidden class="anchor" aria-hidden="true" href="#参考资料">#</a></h5>
<ul>
<li><a href="https://imququ.com/post/web-proxy.html">HTTP 代理原理及实现（一）</a> - 我的文章中举得都是 SOCKS5 的例子，如果想了解一下在 HTTP 代理中流量是如何被封装的，可以看看屈屈的这篇博客</li>
<li><a href="https://medium.com/@Blankwonder/surge-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0-8aa3304fb3bb">Surge 原理与实现</a> - Surge 开发者写的 Surge 早期版本的工作原理，可以了解一下 Surge 是怎么处理各种协议的流量的</li>
<li><a href="https://medium.com/@TachyonDevel/%E6%BC%AB%E8%B0%88%E5%90%84%E7%A7%8D%E9%BB%91%E7%A7%91%E6%8A%80%E5%BC%8F-dns-%E6%8A%80%E6%9C%AF%E5%9C%A8%E4%BB%A3%E7%90%86%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-62c50e58cbd0">漫谈各种黑科技式 DNS 技术在代理环境中的应用</a> - Kitsunebi 开发者写的文章，详细地介绍了在不同的 V2Ray 配置下的 DNS 行为，同时还有对移动端网络栈的一些介绍</li>
</ul>
<h3 id="wireguardhttpsfuckcloudnativeiopostswireguard-docs-practice"><a href="https://fuckcloudnative.io/posts/wireguard-docs-practice/">WireGuard</a><a hidden class="anchor" aria-hidden="true" href="#wireguardhttpsfuckcloudnativeiopostswireguard-docs-practice">#</a></h3>
<p>官方文档：https://github.com/pirate/wireguard-docs</p>
<p><code>WireGuard</code> 是由 <code>Jason Donenfeld</code> 等人用 <code>C</code> 语言编写的一个开源 VPN 协议，被视为下一代 VPN 协议，旨在解决许多困扰 <code>IPSec/IKEv2</code>、<code>OpenVPN</code> 或 <code>L2TP</code> 等其他 VPN 协议的问题。它与 <code>Tinc</code> 和 <code>MeshBird</code> 等现代 VPN 产品有一些相似之处，即加密技术先进、配置简单。从 2020 年 1 月开始，它已经并入了 Linux 内核的 <code>5.6</code> 版本，这意味着大多数 Linux 发行版的用户将拥有一个开箱即用的 WireGuard。</p>
<h4 id="术语">术语<a hidden class="anchor" aria-hidden="true" href="#术语">#</a></h4>
<p><strong>Peer/Node/Device</strong></p>
<p>连接到 VPN 并为自己注册一个 VPN 子网地址（如 192.0.2.3）的主机。还可以通过使用逗号分隔的 CIDR 指定子网范围，为其自身地址以外的 IP 地址选择路由。</p>
<p><strong>中继服务器（Bounce Server）</strong></p>
<p>一个公网可达的对等节点，可以将流量中继到 <code>NAT</code> 后面的其他对等节点。<code>Bounce Server</code> 并不是特殊的节点，它和其他对等节点一样，唯一的区别是它有公网 IP，并且开启了内核级别的 IP 转发，可以将 VPN 的流量转发到其他客户端。</p>
<p><strong>子网（Subnet）</strong></p>
<p>一组私有 IP，例如 <code>192.0.2.1-255</code> 或 <code>192.168.1.1/24</code>，一般在 NAT 后面，例如办公室局域网或家庭网络。</p>
<p><a href="https://www.cnblogs.com/hark0623/p/6547432.html"><strong>CIDR 表示法</strong></a></p>
<p>CIDR中文全称是无分类域间路由选择，英文全称是Classless Inter-Domain Routing，在平常，大家多称之为无分类编址，它也是构成超网的一种技术实现。CIDR在一定程度上解决了路由表项目过多过大的问题。CIDR之所以称为无分类编址，就是因为CIDR完全放弃了之前的分类IP地址表示法，它真正消除了传统的A类、B类、C类地址以及划分子网的概念，它使用如下的IP地址表示法：</p>
<pre tabindex="0"><code>IP地址 ::= {&lt;网络前缀&gt;， &lt;主机号&gt;} / 网络前缀所占位数
</code></pre><p>CIDR仅将IP地址划分为网络前缀和主机号两个部分，可以说又回到了二级IP地址的表示，不过大家要注意，最后面用“/”斜线分隔，在其后写上了网络前缀所占的位数，这样就不需要告知路由器地址掩码，仅需要通过网络前缀所占的位数就可以得到地址掩码，为了统一，CIDR中的地址掩码依然称为子网掩码。</p>
<p><strong>NAT</strong></p>
<p>子网的私有 IP 地址由路由器提供，通过公网无法直接访问私有子网设备，需要通过 NAT 做网络地址转换。路由器会跟踪发出的连接，并将响应转发到正确的内部 IP。</p>
<p><strong>公开端点（Public Endpoint）</strong></p>
<p>节点的公网 IP 地址:端口，例如 <code>123.124.125.126:1234</code>，或者直接使用域名 <code>some.domain.tld:1234</code>。如果对等节点不在同一子网中，那么节点的公开端点必须使用公网 IP 地址。</p>
<p><strong>私钥（Private key）</strong></p>
<p>单个节点的 WireGuard 私钥，生成方法是：<code>wg genkey &gt; example.key</code>。</p>
<p><strong>公钥（Public key）</strong></p>
<p>单个节点的 WireGuard 公钥，生成方式为：<code>wg pubkey &lt; example.key &gt; example.key.pub</code>。</p>
<p><strong>DNS</strong></p>
<p>域名服务器，用于将域名解析为 VPN 客户端的 IP，不让 DNS请求泄漏到 VPN 之外。</p>
<h4 id="工作原理">工作原理<a hidden class="anchor" aria-hidden="true" href="#工作原理">#</a></h4>
<p><strong>中继服务器工作原理</strong></p>
<p>中继服务器（Bounce Server）和普通的对等节点一样，它能够在 <code>NAT</code> 后面的 VPN 客户端之间充当中继服务器，可以将收到的任何 VPN 子网流量转发到正确的对等节点。事实上 WireGuard 并不关心流量是如何转发的，这个由系统内核和 <code>iptables</code> 规则处理。</p>
<p>如果所有的对等节点都是公网可达的，则不需要考虑中继服务器，只有当有对等节点位于 NAT 后面时才需要考虑。</p>
<p>*在 WireGuard 里，客户端和服务端基本是平等的，差别只是谁主动连接谁而已。*双方都会监听一个 UDP 端口，谁主动连接，谁就是客户端。主动连接的客户端需要指定对端的公网地址和端口，被动连接的服务端不需要指定其他对等节点的地址和端口。如果客户端和服务端都位于 NAT 后面，需要加一个中继服务器，客户端和服务端都指定中继服务器作为对等节点，它们的通信流量会先进入中继服务器，然后再转发到对端。</p>
<p>WireGuard 是支持漫游的，也就是说，双方不管谁的地址变动了，WireGuard 在看到对方从新地址说话的时候，就会记住它的新地址（跟 mosh 一样，不过是双向的）。所以双方要是一直保持在线，并且通信足够频繁的话（比如配置 <code>persistent-keepalive</code>），两边的 IP 都不固定也不影响的。</p>
<p><strong>流量路由</strong></p>
<p>利用 WireGuard 可以组建非常复杂的网络拓扑，这里主要介绍几个典型的拓扑：</p>
<ol>
<li>端到端直接连接</li>
</ol>
<p>这是最简单的拓扑，所有的节点要么在同一个局域网，要么直接通过公网访问，这样 <code>WireGuard</code> 可以直接连接到对端，不需要中继跳转。</p>
<ol start="2">
<li>一端位于 NAT 后面，另一端直接通过公网暴露</li>
</ol>
<p>这种情况下，最简单的方案是：通过公网暴露的一端作为服务端，另一端指定服务端的公网地址和端口，然后通过 <code>persistent-keepalive</code> 选项维持长连接，让 NAT 记得对应的映射关系。</p>
<ol start="3">
<li>两端都位于 NAT 后面，通过中继服务器连接</li>
</ol>
<p>大多数情况下，当通信双方都在 NAT 后面的时候，NAT 会做源端口随机化处理，直接连接可能比较困难。可以加一个中继服务器，通信双方都将中继服务器作为对端，然后维持长连接，流量就会通过中继服务器进行转发。</p>
<ol start="3">
<li>两端都位于 NAT 后面，通过 UDP NAT 打洞</li>
</ol>
<p>上面也提到了，当通信双方都在 NAT 后面的时候，直接连接不太现实，因为大多数 NAT 路由器对源端口的随机化相当严格，不可能提前为双方协调一个固定开放的端口。必须使用一个信令服务器（<code>STUN</code>），它会在中间沟通分配给对方哪些随机源端口。通信双方都会和公共信令服务器进行初始连接，然后它记录下随机的源端口，并将其返回给客户端。这其实就是现代 P2P 网络中 <code>WebRTC</code> 的工作原理。有时候，即使有了信令服务器和两端已知的源端口，也无法直接连接，因为 NAT 路由器严格规定只接受来自原始目的地址（信令服务器）的流量，会要求新开一个随机源端口来接受来自其他 IP 的流量（比如其他客户端试图使用原来的通信源端口）。运营商级别的 NAT 就是这么干的，比如蜂窝网络和一些企业网络，它们专门用这种方法来防止打洞连接。更多细节请参考下一部分的 NAT 到 NAT 连接实践的章节。</p>
<p>如果某一端同时连接了多个对端，当它想访问某个 IP 时，如果有具体的路由可用，则优先使用具体的路由，否则就会将流量转发到中继服务器，然后中继服务器再根据系统路由表进行转发。你可以通过测量 ping 的时间来计算每一跳的长度，并通过检查对端的输出（<code>wg show wg0</code>）来找到 WireGuard 对一个给定地址的路由方式。</p>
<p><strong>报文格式</strong></p>
<p>WireGuard 使用加密的 UDP 报文来封装所有的数据，UDP 不保证数据包一定能送达，也不保证按顺序到达，但隧道内的 TCP 连接可以保证数据有效交付。WireGuard 的报文格式如下图所示：</p>
<p><img loading="lazy" src="/Distributions/WireGuardMessage.png" alt="img"  />
</p>
<p><strong>性能</strong></p>
<p>WireGuard 声称其性能比大多数 VPN 协议更好，但这个事情有很多争议，比如某些加密方式支持硬件层面的加速。</p>
<p>WireGuard 直接在内核层面处理路由，直接使用系统内核的加密模块来加密数据，和 Linux 原本内置的密码子系统共存，原有的子系统能通过 <code>API</code> 使用 WireGuard 的 <code>Zinc</code> 密码库。WireGuard 使用 UDP 协议传输数据，在不使用的情况下默认不会传输任何 UDP 数据包，所以比常规 VPN 省电很多，可以像 55 一样一直挂着使用，速度相比其他 VPN 也是压倒性优势。</p>
<p><img loading="lazy" src="/Distributions/WireGuardPerformance.png" alt="img"  />
</p>
<p><strong>安全模型</strong></p>
<p>WireGuard 使用以下加密技术来保障数据的安全：</p>
<ul>
<li>使用 <code>ChaCha20</code> 进行对称加密，使用 <code>Poly1305</code> 进行数据验证。</li>
<li>利用 <code>Curve25519</code> 进行密钥交换。</li>
<li>使用 <code>BLAKE2</code> 作为哈希函数。</li>
<li>使用 <code>HKDF</code> 进行解密。</li>
</ul>
<p>WireGuard 的加密技术本质上是 <code>Trevor Perrin</code> 的 <code>Noise</code> 框架的实例化，它简单高效，其他的 VPN 都是通过一系列协商、握手和复杂的状态机来保障安全性。WireGuard 就相当于 VPN 协议中的 <code>qmail</code>，代码量比其他 VPN 协议少了好几个数量级。</p>
<p><strong>密钥管理</strong></p>
<p>WireGuard 通过为每个对等节点提供简单的公钥和私钥来实现双向认证，每个对等节点在设置阶段生成密钥，且只在对等节点之间共享密钥。每个节点除了公钥和私钥，不再需要其他证书或预共享密钥。</p>
<p>在更大规模的部署中，可以使用 <code>Ansible</code> 或 <code>Kubernetes Secrets</code> 等单独的服务来处理密钥的生成、分发和销毁。</p>
<p>如果你不想在 <code>wg0.conf</code> 配置文件中直接硬编码，可以从文件或命令中读取密钥，这使得通过第三方服务管理密钥变得更加容易：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>Interface<span style="color:#f92672">]</span>
...
PostUp <span style="color:#f92672">=</span> wg set %i private-key /etc/wireguard/wg0.key &lt;<span style="color:#f92672">(</span>cat /some/path/%i/privkey<span style="color:#f92672">)</span>
</code></pre></div><p>从技术上讲，多个服务端之间可以共享相同的私钥，只要客户端不使用相同的密钥同时连接到两个服务器。但有时客户端会需要同时连接多台服务器，例如，你可以使用 <code>DNS</code> 轮询来均衡两台服务器之间的连接，这两台服务器配置相同。大多数情况下，每个对等节点都应该使用独立的的公钥和私钥，这样每个对等节点都不能读取到对方的流量，保障了安全性。</p>
<h4 id="搭建使用与配置详解">搭建使用与配置详解<a hidden class="anchor" aria-hidden="true" href="#搭建使用与配置详解">#</a></h4>
<h5 id="快速开始">快速开始<a hidden class="anchor" aria-hidden="true" href="#快速开始">#</a></h5>
<p><strong>安装</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># Ubuntu ≥ 18.04</span>
$ apt install wireguard
</code></pre></div><p>在中继服务器上开启 IP 地址转发：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ echo <span style="color:#e6db74">&#34;net.ipv4.ip_forward = 1&#34;</span> &gt;&gt; /etc/sysctl.conf
$ echo <span style="color:#e6db74">&#34;net.ipv4.conf.all.proxy_arp = 1&#34;</span> &gt;&gt; /etc/sysctl.conf
$ sysctl -p /etc/sysctl.conf
</code></pre></div><p>添加 iptables 规则，允许本机的 NAT 转换：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ iptables -A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
$ iptables -A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
$ iptables -A FORWARD -i wg0 -o wg0 -m conntrack --ctstate NEW -j ACCEPT
$ iptables -t nat -A POSTROUTING -s 192.0.2.0/24 -o eth0 -j MASQUERADE
</code></pre></div><p>需要把 <code>eth0</code> 改成你实际使用的网卡接口名称。</p>
<p><strong>配置文件</strong></p>
<p>配置文件可以放在任何路径下，但必须通过绝对路径引用。默认路径是 <code>/etc/wireguard/wg0.conf</code>。</p>
<p><strong>生成密钥</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">#生成私钥</span>
$ wg genkey &gt; example.key

<span style="color:#75715e"># 生成公钥</span>
$ wg pubkey &lt; example.key &gt; example.key.pub
</code></pre></div><p><strong>启动与停止</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ wg-quick up /full/path/to/wg0.conf
$ wg-quick down /full/path/to/wg0.conf

<span style="color:#75715e"># 启动/停止 VPN 网络接口</span>
$ ip link set wg0 up
$ ip link set wg0 down

<span style="color:#75715e"># 注册/注销 VPN 网络接口</span>
$ ip link add dev wg0 type wireguard
$ ip link delete dev wg0

<span style="color:#75715e"># 注册/注销 本地 VPN 地址</span>
$ ip address add dev wg0 192.0.2.3/32
$ ip address delete dev wg0 192.0.2.3/32

<span style="color:#75715e"># 添加/删除 VPN 路由</span>
$ ip route add 192.0.2.3/32 dev wg0
$ ip route delete 192.0.2.3/32 dev wg0
</code></pre></div><p><strong>查看信息</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 查看系统 VPN 接口信息</span>
$ ip link show wg0

<span style="color:#75715e"># 查看 VPN 接口详细信息</span>
$ wg show all
$ wg show wg0

<span style="color:#75715e"># 查看 VPN 接口地址</span>
$ ip address show wg0
</code></pre></div><p><strong>路由</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 查看系统路由表</span>
$ ip route show table main
$ ip route show table local

<span style="color:#75715e"># 获取到特定 IP 的路由</span>
$ ip route get 192.0.2.3
</code></pre></div><p><strong>一键安装</strong></p>
<p>一键安装请参考这个项目：<a href="https://github.com/angristan/wireguard-install">WireGuard installer</a></p>
<h5 id="配置详解">配置详解<a hidden class="anchor" aria-hidden="true" href="#配置详解">#</a></h5>
<p>WireGuard 使用 <a href="https://zh.wikipedia.org/wiki/INI%E6%96%87%E4%BB%B6">INI</a> 语法作为其配置文件格式。配置文件可以放在任何路径下，但必须通过绝对路径引用。默认路径是 <code>/etc/wireguard/wg0.conf</code>。</p>
<p>配置文件的命名形式必须为 <code>${WireGuard 接口的名称}.conf</code>。通常情况下 WireGuard 接口名称以 <code>wg</code> 为前缀，并从 <code>0</code> 开始编号，但你也可以使用其他名称，只要符合正则表达式 <code>^[a-zA-Z0-9_=+.-]{1,15}$</code> 就行。</p>
<p>你可以选择使用 <code>wg</code> 命令来手动配置 VPN，但一般建议使用 <code>wg-quick</code>，它提供了更强大和用户友好的配置体验，可以通过配置文件来管理配置。</p>
<p>下面是一个配置文件示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ini" data-lang="ini"><span style="color:#66d9ef">[Interface]</span>
<span style="color:#75715e"># Name = node1.example.tld</span>
<span style="color:#a6e22e">Address</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">192.0.2.3/32</span>
<span style="color:#a6e22e">ListenPort</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">51820</span>
<span style="color:#a6e22e">PrivateKey</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">localPrivateKeyAbcAbcAbc=</span>
<span style="color:#a6e22e">DNS</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">1.1.1.1,8.8.8.8</span>
<span style="color:#a6e22e">Table</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">12345</span>
<span style="color:#a6e22e">MTU</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">1500</span>
<span style="color:#a6e22e">PreUp</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">/bin/example arg1 arg2 %i</span>
<span style="color:#a6e22e">PostUp</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">/bin/example arg1 arg2 %i</span>
<span style="color:#a6e22e">PreDown</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">/bin/example arg1 arg2 %i</span>
<span style="color:#a6e22e">PostDown</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">/bin/example arg1 arg2 %i</span>

<span style="color:#66d9ef">[Peer]</span>
<span style="color:#75715e"># Name = node2-node.example.tld</span>
<span style="color:#a6e22e">AllowedIPs</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">192.0.2.1/24</span>
<span style="color:#a6e22e">Endpoint</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">node1.example.tld:51820</span>
<span style="color:#a6e22e">PublicKey</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">remotePublicKeyAbcAbcAbc=</span>
<span style="color:#a6e22e">PersistentKeepalive</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">25</span>
</code></pre></div><p><strong>[Interface]</strong></p>
<p>这一节定义本地 VPN 配置。例如：</p>
<p>本地节点是客户端，只路由自身的流量，只暴露一个 IP。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ini" data-lang="ini"><span style="color:#66d9ef">[Interface]</span>
<span style="color:#75715e"># Name = phone.example-vpn.dev</span>
<span style="color:#a6e22e">Address</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">192.0.2.5/32</span>
<span style="color:#a6e22e">PrivateKey</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&lt;private key for phone.example-vpn.dev&gt;</span>
</code></pre></div><p>本地节点是中继服务器，它可以将流量转发到其他对等节点（peer），并公开整个 VPN 子网的路由。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ini" data-lang="ini"><span style="color:#66d9ef">[Interface]</span>
<span style="color:#75715e"># Name = public-server1.example-vpn.tld</span>
<span style="color:#a6e22e">Address</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">192.0.2.1/24</span>
<span style="color:#a6e22e">ListenPort</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">51820</span>
<span style="color:#a6e22e">PrivateKey</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&lt;private key for public-server1.example-vpn.tld&gt;</span>
<span style="color:#a6e22e">DNS</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">1.1.1.1</span>
</code></pre></div><ol>
<li>Name</li>
</ol>
<p>这是 <code>INI</code> 语法中的标准注释，用于展示该配置部分属于哪个节点。这部分配置会被 WireGuard 完全忽略，对 VPN 的行为没有任何影响。</p>
<ol start="2">
<li>Address</li>
</ol>
<p>定义本地节点应该对哪个地址范围进行路由。如果是常规的客户端，则将其设置为节点本身的单个 IP（使用 CIDR 指定，例如 192.0.2.3/32）；如果是中继服务器，则将其设置为可路由的子网范围。</p>
<p>例如：</p>
<ul>
<li>常规客户端，只路由自身的流量：<code>Address = 192.0.2.3/32</code></li>
<li>中继服务器，可以将流量转发到其他对等节点（peer）：<code>Address = 192.0.2.1/24</code></li>
<li>也可以指定多个子网或 IPv6 子网：<code>Address = 192.0.2.1/24,2001:DB8::/64</code></li>
</ul>
<ol start="3">
<li>ListenPort</li>
</ol>
<p>当本地节点是中继服务器时，需要通过该参数指定端口来监听传入 VPN 连接，默认端口号是 <code>51820</code>。常规客户端不需要此选项。</p>
<ol start="4">
<li>PrivateKey</li>
</ol>
<p>本地节点的私钥，所有节点（包括中继服务器）都必须设置。不可与其他服务器共用。</p>
<p>私钥可通过命令 <code>wg genkey &gt; example.key</code> 来生成。</p>
<ol start="5">
<li>DNS</li>
</ol>
<p>通过 DHCP 向客户端宣告 DNS 服务器。客户端将会使用这里指定的 DNS 服务器来处理 VPN 子网中的 DNS 请求，但也可以在系统中覆盖此选项。例如：</p>
<ul>
<li>如果不配置则使用系统默认 DNS</li>
<li>可以指定单个 DNS：<code>DNS = 1.1.1.1</code></li>
<li>也可以指定多个 DNS：<code>DNS = 1.1.1.1,8.8.8.8</code></li>
</ul>
<ol start="6">
<li>Table</li>
</ol>
<p>定义 VPN 子网使用的路由表，默认不需要设置。该参数有两个特殊的值需要注意：</p>
<ul>
<li><code>Table = off</code> : 禁止创建路由</li>
<li><code>Table = auto</code>（默认值） : 将路由添加到系统默认的 table 中，并启用对默认路由的特殊处理。</li>
</ul>
<p>例如：<code>Table = 1234</code></p>
<ol start="7">
<li>MTU</li>
</ol>
<p>定义连接到对等节点（peer）的 <code>MTU</code>（Maximum Transmission Unit，最大传输单元），默认不需要设置，一般由系统自动确定。</p>
<ol start="8">
<li>PreUp</li>
</ol>
<p>启动 VPN 接口之前运行的命令。这个选项可以指定多次，按顺序执行。</p>
<p>例如添加路由：<code>PreUp = ip rule add ipproto tcp dport 22 table 1234</code></p>
<ol start="9">
<li>PostUp</li>
</ol>
<p>启动 VPN 接口之后运行的命令。这个选项可以指定多次，按顺序执行。</p>
<p>例如：</p>
<ul>
<li>
<p>从文件或某个命令的输出中读取配置值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ini" data-lang="ini"><span style="color:#a6e22e">PostUp</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">wg set %i private-key /etc/wireguard/wg0.key &lt;(some command here)</span>
</code></pre></div></li>
<li>
<p>添加一行日志到文件中：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ini" data-lang="ini"><span style="color:#a6e22e">PostUp</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">echo &#34;$(date +%s) WireGuard Started&#34; &gt;&gt; /var/log/wireguard.log</span>
</code></pre></div></li>
<li>
<p>调用 WebHook：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ini" data-lang="ini"><span style="color:#a6e22e">PostUp</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">curl https://events.example.dev/wireguard/started/?key=abcdefg</span>
</code></pre></div></li>
<li>
<p>添加路由：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ini" data-lang="ini"><span style="color:#a6e22e">PostUp</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">ip rule add ipproto tcp dport 22 table 1234</span>
</code></pre></div></li>
<li>
<p>添加 iptables 规则，启用数据包转发：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ini" data-lang="ini"><span style="color:#a6e22e">PostUp</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</span>
</code></pre></div></li>
<li>
<p>强制 WireGuard 重新解析对端域名的 IP 地址：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ini" data-lang="ini"><span style="color:#a6e22e">PostUp</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">resolvectl domain %i &#34;~.&#34;; resolvectl dns %i 192.0.2.1; resolvectl dnssec %i yes</span>
</code></pre></div></li>
</ul>
<ol start="10">
<li>PreDown</li>
</ol>
<p>停止 VPN 接口之前运行的命令。这个选项可以指定多次，按顺序执行。</p>
<p>例如：</p>
<ul>
<li>
<p>添加一行日志到文件中：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ini" data-lang="ini"><span style="color:#a6e22e">PreDown</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">echo &#34;$(date +%s) WireGuard Going Down&#34; &gt;&gt; /var/log/wireguard.log</span>
</code></pre></div></li>
<li>
<p>调用 WebHook：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ini" data-lang="ini"><span style="color:#a6e22e">PreDown</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">curl https://events.example.dev/wireguard/stopping/?key=abcdefg</span>
</code></pre></div></li>
</ul>
<ol start="11">
<li>PostDown</li>
</ol>
<p>停止 VPN 接口之后运行的命令。这个选项可以指定多次，按顺序执行。</p>
<p>例如：</p>
<ul>
<li>
<p>添加一行日志到文件中：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ini" data-lang="ini"><span style="color:#a6e22e">PostDown</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">echo &#34;$(date +%s) WireGuard Going Down&#34; &gt;&gt; /var/log/wireguard.log</span>
</code></pre></div></li>
<li>
<p>调用 WebHook：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ini" data-lang="ini"><span style="color:#a6e22e">PostDown</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">curl https://events.example.dev/wireguard/stopping/?key=abcdefg</span>
</code></pre></div></li>
<li>
<p>删除 iptables 规则，关闭数据包转发：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ini" data-lang="ini"><span style="color:#a6e22e">PostDown</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE</span>
</code></pre></div></li>
</ul>
<p><strong>[Peer]</strong></p>
<p>定义能够为一个或多个地址路由流量的对等节点（peer）的 VPN 设置。对等节点（peer）可以是将流量转发到其他对等节点（peer）的中继服务器，也可以是通过公网或内网直连的客户端。</p>
<p>中继服务器必须将所有的客户端定义为对等节点（peer），除了中继服务器之外，其他客户端都不能将位于 NAT 后面的节点定义为对等节点（peer），因为路由不可达。对于那些只为自己路由流量的客户端，只需将中继服务器作为对等节点（peer），以及其他需要直接访问的节点。</p>
<p>举个例子，在下面的配置中，<code>public-server1</code> 作为中继服务器，其他的客户端有的是直连，有的位于 NAT 后面：</p>
<ul>
<li>
<p><code>public-server1</code>（中继服务器）</p>
<p>[peer] : <code>public-server2</code>, <code>home-server</code>, <code>laptop</code>, <code>phone</code></p>
</li>
<li>
<p><code>public-server2</code>（直连客户端）</p>
<p>[peer] : <code>public-server1</code></p>
</li>
<li>
<p><code>home-server</code>（客户端位于 NAT 后面）</p>
<p>[peer] : <code>public-server1</code>, <code>public-server2</code></p>
</li>
<li>
<p><code>laptop</code>（客户端位于 NAT 后面）</p>
<p>[peer] : <code>public-server1</code>, <code>public-server2</code></p>
</li>
<li>
<p><code>phone</code>（客户端位于 NAT 后面）</p>
<p>[peer] : <code>public-server1</code>, <code>public-server2</code></p>
</li>
</ul>
<p>配置示例：</p>
<ul>
<li>
<p>对等节点（peer）是路由可达的客户端，只为自己路由流量</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ini" data-lang="ini"><span style="color:#66d9ef">[Peer]</span>
<span style="color:#75715e"># Name = public-server2.example-vpn.dev</span>
<span style="color:#a6e22e">Endpoint</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">public-server2.example-vpn.dev:51820</span>
<span style="color:#a6e22e">PublicKey</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&lt;public key for public-server2.example-vpn.dev&gt;</span>
<span style="color:#a6e22e">AllowedIPs</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">192.0.2.2/32</span>
</code></pre></div></li>
<li>
<p>对等节点（peer）是位于 NAT 后面的客户端，只为自己路由流量</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ini" data-lang="ini"><span style="color:#66d9ef">[Peer]</span>
<span style="color:#75715e"># Name = home-server.example-vpn.dev</span>
<span style="color:#a6e22e">Endpoint</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">home-server.example-vpn.dev:51820</span>
<span style="color:#a6e22e">PublicKey</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&lt;public key for home-server.example-vpn.dev&gt;</span>
<span style="color:#a6e22e">AllowedIPs</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">192.0.2.3/32</span>
</code></pre></div></li>
<li>
<p>对等节点（peer）是中继服务器，用来将流量转发到其他对等节点（peer）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ini" data-lang="ini"><span style="color:#66d9ef">[Peer]</span>
<span style="color:#75715e"># Name = public-server1.example-vpn.tld</span>
<span style="color:#a6e22e">Endpoint</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">public-server1.example-vpn.tld:51820</span>
<span style="color:#a6e22e">PublicKey</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&lt;public key for public-server1.example-vpn.tld&gt;</span>
<span style="color:#75715e"># 路由整个 VPN 子网的流量</span>
<span style="color:#a6e22e">AllowedIPs</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">192.0.2.1/24</span>
<span style="color:#a6e22e">PersistentKeepalive</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">25</span>
</code></pre></div></li>
</ul>
<ol>
<li>Endpoint</li>
</ol>
<p>指定远端对等节点（peer）的公网地址。如果对等节点（peer）位于 NAT 后面或者没有稳定的公网访问地址，就忽略这个字段。通常只需要指定<strong>中继服务器</strong>的 <code>Endpoint</code>，当然有稳定公网 IP 的节点也可以指定。例如：</p>
<ul>
<li>
<p>通过 IP 指定：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ini" data-lang="ini"><span style="color:#a6e22e">Endpoint</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">123.124.125.126:51820</span>
</code></pre></div></li>
<li>
<p>通过域名指定：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ini" data-lang="ini"><span style="color:#a6e22e">Endpoint</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">public-server1.example-vpn.tld:51820</span>
</code></pre></div></li>
</ul>
<ol start="2">
<li>AllowedIPs</li>
</ol>
<p>允许该对等节点（peer）发送过来的 VPN 流量中的源地址范围。同时这个字段也会作为本机路由表中 wg0 绑定的 IP 地址范围。如果对等节点（peer）是常规的客户端，则将其设置为节点本身的单个 IP；如果对等节点（peer）是中继服务器，则将其设置为可路由的子网范围。可以使用 <code>,</code> 来指定多个 IP 或子网范围。该字段也可以指定多次。</p>
<p>当决定如何对一个数据包进行路由时，系统首先会选择最具体的路由，如果不匹配再选择更宽泛的路由。例如，对于一个发往 <code>192.0.2.3</code> 的数据包，系统首先会寻找地址为 <code>192.0.2.3/32</code> 的对等节点（peer），如果没有再寻找地址为 <code>192.0.2.1/24</code> 的对等节点（peer），以此类推。</p>
<p>例如：</p>
<ul>
<li>
<p>对等节点（peer）是常规客户端，只路由自身的流量：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ini" data-lang="ini"><span style="color:#a6e22e">AllowedIPs</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">192.0.2.3/32</span>
</code></pre></div></li>
<li>
<p>对等节点（peer）是中继服务器，可以将流量转发到其他对等节点（peer）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ini" data-lang="ini"><span style="color:#a6e22e">AllowedIPs</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">192.0.2.1/24</span>
</code></pre></div></li>
<li>
<p>对等节点（peer）是中继服务器，可以转发所有的流量，包括外网流量和 VPN 流量，可以用来干嘛你懂得：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ini" data-lang="ini"><span style="color:#a6e22e">AllowedIPs</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">0.0.0.0/0,::/0</span>
</code></pre></div></li>
<li>
<p>对等节点（peer）是中继服务器，可以路由其自身和其他对等节点（peer）的流量：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ini" data-lang="ini"><span style="color:#a6e22e">AllowedIPs</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">192.0.2.3/32,192.0.2.4/32</span>
</code></pre></div></li>
<li>
<p>对等节点（peer）是中继服务器，可以路由其自身的流量和它所在的内网的流量：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ini" data-lang="ini"><span style="color:#a6e22e">AllowedIPs</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">192.0.2.3/32,192.168.1.1/24</span>
</code></pre></div></li>
</ul>
<ol start="3">
<li>PublicKey</li>
</ol>
<p>对等节点（peer）的公钥，所有节点（包括中继服务器）都必须设置。可与其他对等节点（peer）共用同一个公钥。</p>
<p>公钥可通过命令 <code>wg pubkey &lt; example.key &gt; example.key.pub</code> 来生成，其中 <code>example.key</code> 是上面生成的私钥。</p>
<p>例如：<code>PublicKey = somePublicKeyAbcdAbcdAbcdAbcd=</code></p>
<ol start="4">
<li>PersistentKeepalive</li>
</ol>
<p>如果连接是从一个位于 NAT 后面的对等节点（peer）到一个公网可达的对等节点（peer），那么 NAT 后面的对等节点（peer）必须定期发送一个出站 ping 包来检查连通性，如果 IP 有变化，就会自动更新<code>Endpoint</code>。</p>
<p>例如：</p>
<ul>
<li>本地节点与对等节点（peer）可直连：该字段不需要指定，因为不需要连接检查。</li>
<li>对等节点（peer）位于 NAT 后面：该字段不需要指定，因为维持连接是客户端（连接的发起方）的责任。</li>
<li>本地节点位于 NAT 后面，对等节点（peer）公网可达：需要指定该字段 <code>PersistentKeepalive = 25</code>，表示每隔 <code>25</code> 秒发送一次 ping 来检查连接。</li>
</ul>
<h2 id="gui-utilities">GUI Utilities<a hidden class="anchor" aria-hidden="true" href="#gui-utilities">#</a></h2>
<h3 id="gnome">Gnome<a hidden class="anchor" aria-hidden="true" href="#gnome">#</a></h3>
<p>GNOME 系统设置面板（gnome-control-center）和 GNOME 应用使用 <a href="https://en.wikipedia.org/wiki/Dconf">dconf</a> 配置系统存储设置。您可以使用 <code>gsettings</code> 或 <code>dconf</code> 命令行工具直接访问 dconf 数据库。这也可以让你修改用户界面不公开的设置。</p>
<p>GNOME 桌面拥有强大的搜索功能，按 <code>Super</code> 键并搜索一些东西，可以进入“Settings-Search”中来设置可以搜索的内容和顺序。</p>
<p>Do Not Disturb 使通知只在消息栏中，不会在桌面上弹出。</p>
<p>Gnome 3 自动切换的壁纸会有一个有时钟小图标。</p>
<h4 id="浏览">浏览<a hidden class="anchor" aria-hidden="true" href="#浏览">#</a></h4>
<p><a href="https://wiki.gnome.org/Projects/GnomeShell/CheatSheet">GNOME Shell cheat sheet</a> 中解释了如何高效地使用 GNOME shell，它展示了 GNOME shell 的特色和快捷键，包括切换任务，使用键盘，窗口控制，面板，概览模式等等。以下是部分常用的快捷键：</p>
<ul>
<li><code>Super</code> + <code>m</code>：显示消息托盘</li>
<li><code>Super</code> + <code>a</code>：显示应用程序菜单</li>
<li><code>Alt-</code> + <code>Tab</code>：切换当前使用的应用</li>
<li><code>Alt-</code> +  ` (美式键盘 <code>Tab</code> 上面的按键)：切换前台应用程序的窗口</li>
<li><code>Alt</code> + <code>F2</code>，然后输入 <code>r</code> 或 <code>restart</code>：在图形界面出问题时重启界面（仅用于 X/传统 模式，不适用于 Wayland 模式）。也可通过此运行后台应用，如 cfw。</li>
</ul>
<h4 id="遗留名称">遗留名称<a hidden class="anchor" aria-hidden="true" href="#遗留名称">#</a></h4>
<p><strong>注意：</strong> 一些 GNOME 程序在文档和对话框中的名称已经更改，但执行文件名称却没有。下面表格列出了一些这样的应用程序。</p>
<p><strong>提示：</strong> 在搜索栏中搜索应用的遗留名称将成功找到对应的应用，例如搜索 <em>nautilus</em> 将返还 <em>文件</em>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">当前</th>
<th style="text-align:center">遗留</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">文件</td>
<td style="text-align:center">Nautilus</td>
</tr>
<tr>
<td style="text-align:center">Web</td>
<td style="text-align:center">Epiphany</td>
</tr>
<tr>
<td style="text-align:center">视频</td>
<td style="text-align:center">Totem</td>
</tr>
<tr>
<td style="text-align:center">主菜单</td>
<td style="text-align:center">Alacarte</td>
</tr>
<tr>
<td style="text-align:center">文档查看器</td>
<td style="text-align:center">Evince</td>
</tr>
<tr>
<td style="text-align:center">磁盘使用情况分析器</td>
<td style="text-align:center">Baobab</td>
</tr>
<tr>
<td style="text-align:center">图像查看器</td>
<td style="text-align:center">EoG (Eye of GNOME)</td>
</tr>
<tr>
<td style="text-align:center">密码和密钥</td>
<td style="text-align:center">Seahorse</td>
</tr>
</tbody>
</table>
<h4 id="修改文件默认关联的应用程序">修改文件默认关联的应用程序<a hidden class="anchor" aria-hidden="true" href="#修改文件默认关联的应用程序">#</a></h4>
<ul>
<li>mime类型文件存在于以下的两个路径：
<ul>
<li><code>/usr/share/mime</code></li>
<li><code>~/.local/share/mime</code></li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">/usr/share/mime/text/makrdown.xml
</code></pre></div><ul>
<li>应用程序的desktop文件，存在于以下的两个路径：
<ul>
<li><code>/usr/share/applications</code></li>
<li><code>~/.local/share/applications</code></li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>Desktop Entry<span style="color:#f92672">]</span>
<span style="color:#75715e"># 应用名称，即开始菜单中的名称</span>
Type<span style="color:#f92672">=</span>ApplicationName<span style="color:#f92672">=</span>name 
<span style="color:#75715e"># 应用执行文件位置</span>
Exec<span style="color:#f92672">=</span>appPath
<span style="color:#75715e"># 应用图标位置</span>
Icon<span style="color:#f92672">=</span>default48.png
<span style="color:#75715e"># 是否显示终端</span>
Terminal<span style="color:#f92672">=</span>false
<span style="color:#75715e"># 所属分类</span>
StartupNotify<span style="color:#f92672">=</span>trueCategories<span style="color:#f92672">=</span>Office
<span style="color:#75715e"># MIME 类型</span>
MimeType<span style="color:#f92672">=</span>text/x-markdown
</code></pre></div><ul>
<li>应用程序默认关联文件，存在于以下的两个路径：
<ul>
<li><code>/usr/share/applications/mimeapps.list</code></li>
<li><code>~/.local/share/applications/mimeapps.list</code></li>
</ul>
</li>
</ul>
<h4 id="gedit-编码">Gedit 编码<a hidden class="anchor" aria-hidden="true" href="#gedit-编码">#</a></h4>
<p>直接打开gedit（非通过文件打开），点击左上角 <strong>Open</strong>，点击左下角 <strong>Automatically Detected</strong>，下拉选择 <strong>Add or Remove&hellip;</strong>，将简体中文编码都选上。</p>
<p>或者：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ gsettings list-keys org.gnome.gedit.preferences.encodings
candidate-encodings
$ gsettings set org.gnome.gedit.preferences.encodings candidate-encodings <span style="color:#e6db74">&#34;[&#39;UTF-8&#39;, &#39;ISO-8859-15&#39;, &#39;UTF-16&#39;, &#39;GBK&#39;, &#39;GB18030&#39;, &#39;GB2312&#39;]&#34;</span>
</code></pre></div><h4 id="nvidia-optimushttpswikiarchlinuxorgtitlenvidia_optimus_e7ae80e4bd93e4b8ade69687"><a href="https://wiki.archlinux.org/title/NVIDIA_Optimus_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">NVIDIA Optimus</a><a hidden class="anchor" aria-hidden="true" href="#nvidia-optimushttpswikiarchlinuxorgtitlenvidia_optimus_e7ae80e4bd93e4b8ade69687">#</a></h4>
<p><a href="https://en.wikipedia.org/wiki/NVIDIA_Optimus">NVIDIA Optimus</a> 是一项允许英特尔（Intel）集成图形处理器（GPU）和英伟达（NVIDIA）独立图形处理器置入并通过一台笔记本电脑访问的技术。</p>
<h4 id="桌面卡死httpsblogcsdnnetsonggu1996articledetails87712546"><a href="https://blog.csdn.net/SongGu1996/article/details/87712546">桌面卡死</a><a hidden class="anchor" aria-hidden="true" href="#桌面卡死httpsblogcsdnnetsonggu1996articledetails87712546">#</a></h4>
<p>总的来说，就是杀死相关进程，或者避免使用造成卡死相关软件。</p>
<ul>
<li>
<p>选择其他 tty：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ pkill Xorg 
</code></pre></div><p>pkill 用于杀死一个进程，与 kill 不同的是它会杀死指定名字的所有进程。kill 命令杀死指定进程 PID，需要配合 ps 使用。</p>
</li>
<li>
<p>安全重启：同时按住 Ctrl 和 Alt 键，按住不要放，按一下 <code>SysRq</code> 键（有的键盘是PrtSc），按一下 <code>R</code> 键，按一下 <code>E</code> 键，依次按下 <code>I</code> , <code>S</code> , <code>U</code> , <code>B</code> 键。</p>
</li>
<li>
<p><a href="https://www.cnblogs.com/schips/p/10167168.html">解决 Ubuntu 经常卡死</a>：ubuntu 的卡死可能与显卡驱动不兼容有关。用 nvidia 代替 nouveau显卡驱动。其中 <a href="https://askubuntu.com/questions/1262401/what-is-the-nvidia-server-driver">nvidia-driver-470-server</a> 是 server 版，最好用 nvidia-driver-470</p>
</li>
</ul>
<h4 id="prime-synchronizationhttpswikidebianorgnvidia20optimusprime_synchronization"><a href="https://wiki.debian.org/NVIDIA%20Optimus#PRIME_synchronization">PRIME synchronization</a><a hidden class="anchor" aria-hidden="true" href="#prime-synchronizationhttpswikidebianorgnvidia20optimusprime_synchronization">#</a></h4>
<p>You can enable <a href="https://forums.developer.nvidia.com/t/prime-and-prime-synchronization/44423">PRIME synchronization</a> to prevent <a href="https://en.wikipedia.org/wiki/Screen_tearing">screen tearing</a>. It requires:</p>
<ul>
<li>Linux kernel 4.5 or higher;</li>
<li>X server 1.19 or higher;</li>
<li>NVIDIA driver 370.23 or higher.</li>
</ul>
<p>PRIME synchronization will be enabled automatically after you enable <a href="https://en.wikipedia.org/wiki/Mode_setting">KMS</a> for <code>nvidia-drm</code> module.</p>
<ol>
<li>
<p>Add this line to the end of <code>/etc/modprobe.d/nvidia.conf</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">options nvidia-drm modeset<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</code></pre></div></li>
<li>
<p>Regenerate your <a href="https://wiki.debian.org/initramfs">initramfs</a> image by running:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># update-initramfs -u</span>
</code></pre></div></li>
<li>
<p>Reboot.</p>
</li>
</ol>
<p>要检查重新启动后以前的更改是否有效，请运行命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo cat /sys/module/nvidia_drm/parameters/modeset
Y
</code></pre></div><p>see more about nvidia  on uat <a href="https://help.ubuntu.com/community/BinaryDriverHowto/Nvidia">BinaryDriverHowto/Nvidia</a></p>
<h4 id="permanently-set-nvidia-powermizer-settingshttpsrastatinggithubiohow-to-permanently-set-nvidia-powermizer-settings-in-ubuntu"><a href="https://rastating.github.io/how-to-permanently-set-nvidia-powermizer-settings-in-ubuntu/">Permanently Set NVIDIA PowerMizer Settings</a><a hidden class="anchor" aria-hidden="true" href="#permanently-set-nvidia-powermizer-settingshttpsrastatinggithubiohow-to-permanently-set-nvidia-powermizer-settings-in-ubuntu">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ nvidia-settings -q GpuPowerMizerMode
  Attribute <span style="color:#e6db74">&#39;GPUPowerMizerMode&#39;</span> <span style="color:#f92672">(</span>rastating-PC:1<span style="color:#f92672">[</span>gpu:0<span style="color:#f92672">])</span>: 0.
    Valid values <span style="color:#66d9ef">for</span> <span style="color:#e6db74">&#39;GPUPowerMizerMode&#39;</span> are: 0, <span style="color:#ae81ff">1</span> and 2.
    <span style="color:#e6db74">&#39;GPUPowerMizerMode&#39;</span> can use the following target types: GPU.
    
$ nvidia-settings -a <span style="color:#e6db74">&#34;[gpu:0]/GpuPowerMizerMode=1&#34;</span>
  Attribute <span style="color:#e6db74">&#39;GPUPowerMizerMode&#39;</span> <span style="color:#f92672">(</span>rastating-PC:1<span style="color:#f92672">[</span>gpu:0<span style="color:#f92672">])</span> assigned value 1.

$ nvidia-settings -q GpuPowerMizerMode
  Attribute <span style="color:#e6db74">&#39;GPUPowerMizerMode&#39;</span> <span style="color:#f92672">(</span>rastating-PC:1<span style="color:#f92672">[</span>gpu:0<span style="color:#f92672">])</span>: 1.
    Valid values <span style="color:#66d9ef">for</span> <span style="color:#e6db74">&#39;GPUPowerMizerMode&#39;</span> are: 0, <span style="color:#ae81ff">1</span> and 2.
    <span style="color:#e6db74">&#39;GPUPowerMizerMode&#39;</span> can use the following target types: GPU.
</code></pre></div><p>添加到开机启动</p>
<ul>
<li>Name：<code>NVIDIA X Server Performance Settings</code></li>
<li>Command：<code>/usr/bin/nvidia-settings  -a &quot;[gpu:0]/GpuPowerMizerMode=1&quot;</code></li>
</ul>
<h4 id="密钥环httpslinuxcnarticle-12093-1html"><a href="https://linux.cn/article-12093-1.html">密钥环</a><a hidden class="anchor" aria-hidden="true" href="#密钥环httpslinuxcnarticle-12093-1html">#</a></h4>
<p>如果你用过 Ubuntu 或者其他的 Linux 发行版里的<a href="https://itsfoss.com/ubuntu-automatic-logon/">自动登录功能</a>, 你可能遇到过这种弹出消息：</p>
<blockquote>
<p>请输入密码以解锁你的登录密钥环</p>
<p>登录密钥环在你登录系统时未解锁。</p>
</blockquote>
<p><img loading="lazy" src="/Distributions/230422m0xvgv0oj4fjdk7d.jpg" alt="Enter Password To Unlock Your Login Keyring Ubuntu"  />
</p>
<p>如果你一直点击取消，它会不断弹出几次才会消失。你可能想知道，为什么你会一直看到这个密钥环信息呢？</p>
<p>让我来告诉你吧。它其实不是错误，而是一个安全特性。</p>
<p>奇怪吗？下面就让我来解释下 Linux 里的密钥环概念。</p>
<h5 id="密钥环是什么为什么需要它">密钥环是什么，为什么需要它？<a hidden class="anchor" aria-hidden="true" href="#密钥环是什么为什么需要它">#</a></h5>
<p>在现实生活中你为什么要用钥匙环（也叫<a href="https://en.wikipedia.org/wiki/Keychain">钥匙链</a>）？你用它把一把或多把钥匙串到一起, 以便于携带和查找。</p>
<p>Linux 里也是类似的。密钥环特性使你的系统可以将各种密码放在一起，并将其保存在一个地方。</p>
<p>大多数 Linux 桌面环境，如 GNOME、KDE、Xfce 等采用 <a href="https://wiki.archlinux.org/index.php/GNOME/Keyring">GNOME 密钥环</a>来提供这个功能。</p>
<p>该密钥环保存了 ssh 密钥、GPG 密钥以及使用此功能的应用程序（例如 Chromium 浏览器）的密钥。默认情况下，<strong>“密钥环”通过主密码来保护</strong>，该密码通常是帐户的登录密码。</p>
<p>系统上的每个用户都有自己的密钥环，（通常）密码与用户帐户本身的密码相同。当你使用密码登录系统时，你的密匙环将使用你帐户的密码自动解锁。</p>
<p>当你启用 Ubuntu 中的自动登录功能时时，就有问题了。这意味着你无需输入密码即可登录系统。在这种情况下，你的密钥环不会自动解锁。</p>
<p><strong>密钥环是一个安全特性</strong></p>
<p>记得我说过密钥环是一个安全特性吗？现在想象一下你在 Linux 电脑上开启了自动登录功能。有权访问你电脑的任何人无需密码就能进入你的系统。但是你可能不会在意，因为你只是用它来访问互联网。</p>
<p>但是，如果你在 Ubuntu 中使用 Chromium 或 Google Chrome 之类的浏览器，并使用它来保存各种网站的登录密码，那么你将遇到麻烦。任何人都可以使用浏览器并利用你在浏览器中保存的密码登录网站。这不很危险吗？</p>
<p>这就是为什么当你使用 Chrome 时，它将反复地提示你先解锁密钥环。这确保了只有知道密钥环密码（即账户密码）的人才能使用在浏览器中保存的密码来登录它们相关的网站。</p>
<p>如果你反复取消解锁密钥环的提示，它最终将消失，并允许你使用浏览器。但是，保存的密码将不会被解锁，你在 Chromium/Chome 浏览器上将会看到“同步暂停”的提示。</p>
<p><strong>如果密钥环一直存在，为什么你从来没有见过它呢?</strong></p>
<p>如果你在你的 Linux 系统上从没见过它的话，这个问题就很有道理。</p>
<p>如果你从没有用过自动登录功能（或者修改你的账户密码），你可能都没有意识到这个特性的存在。</p>
<p>这是因为当你通过你的密码登录系统时，你的密钥环被你的账户密码自动解锁了。</p>
<p>Ubuntu（和其他发行版）在执行普通的管理任务如修改用户、安装新软件等需要输入密码，无论你是否是自动登录的。但是对于日常任务像使用浏览器，它不需要输入密码因为密钥环已经被解锁了。</p>
<p>当你切换到自动登录时，你不再需要输入登录密码。这意味着密钥环没有被自动解锁，因此当你使用利用了密钥环特性的浏览器时，它将提示你来解锁密钥环。</p>
<p><strong>你可以轻松地管理密钥环和密码</strong></p>
<p>这个密钥环放在哪里？它的核心是一个守护任务（一个后台自动运行的程序）。</p>
<p>别担心。你不必通过终端来操作守护任务。大多数桌面环境都自带一个可以和这个守护进程进行交互的图形化应用程序。KDE 上有 KDE 钱包，GNOME 和其他桌面上叫做“密码和密钥”（Password And Keys）。</p>
<p>你可以用这个 GUI 程序来查看哪些应用程序在用密钥环来管理/保护密码。</p>
<p>你可以看到，我的系统有自动创建的登录密钥环。也有一个存储 GPG 和 SSH 密钥的密钥环。那个<a href="https://help.ubuntu.com/lts/serverguide/certificates-and-security.html">证书</a>用来保存证书机构颁发的证书（如 HTTPS 证书）。</p>
<p><img loading="lazy" src="/Distributions/230426pr9jj9ifjsgiez9i.png" alt="Password and Keys application in Ubuntu"  />
</p>
<p>你也可以使用这个应用程序来手动保存网站的密码。</p>
<p>这里有一个潜在的问题，如果你格式化你的系统，手动保存的密码必然会丢失。通常，你会备份你的个人文件，但并不是所有的用户特定数据，如密钥环文件。</p>
<p>有一种办法能解决它。密钥环数据通常保存在 <code>~/.local/share/keyrings</code> 目录。在这里你可以看到所有的密钥环，但是你不能直接看到它们的内容。如果你移除密钥环的密码（我会在这篇文章的后面描述操作步骤），你可以像一个普通的文本文件一样读取密钥环的内容。你可以将这个解锁后的密钥环文件完整地复制下来，并在其他的 Linux 机器上运行“密码和密钥”应用程序导入到其中。</p>
<p>总结一下目前为止所学的内容：</p>
<ul>
<li>大多数 Linux 系统缺省已经安装并激活了密钥环特性</li>
<li>系统上的每个用户都拥有他自己的密钥环</li>
<li>密钥环通常是用账户密码锁定的（保护）</li>
<li>当你通过密码登录时密钥环会被自动解锁</li>
<li>对于自动登录，密钥环不会自动解锁，因此当你试图使用依赖密钥环的应用程序时会被提示先解锁它</li>
<li>并不是所有的浏览器或应用程序利用了密钥环特性</li>
<li>（Linux 上）安装一个 GUI 程序可以和密钥环交互</li>
<li>你可以用密钥环来手动存储加密格式的密码</li>
<li>你可以自己修改密钥环密码</li>
<li>你可以通过导出（需要先解锁密钥环）并导入到其他计算机上的方式来获取手工保存的密码。</li>
</ul>
<h5 id="修改密钥环密码">修改密钥环密码<a hidden class="anchor" aria-hidden="true" href="#修改密钥环密码">#</a></h5>
<p>假设你修改了你的账户密码。当你登录时，你的系统试图通过新的登录密码来自动解锁密钥环。但是密钥环还在使用老的登录密码。</p>
<p>这种情况下，你可以修改密钥环密码为新的登录密码，这样密码环才能在你登录系统时自动解锁。</p>
<ul>
<li>从菜单中打开“密码和密钥”应用程序</li>
<li>在“Login”密钥环上右击并点击“修改密码”：</li>
</ul>
<p><strong>如果你不记得老的登录密码怎么办？</strong></p>
<p>你可能知道在 <a href="https://itsfoss.com/how-to-hack-ubuntu-password/">Ubuntu 上重置忘记的密码很容易</a>。但是密钥环在这种场景下还是有问题。你修改了账户密码，但是你不记得仍然被密钥环使用的老的账户密码。</p>
<p>你不能修改它因为你不知道老的密码。怎么办？</p>
<p>这种情况下，你将不得不移除整个密钥环。你可以通过“密码和密钥”应用程序来操作。</p>
<p>另外，你也可以手动删除 <code>~/.local/share/keyrings</code> 目录下的密钥环文件。</p>
<p>老的密钥环文件被移除后，你再打开 Chrome/Chromium 时，它会提示你创建一个新的密钥环。</p>
<p>你可以用新的登录密码，密钥环就会被自动解锁了。</p>
<h5 id="禁用密钥环密码">禁用密钥环密码<a hidden class="anchor" aria-hidden="true" href="#禁用密钥环密码">#</a></h5>
<p>在你想用自动登录但又不想手动解锁密钥环时，你可以把禁用密钥环密码作为一个规避方法。记住你正在禁用一个安全特性，因此请三思。</p>
<p>操作步骤和修改密钥环相似。打开“密码和密钥”应用程序，然后修改密钥环密码。</p>
<p>技巧在于当它提示修改密码时，不要输入新密码，而是点击“继续”按钮。这将移除密钥环的密码。</p>
<p>这种方法，密钥环没有密码保护，并将一直处于解锁状态。</p>
<h3 id="gnome-tweaks">Gnome Tweaks<a hidden class="anchor" aria-hidden="true" href="#gnome-tweaks">#</a></h3>
<p>GNOME 桌面有称为“扩展”的小插件或附加组件，学会使用 GNOME 扩展来扩展系统的可用性。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install gnome-tweaks
</code></pre></div><p>同时会安装新的 GNOME Shell extensions，可以禁用桌面图标、Ubuntu Dock。可从浏览器安装 <a href="https://extensions.gnome.org/">GNOME Shell extensions</a>。</p>
<p>如 OpenWeather，需设置 Location，Units 为公制单位，Layout为Right</p>
<p>theme design: <a href="https://designmodo.com/flat-vs-material/">Skeuomorphism vs Flat Design vs Material Design</a></p>
<ul>
<li>主题目录： <code>/usr/share/themes</code> 或 <code>~/.themes</code></li>
<li>图标鼠标目录： <code>/usr/share/icons</code> 或 <code>~/.icons</code></li>
<li>壁纸： <code>/usr/share/background</code> , <code>/usr/share/wallpapers</code></li>
</ul>
<h4 id="ubuntu-dockhttpsblogcsdnneta6864657articledetails103606669"><a href="https://blog.csdn.net/a6864657/article/details/103606669/">Ubuntu Dock</a><a hidden class="anchor" aria-hidden="true" href="#ubuntu-dockhttpsblogcsdnneta6864657articledetails103606669">#</a></h4>
<p>Ubuntu Dock 就是 Dash to Dock。安装：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt-get install  gnome-shell-extension-dashtodock
</code></pre></div><p>重启，在 Extension 中设置 Dash to Dock，Dash to Dock 与 Ubuntu Dock 只能开启一个，否则有两个 Dock，但是就算关闭 Dash to Dock，Dash to Dock 设置依旧起作用到 Ubuntu Dock。</p>
<p>重新登录。</p>
<h4 id="kde-connecthttpskdeconnectkdeorggsconnecthttpsgithubcomgsconnectgnome-shell-extension-gsconnect"><a href="https://kdeconnect.kde.org/">KDE Connect</a>/<a href="https://github.com/GSConnect/gnome-shell-extension-gsconnect">GSConnect</a><a hidden class="anchor" aria-hidden="true" href="#kde-connecthttpskdeconnectkdeorggsconnecthttpsgithubcomgsconnectgnome-shell-extension-gsconnect">#</a></h4>
<p>Files and links. Shared between devices.</p>
<h4 id="netspeedhttpsextensionsgnomeorgextension104netspeed"><a href="https://extensions.gnome.org/extension/104/netspeed/">NetSpeed</a><a hidden class="anchor" aria-hidden="true" href="#netspeedhttpsextensionsgnomeorgextension104netspeed">#</a></h4>
<p>Displays Internet Speed</p>
<h4 id="clipboard-indicatorhttpsextensionsgnomeorgextension779clipboard-indicator"><a href="https://extensions.gnome.org/extension/779/clipboard-indicator/">Clipboard Indicator</a><a hidden class="anchor" aria-hidden="true" href="#clipboard-indicatorhttpsextensionsgnomeorgextension779clipboard-indicator">#</a></h4>
<p>Clipboard Manager extension for Gnome-Shell - Adds a clipboard indicator to the top panel, and caches clipboard history.</p>
<h4 id="coverflow-alt-tabhttpsextensionsgnomeorgextension97coverflow-alt-tab"><a href="https://extensions.gnome.org/extension/97/coverflow-alt-tab/">Coverflow Alt-Tab</a><a hidden class="anchor" aria-hidden="true" href="#coverflow-alt-tabhttpsextensionsgnomeorgextension97coverflow-alt-tab">#</a></h4>
<p>Replacement of Alt-Tab, iterates through windows in a cover-flow manner.</p>
<h4 id="bluetooth-quick-connecthttpsextensionsgnomeorgextension1401bluetooth-quick-connect"><a href="https://extensions.gnome.org/extension/1401/bluetooth-quick-connect/">Bluetooth Quick Connect</a><a hidden class="anchor" aria-hidden="true" href="#bluetooth-quick-connecthttpsextensionsgnomeorgextension1401bluetooth-quick-connect">#</a></h4>
<p>Allow to connect to paired devices from gnome control panel.</p>
<h4 id="desktop-icons-ng-dinghttpsextensionsgnomeorgextension2087desktop-icons-ng-ding"><a href="https://extensions.gnome.org/extension/2087/desktop-icons-ng-ding/">Desktop Icons NG (DING)</a><a hidden class="anchor" aria-hidden="true" href="#desktop-icons-ng-dinghttpsextensionsgnomeorgextension2087desktop-icons-ng-ding">#</a></h4>
<p>with these advantages:</p>
<ul>
<li>Drag&rsquo;n&rsquo;Drop, both inside the desktop, between desktop and applications, and nautilus windows</li>
<li>Allows to use &ldquo;Open with&hellip;&rdquo; option with several files</li>
<li>When hovering or clicking on an icon with a name too large to fit, it shows the full name</li>
<li>Doesn&rsquo;t hang the compositor when there is too much activity in the desktop folder</li>
</ul>
<h4 id="frippery-move-clockhttpsextensionsgnomeorgextension2move-clock"><a href="https://extensions.gnome.org/extension/2/move-clock/">Frippery Move Clock</a><a hidden class="anchor" aria-hidden="true" href="#frippery-move-clockhttpsextensionsgnomeorgextension2move-clock">#</a></h4>
<p>Move clock to left of status menu button</p>
<h4 id="input-method-panelhttpsextensionsgnomeorgextension261kimpanel"><a href="https://extensions.gnome.org/extension/261/kimpanel/">Input Method Panel</a><a hidden class="anchor" aria-hidden="true" href="#input-method-panelhttpsextensionsgnomeorgextension261kimpanel">#</a></h4>
<p>Input Method Panel using KDE&rsquo;s kimpanel protocol for Gnome-Shell</p>
<h4 id="lock-keyshttpsextensionsgnomeorgextension36lock-keys"><a href="https://extensions.gnome.org/extension/36/lock-keys/">Lock Keys</a><a hidden class="anchor" aria-hidden="true" href="#lock-keyshttpsextensionsgnomeorgextension36lock-keys">#</a></h4>
<p>Numlock &amp; Capslock status on the panel</p>
<h4 id="openweatherhttpsextensionsgnomeorgextension750openweather"><a href="https://extensions.gnome.org/extension/750/openweather/">OpenWeather</a><a hidden class="anchor" aria-hidden="true" href="#openweatherhttpsextensionsgnomeorgextension750openweather">#</a></h4>
<p>Weather extension to display weather information from <a href="https://openweathermap.org/">https://openweathermap.org/</a> or <a href="https://darksky.net">https://darksky.net</a> for almost all locations in the world.</p>
<h4 id="panel-date-formathttpsextensionsgnomeorgextension1462panel-date-format"><a href="https://extensions.gnome.org/extension/1462/panel-date-format/">Panel Date Format</a><a hidden class="anchor" aria-hidden="true" href="#panel-date-formathttpsextensionsgnomeorgextension1462panel-date-format">#</a></h4>
<p>Allows to customize the date format on the panel.</p>
<h4 id="refresh-wifi-connectionshttpsextensionsgnomeorgextension905refresh-wifi-connections"><a href="https://extensions.gnome.org/extension/905/refresh-wifi-connections/">Refresh Wifi Connections</a><a hidden class="anchor" aria-hidden="true" href="#refresh-wifi-connectionshttpsextensionsgnomeorgextension905refresh-wifi-connections">#</a></h4>
<p>This extension adds a refresh button to the Wi-Fi connection selection dialog to manually request for a network scan.</p>
<h4 id="screenshot-toolhttpsextensionsgnomeorgextension1112screenshot-tool"><a href="https://extensions.gnome.org/extension/1112/screenshot-tool/">Screenshot Tool</a><a hidden class="anchor" aria-hidden="true" href="#screenshot-toolhttpsextensionsgnomeorgextension1112screenshot-tool">#</a></h4>
<p>Conveniently create, copy, store and upload screenshots. Please log out and log in again after updating.</p>
<h4 id="sound-input--output-device-chooserlivepatchhttpsextensionsgnomeorgextension906sound-output-device-chooser"><a href="https://extensions.gnome.org/extension/906/sound-output-device-chooser/">Sound Input &amp; Output Device ChooserLivepatch</a><a hidden class="anchor" aria-hidden="true" href="#sound-input--output-device-chooserlivepatchhttpsextensionsgnomeorgextension906sound-output-device-chooser">#</a></h4>
<p>Shows a list of sound output and input devices (similar to gnome sound settings) in the status menu below the volume slider.</p>
<h4 id="status-area-horizontal-spacinghttpsextensionsgnomeorgextension355status-area-horizontal-spacing"><a href="https://extensions.gnome.org/extension/355/status-area-horizontal-spacing/">Status Area Horizontal Spacing</a><a hidden class="anchor" aria-hidden="true" href="#status-area-horizontal-spacinghttpsextensionsgnomeorgextension355status-area-horizontal-spacing">#</a></h4>
<p>Reduce the horizontal spacing between icons in the top-right status area</p>
<h4 id="unitehttpsextensionsgnomeorgextension1287unite"><a href="https://extensions.gnome.org/extension/1287/unite/">Unite</a><a hidden class="anchor" aria-hidden="true" href="#unitehttpsextensionsgnomeorgextension1287unite">#</a></h4>
<p>Unite is a GNOME Shell extension which makes a few layout tweaks to the top panel and removes window decorations to make it look like Ubuntu Unity Shell.</p>
<h4 id="user-themeshttpsextensionsgnomeorgextension19user-themes"><a href="https://extensions.gnome.org/extension/19/user-themes/">User Themes</a><a hidden class="anchor" aria-hidden="true" href="#user-themeshttpsextensionsgnomeorgextension19user-themes">#</a></h4>
<p>Load shell themes from user directory.</p>
<h4 id="vitalshttpsextensionsgnomeorgextension1460vitals"><a href="https://extensions.gnome.org/extension/1460/vitals/">Vitals</a><a hidden class="anchor" aria-hidden="true" href="#vitalshttpsextensionsgnomeorgextension1460vitals">#</a></h4>
<p>A glimpse into your computer&rsquo;s temperature, voltage, fan speed, memory usage, processor load, system resources, network speed and storage stats. This is a one stop shop to monitor all of your vital sensors. Uses asynchronous polling to provide a smooth user experience.</p>
<h4 id="papirus-icon-themehttpsgithubcompapirusdevelopmentteampapirus-icon-theme"><a href="https://github.com/PapirusDevelopmentTeam/papirus-icon-theme">Papirus Icon Theme</a><a hidden class="anchor" aria-hidden="true" href="#papirus-icon-themehttpsgithubcompapirusdevelopmentteampapirus-icon-theme">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo add-apt-repository ppa:papirus/papirus
$ sudo apt-get update
$ sudo apt-get install papirus-icon-theme
</code></pre></div><h4 id="materia-themehttpsgithubcomnana-4materia-theme"><a href="https://github.com/nana-4/materia-theme">Materia Theme</a><a hidden class="anchor" aria-hidden="true" href="#materia-themehttpsgithubcomnana-4materia-theme">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install materia-gtk-theme
</code></pre></div><h3 id="chromehttpswwwgooglecomlinuxrepositories"><a href="https://www.google.com/linuxrepositories/">Chrome</a><a hidden class="anchor" aria-hidden="true" href="#chromehttpswwwgooglecomlinuxrepositories">#</a></h3>
<p><strong><a href="https://www.makeuseof.com/import-passwords-into-chrome/">Import Passwords</a></strong></p>
<ol>
<li>Launch Chrome on your computer.</li>
<li>Type the following in the address bar and pressEnter: <code>chrome://flags</code></li>
<li>On the flags screen, put your cursor in the search box and type <strong>Password import</strong>.</li>
<li>You should see the <strong>Password import</strong> flag in the search results.</li>
<li>To enable this flag, click the dropdown menu next to the flag and select Enabled.</li>
<li>Click <strong>Relaunch</strong> at the bottom to relaunch Chrome. This will restore all of your open tabs.</li>
<li>When Chrome opens, click the three dots in the top-right corner, and select <strong>Settings</strong> &gt; <strong>Passwords</strong> on the following screen.</li>
<li>Click the three dots next to Saved Passwords and select Import.</li>
<li>Navigate to your CSV passwords file and select it to import it into Chrome.</li>
</ol>
<h4 id="tampermonkeyhttpsgreasyforkorgzh-cn"><a href="https://greasyfork.org/zh-CN">Tampermonkey</a><a hidden class="anchor" aria-hidden="true" href="#tampermonkeyhttpsgreasyforkorgzh-cn">#</a></h4>
<p>提供用户脚本</p>
<ul>
<li><a href="https://greasyfork.org/zh-CN/scripts/397419-fastgithub-%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AE-%E5%85%8B%E9%9A%86%E5%92%8C%E4%B8%8B%E8%BD%BD">FastGithub 镜像加速访问、克隆和下载</a></li>
<li><a href="https://greasyfork.org/zh-CN/scripts/405130-%E6%96%87%E6%9C%AC%E9%80%89%E4%B8%AD%E5%A4%8D%E5%88%B6">文本选中复制</a>：解除网站不允许复制的限制，文本选中后点击复制按钮即可复制，主要用于 百度文库 道客巴巴 无忧考网 学习啦 蓬勃范文 思否社区 力扣 知乎 语雀 等</li>
<li><a href="https://greasyfork.org/zh-CN/scripts/424574-%E7%A7%92%E4%BC%A0%E9%93%BE%E6%8E%A5%E6%8F%90%E5%8F%96">秒传链接提取</a>：用于提取和生成百度网盘秒传链接</li>
<li><a href="https://greasyfork.org/zh-CN/scripts/419081-%E7%9F%A5%E4%B9%8E%E5%A2%9E%E5%BC%BA">知乎增强</a>：移除登录弹窗</li>
<li><a href="https://greasyfork.org/zh-CN/scripts/396310-%E7%BD%91%E9%A1%B5%E5%A4%8D%E5%88%B6%E9%99%90%E5%88%B6%E8%A7%A3%E9%99%A4">网页复制限制解除</a></li>
</ul>
<h4 id="download-all-images">Download All Images<a hidden class="anchor" aria-hidden="true" href="#download-all-images">#</a></h4>
<p>下载网页所有图片</p>
<h4 id="ublock-origin">uBlock Origin<a hidden class="anchor" aria-hidden="true" href="#ublock-origin">#</a></h4>
<p>禁广告</p>
<h4 id="沙拉查词httpssaladictcrimxcom"><a href="https://saladict.crimx.com/">沙拉查词</a><a hidden class="anchor" aria-hidden="true" href="#沙拉查词httpssaladictcrimxcom">#</a></h4>
<p>聚合词典专业划词翻译</p>
<h4 id="infinity-new-tabhttpschromegooglecomwebstoredetailinfinity-new-tabdbfmnekepjoapopniengjbcpnbljalfghlen-us"><a href="https://chrome.google.com/webstore/detail/infinity-new-tab/dbfmnekepjoapopniengjbcpnbljalfg?hl=en-US">Infinity New Tab</a><a hidden class="anchor" aria-hidden="true" href="#infinity-new-tabhttpschromegooglecomwebstoredetailinfinity-new-tabdbfmnekepjoapopniengjbcpnbljalfghlen-us">#</a></h4>
<p>Chrome Extension，解决 Chrome new tab 加载后会清空搜索栏问题</p>
<h4 id="questions">Questions<a hidden class="anchor" aria-hidden="true" href="#questions">#</a></h4>
<p><a href="https://askubuntu.com/questions/1078813/the-repository-http-dl-google-com-linux-chrome-deb-stable-release-does-not-h"><strong>The repository &lsquo;http://dl.google.com/linux/chrome/deb stable Release&rsquo; does not have a Release file</strong></a></p>
<p>The &ldquo;key&rdquo; is &ldquo;<strong>repository can&rsquo;t be authenticated</strong>&rdquo;</p>
<p>IMHO&hellip; you don&rsquo;t have the key of the repo</p>
<p>To solve that just use this command:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | sudo apt-key add -
</code></pre></div><h4 id="chromium">Chromium<a hidden class="anchor" aria-hidden="true" href="#chromium">#</a></h4>
<p><a href="https://en.wikipedia.org/wiki/Chromium_(web_browser)">Chromium</a> 是一款来自 &ldquo;The Chromium Project&rdquo; 的开源图形网络浏览器，基于 <a href="https://en.wikipedia.org/wiki/Blink_(web_engine)">Blink</a> 渲染引擎。它也是商业软件 Google Chrome 浏览器得以组成的基础。</p>
<p>在<a href="https://chromium.googlesource.com/chromium/src/+/master/docs/chromium_browser_vs_google_chrome.md">这里</a>你可以看到 Google Chrome 与 Chromium 浏览器的区别。此外，还有一点重要的不同：2021年3月2日发布的 Chromium 89 及其以后版本不再支持 Google 账户同步功能。</p>
<p><strong>注意：</strong> 目前，可以通过 <a href="https://gist.github.com/foutrelis/14e339596b89813aa9c37fd1b4e5d9d5">使用 Chrome 的OAuth2 凭证</a>或者 <a href="https://www.chromium.org/developers/how-tos/api-keys">申请一个属于自己的凭证</a>来恢复同步功能, 但是请注意，这不一定是一个长期的解决方案。长期来讲，最好考虑使用 <a href="https://www.xbrowsersync.org/">xbrowsersync</a> 来同步书签数据。</p>
<h4 id="firefox">Firefox<a hidden class="anchor" aria-hidden="true" href="#firefox">#</a></h4>
<p>主要用于 Firefox，安装媒体解码器来播放 MP3、MPEG4 和其他格式媒体文件。由于各个国家的版权问题， Ubuntu 在默认情况下不会安装它。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt-get install ubuntu-restricted-extras
</code></pre></div><p>这种方式会安装 .exe 程序，不如<a href="https://askubuntu.com/questions/384650/how-to-install-h-264-decoder">直接安装</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt-get install h264enc
</code></pre></div><h3 id="flameshothttpsflameshotorg"><a href="https://flameshot.org/">Flameshot</a><a hidden class="anchor" aria-hidden="true" href="#flameshothttpsflameshotorg">#</a></h3>
<p>Powerful, yet simple to use open-source screenshot software.</p>
<table>
<thead>
<tr>
<th>Keys</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>←, ↓, ↑, →</td>
<td>Move selection 1px</td>
</tr>
<tr>
<td>Shift + ←, ↓, ↑, →</td>
<td>Resize selection 1px</td>
</tr>
<tr>
<td>Esc</td>
<td>Quit capture</td>
</tr>
<tr>
<td>Ctrl + C</td>
<td>Copy to clipboard</td>
</tr>
<tr>
<td>Ctrl + S</td>
<td>Save selection as a file</td>
</tr>
<tr>
<td>Ctrl + Z</td>
<td>Undo the last modification</td>
</tr>
<tr>
<td>Right Click</td>
<td>Show color picker</td>
</tr>
<tr>
<td>Mouse Wheel</td>
<td>Change the tool&rsquo;s thickness</td>
</tr>
</tbody>
</table>
<p><a href="https://flameshot.org/docs/guide/key-bindings/">Add a new Shortcuts</a></p>
<ul>
<li>On &lsquo;Name&rsquo;, name it &lsquo;<code>Flameshot</code>&rsquo;</li>
<li>Define the command as &lsquo;<code>flameshot gui</code>&rsquo;.</li>
<li>Select &lsquo;Define shortcut&hellip;&lsquo;and click your keyboard <code>win</code> + <code>shift</code> + <code>Prt Sc</code> key.</li>
</ul>
<h3 id="ppsspphttpsapkcabalcomngbest-ppsspp-settings"><a href="https://apkcabal.com.ng/best-ppsspp-settings/">PPSSPP</a><a hidden class="anchor" aria-hidden="true" href="#ppsspphttpsapkcabalcomngbest-ppsspp-settings">#</a></h3>
<p>A PSP emulator.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo add-apt-repository ppa:ppsspp/stable
$ sudo apt-get update
$ sudo apt install ppsspp
</code></pre></div><p>Graphics:</p>
<ul>
<li>Rendering Mode
<ul>
<li>set the <strong>Backend</strong> from OpenGL to Vulkan.</li>
</ul>
</li>
<li>Framework Control
<ul>
<li><strong>Frameskipping</strong> is Off</li>
<li><strong>Auto-Frameskip</strong> is Off</li>
<li>set the <strong>Alternative Speed</strong> to Unlimited</li>
</ul>
</li>
<li>Postprocessing effects
<ul>
<li><strong>Postprocessing shader</strong> should be off.</li>
</ul>
</li>
<li>Performance
<ul>
<li>If your Device is Powerful, high rendering resolution will work. Its recommended to first try with <strong>2x Rendering resolution</strong> as It brings impressive graphics and supports stable gameplay too</li>
<li><strong>Hardware transform</strong>, <strong>Software skinning</strong>, <strong>Vertex cache</strong> and <strong>Lazy texture caching</strong> should be checked.</li>
<li><strong>Retain changed textures</strong> should be unchecked while keeping Disable <strong>slower effects</strong> and <strong>Hardware Installation</strong> checked.</li>
</ul>
</li>
<li>Overlay Information
<ul>
<li>Select FPS in <strong>Show FPS counter</strong>.</li>
</ul>
</li>
</ul>
<p>System:</p>
<ul>
<li>Make sure <strong>Fast memory</strong> is checked</li>
<li>Set <strong>I/O timing method</strong>, to Simulate UMD delays or Fast</li>
</ul>
<h3 id="yuzuhttpswwwbilibilicomreadcv4973631"><a href="https://www.bilibili.com/read/cv4973631">yuzu</a><a hidden class="anchor" aria-hidden="true" href="#yuzuhttpswwwbilibilicomreadcv4973631">#</a></h3>
<p><a href="https://yuzu-emu.org/">yuzu</a> 是 <code>Citra</code>的制作者写的一个开源<code>NS</code>模拟器，用<code>C++</code>编写，特点包括<code>Vulkan API</code>的支持、灵活的模拟器配置以及游戏配置等等。</p>
<p>玩了 super mario odyssey，过场动画很卡顿，可以软配置的很少，主要看硬件配置，我的配置玩 BOTW 是不可能了。</p>
<h4 id="安装-2">安装<a hidden class="anchor" aria-hidden="true" href="#安装-2">#</a></h4>
<ul>
<li>
<p>选择 File -&gt; Open yuzu Folder</p>
</li>
<li>
<p>在打开的目录下，新建keys文件夹（如果没有），然后进入keys文件夹，放入key文件prod.keys，内容如下</p>
<pre tabindex="0"><code>aes_kek_generation_source = 4d870986c45d20722fba1053da92e8a9
aes_key_generation_source = 89615ee05c31b6805fe58f3da24f7aa8
bis_kek_source = 34c1a0c48258f8b4fa9e5e6adafc7e4f
bis_key_00 = 374e0e2ab275141f811badcb0fefd881b71d6af540de58895901aa0c01663bc8
bis_key_01 = 0b08f19a42ac5ae590b3373ad9698344a571f35165663536dae0842b5221b31c
bis_key_02 = 38f0936f33bacedc0c0a159ffbbeee0f40bb08386915bdd0c6730349b99081ec
bis_key_03 = 38f0936f33bacedc0c0a159ffbbeee0f40bb08386915bdd0c6730349b99081ec
bis_key_source_00 = f83f386e2cd2ca32a89ab9aa29bfc7487d92b03aa8bfdee1a74c3b6e35cb7106
bis_key_source_01 = 41003049ddccc065647a7eb41eed9c5f44424edab49dfcd98777249adc9f7ca4
bis_key_source_02 = 52c2e9eb09e3ee2932a10c1fb6a0926c4d12e14b2a474c1c09cb0359f015f4e4
device_key = bd16c45b2647d842c5ee3c869e3a9607
device_key_4x = 2078900c6bb36fff1fdad57a7dd1b66e
eticket_rsa_kek = 19c8b441d318802bad63a5beda283a84
eticket_rsa_kek_source = dba451124ca0a9836814f5ed95e3125b
eticket_rsa_kekek_source = 466e57b74a447f02f321cde58f2f5535
header_kek_source = 1f12913a4acbf00d4cde3af6d523882a
header_key = aeaab1ca08adf9bef12991f369e3c567d6881e4e4a6a47a51f6e4877062d542d
header_key_source = 5a3ed84fdec0d82631f7e25d197bf5d01c9b7bfaf628183d71f64d73f150b9d2
key_area_key_application_00 = ef979e289a132c23d39c4ec5a0bba969
key_area_key_application_01 = cdedbab97b69729073dfb2440bff2c13
key_area_key_application_02 = 75716ed3b524a01dfe21456ce26c7270
key_area_key_application_03 = f428306544cf5707c25eaa8bc0583fd1
key_area_key_application_04 = 798844ec099eb6a04b26c7c728a35a4d
key_area_key_application_05 = a57c6eecc5410ada22712eb3ccbf45f1
key_area_key_application_06 = 2a60f6c4275df1770651d5891b8e73ec
key_area_key_application_07 = 32221bd6ed19b938bec06b9d36ed9e51
key_area_key_application_08 = fb20aa9e3dbf67350e86479eb431a0b3
key_area_key_application_09 = ce8d5fa79e220d5f48470e9f21be018b
key_area_key_application_0a = 38b865725adcf568a81d2db3ceaa5bcc
key_area_key_application_0b = bbddfd40a59d0ff555c0954239972213
key_area_key_application_0c = 3fee7204e21c6b0ff1373226c0c3e055
key_area_key_application_source = 7f59971e629f36a13098066f2144c30d
key_area_key_ocean_00 = b33813e4c9c4399c75fabc673ab4947b
key_area_key_ocean_01 = c54166efa8c9c0f6511fa8b580191677
key_area_key_ocean_02 = 3061ce73461e0b0409d6a33da85843c8
key_area_key_ocean_03 = 06f170025a64921c849df168e74d37f2
key_area_key_ocean_04 = dc857fd6dc1c6213076ec7b902ec5bb6
key_area_key_ocean_05 = 131d76b70bd8a60036d8218c15cb610f
key_area_key_ocean_06 = 17d565492ba819b0c19bed1b4297b659
key_area_key_ocean_07 = 37255186f7678324bf2b2d773ea2c412
key_area_key_ocean_08 = 4115c119b7bd8522ad63c831b6c816a6
key_area_key_ocean_09 = 792bfc652870cca7491d1685384be147
key_area_key_ocean_0a = dfcc9e87e61c9fba54a9b1c262d41e4d
key_area_key_ocean_0b = 66fe3107f5a6a8d8eda2459d920b07a1
key_area_key_ocean_0c = b79b6bf3d6cdc5ec10277fc07a4fec93
key_area_key_ocean_source = 327d36085ad1758dab4e6fbaa555d882
key_area_key_system_00 = 6dd02aa15b440d6231236b6677de86bc
key_area_key_system_01 = 4ab155e7f29a292037fd147592770b12
key_area_key_system_02 = b7a74adeaf89c2a198c327bdff322d7d
key_area_key_system_03 = d5aab1acd23a8aec284a316df859d377
key_area_key_system_04 = 9b44b45b37de9d14754b1d22c2ca742c
key_area_key_system_05 = 0012e957530d3dc7af34fbbe6fd44559
key_area_key_system_06 = 01744e3b0818445cd54ee9f89da43192
key_area_key_system_07 = d0d30e46f5695b875f11522c375c5a80
key_area_key_system_08 = bd06cb1b86bd5c433667470a09eb63de
key_area_key_system_09 = e19f788f658eda8bbf34a1dd2a9503a9
key_area_key_system_0a = 7070e7ff5cfe448630143a9874903c38
key_area_key_system_0b = 3fa471d4483e58b8f7756fcb64f63890
key_area_key_system_0c = 7bfd381df3369407ab1c6bdd9fabf522
key_area_key_system_source = 8745f1bba6be79647d048ba67b5fda4a
keyblob_00 = f759024f8199101dddc1ef91e6eecf37e24b95ac9272f7ae441d5d8060c843a48322d21cdd06d4fc958c68d3800eb4db939ffbec930177f77d136144ff615aa8835e811bb958deda218f8486b5a10f531b30cb9d269645ac9fc25c53fc80525e56bd3602988a9fcf06bbf99ca910ad6530791d512c9d57e17abf49220de6419bf4eca1685c1e4df77f19db7b44a985ca
keyblob_01 = bd27264ae07e979756411d0c66e679e3c50851f3e902d9c2cd1a438b948159a517ec1566c10570326ea2697ee62da46f14bb5d581bfc06fd0c9387ea33d2d4dc63e7809ba90f03dd2c7112ffbfa548951b9b8c688b5e4f2951d24a73da29c668154a5d4838dba71ee068ace83fe720e8c2a495c596f73525dc3c05994b40ad27f8c60322f75cd548b821af9162e16f76
keyblob_02 = a3d4a8e153b8e6ae6e6aef3e8f219cb4b7790f47856accc76268f9afa99a1ff8b1a72f63d1f99f480a3c1532078bb59abdd25203cfb12a38b33e9ba6a09afb6f24283b3ba76a0161230a73669ddf5493c2b7919d094fd795b484794854f71e4f4c672245d7770e29397722444d111b4229cdbf35707b70634ea8f140766e884cc580cb1e2d9aa9866ffef920010fc409
keyblob_03 = 1558f525ae8c5be9243fb6d8a8b0a8ee0e886a59035668740a936619b7a5c83e821198b171d18e51445054df68688e45703b936818a827d8e540dd6bef2e11ec9ddc6cfe5fc736dd769b9f6e0a23a62e2e5f49e86143646a04ec3a23f828373a336a5c224a91f8a0c6c6a7b5844dd6415804209f83c943aeca9cfd856db6bd4ec32009c8cb268ed053052c9237dfd8bc
keyblob_04 = 9fbeb1957fc1629e08b753a9086d6e01ffb4f11466b7417e3fa7f5f1efb754406704fd75afaf91a408a0b524c1fc80d36c2046fa4757412efe4c11e382f72e8a10d90ed580017d9deb87af2549b6b02661af48ff94f6072c0fef7fc2833b8bdae503898e2e927ac0663e8b6391dd4f1d685313935e2c48ece7d177c88bc9c883ede36c3677495784b838d7265c6ba7a1
keyblob_05 = 94a92da1d73c2b3e165c891ced5607fc6628ca2a0654f3fbc05711c063377c6e9c96a9d0192e530dd510e4fd41aa62ef4213c5f6e059e7e21db098a9b22d1e6c29bee148aaef15c52549d9165de96e85b0d029ecdc5843e2f32cb18be707eec61909cf3385d45bc2a4c8d76e9bfad5a40c4b92dcb982aa50d474897ac9ebb5351a7015dcc277a08f1214ad41384d7941
keyblob_key_00 = 839944c8a38df6791020b38147e906b0
keyblob_key_01 = b9e6fbde828b5f42c897ade8fd14c625
keyblob_key_02 = b6988a0795d294ef522908692d5db7ca
keyblob_key_03 = 0e57d7777171d125d3fe3af5b397d009
keyblob_key_04 = b55a282d698fabeb4e03c67ff2026bc5
keyblob_key_05 = fdb542c1f1bdf134ec20b1fda02bc9e1
keyblob_key_source_00 = df206f594454efdc7074483b0ded9fd3
keyblob_key_source_01 = 0c25615d684ceb421c2379ea822512ac
keyblob_key_source_02 = 337685ee884aae0ac28afd7d63c0433b
keyblob_key_source_03 = 2d1f4880edeced3e3cf248b5657df7be
keyblob_key_source_04 = bb5a01f988aff5fc6cff079e133c3980
keyblob_key_source_05 = d8cce1266a353fcc20f32d3b517de9c0
keyblob_mac_key_00 = 604422526723e541a849fa4c18660e0b
keyblob_mac_key_01 = 279481456b1dc259d35599e6392e01e5
keyblob_mac_key_02 = dbbfb8096b676c2a54b5d9c61b423a94
keyblob_mac_key_03 = 48b7aef6d9b1edb132b8901a245a7750
keyblob_mac_key_04 = 544c082e9f8602c736dc0732d4319f88
keyblob_mac_key_05 = a540ec8ba84bd31eaaa9ce9f95226875
keyblob_mac_key_source = 59c7fb6fbe9bbe87656b15c0537336a5
mariko_master_kek_source_05 = 77605ad2ee6ef83c3f72e2599dac5e56
mariko_master_kek_source_06 = 1e80b8173ec060aa11be1a4aa66fe4ae
mariko_master_kek_source_07 = 940867bd0a00388411d31adbdd8df18a
mariko_master_kek_source_08 = 5c24e3b8b4f700c23cfd0ace13c3dc23
mariko_master_kek_source_09 = 8669f00987c805aeb57b4874de62a613
mariko_master_kek_source_0a = 0e440cedb436c03faa1daebf62b10982
mariko_master_kek_source_0b = e541acecd1a7d1abed0377f127caf8f1
mariko_master_kek_source_0c = 52719bdfa78b61d8d58511e48e4f74c6
master_kek_00 = f759024f8199101dddc1ef91e6eecf37
master_kek_01 = bd27264ae07e979756411d0c66e679e3
master_kek_02 = a3d4a8e153b8e6ae6e6aef3e8f219cb4
master_kek_03 = 1558f525ae8c5be9243fb6d8a8b0a8ee
master_kek_04 = 9fbeb1957fc1629e08b753a9086d6e01
master_kek_05 = 94a92da1d73c2b3e165c891ced5607fc
master_kek_08 = e42f1ec8002043d746575ae6dd9f283f
master_kek_09 = cec2885fbeef5f6a989db84a4cc4b393
master_kek_0a = dd1a730232522b5cb4590cd43869ab6a
master_kek_0b = fc6f0c891d42710180724ed9e112e72a
master_kek_0c = 43f7fc20fcec22a5b2a744790371b094
master_kek_source_06 = 374b772959b4043081f6e58c6d36179a
master_kek_source_07 = 9a3ea9abfd56461c9bf6487f5cfa095c
master_kek_source_08 = dedce339308816f8ae97adec642d4141
master_kek_source_09 = 1aec11822b32387a2bedba01477e3b67
master_kek_source_0a = 303f027ed838ecd7932534b530ebca7a
master_kek_source_0b = 8467b67f1311aee6589b19af136c807a
master_kek_source_0c = 683bca54b86f9248c305768788707923
master_key_00 = c2caaff089b9aed55694876055271c7d
master_key_01 = 54e1b8e999c2fd16cd07b66109acaaa6
master_key_02 = 4f6b10d33072af2f250562bff06b6da3
master_key_03 = 84e04ec20b9373818c540829cf147f3d
master_key_04 = cfa2176790a53ff74974bff2af180921
master_key_05 = c1dbedcebf0dd6956079e506cfa1af6e
master_key_06 = 0aa90e6330cdc12d819b3254d11a4e1e
master_key_07 = 929f86fbfe4ef7732892bf3462511b0e
master_key_08 = 23cfb792c3cb50cd715da0f84880c877
master_key_09 = 75c93b716255319b8e03e14c19dea64e
master_key_0a = 73767484c73088f629b0eeb605f64aa6
master_key_0b = 8500b14bf4766b855a26ffc614097a8f
master_key_0c = b3c503709135d4b35de31be4b0b9c0f7
master_key_source = d8a2410ac6c59001c61d6a267c513f3c
package1_key_00 = f4eca1685c1e4df77f19db7b44a985ca
package1_key_01 = f8c60322f75cd548b821af9162e16f76
package1_key_02 = c580cb1e2d9aa9866ffef920010fc409
package1_key_03 = c32009c8cb268ed053052c9237dfd8bc
package1_key_04 = ede36c3677495784b838d7265c6ba7a1
package1_key_05 = 1a7015dcc277a08f1214ad41384d7941
package2_key_00 = a35a19cb14404b2f4460d343d178638d
package2_key_01 = a0dd1eacd438610c85a191f02c1db8a8
package2_key_02 = 7e5ba2aafd57d47a85fd4a57f2076679
package2_key_03 = bf03e9889fa18f0d7a55e8e9f684323d
package2_key_04 = 09df6e361e28eb9c96c9fa0bfc897179
package2_key_05 = 444b1a4f9035178b9b1fe262462acb8e
package2_key_06 = 442cd9c21cfb8914587dc12e8e7ed608
package2_key_07 = 70c821e7d6716feb124acbac09f7b863
package2_key_08 = 8accebcc3d15a328a48365503f8369b6
package2_key_09 = f562a7c6c42e3d4d3d13ffd504d77346
package2_key_0a = 0803167ec7fc0bc753d8330e5592a289
package2_key_0b = 341db6796aa7bdb8092f7aae6554900a
package2_key_0c = 4e97dc4225d00c6ae33d49bddd17637d
package2_key_source = fb8b6a9c7900c849efd24d854d30a0c7
per_console_key_source = 4f025f0eb66d110edc327d4186c2f478
retail_specific_aes_key_source = e2d6b87a119cb880e822888a46fba195
rsa_oaep_kek_generation_source = a8ca938434127fda82cc1aa5e807b112
rsa_private_kek_generation_source = ef2cb61a56729b9157c38b9316784ddd
save_mac_kek_source = d89c236ec9124e43c82b038743f9cf1b
save_mac_key = 71a917f1bac8f4f04d732e734c90e2ec
save_mac_key_source = e4cd3d4ad50f742845a487e5a063ea1f
save_mac_sd_card_kek_source = 0489ef5d326e1a59c4b7ab8c367aab17
save_mac_sd_card_key_source = 6f645947c56146f9ffa045d595332918
sd_card_custom_storage_key_source = 370c345e12e4cefe21b58e64db52af354f2ca5a3fc999a47c03ee004485b2fd0
sd_card_kek_source = 88358d9c629ba1a00147dbe0621b5432
sd_card_nca_key_source = 5841a284935b56278b8e1fc518e99f2b67c793f0f24fded075495dca006d99c2
sd_card_save_key_source = 2449b722726703a81965e6e3ea582fdd9a951517b16e8f7f1f68263152ea296a
sd_seed = fdb479221c43741a118fb5475374d2f7
secure_boot_key = 208de9b9de94ff698d00657a6a82a973
ssl_rsa_kek = b011100660d1dccbad1b1b733afa9f95
ssl_rsa_kek_source_x = 7f5bb0847b25aa67fac84be23d7b6903
ssl_rsa_kek_source_y = 9a383bf431d0bd8132534ba964397de3
titlekek_00 = 62a24d6e6d0d0e0abf3554d259be3dc9
titlekek_01 = 8821f642176969b1a18021d2665c0111
titlekek_02 = 5d15b9b95a5739a0ac9b20f600283962
titlekek_03 = 1b3f63bcb67d4b06da5badc7d89acce1
titlekek_04 = e45c1789a69c7afbbf1a1e61f2499459
titlekek_05 = ddc67f7189f4527a37b519cb051eee21
titlekek_06 = b1532b9d38ab036068f074c0d78706ac
titlekek_07 = 81dc1b1783df268789a6a0edbf058343
titlekek_08 = 47dfe4bf0eeda88b17136b8005ab08ea
titlekek_09 = adaa785d90e1a9c182ac07bc276bf600
titlekek_0a = 42daa957c128f75bb1fda56a8387e17b
titlekek_0b = d08903363f2c8655d3de3ccf85d79406
titlekek_0c = be2682599db34caa9bc7ebb2cc7c654c
titlekek_source = 1edc7b3b60e6b4d878b81715985e629b
tsec_key = 53ec4ac7c6c32ff2abff3eeff4f84f36
tsec_root_key_02 = 4b4fbcf58e23cf4902d478b76c8048ec
</code></pre><p><code>yuzu</code>以及<code>Ryujinx</code>都需要<code>prod.keys</code>，里面包含了<code>NS</code>设备需要的<code>key</code>，需要通过<code> Hekate</code>等一些列工具生成。yuzu不需要单独安装固件，只要把key文件放好就可以启动游戏了。</p>
</li>
<li>
<p>关闭模拟器，重新打开 yuzu ，若没有弹窗，则配置成功</p>
</li>
</ul>
<h4 id="设置httpswwwjianshucompd55e015fbcb6"><a href="https://www.jianshu.com/p/d55e015fbcb6">设置</a><a hidden class="anchor" aria-hidden="true" href="#设置httpswwwjianshucompd55e015fbcb6">#</a></h4>
<p><strong>General</strong></p>
<p>确保勾选 Multicore CPU Emulation 和 Confirm exit while emulation is runing。</p>
<p>Limit Speed percent：游戏运行速度，默认即可，可加快或限速</p>
<p>Pause emulation when inbackground：退到后台模拟器暂停运行</p>
<p>Hide mouse inactivity：运行时鼠标隐藏</p>
<p>Prompt for user for game boot：游戏启动时选择哪个账户游玩</p>
<p><strong>Web</strong></p>
<p>yuzu web service：填了用户名和令牌以后可以向官网报告游戏兼容性</p>
<p>Telemetry：开了以后能让yuzu开发者查看你的使用情况，以便改善模拟器</p>
<p>Discord Presence：在discord中显示你的游戏状态</p>
<p><strong>系统</strong></p>
<p>System 页面，Language 选择 Simplified Chinese，Region 选择 China。这个设置的是系统语言，很多游戏会根据系统语言自动切换游戏内显示的语言。当然前提是游戏本身包含中文，如果游戏本身无中文只能通过打补丁的方式显示中文。</p>
<p>Custom RTC：修改系统时间，可以触发某些游戏的特定彩蛋之类的功能。</p>
<p>RNG seed：随机数种子，一般情况别改改。</p>
<p>Profile Manager：这里可以改switch用户名称、头像。可以设置多个用户</p>
<p><strong>CPU</strong></p>
<p><strong>图形</strong></p>
<ul>
<li><code>API</code>设置：支持<code>OpenGL</code>和<code>Vulkan</code>。</li>
<li><code>Use disk shader cache</code>：磁盘着色器缓存，建议开启，这样就不用每次都重新编译，而是直接从磁盘加载到内存</li>
<li><code>Use asynchronous GPU emulation</code>：<code>GPU</code>异步模拟，<code>yuzu</code>重写了<code>GPU</code>显存管理器，加速了缓存机制，使得帧数得到明显提示，同时性能提升40%-400%（来自<code>BSoD Gaming</code>的测试数据）</li>
<li><code>Use NVDEC emulation</code>：<a href="https://yuzu-emu.org/entry/yuzu-nvdec-emulation/"><code>NVDEC</code></a>是一项硬件转码技术，能减少转码期间计算密集型任务中CPU的负担，这是<code>Nvidia</code>的一个技术，有了它，过场动画的播放会畅顺很多</li>
</ul>
<p><strong>Advanced</strong></p>
<ul>
<li><code>Accuracy Level</code>：即模拟器左下角状态栏的 GPU NORMAL。是处理图形绘制精确度，开启High可能会修复一些图形错误，但是速度可能会变慢，一般选默认Normal即可</li>
<li><code>Use Vysnc (OpenGL Only)</code>：开启垂直同步</li>
<li><code>Use Fast GPU time</code>： 使用GPU加速渲染</li>
<li><code>Anisotropic Filtering</code>：是各项异性过滤，是用来处理图形纹理错误的，可以选2x-16x</li>
</ul>
<p><strong>声音</strong></p>
<p>默认。</p>
<p><strong>控制</strong></p>
<p>连接手柄，选择该设备。</p>
<h4 id="管理">管理<a hidden class="anchor" aria-hidden="true" href="#管理">#</a></h4>
<p>游戏格式分为两种，.xci 格式和 .nsp 格式。简单一点说，.xci 格式是卡带版，.nsp 格式是数字版。因此基本上所有的 DLC 基本都是 .nsp 格式，但也有 .xci 里集成了 DLC 的情况。</p>
<p><strong>添加游戏</strong></p>
<p>双击模拟器中间，添加游戏目录，游戏目录也不要有中文。添加完就可以看到游戏了。</p>
<p><strong>安装Update和DLC</strong></p>
<p>选择File -&gt;Install Files to NAND&hellip;，选中 Update和DLC文件，Update 安装最新就行，DLC 需要全部安装（可以不按顺序）。</p>
<p><strong>安装 Mod</strong></p>
<p>Mod 用于修改游戏，如解决一些bug以及优化性能等。右键单击要为其添加模组的游戏。然后将整个mod文件夹粘贴到那里。你可以从 <a href="https://github.com/yuzu-emu/yuzu/wiki/Switch-Mods">Switch Mods</a> 获得一些基本的 yuzu 模组。</p>
<p>注意：您可以通过右键单击游戏并单击属性来检查您拥有的游戏模组。</p>
<p><strong>放入着色器缓存</strong></p>
<p>放入着色器缓存（shader cache）可以明显提升游戏的流畅性，建议找找<a href="https://emulation.gametechwiki.com/index.php/Shader_caches">别人的着色器缓存</a>。</p>
<p>具体放入步骤：右键某个游戏，选择打开可转移着色器缓存，即可弹出缓存所在文件夹，然后放入你下载的别人的缓存就行了，比如 vulkan.bin 和 opengl.bin</p>
<h3 id="rubickhttpsgithubcomrubickcenterrubick"><a href="https://github.com/rubickCenter/rubick">rubick</a><a hidden class="anchor" aria-hidden="true" href="#rubickhttpsgithubcomrubickcenterrubick">#</a></h3>
<p>基于 electron 的开源工具箱，自由集成丰富插件。</p>
<h4 id="utoolshttpsutools"><a href="https://u.tools/">uTools</a><a hidden class="anchor" aria-hidden="true" href="#utoolshttpsutools">#</a></h4>
<p>uTools 是一个极简、插件化的现代桌面软件，通过自由选配丰富的插件，打造得心应手的工具集合。</p>
<p>Goldendict通过快捷键（默认 <code>alt + space</code> ）就可以快速呼出这个搜索框。你可以往输入框内粘贴文本、图片、截图、文件、文件夹等等，能够处理此内容的插件也早已准备就绪，统一的设计风格和操作方式，助你高效的得到结果。</p>
<p>一旦你熟悉它后，能够为你节约大量时间，即用即走、不中断、无干扰，让你可以更加专注地改变世界。</p>
<h3 id="lifereahttpslzonedeliferea"><a href="https://lzone.de/liferea/">Liferea</a><a hidden class="anchor" aria-hidden="true" href="#lifereahttpslzonedeliferea">#</a></h3>
<p>Liferea is a web feed reader/news aggregator that brings together all of the content from your favorite subscriptions into a simple interface that makes it easy to organize and browse feeds. Its GUI is similar to a desktop mail/news client, with an embedded web browser.</p>
<h3 id="calibrehttpscalibre-ebookcom"><a href="https://calibre-ebook.com/">Calibre</a><a hidden class="anchor" aria-hidden="true" href="#calibrehttpscalibre-ebookcom">#</a></h3>
<p><strong>calibre is a powerful and easy to use e-book manager</strong>. Users say it’s <em>outstanding</em> and a <em>must-have</em>. It’ll allow you to do nearly everything and it takes things a step beyond normal e-book software. It’s also <strong>completely free</strong> and <em>open source</em> and great for both <strong>casual users</strong> and computer experts.</p>
<h3 id="ventoyhttpswwwventoynetcnindexhtml"><a href="https://www.ventoy.net/cn/index.html">Ventoy</a><a hidden class="anchor" aria-hidden="true" href="#ventoyhttpswwwventoynetcnindexhtml">#</a></h3>
<p>简单来说，Ventoy是一个制作可启动U盘的开源工具。</p>
<p>有了Ventoy你就无需反复地格式化U盘，你只需要把 ISO/WIM/IMG/VHD(x)/EFI 等类型的文件直接拷贝到U盘里面就可以启动了，无需其他操作。</p>
<h4 id="balenaetcherhttpsgithubcombalena-ioetcher"><a href="https://github.com/balena-io/etcher">balenaEtcher</a><a hidden class="anchor" aria-hidden="true" href="#balenaetcherhttpsgithubcombalena-ioetcher">#</a></h4>
<p>Supported Operating Systems</p>
<ul>
<li>Linux (most distros)</li>
<li>macOS 10.10 (Yosemite) and later</li>
<li>Microsoft Windows 7 and later</li>
</ul>
<h4 id="unetbootinhttpsgithubcomunetbootinunetbootin"><a href="https://github.com/unetbootin/unetbootin">UNetbootin</a><a hidden class="anchor" aria-hidden="true" href="#unetbootinhttpsgithubcomunetbootinunetbootin">#</a></h4>
<p>UNetbootin installs Linux/BSD distributions to a partition or USB drive</p>
<h4 id="woeusb-nghttpsgithubcomwoeusbwoeusb-ng"><a href="https://github.com/WoeUSB/WoeUSB-ng">WoeUSB-ng</a><a hidden class="anchor" aria-hidden="true" href="#woeusb-nghttpsgithubcomwoeusbwoeusb-ng">#</a></h4>
<p>WoeUSB-ng is a simple tool that enable you to create your own usb stick windows installer from an iso image or a real DVD. This is a rewrite of original WoeUSB.</p>
<h3 id="goldendicthttpgoldendictorg"><a href="http://goldendict.org/">GoldenDict</a><a hidden class="anchor" aria-hidden="true" href="#goldendicthttpgoldendictorg">#</a></h3>
<h3 id="timeshifthttpsgithubcomteejee2008timeshift"><a href="https://github.com/teejee2008/timeshift">Timeshift</a><a hidden class="anchor" aria-hidden="true" href="#timeshifthttpsgithubcomteejee2008timeshift">#</a></h3>
<p>System restore tool for Linux.</p>
<h3 id="todoisthttpssnapcraftioinstalltodoistubuntuinstall"><a href="https://snapcraft.io/install/todoist/ubuntu#install">Todoist</a><a hidden class="anchor" aria-hidden="true" href="#todoisthttpssnapcraftioinstalltodoistubuntuinstall">#</a></h3>
<h3 id="plankhttpslaunchpadnetplank"><a href="https://launchpad.net/plank">Plank</a><a hidden class="anchor" aria-hidden="true" href="#plankhttpslaunchpadnetplank">#</a></h3>
<p>Plank is meant to be the simplest dock on the planet.</p>
<h3 id="motrixhttpsgithubcomagalwoodmotrix"><a href="https://github.com/agalwood/Motrix">Motrix</a><a hidden class="anchor" aria-hidden="true" href="#motrixhttpsgithubcomagalwoodmotrix">#</a></h3>
<p>A full-featured download manager.</p>
<h3 id="steamhttpsstoresteampoweredcom"><a href="https://store.steampowered.com/">Steam</a><a hidden class="anchor" aria-hidden="true" href="#steamhttpsstoresteampoweredcom">#</a></h3>
<h3 id="yacreaderhttpsyacreadercom"><a href="https://yacreader.com/">YACReader</a><a hidden class="anchor" aria-hidden="true" href="#yacreaderhttpsyacreadercom">#</a></h3>
<h3 id="work_crawlerhttpsgithubcomkanasimiwork_crawler"><a href="https://github.com/kanasimi/work_crawler">work_crawler</a><a hidden class="anchor" aria-hidden="true" href="#work_crawlerhttpsgithubcomkanasimiwork_crawler">#</a></h3>
<p>Download comics novels</p>
<h3 id="dingtalkhttpsgithubcomnashaofudingtalk"><a href="https://github.com/nashaofu/dingtalk">dingtalk</a><a hidden class="anchor" aria-hidden="true" href="#dingtalkhttpsgithubcomnashaofudingtalk">#</a></h3>
<p>钉钉桌面版，基于electron和钉钉网页版开发</p>
<h3 id="howdyhttpsgithubcomboltgolthowdy"><a href="https://github.com/boltgolt/howdy">howdy</a><a hidden class="anchor" aria-hidden="true" href="#howdyhttpsgithubcomboltgolthowdy">#</a></h3>
<p>Windows Hello™ style facial authentication for Linux</p>
<h3 id="向日葵httpssunloginoraycom"><a href="https://sunlogin.oray.com/">向日葵</a><a hidden class="anchor" aria-hidden="true" href="#向日葵httpssunloginoraycom">#</a></h3>
<p>向日葵远程控制软件是一款免费的集远程控制电脑手机、远程桌面连接、远程开机、远程管理、支持内网穿透的一体化远程控制管理工具软件。</p>
<h3 id="keepassxchttpskeepassxcorg"><a href="https://keepassxc.org/">KeePassXC</a><a hidden class="anchor" aria-hidden="true" href="#keepassxchttpskeepassxcorg">#</a></h3>
<h2 id="cli-utilities">CLI Utilities<a hidden class="anchor" aria-hidden="true" href="#cli-utilities">#</a></h2>
<h3 id="ansiblehttpsansible-tranreadthedocsioenlatestindexhtml"><a href="https://ansible-tran.readthedocs.io/en/latest/index.html">Ansible</a><a hidden class="anchor" aria-hidden="true" href="#ansiblehttpsansible-tranreadthedocsioenlatestindexhtml">#</a></h3>
<p>安装Ansible之后,不需要启动或运行一个后台进程,或是添加一个数据库.只要在一台电脑(可以是一台笔记本)上安装好,就可以通过这台电脑管理一组远程的机器.在远程被管理的机器上,不需要安装运行任何软件,因此升级Ansible版本不会有太多问题.</p>
<h3 id="fdupeshttpsaskubuntucomquestions3865how-to-find-and-delete-duplicate-files"><a href="https://askubuntu.com/questions/3865/how-to-find-and-delete-duplicate-files">fdupes</a><a hidden class="anchor" aria-hidden="true" href="#fdupeshttpsaskubuntucomquestions3865how-to-find-and-delete-duplicate-files">#</a></h3>
<p>You can call it like <code>fdupes -r /dir/ect/ory</code> and it will print out a list of dupes. fdupes has also a <a href="http://netdial.caribe.net/~adrian2/fdupes.html">simple Homepage</a> and a <a href="http://en.wikipedia.org/wiki/Fdupes">Wikipedia article</a>, which lists some more programs.</p>
<h4 id="digikamhttpswwwdigikamorg"><a href="https://www.digikam.org/">digiKam</a><a hidden class="anchor" aria-hidden="true" href="#digikamhttpswwwdigikamorg">#</a></h4>
<p>可用于查找重复相片，然后根据需要删除重复内容。</p>
<h3 id="bypyhttpscdnjsdelivrnetghhoutianzebypymaster"><a href="https://cdn.jsdelivr.net/gh/houtianze/bypy@master/">bypy</a><a hidden class="anchor" aria-hidden="true" href="#bypyhttpscdnjsdelivrnetghhoutianzebypymaster">#</a></h3>
<p><code>bypy info</code> 认证特别慢，而授权码又只有10分钟，导致后面授权码过期 Heroku server 认证失败失败。</p>
<p>如此，可以通过手动认证。</p>
<ul>
<li>
<p>通过 <code>bypy -dv</code> 查看详细输出，得到 Full URL，如 <code>https://bypyoauth.herokuapp.com/auth?code=...&amp;bypy_version=1.7.2&amp;redirect_uri=oob</code>，在浏览器中打开，获得token。</p>
</li>
<li>
<p>将其放在 <code>~/.bypy/bypy.json</code> 中。</p>
</li>
</ul>
<p>源码仓库也有<a href="https://cdn.jsdelivr.net/gh/houtianze/bypy@master/bypy/test/configdir/">示例</a>。</p>
<p>我下载一个大文件，总共12G左右，已用了两个晚上，中途没关（由于不是立马就要的东西，就用时间换金钱了），一次看进度时，Terminal 就卡退了，重新运行后，bypy会继续上次下载，而不是重新开始（这样话太可怕了）。</p>
<h3 id="frphttpsgofrporg"><a href="https://gofrp.org/">FRP</a><a hidden class="anchor" aria-hidden="true" href="#frphttpsgofrporg">#</a></h3>
<p>frp 是一个专注于内网穿透的高性能的反向代理应用，支持 TCP、UDP、HTTP、HTTPS 等多种协议。可以将内网服务以安全、便捷的方式通过具有公网 IP 节点的中转暴露到公网。</p>
<p><strong><a href="http://www.senra.me/tag/%e5%86%85%e7%bd%91%e7%a9%bf%e9%80%8f/">其他内网穿透工具</a></strong></p>
<ul>
<li><a href="https://github.com/inconshreveable/ngrok">ngrok</a></li>
<li><a href="https://github.com/zerotier/ZeroTierOne">ZeroTier</a></li>
<li><a href="https://github.com/ntop/n2n">N2N</a></li>
<li><a href="https://github.com/vzex/dog-tunnel">Dog Tunnel</a></li>
<li><a href="https://github.com/gsliepen/tinc">Tinc</a></li>
</ul>
<h3 id="git">Git<a hidden class="anchor" aria-hidden="true" href="#git">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ vi .gitignore_default
$ vi .auto-git.sh
<span style="color:#75715e">#!/bin/bash</span>
TIME<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span><span style="color:#66d9ef">$(</span>date <span style="color:#e6db74">&#39;+%Y%m%d%H%M%S&#39;</span><span style="color:#66d9ef">)</span><span style="color:#e6db74">&#34;</span>

echo <span style="color:#e6db74">&#39;###SakamotoKuromeSource###&#39;</span>
/bin/bash $HOME/Documents/SakamotoKuromeSource/deploy.sh

echo <span style="color:#e6db74">&#39;###vNotebook###&#39;</span>
cd $HOME/Documents/vNotebook
git pull
echo <span style="color:#e6db74">&#39;#Tree DataOne&#39;</span>
echo <span style="color:#e6db74">&#39;#Ignore files larger than 100MB&#39;</span>
cat .gitignore_default &gt; .gitignore
find . -size +100M | sed <span style="color:#e6db74">&#39;s|^./||g&#39;</span> | cat &gt;&gt; .gitignore
git add .
git commit -m <span style="color:#e6db74">&#34;Update-</span><span style="color:#e6db74">${</span>TIME<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>
git push -v

$ crontab -e 
<span style="color:#ae81ff">0</span> <span style="color:#ae81ff">12</span> * * * /home/vane/.auto-git.sh
</code></pre></div><ul>
<li>A collection of useful <a href="https://github.com/github/gitignore">.gitignore</a> templates</li>
<li><a href="https://github.com/sr320/course-fish546-2015/issues/43">Ignore files &gt;100MB in your Git repos</a></li>
<li><a href="https://docs.github.com/en/repositories/working-with-files/managing-large-files/about-large-files-on-github">About large files on GitHub</a></li>
</ul>
<h4 id="github-desktophttpsdesktopgithubcom"><a href="https://desktop.github.com/">GitHub Desktop</a><a hidden class="anchor" aria-hidden="true" href="#github-desktophttpsdesktopgithubcom">#</a></h4>
<p>Focus on what matters instead of fighting with Git. Whether you&rsquo;re new to Git or a seasoned user, GitHub Desktop simplifies your development workflow.</p>
<h3 id="libguestfs">libguestfs<a hidden class="anchor" aria-hidden="true" href="#libguestfs">#</a></h3>
<p>libguestfs 支持几乎所有类型的磁盘镜像。</p>
<p>在基于 Debian 的系统上：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ apt-get install libguestfs-tools
</code></pre></div><p>我们可以像下面这样挂载一个 qcow2 格式的磁盘镜像：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ guestmount -a /path/to/qcow2/image -m &lt;device&gt; /path/to/mount/point
</code></pre></div><p>要卸载它，则执行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ guestunmount qcow2_mount_poin
</code></pre></div><h3 id="oracle-jdk">Oracle JDK<a hidden class="anchor" aria-hidden="true" href="#oracle-jdk">#</a></h3>
<ul>
<li>
<p>解压缩到目录</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ tar -zxv -f jdk-7u60-linux-x64.gz -C dir
</code></pre></div></li>
<li>
<p>修改环境变量</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ vi ~/.bashrc
export JAVA_HOME<span style="color:#f92672">=</span>/usr/lib/jvm/jdk1.7.0_60 <span style="color:#75715e"># 这里换成自己解压的jdk 目录</span>
export JRE_HOME<span style="color:#f92672">=</span><span style="color:#e6db74">${</span>JAVA_HOME<span style="color:#e6db74">}</span>/jre
export CLASSPATH<span style="color:#f92672">=</span>.:<span style="color:#e6db74">${</span>JAVA_HOME<span style="color:#e6db74">}</span>/lib:<span style="color:#e6db74">${</span>JRE_HOME<span style="color:#e6db74">}</span>/lib
export PATH<span style="color:#f92672">=</span><span style="color:#e6db74">${</span>JAVA_HOME<span style="color:#e6db74">}</span>/bin:$PATH
</code></pre></div></li>
<li>
<p>使环境变量生效</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ source ~/.bashrc
</code></pre></div></li>
</ul>
<h3 id="snapper">Snapper<a hidden class="anchor" aria-hidden="true" href="#snapper">#</a></h3>
<p>Snapper 是一个由 openSUSE 的 Arvin Schnell 开发的工具，用于管理 Btrfs 子卷和 LVM 精简配置(thin-provisioned)卷。它可以创建和比较快照，在快照间回滚，并支持自动按时间序列创建快照。</p>
<p>列出子卷列表</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo btrfs subvolume list -p /
ID <span style="color:#ae81ff">256</span> gen <span style="color:#ae81ff">7746</span> parent <span style="color:#ae81ff">5</span> top level <span style="color:#ae81ff">5</span> path @
ID <span style="color:#ae81ff">258</span> gen <span style="color:#ae81ff">7746</span> parmount -n -o remount,rw /ent <span style="color:#ae81ff">5</span> top level <span style="color:#ae81ff">5</span> path @home
</code></pre></div><p>安装 snapper</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install snapper snapper-gui
</code></pre></div><p>创建配置文件，启用自动快照</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo snapper -c root create-config /
$ sudo snapper -c home create-config /home
</code></pre></div><p>Snapshots on boot</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo systemctl status snapper-boot.timer
</code></pre></div><p>管理 snapshot</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo snapper-gui
</code></pre></div><h3 id="fail2banhttpszhuanlanzhihucomp33546122"><a href="https://zhuanlan.zhihu.com/p/33546122">Fail2Ban</a><a hidden class="anchor" aria-hidden="true" href="#fail2banhttpszhuanlanzhihucomp33546122">#</a></h3>
<p><a href="https://github.com/fail2ban/fail2ban">Fail2Ban</a> 是一款入侵防御软件，可以保护服务器免受暴力攻击。 它是用 Python 编程语言编写的。 Fail2Ban 基于auth 日志文件工作，默认情况下它会扫描所有 auth 日志文件，如 <code>/var/log/auth.log</code>、<code>/var/log/apache/access.log</code> 等，并禁止带有恶意标志的IP，比如密码失败太多，寻找漏洞等等标志。</p>
<p>通常，Fail2Ban 用于更新防火墙规则，用于在指定的时间内拒绝 IP 地址。 它也会发送邮件通知。 Fail2Ban 为各种服务提供了许多过滤器，如 ssh、apache、nginx、squid、named、mysql、nagios 等。</p>
<p>Fail2Ban 能够降低错误认证尝试的速度，但是它不能消除弱认证带来的风险。 这只是服务器防止暴力攻击的安全手段之一。</p>
<h3 id="syncthinghttpszhuanlanzhihucomp69267020"><a href="https://zhuanlan.zhihu.com/p/69267020">Syncthing</a><a hidden class="anchor" aria-hidden="true" href="#syncthinghttpszhuanlanzhihucomp69267020">#</a></h3>
<p><a href="https://syncthing.net/">Syncthing</a>是一款开源免费跨平台的文件同步工具，是基于<strong>P2P技术</strong>实现设备间的文件同步，所以它的同步是<strong>去中心化</strong>的，即你并不需要一个服务器，故不需要担心这个中心的服务器给你带来的种种限制，而且类似于torrent协议，参与同步的设备越多，同步的速度越快。针对<strong>隐私</strong>问题，Syncthing软件只会将数据存储于个人信任的设备上，不会存储到服务器上。设备之间的通信均通过TLS进行，Syncthing还使用了完全正向保密技术来进一步保障你的数据安全。对于处于<strong>不同局域网之中</strong>的设备之间的文件同步，Syncthing也提供了支持。</p>
<h3 id="masscanhttpscloudtencentcomdeveloperarticle1707983"><a href="https://cloud.tencent.com/developer/article/1707983">masscan</a><a hidden class="anchor" aria-hidden="true" href="#masscanhttpscloudtencentcomdeveloperarticle1707983">#</a></h3>
<p><a href="https://github.com/robertdavidgraham/masscan">Masscan</a>号称是最快的互联网端口扫描器，最快可以在六分钟内扫遍互联网。</p>
<h3 id="imagemagickhttpswwwimagemagickorgscriptindexphp"><a href="https://www.imagemagick.org/script/index.php">ImageMagick</a><a hidden class="anchor" aria-hidden="true" href="#imagemagickhttpswwwimagemagickorgscriptindexphp">#</a></h3>
<p>Use ImageMagick to create, edit, compose, or convert digital images. It can read and write images in a variety of formats (over 200) including PNG, JPEG, GIF, WebP, HEIC, SVG, PDF, DPX, EXR and TIFF. ImageMagick can resize, flip, mirror, rotate, distort, shear and transform images, adjust image colors, apply various special effects, or draw text, lines, polygons, ellipses and Bézier curves.</p>
<h3 id="p7ziphttpswww7-ziporg"><a href="https://www.7-zip.org/">p7zip</a><a hidden class="anchor" aria-hidden="true" href="#p7ziphttpswww7-ziporg">#</a></h3>
<p><strong>7-Zip</strong> is a file archiver with a high compression ratio.</p>
<p>p7zip 是 <a href="https://en.wikipedia.org/wiki/7zip">7-Zip</a> 的 <a href="https://en.wikipedia.org/wiki/POSIX">POSIX</a> 系统移植，支持 Linux。</p>
<p><strong>警告：</strong> 不要将7z格式用于备份目的，因为它不会保存文件的所有者/组。有关更多详细信息，请参见<a href="https://man.archlinux.org/man/7z.1">7z(1)</a>。</p>
<p>添加文件或目录至已有的存档（或创建一个新的存档）：</p>
<pre tabindex="0"><code>$ 7z a &lt;archive name&gt; &lt;file name&gt;
</code></pre><p>也可以通过参数-p设置密码，并通过标志-mhe = on隐藏存档的结构：</p>
<pre tabindex="0"><code>$ 7z a &lt;archive name&gt; &lt;file name&gt; -p -mhe=on
</code></pre><p>更新存档内已有的文件或添加新文件：</p>
<pre tabindex="0"><code>$ 7z u &lt;archive name&gt; &lt;file name&gt;
</code></pre><p>列出存档内容：</p>
<pre tabindex="0"><code>$ 7z l &lt;archive name&gt;
</code></pre><p>从存档中解压文件至当前文件夹，不使用存档内的目录结构：</p>
<pre tabindex="0"><code>$ 7z e &lt;archive name&gt;
</code></pre><p>如果需要恢复存档内的目录结构，使用：</p>
<pre tabindex="0"><code>$ 7z x &lt;archive name&gt;
</code></pre><p>解压至新的目录：</p>
<pre tabindex="0"><code>$ 7z x -o&lt;folder name&gt; &lt;archive name&gt;
</code></pre><p>校验存档完整性：</p>
<pre tabindex="0"><code>$ 7z t &lt;archive name&gt;
</code></pre><h4 id="differences-between-7z-7za-and-7zr-binarieshttpswikiarchlinuxorgtitlep7zip"><a href="https://wiki.archlinux.org/title/p7zip">Differences between 7z, 7za and 7zr binaries</a><a hidden class="anchor" aria-hidden="true" href="#differences-between-7z-7za-and-7zr-binarieshttpswikiarchlinuxorgtitlep7zip">#</a></h4>
<p>The package includes three binaries, <code>/usr/bin/7z</code>, <code>/usr/bin/7za</code>, and <code>/usr/bin/7zr</code>. Their manual pages explain the differences:</p>
<ul>
<li>7z(1) uses plugins to handle archives.</li>
<li>7za(1) is a stand-alone executable that handles fewer archive formats than 7z.</li>
<li>7zr(1) is a stand-alone executable. It is a &ldquo;light-version&rdquo; of 7za that only handles 7z archives. In contrast to 7za, it cannot handle encrypted archives.</li>
</ul>
<h4 id="分卷压缩与解压缩httpsdeveloperaliyuncomarticle506654"><a href="https://developer.aliyun.com/article/506654">分卷压缩与解压缩</a><a hidden class="anchor" aria-hidden="true" href="#分卷压缩与解压缩httpsdeveloperaliyuncomarticle506654">#</a></h4>
<p><strong>rar</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># rar a -vSIZE  压缩后的文件名 被压缩的文件或者文件夹</span>
<span style="color:#75715e"># 最大限制为 12M</span>
$ rar a -m5 -v12m myarchive myfiles
<span style="color:#75715e">#解压</span>
$ rar e myarchive.part1.rar
</code></pre></div><p><strong>tar</strong></p>
<p>要将目录logs打包压缩并分割成多个1M的文件，可以用下面的命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ tar cjf - logs/ | split -b 1m - logs.tar.bz2.
</code></pre></div><p>完成后会产生下列文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">logs.tar.bz2.aa, logs.tar.bz2.ab, logs.tar.bz2.ac
</code></pre></div><p>要解压的时候只要执行下面的命令就可以了：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat logs.tar.bz2.a* |  tar xj
</code></pre></div><p><strong>7z</strong></p>
<p>压缩：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ 7z a name.7z filename -v10m
</code></pre></div><p>这里a是添加文件到压缩卷，name.7z是压缩后文件,然后filename可以是文件夹或文件，-v10m是限制每个包大小不超过10m.</p>
<p>解压到当前目录：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ 7z x film.7z.001
</code></pre></div><h3 id="wudao-dicthttpsgithubcomchestnuthengwudao-dict"><a href="https://github.com/ChestnutHeng/Wudao-dict">Wudao-dict</a><a hidden class="anchor" aria-hidden="true" href="#wudao-dicthttpsgithubcomchestnuthengwudao-dict">#</a></h3>
<p>有道词典的命令行版本，支持英汉互查和在线查询。</p>
<h3 id="-ascii-image-converterhttpsgithubcomthezoraizascii-image-converter"><a href="https://github.com/TheZoraiz/ascii-image-converter"> ascii-image-converter</a><a hidden class="anchor" aria-hidden="true" href="#-ascii-image-converterhttpsgithubcomthezoraizascii-image-converter">#</a></h3>
<h3 id="ttydhttpsgithubcomtsl0922ttyd"><a href="https://github.com/tsl0922/ttyd">ttyd</a><a hidden class="anchor" aria-hidden="true" href="#ttydhttpsgithubcomtsl0922ttyd">#</a></h3>
<p>Share your terminal over the web</p>
<h3 id="progresshttpsgithubcomxfennecprogress"><a href="https://github.com/Xfennec/progress">progress</a><a hidden class="anchor" aria-hidden="true" href="#progresshttpsgithubcomxfennecprogress">#</a></h3>
<p>Linux tool to show progress for cp, mv, dd, &hellip; (formerly known as cv)</p>
<h3 id="vosk-apihttpsgithubcomalphacepvosk-api"><a href="https://github.com/alphacep/vosk-api">vosk-api</a><a hidden class="anchor" aria-hidden="true" href="#vosk-apihttpsgithubcomalphacepvosk-api">#</a></h3>
<p>Offline speech recognition API for Android, iOS, Raspberry Pi and servers with Python, Java, C# and Node</p>
<h4 id="convert-mp3-to-texthttpsaskubuntucomquestions161515speech-recognition-app-to-convert-mp3-to-text"><a href="https://askubuntu.com/questions/161515/speech-recognition-app-to-convert-mp3-to-text">convert MP3 to text</a><a hidden class="anchor" aria-hidden="true" href="#convert-mp3-to-texthttpsaskubuntucomquestions161515speech-recognition-app-to-convert-mp3-to-text">#</a></h4>
<p>The software you can use is <a href="https://github.com/alphacep/vosk-api/">Vosk-api</a>, a modern speech recognition toolkit based on neural networks. It supports 7+ languages and works on variety of platforms including RPi and mobile.</p>
<p>First you convert the file to the required format and then you recognize it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ffmpeg -i file.mp3 -ar <span style="color:#ae81ff">16000</span> -ac <span style="color:#ae81ff">1</span> file.wav
</code></pre></div><p>Then install vosk-api with pip:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple vosk
</code></pre></div><p>Then use these steps:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git clone https://github.com/alphacep/vosk-api
$ cd vosk-api/python/example
$ curl -O http://alphacephei.com/vosk/models/vosk-model-small-en-us-0.15.zip
$ unzip vosk-model-small-en-us-0.15.zip
$ mv vosk-model-small-en-us-0.15 model
$ python3 ./test_simple.py test.wav &gt; result.json
</code></pre></div><p>The result will be stored in json format.</p>
<p>The same directory also contains an srt subtitle output example, which is easier to evaluate and can be directly useful to some users:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ python3 -m pip install srt
$ python3 ./test_srt.py test.wav
</code></pre></div><p>The example given in the repository says in perfect American English accent and perfect sound quality three sentences which I transcribe as:</p>
<pre tabindex="0"><code>one zero zero zero one
nine oh two one oh
zero one eight zero three
</code></pre><p>The &ldquo;nine oh two one oh&rdquo; is said very fast, but still clear. The &ldquo;z&rdquo; of the before last &ldquo;zero&rdquo; sounds a bit like an &ldquo;s&rdquo;.</p>
<p>The SRT generated above reads:</p>
<pre tabindex="0"><code>1
00:00:00,870 --&gt; 00:00:02,610
what zero zero zero one

2
00:00:03,930 --&gt; 00:00:04,950
no no to uno

3
00:00:06,240 --&gt; 00:00:08,010
cyril one eight zero three
</code></pre><p>so we can see that several mistakes were made, presumably in part because we have the understanding that all words are numbers to help us.</p>
<p>Next I also tried with the <code>vosk-model-en-us-0.22.zip</code> which was a 1.8G download compared to 40M of <code>vosk-model-small-en-us-0.15</code> and is listed at <a href="https://alphacephei.com/vosk/models">https://alphacephei.com/vosk/models</a>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ mv model vosk-model-small-en-us-0.15
$ curl -O http://alphacephei.com/vosk/models/vosk-model-en-us-0.22.zip
$ unzip vosk-model-en-us-0.22.zip
$ mv vosk-model-en-us-0.22 model
</code></pre></div><p>and the result was:</p>
<pre tabindex="0"><code>1
00:00:00,840 --&gt; 00:00:02,610
one zero zero zero one

2
00:00:04,026 --&gt; 00:00:04,980
i know what you window

3
00:00:06,270 --&gt; 00:00:07,980
serial one eight zero three
</code></pre><p>which got one more word correct.</p>
<h3 id="inxihttpslinuxcnarticle-14089-1html"><a href="https://linux.cn/article-14089-1.html">inxi</a><a hidden class="anchor" aria-hidden="true" href="#inxihttpslinuxcnarticle-14089-1html">#</a></h3>
<p><code>inix</code> 是一个用于获取 Linux 系统信息的终端命令。能够获取软件和硬件的详细信息，比如计算机型号、内核版本、发行版号以及桌面环境等信息，甚至可以读取主存模块占用主板的哪块 RAM 卡槽等详细信息。</p>
<p><code>inxi</code> 还可以用于监控系统中正在消耗 CPU 或者内存资源的进程。</p>
<p>在 Ubuntu/Debian 发行版系统中，安装命令：</p>
<pre tabindex="0"><code>sudo apt install inxi
</code></pre><p>用 <code>-F</code> 参数可以获取详细的系统信息。几乎囊括了所有层次的系统信息。</p>
<pre tabindex="0"><code>inxi -F
</code></pre><h3 id="busyboxhttpslinuxcnarticle-13840-1html"><a href="https://linux.cn/article-13840-1.html">BusyBox</a><a hidden class="anchor" aria-hidden="true" href="#busyboxhttpslinuxcnarticle-13840-1html">#</a></h3>
<p><a href="https://www.busybox.net/">BusyBox</a> 是一个开源（GPL）项目，提供了近 400 个常用命令的简单实现，包括 <code>ls</code>、<code>mv</code>、<code>ln</code>、<code>mkdir</code>、<code>more</code>、<code>ps</code>、<code>gzip</code>、<code>bzip2</code>、<code>tar</code> 和 <code>grep</code>。它还包含了编程语言 <code>awk</code>、流编辑器 <code>sed</code>、文件系统检查工具 <code>fsck</code>、软件包管理器<code>rpm</code> 和 <code>dpkg</code> ，当然还有一个可以方便的访问所有这些命令的 shell（<code>sh</code>）。简而言之，它包含了所有 POSIX 系统需要的基本命令，以执行常见的系统维护任务以及许多用户和管理任务。</p>
<p>事实上，它甚至包含一个 <code>init</code> 命令，可以作为 PID 1 启动，以作为所有其它系统服务的父进程。换句话说，BusyBox 可以作为 systemd、OpenRC、sinit、init 和其他初始化系统的替代品。</p>
<p>BusyBox 非常小。作为一个可执行文件，它不到 1MB，所以它在嵌入式、边缘计算 和物联网领域很受欢迎，因为这些场景的存储空间是很宝贵的。在容器和云计算的世界里，它作为精简的 Linux 容器镜像的基础镜像也很受欢迎。</p>
<h4 id="极简主义">极简主义<a hidden class="anchor" aria-hidden="true" href="#极简主义">#</a></h4>
<p>BusyBox 的部分魅力在于它的极简主义。它的所有命令都被编译到一个二进制文件里（<code>busybox</code>），它的手册只有 81 页（根据我对 <code>man</code> 送到 <code>pr</code> 管道的计算），但它涵盖了近 400 条命令。</p>
<p>作为一个例子的比较，这是 “原版” 的 <code>useradd —help</code> 的输出：</p>
<pre tabindex="0"><code>-b, --base-dir BASE_DIR       base directory for home
 -c, --comment COMMENT         GECOS field of the new account
 -d, --home-dir HOME_DIR       home directory of the new account
 -D, --defaults                print or change the default config
 -e, --expiredate EXPIRE_DATE  expiration date of the new account
 -f, --inactive INACTIVE       password inactivity
 -g, --gid GROUP               name or ID of the primary group
 -G, --groups GROUPS           list of supplementary groups
 -h, --help                    display this help message and exit
 -k, --skel SKEL_DIR           alternative skeleton dir
 -K, --key KEY=VALUE           override /etc/login.defs
 -l, --no-log-init             do not add the user to the lastlog
 -m, --create-home             create the user's home directory
 -M, --no-create-home          do not create the user's home directory
 -N, --no-user-group           do not create a group with the user's name
 -o, --non-unique              allow users with non-unique UIDs
 -p, --password PASSWORD       encrypted password of the new account
 -r, --system                  create a system account
 -R, --root CHROOT_DIR         directory to chroot into
 -s, --shell SHELL             login shell of the new account
 -u, --uid UID                 user ID of the new account
 -U, --user-group              create a group with the same name as a user
</code></pre><p>而这是是同一命令的 BusyBox 版本：</p>
<pre tabindex="0"><code>-h DIR    Home directory
 -g GECOS  GECOS field
 -s SHELL  Login shell
 -G GRP    Group
 -S            Create a system user
 -D            Don't assign a password
 -H            Don't create home directory
 -u UID    User id
 -k SKEL   Skeleton directory (/etc/skel)
</code></pre><p>这种差异是一种特性还是一种限制，取决于你是喜欢你的命令拥有 20 个选项还是 10 个选项。对于一些用户和某些用例来说，BusyBox 的极简主义刚刚满足所需。对于其他人来说，它是一个很好的最小化环境，可以作为一个后备工具，或者作为安装更强大的工具的基础，比如 Bash、Zsh、GNU Awk 等等。</p>
<h3 id="lynishttpslinuxcnarticle-12696-1html"><a href="https://linux.cn/article-12696-1.html">Lynis</a><a hidden class="anchor" aria-hidden="true" href="#lynishttpslinuxcnarticle-12696-1html">#</a></h3>
<blockquote>
<p>使用这个全面的开源安全审计工具检查你的 Linux 机器的安全性。</p>
</blockquote>
<p>你有没有想过你的 Linux 机器到底安全不安全？Linux 发行版众多，每个发行版都有自己的默认设置，你在上面运行着几十个版本各异的软件包，还有众多的服务在后台运行，而我们几乎不知道或不关心这些。</p>
<p>要想确定安全态势（指你的 Linux 机器上运行的软件、网络和服务的整体安全状态），你可以运行几个命令，得到一些零碎的相关信息，但你需要解析的数据量是巨大的。</p>
<p>如果能运行一个工具，生成一份关于机器安全状况的报告，那就好得多了。而幸运的是，有一个这样的软件：<a href="https://github.com/CISOfy/lynis">Lynis</a>。它是一个非常流行的开源安全审计工具，可以帮助强化基于 Linux 和 Unix 的系统。根据该项目的介绍：</p>
<blockquote>
<p>“它运行在系统本身，可以进行深入的安全扫描。主要目标是测试安全防御措施，并提供进一步强化系统的提示。它还将扫描一般系统信息、易受攻击的软件包和可能的配置问题。Lynis 常被系统管理员和审计人员用来评估其系统的安全防御。”</p>
</blockquote>
<h4 id="安装-lynis">安装 Lynis<a hidden class="anchor" aria-hidden="true" href="#安装-lynis">#</a></h4>
<p>你的 Linux 软件仓库中可能有 Lynis。如果有的话，你可以用以下方法安装它：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install lynis
</code></pre></div><p>然而，如果你的仓库中的版本不是最新的，你最好从 GitHub 上安装它。事实上，Lynis 主要是用 shell 脚本来实现的。</p>
<h4 id="运行-lynis">运行 Lynis<a hidden class="anchor" aria-hidden="true" href="#运行-lynis">#</a></h4>
<p>通过给 Lynis 一个 <code>-h</code> 选项来查看帮助部分，以便有个大概了解：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo lynis -h
</code></pre></div><p>你会看到一个简短的信息屏幕，然后是 Lynis 支持的所有子命令。</p>
<p>接下来，尝试一些测试命令以大致熟悉一下。要查看你正在使用的 Lynis 版本，请运行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo lynis show version
3.0.0
</code></pre></div><p>要查看 Lynis 中所有可用的命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo lynis show commands
Commands:
lynis audit
lynis configure
lynis generate
lynis show
lynis update
lynis upload-only
</code></pre></div><h4 id="审计-linux-系统">审计 Linux 系统<a hidden class="anchor" aria-hidden="true" href="#审计-linux-系统">#</a></h4>
<p>要审计你的系统的安全态势，运行以下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo lynis audit system
</code></pre></div><p>这个命令运行得很快，并会返回一份详细的报告，输出结果可能一开始看起来很吓人，但我将在下面引导你来阅读它。这个命令的输出也会被保存到一个日志文件中，所以你可以随时回过头来检查任何可能感兴趣的东西。</p>
<p>Lynis 将日志保存在这里：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">  Files:
  - Test and debug information      : /var/log/lynis.log
  - Report data                     : /var/log/lynis-report.dat
</code></pre></div><p>你可以验证是否创建了日志文件。它确实创建了：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ls -l /var/log/lynis.log
-rw-r-----. <span style="color:#ae81ff">1</span> root root <span style="color:#ae81ff">341489</span> Apr <span style="color:#ae81ff">30</span> 05:52 /var/log/lynis.log

$ ls -l /var/log/lynis-report.dat
-rw-r-----. <span style="color:#ae81ff">1</span> root root <span style="color:#ae81ff">638</span> Apr <span style="color:#ae81ff">30</span> 05:55 /var/log/lynis-report.dat
</code></pre></div><h4 id="探索报告">探索报告<a hidden class="anchor" aria-hidden="true" href="#探索报告">#</a></h4>
<p>Lynis 提供了相当全面的报告，所以我将介绍一些重要的部分。作为初始化的一部分，Lynis 做的第一件事就是找出机器上运行的操作系统的完整信息。之后是检查是否安装了什么系统工具和插件：</p>
<pre tabindex="0"><code>[+] Initializing program
------------------------------------
  - Detecting OS...                                           [ DONE ]
  - Checking profiles...                                      [ DONE ]
  ---------------------------------------------------
  Program version:           3.0.0
  Operating system:          Linux
  Operating system name:     Red Hat Enterprise Linux Server 7.8 (Maipo)
  Operating system version:  7.8
  Kernel version:            3.10.0
  Hardware platform:         x86_64
  Hostname:                  example
  ---------------------------------------------------
&lt;&lt;截断&gt;&gt;
[+] System Tools
------------------------------------
  - Scanning available tools...
  - Checking system binaries...
[+] Plugins (phase 1)
------------------------------------
 Note: plugins have more extensive tests and may take several minutes to complete
 
  - Plugin: pam
    [..]
  - Plugin: systemd
    [................]
</code></pre><p>接下来，该报告被分为不同的部分，每个部分都以 <code>[+]</code> 符号开头。下面可以看到部分章节。（哇，要审核的地方有这么多，Lynis 是最合适的工具！）</p>
<pre tabindex="0"><code>[+] Boot and services
[+] Kernel
[+] Memory and Processes
[+] Users, Groups and Authentication
[+] Shells
[+] File systems
[+] USB Devices
[+] Storage
[+] NFS
[+] Name services
[+] Ports and packages
[+] Networking
[+] Printers and Spools
[+] Software: e-mail and messaging
[+] Software: firewalls
[+] Software: webserver
[+] SSH Support
[+] SNMP Support
[+] Databases
[+] LDAP Services
[+] PHP
[+] Squid Support
[+] Logging and files
[+] Insecure services
[+] Banners and identification
[+] Scheduled tasks
[+] Accounting
[+] Time and Synchronization
[+] Cryptography
[+] Virtualization
[+] Containers
[+] Security frameworks
[+] Software: file integrity
[+] Software: System tooling
[+] Software: Malware
[+] File Permissions
[+] Home directories
[+] Kernel Hardening
[+] Hardening
[+] Custom tests
</code></pre><p>Lynis 使用颜色编码使报告更容易解读。</p>
<ul>
<li>绿色。一切正常</li>
<li>黄色。跳过、未找到，可能有个建议</li>
<li>红色。你可能需要仔细看看这个</li>
</ul>
<p>在我的案例中，大部分的红色标记都是在 “Kernel Hardening” 部分找到的。内核有各种可调整的设置，它们定义了内核的功能，其中一些可调整的设置可能有其安全场景。发行版可能因为各种原因没有默认设置这些，但是你应该检查每一项，看看你是否需要根据你的安全态势来改变它的值：</p>
<pre tabindex="0"><code>[+] Kernel Hardening
------------------------------------
  - Comparing sysctl key pairs with scan profile
    - fs.protected_hardlinks (exp: 1)                         [ OK ]
    - fs.protected_symlinks (exp: 1)                          [ OK ]
    - fs.suid_dumpable (exp: 0)                               [ OK ]
    - kernel.core_uses_pid (exp: 1)                           [ OK ]
    - kernel.ctrl-alt-del (exp: 0)                            [ OK ]
    - kernel.dmesg_restrict (exp: 1)                          [ DIFFERENT ]
    - kernel.kptr_restrict (exp: 2)                           [ DIFFERENT ]
    - kernel.randomize_va_space (exp: 2)                      [ OK ]
    - kernel.sysrq (exp: 0)                                   [ DIFFERENT ]
    - kernel.yama.ptrace_scope (exp: 1 2 3)                   [ DIFFERENT ]
    - net.ipv4.conf.all.accept_redirects (exp: 0)             [ DIFFERENT ]
    - net.ipv4.conf.all.accept_source_route (exp: 0)          [ OK ]
    - net.ipv4.conf.all.bootp_relay (exp: 0)                  [ OK ]
    - net.ipv4.conf.all.forwarding (exp: 0)                   [ OK ]
    - net.ipv4.conf.all.log_martians (exp: 1)                 [ DIFFERENT ]
    - net.ipv4.conf.all.mc_forwarding (exp: 0)                [ OK ]
    - net.ipv4.conf.all.proxy_arp (exp: 0)                    [ OK ]
    - net.ipv4.conf.all.rp_filter (exp: 1)                    [ OK ]
    - net.ipv4.conf.all.send_redirects (exp: 0)               [ DIFFERENT ]
    - net.ipv4.conf.default.accept_redirects (exp: 0)         [ DIFFERENT ]
    - net.ipv4.conf.default.accept_source_route (exp: 0)      [ OK ]
    - net.ipv4.conf.default.log_martians (exp: 1)             [ DIFFERENT ]
    - net.ipv4.icmp_echo_ignore_broadcasts (exp: 1)           [ OK ]
    - net.ipv4.icmp_ignore_bogus_error_responses (exp: 1)     [ OK ]
    - net.ipv4.tcp_syncookies (exp: 1)                        [ OK ]
    - net.ipv4.tcp_timestamps (exp: 0 1)                      [ OK ]
    - net.ipv6.conf.all.accept_redirects (exp: 0)             [ DIFFERENT ]
    - net.ipv6.conf.all.accept_source_route (exp: 0)          [ OK ]
    - net.ipv6.conf.default.accept_redirects (exp: 0)         [ DIFFERENT ]
    - net.ipv6.conf.default.accept_source_route (exp: 0)      [ OK ]
</code></pre><p>看看 SSH 这个例子，因为它是一个需要保证安全的关键领域。这里没有什么红色的东西，但是 Lynis 对我的环境给出了很多强化 SSH 服务的建议：</p>
<pre tabindex="0"><code>[+] SSH Support
------------------------------------
  - Checking running SSH daemon                               [ FOUND ]
    - Searching SSH configuration                             [ FOUND ]
    - OpenSSH option: AllowTcpForwarding                      [ SUGGESTION ]
    - OpenSSH option: ClientAliveCountMax                     [ SUGGESTION ]
    - OpenSSH option: ClientAliveInterval                     [ OK ]
    - OpenSSH option: Compression                             [ SUGGESTION ]
    - OpenSSH option: FingerprintHash                         [ OK ]
    - OpenSSH option: GatewayPorts                            [ OK ]
    - OpenSSH option: IgnoreRhosts                            [ OK ]
    - OpenSSH option: LoginGraceTime                          [ OK ]
    - OpenSSH option: LogLevel                                [ SUGGESTION ]
    - OpenSSH option: MaxAuthTries                            [ SUGGESTION ]
    - OpenSSH option: MaxSessions                             [ SUGGESTION ]
    - OpenSSH option: PermitRootLogin                         [ SUGGESTION ]
    - OpenSSH option: PermitUserEnvironment                   [ OK ]
    - OpenSSH option: PermitTunnel                            [ OK ]
    - OpenSSH option: Port                                    [ SUGGESTION ]
    - OpenSSH option: PrintLastLog                            [ OK ]
    - OpenSSH option: StrictModes                             [ OK ]
    - OpenSSH option: TCPKeepAlive                            [ SUGGESTION ]
    - OpenSSH option: UseDNS                                  [ SUGGESTION ]
    - OpenSSH option: X11Forwarding                           [ SUGGESTION ]
    - OpenSSH option: AllowAgentForwarding                    [ SUGGESTION ]
    - OpenSSH option: UsePrivilegeSeparation                  [ OK ]
    - OpenSSH option: AllowUsers                              [ NOT FOUND ]
    - OpenSSH option: AllowGroups                             [ NOT FOUND ]
</code></pre><p>我的系统上没有运行虚拟机或容器，所以这些显示的结果是空的：</p>
<pre tabindex="0"><code>[+] Virtualization
------------------------------------
[+] Containers
------------------------------------
</code></pre><p>Lynis 会检查一些从安全角度看很重要的文件的文件权限：</p>
<pre tabindex="0"><code>[+] File Permissions
------------------------------------
  - Starting file permissions check
    File: /boot/grub2/grub.cfg                                [ SUGGESTION ]
    File: /etc/cron.deny                                      [ OK ]
    File: /etc/crontab                                        [ SUGGESTION ]
    File: /etc/group                                          [ OK ]
    File: /etc/group-                                         [ OK ]
    File: /etc/hosts.allow                                    [ OK ]
    File: /etc/hosts.deny                                     [ OK ]
    File: /etc/issue                                          [ OK ]
    File: /etc/issue.net                                      [ OK ]
    File: /etc/motd                                           [ OK ]
    File: /etc/passwd                                         [ OK ]
    File: /etc/passwd-                                        [ OK ]
    File: /etc/ssh/sshd_config                                [ OK ]
    Directory: /root/.ssh                                     [ SUGGESTION ]
    Directory: /etc/cron.d                                    [ SUGGESTION ]
    Directory: /etc/cron.daily                                [ SUGGESTION ]
    Directory: /etc/cron.hourly                               [ SUGGESTION ]
    Directory: /etc/cron.weekly                               [ SUGGESTION ]
    Directory: /etc/cron.monthly                              [ SUGGESTION ]
</code></pre><p>在报告的底部，Lynis 根据报告的发现提出了建议。每项建议后面都有一个 “TEST-ID”（为了下一部分方便，请将其保存起来）。</p>
<pre tabindex="0"><code>Suggestions (47):
  ----------------------------
  * If not required, consider explicit disabling of core dump in /etc/security/limits.conf file [KRNL-5820]
      https://cisofy.com/lynis/controls/KRNL-5820/
  * Check PAM configuration, add rounds if applicable and expire passwords to encrypt with new values [AUTH-9229]
      https://cisofy.com/lynis/controls/AUTH-9229/
</code></pre><p>Lynis 提供了一个选项来查找关于每个建议的更多信息，你可以使用 <code>show details</code> 命令和 TEST-ID 号来访问：</p>
<pre tabindex="0"><code>$ sudo lynis show details TEST-ID
</code></pre><p>这将显示该测试的其他信息。例如，我检查了 SSH-7408 的详细信息：</p>
<pre tabindex="0"><code>$ sudo lynis show details SSH-7408
2020-04-30 05:52:23 Performing test ID SSH-7408 (Check SSH specific defined options)
2020-04-30 05:52:23 Test: Checking specific defined options in /tmp/lynis.k8JwazmKc6
2020-04-30 05:52:23 Result: added additional options for OpenSSH &amp;lt; 7.5
2020-04-30 05:52:23 Test: Checking AllowTcpForwarding in /tmp/lynis.k8JwazmKc6
2020-04-30 05:52:23 Result: Option AllowTcpForwarding found
2020-04-30 05:52:23 Result: Option AllowTcpForwarding value is YES
2020-04-30 05:52:23 Result: OpenSSH option AllowTcpForwarding is in a weak configuration state and should be fixed
2020-04-30 05:52:23 Suggestion: Consider hardening SSH configuration [test:SSH-7408] [details:AllowTcpForwarding (set YES to NO)] [solution:-]
</code></pre><h4 id="试试吧">试试吧<a hidden class="anchor" aria-hidden="true" href="#试试吧">#</a></h4>
<p>如果你想更多地了解你的 Linux 机器的安全性，请试试 Lynis。如果你想了解 Lynis 是如何工作的，可以研究一下它的 shell 脚本，看看它是如何收集这些信息的。</p>
<h4 id="how-can-i-protect-against-single-user-modehttpsaskubuntucomquestions1011368how-can-i-protect-against-single-user-mode"><a href="https://askubuntu.com/questions/1011368/how-can-i-protect-against-single-user-mode">How can I protect against single user mode</a><a hidden class="anchor" aria-hidden="true" href="#how-can-i-protect-against-single-user-modehttpsaskubuntucomquestions1011368how-can-i-protect-against-single-user-mode">#</a></h4>
<p><strong>Potential Attacks</strong></p>
<p><strong>Single User Mode</strong></p>
<p>This is the easiest way to gain unauthorised access to a Linux system is to boot the server into Single User Mode because it does not, by default, require a root password to gain root level access. Single User Mood can be accessed by power cycling the machine and interrupting the boot process. To boot into single user mode where the GRUB bootloader is used perform the following; interrupt the boot process, press e to edit the boot configuration file, append to the line starting <code>Linux</code> one of either <code>s, S, 1 or systemd. unit=[rescue.target, emergency.target, rescue]</code> to change the argument being passed to the kernel during boot to boot into Single User Mode, then press ctrl+x.</p>
<p><strong>Protecting Against Single User Mode</strong></p>
<p><strong>For a traditional init based system</strong></p>
<p>As root edit the file <code>/etc/sysconfig/init</code> then on the line <code>SINGLE=/sbin/sushell</code> change sushell TO <code>sulogin</code>.</p>
<p><strong>For a systemd based system</strong></p>
<p>The target configuration need to be altered for the root password to be prompted for. The targets are located in <code>/lib/systemd/system</code> the files which need alteration are <code>emergency.service</code> and <code>rescue.service</code>. Alter the line starting <code>ExecStart=-/bin/sh –c “/usr/sbin/sushell; ……”</code> and change the <code>/usr/sbin/sushell</code> to<code>/usr/sbin/sulogin</code> in both <code>emergency.service</code> and <code>rescue.service</code>.</p>
<p><strong>To check this has taken affect</strong></p>
<p>Then save changes and reboot to confirm the alteration has taken affect, if the alteration was success when booting into single user mode it shall ask for the root password.</p>
<p><strong>Root Password</strong></p>
<p>By default, some Linux distributions do not have root password sets, this can be checked by running the command <code>head -1 /etc/shadow</code> and if the second column, using a colon as a delimiter, is an exclamation mark then no password has been set. If no root password is set, then regardless of if the system is set to prompt for a password for Single User Mode or not it will just load root access.</p>
<p><strong>Securing Bootloader</strong></p>
<p>Insecure bootloaders can result in the bootloader being bypassed completely and a shell being used to gain direct root level access to the system. This is done by interrupting the GRUB boot process and appending <code>init=/bin/bas</code> to the line beginning <code>linux16</code>. This will tell the kernel to use bash instead of init.</p>
<p><strong>Protecting against bootloader side loading</strong></p>
<p>The GRUB bootloader can be password protected by placing the configuration in /etc/grub.d/40_custom file because this file will remain un touched by updates and upgrades to the boot loader. In <code>/etc/grub.d/40_custom</code> add <code>set superusers=”admin”</code> then password admin after that save and exit the file and run the following command <code>grub2-mkpasswd-…</code> (allow tab completion to finish this command so that the system compatible script is run) the output of this command from grub2. Onwards need to be added to the end of the line <code>password admin</code> in <code>/etc/grub.d/40_custom</code>. After that the grub file need to be recompiled by running the command <code>grub2-mkconfig –o /boot/grub2/grub.cfg</code> for centos or <code>update-grub¬</code> on debian.</p>
<p><strong>To check this has taken affect</strong></p>
<p>Then save changes and reboot to confirm the alteration has taken affect, if the alteration was success when booting and wanting to change the grub setting you will need to supply the username admin and the encrypted password.</p>
<p><strong>Protecting Against Recovery Attack</strong></p>
<p>These measures can aid in protection however, if a disk is used the recover Linux feature on the disk can be used to mount the file system and alter the GRUB setting from the disk. To protect against make any removable media have a lower boot priority than the boot drive and password protect the BIOS and boot option menu to stop someone who hasn’t got access altering the boot order and booting into a disk to make changes to the system.</p>
<h3 id="checkinstallhttpslinuxcnarticle-4090-1html"><a href="https://linux.cn/article-4090-1.html">CheckInstall</a><a hidden class="anchor" aria-hidden="true" href="#checkinstallhttpslinuxcnarticle-4090-1html">#</a></h3>
<p>如果你已经从它的源码运行“make  install”安装了linux程序。想完整移除它将变得真的很麻烦，除非程序的开发者在Makefile里提供了uninstall的目标设置。否则你必须在安装前后比较你系统里文件的完整列表，然后手工移除所有在安装过程中加入的文件。</p>
<p>这时候Checkinstall就可以派上使用。Checkinstall会跟踪install命令行所创建或修改的所有文件的路径(例如：“make install”、“make  install_modules”等)并建立一个标准的二进制包，让你能用你发行版的标准包管理系统安装或卸载它，请参考其<a href="http://checkinstall.izto.org/">官方文档</a>。</p>
<p>安装Checkinstall：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># apt install checkinstall </span>
</code></pre></div><p>一旦checkinstall安装好，你就可以用下列格式创建一个特定的软件包</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># checkinstall &lt;install-command&gt; </span>
</code></pre></div><p>如果没有参数，默认安装命令“make install”将被使用。</p>
<p>在这个例子里，我们将创建一个htop包，这是一个linux交互式文本模式进程查看器（类似 top）。</p>
<p>首先，让我们从项目的官方网站下载源代码，作为一个好的习惯，我们存储源码包到/usr/local/src下，并解压它。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># cd /usr/local/src</span>
<span style="color:#75715e"># wget http://hisham.hm/htop/releases/1.0.3/htop-1.0.3.tar.gz</span>
<span style="color:#75715e"># tar xzf htop-1.0.3.tar.gz</span>
<span style="color:#75715e"># cd htop-1.0.3 </span>
</code></pre></div><p>让我们看看htop的安装命令是什么，以便我们能用Checkinstall命令调用它，如下面所示，htop用“make install”命令安装。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># ./configure</span>
<span style="color:#75715e"># make install </span>
</code></pre></div><p>因此，要创建一个htop安装包，我们可以不带任何参数的调用checkinstall，这将使用“make install”命令创建一个包。在这个过程中， checkinstall命令会问你几个问题。</p>
<p>简而言之，如下命令会创建一个htop包：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># ./configure</span>
<span style="color:#75715e"># checkinstall </span>
</code></pre></div><p>然后checkinstall将根据你的linux系统是什么，自动地创建一个.rpm或者.deb包。</p>
<h3 id="gksudokdesudohttpsaskubuntucomquestions11760what-is-the-difference-between-gksudo-nautilus-and-sudo-nautilus"><a href="https://askubuntu.com/questions/11760/what-is-the-difference-between-gksudo-nautilus-and-sudo-nautilus">gksudo/kdesudo</a><a hidden class="anchor" aria-hidden="true" href="#gksudokdesudohttpsaskubuntucomquestions11760what-is-the-difference-between-gksudo-nautilus-and-sudo-nautilus">#</a></h3>
<p>Taken from <a href="https://help.ubuntu.com/community/RootSudo#Graphical_sudo">here</a>:</p>
<blockquote>
<p>You should <strong>never</strong> use normal <code>sudo</code> to start graphical applications as root. You should use <code>gksudo</code> (<code>kdesudo</code> on Kubuntu) to run such programs. <code>gksudo</code> sets <code>HOME=/root</code>, and copies <code>.Xauthority</code> to a <code>tmp</code> directory. This prevents files in your home directory becoming owned by root.</p>
</blockquote>
<p>Please note that this is primarily about <em>configuration files</em>. If you run Nautilus as <code>root</code>, even with <code>gksu</code>/<code>gksudo</code>, and you create a file or folder anywhere with it (including in your home directory), that file or folder will be owned by <code>root</code>. But if you run Nautilus (or most other graphical applications) as <code>root</code> with <code>sudo</code>, they may save their <em>configuration files</em> in your home directory (rather than <code>root</code>&rsquo;s home directory). Those configuration files may be owned by <code>root</code> and inaccessible when you&rsquo;re not running as root, which can severely mess up your settings, and may even keep some applications from working altogether.</p>
<p>The solution, once you have made this mistake, is to find the configuration files and delete them or <a href="http://manpages.ubuntu.com/manpages/precise/en/man1/chown.1.html"><code>chown</code></a> them back to belonging your non-<code>root</code> user. Many such files start with a <code>.</code> or are contained in a directory that starts with a <code>.</code>. Some are located inside the <code>.config</code> folder in your home directory. To see files and folders that start with a <code>.</code> in Nautilus, press Ctrl+H (this <em>shows hidden files</em>.) To see them with <a href="http://manpages.ubuntu.com/manpages/precise/en/man1/ls.1.html"><code>ls</code></a>, use the <code>-a</code> (or <code>-A</code>) flag.</p>
<p>To find if there are files not owned by you in your home directory, you can use the following command in a terminal:</p>
<pre tabindex="0"><code>find $HOME -not -user $USER -exec ls -lad {} \;
</code></pre><p>which will list all files under the home directory not owned by the user.</p>
<h3 id="manhttpslinuxcnarticle-13478-1html"><a href="https://linux.cn/article-13478-1.html">man</a><a hidden class="anchor" aria-hidden="true" href="#manhttpslinuxcnarticle-13478-1html">#</a></h3>
<p>手册页（man pages），即参考手册页（reference manual pages）的简称，是你进入 Linux 的钥匙。你想知道的一切都在那里，包罗万象。这套文档永远不会赢得普利策奖，但这套文档是相当准确和完整的。手册页是主要信源，其权威性是众所周知的。</p>
<p>虽然它们是源头，但阅读起来并不是最令人愉快的。有一次，在很久以前的哲学课上，有人告诉我，阅读 <a href="https://www.britannica.com/biography/Aristotle">亚里士多德</a> 是最无聊的阅读。我不同意：说到枯燥的阅读，亚里士多德远远地排在第二位，仅次于手册页。</p>
<p>乍一看，这些页面可能看起来并不完整，但是，不管你信不信，手册页并不是为了隐藏信息 —— 只是因为信息量太大，这些页面必须要有结构，而且信息是以尽可能简短的形式给出的。这些解释相当简略，需要一些时间来适应，但一旦你掌握了使用它们的技巧，你就会发现它们实际上是多么有用。</p>
<h4 id="入门">入门<a hidden class="anchor" aria-hidden="true" href="#入门">#</a></h4>
<p>这些页面是通过一个叫做 <code>man</code> 的工具查看的，使用它的命令相当简单。在最简单的情况下，要使用 <code>man</code>，你要在命令行上输入 <code>man</code>，后面加一个空格和你想查询的命令，比如 <code>ls</code> 或 <code>cp</code>，像这样：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">man ls
</code></pre></div><p><code>man</code> 会打开 <code>ls</code> 命令的手册页。</p>
<p>你可以用方向键上下移动，按 <code>q</code> 退出查看手册页。通常情况下，手册页是用 <code>less</code> 打开的，所以 <code>less</code> 命令的键盘快捷键在 <code>man</code> 中也可以使用。</p>
<p>例如，你可以用 <code>/search_term</code> 来搜索一个特定的文本，等等。</p>
<p>有一个关于手册页的介绍，这是一篇值得阅读介绍。它非常详细地说明了手册页是如何布局和组织的。</p>
<p>要看这个页面，请打开一个终端，然后输入：</p>
<pre tabindex="0"><code>man man
</code></pre><h4 id="节">节<a hidden class="anchor" aria-hidden="true" href="#节">#</a></h4>
<p>在你开始更深入地研究手册页之前，知道手册页有一个固定的页面布局和一个归档方案会有帮助。这可能会让新手感到困惑，因为我可以说：“看手册页中关于 <code>ls</code> 的 NAME 节（section）”，我也可以说：“看第 5 节（section）中的 <code>passwd</code> 的手册页。”</p>
<p>这个词，“节（section）” 被用于两种不同的方式，但并不总是向新人解释其中的区别。</p>
<p>我不确定为什么会出现这种混淆，但我在培训新用户和初级系统管理员时看到过几次这种混淆。我认为这可能是隧道视野，专注于一件事会使一个人忘记另一件事。一叶障目，不见泰山。</p>
<p>对于那些已经知道其中的区别的人，你可以跳过这一小节。这一部分是针对那些刚接触到手册页的人。</p>
<p>这就是区别：</p>
<p><strong>对于手册页</strong></p>
<p>单独的手册页是用来显示信息块的。例如，每个手册页都有一个“NAME”节，显示命令的名称和简短的描述。还会有另一个信息块，称为“SYNOPSIS”，显示该命令是如何使用的，以此类推。</p>
<p>每个手册页都会有这些，以及其他的标题。这些在各个手册页上的节，或者说标题，有助于保持事情的一致性和信息的分工。</p>
<p><strong>对于手册</strong></p>
<p>使用“节”，如 “查看第 5 节中的 <code>passwd</code> 的手册页”，是指整个手册的内容。当我们只看一页时，很容易忽略这一点，但是 <code>passwd</code> 手册页是同一本手册的一部分，该手册还有 <code>ls</code>、<code>rm</code>、<code>date</code>、<code>cal</code> 等的手册页。</p>
<p>整个 Linux 手册是巨大的；它有成千上万的手册页。其中一些手册页有专门的信息。有些手册页有程序员需要的信息，有些手册页有网络方面的独特信息，还有一些是系统管理员会感兴趣的。</p>
<p>这些手册页根据其独特的目的被分组。想想看，把整个手册分成几个章节 —— 每章有一个特定的主题。有 9 个左右的章节（非常大的章节）。碰巧的是，这些章节被称为“节”。</p>
<p>总结一下：</p>
<ul>
<li>手册中单页（我们称之为“手册页”）的节是由标题定义的信息块。</li>
<li>这个大的手册（所有页面的集合）中的章节，刚好被称为“节”。</li>
</ul>
<p>现在你知道区别了，希望本文的其余部分会更容易理解。</p>
<h4 id="手册页的节">手册页的节<a hidden class="anchor" aria-hidden="true" href="#手册页的节">#</a></h4>
<p>你将会看到不同的手册页，所以让我们先研究一下各个页面的布局。</p>
<p>手册页被分成几个标题，它们可能因提供者不同而不同，但会有相似之处。一般的分类如下：</p>
<ul>
<li><code>NAME</code>（名称）</li>
<li><code>SYNOPSIS</code>（概要）</li>
<li><code>DESCRIPTION</code>（描述）</li>
<li><code>EXAMPLES</code>（例子）</li>
<li><code>DIAGNOSTICS</code>（诊断）</li>
<li><code>FILES</code>（文件）</li>
<li><code>LIMITS</code>（限制）</li>
<li><code>PORTABILITY</code>（可移植性）</li>
<li><code>SEE ALSO</code>（另见）</li>
<li><code>HISTORY</code>（历史）</li>
<li><code>WARNING</code>（警告）或<code>BUGS</code>（错误）</li>
<li><code>NOTES</code>（注意事项）</li>
</ul>
<p><code>NAME</code> - 在这个标题下是命令的名称和命令的简要描述。</p>
<p><code>SYNOPSIS</code> - 显示该命令的使用方法。例如，这里是 <code>cal</code> 命令的概要：</p>
<pre tabindex="0"><code>cal [Month] [Year]
</code></pre><p>概要以命令的名称开始，后面是选项列表。概要采用命令行的一般形式；它显示了你可以输入的内容和参数的顺序。方括号中的参数（<code>[]</code>）是可选的；你可以不输入这些参数，命令仍然可以正常工作。不在括号内的项目必须使用。</p>
<p>请注意，方括号只是为了便于阅读。当你输入命令时，不应该输入它们。</p>
<p><code>DESCRIPTION</code> - 描述该命令或工具的作用以及如何使用它。这一节通常以对概要的解释开始，并说明如果你省略任何一个可选参数会发生什么。对于长的或复杂的命令，这一节可能会被细分。</p>
<p><code>EXAMPLES</code> - 一些手册页提供了如何使用命令或工具的例子。如果有这一节，手册页会尝试给出一些简单的使用例子，以及更复杂的例子来说明如何完成复杂的任务。</p>
<p><code>DIAGNOSTICS</code> - 本节列出了由命令或工具返回的状态或错误信息。通常不显示不言自明的错误和状态信息。通常会列出可能难以理解的信息。</p>
<p><code>FILES</code> - 本节包含了 UNIX 用来运行这个特定命令的补充文件的列表。这里，“补充文件”是指没有在命令行中指定的文件。例如，如果你在看 <code>passwd</code> 命令的手册，你可能会发现 <code>/etc/passwd</code> 列在这一节中，因为 UNIX 是在这里存储密码信息。</p>
<p><code>LIMITS</code> - 本节描述了一个工具的限制。操作系统和硬件的限制通常不会被列出，因为它们不在工具的控制范围内。</p>
<p><code>PORTABILITY</code> - 列出其他可以使用该工具的系统，以及该工具的其他版本可能有什么不同。</p>
<p><code>SEE ALSO</code> - 列出包含相关信息的相关手册页。</p>
<p><code>HISTORY</code> - 提供命令的简要历史，如它第一次出现的时间。</p>
<p><code>WARNING</code> - 如果有这个部分，它包含了对用户的重要建议。</p>
<p><code>NOTES</code> - 不像警告那样严重，但也是重要的信息。</p>
<p>同样，并不是所有的手册都使用上面列出的确切标题，但它们足够接近，可以遵循。</p>
<h4 id="手册的节">手册的节<a hidden class="anchor" aria-hidden="true" href="#手册的节">#</a></h4>
<p>整个 Linux 手册集合的手册页传统上被划分为有编号的节：</p>
<p><strong>第 1 节</strong>：Shell 命令和应用程序</p>
<p><strong>第 2 节</strong>：基本内核服务 - 系统调用和错误代码</p>
<p><strong>第 3 节</strong>：为程序员提供的库信息</p>
<p><strong>第 4 节</strong>：网络服务 - 如果安装了 TCP/IP 或 NFS 设备驱动和网络协议</p>
<p><strong>第 5 节</strong>：文件格式 - 例如：显示 <code>tar</code> 存档的样子</p>
<p><strong>第 6 节</strong>：游戏</p>
<p><strong>第 7 节</strong>：杂项文件和文档</p>
<p><strong>第 8 节</strong>：系统管理和维护命令</p>
<p><strong>第 9 节</strong>：不知名的内核规格和接口</p>
<p>将手册页分成这些组，可以使搜索更有效率。在我工作的地方，我有时会做一些编程工作，所以我花了一点时间看第 3 节的手册页。我也做一些网络方面的工作，所以我也知道要涉足网络部分。作为几个实验性机器的系统管理员，我在第 8 节花了很多时间。</p>
<p>将手册网归入特定的节（章节），使搜索信息更加容易 —— 无论是对需要搜索的人，还是对进行搜索的机器。</p>
<p>你可以通过名称旁边的数字来判断哪个手册页属于哪个部分。例如，如果你正在看 <code>ls</code> 的手册页，而页面的最上面写着。 <code>LS(1)</code>，那么你正在浏览第 1 节中的 <code>ls</code> 页面，该节包含关于 shell 命令和应用程序的页面。</p>
<p>下面是另一个例子。如果你在看 <code>passwd</code> 的手册页，页面的顶部显示: <code>PASSWD(1)</code>，说明你正在阅读第 1 节中描述 <code>passwd</code> 命令如何更改用户账户密码的手册页。如果你看到 <code>PASSWD(5)</code>，那么你正在阅读关于密码文件和它是如何组成的的手册页。</p>
<p><code>passwd</code> 恰好是两个不同的东西：一个是命令的名称，一个是文件的名称。同样，第 1 节描述了命令，而第 5 节涉及文件格式。</p>
<p>括号中的数字是重要的线索 —— 这个数字告诉你正在阅读的页面来自哪一节。</p>
<h4 id="搜索一个特定的节">搜索一个特定的节<a hidden class="anchor" aria-hidden="true" href="#搜索一个特定的节">#</a></h4>
<p>基本命令：</p>
<pre tabindex="0"><code>man -a name
</code></pre><p>将在每一节中搜索由 <code>name</code> 标识的手册页，按数字顺序逐一显示。要把搜索限制在一个特定的部分，请在 <code>man</code> 命令中使用一个参数，像这样：</p>
<pre tabindex="0"><code>man 1 name
</code></pre><p>这个命令将只在手册页的第 1 节中搜索 <code>name</code>。使用我们前面的 <code>passwd</code> 例子，这意味着我们可以保持搜索的针对性。如果我想阅读 <code>passwd</code> 命令的手册页，我可以在终端输入以下内容：</p>
<pre tabindex="0"><code>man 1 passwd
</code></pre><p><code>man</code> 工具将只在第 1 节中搜索 <code>passwd</code> 并显示它。它不会在任何其他节中寻找 <code>passwd</code>。</p>
<p>这个命令的另一种方法是输入: <code>man passwd.1</code>。</p>
<h4 id="搜索包含某个关键词的所有手册页">搜索包含某个关键词的所有手册页<a hidden class="anchor" aria-hidden="true" href="#搜索包含某个关键词的所有手册页">#</a></h4>
<p>如果你想获得包含某个关键词的手册页的列表，<code>man</code> 命令中的 <code>-k</code> 选项（通常称为标志或开关）可以派上用场。例如，如果你想看一个关于 <code>ftp</code> 的手册列表，你可以通过输入以下内容得到这个列表：</p>
<pre tabindex="0"><code>man -k ftp
</code></pre><p>在接下来的列表中，你可以选择一个特定的手册页来阅读。</p>
<p>在某些系统上，在 <code>man -k</code> 工作之前，系统管理员需要运行一个叫做 <code>catman</code> 的工具。</p>
<h4 id="了解手册的各个节">了解手册的各个节<a hidden class="anchor" aria-hidden="true" href="#了解手册的各个节">#</a></h4>
<p>有两个有趣的工具可以帮助你搜索信息：<code>whatis</code>和 <code>whereis</code>。</p>
<p><strong>whatis</strong></p>
<p>有的时候，我们完全可以得到我们需要的信息。我们需要的信息有很大的机会是可以找到的 —— 找到它可能是一个小问题。</p>
<p>例如，如果我想看关于 <code>passwd</code> 文件的手册页，我在终端上输入：</p>
<pre tabindex="0"><code>man passwd
</code></pre><p>我就会看到关于 <code>passwd</code> 命令所有信息的手册页，但没有关于 <code>passwd</code> 文件的内容。我知道 <code>passwd</code> 是一个命令，也有一个 <code>passwd</code> 文件，但有时，我可能会忘记这一点。这时我才意识到，文件结构在手册页中的不同节，所以我输入了：</p>
<pre tabindex="0"><code>man 4 passwd
</code></pre><p>我得到这样的答复：</p>
<pre tabindex="0"><code>No manual entry for passwd in section 4
See 'man 7 undocumented' for help when manual pages are not available.
</code></pre><p>又是一次健忘的失误。文件结构在 System V UNIX 页面的第 4 节中。几年前，当我建立文件时，我经常使用 <code>man 4 ...</code>；这仍然是我的一个习惯。那么它在 Linux 手册中的什么地方呢？</p>
<p>现在是时候调用 <code>whatis</code> 来纠正我了。为了做到这一点，我在我的终端中输入以下内容：</p>
<pre tabindex="0"><code>whatis passwd
</code></pre><p>然后我看到以下内容：</p>
<pre tabindex="0"><code>passwd (1)           - change user password
passwd (1ssl)        - compute password hashes
passwd (5)           - the password file
</code></pre><p>啊！<code>passwd</code> 文件的页面在第 5 节。现在没问题了，可以访问我想要的信息了：</p>
<pre tabindex="0"><code>man 5 passwd
</code></pre><p>然后我被带到了有我需要的信息的手册页。</p>
<p><code>whatis</code> 是一个方便的工具，可以用简短的一句话告诉你一个命令的作用。想象一下，你想知道 <code>cal</code> 是做什么的，而不想查看手册页。只要在命令提示符下键入以下内容。</p>
<pre tabindex="0"><code>whatis cal
</code></pre><p>你会看到这样的回应：</p>
<pre tabindex="0"><code>cal (1)              - displays a calendar and the date of Easter
</code></pre><p>现在你知道了 <code>whatis</code> 命令，我可以告诉你一个秘密 —— 有一个 <code>man</code> 命令的等价物。为了得到这个，我们使用 <code>-f</code> 开关：<code>man -f ...</code>。</p>
<p>试试吧。在终端提示下输入 <code>whatis cal</code>。执行后就输入：<code>man -f cal</code>。两个命令的输出将是相同的。</p>
<p><strong>whereis</strong></p>
<p><code>whereis</code> 命令的名字就说明了这一点 —— 它告诉你一个程序在文件系统中的位置。它也会告诉你手册页的存放位置。再以 <code>cal</code> 为例，我在提示符下输入以下内容：</p>
<pre tabindex="0"><code>whereis cal
</code></pre><p>我将看到这个：</p>
<pre tabindex="0"><code>cal: /usr/bin/cal /usr/share/man/man1/cal.1.gz
</code></pre><p>仔细看一下这个回答。答案只在一行里，但它告诉我两件事：</p>
<ul>
<li><code>/usr/bin/cal</code> 是 <code>cal</code> 程序所在的地方，以及</li>
<li><code>/usr/share/man/man1/cal.1.gz</code> 是手册页所在的地方（我也知道手册页是被压缩的，但不用担心 —— <code>man</code> 命令知道如何即时解压）。</li>
</ul>
<p><code>whereis</code> 依赖于 <code>PATH</code> 环境变量；它只能告诉你文件在哪里，如果它们在你的 <code>PATH</code> 环境变量中。</p>
<p>你可能想知道是否有一个与 <code>whereis</code> 相当的 <code>man</code> 命令。没有一个命令可以告诉你可执行文件的位置，但有一个开关可以告诉你手册页的位置。在这个例子中使用 <code>date</code> 命令，如果我们输入：</p>
<pre tabindex="0"><code>whereis date
</code></pre><p>在终端提示符下，我们会看到：</p>
<pre tabindex="0"><code>date: /usr/bin/date /usr/share/man/man1/date.1.gz
</code></pre><p>我们看到 <code>date</code> 程序在 <code>/usr/bin/</code> 目录下，其手册页的名称和位置是：<code>/usr/share/man/man1/date.1.gz</code>。</p>
<p>我们可以让 <code>man</code> 像 <code>whereis</code> 一样行事，最接近的方法是使用 <code>-w</code> 开关。我们不会得到程序的位置，但我们至少可以得到手册页的位置，像这样：</p>
<pre tabindex="0"><code>man -w date
</code></pre><p>我们将看到这样的返回：</p>
<pre tabindex="0"><code>/usr/share/man/man1/date.1.gz
</code></pre><p>你知道了 <code>whatis</code> 和 <code>whereis</code>，以及让 <code>man</code> 命令做同样（或接近）事情的方法。我展示了这两种方法，有几个不同的原因。</p>
<p>多年来，我使用 <code>whatis</code> 和 <code>whereis</code>，因为它们在我的培训手册中。直到最近我才了解到 <code>man -f ...</code> 和 <code>man -w ...</code>。我确信我看了几百次 <code>man</code> 的手册页，但我从未注意到 <code>-f</code> 和 <code>-w</code> 开关。我总是在看手册页的其他东西（例如：<code>man -k ...</code>）。我只专注于我需要找到的东西，而忽略了其他的东西。一旦我找到了我需要的信息，我就会离开这个页面，去完成工作，而不去注意这个命令所提供的其他一些宝贝。</p>
<p>这没关系，因为这部分就是手册页的作用：帮助你完成工作。</p>
<p>直到最近我向别人展示如何使用手册页时，我才花时间去阅读 —— “看看还有什么可能” —— 我们才真正注意到关于 <code>man</code> 命令的 <code>-f</code> 和 <code>-w</code> 标记可以做什么的信息。</p>
<p>不管你使用 Linux 多久了，或者多么有经验，总有一些新东西需要学习。</p>
<p>手册页会告诉你在完成某项任务时可能需要知道的东西 —— 但它们也有很多内容 —— 足以让你看起来像个魔术师，但前提是你要花时间去读。</p>
<h4 id="结论">结论<a hidden class="anchor" aria-hidden="true" href="#结论">#</a></h4>
<p>如果你花一些时间和精力在手册页上，你将会取得胜利。你对手册页的熟练程度，将在你掌握 Linux 的过程中发挥巨大作用。</p>
<h4 id="tldrhttpsgithubcomtldr-pagestldr"><a href="https://github.com/tldr-pages/tldr">tldr</a><a hidden class="anchor" aria-hidden="true" href="#tldrhttpsgithubcomtldr-pagestldr">#</a></h4>
<p>Collaborative cheatsheets for console commands</p>
<p>“TLDR” 是流行的互联网行话，意思是“太长不读（to long didn&rsquo;t read）”。这就是他们创建 tldr 的想法。如果你觉得手册页太长而不想阅读，tldr 通过提供命令的实际例子而将其简化了。</p>
<h3 id="lshttpslinuxcnarticle-11159-1html"><a href="https://linux.cn/article-11159-1.html">ls</a><a hidden class="anchor" aria-hidden="true" href="#lshttpslinuxcnarticle-11159-1html">#</a></h3>
<p><code>ls</code> 命令可以列出一个 <a href="https://opensource.com/article/19/7/what-posix-richard-stallman-explains">POSIX</a> 系统上的文件。这是一个简单的命令，但它经常被低估，不是它能做什么（因为它确实只做了一件事），而是你该如何优化对它的使用。</p>
<h4 id="gnu-还是-bsd">GNU 还是 BSD？<a hidden class="anchor" aria-hidden="true" href="#gnu-还是-bsd">#</a></h4>
<p>在了解 <code>ls</code> 的隐藏能力之前，你必须确定你正在运行哪个 <code>ls</code> 命令。有两个最流行的版本：包含在 GNU coreutils 包中的 GNU 版本，以及 BSD 版本。如果你正在运行 Linux，那么你很可能已经安装了 GNU 版本的 <code>ls</code>。如果你正在运行 BSD 或 MacOS，那么你有的是 BSD 版本。本文会介绍它们的不同之处。</p>
<p>你可以使用 <code>--version</code> 选项找出你计算机上的版本：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ls --version
</code></pre></div><p>如果它返回有关 GNU coreutils 的信息，那么你拥有的是 GNU 版本。如果它返回一个错误，你可能正在运行的是 BSD 版本（运行 <code>man ls | head</code> 以确定）。</p>
<p>你还应该调查你的发行版可能具有哪些预设选项。终端命令的自定义通常放在 <code>$HOME/.bashrc</code> 或 <code>$HOME/.bash_aliases</code> 或 <code>$HOME/.profile</code> 中，它们是通过将 <code>ls</code> 别名化为更复杂的 <code>ls</code> 命令来完成的。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">alias ls<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;ls --color&#39;</span>
</code></pre></div><p>发行版提供的预设非常有用，但它们确实很难分辨出哪些是 <code>ls</code> 本身的特性，哪些是它的附加选项提供的。你要是想要运行 <code>ls</code> 命令本身而不是它的别名，你可以用反斜杠“转义”命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ <span style="color:#ae81ff">\l</span>s
</code></pre></div><h4 id="分类">分类<a hidden class="anchor" aria-hidden="true" href="#分类">#</a></h4>
<p>单独运行 <code>ls</code> 会以适合你终端的列数列出文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ls ~/example
bunko        jdk-10.0.2
chapterize   otf2ttf.ff
despacer     overtar.sh
estimate.sh  pandoc-2.7.1
fop-2.3      safe_yaml
games        tt
</code></pre></div><p>这是有用的信息，但所有这些文件看起来基本相同，没有方便的图标来快速表示出哪个是目录、文本文件或图像等等。</p>
<p>使用 <code>-F</code>（或 GNU 上的长选项 <code>--classify</code>）以在每个条目之后显示标识文件类型的指示符：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ls ~/example
bunko         jdk-10.0.2/
chapterize*   otf2ttf.ff*
despacer*     overtar.sh*
estimate.sh   pandoc@
fop-2.3/      pandoc-2.7.1/
games/        tt*
</code></pre></div><p>使用此选项，终端中列出的项目使用简写符号来按文件类型分类：</p>
<ul>
<li>斜杠（<code>/</code>）表示目录（或“文件夹”）。</li>
<li>星号（<code>*</code>）表示可执行文件。这包括二进制文件（编译代码）以及脚本（具有<a href="https://opensource.com/article/19/6/understanding-linux-permissions">可执行权限</a>的文本文件）。</li>
<li>符号（<code>@</code>）表示符号链接（或“别名”）。</li>
<li>等号（<code>=</code>）表示套接字。</li>
<li>在 BSD 上，百分号（<code>%</code>）表示涂改whiteout（某些文件系统上的文件删除方法）。</li>
<li>在 GNU 上，尖括号（<code>&gt;</code>）表示门door（<a href="https://www.illumos.org/">Illumos</a> 和 Solaris上的进程间通信）。</li>
<li>竖线（<code>|</code>）表示 <a href="https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)">FIFO</a> 管道。   这个选项的一个更简单的版本是 <code>-p</code>，它只区分文件和目录。</li>
</ul>
<p>（LCTT 译注：在支持彩色的终端上，使用 <code>--color</code> 选项可以以不同的颜色来区分文件类型，但要注意如果将输出导入到管道中，则颜色消失。）</p>
<h4 id="长列表">长列表<a hidden class="anchor" aria-hidden="true" href="#长列表">#</a></h4>
<p>从 <code>ls</code> 获取“长列表”的做法是如此常见，以至于许多发行版将 <code>ll</code> 别名为 <code>ls -l</code>。长列表提供了许多重要的文件属性，例如权限、拥有每个文件的用户、文件所属的组、文件大小（以字节为单位）以及文件上次更改的日期：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ls -l
-rwxrwx---. <span style="color:#ae81ff">1</span> seth users         <span style="color:#ae81ff">455</span> Mar  <span style="color:#ae81ff">2</span>  <span style="color:#ae81ff">2017</span> estimate.sh
-rwxrwxr-x. <span style="color:#ae81ff">1</span> seth users         <span style="color:#ae81ff">662</span> Apr <span style="color:#ae81ff">29</span> 22:27 factorial
-rwxrwx---. <span style="color:#ae81ff">1</span> seth users    <span style="color:#ae81ff">20697793</span> Jun <span style="color:#ae81ff">29</span>  <span style="color:#ae81ff">2018</span> fop-2.3-bin.tar.gz
-rwxrwxr-x. <span style="color:#ae81ff">1</span> seth users        <span style="color:#ae81ff">6210</span> May <span style="color:#ae81ff">22</span> 10:22 geteltorito
-rwxrwx---. <span style="color:#ae81ff">1</span> seth users         <span style="color:#ae81ff">177</span> Nov <span style="color:#ae81ff">12</span>  <span style="color:#ae81ff">2018</span> html4mutt.sh
<span style="color:#f92672">[</span>...<span style="color:#f92672">]</span>
</code></pre></div><p>如果你不想以字节为单位，请添加 <code>-h</code> 标志（或 GNU 中的 <code>--human</code>）以将文件大小转换为更加人性化的表示方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ls --human
-rwxrwx---. <span style="color:#ae81ff">1</span> seth users    <span style="color:#ae81ff">455</span> Mar  <span style="color:#ae81ff">2</span>  <span style="color:#ae81ff">2017</span> estimate.sh
-rwxrwxr-x. <span style="color:#ae81ff">1</span> seth seth     <span style="color:#ae81ff">662</span> Apr <span style="color:#ae81ff">29</span> 22:27 factorial
-rwxrwx---. <span style="color:#ae81ff">1</span> seth users    20M Jun <span style="color:#ae81ff">29</span>  <span style="color:#ae81ff">2018</span> fop-2.3-bin.tar.gz
-rwxrwxr-x. <span style="color:#ae81ff">1</span> seth seth    6.1K May <span style="color:#ae81ff">22</span> 10:22 geteltorito
-rwxrwx---. <span style="color:#ae81ff">1</span> seth users    <span style="color:#ae81ff">177</span> Nov <span style="color:#ae81ff">12</span>  <span style="color:#ae81ff">2018</span> html4mutt.sh
</code></pre></div><p>要看到更少的信息，你可以带有 <code>-o</code> 选项只显示所有者的列，或带有 <code>-g</code> 选项只显示所属组的列：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ls -o
-rwxrwx---. <span style="color:#ae81ff">1</span> seth    <span style="color:#ae81ff">455</span> Mar  <span style="color:#ae81ff">2</span>  <span style="color:#ae81ff">2017</span> estimate.sh
-rwxrwxr-x. <span style="color:#ae81ff">1</span> seth    <span style="color:#ae81ff">662</span> Apr <span style="color:#ae81ff">29</span> 22:27 factorial
-rwxrwx---. <span style="color:#ae81ff">1</span> seth    20M Jun <span style="color:#ae81ff">29</span>  <span style="color:#ae81ff">2018</span> fop-2.3-bin.tar.gz
-rwxrwxr-x. <span style="color:#ae81ff">1</span> seth   6.1K May <span style="color:#ae81ff">22</span> 10:22 geteltorito
-rwxrwx---. <span style="color:#ae81ff">1</span> seth    <span style="color:#ae81ff">177</span> Nov <span style="color:#ae81ff">12</span>  <span style="color:#ae81ff">2018</span> html4mutt.sh
</code></pre></div><p>也可以将两个选项组合使用以显示两者。</p>
<h4 id="时间和日期格式">时间和日期格式<a hidden class="anchor" aria-hidden="true" href="#时间和日期格式">#</a></h4>
<p><code>ls</code> 的长列表格式通常如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">-rwxrwx---. <span style="color:#ae81ff">1</span> seth users         <span style="color:#ae81ff">455</span> Mar  <span style="color:#ae81ff">2</span>  <span style="color:#ae81ff">2017</span> estimate.sh
-rwxrwxr-x. <span style="color:#ae81ff">1</span> seth users         <span style="color:#ae81ff">662</span> Apr <span style="color:#ae81ff">29</span> 22:27 factorial
-rwxrwx---. <span style="color:#ae81ff">1</span> seth users    <span style="color:#ae81ff">20697793</span> Jun <span style="color:#ae81ff">29</span>  <span style="color:#ae81ff">2018</span> fop-2.3-bin.tar.gz
-rwxrwxr-x. <span style="color:#ae81ff">1</span> seth users        <span style="color:#ae81ff">6210</span> May <span style="color:#ae81ff">22</span> 10:22 geteltorito
-rwxrwx---. <span style="color:#ae81ff">1</span> seth users         <span style="color:#ae81ff">177</span> Nov <span style="color:#ae81ff">12</span>  <span style="color:#ae81ff">2018</span> html4mutt.sh
</code></pre></div><p>月份的名字不便于排序，无论是通过计算还是识别（取决于你的大脑是否倾向于喜欢字符串或整数）。你可以使用 <code>--time-style</code> 选项和格式名称更改时间戳的格式。可用格式为：</p>
<ul>
<li><code>full-iso</code>：ISO 完整格式（1970-01-01 21:12:00）</li>
<li><code>long-iso</code>：ISO 长格式（1970-01-01 21:12）</li>
<li><code>iso</code>：iso 格式（01-01 21:12）</li>
<li><code>locale</code>：本地化格式（使用你的区域设置）</li>
<li><code>posix-STYLE</code>：POSIX 风格（用区域设置定义替换 <code>STYLE</code>）</li>
</ul>
<p>你还可以使用 <code>date</code> 命令的正式表示法创建自定义样式。</p>
<h4 id="按时间排序">按时间排序<a hidden class="anchor" aria-hidden="true" href="#按时间排序">#</a></h4>
<p>通常，<code>ls</code> 命令按字母顺序排序。你可以使用 <code>-t</code> 选项根据文件的最近更改的时间（最新的文件最先列出）进行排序。</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ touch foo bar baz
$ ls
bar  baz  foo
$ touch foo
$ ls -t
foo bar baz
</code></pre></div><h4 id="列出方式">列出方式<a hidden class="anchor" aria-hidden="true" href="#列出方式">#</a></h4>
<p><code>ls</code> 的标准输出平衡了可读性和空间效率，但有时你需要按照特定方式排列的文件列表。</p>
<p>要以逗号分隔文件列表，请使用 <code>-m</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">ls -m ~/example
bar, baz, foo
</code></pre></div><p>要强制每行一个文件，请使用 <code>-1</code> 选项（这是数字 1，而不是小写的 L）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ls -1 ~/bin/
bar
baz
foo
</code></pre></div><p>要按文件扩展名而不是文件名对条目进行排序，请使用 <code>-X</code>（这是大写 X）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ls
bar.xfc  baz.txt  foo.asc
$ ls -X
foo.asc  baz.txt  bar.xfc
</code></pre></div><h4 id="隐藏杂项">隐藏杂项<a hidden class="anchor" aria-hidden="true" href="#隐藏杂项">#</a></h4>
<p>在某些 <code>ls</code> 列表中有一些你可能不关心的条目。例如，元字符 <code>.</code> 和 <code>..</code> 分别代表“本目录”和“父目录”。如果你熟悉在终端中如何切换目录，你可能已经知道每个目录都将自己称为 <code>.</code>，并将其父目录称为 <code>..</code>，因此当你使用 <code>-a</code> 选项显示隐藏文件时并不需要它经常提醒你。</p>
<p>要显示几乎所有隐藏文件（<code>.</code> 和 <code>..</code> 除外），请使用 <code>-A</code> 选项：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ls -a
.
..
.android
.atom
.bash_aliases
<span style="color:#f92672">[</span>...<span style="color:#f92672">]</span>
$ ls -A
.android
.atom
.bash_aliases
<span style="color:#f92672">[</span>...<span style="color:#f92672">]</span>
</code></pre></div><p>有许多优秀的 Unix 工具有保存备份文件的传统，它们会在保存文件的名称后附加一些特殊字符作为备份文件。例如，在 Vim 中，备份会以在文件名后附加 <code>~</code> 字符的文件名保存。</p>
<p>这些类型的备份文件已经多次使我免于愚蠢的错误，但是经过多年享受它们提供的安全感后，我觉得不需要用视觉证据来证明它们存在。我相信 Linux 应用程序可以生成备份文件（如果它们声称这样做的话），我很乐意相信它们存在 —— 而不用必须看到它们。</p>
<p>要隐藏备份文件，请使用 <code>-B</code> 或 <code>--ignore-backups</code> 隐藏常用备份格式（此选项在 BSD 的 <code>ls</code> 中不可用）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ls
bar.xfc  baz.txt  foo.asc~  foo.asc
$ ls -B
bar.xfc  baz.txt  foo.asc
</code></pre></div><p>当然，备份文件仍然存在；它只是过滤掉了，你不必看到它。</p>
<p>除非另有配置，GNU Emacs 在文件名的开头和结尾添加哈希字符（<code>＃</code>）来保存备份文件（<code>#file＃</code>）。其他应用程序可能使用不同的样式。使用什么模式并不重要，因为你可以使用 <code>--hide</code> 选项创建自己的排除项：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ls
bar.xfc  baz.txt  <span style="color:#75715e">#foo.asc#  foo.asc</span>
$ ls --hide<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;#*#&#34;</span>
bar.xfc  baz.txt  foo.asc
</code></pre></div><h4 id="递归地列出目录">递归地列出目录<a hidden class="anchor" aria-hidden="true" href="#递归地列出目录">#</a></h4>
<p>除非你在指定目录上运行 <code>ls</code>，否则子目录的内容不会与 <code>ls</code> 命令一起列出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ls -F
example/  quux*  xyz.txt
$ ls -R
quux  xyz.txt
./example:
bar.xfc  baz.txt  <span style="color:#75715e">#foo.asc#  foo.asc</span>
</code></pre></div><h4 id="使用别名使其永久化">使用别名使其永久化<a hidden class="anchor" aria-hidden="true" href="#使用别名使其永久化">#</a></h4>
<p><code>ls</code> 命令可能是 shell 会话期间最常使用的命令。这是你的眼睛和耳朵，为你提供上下文信息和确认命令的结果。虽然有很多选项很有用，但 <code>ls</code> 之美的一部分就是简洁：两个字符和回车键，你就知道你到底在哪里以及附近有什么。如果你不得不停下思考（更不用说输入）几个不同的选项，它会变得不那么方便，所以通常情况下，即使最有用的选项也不会用了。</p>
<p>解决方案是为你的 <code>ls</code> 命令添加别名，以便在使用它时，你可以获得最关心的信息。</p>
<p>要在 Bash shell 中为命令创建别名，请在主目录中创建名为 <code>.bash_aliases</code> 的文件（必须在开头包含 <code>.</code>）。 在此文件中，列出要创建的别名，然后是要为其创建别名的命令。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">alias ls<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;ls -A -F -B --human --color&#39;</span>
</code></pre></div><p>这一行导致你的 Bash shell 将 <code>ls</code> 命令解释为 <code>ls -A -F -B --human --color</code>。</p>
<p>你不必仅限于重新定义现有命令，还可以创建自己的别名：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">alias ll<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;ls -l&#39;</span>
alias la<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;ls -A&#39;</span>
alias lh<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;ls -h&#39;</span>
</code></pre></div><p>要使别名起作用，shell 必须知道 <code>.bash_aliases</code> 配置文件存在。在编辑器中打开 <code>.bashrc</code> 文件（如果它不存在则创建它），并包含以下代码块：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> -e $HOME/.bash_aliases <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
    source $HOME/.bash_aliases
<span style="color:#66d9ef">fi</span>
</code></pre></div><p>每次加载 <code>.bashrc</code>（这是一个新的 Bash shell 启动的时候），Bash 会将 <code>.bash_aliases</code> 加载到你的环境中。你可以关闭并重新启动 Bash 会话，或者直接强制它执行此操作：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ source ~/.bashrc
</code></pre></div><p>如果你忘了你是否有别名命令，<code>which</code> 命令可以告诉你：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ which ls
alias ls<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;ls -A -F -B --human --color&#39;</span>
        /usr/bin/ls
</code></pre></div><p>如果你将 <code>ls</code> 命令别名为带有选项的 <code>ls</code> 命令，则可以通过将反斜杠前缀到 <code>ls</code> 前来覆盖你的别名。例如，在示例别名中，使用 <code>-B</code> 选项隐藏备份文件，这意味着无法使用 <code>ls</code> 命令显示备份文件。 可以覆盖该别名以查看备份文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ls
bar  baz  foo
$ <span style="color:#ae81ff">\l</span>s
bar  baz  baz~  foo
</code></pre></div><h4 id="做一件事把它做好">做一件事，把它做好<a hidden class="anchor" aria-hidden="true" href="#做一件事把它做好">#</a></h4>
<p><code>ls</code> 命令有很多选项，其中许多是特定用途的或高度依赖于你所使用的终端。在 GNU 系统上查看 <code>info ls</code>，或在 GNU 或 BSD 系统上查看 <code>man ls</code> 以了解更多选项。</p>
<p>你可能会觉得奇怪的是，一个以每个工具“做一件事，把它做好”的前提而闻名的系统会让其最常见的命令背负 50 个选项。但是 <code>ls</code> 只做一件事：它列出文件，而这 50 个选项允许你控制接收列表的方式，<code>ls</code> 的这项工作做得非常、<em>非常</em>好。</p>
<h4 id="exahttpsgithubcomoghamexa"><a href="https://github.com/ogham/exa">exa</a><a hidden class="anchor" aria-hidden="true" href="#exahttpsgithubcomoghamexa">#</a></h4>
<p>A modern replacement for ‘ls’.</p>
<h3 id="du-disk-usagehttpslinuxcnarticle-11503-1html"><a href="https://linux.cn/article-11503-1.html">du (Disk Usage)</a><a hidden class="anchor" aria-hidden="true" href="#du-disk-usagehttpslinuxcnarticle-11503-1html">#</a></h3>
<p>在 Linux 中使用 ls 命令 列出的目录内容中，目录的大小仅显示 4KB。这是一个默认的大小，是用来存储磁盘上存储目录的元数据的大小。</p>
<p>du 命令 表示 磁盘使用率。这是一个标准的 Unix 程序，用于估计当前工作目录中的文件空间使用情况。</p>
<p>它使用递归方式总结磁盘使用情况，以获取目录及其子目录的大小。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ du -hs --max-depth<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span> /path/dir
</code></pre></div><ul>
<li><code>du</code> – 这是一个命令</li>
<li><code>-h</code> – 以易读的格式显示大小 (例如 1K 234M 2G)</li>
<li><code>-s</code> – 仅显示每个参数的总数</li>
<li><code>--max-depth=N</code> – 目录的打印深度</li>
</ul>
<h4 id="ncurses-disk-usagehttpsdevyorhelnlncdu"><a href="https://dev.yorhel.nl/ncdu">NCurses Disk Usage</a><a hidden class="anchor" aria-hidden="true" href="#ncurses-disk-usagehttpsdevyorhelnlncdu">#</a></h4>
<p>Ncdu is a disk usage analyzer with an ncurses interface.</p>
<p><code>ncdu</code> 命令旨在提供一份关于你在硬盘上使用的空间的交互式报告。</p>
<h4 id="gduhttpsgithubcomdundeegdu"><a href="https://github.com/dundee/gdu">gdu</a><a hidden class="anchor" aria-hidden="true" href="#gduhttpsgithubcomdundeegdu">#</a></h4>
<p>Fast disk usage analyzer with console interface written in Go</p>
<h3 id="diffhttpswwwruanyifengcomblog201208how_to_read_diffhtml"><a href="https://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html">Diff</a><a hidden class="anchor" aria-hidden="true" href="#diffhttpswwwruanyifengcomblog201208how_to_read_diffhtml">#</a></h3>
<p>diff是Unix系统的一个很重要的工具程序。</p>
<p>它用来比较两个文本文件的差异，是代码版本管理的基石之一。你在命令行下，输入：</p>
<pre tabindex="0"><code>$ diff &lt;变动前的文件&gt; &lt;变动后的文件&gt;
</code></pre><p>diff就会告诉你，这两个文件有何差异。它的显示结果不太好懂，下面我就来说明，如何读懂diff。</p>
<h4 id="三种格式">三种格式<a hidden class="anchor" aria-hidden="true" href="#三种格式">#</a></h4>
<p>由于历史原因，diff有三种格式：</p>
<ul>
<li>正常格式（normal diff）</li>
<li>上下文格式（context diff）</li>
<li>合并格式（unified diff）</li>
</ul>
<p>我们依次来看。</p>
<h4 id="示例文件">示例文件<a hidden class="anchor" aria-hidden="true" href="#示例文件">#</a></h4>
<p>为了便于讲解，先新建两个示例文件。</p>
<p>第一个文件叫做f1，内容是每行一个a，一共7行。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">a
a
a
a
a
a
a
</code></pre></div><p>第二个文件叫做f2，修改f1而成，第4行变成b，其他不变。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">a
a
a
b
a
a
a
</code></pre></div><h4 id="正常格式">正常格式<a hidden class="anchor" aria-hidden="true" href="#正常格式">#</a></h4>
<p>现在对f1和f2进行比较：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ diff f1 f2
</code></pre></div><p>这时，diff就会显示正常格式的结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">4c4
&lt; a
---
&gt; b
</code></pre></div><p>第一行是一个提示，用来说明变动位置。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">4c4
</code></pre></div><p>它分成三个部分：前面的&quot;4&quot;，表示f1的第4行有变化；中间的&quot;c&quot;表示变动的模式是内容改变（change），其他模式还有&quot;增加&quot;（a，代表addition）和&quot;删除&quot;（d，代表deletion）；后面的&quot;4&quot;，表示变动后变成f2的第4行。</p>
<p>第二行分成两个部分。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">&lt; a
</code></pre></div><p>前面的小于号，表示要从f1当中去除该行（也就是第4行），后面的&quot;a&quot;表示该行的内容。</p>
<p>第三行用来分割f1和f2。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">---
</code></pre></div><p>第四行，类似于第二行。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">&gt; b
</code></pre></div><p>前面的大于号表示f2增加了该行，后面的&quot;b&quot;表示该行的内容。</p>
<p>最早的<a href="https://www.ruanyifeng.com/blog/2010/03/unix_copyright_history.html">Unix</a>（即AT&amp;T版本的Unix），使用的就是这种格式的diff。</p>
<h4 id="上下文格式">上下文格式<a hidden class="anchor" aria-hidden="true" href="#上下文格式">#</a></h4>
<p>上个世纪80年代初，加州大学伯克利分校推出BSD版本的Unix时，觉得diff的显示结果太简单，最好加入上下文，便于了解发生的变动。因此，推出了上下文格式的diff。</p>
<p>它的使用方法是加入c参数（代表context）。</p>
<pre tabindex="0"><code>$ diff -c f1 f2
</code></pre><p>显示结果如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">*** f1 2012-08-29 16:45:41.000000000 +0800
--- f2 2012-08-29 16:45:51.000000000 +0800
***************
*** 1,7 ****
a
a
a
!a
a
a
a
--- 1,7 ----
a
a
a
!b
a
a
a
</code></pre></div><p>这个结果分成四个部分。</p>
<p>第一部分的两行，显示两个文件的基本情况：文件名和时间信息。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">*** f1 2012-08-29 16:45:41.000000000 +0800
--- f2 2012-08-29 16:45:51.000000000 +0800
</code></pre></div><p><code>***</code>表示变动前的文件，<code>---</code>表示变动后的文件。</p>
<p>第二部分是15个星号，将文件的基本情况与变动内容分割开。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">***************
</code></pre></div><p>第三部分显示变动前的文件，即f1。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">*** 1,7 ****
a
a
a
!a
a
a
a
</code></pre></div><p>这时不仅显示发生变化的第4行，还显示第4行的前面三行和后面三行，因此一共显示7行。所以，前面的<code>*** 1,7 ****</code>就表示，从第1行开始连续7行。</p>
<p>另外，文件内容的每一行最前面，还有一个标记位。如果为空，表示该行无变化；如果是感叹号（!），表示该行有改动；如果是减号（-），表示该行被删除；如果是加号（+），表示该行为新增。</p>
<p>第四部分显示变动后的文件，即f2。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">--- 1,7 ----
a
a
a
!b
a
a
a
</code></pre></div><p>除了变动行（第4行）以外，也是上下文各显示三行，总共显示7行。</p>
<h4 id="合并格式">合并格式<a hidden class="anchor" aria-hidden="true" href="#合并格式">#</a></h4>
<p>如果两个文件相似度很高，那么上下文格式的diff，将显示大量重复的内容，很浪费空间。1990年，GNU diff率先推出了&quot;合并格式&quot;的diff，将f1和f2的上下文合并在一起显示。</p>
<p>它的使用方法是加入u参数（代表unified）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ diff -u f1 f2
</code></pre></div><p>显示结果如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">--- f1 2012-08-29 16:45:41.000000000 +0800
+++ f2 2012-08-29 16:45:51.000000000 +0800
@@ -1,7 +1,7 @@
a
a
a
-a
+b
a
a
a
</code></pre></div><p>它的第一部分，也是文件的基本信息。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">--- f1 2012-08-29 16:45:41.000000000 +0800
+++ f2 2012-08-29 16:45:51.000000000 +0800
</code></pre></div><p><code>---</code>表示变动前的文件，<code>+++</code>表示变动后的文件。</p>
<p>第二部分，变动的位置用两个@作为起首和结束。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">@@ -1,7 +1,7 @@
</code></pre></div><p>前面的&quot;-1,7&quot;分成三个部分：减号表示第一个文件（即f1），&ldquo;1&quot;表示第1行，&ldquo;7&quot;表示连续7行。合在一起，就表示下面是第一个文件从第1行开始的连续7行。同样的，&quot;+1,7&quot;表示变动后，成为第二个文件从第1行开始的连续7行。</p>
<p>第三部分是变动的具体内容。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">a
a
a
-a
+b
a
a
a
</code></pre></div><p>除了有变动的那些行以外，也是上下文各显示3行。它将两个文件的上下文，合并显示在一起，所以叫做&quot;合并格式&rdquo;。每一行最前面的标志位，空表示无变动，减号表示第一个文件删除的行，加号表示第二个文件新增的行。</p>
<h4 id="git格式">git格式<a hidden class="anchor" aria-hidden="true" href="#git格式">#</a></h4>
<p>版本管理系统git，使用的是合并格式diff的变体。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git diff
</code></pre></div><p>显示结果如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">diff --git a/f1 b/f1
index 6f8a38c..449b072 <span style="color:#ae81ff">100644</span>
--- a/f1
+++ b/f1
@@ -1,7 +1,7 @@
a
a
a
-a
+b
a
a
a
</code></pre></div><p>第一行表示结果为git格式的diff。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">diff --git a/f1 b/f1
</code></pre></div><p>进行比较的是，a版本的f1（即变动前）和b版本的f1（即变动后）。</p>
<p>第二行表示两个版本的git哈希值（index区域的6f8a38c对象，与工作目录区域的449b072对象进行比较），最后的六位数字是对象的模式（普通文件，644权限）。　</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">index 6f8a38c..449b072 <span style="color:#ae81ff">100644</span>
</code></pre></div><p>第三行表示进行比较的两个文件。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">--- a/f1
+++ b/f1
</code></pre></div><p><code>---</code>表示变动前的版本，<code>+++</code>表示变动后的版本。</p>
<p>后面的行都与官方的合并格式diff相同。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">@@ -1,7 +1,7 @@
a
a
a
-a
+b
a
a
a
</code></pre></div><h3 id="crontabhttpcbianchengnetview1092html"><a href="http://c.biancheng.net/view/1092.html">Crontab</a><a hidden class="anchor" aria-hidden="true" href="#crontabhttpcbianchengnetview1092html">#</a></h3>
<p>使用 crontab 命令来执行定时任务。所谓定时任务，就是未来的某个或多个时点，预定要执行的任务，比如每五分钟收一次邮件、每天半夜两点分析一下日志等等。</p>
<h4 id="installing">Installing<a hidden class="anchor" aria-hidden="true" href="#installing">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install cronie
</code></pre></div><h4 id="running">Running<a hidden class="anchor" aria-hidden="true" href="#running">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ systemctl enable crond.service
$ systemctl start crond.service
</code></pre></div><h4 id="命令详解">命令详解<a hidden class="anchor" aria-hidden="true" href="#命令详解">#</a></h4>
<p>crontab 命令通过 /etc/cron.allow 和 /etc/cron.deny 文件来限制某些用户是否可以使用 crontab 命令：</p>
<ul>
<li>当系统中有 /etc/cron.allow 文件时，只有写入此文件的用户可以使用 crontab 命令，没有写入的用户不能使用 crontab 命令。</li>
<li>当系统中只有 /etc/cron.deny 文件时，写入此文件的用户不能使用 crontab 命令，没有写入文件的用户可以使用 crontab 命令。</li>
<li>/etc/cron.allow 文件比 /etc/cron.deny 文件的优先级高，Linux 系统中默认只有 /etc/cron.deny 文件。</li>
</ul>
<p>crontab 命令的基本格式如下：</p>
<pre tabindex="0"><code>crontab [选项] [file]
</code></pre><p>注意，这里的 file 指的是命令文件的名字，表示将 file 作为 crontab 的任务列表文件并载入 crontab，若在命令行中未指定文件名，则此命令将接受标准输入（键盘）上键入的命令，并将它们键入 crontab。</p>
<h5 id="常用选项">常用选项<a hidden class="anchor" aria-hidden="true" href="#常用选项">#</a></h5>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>-u user</td>
<td>用来设定某个用户的 crontab 服务，例如 &ldquo;-u demo&rdquo; 表示设备 demo 用户的 crontab 服务，此选项一般有 root 用户来运行。</td>
</tr>
<tr>
<td>-e</td>
<td>编辑某个用户的 crontab 文件内容。如果不指定用户，则表示编辑当前用户的 crontab 文件。</td>
</tr>
<tr>
<td>-l</td>
<td>显示某用户的 crontab 文件内容，如果不指定用户，则表示显示当前用户的 crontab 文件内容。</td>
</tr>
<tr>
<td>-r</td>
<td>从 /var/spool/cron 删除某用户的 crontab 文件，如果不指定用户，则默认删除当前用户的 crontab 文件。</td>
</tr>
<tr>
<td>-i</td>
<td>在删除用户的 crontab 文件时，给确认提示。</td>
</tr>
</tbody>
</table>
<h5 id="crontab-文件格式">crontab 文件格式<a hidden class="anchor" aria-hidden="true" href="#crontab-文件格式">#</a></h5>
<pre tabindex="0"><code>* * * * * 执行的任务
</code></pre><p>执行的任务字段既可以定时执行系统命令，也可以定时执行某个 Shell 脚本。</p>
<p><strong>执行时间</strong></p>
<table>
<thead>
<tr>
<th>项目</th>
<th>含义</th>
<th>范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>第一个&rdquo;*&quot;</td>
<td>一小时当中的第几分钟（minute）</td>
<td>0~59</td>
</tr>
<tr>
<td>第二个&quot;*&quot;</td>
<td>一天当中的第几小时（hour）</td>
<td>0~23</td>
</tr>
<tr>
<td>第三个&quot;*&quot;</td>
<td>一个月当中的第几天（day）</td>
<td>1~31</td>
</tr>
<tr>
<td>第四个&quot;*&quot;</td>
<td>一年当中的第几个月（month）</td>
<td>1~12</td>
</tr>
<tr>
<td>第五个&quot;*&quot;</td>
<td>一周当中的星期几（week）</td>
<td>0~7（0和7都代表星期日）</td>
</tr>
</tbody>
</table>
<p><strong>时间特殊符号</strong></p>
<table>
<thead>
<tr>
<th>特殊符号</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>*（星号）</td>
<td>代表任何时间。比如第一个&quot;*&ldquo;就代表一小时种每分钟都执行一次的意思。</td>
</tr>
<tr>
<td>,（逗号）</td>
<td>代表不连续的时间。比如&quot;0 8，12，16***命令&quot;就代表在每天的 8 点 0 分、12 点 0 分、16 点 0 分都执行一次命令。</td>
</tr>
<tr>
<td>-（中杠）</td>
<td>代表连续的时间范围。比如&quot;0 5 ** 1-6命令&rdquo;，代表在周一到周六的凌晨 5 点 0 分执行命令。</td>
</tr>
<tr>
<td>/（正斜线）</td>
<td>代表每隔多久执行一次。比如&quot;<code>*/10****命令</code>&quot;，代表每隔 10 分钟就执行一次命令。</td>
</tr>
</tbody>
</table>
<p>当“crontab -e”编辑完成之后，一旦保存退出，那么这个定时任务实际就会写入 /var/spool/cron/ 目录中，每个用户的定时任务用自己的用户名进行区分。而且 crontab 命令只要保存就会生效，只要 crond 服务是启动的。</p>
<p><strong>crontab举例</strong></p>
<table>
<thead>
<tr>
<th>时间</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>45 22 ***命令</td>
<td>在每天 22 点 45 分执行命令</td>
</tr>
<tr>
<td>0 17 ** 1命令</td>
<td>在每周一的 17 点 0 分执行命令</td>
</tr>
<tr>
<td>0 5 1，15**命令</td>
<td>在每月 1 日和 15 日的凌晨 5 点 0 分执行命令</td>
</tr>
<tr>
<td>40 4 ** 1-5命令</td>
<td>在每周一到周五的凌晨 4 点 40 分执行命令</td>
</tr>
<tr>
<td>*/10 4 ***命令</td>
<td>在每天的凌晨 4 点，每隔 10 分钟执行一次命令</td>
</tr>
<tr>
<td>0 0 1，15 * 1命令</td>
<td>在每月 1 日和 15 日，每周一 0 点 0 分都会执行命令</td>
</tr>
</tbody>
</table>
<p><strong>注意事项</strong></p>
<ul>
<li>6 个选项都不能为空，必须填写。如果不确定，则使用“*”代表任意时间。</li>
<li>crontab 定时任务的最小有效时间是分钟，最大有效时间是月。像 2018 年某时执行、3 点 30 分 30 秒这样的时间都不能被识别。</li>
<li>在定义时间时，日期和星期最好不要在一条定时任务中出现，因为它们都以天为单位，非常容易让管理员混淆。</li>
<li>在定时任务中，不管是直接写命令，还是在脚本中写命令，最好都使用绝对路径。有时使用相对路径的命令会报错。</li>
</ul>
<h4 id="run-a-script-on-startuphttpsunixstackexchangecomquestions416137how-can-i-run-a-script-on-startup-on-ubuntu-server-17-10"><a href="https://unix.stackexchange.com/questions/416137/how-can-i-run-a-script-on-startup-on-ubuntu-server-17-10">run a script on startup</a><a hidden class="anchor" aria-hidden="true" href="#run-a-script-on-startuphttpsunixstackexchangecomquestions416137how-can-i-run-a-script-on-startup-on-ubuntu-server-17-10">#</a></h4>
<p>Put the script in the appropriate user&rsquo;s <code>cron</code> table (i. e. the <em>crontab</em>) with a schedule of <code>@reboot</code>.</p>
<p>A user can edit its <code>cron</code> table with <code>crontab -e</code>.</p>
<p>An example which will run <code>/path/to/script.sh</code> at startup:</p>
<pre tabindex="0"><code class="language-bsh" data-lang="bsh">@reboot /path/to/script.sh
</code></pre><p>If you need to run it as root, don&rsquo;t use <code>@reboot sudo /path/to/script.sh</code>;
use <code>sudo crontab -eu root</code> to edit root&rsquo;s crontab.</p>
<h3 id="pshttpslinuxtools-rstreadthedocsiozh_cnlatesttoolpshtml"><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/ps.html">ps</a><a hidden class="anchor" aria-hidden="true" href="#pshttpslinuxtools-rstreadthedocsiozh_cnlatesttoolpshtml">#</a></h3>
<h4 id="简介-4">简介<a hidden class="anchor" aria-hidden="true" href="#简介-4">#</a></h4>
<p>要对进程进行监测和控制，首先必须要了解当前进程的情况，也就是需要查看当前进程，而 ps 命令（Process Status）就是最基本同时也是非常强大的进程查看命令。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。总之大部分信息都是可以通过执行该命令得到的。ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用top命令。</p>
<p><a href="https://blog.csdn.net/qq_38410730/article/details/81173170">linux上进程有5种状态</a>：</p>
<ul>
<li>
<p>就绪状态和运行状态</p>
<p>就绪状态的状态标志state的值为TASK_RUNNING。此时，程序已被挂入运行队列，处于准备运行状态。一旦获得处理器使用权，即可进入运行状态。</p>
<p>当进程获得处理器而运行时 ，state的值仍然为TASK_RUNNING，并不发生改变；但Linux会把一个专门用来指向当前运行任务的指针current指向它，以表示它是一个正在运行的进程。</p>
</li>
<li>
<p>可中断等待状态</p>
<p>状态标志state的值为TASK_INTERRUPTIBL。此时，由于进程未获得它所申请的资源而处在等待状态。一旦资源有效或者有唤醒信号，进程会立即结束等待而进入就绪状态。</p>
</li>
<li>
<p>不可中断等待状态</p>
<p>状态标志state的值为TASK_UNINTERRUPTIBL。此时，进程也处于等待资源状态。一旦资源有效，进程会立即进入就绪状态。这个等待状态与可中断等待状态的区别在于：处于TASK_UNINTERRUPTIBL状态的进程不能被信号量或者中断所唤醒，只有当它申请的资源有效时才能被唤醒。</p>
<p>这个状态被应用在内核中某些场景中，比如当进程需要对磁盘进行读写，而此刻正在DMA中进行着数据到内存的拷贝，如果这时进程休眠被打断（比如强制退出信号）那么很可能会出现问题，所以这时进程就会处于不可被打断的状态下。</p>
</li>
<li>
<p>停止状态</p>
<p>状态标志state的值为TASK_STOPPED。当进程收到一个SIGSTOP信号后，就由运行状态进入停止状态，当受到一个SIGCONT信号时，又会恢复运行状态。这种状态主要用于程序的调试，又被叫做“暂停状态”、“挂起状态”。</p>
</li>
<li>
<p>中止状态</p>
<p>状态标志state的值为TASK_DEAD。进程因某种原因而中止运行，进程占有的所有资源将被回收，除了task_struct结构（以及少数资源）以外，并且系统对它不再予以理睬，所以这种状态也叫做“僵死状态”，进程成为僵尸进程。</p>
</li>
</ul>
<p><img loading="lazy" src="/Distributions/20180723211512765.png" alt=""  />
</p>
<p>ps 标识进程状态对应的 5 种状态码：</p>
<ul>
<li><code>R</code>：就绪状态和运行状态 runnable (on run queue)</li>
<li><code>S</code>：可中断等待状态 sleeping</li>
<li><code>D</code>：不可中断等待状态 uninterruptible sleep (usually IO)</li>
<li><code>T</code>：停止状态 traced or stopped</li>
<li><code>Z</code>：中止状态 a defunct (”zombie”) process</li>
</ul>
<p>ps 标识进程的其他状态码：</p>
<ul>
<li><code>X</code>：死掉的进程 Dead （应该不会出现）</li>
<li><code>W</code>：内存交互状态Paging （从 2.6 内核开始无效）</li>
<li><code>N</code>：高优先级</li>
<li><code>&lt;</code>：低优先级</li>
<li><code>s</code>：包含子进程</li>
<li><code>L</code>：被锁入内存</li>
<li><code>l</code>：多线程状态</li>
<li><code>+</code>：前台进程</li>
</ul>
<h4 id="命令参数httpswwwjianshucomp943b90150c10"><a href="https://www.jianshu.com/p/943b90150c10">命令参数</a><a hidden class="anchor" aria-hidden="true" href="#命令参数httpswwwjianshucomp943b90150c10">#</a></h4>
<p>在不同的 Linux 发行版上，ps 命令的语法各不相同，为此，Linux 采取了一个折中的方法，即融合各种不同的风格，兼顾那些已经习惯了其它系统上使用 ps  命令的用户。ps命令支持三种使用的语法格式：</p>
<ul>
<li>UNIX 风格，选项可以组合在一起，并且选项前必须有“-”连字符；</li>
<li>BSD 风格，选项可以组合在一起，但是选项前不能有“-”连字符；</li>
<li>GNU 风格的选项，选项前有两个“-”连字符；</li>
</ul>
<p>ps 命令常用的参数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">ps -a  显示所有终端下执行的进程，包含其他用户的进程
ps -A  显示所有进程
ps -e  和-A功能一样
ps -H  显示树状结构，表示程序间的相互关系
ps -f  全格式显示进程

ps a   显示当前终端下执行的进程
ps c   显示进程的真实名称
ps e   列出程序所使用的环境变量
ps f   用ASCII字符显示树状结构，表达程序间的相互关系
ps x   显示所有进程，无论是否运行在终端上
ps u   显示用户相关的进程或者与用户相关的属性
ps r   只显示正在运行的进程
</code></pre></div><h4 id="使用实例httpcbianchengnetview1062html"><a href="http://c.biancheng.net/view/1062.html">使用实例</a><a hidden class="anchor" aria-hidden="true" href="#使用实例httpcbianchengnetview1062html">#</a></h4>
<p>大家如果执行 <code>man ps</code> 命令，则会发现 ps 命令的帮助为了适应不同的类 UNIX 系统，可用格式非常多，不方便记忆。所以，我建议大家记忆几个固定选项即可。</p>
<p><strong><code>ps aux</code> 查看系统中所有的进程</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># ps aux</span>
USER PID %CPU %MEM  VSZ  RSS   TTY STAT START TIME COMMAND
root   <span style="color:#ae81ff">1</span>  0.0  0.2 <span style="color:#ae81ff">2872</span> <span style="color:#ae81ff">1416</span>   ?   Ss   Jun04 0:02 /sbin/init
root   <span style="color:#ae81ff">2</span>  0.0  0.0    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>   ?    S   Jun04 0:00 <span style="color:#f92672">[</span>kthreadd<span style="color:#f92672">]</span>
root   <span style="color:#ae81ff">3</span>  0.0  0.0    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>   ?    S   Jun04 0:00 <span style="color:#f92672">[</span>migration/0<span style="color:#f92672">]</span>
root   <span style="color:#ae81ff">4</span>  0.0  0.0    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>   ?    S   Jun04 0:00 <span style="color:#f92672">[</span>ksoftirqd/0<span style="color:#f92672">]</span>
…省略部分输出…
</code></pre></div><p>输出信息中各列的具体含义：</p>
<table>
<thead>
<tr>
<th>表头</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>USER</td>
<td>该进程是由哪个用户产生的。</td>
</tr>
<tr>
<td>PID</td>
<td>进程的 ID。</td>
</tr>
<tr>
<td>%CPU</td>
<td>该进程占用 CPU 资源的百分比，占用的百分比越高，进程越耗费资源。</td>
</tr>
<tr>
<td>%MEM</td>
<td>该进程占用物理内存的百分比，占用的百分比越高，进程越耗费资源。</td>
</tr>
<tr>
<td>VSZ</td>
<td>该进程占用虚拟内存的大小，单位为 KB。</td>
</tr>
<tr>
<td>RSS</td>
<td>该进程占用实际物理内存的大小，单位为 KB。</td>
</tr>
<tr>
<td>TTY</td>
<td>该进程是在哪个终端运行的。其中，tty1 ~ tty7 代表本地控制台终端（可以通过 Alt+F1 ~ F7 快捷键切换不同的终端），tty1~tty6 是本地的字符界面终端，tty7 是图形终端。pts/0 ~ 255 代表虚拟终端，一般是远程连接的终端，第一个远程连接占用 pts/0，第二个远程连接占用 pts/1，依次増长。</td>
</tr>
<tr>
<td>STAT</td>
<td>进程状态。</td>
</tr>
<tr>
<td>START</td>
<td>该进程的启动时间。</td>
</tr>
<tr>
<td>TIME</td>
<td>该进程占用 CPU 的运算时间，注意不是系统时间。</td>
</tr>
<tr>
<td>COMMAND</td>
<td>产生此进程的命令名。</td>
</tr>
</tbody>
</table>
<p><strong><code>ps -le</code> 查看系统中所有的进程</strong></p>
<p><code>ps aux</code> 命令可以看到系统中所有的进程，<code>ps -le</code> 命令也能看到系统中所有的进程。由于 <code>-l</code> 选项的作用，所以 <code>ps -le</code> 命令能够看到更加详细的信息，比如父进程的 PID、优先级等。但是这两个命令的基本作用是一致的，掌握其中一个就足够了。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># ps -le</span>
F S UID PID PPID C  PRI Nl ADDR  SZ WCHAN TTY      TIME  CMD
<span style="color:#ae81ff">4</span> S   <span style="color:#ae81ff">0</span>   <span style="color:#ae81ff">1</span>    <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">80</span>   <span style="color:#ae81ff">0</span> -    <span style="color:#ae81ff">718</span> -     ?    00:00:02  init
<span style="color:#ae81ff">1</span> S   <span style="color:#ae81ff">0</span>   <span style="color:#ae81ff">2</span>    <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">80</span>   <span style="color:#ae81ff">0</span> -      <span style="color:#ae81ff">0</span> -     ?    00:00:00  kthreadd
<span style="color:#ae81ff">1</span> S   <span style="color:#ae81ff">0</span>   <span style="color:#ae81ff">3</span>    <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">0</span> -40   - -      <span style="color:#ae81ff">0</span> -     ?    00:00:00  migration/0
<span style="color:#ae81ff">1</span> S   <span style="color:#ae81ff">0</span>   <span style="color:#ae81ff">4</span>    <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">80</span>   <span style="color:#ae81ff">0</span> -      <span style="color:#ae81ff">0</span> -     ?    00:00:00  ksoflirqd/0
<span style="color:#ae81ff">1</span> S   <span style="color:#ae81ff">0</span>   <span style="color:#ae81ff">5</span>    <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">0</span> -40   - -      <span style="color:#ae81ff">0</span> -     ?    00:00:00  migration/0
…省略部分输出…
</code></pre></div><p>输出信息中各列的含义：</p>
<table>
<thead>
<tr>
<th>表头</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>F</td>
<td>进程标志，说明进程的权限，常见的标志有两个: 1：进程可以被复制，但是不能被执行；4：进程使用超级用户权限；</td>
</tr>
<tr>
<td>S</td>
<td>进程状态。具体的状态和&quot;psaux&quot;命令中的 STAT 状态一致；</td>
</tr>
<tr>
<td>UID</td>
<td>运行此进程的用户的 ID；</td>
</tr>
<tr>
<td>PID</td>
<td>进程的 ID；</td>
</tr>
<tr>
<td>PPID</td>
<td>父进程的 ID；</td>
</tr>
<tr>
<td>C</td>
<td>该进程的 CPU 使用率，单位是百分比；</td>
</tr>
<tr>
<td>PRI</td>
<td>进程的优先级，数值越小，该进程的优先级越高，越早被 CPU 执行；</td>
</tr>
<tr>
<td>NI</td>
<td>进程的优先级，数值越小，该进程越早被执行；</td>
</tr>
<tr>
<td>ADDR</td>
<td>该进程在内存的哪个位置；</td>
</tr>
<tr>
<td>SZ</td>
<td>该进程占用多大内存；</td>
</tr>
<tr>
<td>WCHAN</td>
<td>该进程是否运行。&quot;-&ldquo;代表正在运行；</td>
</tr>
<tr>
<td>TTY</td>
<td>该进程由哪个终端产生；</td>
</tr>
<tr>
<td>TIME</td>
<td>该进程占用 CPU 的运算时间，注意不是系统时间；</td>
</tr>
<tr>
<td>CMD</td>
<td>产生此进程的命令名；</td>
</tr>
</tbody>
</table>
<p><strong><code>ps -l</code> 查看当前 Shell 产生的进程</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># ps -l</span>
F S UID   PID  PPID C PRI NI ADDR SZ WCHAN TTY       TIME CMD
<span style="color:#ae81ff">4</span> S <span style="color:#ae81ff">0</span>   <span style="color:#ae81ff">18618</span> <span style="color:#ae81ff">18614</span> <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">80</span>  <span style="color:#ae81ff">0</span> - <span style="color:#ae81ff">1681</span>  -     pts/1 00:00:00 bash
<span style="color:#ae81ff">4</span> R <span style="color:#ae81ff">0</span>   <span style="color:#ae81ff">18683</span> <span style="color:#ae81ff">18618</span> <span style="color:#ae81ff">4</span>  <span style="color:#ae81ff">80</span>  <span style="color:#ae81ff">0</span> - <span style="color:#ae81ff">1619</span>  -     pts/1 00:00:00 ps
</code></pre></div><h3 id="tophttpcbianchengnetview1065html"><a href="http://c.biancheng.net/view/1065.html">top</a><a hidden class="anchor" aria-hidden="true" href="#tophttpcbianchengnetview1065html">#</a></h3>
<h4 id="简介httpslinuxtools-rstreadthedocsiozh_cnlatesttooltophtml"><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/top.html">简介</a><a hidden class="anchor" aria-hidden="true" href="#简介httpslinuxtools-rstreadthedocsiozh_cnlatesttooltophtml">#</a></h4>
<p>top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。</p>
<p>top显示系统当前的进程和其他状况，是一个动态显示过程，即可以通过用户按键来不断刷新当前状态。如果在前台执行该命令，它将独占前台，直到用户终止该程序为止。</p>
<p>比较准确的说，top命令提供了实时的对系统处理器的状态监视。它将显示系统中CPU最“敏感”的任务列表。该命令可以按CPU使用、内存使用和执行时间对任务进行排序；而且该命令的很多特性都可以通过交互式命令或者在个人定制文件中进行设定。</p>
<h4 id="命令参数">命令参数<a hidden class="anchor" aria-hidden="true" href="#命令参数">#</a></h4>
<p>top 命令的基本格式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">#top [选项]</span>
</code></pre></div><p>选项：</p>
<ul>
<li>-d 秒数：指定 top 命令每隔几秒更新。默认是 3 秒；</li>
<li>-b：使用批处理模式输出。一般和&rdquo;-n&quot;选项合用，用于把 top 命令重定向到文件中；</li>
<li>-n 次数：指定 top 命令执行的次数。一般和&quot;-b&quot;选项合用；</li>
<li>-p 进程PID：仅查看指定 ID 的进程；</li>
<li>-s：使 top 命令在安全模式中运行，避免在交互模式中出现错误；</li>
<li>-u 用户名：只监听某个用户的进程；</li>
</ul>
<h4 id="交互操作指令">交互操作指令<a hidden class="anchor" aria-hidden="true" href="#交互操作指令">#</a></h4>
<p>在 top 命令的显示窗口中，还可以使用如下按键，进行一下交互操作：</p>
<ul>
<li>? 或 h：显示交互模式的帮助</li>
<li>P：按照 CPU 的使用率排序，默认就是此选项</li>
<li>M：按照内存的使用率排序</li>
<li>N：按照 PID 排序</li>
<li>T：按照 CPU 的累积运算时间排序，也就是按照 TIME+ 项排序</li>
<li>k：按照 PID 给予某个进程一个信号。一般用于中止某个进程，信号 9 是强制中止的信号</li>
<li>r：按照 PID 给某个进程重设优先级（Nice）值</li>
<li><code>&lt;Space&gt;</code>：立即刷新</li>
<li>s：设置刷新时间间隔</li>
<li>c：显示命令完全模式</li>
<li>t:：显示或隐藏进程和CPU状态信息</li>
<li>m：显示或隐藏内存状态信息</li>
<li>l：显示或隐藏uptime信息</li>
<li>f：增加或减少进程显示标志</li>
<li>S：累计模式，会把已完成或退出的子进程占用的CPU时间累计到父进程的TIME+</li>
<li>u：指定显示用户进程</li>
<li>i：只显示正在运行的进程</li>
<li>W：保存对top的设置到文件 <code>~/.toprc</code>，下次启动将自动调用toprc文件的设置。</li>
<li>q：退出</li>
</ul>
<h4 id="使用实例">使用实例<a hidden class="anchor" aria-hidden="true" href="#使用实例">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># top</span>
top - 12:26:46 up <span style="color:#ae81ff">1</span> day, 13:32, <span style="color:#ae81ff">2</span> users, load average: 0.00, 0.00, 0.00
Tasks: <span style="color:#ae81ff">95</span> total, <span style="color:#ae81ff">1</span> running, <span style="color:#ae81ff">94</span> sleeping, <span style="color:#ae81ff">0</span> stopped, <span style="color:#ae81ff">0</span> zombie
Cpu<span style="color:#f92672">(</span>s<span style="color:#f92672">)</span>: 0.1%us, 0.1%sy, 0.0%ni, 99.7%id, 0.1%wa, 0.0%hi, 0.1%si, 0.0%st
Mem: 625344k total, 571504k used, 53840k free, 65800k buffers
Swap: 524280k total, 0k used, 524280k free, 409280k cached
PID   USER PR NI VIRT  RES  SHR S %CPU %MEM   TIME+ COMMAND
<span style="color:#ae81ff">19002</span> root <span style="color:#ae81ff">20</span>  <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">2656</span> <span style="color:#ae81ff">1068</span>  <span style="color:#ae81ff">856</span> R  0.3  0.2 0:01.87 top
<span style="color:#ae81ff">1</span>     root <span style="color:#ae81ff">20</span>  <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">2872</span> <span style="color:#ae81ff">1416</span> <span style="color:#ae81ff">1200</span> S  0.0  0.2 0:02.55 init
<span style="color:#ae81ff">2</span>     root <span style="color:#ae81ff">20</span>  <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> S  0.0  0.0 0:00.03 kthreadd
</code></pre></div><p><strong>第一行为任务队列信息</strong></p>
<table>
<thead>
<tr>
<th>内 容</th>
<th>说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td>12:26:46</td>
<td>系统当前时间</td>
</tr>
<tr>
<td>up 1 day, 13:32</td>
<td>系统的运行时间.本机己经运行 1 天 13 小时 32 分钟</td>
</tr>
<tr>
<td>2 users</td>
<td>当前登录了两个用户</td>
</tr>
<tr>
<td>load average: 0.00,0.00，0.00</td>
<td>系统在之前 1 分钟、5 分钟、15 分钟的平均负载。如果 CPU 是单核的，则这个数值超过 1 就是高负载：如果 CPU 是四核的，则这个数值超过 4 就是高负载 （这个平均负载完全是依据个人经验来进行判断的，一般认为不应该超过服务器 CPU 的核数）</td>
</tr>
</tbody>
</table>
<p><strong>第二行为进程信息</strong></p>
<table>
<thead>
<tr>
<th>内 容</th>
<th>说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Tasks: 95 total</td>
<td>系统中的进程总数</td>
</tr>
<tr>
<td>1 running</td>
<td>正在运行的进程数</td>
</tr>
<tr>
<td>94 sleeping</td>
<td>睡眠的进程数</td>
</tr>
<tr>
<td>0 stopped</td>
<td>正在停止的进程数</td>
</tr>
<tr>
<td>0 zombie</td>
<td>僵尸进程数。如果不是 0，则需要手工检查僵尸进程</td>
</tr>
</tbody>
</table>
<p><strong>第三行为 CPU 信息</strong></p>
<table>
<thead>
<tr>
<th>内 容</th>
<th>说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cpu(s): 0.1 %us</td>
<td>用户模式占用的 CPU 百分比</td>
</tr>
<tr>
<td>0.1%sy</td>
<td>系统模式占用的 CPU 百分比</td>
</tr>
<tr>
<td>0.0%ni</td>
<td>改变过优先级的用户进程占用的 CPU 百分比</td>
</tr>
<tr>
<td>99.7%id</td>
<td>空闲 CPU 占用的 CPU 百分比</td>
</tr>
<tr>
<td>0.1%wa</td>
<td>等待输入/输出的进程占用的 CPU 百分比</td>
</tr>
<tr>
<td>0.0%hi</td>
<td>硬中断请求服务占用的 CPU 百分比</td>
</tr>
<tr>
<td>0.1%si</td>
<td>软中断请求服务占用的 CPU 百分比</td>
</tr>
<tr>
<td>0.0%st</td>
<td>st（steal time）意为虚拟时间百分比，就是当有虚拟机时，虚拟 CPU 等待实际 CPU 的时间百分比</td>
</tr>
</tbody>
</table>
<p><strong>第四行为物理内存信息</strong></p>
<table>
<thead>
<tr>
<th>内 容</th>
<th>说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mem: 625344k total</td>
<td>物理内存的总量，单位为KB</td>
</tr>
<tr>
<td>571504k used</td>
<td>己经使用的物理内存数量</td>
</tr>
<tr>
<td>53840k free</td>
<td>空闲的物理内存数量。我们使用的是虚拟机，共分配了 628MB内存，所以只有53MB的空闲内存</td>
</tr>
<tr>
<td>65800k buffers/cache</td>
<td>作为缓冲的内存数量</td>
</tr>
</tbody>
</table>
<p>缓冲（buffer）和缓存（cache）的区别：</p>
<ul>
<li>缓存（cache）是在读取硬盘中的数据时，把最常用的数据保存在内存的缓存区中，再次读取该数据时，就不去硬盘中读取了，而在缓存中读取。</li>
<li>缓冲（buffer）是在向硬盘写入数据时，先把数据放入缓冲区,然后再一起向硬盘写入，把分散的写操作集中进行，减少磁盘碎片和硬盘的反复寻道，从而提高系统性能。</li>
</ul>
<p>简单来说，缓存（cache）是用来加速数据从硬盘中&quot;读取&quot;的，而缓冲（buffer）是用来加速数据&quot;写入&quot;硬盘的。</p>
<p><strong>第五行为交换分区（swap）信息</strong></p>
<table>
<thead>
<tr>
<th>内 容</th>
<th>说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Swap: 524280k total</td>
<td>交换分区（虚拟内存）的总大小</td>
</tr>
<tr>
<td>Ok used</td>
<td>已经使用的交换分区的大小</td>
</tr>
<tr>
<td>524280k free</td>
<td>空闲交换分区的大小</td>
</tr>
<tr>
<td>409280k cached</td>
<td>作为缓存的交换分区的大小</td>
</tr>
</tbody>
</table>
<p><strong>第六行为系统进程信息</strong></p>
<p>再来看 top 命令的第二部分输出，主要是系统进程信息，各个字段的含义如下：</p>
<ul>
<li>PID：进程的 ID。</li>
<li>USER：该进程所属的用户。</li>
<li>PR：优先级，数值越小优先级越高。</li>
<li>NI：优先级，数值越小、优先级越高。</li>
<li>VIRT：该进程使用的虚拟内存的大小，单位为 KB。</li>
<li>RES：该进程使用的物理内存的大小，单位为 KB。</li>
<li>SHR：共享内存大小，单位为 KB。</li>
<li>S：进程状态。</li>
<li>%CPU：该进程占用 CPU 的百分比。</li>
<li>%MEM：该进程占用内存的百分比。</li>
<li>TIME+：该进程共占用的 CPU 时间。</li>
<li>COMMAND：进程的命令名。</li>
</ul>
<h4 id="htophttpsgithubcomhtop-devhtop"><a href="https://github.com/htop-dev/htop/">htop</a><a hidden class="anchor" aria-hidden="true" href="#htophttpsgithubcomhtop-devhtop">#</a></h4>
<p>htop 是一个 Linux 下的交互式的进程浏览器，可以用来替换Linux下的top命令。</p>
<p>与Linux传统的top相比，htop更加人性化。它可让用户交互式操作，支持颜色主题，可横向或纵向滚动浏览进程列表，并支持鼠标操作。</p>
<h4 id="bpytophttpsgithubcomaristocratosbpytop"><a href="https://github.com/aristocratos/bpytop">bpytop</a><a hidden class="anchor" aria-hidden="true" href="#bpytophttpsgithubcomaristocratosbpytop">#</a></h4>
<p>Linux/OSX/FreeBSD resource monitor</p>
<h3 id="lsofhttpslinuxtools-rstreadthedocsiozh_cnlatesttoollsofhtml"><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/lsof.html">lsof</a><a hidden class="anchor" aria-hidden="true" href="#lsofhttpslinuxtools-rstreadthedocsiozh_cnlatesttoollsofhtml">#</a></h3>
<h4 id="简介httpcbianchengnetview1088html"><a href="http://c.biancheng.net/view/1088.html">简介</a><a hidden class="anchor" aria-hidden="true" href="#简介httpcbianchengnetview1088html">#</a></h4>
<p>lsof 命令，“list opened files”的缩写，直译过来，就是列举系统中已经被打开的文件。通过 lsof 命令，我们就可以根据文件找到对应的进程信息，也可以根据进程信息找到进程打开的文件。</p>
<p>在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，无论这个文件的本质如何，该文件描述符为应用程序与基础操作系统之间的交互提供了通用接口。因为应用程序打开文件的描述符列表提供了大量关于这个应用程序本身的信息，因此通过lsof工具能够查看这个列表对系统监测以及排错将是很有帮助的。</p>
<p>在终端下输入lsof即可显示系统打开的文件，因为 lsof 需要访问核心内存和各种文件，所以必须以 root 用户的身份运行它才能够充分地发挥其功能。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo lsof | less
COMMAND     PID   TID TASKCMD                  USER   FD      TYPE             DEVICE   SIZE/OFF       NODE NAME
systemd       <span style="color:#ae81ff">1</span>                                root  cwd       DIR                8,2       <span style="color:#ae81ff">4096</span>          <span style="color:#ae81ff">2</span> /
systemd       <span style="color:#ae81ff">1</span>                                root  rtd       DIR                8,2       <span style="color:#ae81ff">4096</span>          <span style="color:#ae81ff">2</span> /
systemd       <span style="color:#ae81ff">1</span>                                root  txt       REG                8,2    <span style="color:#ae81ff">1620224</span>    <span style="color:#ae81ff">2491035</span> /usr/lib/systemd/systemd
systemd       <span style="color:#ae81ff">1</span>                                root  mem       REG                8,2    <span style="color:#ae81ff">1369352</span>    <span style="color:#ae81ff">2498532</span> /usr/lib/x86_64-linux-gnu/libm-2.31.so
systemd       <span style="color:#ae81ff">1</span>                                root  mem       REG                8,2     <span style="color:#ae81ff">178528</span>    <span style="color:#ae81ff">2490726</span> /usr/lib/x86_64-linux-gnu/libudev.so.1.6.17
</code></pre></div><p>输出各列信息的意义如下：</p>
<ul>
<li>
<p>COMMAND：进程的名称</p>
</li>
<li>
<p>PID：进程标识符</p>
</li>
<li>
<p>PPID：父进程标识符（需要指定-R参数）</p>
</li>
<li>
<p>USER：进程所有者</p>
</li>
<li>
<p>PGID：进程所属组</p>
</li>
<li>
<p>FD：文件描述符（filedescriptor，简称 fd），应用程序通过文件描述符识别该文件类型。</p>
<p>例如 cwd 表示current work dirctory，即应用程序的当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改。txt 表示该类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 <code>/usr/lib/systemd/systemd</code> 程序。</p>
</li>
<li>
<p>TYPE：文件类型，如DIR、REG等，常见的文件类型:</p>
<ul>
<li>DIR：目录</li>
<li>REG：普通文件</li>
<li>CHR：字符</li>
<li>BLK：块设备类型</li>
<li>UNIX： UNIX 域套接字</li>
<li>FIFO：先进先出 (FIFO) 队列</li>
<li>IPv4：网际协议 (IP) 套接字</li>
</ul>
</li>
<li>
<p>DEVICE：指定磁盘的名称</p>
</li>
<li>
<p>SIZE：文件的大小</p>
</li>
<li>
<p>NODE：索引节点（文件在磁盘上的标识）</p>
</li>
<li>
<p>NAME：打开文件的确切名称</p>
</li>
</ul>
<h4 id="命令参数-1">命令参数<a hidden class="anchor" aria-hidden="true" href="#命令参数-1">#</a></h4>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>列出打开文件存在的进程</td>
</tr>
<tr>
<td>-c &lt;进程名&gt;</td>
<td>列出指定进程名所打开的文件</td>
</tr>
<tr>
<td>-g</td>
<td>列出GID号进程详情</td>
</tr>
<tr>
<td>-d &lt;文件号&gt;</td>
<td>列出占用该文件号的进程</td>
</tr>
<tr>
<td>+d &lt;目录&gt;</td>
<td>列出目录下被打开的文件</td>
</tr>
<tr>
<td>+D &lt;目录&gt;</td>
<td>递归列出目录下被打开的文件</td>
</tr>
<tr>
<td>-n &lt;目录&gt;</td>
<td>列出使用NFS的文件</td>
</tr>
<tr>
<td>-i &lt;条件&gt;</td>
<td>列出符合条件的进程</td>
</tr>
<tr>
<td>-p &lt;进程号&gt;</td>
<td>列出指定进程号所打开的文件</td>
</tr>
<tr>
<td>-u</td>
<td>列出UID号进程详情</td>
</tr>
<tr>
<td>-h</td>
<td>显示帮助信息</td>
</tr>
<tr>
<td>-v</td>
<td>显示版本信息</td>
</tr>
</tbody>
</table>
<h4 id="使用实例-1">使用实例<a hidden class="anchor" aria-hidden="true" href="#使用实例-1">#</a></h4>
<p><strong>查询某个文件被哪个进程调用</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ lsof /bin/bash
</code></pre></div><p><strong>查询某个目录下所有的文件是被哪些进程调用的</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ lsof +d /usr/lib
</code></pre></div><p><strong>查看以httpd开头的进程调用了哪些文件</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ lsof -c httpd
</code></pre></div><p><strong>查询PID是1的进程调用的文件</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ lsof -p <span style="color:#ae81ff">1</span>
</code></pre></div><p><strong>按照用户名查询某个用户的进程调用的文件</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ lsof -u username
</code></pre></div><p><strong>列出某个用户以及某个进程所打开的文件信息</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ lsof  -u test -c mysql
</code></pre></div><p><strong>列出所有的网络连接</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ lsof -i
</code></pre></div><p><strong>列出所有tcp 网络连接信息</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ lsof -i tcp
</code></pre></div><p><strong>列出谁在使用某个端口</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ lsof -i :3306
</code></pre></div><p><strong>列出某个用户的所有活跃的网络端口</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ lsof -a -u test -i
</code></pre></div><p><strong>根据文件描述列出对应的文件信息</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ lsof -d txt
</code></pre></div><p><strong>列出被进程号为1234的进程所打开的所有 IPV4 network files</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ lsof -i <span style="color:#ae81ff">4</span> -a -p <span style="color:#ae81ff">1234</span>
</code></pre></div><p><strong>列出目前连接主机nf5260i5-td上端口为：20，21，80相关的所有文件信息，且每隔3秒重复执行</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ lsof -i @nf5260i5-td:20,21,80 -r <span style="color:#ae81ff">3</span>
</code></pre></div><h3 id="write">write<a hidden class="anchor" aria-hidden="true" href="#write">#</a></h3>
<p>在服务器上，有时会有多个用户同时登录，一些必要的沟通就显得尤为重要。比如,我必须关闭某个服务，或者需要重启服务器，当然需要通知同时登录服务器的用户，这时就可以使用 write 命令。</p>
<p>write 命令的信息如下：</p>
<ul>
<li>命令名称：write。</li>
<li>英文原意：send a message to another user。</li>
<li>所在路径：/usr/bin/write。</li>
<li>执行权限：所有用户。</li>
<li>功能描述：向其他用户发送信息。</li>
</ul>
<p>write 命令的基本格式如下:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ write 用户名 <span style="color:#f92672">[</span>终端号<span style="color:#f92672">]</span>
</code></pre></div><p>write 命令没有多余的选项，我们要向在某个终端登录的用户发送信息，就可以这样来执行命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 向在pts/1 (远程终端1)登录的user1用户发送信息，使用&#34;Ctrl+D&#34;快捷键保存发送的数据</span>
$ write user1 pts/1
hello
I will be in <span style="color:#ae81ff">5</span> minutes to restart, please save your data
</code></pre></div><p>这时，user1 用户就可以收到你要在 5 分钟之后重启系统的信息了。</p>
<h3 id="xargs">xargs<a hidden class="anchor" aria-hidden="true" href="#xargs">#</a></h3>
<h4 id="标准输入与管道命令">标准输入与管道命令<a hidden class="anchor" aria-hidden="true" href="#标准输入与管道命令">#</a></h4>
<p>Unix 命令都带有参数，有些命令可以接受&quot;标准输入&quot;（stdin）作为参数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat /etc/passwd | grep root
</code></pre></div><p>上面的代码使用了管道命令（<code>|</code>）。管道命令的作用，是将左侧命令（<code>cat /etc/passwd</code>）的标准输出转换为标准输入，提供给右侧命令（<code>grep root</code>）作为参数。</p>
<p>因为<code>grep</code>命令可以接受标准输入作为参数，所以上面的代码等同于下面的代码。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ grep root /etc/passwd
</code></pre></div><p>但是，大多数命令都不接受标准输入作为参数，只能直接在命令行输入参数，这导致无法用管道命令传递参数。举例来说，<code>echo</code>命令就不接受管道传参。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ echo <span style="color:#e6db74">&#34;hello world&#34;</span> | echo
</code></pre></div><p>上面的代码不会有输出。因为管道右侧的<code>echo</code>不接受管道传来的标准输入作为参数。</p>
<h4 id="xargs-命令的作用">xargs 命令的作用<a hidden class="anchor" aria-hidden="true" href="#xargs-命令的作用">#</a></h4>
<p><code>xargs</code>命令的作用，是将标准输入转为命令行参数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ echo <span style="color:#e6db74">&#34;hello world&#34;</span> | xargs echo
hello world
</code></pre></div><p>上面的代码将管道左侧的标准输入，转为命令行参数<code>hello world</code>，传给第二个<code>echo</code>命令。</p>
<p><code>xargs</code>命令的格式如下。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ xargs <span style="color:#f92672">[</span>-options<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>command<span style="color:#f92672">]</span>
</code></pre></div><p>真正执行的命令，紧跟在<code>xargs</code>后面，接受<code>xargs</code>传来的参数。</p>
<p><code>xargs</code>的作用在于，大多数命令（比如<code>rm</code>、<code>mkdir</code>、<code>ls</code>）与管道一起使用时，都需要<code>xargs</code>将标准输入转为命令行参数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ echo <span style="color:#e6db74">&#34;one two three&#34;</span> | xargs mkdir
</code></pre></div><p>上面的代码等同于<code>mkdir one two three</code>。如果不加<code>xargs</code>就会报错，提示<code>mkdir</code>缺少操作参数。</p>
<h4 id="xargs-的单独使用">xargs 的单独使用<a hidden class="anchor" aria-hidden="true" href="#xargs-的单独使用">#</a></h4>
<p><code>xargs</code>后面的命令默认是<code>echo</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ xargs
<span style="color:#75715e"># 等同于</span>
$ xargs echo
</code></pre></div><p>大多数时候，<code>xargs</code>命令都是跟管道一起使用的。但是，它也可以单独使用。</p>
<p>输入<code>xargs</code>按下回车以后，命令行就会等待用户输入，作为标准输入。你可以输入任意内容，然后按下<code>Ctrl d</code>，表示输入结束，这时<code>echo</code>命令就会把前面的输入打印出来。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ xargs
hello 
<span style="color:#f92672">(</span>Ctrl + d<span style="color:#f92672">)</span>
hello
</code></pre></div><p>再看一个例子。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ xargs find -name
<span style="color:#e6db74">&#34;*.txt&#34;</span>
./foo.txt
./hello.txt
</code></pre></div><p>上面的例子输入<code>xargs find -name</code>以后，命令行会等待用户输入所要搜索的文件。用户输入<code>&quot;*.txt&quot;</code>，表示搜索当前目录下的所有 TXT 文件，然后按下<code>Ctrl d</code>，表示输入结束。这时就相当执行<code>find -name *.txt</code>。</p>
<h4 id="-d-参数与分隔符">-d 参数与分隔符<a hidden class="anchor" aria-hidden="true" href="#-d-参数与分隔符">#</a></h4>
<p>默认情况下，<code>xargs</code>将换行符和空格作为分隔符，把标准输入分解成一个个命令行参数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ echo <span style="color:#e6db74">&#34;one two three&#34;</span> | xargs mkdir
</code></pre></div><p>上面代码中，<code>mkdir</code>会新建三个子目录，因为<code>xargs</code>将<code>one two three</code>分解成三个命令行参数，执行<code>mkdir one two three</code>。</p>
<p><code>-d</code>参数可以更改分隔符。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ echo -e <span style="color:#e6db74">&#34;a\tb\tc&#34;</span> | xargs -d <span style="color:#e6db74">&#34;\t&#34;</span> echo
a b c
</code></pre></div><p>上面的命令指定制表符<code>\t</code>作为分隔符，所以<code>a\tb\tc</code>就转换成了三个命令行参数。<code>echo</code>命令的<code>-e</code>参数表示解释转义字符。</p>
<h4 id="-p-参数-t-参数">-p 参数，-t 参数<a hidden class="anchor" aria-hidden="true" href="#-p-参数-t-参数">#</a></h4>
<p>使用<code>xargs</code>命令以后，由于存在转换参数过程，有时需要确认一下到底执行的是什么命令。</p>
<p><code>-p</code>参数打印出要执行的命令，询问用户是否要执行。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ echo <span style="color:#e6db74">&#39;one two three&#39;</span> | xargs -p touch
touch one two three ?...
</code></pre></div><p>上面的命令执行以后，会打印出最终要执行的命令，让用户确认。用户输入<code>y</code>以后（大小写皆可），才会真正执行。</p>
<p><code>-t</code>参数则是打印出最终要执行的命令，然后直接执行，不需要用户确认。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ echo <span style="color:#e6db74">&#39;one two three&#39;</span> | xargs -t rm
rm one two three
</code></pre></div><h4 id="-0-参数与-find-命令">-0 参数与 find 命令<a hidden class="anchor" aria-hidden="true" href="#-0-参数与-find-命令">#</a></h4>
<p>由于<code>xargs</code>默认将空格作为分隔符，所以不太适合处理文件名，因为文件名可能包含空格。</p>
<p><code>find</code>命令有一个特别的参数<code>-print0</code>，指定输出的文件列表以<code>null</code>分隔。然后，<code>xargs</code>命令的<code>-0</code>参数表示用<code>null</code>当作分隔符。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ find /path -type f -print0 | xargs -0 rm
</code></pre></div><p>上面命令删除<code>/path</code>路径下的所有文件。由于分隔符是<code>null</code>，所以处理包含空格的文件名，也不会报错。</p>
<p>还有一个原因，使得<code>xargs</code>特别适合<code>find</code>命令。有些命令（比如<code>rm</code>）一旦参数过多会报错&quot;参数列表过长&quot;，而无法执行，改用<code>xargs</code>就没有这个问题，因为它对每个参数执行一次命令。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ find . -name <span style="color:#e6db74">&#34;*.txt&#34;</span> | xargs grep <span style="color:#e6db74">&#34;abc&#34;</span>
</code></pre></div><p>上面命令找出所有 TXT 文件以后，对每个文件搜索一次是否包含字符串<code>abc</code>。</p>
<h4 id="-l-参数">-L 参数<a hidden class="anchor" aria-hidden="true" href="#-l-参数">#</a></h4>
<p>如果标准输入包含多行，<code>-L</code>参数指定多少行作为一个命令行参数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ xargs find -name
<span style="color:#e6db74">&#34;*.txt&#34;</span>
<span style="color:#e6db74">&#34;*.md&#34;</span>
find: paths must precede expression: <span style="color:#e6db74">`</span>*.md<span style="color:#960050;background-color:#1e0010">&#39;</span>
</code></pre></div><p>上面命令同时将<code>&quot;*.txt&quot;</code>和<code>*.md</code>两行作为命令行参数，传给<code>find</code>命令导致报错。</p>
<p>使用<code>-L</code>参数，指定每行作为一个命令行参数，就不会报错。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ xargs -L <span style="color:#ae81ff">1</span> find -name
<span style="color:#e6db74">&#34;*.txt&#34;</span>
./foo.txt
./hello.txt
<span style="color:#e6db74">&#34;*.md&#34;</span>
./README.md
</code></pre></div><p>上面命令指定了每一行（<code>-L 1</code>）作为命令行参数，分别运行一次命令（<code>find -name</code>）。</p>
<p>下面是另一个例子。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ echo -e <span style="color:#e6db74">&#34;a\nb\nc&#34;</span> | xargs -L <span style="color:#ae81ff">1</span> echo
a
b
c
</code></pre></div><p>上面代码指定每行运行一次<code>echo</code>命令，所以<code>echo</code>命令执行了三次，输出了三行。</p>
<h4 id="-n-参数">-n 参数<a hidden class="anchor" aria-hidden="true" href="#-n-参数">#</a></h4>
<p><code>-L</code>参数虽然解决了多行的问题，但是有时用户会在同一行输入多项。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ xargs find -name
<span style="color:#e6db74">&#34;*.txt&#34;</span> <span style="color:#e6db74">&#34;*.md&#34;</span>
find: paths must precede expression: <span style="color:#e6db74">`</span>*.md<span style="color:#960050;background-color:#1e0010">&#39;</span>
</code></pre></div><p>上面的命令将同一行的两项作为命令行参数，导致报错。</p>
<p><code>-n</code>参数指定每次将多少项，作为命令行参数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ xargs -n <span style="color:#ae81ff">1</span> find -name
</code></pre></div><p>上面命令指定将每一项（<code>-n 1</code>）标准输入作为命令行参数，分别执行一次命令（<code>find -name</code>）。</p>
<p>下面是另一个例子。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ echo <span style="color:#f92672">{</span>0..9<span style="color:#f92672">}</span> | xargs -n <span style="color:#ae81ff">2</span> echo
<span style="color:#ae81ff">0</span> <span style="color:#ae81ff">12</span> <span style="color:#ae81ff">34</span> <span style="color:#ae81ff">56</span> <span style="color:#ae81ff">78</span> <span style="color:#ae81ff">9</span>
</code></pre></div><p>上面命令指定，每两个参数运行一次<code>echo</code>命令。所以，10个阿拉伯数字运行了五次<code>echo</code>命令，输出了五行。</p>
<h4 id="-i-参数">-I 参数<a hidden class="anchor" aria-hidden="true" href="#-i-参数">#</a></h4>
<p>如果<code>xargs</code>要将命令行参数传给多个命令，可以使用<code>-I</code>参数。</p>
<p><code>-I</code>指定每一项命令行参数的替代字符串。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat foo.txt
one
two
three
$ cat foo.txt | xargs -I file sh -c <span style="color:#e6db74">&#39;echo file; mkdir file&#39;</span>
one 
two
three
$ ls
one two three
</code></pre></div><p>上面代码中，<code>foo.txt</code>是一个三行的文本文件。我们希望对每一项命令行参数，执行两个命令（<code>echo</code>和<code>mkdir</code>），使用<code>-I file</code>表示<code>file</code>是命令行参数的替代字符串。执行命令时，具体的参数会替代掉<code>echo file; mkdir file</code>里面的两个<code>file</code>。</p>
<h4 id="--max-procs-参数">&ndash;max-procs 参数<a hidden class="anchor" aria-hidden="true" href="#--max-procs-参数">#</a></h4>
<p><code>xargs</code>默认只用一个进程执行命令。如果命令要执行多次，必须等上一次执行完，才能执行下一次。</p>
<p><code>--max-procs</code>参数指定同时用多少个进程并行执行命令。<code>--max-procs 2</code>表示同时最多使用两个进程，<code>--max-procs 0</code>表示不限制进程数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ docker ps -q | xargs -n <span style="color:#ae81ff">1</span> --max-procs <span style="color:#ae81ff">0</span> docker kill
</code></pre></div><p>上面命令表示，同时关闭尽可能多的 Docker 容器，这样运行速度会快很多。</p>
<h3 id="awkhttpswwwruanyifengcomblog201811awkhtml"><a href="https://www.ruanyifeng.com/blog/2018/11/awk.html">awk</a><a hidden class="anchor" aria-hidden="true" href="#awkhttpswwwruanyifengcomblog201811awkhtml">#</a></h3>
<p><a href="https://en.wikipedia.org/wiki/AWK"><code>awk</code></a>是处理文本文件的一个应用程序，几乎所有 Linux 系统都自带这个程序。</p>
<p>它依次处理文件的每一行，并读取里面的每一个字段。对于日志、CSV 那样的每行格式相同的文本文件，<code>awk</code>可能是最方便的工具。</p>
<p><code>awk</code>其实不仅仅是工具软件，还是一种编程语言。不过，本文只介绍它的命令行用法，对于大多数场合，应该足够用了。</p>
<h4 id="基本用法-1">基本用法<a hidden class="anchor" aria-hidden="true" href="#基本用法-1">#</a></h4>
<p><code>awk</code>的基本用法就是下面的形式。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 格式</span>
$ awk 动作 文件名

<span style="color:#75715e"># 示例</span>
$ awk <span style="color:#e6db74">&#39;{print $0}&#39;</span> demo.txt
</code></pre></div><p>上面示例中，<code>demo.txt</code>是<code>awk</code>所要处理的文本文件。前面单引号内部有一个大括号，里面就是每一行的处理动作<code>print $0</code>。其中，<code>print</code>是打印命令，<code>$0</code>代表当前行，因此上面命令的执行结果，就是把每一行原样打印出来。</p>
<p>下面，我们先用标准输入（stdin）演示上面这个例子。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ echo <span style="color:#e6db74">&#39;this is a test&#39;</span> | awk <span style="color:#e6db74">&#39;{print $0}&#39;</span>
this is a test
</code></pre></div><p>上面代码中，<code>print $0</code>就是把标准输入<code>this is a test</code>，重新打印了一遍。</p>
<p><code>awk</code>会根据空格和制表符，将每一行分成若干字段，依次用<code>$1</code>、<code>$2</code>、<code>$3</code>代表第一个字段、第二个字段、第三个字段等等。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ echo <span style="color:#e6db74">&#39;this is a test&#39;</span> | awk <span style="color:#e6db74">&#39;{print $3}&#39;</span>
a
</code></pre></div><p>上面代码中，<code>$3</code>代表<code>this is a test</code>的第三个字段<code>a</code>。</p>
<p>下面，为了便于举例，我们把<code>/etc/passwd</code>文件保存成<code>demo.txt</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">root❌0:0:root:/root:/usr/bin/zsh
daemon❌1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin❌2:2:bin:/bin:/usr/sbin/nologin
sys❌3:3:sys:/dev:/usr/sbin/nologin
sync❌4:65534:sync:/bin:/bin/sync
</code></pre></div><p>这个文件的字段分隔符是冒号（<code>:</code>），所以要用<code>-F</code>参数指定分隔符为冒号。然后，才能提取到它的第一个字段。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ awk -F <span style="color:#e6db74">&#39;:&#39;</span> <span style="color:#e6db74">&#39;{ print $1 }&#39;</span> demo.txt
root
daemon
bin
sys
sync
</code></pre></div><h4 id="变量">变量<a hidden class="anchor" aria-hidden="true" href="#变量">#</a></h4>
<p>除了<code>$ + 数字</code>表示某个字段，<code>awk</code>还提供其他一些变量。</p>
<p>变量<code>NF</code>表示当前行有多少个字段，因此<code>$NF</code>就代表最后一个字段。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ echo <span style="color:#e6db74">&#39;this is a test&#39;</span> | awk <span style="color:#e6db74">&#39;{print $NF}&#39;</span>
test
</code></pre></div><p><code>$(NF-1)</code>代表倒数第二个字段。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ awk -F <span style="color:#e6db74">&#39;:&#39;</span> <span style="color:#e6db74">&#39;{print $1, $(NF-1)}&#39;</span> demo.txt
root /root
daemon /usr/sbin
bin /bin
sys /dev
sync /bin
</code></pre></div><p>上面代码中，<code>print</code>命令里面的逗号，表示输出的时候，两个部分之间使用空格分隔。</p>
<p>变量<code>NR</code>表示当前处理的是第几行。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ awk -F <span style="color:#e6db74">&#39;:&#39;</span> <span style="color:#e6db74">&#39;{print NR &#34;) &#34; $1}&#39;</span> demo.txt
1<span style="color:#f92672">)</span> root
2<span style="color:#f92672">)</span> daemon
3<span style="color:#f92672">)</span> bin
4<span style="color:#f92672">)</span> sys
5<span style="color:#f92672">)</span> sync
</code></pre></div><p>上面代码中，<code>print</code>命令里面，如果原样输出字符，要放在双引号里面。</p>
<p><code>awk</code>的其他内置变量如下。</p>
<ul>
<li><code>FILENAME</code>：当前文件名</li>
<li><code>FS</code>：字段分隔符，默认是空格和制表符。</li>
<li><code>RS</code>：行分隔符，用于分割每一行，默认是换行符。</li>
<li><code>OFS</code>：输出字段的分隔符，用于打印时分隔字段，默认为空格。</li>
<li><code>ORS</code>：输出记录的分隔符，用于打印时分隔记录，默认为换行符。</li>
<li><code>OFMT</code>：数字输出的格式，默认为<code>％.6g</code>。</li>
</ul>
<h4 id="函数-1">函数<a hidden class="anchor" aria-hidden="true" href="#函数-1">#</a></h4>
<p><code>awk</code>还提供了一些内置函数，方便对原始数据的处理。</p>
<p>函数<code>toupper()</code>用于将字符转为大写。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ awk -F <span style="color:#e6db74">&#39;:&#39;</span> <span style="color:#e6db74">&#39;{ print toupper($1) }&#39;</span> demo.txt
ROOT
DAEMON
BIN
SYS
SYNC
</code></pre></div><p>上面代码中，第一个字段输出时都变成了大写。</p>
<p>其他常用函数如下。</p>
<ul>
<li><code>tolower()</code>：字符转为小写。</li>
<li><code>length()</code>：返回字符串长度。</li>
<li><code>substr()</code>：返回子字符串。</li>
<li><code>sin()</code>：正弦。</li>
<li><code>cos()</code>：余弦。</li>
<li><code>sqrt()</code>：平方根。</li>
<li><code>rand()</code>：随机数。</li>
</ul>
<p><code>awk</code>内置函数的完整列表，可以查看<a href="https://www.gnu.org/software/gawk/manual/html_node/Built_002din.html#Built_002din">手册</a>。</p>
<h4 id="条件">条件<a hidden class="anchor" aria-hidden="true" href="#条件">#</a></h4>
<p><code>awk</code>允许指定输出条件，只输出符合条件的行。</p>
<p>输出条件要写在动作的前面。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ awk <span style="color:#e6db74">&#39;条件 动作&#39;</span> 文件名
</code></pre></div><p>请看下面的例子。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ awk -F <span style="color:#e6db74">&#39;:&#39;</span> <span style="color:#e6db74">&#39;/usr/ {print $1}&#39;</span> demo.txt
root
daemon
bin
sys
</code></pre></div><p>上面代码中，<code>print</code>命令前面是一个正则表达式，只输出包含<code>usr</code>的行。</p>
<p>下面的例子只输出奇数行，以及输出第三行以后的行。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 输出奇数行</span>
$ awk -F <span style="color:#e6db74">&#39;:&#39;</span> <span style="color:#e6db74">&#39;NR % 2 == 1 {print $1}&#39;</span> demo.txt
root
bin
sync

<span style="color:#75715e"># 输出第三行以后的行</span>
$ awk -F <span style="color:#e6db74">&#39;:&#39;</span> <span style="color:#e6db74">&#39;NR &gt;3 {print $1}&#39;</span> demo.txt
sys
sync
</code></pre></div><p>下面的例子输出第一个字段等于指定值的行。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ awk -F <span style="color:#e6db74">&#39;:&#39;</span> <span style="color:#e6db74">&#39;$1 == &#34;root&#34; {print $1}&#39;</span> demo.txt
root

$ awk -F <span style="color:#e6db74">&#39;:&#39;</span> <span style="color:#e6db74">&#39;$1 == &#34;root&#34; || $1 == &#34;bin&#34; {print $1}&#39;</span> demo.txt
root
bin
</code></pre></div><h4 id="if-语句">if 语句<a hidden class="anchor" aria-hidden="true" href="#if-语句">#</a></h4>
<p><code>awk</code>提供了<code>if</code>结构，用于编写复杂的条件。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ awk -F <span style="color:#e6db74">&#39;:&#39;</span> <span style="color:#e6db74">&#39;{if ($1 &gt; &#34;m&#34;) print $1}&#39;</span> demo.txt
root
sys
sync
</code></pre></div><p>上面代码输出第一个字段的第一个字符大于<code>m</code>的行。</p>
<p><code>if</code>结构还可以指定<code>else</code>部分。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ awk -F <span style="color:#e6db74">&#39;:&#39;</span> <span style="color:#e6db74">&#39;{if ($1 &gt; &#34;m&#34;) print $1; else print &#34;---&#34;}&#39;</span> demo.txt
root
---
---
sys
sync
</code></pre></div><h3 id="findhttpslinuxcnarticle-14071-1html"><a href="https://linux.cn/article-14071-1.html">find</a><a hidden class="anchor" aria-hidden="true" href="#findhttpslinuxcnarticle-14071-1html">#</a></h3>
<p><code>find</code> 命令由 <a href="https://pubs.opengroup.org/onlinepubs/9699919799.2018edition/">POSIX 规范</a> 定义，它创建了一个用于衡量 POSIX 系统的开放标准，这包括 Linux、BSD 和 macOS。简而言之，只要你运行的是 Linux、BSD 或 macOS，那么 <code>find</code> 已经安装了。</p>
<p>但是，并非所有的 <code>find</code> 命令都完全相同。例如，GNU 的 <code>find</code> 命令有一些 BSD、Busybox 或 Solaris 上 <code>find</code> 命令可能没有或有但实现方式不同的功能。本文使用 <a href="https://www.gnu.org/software/findutils/">findutils</a> 包中的 GNU <code>find</code>，因为它很容易获得且非常流行。本文演示的大多数命令都适用于 <code>find</code> 的其他实现，但是如果你在 Linux 以外的平台上尝试命令并得到非预期结果，尝试下载并安装 GNU 版本。</p>
<p>man文档中给出的find命令的一般形式为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">find <span style="color:#f92672">[</span>-H<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>-L<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>-P<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>-D debugopts<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>-Olevel<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>path...<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>expression<span style="color:#f92672">]</span>
</code></pre></div><p>其实[-H] [-L] [-P] [-D debugopts] [-Olevel]这几个选项并不常用（至少在我的日常工作中，没有用到过），上面的find命令的常用形式可以简化为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">find <span style="color:#f92672">[</span>path...<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>expression<span style="color:#f92672">]</span>
</code></pre></div><ul>
<li>
<p>path：find命令所查找的目录路径。例如用<code>.</code>来表示当前目录，用<code>/</code>来表示系统根目录</p>
</li>
<li>
<p>expression：expression可以分为——“-options [-print -exec -ok &hellip;]”</p>
</li>
<li>
<ul>
<li><code>-options</code>，指定find命令的常用选项</li>
<li><code>-print</code>，find命令将匹配的文件输出到标准输出</li>
<li><code>-exec</code>，find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为<code>'command' { } \;</code>，注意{  }和\；之间的空格
<code>find ./ -size 0 -exec rm {} \;</code> 删除文件大小为零的文件 （还可以以这样做：<code>rm -i find ./ -size 0</code>  或 <code>find ./ -size 0 | xargs rm -f &amp;） </code></li>
<li>为了用ls -l命令列出所匹配到的文件，可以把ls -l命令放在find命令的-exec选项中：<code>find . -type f -exec ls -l { } \;</code>
在/logs目录中查找更改时间在5日以前的文件并删除它们：<code>find /logs -type f -mtime +5 -exec rm { } \;</code></li>
<li><code>-ok</code>，和<code>-exec</code>的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。
<code>find . -name &quot;*.conf&quot; -mtime +5 -ok rm { } \;</code> 在当前目录中查找所有文件名以.LOG结尾、更改时间在5日以上的文件，并删除它们，只不过在删除之前先给出提示</li>
</ul>
</li>
</ul>
<p>也有人这样总结find命令的结构：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">find start_directory
      options
      criteria_to_match
      action_to_perform_on_results
</code></pre></div><h4 id="常用选项httpslinuxcnarticle-1672-1html"><a href="https://linux.cn/article-1672-1.html">常用选项</a><a hidden class="anchor" aria-hidden="true" href="#常用选项httpslinuxcnarticle-1672-1html">#</a></h4>
<ul>
<li><code>-name </code>
按照文件名查找文件。
<code>find /dir -name filename </code> 在/dir目录及其子目录下面查找名字为filename的文件
<code>find . -name &quot;*.c&quot;</code> 在当前目录及其子目录（用“.”表示）中查找任何扩展名为“c”的文件</li>
<li><code>-perm</code>
按照文件权限来查找文件。
<code>find . -perm 755 –print</code> 在当前目录下查找文件权限位为755的文件，即文件属主可以读、写、执行，其它用户可以读、执行的文件</li>
<li><code>-prune </code>
使用这一选项可以使find命令不在当前指定的目录中查找，如果同时使用-depth选项，那么-prune将被find命令忽略。
<code>find /apps -path &quot;/apps/bin&quot; -prune -o –print </code>在/apps目录下查找文件，但不希望在/apps/bin目录下查找
<code>find /usr/sam -path &quot;/usr/sam/dir1&quot; -prune -o –print</code> 在/usr/sam目录下查找不在dir1子目录之内的所有文件</li>
<li><code>-user </code>
按照文件属主来查找文件。
<code>find ~ -user sam –print</code> 在$HOME目录中查找文件属主为sam的文件</li>
<li><code>-group </code>
按照文件所属的组来查找文件。
<code>find /apps -group gem –print</code> 在/apps目录下查找属于gem用户组的文件</li>
<li><code>-mtime -n +n </code>
按照文件的更改时间来查找文件， - n表示文件更改时间距现在n天以内，+ n表示文件更改时间距现在n天以前。
<code>find / -mtime -5 –print </code>在系统根目录下查找更改时间在5日以内的文件
<code>find /var/adm -mtime +3 –print</code> 在/var/adm目录下查找更改时间在3日以前的文件</li>
<li><code>-nogroup </code>
查找无有效所属组的文件，即该文件所属的组在/etc/groups中不存在。
<code>find / –nogroup -print</code></li>
<li><code>-nouser </code>
查找无有效属主的文件，即该文件的属主在/etc/passwd中不存在。
<code>find /home -nouser –print</code></li>
<li><code>-newer file1 ! file2 </code>
查找更改时间比文件file1新但比文件file2旧的文件。</li>
<li><code>-type </code>
查找某一类型的文件，诸如：
b - 块设备文件。
d - 目录。
c - 字符设备文件。
p - 管道文件。
l - 符号链接文件。
f - 普通文件。
<code>find /etc -type d –print</code> 在/etc目录下查找所有的目录
<code>find . ! -type d –print</code> 在当前目录下查找除目录以外的所有类型的文件
<code>find /etc -type l –print</code> 在/etc目录下查找所有的符号链接文件</li>
<li><code>-size n</code>：[c] 查找文件长度为n块的文件，带有c时表示文件长度以字节计。
<code>find . -size +1000000c –print</code> 在当前目录下查找文件长度大于1 M字节的文件
<code>find /home/apache -size 100c –print</code> 在/home/apache目录下查找文件长度恰好为100字节的文件
<code>find . -size +10 –print</code> 在当前目录下查找长度超过10块的文件（一块等于512字节）</li>
<li><code>-depth</code>：在查找文件时，首先查找当前目录中的文件，然后再在其子目录中查找。
<code>find / -name &quot;CON.FILE&quot; -depth –print</code> 它将首先匹配所有的文件然后再进入子目录中查找</li>
<li><code>-mount</code>：在查找文件时不跨越文件系统mount点。
<code>find . -name &quot;*.XC&quot; -mount –print</code> 从当前目录开始查找位于本文件系统中文件名以XC结尾的文件（不进入其它文件系统）</li>
<li><code>-follow</code>：如果find命令遇到符号链接文件，就跟踪至链接所指向的文件。</li>
</ul>
<h4 id="按名称查找文件">按名称查找文件<a hidden class="anchor" aria-hidden="true" href="#按名称查找文件">#</a></h4>
<p>你可以借助正则表达式使用完整或部分的文件名来定位文件。<code>find</code> 命令需要你给出想搜索的目录；指定搜索属性选项，例如，<code>-name</code> 用于指定区分大小写的文件名；然后是搜索字符串。默认情况下，搜索字符串按字面意思处理：除非你使用正则表达式语法，否则 <code>find</code> 命令搜索的文件名正是你在引号之间输入的字符串。</p>
<p>假设你的 <code>Documents</code> 目录包含四个文件：<code>Foo</code>、<code>foo</code>、<code>foobar.txt</code> 和 <code>foo.xml</code>。以下是对 <code>foo</code> 的字面搜索：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ find ~ -name <span style="color:#e6db74">&#34;foo&#34;</span>
/home/tux/Documents/examples/foo
</code></pre></div><p>你可以使用 <code>-iname</code> 选项使其不区分大小写来扩大搜索范围：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ find ~ -iname <span style="color:#e6db74">&#34;foo&#34;</span>
/home/tux/Documents/examples/foo
/home/tux/Documents/examples/Foo
</code></pre></div><h4 id="通配符">通配符<a hidden class="anchor" aria-hidden="true" href="#通配符">#</a></h4>
<p>你可以使用基本的 shell 通配符来扩展搜索。例如，<code>*</code> 表示任意数量的字符：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ find ~ -iname <span style="color:#e6db74">&#34;foo*&#34;</span>
/home/tux/Documents/examples/foo
/home/tux/Documents/examples/Foo
/home/tux/Documents/examples/foo.xml
/home/tux/Documents/examples/foobar.txt
</code></pre></div><p><code>?</code> 表示单个字符：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ find ~ -iname <span style="color:#e6db74">&#34;foo*.???&#34;</span>
/home/tux/Documents/examples/foo.xml
/home/tux/Documents/examples/foobar.txt
</code></pre></div><p>这不是正则表达式语法，因此 <code>.</code> 在示例中只表示字母“点”。</p>
<h4 id="正则表达式">正则表达式<a hidden class="anchor" aria-hidden="true" href="#正则表达式">#</a></h4>
<p>你还可以使用正则表达式。与 <code>-iname</code> 和 <code>-name</code> 一样，也有区分大小写和不区分大小写的选项。但不一样的是，<code>-regex</code> 和 <code>-iregex</code> 搜索应用于整个路径，而不仅仅是文件名。这意味着，如果你搜索 <code>foo</code>，你不会得到任何结果，因为 <code>foo</code> 与 <code>/home/tux/Documents/foo</code> 不匹配。相反，你必须要么搜索整个路径，要么在字符串的开头使用通配符：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ find ~ -iregex <span style="color:#e6db74">&#34;.*foo&#34;</span>
/home/tux/Documents/examples/foo
/home/tux/Documents/examples/Foo
</code></pre></div><h4 id="查找近一周修改过的文件">查找近一周修改过的文件<a hidden class="anchor" aria-hidden="true" href="#查找近一周修改过的文件">#</a></h4>
<p>要查找近一周修改的文件，使用 <code>-mtime</code> 选项以及过去的天数（负数）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ find ~ -mtime -7
/home/tux/Documents/examples/foo
/home/tux/Documents/examples/Foo
/home/tux/Documents/examples/foo.xml
/home/tux/Documents/examples/foobar.txt
</code></pre></div><h4 id="查找近几天修改的文件">查找近几天修改的文件<a hidden class="anchor" aria-hidden="true" href="#查找近几天修改的文件">#</a></h4>
<p>你可以结合使用 <code>-mtime</code> 选项来查找近几天范围内修改的文件。对于第一个 <code>-mtime</code> 参数，表示上一次修改文件的最近天数。第二个参数表示最大天数。例如，搜索修改时间超过 1 天但不超过 7 天的文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ find ~ -mtime +1 -mtime -7
</code></pre></div><h4 id="按文件类型限制搜索">按文件类型限制搜索<a hidden class="anchor" aria-hidden="true" href="#按文件类型限制搜索">#</a></h4>
<p>指定查找文件的类型来优化 <code>find</code> 的结果是很常见的。如果你不确定要查找的内容，则不应该使用此选项。但如果你知道要查找的是文件而不是目录，或者是目录而不是文件，那么这可能是一个很好的过滤器。选项是 <code>-type</code>，它的参数是代表不同类型数据的字母代码。最常见的是：</p>
<ul>
<li><code>d</code> - 目录</li>
<li><code>f</code> - 文件</li>
<li><code>l</code> - 链接文件</li>
<li><code>s</code> - 套接字</li>
<li><code>p</code> - 命名管道（用于 FIFO）</li>
<li><code>b</code> - 块设备（通常是硬盘）</li>
</ul>
<p>下面是一些例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ find ~ -type d -name <span style="color:#e6db74">&#34;Doc*&#34;</span>
/home/tux/Documents
$ find ~ -type f -name <span style="color:#e6db74">&#34;Doc*&#34;</span>
/home/tux/Downloads/10th-Doctor.gif
$ find /dev -type b -name <span style="color:#e6db74">&#34;sda*&#34;</span>
/dev/sda/dev/sda1
</code></pre></div><h4 id="调整范围">调整范围<a hidden class="anchor" aria-hidden="true" href="#调整范围">#</a></h4>
<p><code>find</code> 命令默认是递归的，这意味着它会在指定的目录中层层搜索结果。这在大型文件系统中可能会变得不堪重负，但你可以使用 <code>-maxdepth</code> 选项来控制搜索深度：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ find /usr -iname <span style="color:#e6db74">&#34;*xml&#34;</span> | wc -l
<span style="color:#ae81ff">15588</span>
$ find /usr -maxdepth <span style="color:#ae81ff">2</span> -iname <span style="color:#e6db74">&#34;*xml&#34;</span> | wc -l
<span style="color:#ae81ff">15</span>
</code></pre></div><p>也可以使用 <code>-mindepth</code> 设置最小递归深度：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ find /usr -mindepth <span style="color:#ae81ff">8</span> -iname <span style="color:#e6db74">&#34;*xml&#34;</span> | wc -l
<span style="color:#ae81ff">9255</span>
</code></pre></div><h4 id="与-xargs">与 xargs<a hidden class="anchor" aria-hidden="true" href="#与-xargs">#</a></h4>
<p>在使用find命令的-exec选项处理匹配到的文件时， find命令将所有匹配到的文件一起传递给exec执行。但有些系统对能够传递给exec的命令长度有限制，这样在find命令运行几分钟之后，就会出现溢出错误。错误信息通常是“参数列太长”或“参数列溢出”。这就是xargs命令的用处所在，特别是与find命令一起使用。</p>
<p>find命令把匹配到的文件传递给xargs命令，而xargs命令每次只获取一部分文件而不是全部，不像-exec选项那样。这样它可以先处理最先获取的一部分文件，然后是下一批，并如此继续下去。</p>
<p>在有些系统中，使用-exec选项会为处理每一个匹配到的文件而发起一个相应的进程，并非将匹配到的文件全部作为参数一次执行；这样在有些情况下就会出现进程过多，系统性能下降的问题，因而效率不高；</p>
<p>而使用xargs命令则只有一个进程。另外，在使用xargs命令时，究竟是一次获取所有的参数，还是分批取得参数，以及每一次获取参数的数目都会根据该命令的选项及系统内核中相应的可调参数来确定。</p>
<p>来看看xargs命令是如何同find命令一起使用的，并给出一些例子。</p>
<p><code>find . -type f -print | xargs file </code>查找系统中的每一个普通文件，然后使用xargs命令来测试它们分别属于哪类文件</p>
<p><code>find / -name &quot;core&quot; -print | xargs echo &quot;&quot; &gt;/tmp/core.log</code> 在整个系统中查找内存信息转储文件(core dump) ，然后把结果保存到/tmp/core.log 文件中：</p>
<p><code>find . -type f -print | xargs grep &quot;hostname&quot;</code> 用grep命令在所有的普通文件中搜索hostname这个词</p>
<p><code>find ./ -mtime +3 -print|xargs rm -f –r </code>删除3天以前的所有东西 （<code>find . -ctime +3 -exec rm -rf {} \;</code>）</p>
<p><code>find ./ -size 0 | xargs rm -f &amp;</code> 删除文件大小为零的文件</p>
<p>find命令配合使用exec和xargs可以使用户对所匹配到的文件执行几乎所有的命令。</p>
<h4 id="fdhttpsgithubcomsharkdpfd"><a href="https://github.com/sharkdp/fd">fd</a><a hidden class="anchor" aria-hidden="true" href="#fdhttpsgithubcomsharkdpfd">#</a></h4>
<p>fd 命令是一个流行的、用户友好的 find 命令的替代品。</p>
<h3 id="grephttpslinuxcnarticle-6927-1html"><a href="https://linux.cn/article-6927-1.html">grep</a><a hidden class="anchor" aria-hidden="true" href="#grephttpslinuxcnarticle-6927-1html">#</a></h3>
<p>grep (global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来)是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p>
<p>grep 这个名字，来源于一个 Unix/Linux 中的古老的行编辑器 <a href="https://en.wikipedia.org/wiki/Ed_(text_editor)">ed</a> 中执行相似操作的命令：</p>
<pre tabindex="0"><code>g/re/p
</code></pre><p>语法如下所示:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">grep <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> PATTERN <span style="color:#f92672">[</span>FILE...<span style="color:#f92672">]</span> 
grep <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>-e PATTERN | -f FILE<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>FILE...<span style="color:#f92672">]</span>
</code></pre></div><p>grep命令用于搜索由Pattern参数指定的模式，并将每个匹配的行写入标准输出中。这些模式是具有限定的正则表达式，它们使用ed或egrep命令样式。</p>
<p>如果在File参数中指定了多个名称，grep命令将显示包含匹配行的文件的名称。</p>
<p>对 shell 有特殊含义的字符 ($, *, [, |, ^, (, ), \ ) 出现在 Pattern参数中时必须带双引号。如果 Pattern参数不是简单字符串，通常必须用单引号将整个模式括起来。在诸如 [a-z], 之类的表达式中，-（减号）cml 可根据当前正在整理的序列来指定一个范围。整理序列可以定义等价的类以供在字符范围中使用。</p>
<p>如果未指定任何文件，grep会假定为标准输入。</p>
<h4 id="基本集httpslinuxcnarticle-1672-1html"><a href="https://linux.cn/article-1672-1.html">基本集</a><a hidden class="anchor" aria-hidden="true" href="#基本集httpslinuxcnarticle-1672-1html">#</a></h4>
<p>grep正则表达式元字符集：</p>
<ul>
<li><code>^</code> 锚定行的开始 如：<code>'^grep'</code>匹配所有以grep开头的行。</li>
<li><code>$</code> 锚定行的结束 如：<code>'grep$'</code>匹配所有以grep结尾的行。</li>
<li><code>.</code>  匹配一个非换行符的字符 如：<code>'gr.p'</code>匹配gr后接一个任意字符，然后是p。</li>
<li><code>*</code> 匹配零个或多个先前字符 如：<code>' *grep'</code>匹配所有一个或多个空格后紧跟grep的行。 <code>.*</code>一起用代表任意字符。</li>
<li><code>[]</code> 匹配一个指定范围内的字符，如<code>'[Gg]rep'</code>匹配Grep和grep。</li>
<li><code>[^] </code> 匹配一个不在指定范围内的字符，如：<code>'[^A-FH-Z]rep'</code>匹配不包含A-F和H-Z的一个字母开头，紧跟rep的行。</li>
<li><code>\(..\)</code> 标记匹配字符，如：<code>'\(love\)'</code>，love被标记为1。</li>
<li><code>\&lt;</code> 锚定单词的开始，如：<code>'\</code></li>
<li><code>\&gt;</code> 锚定单词的结束，如<code>grep\&gt;'</code>匹配包含以grep结尾的单词的行。</li>
<li><code>x\{m\}</code> 连续重复字符x，m次，如：<code>'o\{5\}'</code>匹配包含连续5个o的行。</li>
<li><code>x\{m,\}</code> 连续重复字符x,至少m次，如：<code>'o\{5,\}'</code>匹配至少连续有5个o的行。</li>
<li><code>x\{m,n\}</code> 连续重复字符x，至少m次，不多于n次，如：<code>'o\{5,10\}'</code>匹配连续5&ndash;10个o的行。</li>
<li><code>\w</code> 匹配一个文字和数字字符，也就是[A-Za-z0-9]，如：<code>'G\w*p'</code>匹配以G后跟零个或多个文字或数字字符，然后是p。</li>
<li><code>\W </code> w的反置形式，匹配一个非单词字符，如点号句号等。<code>\W*</code>则可匹配多个。</li>
<li><code>\b</code> 单词锁定符，如: <code>'\bgrep\b'</code>只匹配grep，即只能是grep这个单词，两边均为空格。</li>
</ul>
<h4 id="常用选项-1">常用选项<a hidden class="anchor" aria-hidden="true" href="#常用选项-1">#</a></h4>
<pre tabindex="0"><code>-?
</code></pre><p>同时显示匹配行上下的？行，如：grep -2 pattern filename同时显示匹配行的上下2行。</p>
<pre tabindex="0"><code>-b，--byte-offset
</code></pre><p>打印匹配行前面打印该行所在的块号码。</p>
<pre tabindex="0"><code>-c,--count
</code></pre><p>只打印匹配的行数，不显示匹配的内容。</p>
<pre tabindex="0"><code>-f File，--file=File
</code></pre><p>从文件中提取模板。空文件中包含0个模板，所以什么都不匹配。</p>
<pre tabindex="0"><code>-h，--no-filename
</code></pre><p>当搜索多个文件时，不显示匹配文件名前缀。</p>
<pre tabindex="0"><code>-i，--ignore-case
</code></pre><p>忽略大小写差别。</p>
<pre tabindex="0"><code>-q，--quiet
</code></pre><p>取消显示，只返回退出状态。0则表示找到了匹配的行。</p>
<pre tabindex="0"><code>-l，--files-with-matches
</code></pre><p>打印匹配模板的文件清单。</p>
<pre tabindex="0"><code>-L，--files-without-match
</code></pre><p>打印不匹配模板的文件清单。</p>
<pre tabindex="0"><code>-n，--line-number
</code></pre><p>在匹配的行前面打印行号。</p>
<pre tabindex="0"><code>-s，--silent
</code></pre><p>不显示关于不存在或者无法读取文件的错误信息。</p>
<pre tabindex="0"><code>-v，--revert-match
</code></pre><p>反检索，只显示不匹配的行。</p>
<pre tabindex="0"><code>-w，--word-regexp
</code></pre><p>如果被\引用，就把表达式做为一个单词搜索。</p>
<pre tabindex="0"><code>-V，--version
</code></pre><p>显示软件版本信息。</p>
<h4 id="怎么样使用-grep-来搜索一个文件">怎么样使用 grep 来搜索一个文件<a hidden class="anchor" aria-hidden="true" href="#怎么样使用-grep-来搜索一个文件">#</a></h4>
<p>搜索 /etc/passwd 文件下的 boo 用户,输入:</p>
<pre tabindex="0"><code>$ grep boo /etc/passwd
</code></pre><p>输出内容:</p>
<pre tabindex="0"><code>foo❌1000:1000:foo,,,:/home/foo:/bin/ksh
</code></pre><p>可以使用 grep 去强制忽略大小写。例如，使用 -i 选项可以匹配 boo, Boo, BOO 和其他组合：</p>
<pre tabindex="0"><code>$ grep -i &quot;boo&quot; /etc/passwd
</code></pre><h4 id="递归使用-grep">递归使用 grep<a hidden class="anchor" aria-hidden="true" href="#递归使用-grep">#</a></h4>
<p>你可以递归地使用 grep 进行搜索。例如，在文件目录下面搜索所有包含字符串“192.168.1.5”的文件</p>
<pre tabindex="0"><code>$ grep -r &quot;192.168.1.5&quot; /etc/
</code></pre><p>或者是：</p>
<pre tabindex="0"><code>$ grep -R &quot;192.168.1.5&quot; /etc/
</code></pre><p>示例输出:</p>
<pre tabindex="0"><code>/etc/ppp/options:# ms-wins 192.168.1.50/etc/ppp/options:# ms-wins 192.168.1.51/etc/NetworkManager/system-connections/Wired connection 1:addresses1=192.168.1.5;24;192.168.1.2;
</code></pre><p>你会看到搜索到 192.168.1.5 的结果每一行都前缀以找到匹配的文件名（例如：/etc/ppp/options）。输出之中包含的文件名可以加 -h 选项来禁止输出：</p>
<pre tabindex="0"><code>$ grep -h -R &quot;192.168.1.5&quot; /etc/
</code></pre><p>或者</p>
<pre tabindex="0"><code>$ grep -hR &quot;192.168.1.5&quot; /etc/
</code></pre><p>示例输出:</p>
<pre tabindex="0"><code># ms-wins 192.168.1.50# ms-wins 192.168.1.51addresses1=192.168.1.5;24;192.168.1.2;
</code></pre><h4 id="使用-grep-去搜索文本">使用 grep 去搜索文本<a hidden class="anchor" aria-hidden="true" href="#使用-grep-去搜索文本">#</a></h4>
<p>当你搜索 boo 时，grep 命令将会匹配 fooboo，boo123, barfoo35 和其他所有包含 boo 的字符串，你可以使用 -w 选项去强制只输出那些仅仅包含那个整个单词的行（LCTT译注：即该字符串两侧是英文单词分隔符，如空格，标点符号，和末端等，因此对中文这种没有断字符号的语言并不适用。）。</p>
<pre tabindex="0"><code>$ grep -w &quot;boo&quot; file
</code></pre><h4 id="使用-grep-命令去搜索两个不同的单词">使用 grep 命令去搜索两个不同的单词<a hidden class="anchor" aria-hidden="true" href="#使用-grep-命令去搜索两个不同的单词">#</a></h4>
<p>使用 egrep 命令如下:</p>
<pre tabindex="0"><code>$ egrep -w 'word1|word2' /path/to/file
</code></pre><p>（LCTT 译注：这里使用到了正则表达式，因此使用的是 egrep 命令，即扩展的 grep 命令。）</p>
<h4 id="统计文本匹配到的行数">统计文本匹配到的行数<a hidden class="anchor" aria-hidden="true" href="#统计文本匹配到的行数">#</a></h4>
<p>grep 命令可以通过加 -c 参数显示每个文件中匹配到的次数：</p>
<pre tabindex="0"><code>$ grep -c 'word' /path/to/file
</code></pre><p>传递 -n 选项可以输出的行前加入匹配到的行的行号：</p>
<pre tabindex="0"><code>$ grep -n 'root' /etc/passwd
</code></pre><p>示例输出:</p>
<pre tabindex="0"><code>1:root:x:0:0:root:/root:/bin/bash1042:rootdoor:x:0:0:rootdoor:/home/rootdoor:/bin/csh3319:initrootapp:x:0:0:initrootapp:/home/initroot:/bin/ksh
</code></pre><h4 id="反转匹配不匹配">反转匹配（不匹配）<a hidden class="anchor" aria-hidden="true" href="#反转匹配不匹配">#</a></h4>
<p>可以使用 -v 选项来输出不包含匹配项的内容，输出内容仅仅包含那些不含给定单词的行，例如输出所有不包含 bar 单词的行：</p>
<pre tabindex="0"><code>$ grep -v bar /path/to/file
</code></pre><h4 id="unixlinux-管道与-grep-命令">UNIX/Linux 管道与 grep 命令<a hidden class="anchor" aria-hidden="true" href="#unixlinux-管道与-grep-命令">#</a></h4>
<p>grep 常常与管道一起使用，在这个例子中，显示硬盘设备的名字：</p>
<pre tabindex="0"><code># dmesg | egrep '(s|h)d[a-z]'
</code></pre><p>显示 CPU 型号：</p>
<pre tabindex="0"><code># cat /proc/cpuinfo | grep -i 'Model'
</code></pre><p>然而，以上命令也可以按照以下方法使用，不使用管道:</p>
<pre tabindex="0"><code># grep -i 'Model' /proc/cpuinfo
</code></pre><p>示例输出:</p>
<pre tabindex="0"><code>model       : 30model name  : Intel(R) Core(TM) i7 CPU       Q 820  @ 1.73GHzmodel       : 30model name  : Intel(R) Core(TM) i7 CPU       Q 820  @ 1.73GHz
</code></pre><h4 id="如何仅仅显示匹配到内容的文件名字">如何仅仅显示匹配到内容的文件名字?<a hidden class="anchor" aria-hidden="true" href="#如何仅仅显示匹配到内容的文件名字">#</a></h4>
<p>使用 -l 选项去显示那些文件内容中包含 main() 的文件名：</p>
<pre tabindex="0"><code>$ grep -l 'main' *.c
</code></pre><p>最后，你可以强制 grep 以彩色输出：</p>
<pre tabindex="0"><code>$ grep --color vivek /etc/passwd
</code></pre><h4 id="查找文件内容httpswwwrunoobcomnote48437"><a href="https://www.runoob.com/note/48437">查找文件内容</a><a hidden class="anchor" aria-hidden="true" href="#查找文件内容httpswwwrunoobcomnote48437">#</a></h4>
<p>从根目录开始查找所有扩展名为 .log 的文本文件，并找出包含 &ldquo;ERROR&rdquo; 的行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ find / -type f -name <span style="color:#e6db74">&#34;*.log&#34;</span> | xargs grep <span style="color:#e6db74">&#34;ERROR&#34;</span>
</code></pre></div><p>例子：从当前目录开始查找所有扩展名为 .in 的文本文件，并找出包含 &ldquo;thermcontact&rdquo; 的行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ find . -name <span style="color:#e6db74">&#34;*.in&#34;</span> | xargs grep <span style="color:#e6db74">&#34;thermcontact&#34;</span>
</code></pre></div><h3 id="cat">cat<a hidden class="anchor" aria-hidden="true" href="#cat">#</a></h3>
<h4 id="bathttpsgithubcomsharkdpbat"><a href="https://github.com/sharkdp/bat">bat</a><a hidden class="anchor" aria-hidden="true" href="#bathttpsgithubcomsharkdpbat">#</a></h4>
<p>A cat(1) clone with wings.</p>
<p>添加了语法高亮和 Git 集成等功能，并且还提供了分页选项。</p>
<h3 id="iphttpslinuxcnarticle-3144-1html"><a href="https://linux.cn/article-3144-1.html">ip</a><a hidden class="anchor" aria-hidden="true" href="#iphttpslinuxcnarticle-3144-1html">#</a></h3>
<p>linux的<strong>ip</strong>命令和<strong>ifconfig</strong>类似，但前者功能更强大，并旨在取代后者。使用ip命令，只需一个命令，你就能很轻松地执行一些网络管理任务。ifconfig是net-tools中已被废弃使用的一个命令，许多年前就已经没有维护了。iproute2套件里提供了许多增强功能的命令，ip命令即是其中之一。</p>
<p><img loading="lazy" src="/Distributions/003404uy9l1t5zayzllylm.png" alt="003404uy9l1t5zayzllylm"  />
</p>
<h4 id="设置和删除ip地址">设置和删除Ip地址<a hidden class="anchor" aria-hidden="true" href="#设置和删除ip地址">#</a></h4>
<p>要给你的机器设置一个IP地址，可以使用下列ip命令：</p>
<pre tabindex="0"><code>$ sudo ip addr add 192.168.0.193/24 dev wlan0
</code></pre><p>请注意IP地址要有一个后缀，比如/24。这种用法用于在无类域内路由选择（CIDR）中来显示所用的子网掩码。在这个例子中，子网掩码是255.255.255.0。</p>
<p>在你按照上述方式设置好IP地址后，需要查看是否已经生效。</p>
<pre tabindex="0"><code>$ ip addr show wlan0
</code></pre><p>你也可以使用相同的方式来删除IP地址，只需用del代替add。</p>
<pre tabindex="0"><code>$ sudo ip addr del 192.168.0.193/24 dev wlan0
</code></pre><h4 id="列出路由表条目">列出路由表条目<a hidden class="anchor" aria-hidden="true" href="#列出路由表条目">#</a></h4>
<p>ip命令的路由对象的参数还可以帮助你查看网络中的路由数据，并设置你的路由表。第一个条目是默认的路由条目，你可以随意改动它。</p>
<p>在这个例子中，有几个路由条目。这个结果显示有几个设备通过不同的网络接口连接起来。它们包括WIFI、以太网和一个点对点连接。</p>
<pre tabindex="0"><code>$ ip route show
</code></pre><p>假设现在你有一个IP地址，你需要知道路由包从哪里来。可以使用下面的路由选项（译注：列出了路由所使用的接口等）：</p>
<pre tabindex="0"><code>$ ip route get 10.42.0.47
</code></pre><h4 id="更改默认路由">更改默认路由<a hidden class="anchor" aria-hidden="true" href="#更改默认路由">#</a></h4>
<p>要更改默认路由，使用下面ip命令：</p>
<pre tabindex="0"><code>$ sudo ip route add default via 192.168.0.196
</code></pre><h4 id="显示网络统计数据">显示网络统计数据<a hidden class="anchor" aria-hidden="true" href="#显示网络统计数据">#</a></h4>
<p>使用ip命令还可以显示不同网络接口的统计数据。</p>
<p>当你需要获取一个特定网络接口的信息时，在网络接口名字后面添加选项<strong>ls</strong>即可。使用多个选项**-s**会给你这个特定接口更详细的信息。特别是在排除网络连接故障时，这会非常有用。</p>
<pre tabindex="0"><code>$ ip -s -s link ls p2p1
</code></pre><h4 id="arp条目">ARP条目<a hidden class="anchor" aria-hidden="true" href="#arp条目">#</a></h4>
<p>地址解析协议（ARP）用于将一个IP地址转换成它对应的物理地址，也就是通常所说的MAC地址。使用ip命令的neigh或者neighbour选项，你可以查看接入你所在的局域网的设备的MAC地址。</p>
<pre tabindex="0"><code>$ ip neighbour
</code></pre><h4 id="监控netlink消息">监控netlink消息<a hidden class="anchor" aria-hidden="true" href="#监控netlink消息">#</a></h4>
<p>也可以使用ip命令查看netlink消息。monitor选项允许你查看网络设备的状态。比如，所在局域网的一台电脑根据它的状态可以被分类成REACHABLE或者STALE。使用下面的命令：</p>
<pre tabindex="0"><code>$ ip monitor all
</code></pre><h4 id="激活和停止网络接口">激活和停止网络接口<a hidden class="anchor" aria-hidden="true" href="#激活和停止网络接口">#</a></h4>
<p>你可以使用ip命令的up和down选项来激某个特定的接口，就像ifconfig的用法一样。</p>
<p>在这个例子中，当ppp0接口被激活和在它被停止和再次激活之后，你可以看到相应的路由表条目。这个接口可能是wlan0或者eth0。将ppp0更改为你可用的任意接口即可。</p>
<pre tabindex="0"><code>$ sudo ip link set ppp0 down 
$ sudo ip link set ppp0 up
</code></pre><h4 id="获取帮助">获取帮助<a hidden class="anchor" aria-hidden="true" href="#获取帮助">#</a></h4>
<p>当你陷入困境，不知道某一个特定的选项怎么用的时候，你可以使用help选项。man页面并不会提供许多关于如何使用ip选项的信息，因此这里就是获取帮助的地方。</p>
<p>比如，想知道关于route选项更多的信息：</p>
<pre tabindex="0"><code>$ ip route help
</code></pre><h4 id="小结">小结<a hidden class="anchor" aria-hidden="true" href="#小结">#</a></h4>
<p>对于网络管理员们和所有的Linux使用者们，ip命令是必备工具。是时候抛弃ifconfig命令了，特别是当你写脚本时。</p>
<h3 id="dighttpslinuxcnarticle-14051-1html"><a href="https://linux.cn/article-14051-1.html">dig</a><a hidden class="anchor" aria-hidden="true" href="#dighttpslinuxcnarticle-14051-1html">#</a></h3>
<p>使用 <code>dig</code> 来进行 DNS 查询。</p>
<h4 id="参数类型查询和格式化">参数类型：查询和格式化<a hidden class="anchor" aria-hidden="true" href="#参数类型查询和格式化">#</a></h4>
<p>有两种主要的参数可以传递给 <code>dig</code>：</p>
<ol>
<li>告诉 <code>dig</code> <strong>要进行什么 DNS 查询的参数</strong>。</li>
<li>告诉 <code>dig</code> 如何 <strong>格式化响应的参数</strong>。</li>
</ol>
<p>首先，让我们看一下查询选项。</p>
<h4 id="主要的查询选项">主要的查询选项<a hidden class="anchor" aria-hidden="true" href="#主要的查询选项">#</a></h4>
<p>你通常想控制 DNS 查询的 3 件事是：</p>
<ol>
<li><strong>名称</strong>（如 <code>jvns.ca</code>）。默认情况下，查询的是空名称（<code>.</code>）。</li>
<li><strong>DNS 查询类型</strong>（如 <code>A</code> 或 <code>CNAME</code>）。默认是 <code>A</code>。</li>
<li>发送查询的 <strong>服务器</strong>（如 <code>8.8.8.8</code>）。默认是 <code>/etc/resolv.conf</code> 中的内容。</li>
</ol>
<p>其格式是：</p>
<pre tabindex="0"><code>dig @server name type
</code></pre><p>这里有几个例子：</p>
<ul>
<li><code>dig @8.8.8.8 jvns.ca</code> 向谷歌的公共 DNS 服务器（<code>8.8.8.8</code>）查询 <code>jvns.ca</code>。</li>
<li><code>dig ns jvns.ca</code> 对 <code>jvns.ca</code> 进行类型为 <code>NS</code> 的查询。</li>
</ul>
<p><strong><code>-x</code>：进行反向 DNS 查询</strong></p>
<p>我偶尔使用的另一个查询选项是 <code>-x</code>，用于进行反向 DNS 查询。下面是输出结果的样子。</p>
<pre tabindex="0"><code>$ dig -x 172.217.13.174
174.13.217.172.in-addr.arpa. 72888 IN PTR yul03s04-in-f14.1e100.net。
</code></pre><p><code>-x</code> 不是魔术。<code>dig -x 172.217.13.174</code> 只是对 <code>174.13.217.172.in-addr.arpa.</code> 做了一个 <code>PTR</code> 查询。下面是如何在不使用 `-x’ 的情况下进行完全相同的反向 DNS 查询。</p>
<pre tabindex="0"><code>$ dig ptr 174.13.217.172.in-addr.arpa.
174.13.217.172.in-addr.arpa. 72888 IN PTR yul03s04-in-f14.1e100.net。
</code></pre><p>我总是使用 <code>-x</code>，因为它可以减少输入。</p>
<p><a href="https://www.cnblogs.com/mysticbinary/p/13344930.html">DNS反向查询</a>大概的一个定义就是：</p>
<p>从 IP 地址获取 PTR 记录。也就是说，通过使用一些网络工具可以将 IP 地址转换为主机名。 实际上，PRT 代表 POINTER，在 DNS 系统有唯一性，将 IP 地址与规范化的主机名联系起来。PTR 记录其实是 NDS 系统的一部分，但是由专门的区域文件组成的，使用的是传统的 in-addr.arpa 格式。</p>
<h4 id="格式化响应的选项">格式化响应的选项<a hidden class="anchor" aria-hidden="true" href="#格式化响应的选项">#</a></h4>
<p>现在，让我们讨论一下你可以用来格式化响应的参数。</p>
<p>我发现 <code>dig</code> 默认格式化 DNS 响应的方式对初学者来说是很难接受的。下面是输出结果的样子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">; &lt;&lt;&gt;&gt; DiG 9.16.20 &lt;&lt;&gt;&gt; -r jvns.ca
;; global options: +cmd
;; Got answer:
;; -&gt;&gt;HEADER<span style="color:#e6db74">&lt;&lt;- opco</span>de: QUERY, status: NOERROR, id: <span style="color:#ae81ff">28629</span>
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: <span style="color:#ae81ff">1</span>
;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: <span style="color:#ae81ff">4096</span>
; COOKIE: d87fc3022c0604d60100000061ab74857110b908b274494d <span style="color:#f92672">(</span>good<span style="color:#f92672">)</span>
;; QUESTION SECTION:
;jvns.ca.           IN  A
;; ANSWER SECTION:
jvns.ca.        <span style="color:#ae81ff">276</span> IN  A   172.64.80.1
;; Query time: <span style="color:#ae81ff">9</span> msec
;; SERVER: 192.168.1.1#53<span style="color:#f92672">(</span>192.168.1.1<span style="color:#f92672">)</span>
;; WHEN: Sat Dec <span style="color:#ae81ff">04</span> 09:00:37 EST <span style="color:#ae81ff">2021</span>
;; MSG SIZE  rcvd: <span style="color:#ae81ff">80</span>
</code></pre></div><p>如果你不习惯看这个，你可能需要花点时间来筛选，找到你要找的 IP 地址。而且大多数时候，你只对这个响应中的一行感兴趣（<code>jvns.ca. 180 IN A 172.64.80.1</code>）。</p>
<p>下面是我最喜欢的两种方法，可以使 <code>dig</code> 的输出更容易管理：</p>
<p><strong>方式 1 : +noall +answer</strong></p>
<p>这告诉 <code>dig</code> 只打印 DNS 响应中的“答案”部分的内容。下面是一个查询 <code>google.com</code> 的 <code>NS</code> 记录的例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ dig +noall +answer ns google.com
google.com.     <span style="color:#ae81ff">158564</span>  IN  NS  ns4.google.com.
google.com.     <span style="color:#ae81ff">158564</span>  IN  NS  ns1.google.com.
google.com.     <span style="color:#ae81ff">158564</span>  IN  NS  ns2.google.com.
google.com.     <span style="color:#ae81ff">158564</span>  IN  NS  ns3.google.com.
</code></pre></div><p>这里的格式是：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">NAME         TTL            TYPE   CONTENT
google.com   <span style="color:#ae81ff">158564</span>   IN    NS     ns3.google.com.
</code></pre></div><p>顺便说一下：如果你曾经想知道 <code>IN</code> 是什么意思，它是指“查询类”，代表“互联网internet”。它基本上只是上世纪 80、90 年代的遗物，当时还有其他网络与互联网竞争，如“混沌网络chaosnet”。</p>
<p><strong>方式 2：+short</strong></p>
<p>这就像 <code>dig +noall +answer</code>，但更短：它只显示每条记录的内容。比如说：</p>
<pre tabindex="0"><code>$ dig +short ns google.com
ns2.google.com.
ns1.google.com.
ns4.google.com.
ns3.google.com.
</code></pre><h4 id="digrc"><code>digrc</code><a hidden class="anchor" aria-hidden="true" href="#digrc">#</a></h4>
<p>如果你不喜欢 <code>dig</code> 的默认格式（我就不喜欢！），你可以在你的主目录下创建一个 <code>.digrc</code> 文件，告诉它默认使用不同的格式。</p>
<p>我非常喜欢 <code>+noall +answer</code> 格式，所以我把 <code>+noall +answer</code> 放在我的 <code>~/.digrc</code> 中。下面是我使用该配置文件运行 <code>dig jvns.ca</code> 时的情况。</p>
<pre tabindex="0"><code>$ dig jvns.ca
jvns.ca.        255在172.64.80.1中
</code></pre><p>这样读起来就容易多了！</p>
<p>如果我想回到所有输出的长格式（我有时会这样做，通常是因为我想看响应的权威部分的记录），我可以通过运行再次得到一个长答案。</p>
<pre tabindex="0"><code>$ dig +all jvns.ca
</code></pre><h4 id="dig-trace">dig +trace<a hidden class="anchor" aria-hidden="true" href="#dig-trace">#</a></h4>
<p>我使用的最后一个 <code>dig</code> 选项是 <code>+trace</code>。<code>dig +trace</code> 模仿 DNS 解析器在查找域名时的做法 —— 它从根域名服务器开始，然后查询下一级域名服务器（如 <code>.com</code>），以此类推，直到到达该域名的权威域名服务器。因此，它将进行大约 30 次 DNS 查询。（我用 <code>tcpdump</code> 检查了一下，对于每个根域名服务器的 <code>A</code> / <code>AAAA</code> 记录它似乎要进行 2 次查询，所以这已经是 26 次查询了。我不太清楚它为什么这样做，因为它应该已经有了这些 IP 的硬编码，但它确实如此。）</p>
<p>我发现这对了解 DNS 的工作原理很有用，但我不认为我用它解决过问题。</p>
<h4 id="为什么要用-dig">为什么要用 dig<a hidden class="anchor" aria-hidden="true" href="#为什么要用-dig">#</a></h4>
<p>尽管有一些更简单的工具来进行 DNS 查询（如 <code>dog</code> 和 <code>host</code>），我发现自己还是坚持使用 <code>dig</code>。</p>
<p>我喜欢 <code>dig</code> 的地方实际上也是我 <strong>不喜欢</strong> <code>dig</code> 的地方 —— 它显示了大量的细节！</p>
<p>我知道，如果我运行 <code>dig +all</code>，它将显示 DNS 响应的所有部分。例如，让我们查询 <code>jvns.ca</code> 的一个根名称服务器。响应有 3 个部分，我可能会关心：回答部分、权威部分和附加部分。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ dig @h.root-servers.net. jvns.ca +all
;; Got answer:
;; -&gt;&gt;HEADER<span style="color:#e6db74">&lt;&lt;- opco</span>de: QUERY, status: NOERROR, id: <span style="color:#ae81ff">18229</span>
;; flags: qr rd; QUERY: 1, ANSWER: 0, AUTHORITY: 4, ADDITIONAL: <span style="color:#ae81ff">9</span>
;; WARNING: recursion requested but not available
;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: <span style="color:#ae81ff">1232</span>
;; QUESTION SECTION:
;jvns.ca.           IN  A
;; AUTHORITY SECTION:
ca.         <span style="color:#ae81ff">172800</span>  IN  NS  c.ca-servers.ca.
ca.         <span style="color:#ae81ff">172800</span>  IN  NS  j.ca-servers.ca.
ca.         <span style="color:#ae81ff">172800</span>  IN  NS  x.ca-servers.ca.
ca.         <span style="color:#ae81ff">172800</span>  IN  NS  any.ca-servers.ca.
;; ADDITIONAL SECTION:
c.ca-servers.ca.    <span style="color:#ae81ff">172800</span>  IN  A   185.159.196.2
j.ca-servers.ca.    <span style="color:#ae81ff">172800</span>  IN  A   198.182.167.1
x.ca-servers.ca.    <span style="color:#ae81ff">172800</span>  IN  A   199.253.250.68
any.ca-servers.ca.  <span style="color:#ae81ff">172800</span>  IN  A   199.4.144.2
c.ca-servers.ca.    <span style="color:#ae81ff">172800</span>  IN  AAAA    2620:10a:8053::2
j.ca-servers.ca.    <span style="color:#ae81ff">172800</span>  IN  AAAA    2001:500:83::1
x.ca-servers.ca.    <span style="color:#ae81ff">172800</span>  IN  AAAA    2620:10a:80ba::68
any.ca-servers.ca.  <span style="color:#ae81ff">172800</span>  IN  AAAA    2001:500:a7::2
;; Query time: <span style="color:#ae81ff">103</span> msec
;; SERVER: 198.97.190.53#53<span style="color:#f92672">(</span>198.97.190.53<span style="color:#f92672">)</span>
;; WHEN: Sat Dec <span style="color:#ae81ff">04</span> 11:23:32 EST <span style="color:#ae81ff">2021</span>
;; MSG SIZE  rcvd: <span style="color:#ae81ff">289</span>
</code></pre></div><p><code>dog</code> 也显示了 “附加” 部分的记录，但它没有明确指出哪个是哪个（我猜 <code>+</code> 意味着它在附加部分？） ，但它似乎没有显示“权威”部分的记录。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ dog @h.root-servers.net. jvns.ca 
  NS ca.                2d0h00m00s A <span style="color:#e6db74">&#34;c.ca-servers.ca.&#34;</span>
  NS ca.                2d0h00m00s A <span style="color:#e6db74">&#34;j.ca-servers.ca.&#34;</span>
  NS ca.                2d0h00m00s A <span style="color:#e6db74">&#34;x.ca-servers.ca.&#34;</span>
  NS ca.                2d0h00m00s A <span style="color:#e6db74">&#34;any.ca-servers.ca.&#34;</span>
   A c.ca-servers.ca.   2d0h00m00s + 185.159.196.2
   A j.ca-servers.ca.   2d0h00m00s + 198.182.167.1
   A x.ca-servers.ca.   2d0h00m00s + 199.253.250.68
   A any.ca-servers.ca. 2d0h00m00s + 199.4.144.2
AAAA c.ca-servers.ca.   2d0h00m00s + 2620:10a:8053::2
AAAA j.ca-servers.ca.   2d0h00m00s + 2001:500:83::1
AAAA x.ca-servers.ca.   2d0h00m00s + 2620:10a:80ba::68
AAAA any.ca-servers.ca. 2d0h00m00s + 2001:500:a7::2
</code></pre></div><p>而 <code>host</code> 似乎只显示“答案”部分的记录（在这种情况下没有得到记录）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ host jvns.ca h.root-servers.net
Using domain server:
Name: h.root-servers.net
Address: 198.97.190.53#53
Aliases:
</code></pre></div><p>总之，我认为这些更简单的 DNS 工具很好（我甚至自己做了一个 <a href="https://dns-lookup.jvns.ca/">简单的网络 DNS 工具</a>），如果你觉得它们更容易，你绝对应该使用它们，但这就是为什么我坚持使用 <code>dig</code> 的原因。<code>drill</code> 的输出格式似乎与 <code>dig</code> 的非常相似，也许 <code>drill</code> 更好！但我还没有真正试过它。</p>
<h3 id="sambahttpswwwcnblogscomgzdaijiep5194033html"><a href="https://www.cnblogs.com/gzdaijie/p/5194033.html">Samba</a><a hidden class="anchor" aria-hidden="true" href="#sambahttpswwwcnblogscomgzdaijiep5194033html">#</a></h3>
<p><strong>Samba</strong> 是 <a href="https://en.wikipedia.org/wiki/Server_Message_Block">SMB/CIFS</a> 网络协议的重新实现, 可以在 Linux 和 Windows 系统间进行文件、打印机共享，和 <a href="https://wiki.archlinux.org/title/NFS_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">NFS</a> 的功能类似。</p>
<h4 id="安装-3">安装<a hidden class="anchor" aria-hidden="true" href="#安装-3">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install samba
$ sudo systemctl enable --now smbd.service
</code></pre></div><p>Samba 服务的配置文件是 <code>/etc/samba/smb.conf</code>，<a href="https://man.archlinux.org/man/smb.conf.5">smb.conf(5)</a>提供了详细的文档。</p>
<p>如果使用了 <a href="https://wiki.archlinux.org/title/Firewall">防火墙</a>，请记得打开需要的端口(通常是 137-139 + 445)。完整列表请查看 <a href="https://www.samba.org/~tpot/articles/firewall.html">Samba 端口使用</a>。</p>
<h4 id="创建共享">创建共享<a hidden class="anchor" aria-hidden="true" href="#创建共享">#</a></h4>
<p>创建的目录即之后能够在Windows主机上直接访问的目录。例如：在用户samba_user的主目录下新建share文件夹为共享目录，由于Windows下的文件夹需可读可写可执行，需更改权限为777</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ mkdir /home/samba_user/smbshare
$ sudo chmod <span style="color:#ae81ff">777</span> /home/samba_user/smbshare
</code></pre></div><p>修改 /<code>etc/samba/smb.conf</code>，在smb.conf文件最后加上以下内容</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo vim /etc/samba/smb.conf
<span style="color:#f92672">[</span>share<span style="color:#f92672">]</span>
path <span style="color:#f92672">=</span> /home/samba_user/smbshare
public <span style="color:#f92672">=</span> yes
writable <span style="color:#f92672">=</span> yes
valid users <span style="color:#f92672">=</span> samba_user
create mask <span style="color:#f92672">=</span> <span style="color:#ae81ff">0644</span>
force create mode <span style="color:#f92672">=</span> <span style="color:#ae81ff">0644</span>
directory mask <span style="color:#f92672">=</span> <span style="color:#ae81ff">0755</span>
force directory mode <span style="color:#f92672">=</span> <span style="color:#ae81ff">0755</span>
available <span style="color:#f92672">=</span> yes
</code></pre></div><ul>
<li>[share]表示共享文件夹的别名，之后将直接使用这个别名</li>
<li><code>force create mode</code> 与 <code>force directory mode</code>的设置是因为Windows下与Linux下文件和文件夹的默认权限不同造成的，Windows下新建的文件是可执行的，必须强制设定其文件权限。</li>
<li>valid users 设置为你当前的Linux用户名，例如我的是samba_user，因为第一次打开共享文件夹时，需要验证权限。</li>
</ul>
<h4 id="用户管理">用户管理<a hidden class="anchor" aria-hidden="true" href="#用户管理">#</a></h4>
<p>Samba 需要 Linux 账户才能使用 - 可以使用已有账户或创建新用户。</p>
<p>虽然用户名可以和 Linux 系统共享，Samba 使用单独的密码管理，将下面的 <code>samba_user</code> 替换为上面设置的 valid users:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo smbpasswd -a samba_user
</code></pre></div><p>根据服务器角色的差异，可能需要修改已有的文件权限和属性。</p>
<h4 id="which-is-faster-samba-or-scphttpsarstechnicacomcivisviewtopicphpf16t365900"><a href="https://arstechnica.com/civis/viewtopic.php?f=16&amp;t=365900">Which is faster-Samba or scp?</a><a hidden class="anchor" aria-hidden="true" href="#which-is-faster-samba-or-scphttpsarstechnicacomcivisviewtopicphpf16t365900">#</a></h4>
<p>Depends on the machines. Machines with really fast CPU may do SCP or SFTP faster.</p>
<p>Otherwise, Samba will probably be faster because it doesn&rsquo;t have to encrypt.</p>
<h3 id="sudohttpswwwcnblogscomsparkdevp6189196html"><a href="https://www.cnblogs.com/sparkdev/p/6189196.html">sudo</a><a hidden class="anchor" aria-hidden="true" href="#sudohttpswwwcnblogscomsparkdevp6189196html">#</a></h3>
<p>简单的说，sudo 是一种权限管理机制，管理员可以授权于一些普通用户去执行一些 root 执行的操作，而不需要知道 root 的密码。</p>
<p>严谨些说，sudo 允许一个已授权用户以超级用户或者其它用户的角色运行一个命令。当然，能做什么不能做什么都是通过安全策略来指定的。sudo 支持插件架构的安全策略，并能把输入输出写入日志。第三方可以开发并发布自己的安全策略和输入输出日志插件，并让它们无缝的和 sudo 一起工作。默认的安全策略记录在 <code>/etc/sudoers</code> 文件中。而安全策略可能需要用户通过密码来验证他们自己。也就是在用户执行 sudo 命令时要求用户输入自己账号的密码。如果验证失败，sudo 命令将会退出。</p>
<h4 id="命令语法">命令语法<a hidden class="anchor" aria-hidden="true" href="#命令语法">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo <span style="color:#f92672">[</span>-bhHpV<span style="color:#f92672">][</span>-s <span style="color:#f92672">][</span>-u &lt;用户&gt;<span style="color:#f92672">][</span>指令<span style="color:#f92672">]</span>
$ sudo <span style="color:#f92672">[</span>-klv<span style="color:#f92672">]</span>
</code></pre></div><p>参数：</p>
<ul>
<li><code>-b</code> 在后台执行指令。</li>
<li><code>-h</code> 显示帮助。</li>
<li><code>-H</code> 将HOME环境变量设为新身份的HOME环境变量。</li>
<li><code>-k</code> 结束密码的有效期限，也就是下次再执行sudo时便需要输入密码。</li>
<li><code>-l</code> 列出目前用户可执行与无法执行的指令。</li>
<li><code>-p</code> 改变询问密码的提示符号。</li>
<li><code>-s</code> 执行指定的shell。</li>
<li><code>-u</code> &lt;用户&gt; 以指定的用户作为新的身份。若不加上此参数，则预设以root作为新的身份。</li>
<li><code>-v</code> 延长密码有效期限5分钟。</li>
<li><code>-V</code> 显示版本信息。</li>
<li><code>-S</code> 从标准输入流替代终端来获取密码</li>
</ul>
<h4 id="基本配置">基本配置<a hidden class="anchor" aria-hidden="true" href="#基本配置">#</a></h4>
<p>系统默认创建了一个名为 sudo 的组。只要把用户加入这个组，用户就具有了 sudo 的权限。</p>
<p>至于如何把用户加入 sudo 组，您可以直接编辑 <code>/etc/group</code> 文件，当然您得使用一个有 sudo 权限的用户来干这件，在 sudo 组中加入新的用户，要使用逗号分隔多个用户。</p>
<p>或者您可以使用 usermod 命令把用户添加到一个组中：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo usermod -a -G sudo jack
</code></pre></div><p>上面的设置中我们把用户 jack 添加到了 sudo 组中，所以当用户 jack 登录后就可以通过 sudo 命令以 root 权限执行命令了！</p>
<h4 id="详细配置">详细配置<a hidden class="anchor" aria-hidden="true" href="#详细配置">#</a></h4>
<p>在前面的配置中我们只是把用户 jack 加入了 sudo 组，他就具有了通过 root 权限执行命令的能力。</p>
<p>现在我们想问一下，这是怎么发生的？是时候介绍如何配置 sudo 命令了！</p>
<p>sudo 命令的配置文件为 <code>/etc/sudoers</code>。</p>
<p>编辑这个文件是有单独的命令的 visudo，这个文件我们最好不要使用 vim 命令来打开，是因为一旦你的语法写错会造成严重的后果，这个工具会替你检查你写的语法，这个文件的语法遵循以下格式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">who where whom command
</code></pre></div><p>说白了就是哪个用户在哪个主机以谁的身份执行那些命令，那么这个 where, 是指允许在那台主机 ssh 连接进来才能执行后面的命令，文件里面默认给 root 用户定义了一条规则：</p>
<pre tabindex="0"><code>root    ALL=(ALL:ALL)       ALL
</code></pre><ul>
<li><code>root</code> 表示 root 用户。</li>
<li><code>ALL</code> 表示从任何的主机上都可以执行，也可以这样 192.168.100.0/24。</li>
<li><code>(ALL:ALL)</code>  是以谁的身份来执行，ALL:ALL 就代表 root 可以任何人的身份来执行命令。</li>
<li><code>ALL</code>  表示任何命令。</li>
</ul>
<p>那么整条规则就是 root 用户可以在任何主机以任何人的身份来执行所有的命令。</p>
<p>现在我们可以回答 jack 为什么具有通过 root 权限执行命令的能力了。打开 <code>/etc/sudoers</code> 文件：</p>
<pre tabindex="0"><code>%sudo ALL=(ALL:ALL) ALL
</code></pre><p>sudo 组中的所有用户都具有通过 root 权限执行命令的能力！</p>
<p>再看个例子：</p>
<pre tabindex="0"><code>nick   192.168.10.0/24=(root) /usr/sbin/useradd
</code></pre><p>上面的配置只允许 nick 在 192.168.10.0/24 网段上连接主机并且以 root 权限执行 useradd 命令。</p>
<p><strong>设置 sudo 时不需要输入密码</strong></p>
<p>只需要在配置行中添加 NOPASSWD: 就可以了：</p>
<pre tabindex="0"><code>%sudo ALL=(ALL:ALL) NOPASSWD:ALL
</code></pre><h4 id="日志">日志<a hidden class="anchor" aria-hidden="true" href="#日志">#</a></h4>
<p>在 ubuntu 中，sudo 的日志默认被记录在 <code>/var/log/auth.log</code> 文件中。当我们执行 sudo 命令时，相关日志都是会被记录下来的。</p>
<h4 id="与输出重定向httpswwwcnblogscomsparkdevp10287164html"><a href="https://www.cnblogs.com/sparkdev/p/10287164.html">与输出重定向</a><a hidden class="anchor" aria-hidden="true" href="#与输出重定向httpswwwcnblogscomsparkdevp10287164html">#</a></h4>
<p>如果当前用户没有某个文件的写权限，又要通过输出重定向往该文件中写入内容。结果只能是 &ldquo;Permission denied&rdquo;。</p>
<p>比如当前用户为 nick，下面的命令试图查询 /root 目录下的文件并把结果写入到 /root/test.txt 文件中，注意用户 nick 没有对 /root/test.txt 文件的写权限：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ls -al /root/test.txt
-rw-r--r-- <span style="color:#ae81ff">1</span> root root <span style="color:#ae81ff">0</span> Jan <span style="color:#ae81ff">10</span> 05:19 /root/test.txt
$ sudo ls -al /root &gt; /root/test.txt
-bash: /root/test.txt: Premission denied
</code></pre></div><p>不工作的原因是：<em>虽然 ls 命令是以 sudo 方式执行的，但是输出重定向操作是由当前 shell 执行的，它(当前 shell)没有 /root/test.txt 文件的权限，所以最终失败。</em></p>
<p>搞清楚了原因，就可以通过不同的方式来解决这个问题了，下面介绍四种方式。</p>
<p><strong>以 sudo 方式运行 shell</strong></p>
<p>既然是 shell 进程没有权限，那就用 sudo 的方式执行 shell：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo bash -c <span style="color:#e6db74">&#39;ls -al /root &gt; /root/test.txt&#39;</span>
</code></pre></div><p><strong>把命令写入脚本，以 sudo 方式执行脚本</strong></p>
<p>把下面的代码保存到脚本文件 test.sh 中：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">#!/bin/bash
</span><span style="color:#75715e"></span>ls -al /root &gt; /root/test.txt
</code></pre></div><p>然后通过下面的方式执行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ chmod +x test.sh
$ sudo ./test.sh
</code></pre></div><p>如果觉着创建脚本麻烦的话还可以使用变通的方式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo bash <span style="color:#e6db74">&lt;&lt;EOF
</span><span style="color:#e6db74">&gt; ls -al /root &gt; /root/test.txt
</span><span style="color:#e6db74">&gt; EOF</span>
</code></pre></div><p>或者是下面的写法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ echo <span style="color:#e6db74">&#39;ls -al /root &gt; /root/test.txt&#39;</span> | sudo bash
</code></pre></div><p><strong>先通过 sudo -s 启动 shell，然后执行命令</strong></p>
<p>先通过 sudo -s 命令切换到 root 用户再执行命令，最后 ctrl + d 退出。</p>
<p><strong>通过 sudo tee 命令实现</strong></p>
<p>Tee 命令用于将数据重定向到文件，另一方面还可以提供一份重定向数据的副本作为后续命令的 stdin。简单的说就是把数据重定向到给定文件和屏幕上：</p>
<p><img loading="lazy" src="/Distributions/952033-20190118131012035-1560486278.png" alt=""  />
</p>
<p>面的命令中通过 sudo tee 把 ls 命令的输出写入文件：</p>
<pre tabindex="0"><code>$ sudo ls -al /root | sudo tee /root/test.txt &gt; /dev/null
</code></pre><p>其中的 &gt; /dev/null 阻止 tee 把内容输出到终端。</p>
<h3 id="fdiskhttpswwwcnblogscomsparkdevp10095916html"><a href="https://www.cnblogs.com/sparkdev/p/10095916.html">fdisk</a><a hidden class="anchor" aria-hidden="true" href="#fdiskhttpswwwcnblogscomsparkdevp10095916html">#</a></h3>
<p>Linux 系统中所有的硬件设备都是通过文件的方式来表现和使用的，我们将这些文件称为设备文件，硬盘对应的设备文件一般被称为块设备文件。</p>
<h4 id="磁盘分类">磁盘分类<a hidden class="anchor" aria-hidden="true" href="#磁盘分类">#</a></h4>
<p>比较常见的磁盘类型有消费类市场中的 SATA 硬盘和服务器中使用的 SCSI 硬盘、SAS 硬盘，当然还有当下大热的各种固态硬盘。</p>
<p><strong>SATA 硬盘</strong></p>
<p>SATA(Serial ATA)口的硬盘又叫串口硬盘，Serial ATA 采用串行连接方式，串行 ATA 总线使用嵌入式时钟信号，具备了更强的纠错能力，与以往相比其最大的区别在于能对传输指令(不仅仅是数据)进行检查，如果发现错误会自动矫正，这在很大程度上提高了数据传输的可靠性。串行接口还具有结构简单、支持热插拔的优点。SATA 硬盘主要用于消费类市场和一些低端服务器：</p>
<p><img loading="lazy" src="/Distributions/952033-20181210130351845-1555163788.jpg" alt="img"  />
</p>
<p><strong>SCSI 硬盘</strong></p>
<p>SCSI 硬盘即采用 SCSI 接口的硬盘。它由于性能好、稳定性高，因此在服务器上得到广泛应用。同时其价格也不菲，正因它的价格昂贵，所以在普通PC上很少见到它的踪迹。SCSI 硬盘使用 50 针接口，外观和普通硬盘接口有些相似(下图来自互联网)：</p>
<p><img loading="lazy" src="/Distributions/952033-20181210130325224-626582547.jpg" alt="img"  />
</p>
<p><strong>SAS 硬盘</strong></p>
<p>SAS 是 Serial Attached SCSI 的缩写，即串行连接的 SCSI，其目标是定义一个新的串行点对点的企业级存储设备接口。串行接口减少了线缆的尺寸，允许更快的传输速度。SAS 硬盘与相同转速的 SCSI 硬盘相比有相同或者更好的性能。SAS 硬盘一般用于比较高端的服务器。</p>
<p><strong>固态硬盘</strong></p>
<p>固态硬盘(Solid State Disk)，一般称之为 SSD 硬盘，固态硬盘是用固态电子存储芯片阵列而制成的硬盘，由控制单元和存储单元(FLASH芯片、DRAM芯片)组成。其主要特点是没有传统硬盘的机械结构，读写速度非常快(下图来自互联网)：</p>
<p><img loading="lazy" src="/Distributions/952033-20181210130414715-469384412.png" alt="img"  />
</p>
<h4 id="表示方法">表示方法<a hidden class="anchor" aria-hidden="true" href="#表示方法">#</a></h4>
<p>在 Linux 系统中磁盘设备文件的命名规则为：</p>
<pre tabindex="0"><code>主设备号 + 次设备号 + 磁盘分区号
</code></pre><p>对于目前常见的磁盘，一般表示为：</p>
<pre tabindex="0"><code>sd[a-z]x
</code></pre><ul>
<li>主设备号代表设备的类型，相同的主设备号表示同类型的设备。当前常见磁盘的主设备号为 sd。</li>
<li>次设备号代表同类设备中的序号，用 &ldquo;a-z&rdquo; 表示。比如 /dev/sda 表示第一块磁盘，/dev/sdb 表示第二块磁盘。</li>
<li>x 表示磁盘分区编号。在每块磁盘上可能会划分多个分区，针对每个分区，Linux 用 /dev/sdbx 表示，这里的 x 表示第二块磁盘的第 x 个分区。</li>
</ul>
<h4 id="磁盘分区">磁盘分区<a hidden class="anchor" aria-hidden="true" href="#磁盘分区">#</a></h4>
<p>创建磁盘分区大概有下面几个目的：</p>
<ul>
<li>提升数据的安全性(一个分区的数据损坏不会影响其他分区的数据)</li>
<li>支持安装多个操作系统</li>
<li>多个小分区对比一个大分区会有性能提升</li>
<li>更好的组织数据</li>
</ul>
<p>本文以常见的 MBR 分区为例介绍磁盘分区中的一些常见概念。MBR 磁盘的分区由主分区、扩展分区和逻辑分区组成。在一块磁盘上，主分区的最大个数是 4，其中扩展分区也是一个主分区，并且最多只能有一个扩展分区，但可以在扩展分区上创建多个逻辑分区。因此主分区(包括扩展分区)的范围是 1-4，逻辑分区从 5 开始。对于逻辑分区，Linux 规定它们必须建立在扩展分区上，而不是建立在主分区上。</p>
<p>主分区的作用是用来启动操作系统的，主要存放操作系统的启动或引导程序。</p>
<p>扩展分区只不过是逻辑分区的 &ldquo;容器&rdquo;。实际上只有主分区和逻辑分区是用来进行数据存储的，因而可以将数据集中存放在磁盘的逻辑分区中。</p>
<p>我们可以通过 fdisk 命令来查看磁盘分区的信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo fdisk -l /dev/sda
</code></pre></div><p>分区信息：</p>
<ul>
<li><strong>Device</strong> 显示了磁盘分区对应的设备文件名。</li>
<li><strong>Boot</strong> 显示是否为引导分区，是引导分区就有一个 &lsquo;*&rsquo; 号。</li>
<li><strong>Start</strong> 表示磁盘分区的起始位置。</li>
<li><strong>End</strong> 表示磁盘分区的结束位置。</li>
<li><strong>Sectors</strong> 表示分区占用的扇区数目。</li>
<li><strong>Size</strong> 显示分区的大小。</li>
<li><strong>Id/Type</strong> 显示的内容相同，分别是数值 ID 及其文字描述。 Id 列显示了磁盘分区对应的 ID，根据分区的不同，分区对应的 ID 号也不相同。Linux 下用 83 表示主分区和逻辑分区，5 表示扩展分区，8e 表示 LVM 分区，82 表示交换分区，7 表示 NTFS 分区。</li>
</ul>
<h4 id="划分磁盘分区">划分磁盘分区<a hidden class="anchor" aria-hidden="true" href="#划分磁盘分区">#</a></h4>
<p>fdisk 是 Linux 系统中一款功能强大的磁盘分区管理工具，可以观察硬盘的使用情况，也可以用来管理磁盘分区。</p>
<p>假设我们的 Linux 系统中增加了一块新的磁盘，系统对应的设备名为 /dev/sdd，下面我们通过 fdisk 命令对这个磁盘进行分区：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ <span style="color:#f92672">(</span>echo n; echo p; echo 1; echo ; echo ; echo w<span style="color:#f92672">)</span> | sudo fdisk /dev/sdd
</code></pre></div><ul>
<li>命令 n 来创建新分区</li>
<li>p 来创建主分区</li>
<li>主分区的编号为 1- 4，这里我们输入了 1。</li>
<li>分区的大小是通过设置分区开始处的扇区和结束处的扇区设置的。这里如果回车两次会把整个磁盘划分为一个分区，也就是整个磁盘的容器都分给了一个分区。</li>
<li>注意此时的分区信息还没有写入到磁盘中，在这里还可以反悔，如果确认执行上面的分区，执行 w 命令就行了。</li>
</ul>
<p>这时分区操作已经完成了，我们可以通过下面的命令查看分区的结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo fdisk -l /dev/sdd
</code></pre></div><p>分区是使用磁盘的基础，在分区完成后还需要对分区进行格式化，并把格式化后的文件系统挂载到 Linux 系统之后才能存储文件。</p>
<p><strong>更改分区的类型</strong></p>
<p>创建的分区类型默认为 83(Linux)，如果想要一个 8e(Linux LVM)类型的分区，在 fdisk 输入 t 命令来修改分区的类型。</p>
<h3 id="fuserhttpswwwcnblogscomsungeekp11857549html"><a href="https://www.cnblogs.com/Sungeek/p/11857549.html">fuser</a><a hidden class="anchor" aria-hidden="true" href="#fuserhttpswwwcnblogscomsungeekp11857549html">#</a></h3>
<p>当使用umount命令卸载挂载点时，会遇到“device is busy”提示，这时fuser就能查出谁在使用这个资源。</p>
<h4 id="描述">描述<a hidden class="anchor" aria-hidden="true" href="#描述">#</a></h4>
<p>fuser可以显示出当前哪个程序在使用磁盘上的某个文件、挂载点、甚至网络端口，并给出程序进程的详细信息。</p>
<p>每个进程 ID 后面跟有一个字母代码。字母代码的解释如下所述。</p>
<ul>
<li><code>c</code>：表示此进程正在使用该文件作为其当前目录。</li>
<li><code>e</code>：将此文件作为程序的可执行对象使用</li>
<li><code>f</code>：打开的文件。默认不显示。</li>
<li><code>F</code>：打开的文件，用于写操作。默认不显示。</li>
<li><code>r</code>：表示此进程正在将该文件用作其根目录。</li>
<li><code>m</code>：指示进程使用该文件进行内存映射，抑或该文件为共享库文件，被进程映射进内存。</li>
<li><code>s</code>：将此文件作为共享库（或其他可装载对象）使用</li>
</ul>
<p>对于具有已挂载文件系统的块特殊设备，将列出使用该设备上的任何文件的所有进程。对于所有类型的文件（文本文件、可执行文件、目录、设备，等等），只会报告使用该文件的进程。</p>
<p>对于所有类型的设备，<code>fuser</code> 还会显示打开设备的任何已知内核使用者。内核使用者显示为下列格式之一：</p>
<pre tabindex="0"><code>[module_name]
[module_name,dev_path=path]
[module_name,dev=(major,minor)]
[module_name,dev=(major,minor),dev_path=path]
</code></pre><p>如果指定了多组文件，可能需要为其他每个文件组重新指定选项。单个短划线可取消当前施行的选项。</p>
<p>各个进程 ID 输出到标准输出中的单个行上，并以空格分隔。所有其他输出（包括单个终止换行符）均被写入到标准错误。</p>
<p>任何用户都可以运行 fuser，但只有超级用户可以终止其他用户的进程。</p>
<h4 id="选项">选项<a hidden class="anchor" aria-hidden="true" href="#选项">#</a></h4>
<p>支持以下选项：</p>
<ul>
<li><code>-a</code>：显示所有命令行中指定的文件，默认情况下被访问的文件才会被显示。</li>
<li><code>-c</code>：和-m一样，用于POSIX兼容。</li>
<li><code>-k</code>：杀掉访问文件的进程。如果没有指定-signal就会发送SIGKILL信号。</li>
<li><code>-i</code>：杀掉进程之前询问用户，如果没有-k这个选项会被忽略。</li>
<li><code>-l</code>：列出所有已知的信号名称。</li>
<li><code>-m</code>：name 指定一个挂载文件系统上的文件或者被挂载的块设备（名称name）。这样所有访问这个文件或者文件系统的进程都会被列出来。如果指定的是一个目录会自动转换成&quot;name/&quot;,并使用所有挂载在那个目录下面的文件系统。</li>
<li><code>-n</code>：space 指定一个不同的命名空间(space).这里支持不同的空间文件(文件名，此处默认)、tcp(本地tcp端口)、udp(本地udp端口)。对于端口， 可以指定端口号或者名称，如果不会引起歧义那么可以使用简单表示的形式，例如：name/space (即形如:80/tcp之类的表示)。</li>
<li><code>-s</code>：静默模式，这时候-u,-v会被忽略。-a不能和-s一起使用。</li>
<li><code>-signal</code>：使用指定的信号，而不是用SIGKILL来杀掉进程。可以通过名称或者号码来表示信号(例如-HUP,-1),这个选项要和-k一起使用，否则会被忽略。</li>
<li><code>-u</code>：在每个PID后面添加进程拥有者的用户名称。</li>
<li><code>-v</code>：详细模式。输出似ps命令的输出，包含PID,USER,COMMAND等许多域,如果是内核访问的那么PID为kernel.  -V 输出版本号。</li>
<li><code>-4</code>：使用IPV4套接字,不能和-6一起应用，只在-n的tcp和udp的命名存在时不被忽略。</li>
<li><code>-6</code>：使用IPV6套接字,不能和-4一起应用，只在-n的tcp和udp的命名存在时不被忽略。</li>
<li><code>-</code>：重置所有的选项，把信号设置为SIGKILL.</li>
</ul>
<h4 id="示例">示例<a hidden class="anchor" aria-hidden="true" href="#示例">#</a></h4>
<p><strong>示例 1</strong> 显示使用某个文件的进程信息</p>
<p>这个命令在umount的时候很有用，可以找到还有哪些用到这个设备了。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ fuser -um /dev/sda2  
/dev/sda2:            6378c<span style="color:#f92672">(</span>quietheart<span style="color:#f92672">)</span>  6534c<span style="color:#f92672">(</span>quietheart<span style="color:#f92672">)</span>  6628<span style="color:#f92672">(</span>quietheart<span style="color:#f92672">)</span>  
6653c<span style="color:#f92672">(</span>quietheart<span style="color:#f92672">)</span>  7429c<span style="color:#f92672">(</span>quietheart<span style="color:#f92672">)</span>  7549c<span style="color:#f92672">(</span>quietheart<span style="color:#f92672">)</span>  7608c<span style="color:#f92672">(</span>quietheart<span style="color:#f92672">)</span>  
</code></pre></div><p><strong>示例 2</strong> 杀掉打开readme文件的程序</p>
<p>这里，会在kill之前询问是否确定。最好加上-v以便知道将要杀那个进程。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ fuser -m -k -i readme
</code></pre></div><p><strong>示例 3</strong> 查看那些程序使用tcp的80端口</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ fuser -v -n tcp <span style="color:#ae81ff">80</span>
<span style="color:#75715e"># or</span>
$ fuser -v 80/tcp  
</code></pre></div><h3 id="tcpdumphttpssegmentfaultcoma1190000018944427"><a href="https://segmentfault.com/a/1190000018944427">tcpdump</a><a hidden class="anchor" aria-hidden="true" href="#tcpdumphttpssegmentfaultcoma1190000018944427">#</a></h3>
<p><strong>tcpdump</strong> 是一款 Linux 平台的抓包工具。它可以抓取涵盖整个 TCP/IP 协议族的数据包，支持针对网络层、协议、主机、端口的过滤，并提供 and、or、not 等逻辑语句来过滤无用的信息。</p>
<p>tcpdump 是一个非常复杂的工具，掌握它的方方面面实属不易，也不推荐，能够用它来解决日常工作问题才是关系。</p>
<h4 id="命令选项">命令选项<a hidden class="anchor" aria-hidden="true" href="#命令选项">#</a></h4>
<p>tcpdump 有很多命令选项，想了解所有选项可以 Linux 命令行输入 <code>tcpdump -h</code>，<code>man tcpdump</code> 查看每个选项的意思。</p>
<p>下面列举一些常用选项：</p>
<ul>
<li>-A 只使用 ASCII 打印报文的全部数据，不要和 <code>-X</code> 一起使用，获取 http 可以用 <code>tcpdump -nSA port 80</code></li>
<li>-b 在数据链路层上选择协议，包括 ip, arp, rarp, ipx 等</li>
<li>-c 指定要抓取包的数量</li>
<li>-D 列出操作系统所有可以用于抓包的接口</li>
<li>-e 输出链路层报头</li>
<li>-i 指定监听的网卡，<code>-i any</code> 显示所有网卡</li>
<li>-n 表示不解析主机名，直接用 IP 显示，默认是用 hostname 显示</li>
<li>-nn 表示不解析主机名和端口，直接用端口号显示，默认显示是端口号对应的服务名</li>
<li>-p 关闭接口的混杂模式</li>
<li>-P 指定抓取的包是流入的包还是流出的，可以指定参数 in, out, inout 等，默认是 inout</li>
<li>-q 快速打印输出，即只输出少量的协议相关信息</li>
<li>-s len 设置要抓取数据包长度为 len，默认只会截取前 96bytes 的内容，<code>-s 0</code> 的话，会截取全部内容。</li>
<li>-S 将 TCP 的序列号以绝对值形式输出，而不是相对值</li>
<li>-t 不要打印时间戳</li>
<li>-vv 输出详细信息（比如 tos、ttl、checksum等）</li>
<li>-X 同时用 hex 和 ascii 显示报文内容</li>
<li>-XX 同 -X，但同时显示以太网头部</li>
</ul>
<h4 id="过滤器">过滤器<a hidden class="anchor" aria-hidden="true" href="#过滤器">#</a></h4>
<p>网络报文是很多的，很多时候我们在主机上抓包，会抓到很多我们并不关心的无用包，然后要从这些包里面去找我们需要的信息，无疑是一件费时费力的事情，tcpdump 提供了灵活的语法可以精确获取我们关心的数据，这些语法说得专业点就是过滤器。</p>
<p>过滤器简单可分为三类：协议（proto）、传输方向（dir）和类型（type）。</p>
<p>一般的 <strong>表达式格式</strong> 为：</p>
<p><img loading="lazy" src="/Distributions/3347645908-5cc81421999ad_fix732.webp" alt=""  />
</p>
<ul>
<li>关于 proto：可选有 ip, arp, rarp, tcp, udp, icmp, ether 等，默认是所有协议的包</li>
<li>关于 dir：可选有 src, dst, src or dst, src and dst，默认为 src or dst</li>
<li>关于 type：可选有 host, net, port, portrange（端口范围，比如 21-42），默认为 host</li>
</ul>
<h4 id="常用操作">常用操作<a hidden class="anchor" aria-hidden="true" href="#常用操作">#</a></h4>
<p>测试环境 IP：172.18.82.173</p>
<h5 id="抓取某主机的数据包">抓取某主机的数据包<a hidden class="anchor" aria-hidden="true" href="#抓取某主机的数据包">#</a></h5>
<p>抓取主机 172.18.82.173 上所有收到（DST_IP）和发出（SRC_IP）的所有数据包</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ tcpdump host 172.18.82.173
</code></pre></div><p>抓取经过指定网口 interface ，并且 DST_IP 或 SRC_IP 是 172.18.82.173 的数据包</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ tcpdump -i eth0 host 172.18.82.173
</code></pre></div><p>筛选 SRC_IP，抓取经过 interface 且从 172.18.82.173 发出的包</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ tcpdump -i eth0 src host 172.18.82.173
</code></pre></div><p>筛选 DST_IP，抓取经过 interface 且发送到 172.18.82.173 的包</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ tcpdump -i eth0 dst host 172.18.82.173
</code></pre></div><p>抓取主机 200.200.200.1 和主机 200.200.200.2 或 200.200.200.3 通信的包</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ tcpdump host 200.200.200.1 and <span style="color:#ae81ff">\(</span>200.200.200.2 or 200.200.200.3<span style="color:#ae81ff">\)</span>
</code></pre></div><p>抓取主机 200.200.200.1 和除了主机 200.200.200.2 之外所有主机通信的包</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ tcpdump ip host 200.200.200.1 and ! 200.200.200.2
</code></pre></div><h5 id="抓取某端口的数据包">抓取某端口的数据包<a hidden class="anchor" aria-hidden="true" href="#抓取某端口的数据包">#</a></h5>
<p>抓取所有端口，显示 IP 地址</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ tcpdump -nS
</code></pre></div><p>抓取某端口上的包</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ tcpdump port <span style="color:#ae81ff">22</span>
</code></pre></div><p>抓取经过指定 interface，并且 DST_PORT 或 SRC_PORT 是 22 的数据包</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ tcpdump -i eth0 port <span style="color:#ae81ff">22</span>
</code></pre></div><p>筛选 SRC_PORT</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ tcpdump -i eth0 src port <span style="color:#ae81ff">22</span>
</code></pre></div><p>筛选 DST_PORT</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ tcpdump -i eth0 dst port <span style="color:#ae81ff">22</span>
</code></pre></div><p>比如希望查看发送到 host 172.18.82.173 的网口 eth0 的 22 号端口的包</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ tcpdump -i eth0 -nnt dst host 172.18.82.173 and port <span style="color:#ae81ff">22</span> -c <span style="color:#ae81ff">1</span> -vv
</code></pre></div><h5 id="抓取某网络网段的数据包">抓取某网络（网段）的数据包<a hidden class="anchor" aria-hidden="true" href="#抓取某网络网段的数据包">#</a></h5>
<p>抓取经过指定 interface，并且 DST_NET 或 SRC_NET 是 172.18.82 的包</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ tcpdump -i eth0 net 172.18.82
</code></pre></div><p>筛选 SRC_NET</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ tcpdump -i eth0 src net 172.18.82
</code></pre></div><p>筛选 DST_NET</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ tcpdump -i eth0 dst net 172.18.82
</code></pre></div><h5 id="抓取某协议的数据包">抓取某协议的数据包<a hidden class="anchor" aria-hidden="true" href="#抓取某协议的数据包">#</a></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ tcpdump -i eth0 icmp
$ tcpdump -i eth0 ip
$ tcpdump -i eth0 tcp
$ tcpdump -i eth0 udp
$ tcpdump -i eth0 arp
</code></pre></div><h5 id="复杂的过滤条件">复杂的过滤条件<a hidden class="anchor" aria-hidden="true" href="#复杂的过滤条件">#</a></h5>
<p>抓取经过 interface eth0 发送到 host 200.200.200.1 或 200.200.200.2 的 TCP 协议 22 号端口的数据包</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ tcpdump -i eth0 -nntvv -c <span style="color:#ae81ff">10</span> <span style="color:#e6db74">&#39;((tcp) and (port 22) and ((dst host 200.200.200.1) or (dst host 200.200.200.2)))&#39;</span>
</code></pre></div><p>对于复杂的过滤器表达式，为了逻辑清晰，可以使用 <code>()</code>，不过默认情况下，tcpdump 会将 <code>()</code> 当做特殊字符，所以必须使用 <code>''</code> 来消除歧义。</p>
<p>抓取经过 interface eth0， DST_MAC 或 SRC_MAC 地址是 00:16:3e:12:16:e7 的 ICMP 数据包</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ tcpdump -i eth0 <span style="color:#e6db74">&#39;((icmp) and ((ether host 00:16:3e:12:16:e7)))&#39;</span> -nnvv
</code></pre></div><p>抓取经过 interface eth0，目标网络是 172.18 但目标主机又不是 172.18.82.173 的 TCP 且非 22 号端口号的数据包</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ tcpdump -i eth0 -nntvv <span style="color:#e6db74">&#39;((dst net 172.18) and (not dst host 172.18.82.173) and (tcp) and (not port 22))&#39;</span>
</code></pre></div><p>抓取流入 interface eth0，host 为 172.18.82.173 且协议为 ICMP 的数据包</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ tcpdump -i eth0 -nntvv -P in host 172.18.82.173 and icmp
</code></pre></div><p>抓取流出 interface eth0，host 为 172.18.82.173 且协议为 ICMP 的数据包</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ tcpdump -i eth0 -nntvv -P out host 172.18.82.173 and icmp
</code></pre></div><h4 id="与其他工具的配合">与其他工具的配合<a hidden class="anchor" aria-hidden="true" href="#与其他工具的配合">#</a></h4>
<p>tcpdump 抓包的时候，默认是打印到屏幕输出，如果是抓取包少还好，如果包很多，很多行数据，刷刷刷从眼前一闪而过，根本来不及看清内容。不过，tcpdump 提供了将抓取的数据保存到文件的功能，查看文件就方便分析多了，而且还能与其他图形工具一起配合分析，比如 wireshark、Snort 等。</p>
<ul>
<li>-w 选项表示把数据报文输出到文件</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ tcpdump -w capture_file.pcap port <span style="color:#ae81ff">80</span>
</code></pre></div><ul>
<li>-r 选项表示读取文件里的数据报文，显示到屏幕上</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ tcpdump -nXr capture_file.pcap host host1
</code></pre></div><p><code>.pcap</code> 格式的文件需要用 wireshark、Snort 等工具查看，使用 <code>vim</code> 或 <code>cat</code> 会出现乱码。</p>
<h4 id="tcpdump-的输出格式">tcpdump 的输出格式<a hidden class="anchor" aria-hidden="true" href="#tcpdump-的输出格式">#</a></h4>
<p>tcpdump 的输出格式总体上为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">系统时间 源主机.端口 &gt; 目标主机.端口 数据包参数
</code></pre></div><p>比如下面的例子，显示了 TCP 的三次握手过程：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">21:27:06.995846 IP <span style="color:#f92672">(</span>tos 0x0, ttl 64, id 45646, offset 0, flags <span style="color:#f92672">[</span>DF<span style="color:#f92672">]</span>, proto TCP <span style="color:#f92672">(</span>6<span style="color:#f92672">)</span>, length 64<span style="color:#f92672">)</span>
    192.168.1.106.56166 &gt; 124.192.132.54.80: Flags <span style="color:#f92672">[</span>S<span style="color:#f92672">]</span>, cksum 0xa730 <span style="color:#f92672">(</span>correct<span style="color:#f92672">)</span>, seq 992042666, win 65535, options <span style="color:#f92672">[</span>mss 1460,nop,wscale 4,nop,nop,TS val <span style="color:#ae81ff">663433143</span> ecr 0,sackOK,eol<span style="color:#f92672">]</span>, length <span style="color:#ae81ff">0</span>

21:27:07.030487 IP <span style="color:#f92672">(</span>tos 0x0, ttl 51, id 0, offset 0, flags <span style="color:#f92672">[</span>DF<span style="color:#f92672">]</span>, proto TCP <span style="color:#f92672">(</span>6<span style="color:#f92672">)</span>, length 44<span style="color:#f92672">)</span>
    124.192.132.54.80 &gt; 192.168.1.106.56166: Flags <span style="color:#f92672">[</span>S.<span style="color:#f92672">]</span>, cksum 0xedc0 <span style="color:#f92672">(</span>correct<span style="color:#f92672">)</span>, seq 2147006684, ack 992042667, win 14600, options <span style="color:#f92672">[</span>mss 1440<span style="color:#f92672">]</span>, length <span style="color:#ae81ff">0</span>

21:27:07.030527 IP <span style="color:#f92672">(</span>tos 0x0, ttl 64, id 59119, offset 0, flags <span style="color:#f92672">[</span>DF<span style="color:#f92672">]</span>, proto TCP <span style="color:#f92672">(</span>6<span style="color:#f92672">)</span>, length 40<span style="color:#f92672">)</span>
    192.168.1.106.56166 &gt; 124.192.132.54.80: Flags <span style="color:#f92672">[</span>.<span style="color:#f92672">]</span>, cksum 0x3e72 <span style="color:#f92672">(</span>correct<span style="color:#f92672">)</span>, ack 2147006685, win 65535, length <span style="color:#ae81ff">0</span>
</code></pre></div><p>第一条是 <code>SYN</code> 报文，通过 <code>Flags[S]</code> 看出。第二条是 <code>[S.]</code>，表示 <code>SYN-ACK</code> 报文。常见的 TCP 报文的 Flags 如下：</p>
<ul>
<li><code>[S]</code>： SYN（开始连接）</li>
<li><code>[.]</code>: 没有 Flag</li>
<li><code>[P]</code>: PSH（推送数据）</li>
<li><code>[F]</code>: FIN （结束连接）</li>
<li><code>[R]</code>: RST（重置连接）</li>
</ul>
<h2 id="others-2">Others<a hidden class="anchor" aria-hidden="true" href="#others-2">#</a></h2>
<h3 id="ubuntu-packages-searchhttpspackagesubuntucom"><a href="https://packages.ubuntu.com/">Ubuntu Packages Search</a><a hidden class="anchor" aria-hidden="true" href="#ubuntu-packages-searchhttpspackagesubuntucom">#</a></h3>
<h3 id="list-of-applicationsarchhttpswikiarchlinuxorgtitlelist_of_applications"><a href="https://wiki.archlinux.org/title/List_of_applications">List of applications—Arch</a><a hidden class="anchor" aria-hidden="true" href="#list-of-applicationsarchhttpswikiarchlinuxorgtitlelist_of_applications">#</a></h3>
<h3 id="常用软件opensusehttpszhopensuseorge5b8b8e794a8e8bdafe4bbb6"><a href="https://zh.opensuse.org/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6">常用软件—openSUSE</a><a hidden class="anchor" aria-hidden="true" href="#常用软件opensusehttpszhopensuseorge5b8b8e794a8e8bdafe4bbb6">#</a></h3>
<h3 id="应用程序ubuntuhttpswikiubuntucomcne9a696e9a1b5"><a href="https://wiki.ubuntu.com.cn/%E9%A6%96%E9%A1%B5">应用程序—Ubuntu</a><a hidden class="anchor" aria-hidden="true" href="#应用程序ubuntuhttpswikiubuntucomcne9a696e9a1b5">#</a></h3>
<h3 id="生态适配清单uoshttpswwwchinauoscomecologyadapt"><a href="https://www.chinauos.com/ecology/adapt">生态适配清单—UOS</a><a hidden class="anchor" aria-hidden="true" href="#生态适配清单uoshttpswwwchinauoscomecologyadapt">#</a></h3>
<h2 id="qemu-kvmhttpswikiarchlinuxorgtitleqemu_e7ae80e4bd93e4b8ade69687"><a href="https://wiki.archlinux.org/title/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">QEMU KVM</a><a hidden class="anchor" aria-hidden="true" href="#qemu-kvmhttpswikiarchlinuxorgtitleqemu_e7ae80e4bd93e4b8ade69687">#</a></h2>
<h3 id="qemu-的图形前端">QEMU 的图形前端<a hidden class="anchor" aria-hidden="true" href="#qemu-的图形前端">#</a></h3>
<p>与其他的虚拟化程序如 VirtualBox 和 VMware 不同, QEMU不提供管理虚拟机的GUI（运行虚拟机时出现的窗口除外），也不提供创建具有已保存设置的持久虚拟机的方法。除非您已创建自定义脚本以启动虚拟机，否则必须在每次启动时在命令行上指定运行虚拟机的所有参数。</p>
<p>Libvirt提供了一种管理 QEMU 虚拟机的便捷方式。有关可用的前端，请参阅 <a href="https://wiki.archlinux.org/title/Libvirt_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#.E5.AE.A2.E6.88.B7.E7.AB.AF">libvirt 客户端列表</a>。</p>
<h3 id="创建新虚拟系统">创建新虚拟系统<a hidden class="anchor" aria-hidden="true" href="#创建新虚拟系统">#</a></h3>
<h4 id="创建硬盘镜像">创建硬盘镜像<a hidden class="anchor" aria-hidden="true" href="#创建硬盘镜像">#</a></h4>
<p>除非直接从 CD-ROM 或网络引导（并且不安装系统到本地），运行 QEMU 时都需要硬盘镜像。硬盘镜像是一个文件，存储虚拟机硬盘上的内容。</p>
<p>一个硬盘镜像可能是 <em>raw</em>镜像, 和客户机器上看到的内容一模一样，并且将始终使用主机上的来宾硬盘驱动器的全部容量。此方法提供的I / O开销最小，但可能会浪费大量空间，因为guest虚拟机上未使用的空间无法在主机上使用。</p>
<p>另外一种方式是<em>qcow2</em> 格式，仅当客户系统实际写入内容的时候，才会分配镜像空间。对客户机器来说，硬盘大小表现为完整大小，即使它可能仅占用主机系统上的非常小的空间。此映像格式还支持QEMU快照功能。但是，使用此格式而不是 <em>raw</em> 可能会影响性能。</p>
<p>QEMU 提供 <code>qemu-img</code>命令创建硬盘镜像.例如创建一个 4 GB <em>raw</em> 格式的镜像:</p>
<pre tabindex="0"><code>$ qemu-img create -f raw image_file 4G
</code></pre><p>您也可以用 <code>-f qcow2</code> 创建一个 <em>qcow2</em> 镜像。</p>
<p>用 <code>dd</code> 或 <code>fallocate</code> 也可以创建一个 <em>raw</em> 镜像。</p>
<p><strong>警告：</strong> 如果硬盘镜像存储在 Btrfs 系统上，则应在创建任何映像之前考虑禁用该目录的 写时复制。</p>
<p><strong>调整镜像大小</strong></p>
<p><strong>警告：</strong> 调整包含NTFS引导文件系统的镜像将无法启动已安装的操作系统，推荐在操作之前进行备份</p>
<p>执行 <code>qemu-img</code> 带 <code>resize</code> 选项调整硬盘驱动镜像的大小.它适用于 <em>raw</em> 和 <em>qcow2</em>. 例如, 增加镜像 10 GB 大小, 运行:</p>
<pre tabindex="0"><code>$ qemu-img resize disk_image +10G
</code></pre><p>在磁盘映像扩容后，必须使用虚拟机内部系统的分区工具对该镜像进行分区并格式化后才能真正开始使用新空间。 在收缩磁盘映像时，必须首先使用虚拟机内部系统的分区工具减少分该分区的大小，然后相应地收缩磁盘映像，否则收缩磁盘映像将导致数据丢失！</p>
<h4 id="安装操作系统">安装操作系统<a hidden class="anchor" aria-hidden="true" href="#安装操作系统">#</a></h4>
<p>这是你第一次需要去启动模拟器的步骤，为了在磁盘镜像上安装操作系统，你必须同时将磁盘镜像与安装介质装载到虚拟机上，从安装介质中启动操作系统。</p>
<p>以i386的客户机为例，为了从CD-ROM内的把可用于启动的ISO文件安装到磁盘镜像上，你需要：</p>
<pre tabindex="0"><code>$ qemu-system-x86_64 -cdrom iso_image -boot order=d -drive file=disk_image,format=raw
</code></pre><p>在安装完操作系统后，就可以直接从QEMU镜像内启动了。</p>
<p><strong>注意：</strong> 默认情况下仅分配给虚拟机128MB的内存， 分配的内存大小可以通过 <code>-m</code> 调整， 比如 <code>-m 512M</code> 或 <code>-m 2G</code>。</p>
<p><strong>提示：</strong></p>
<ul>
<li>相较于指定 <code>-boot order=x</code> ，一部分用户感觉使用 <code>-boot menu=on</code> 启用boot菜单的体验更舒服些，至少在配置和实验时是这样的。</li>
<li>当使用无界面（headless）模式时， 将会默认在本地5900端口启动一个VNC服务器， 可以用 <a href="https://wiki.archlinux.org/title/TigerVNC">TigerVNC</a> 连接到客户机的系统上: <code>vncviewer :5900</code></li>
<li>若你在安装过程中需要替换软盘或CD，可以使用QEMU机器监视器（在虚拟机窗口中按<code>Ctrl + Alt + 2</code>）来删除存储设备并将其连接到虚拟机。使用<code>info block</code>查看块设备，然后使用<code>change</code>命令换出设备。按下<code>Ctrl + Alt + 1</code>返回虚拟机。</li>
</ul>
<h3 id="运行虚拟化的系统">运行虚拟化的系统<a hidden class="anchor" aria-hidden="true" href="#运行虚拟化的系统">#</a></h3>
<p><code>qemu-system-*</code> 程序 (例如 <code>qemu-system-i386</code> 或 <code>qemu-system-x86_64</code>, 取决于客户机架构)用来运行虚拟化的客户机. 用法是:</p>
<pre tabindex="0"><code>$ qemu-system-i386 options disk_image
</code></pre><p>所有 <code>qemu-system-*</code>的选项是相同的。</p>
<p>默认 QEMU会在窗口中显示虚拟机的视频输出.有一点要记住:当您单击QEMU窗口,鼠标指针被捕获。要放开，按 <code>Ctrl+Alt+g</code>.</p>
<p><strong>警告：</strong> QEMU 不应以 root 身份运行. 如果必须以root身份在某个脚本中运行QEMU，那么你需要使用 <code>-runas</code> 选项让QEMU放弃root权限</p>
<h4 id="启用-kvm">启用 KVM<a hidden class="anchor" aria-hidden="true" href="#启用-kvm">#</a></h4>
<p>KVM 必须要您处理器和内核支持, 和必要的 <a href="https://wiki.archlinux.org/title/Kernel_modules">kernel modules</a>加载。更多信息参见 <a href="https://wiki.archlinux.org/title/KVM">KVM</a>。</p>
<p>要在KVM模式中启动QEMU, 追加 <code>-enable-kvm</code>到启动选项. 要检查是否为正在运行的 VM 启用了 KVM，请使用 Ctrl+Alt+Shift+2 进入 QEMU Monitor，然后键入 info kvm。</p>
<p><strong>注意：</strong></p>
<ul>
<li><code>-machine</code> 选项中的 <code>accel=kvm</code> 参数与<code>-enable-kvm</code> 或 <code>-accel kvm</code> 选项是等价的。</li>
<li>CPU模型 <code>host</code> 需要 KVM。</li>
<li>如果你使用GUI工具去启动QEMU，但是性能体验极差，那么最好检查一下是否真的开启了KVM支持，因为QEMU可能选择了备用的模拟模式，即软件级模拟。</li>
<li>需要启用KVM才能正常启动windows7和windows8，否则会出现“蓝屏”.</li>
</ul>
<h4 id="启用-iommu-intel-vt-damd-vi-的支持">启用 IOMMU (Intel VT-d/AMD-Vi) 的支持<a hidden class="anchor" aria-hidden="true" href="#启用-iommu-intel-vt-damd-vi-的支持">#</a></h4>
<p>首先启用IOMMU。</p>
<p>确保您的 CPU 支持 AMD-Vi/Intel Vt-d 并且已经在 BIOS 中打开。通常这个选项会在类似“其他 CPU 特性”的菜单里，也有可能隐藏在超频选项之中。选项可能就叫做 “VT-d” 或者 “AMD-Vi” ，也有可能是更通用的名称，比如“虚拟化技术”之类。有可能您主板的手册并不会解释这些。</p>
<p>设置<a href="https://wiki.ubuntu.com/Kernel/KernelBootParameters">内核参数</a>以启用 IOMMU，注意不同品牌的 CPU 所需的内核参数并不同。</p>
<ul>
<li>对于 Intel CPU(VT-d)，使用 <code>intel_iommu=on</code>。</li>
<li>对于 AMD CPU(AMD-Vi)，使用 <code>amd_iommu=on</code>。</li>
</ul>
<p>您同时需要设置<code>iommu=pt</code>，这将防止Linux试图接触(touching)无法直通的设备。</p>
<p>在重启之后，检查 dmesg 以确认 IOMMU 已经被正确启用：</p>
<pre tabindex="0"><code>$ dmesg | grep -e DMAR -e IOMMU
...
[    0.000000] Intel-IOMMU: enabled
...
</code></pre><p>添加 <code>-device intel-iommu</code> 选项创建IOMMU设备:</p>
<pre tabindex="0"><code>$ qemu-system-x86_64 -enable-kvm -machine q35 -device intel-iommu -cpu host ..
</code></pre><p><strong>注意：</strong> 在基于Intel CPU的系统上用 <code>-device intel-iommu</code> 创建QEMU内的IOMMU设备将会禁用PCI直通， 如果需要PCI直通，则不应设置<code>-device intel-iommu</code>。</p>
<h3 id="宿主机和虚拟机数据交互">宿主机和虚拟机数据交互<a hidden class="anchor" aria-hidden="true" href="#宿主机和虚拟机数据交互">#</a></h3>
<h4 id="网络">网络<a hidden class="anchor" aria-hidden="true" href="#网络">#</a></h4>
<p>我们可以利用任何支持文件传输的网络协议实现客户机和宿主机之间的数据交互, 例如 <a href="https://wiki.archlinux.org/title/NFS">NFS</a>, <a href="https://wiki.archlinux.org/title/SMB">SMB</a>, <a href="https://en.wikipedia.org/wiki/Network_block_device">NBD</a>, HTTP, <a href="https://wiki.archlinux.org/title/Very_Secure_FTP_Daemon">FTP</a>, 或 <a href="https://wiki.archlinux.org/title/SSH">SSH</a>, 当然这么做的前提是你已经配置好二者之间的网络，且在系统上启动了相应的服务程序。</p>
<p>在默认情况下，用户模式的客户机能够通过10.0.2.2这个IP访问到宿主机。任何运行于宿主机上的服务端程序都可以通过这个地址被访问到，比如说我们可以通过这个IP访问到宿主机上的SSH服务器或SMB服务器。因此在这种情况下，客户机能够挂载宿主机通过<a href="https://wiki.archlinux.org/title/SMB">SMB</a> or <a href="https://wiki.archlinux.org/title/NFS">NFS</a>暴露出来的目录，也可以访问宿主机上的HTTP服务器等。 通常情况下宿主机无法访问客户机上的服务，不过你也可以通过一些特殊的网络配置达到这个目的 (参阅<a href="https://wiki.archlinux.org/title/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#Tap_%E7%BD%91%E7%BB%9C">#Tap 网络</a>)</p>
<h4 id="qemu-端口转发">QEMU 端口转发<a hidden class="anchor" aria-hidden="true" href="#qemu-端口转发">#</a></h4>
<p>QEMU能够将宿主机的端口转发到客户机上以实现一些功能，例如从宿主机上访问客户机的SSH端口。</p>
<p>举个例子，将宿主机上的10022端口与客户机上的22 (SSH) 端口进行绑定， 对应的QEMU命令如下：</p>
<pre tabindex="0"><code>$ qemu-system-x86_64 disk_image -nic user,hostfwd=tcp::10022-:22
</code></pre><p>确认你客户机上的sshd程序正在运行，然后可以通过如下命令连接到客户机的SSH端口</p>
<pre tabindex="0"><code>$ ssh guest-user@localhost -p 10022
</code></pre><p>你可以用 <a href="https://wiki.archlinux.org/title/SSHFS">SSHFS</a> 把客户机的整个文件系统都挂到宿主机上，这样就可以在宿主机上对客户机的文件系统进行读写了。</p>
<p>想进行多端口转发的话, 只需要在<code>-nic</code>参数中指定多个<code>hostfwd</code>, 以VNC端口为例:</p>
<pre tabindex="0"><code>$ qemu-system-x86_64 disk_image -nic user,hostfwd=tcp::10022-:22,hostfwd=tcp::5900-:5900
</code></pre><h4 id="qemu-的内置smb服务器">QEMU 的内置SMB服务器<a hidden class="anchor" aria-hidden="true" href="#qemu-的内置smb服务器">#</a></h4>
<p>QEMU的文档中指出它有一个内置的SMB服务器，但实际上，它只是在宿主机上加载一个自动生成的<code>smb.conf</code>配置文件 (位于<code>/tmp/qemu-smb.random_string</code>)，然后启动宿主机上的Samba，使得客户机能够通过一个IP地址进行访问 (默认的IP地址是10.0.2.4)。这个方法只适用于用户网络，在你不想在宿主机开启通常的Samba服务 (客户机同样能访问这类Samba服务) 时这个方法还挺好用的。</p>
<p>宿主机上必须安装 <em>Samba</em>。通过如下QEMU命令启用这项特性:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install samba
$ qemu-system-x86_64 disk_image -net nic -net user,smb<span style="color:#f92672">=</span>shared_dir_path
</code></pre></div><p><code>shared_dir_path</code> 就是你想要在宿主机和客户机之间共享的目录。</p>
<p>接着，在客户机内，你应该能够通过10.0.2.4访问到名为qemu的共享文件夹。例如在Windows Explorer中前往 <code>\\10.0.2.4\qemu</code> 这个地址。</p>
<p><strong>注意：</strong></p>
<ul>
<li>如果你像这样多次指定共享选项 <code>-net user,smb=shared_dir_path1 -net user,smb=shared_dir_path2</code> or <code>-net user,smb=shared_dir_path1,smb=shared_dir_path2</code> qemu只会共享参数中最后的一个目录。</li>
<li>如果你不能访问共享文件夹且客户机系统为 Windows, 请检查 <a href="http://ecross.mvps.org/howto/enable-netbios-over-tcp-ip-with-windows.htm">NetBIOS 协议是否被启用</a> 并确认防火墙没有屏蔽NetBIOS协议的 <a href="https://technet.microsoft.com/en-us/library/cc940063.aspx">端口</a></li>
<li>如果你不能访问共享文件夹且客户机系统为 Windows 10 Enterprise 或 Education 或 Windows Server 2016, 请<a href="https://support.microsoft.com/en-us/help/4046019">启用游客访问</a>.</li>
</ul>
<p>共享多个文件夹并在运行时增删文件夹的一个方法是：共享一个空目录，然后在其中创建指向其余共享目录的符号链接。可以用下面的脚本修改SMB服务器的配置，这个脚本还能使宿主机上不允许执行的文件在客户机内拥有执行权限。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">#!/bin/bash
</span><span style="color:#75715e"></span>eval <span style="color:#66d9ef">$(</span>ps h -C smbd -o pid,args | grep /tmp/qemu-smb | gawk <span style="color:#e6db74">&#39;{print &#34;pid=&#34;$1&#34;;conf=&#34;$6}&#39;</span><span style="color:#66d9ef">)</span>
echo <span style="color:#e6db74">&#34;[global]
</span><span style="color:#e6db74">allow insecure wide links = yes
</span><span style="color:#e6db74">[qemu]
</span><span style="color:#e6db74">follow symlinks = yes
</span><span style="color:#e6db74">wide links = yes
</span><span style="color:#e6db74">acl allow execute always = yes&#34;</span> &gt;&gt; $conf
<span style="color:#75715e"># in case the change is not detected automatically:</span>
smbcontrol --configfile<span style="color:#f92672">=</span>$conf $pid reload-config
</code></pre></div><p>仅当客户机第一次访问到网络驱动后，才能将该脚本启用，并作用于qemu启动的SMB服务器。共享多文件的另一个方法是在配置文件里加入额外的共享路径，就像下面这样</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ echo <span style="color:#e6db74">&#34;[myshare]
</span><span style="color:#e6db74">path=another_path
</span><span style="color:#e6db74">read only=no
</span><span style="color:#e6db74">guest ok=yes
</span><span style="color:#e6db74">force user=username&#34;</span> &gt;&gt; $conf
</code></pre></div><p>这个共享文件夹可以在客户机内通过<code>\\10.0.2.4\*myshare*</code>访问。</p>
<h3 id="网络-1">网络<a hidden class="anchor" aria-hidden="true" href="#网络-1">#</a></h3>
<p>采用<strong>TAP设备</strong>（<a href="https://www.cxyzjd.com/article/Longyu_wlz/107627564">tun 与 tap 设备</a>，都是虚拟网络设备，tun 设备用来实现三层隧道（三层 ip 数据报），tap 设备用来实现二层隧道（二层以太网数据帧）。）和<strong>网桥</strong>（使用网桥可以将多个接口连接到同一网段内，这一功能等同于交换式集线器。）的虚拟网络的性能应该会比使用用户模式网络或VDE要好，原因在于TAP设备和网桥是在内核中实现的。</p>
<p>此外，虚拟网络的性能可以通过将网络设备直接注册到虚拟机中改善，这比默认情况下模拟e1000 NIC的性能表现要更好，参阅 [安装 virtio 驱动](#安装 virtio 驱动) 获得更多相关信息。</p>
<h4 id="关于链路层地址的限制">关于链路层地址的限制<a hidden class="anchor" aria-hidden="true" href="#关于链路层地址的限制">#</a></h4>
<p>若在QEMU启动中指定了 <code>-net nic</code> 参数，QEMU将会为虚拟机注册一块虚拟网卡，其链路层地址为 <code>52:54:00:12:34:56</code> 。然而，当在多台虚拟机之间搭建桥接网络时，每台虚拟机在tap设备的虚拟机端都需要拥有一个独一无二的链路层地址 (MAC)，否则网桥会因为收到多个不同源却拥有相同MAC地址的数据包而无法正常工作。即使你为多个tap设备配置了不同的MAC地址也依旧会出现这个问题，因为当数据包通过tap设备时，tap设备并不会改写包内的链路层地址。</p>
<p>因此请确保每个虚拟机拥有自己独一无二的网卡地址, 并且它们都以 <code>52:54:</code> 开头。 可以通过如下命令手动设置虚拟机的MAC地址, 下面的&rsquo;X&rsquo;可以替换成任何16进制字符:</p>
<pre tabindex="0"><code>$ qemu-system-x86_64 -net nic,macaddr=52:54:XX:XX:XX:XX -net vde disk_image
</code></pre><h4 id="用户模式">用户模式<a hidden class="anchor" aria-hidden="true" href="#用户模式">#</a></h4>
<p>默认情况下，没有任何<code>-netdev</code>参数，QEMU将使用带有内置DHCP服务器的用户模式网络。当您的虚拟机运行其DHCP客户端时，将为其分配IP地址，它们将能够通过QEMU伪装的IP来访问物理主机的网络。</p>
<p><strong>警告：</strong> 仅适用于TCP和UDP协议，因此ICMP协议（包括<code>ping</code>）将不起作用。 请勿使用<code>ping</code>测试网络连接。</p>
<p>如果主机已连接Internet，则此默认配置可以使您的虚拟机轻松访问Internet。但是如果您同时启动多个虚拟机，则虚拟机将无法在外部网络上直接看到，虚拟机也将无法相互通信。</p>
<p>QEMU的用户模式网络可以提供更多功能，例如内置TFTP或SMB服务器，将主机端口重定向到虚拟机（例如，允许SSH连接到虚拟机）或将虚拟机连接到VLAN（vlan 全程 virtual lan，能够用来虚拟分配以太网。归属于不同的 VLAN ID 的设备之间需要一个路由才能够通信，这意味这不同的 VLAN ID 将以太网划分成了不同的分组。），以便它们可以彼此通信。 有关更多详细信息，请参见<code>-net user</code>标志上的QEMU文档。</p>
<p>但是，用户模式网络在效用和性能上都有局限性。更高级的网络配置需要使用TAP设备或其他方法。</p>
<h4 id="tap-网络">Tap 网络<a hidden class="anchor" aria-hidden="true" href="#tap-网络">#</a></h4>
<p><a href="https://en.wikipedia.org/wiki/TUN/TAP">Tap devices</a>是一个Linux内核特性，允许您创建作为真实网络接口的虚拟网络接口。发送到tap接口的包将被传递到一个用户空间程序(如QEMU)，该程序将自己绑定到该接口。</p>
<p>QEMU可以为虚拟机使用tap网络，因此发送到tap接口的包将被发送到虚拟机，并显示为来自虚拟机中的网络接口(通常是以太网接口)。相反，虚拟机通过其网络接口发送的所有内容都将出现在tap接口上。</p>
<p>Linux桥接驱动程    序支持Tap设备，因此可以将Tap设备彼此桥接在一起，也可以连接其他主机接口，如<code>eth0</code>。如果您希望您的虚拟机能够相互通信，或者希望LAN上的其他机器能够与虚拟机通信，那么这是非常理想的方案。</p>
<p><strong>警告：</strong> 如果您将tap设备和一些主机接口桥接在一起，例如<code>eth0</code>，您的虚拟机将直接出现在外部网络上，这将使它们遭受攻击的可能。根据您的虚拟机可以访问的资源，您可能需要采取所有<a href="https://wiki.archlinux.org/title/Firewalls">precautions</a>来保护您的虚拟机。如果风险太大,虚拟机没有资源或您设置多个虚拟机,一个更好的解决方案可能是使用<a href="https://wiki.archlinux.org/title/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E4%BB%85%E4%B8%BB%E6%9C%BA_%E7%BD%91%E7%BB%9C">host-only networking</a>建立NAT。在这种情况下，您只需要在主机上安装一个防火墙，而不是为每个虚拟机安装多个防火墙。</p>
<p>正如在用户模式网络部分中指出的，tap设备提供比用户模式具有更高的网络性能。如果虚拟机中的操作系统支持virtio网络驱动程序，那么网络性能也会显著提高。假设使用tap0设备，virtio驱动程序在客户端上使用，并且没有使用脚本来帮助启动/停止网络，使用下面的qemu命令：</p>
<pre tabindex="0"><code>-net nic,model=virtio -net tap,ifname=tap0,script=no,downscript=no
</code></pre><p>但是，如果已经使用带有virtio网络驱动程序的Tap设备，则甚至可以通过启用vhost来提高网络性能，例如：</p>
<pre tabindex="0"><code>-net nic,model=virtio -net tap,ifname=tap0,script=no,downscript=no,vhost=on
</code></pre><p><strong>仅主机网络</strong></p>
<p>如果为网桥提供了IP地址，并且使能发往该网桥的流量允许，但没有实际接口（例如<code>eth0</code>）连接到网桥，则虚拟机与虚拟机间，虚拟机与主机间能够相互通信。但是，如果您没有在物理主机上设置IP掩蔽，则他们将无法与外部网络进行通信。 此配置被其他虚拟化软件（例如<a href="https://wiki.archlinux.org/title/VirtualBox">VirtualBox</a>）称为“仅主机网络模式”。</p>
<p><strong>提示：</strong></p>
<ul>
<li>
<p>如果你想设置IP掩蔽，例如虚拟机的NAT，请查看<a href="https://wiki.archlinux.org/title/Internet_sharing#Enable_NAT">Internet sharing#Enable NAT</a>页面。</p>
</li>
<li>
<p>您也许想在网桥接口上运行一个DHCP服务器来服务虚拟网络。例如，使用<code>172.20.0.1/16</code>子网，<a href="https://wiki.archlinux.org/title/Dnsmasq">dnsmasq</a>作为DHCP服务器:</p>
<pre tabindex="0"><code># ip addr add 172.20.0.1/16 dev br0
# ip link set br0 up
# dnsmasq --interface=br0 --bind-interfaces --dhcp-range=172.20.0.2,172.20.255.254
</code></pre></li>
</ul>
<p><strong>内部网络</strong></p>
<p>如果您不为网桥提供IP地址并在<a href="https://wiki.archlinux.org/title/Iptables">iptables</a>添加INPUT规则链，将所有流向网桥中的数据丢弃，则虚拟机将能够彼此通信，但无法与物理主机或外部网络通信。此配置被其他虚拟化软件（例如<a href="https://wiki.archlinux.org/title/VirtualBox">VirtualBox</a>）称为“内部网络”。您将需要为虚拟机分配静态IP地址，或在其中一个虚拟机上运行DHCP服务器。</p>
<p>在默认情况下，iptables将丢弃桥接网络中的数据包。您可能需要使用这样的iptables规则来允许桥接网络中的数据包:</p>
<pre tabindex="0"><code># iptables -I FORWARD -m physdev --physdev-is-bridged -j ACCEPT
</code></pre><p><strong>使用 qemu-bridge-helper 桥接网络</strong></p>
<p>这种方法不需要启动脚本，并且很容易适应多个tap和多个桥。它使用<code>/usr/lib/qemu/qemu-bridge-helper</code>，允许在现有桥上创建tap设备。</p>
<p><strong>提示：</strong> 参见 <a href="https://wiki.archlinux.org/title/Network_bridge">Network bridge</a> 获取创建网桥的信息.</p>
<p>首先，创建一个配置文件，包含QEMU使用的所有网桥的名称:</p>
<pre tabindex="0"><code>/etc/qemu/bridge.conf
allow bridge0
allow bridge1
...
</code></pre><p>现在启动虚拟机：</p>
<pre tabindex="0"><code>$ qemu-system-i386 -net nic -net bridge,br=bridge0 [...]
</code></pre><p>在多个TAP设备的情况下，最基本的用法是要为所有NIC指定VLAN：</p>
<pre tabindex="0"><code>$ qemu-system-i386 -net nic -net bridge,br=bridge0 -net nic,vlan=1 -net bridge,vlan=1,br=bridge1 [...]
</code></pre><p><strong>手工创建网桥</strong></p>
<p>将虚拟机连接到主机接口，如<code>eth0</code>，这可能是最常见的配置。这种配置使虚拟机看起来直接位于外部网络，与物理主机位于同一以太网段。</p>
<p><strong>物理设备和Tap设备之间通过iptables进行网络共享</strong></p>
<p>桥接网络能在有线接口(例如eth0)之间工作，并且很容易设置。但是，如果主机通过无线设备连接到网络，则无法进行桥接。</p>
<p>解决这个问题的一种方法是，给tap设备设置一个静态IP，使linux自动处理它的路由，然后通过iptables规则转发tap接口和连接到网络的设备之间的通信。</p>
<h4 id="通过-vde2-配置网络">通过 VDE2 配置网络<a hidden class="anchor" aria-hidden="true" href="#通过-vde2-配置网络">#</a></h4>
<p>VDE全称为Virtual Distributed Ethernet，作为uml_switch的一个扩展，是一个用于管理虚拟网络的工具包</p>
<p>其基本的思想是创建一个虚拟的开关，就如插座那样，允许虚拟机和物理机通过&quot;插入&quot;连接彼此。下面的配置非常简单，然而，VDE的功能远比展示的更强大，其能够接入虚拟开关，在不同的主机上运行它们并监听开关上的通信。</p>
<p>本方法的优点在于无需sudo特权，普通用户一般没有运行modprobe的权限。</p>
<h4 id="vde2-网桥">VDE2 网桥<a hidden class="anchor" aria-hidden="true" href="#vde2-网桥">#</a></h4>
<p>任何连接到vde上的虚拟机都会暴露给外部。举个例子，每台虚拟机都能直接从ADSL路由器那收到DHCP的配置信息。</p>
<h4 id="简化配置参数">简化配置参数<a hidden class="anchor" aria-hidden="true" href="#简化配置参数">#</a></h4>
<p>如果你经常需要以不同的网络配置选项运行QEMU，就会发现时常得输入大量的<code>-netdev</code>和<code>-device</code>选项组合，这些是大量重复性的劳动。可以用<code>-nic</code>选项将二者结合，就如下面这样，底下这些参数：</p>
<pre tabindex="0"><code>-netdev tap,id=network0,ifname=tap0,script=no,downscript=no,vhost=on -device virtio-net-pci,netdev=network0
</code></pre><p>可简化为:</p>
<pre tabindex="0"><code>-nic tap,script=no,downscript=no,vhost=on,model=virtio-net-pci
</code></pre><p>要注意的是缺失了网络ID，因此将会以<code>model=</code>创建这些设备。{ic|-nic}}命令的前半部分参数正是<code>-netdev</code>的参数，而后半部分参数（<code>model=</code>之后的部分）则与设备有关，原本设备所提供的参数同样可以在此使用（例如，可以指定<code>smb=</code>）。若要完全禁用网络，可以用<code>-nic none</code>。</p>
<h3 id="图形">图形<a hidden class="anchor" aria-hidden="true" href="#图形">#</a></h3>
<p>QEMU 可以使用一下几个图形输出：std, cirrus, vmware, qxl, xenfs 和 vnc。</p>
<p>使用 <code>vnc</code> 选项，你可以单独运行客户机，并且通过 VNC 连接。</p>
<h4 id="std">std<a hidden class="anchor" aria-hidden="true" href="#std">#</a></h4>
<p>使用 <code>-vga std</code> 你可以得到最高 2560 x 1600 像素的分辨率。从 QEMU 2.2 开始是默认选项。</p>
<h4 id="qxl">qxl<a hidden class="anchor" aria-hidden="true" href="#qxl">#</a></h4>
<p>QXL是一个支持2D的并行虚拟化图形驱动。需要在客户机中安装驱动并在启动QEMU时设置<code>-vga qxl</code>选项。你可能也会想使用<a href="https://wiki.archlinux.org/title/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#SPICE">#SPICE</a>优化QXL的图形表现。</p>
<p>在Linux客户机中，需要加载<code>qxl</code>和<code>bochs_drm</code>这两个内核模块，以获得一个比较好的效果。</p>
<p>QXL设备的默认VGA内存大小为16M，这样的内存大小最高支持QHD (2560x1440)的分辨率，如果想要一个更高的分辨率，请<a href="https://wiki.archlinux.org/title/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E5%A4%9A%E5%B1%8F%E6%94%AF%E6%8C%81">增加vga_memmb</a>。</p>
<h4 id="vmware">vmware<a hidden class="anchor" aria-hidden="true" href="#vmware">#</a></h4>
<p>尽管Bug有点多，但相比于std和cirrus它的表现会更好。对于Arch Linux客户机来说可以安装<a href="https://archlinux.org/packages/?name=xf86-video-vmware">xf86-video-vmware</a>和<a href="https://archlinux.org/packages/?name=xf86-input-vmmouse">xf86-input-vmmouse</a>获取VMware驱动。</p>
<h4 id="virtio">virtio<a hidden class="anchor" aria-hidden="true" href="#virtio">#</a></h4>
<p><code>virtio-vga</code> / <code>virtio-gpu</code> 是一个基于<a href="https://virgil3d.github.io/">virgl</a>的3D并行虚拟化图形驱动。目前依旧处于开发中，仅支持最近的（&gt;= 4.4）的Linux客户机，且需要以<code>gallium-drivers=virgl</code>选项编译<a href="https://archlinux.org/packages/?name=mesa">mesa</a> (&gt;=11.2)。</p>
<p>若要在客户机上启用3D加速，那么需要用<code>-vga virtio</code>选项选择此vga，并用<code>-display sdl,gl=on</code>或<code>-display gtk,gl=on</code>在显示设备上启用opengl上下文，这两个选项分别适用于sdl输出和gtk输出。如果配置成功了，那么在客户机的kernel log里可以看到：</p>
<pre tabindex="0"><code># dmesg | grep drm 
[drm] pci: virtio-vga detected
[drm] virgl 3d acceleration enabled
</code></pre><h4 id="cirrus">cirrus<a hidden class="anchor" aria-hidden="true" href="#cirrus">#</a></h4>
<p>cirrus是<a href="https://wiki.qemu.org/ChangeLog/2.2#VGA">2.2之前</a>默认的图形选项，<a href="https://www.kraxel.org/blog/2014/10/qemu-using-cirrus-considered-harmful/">不应当</a>在现代操作系统中使用它。</p>
<h4 id="none">none<a hidden class="anchor" aria-hidden="true" href="#none">#</a></h4>
<p>这就像一台完全没有VGA卡的PC，无法通过<code>-vnc</code>访问它。另外，这种情况与使用<code>-nographic</code>选项不同，<code>-nographic</code>会让QEMU模拟VGA卡，只是关闭了SDL输出。</p>
<h3 id="spice">SPICE<a hidden class="anchor" aria-hidden="true" href="#spice">#</a></h3>
<p><a href="https://www.spice-space.org/">SPICE project</a>旨在为用户提供一种完全开源的方式，无缝地对虚拟机进行远程访问。</p>
<h3 id="vnc">VNC<a hidden class="anchor" aria-hidden="true" href="#vnc">#</a></h3>
<p>可以用<code>-vnc :*X*</code>选项将QEMU的VGA输出重定向至VNC会话中。将<code>*X*</code>替换为输出目标的编号（0代表之后监听在5900，1代表监听在5901&hellip;）。</p>
<pre tabindex="0"><code>$ qemu-system-x86_64 -vnc :0
</code></pre><p><strong>警告：</strong> 默认的VNC服务器没有使用任何验证手段，用户可以从任何主机上连接到VNC。</p>
<p><strong>基本的口令验证</strong></p>
<p>可以通过使用<code>password</code>选项很容易地设置访问口令。必须在QEMU Monitor中指定口令，仅当用户提供口令时才有可能连接到VNC。</p>
<pre tabindex="0"><code>$ qemu-system-x86_64 -vnc :0,password -monitor stdio
</code></pre><p>在QEMU Monitor中设置口令需使用<code>change vnc password</code>命令，然后指定一个口令。</p>
<p>底下的命令将在启动VNC时直接为其设置口令：</p>
<pre tabindex="0"><code>$ printf &quot;change vnc password\n%s\n&quot; MYPASSWORD | qemu-system-x86_64 -vnc :0,password -monitor stdio
</code></pre><p><strong>注意：</strong> 口令被限制在8个字符内，可以用暴力破解的方式猜到口令。因此在公网上推荐使用更细致的保护措施。</p>
<h3 id="音频">音频<a hidden class="anchor" aria-hidden="true" href="#音频">#</a></h3>
<p><code>-audiodev</code>标识用于设定后端音频驱动及其相关选项。最简单的情况下，你需要选择一个驱动并设置一个id。</p>
<pre tabindex="0"><code>-audiodev pa,id=snd0
</code></pre><h4 id="使用音频设备">使用音频设备<a hidden class="anchor" aria-hidden="true" href="#使用音频设备">#</a></h4>
<p><strong>Intel HD Audio</strong></p>
<p>模拟Intel HD Audio需要添加控制器和编解码器设备。可以用如下命令列出可用的Intel HDA Audio设备：</p>
<pre tabindex="0"><code>$ qemu-system-x86_64 -device help | grep hda
</code></pre><p>添加音频控制器：</p>
<pre tabindex="0"><code>-device ich9-intel-hda
</code></pre><p>添加音频编解码器并将其映射到宿主机的音频后端id上。</p>
<pre tabindex="0"><code>-device hda-output,audiodev=snd0
</code></pre><p><strong>Intel 82801AA AC97</strong></p>
<p>模拟AC97需要添加声卡设备并将其映射到宿主机的一个音频后端id上。</p>
<pre tabindex="0"><code>-device AC97,audiodev=snd0
</code></pre><h4 id="无音频设备">无音频设备<a hidden class="anchor" aria-hidden="true" href="#无音频设备">#</a></h4>
<p>通过如下命令获取支持模拟的音频驱动列表：</p>
<pre tabindex="0"><code>$ qemu-system-x86_64 -soundhw help
</code></pre><p>比如，要在客户机上模拟<code>hda</code>驱动，需要使用<code>-device intel-hda -device hda-duplex</code>选项启动QEMU。</p>
<p><strong>注意：</strong> 客户机的显卡模拟驱动可能也会导致客户机中的音频质量出现问题，需要一个个进行排查。使用<code>qemu-system-x86_64 -h | grep vga</code>列出可用的选项</p>
<h3 id="安装-virtio-驱动">安装 virtio 驱动<a hidden class="anchor" aria-hidden="true" href="#安装-virtio-驱动">#</a></h3>
<p>QEMU为用户提供并行虚拟化块设备和网络设备的能力，其是借助<a href="https://wiki.libvirt.org/page/Virtio">virtio</a>驱动实现的，拥有更好的性能表现以及更低的开销。</p>
<p>virtio块设备需要使用<code>-drive</code>指定一个disk image的参数，且需要带上<code>if=virtio</code>参数：</p>
<pre tabindex="0"><code>$ qemu-system-x86_64 -boot order=c -drive file=disk_image,if=virtio
</code></pre><p>网络配置也是类似的：</p>
<pre tabindex="0"><code>$ qemu-system-x86_64 -nic user,model=virtio-net-pci
</code></pre><p><strong>注意：</strong> 仅有当客户机有virtio设备对应的驱动时该方法才能起效，Linux是有这方面支持的，不过无法保证这些驱动能够兼容其他操作系统。</p>
<p>以下以windows为例。</p>
<h4 id="块设备驱动">块设备驱动<a hidden class="anchor" aria-hidden="true" href="#块设备驱动">#</a></h4>
<p>Windows没有自带virtio驱动，因此需要在安装时加载该驱动。镜像文件可以从<a href="https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/stable-virtio/virtio-win.iso">Fedora 仓库</a>下载。</p>
<p>通过ISO加载只对Windows Vista和Windows Server 2008及其之后的版本有效。这个方法的具体操作是在主磁盘设备和Windows安装盘外挂载一个额外的cdrom设备，将系统镜像与virtio驱动一同加载：</p>
<pre tabindex="0"><code>$ qemu-system-x86_64 ... \
-drive file=windows_disk_image,index=0,media=disk,if=virtio \
-drive file=windows.iso,index=2,media=cdrom \
-drive file=virtio.iso,index=3,media=cdrom \
...
</code></pre><p>在安装过程中，Windows Installer会询问你“Where do you want to install Windows?”，其会返回一个警告表示没有找到任何磁盘设备。接下来跟着如下示例中的步骤进行操作（基于Windows Server 2012 R2 with Update）：</p>
<ul>
<li>Select the option <em>Load Drivers</em>.</li>
<li>Uncheck the box for <em>Hide drivers that are not compatible with this computer&rsquo;s hardware</em>.</li>
<li>Click the browse button and open the CDROM for the virtio iso, usually named &ldquo;virtio-win-XX&rdquo;.</li>
<li>Now browse to <code>E:\viostor\[your-os]\amd64</code>, select it, and confirm.</li>
</ul>
<p>现在应该能看到virtio磁盘出现在列表中了，等待着被选中、格式化并安装。</p>
<h4 id="网络驱动">网络驱动<a hidden class="anchor" aria-hidden="true" href="#网络驱动">#</a></h4>
<p>安装virtio网络驱动程序要容易一些，只需如上所述添加<code>-net</code>参数即可。</p>
<pre tabindex="0"><code>$ qemu-system-i386 -m 4G -vga std -drive file=windows_disk_image,if=virtio -net nic,model=virtio-net-pci -cdrom virtio-win-0.1-185.iso
</code></pre><p>Windows将检测网络适配器并尝试为其找到驱动程序。如果失败，请转到“设备管理器”，找到带有感叹号图标的网络适配器（双击打开），切换到驱动程序并单击“更新驱动程序”，然后选择虚拟CD-ROM。别忘了选中显示要递归搜索目录的复选框。</p>
<h4 id="balloon-驱动">Balloon 驱动<a hidden class="anchor" aria-hidden="true" href="#balloon-驱动">#</a></h4>
<p>如果想要追踪客户机内存状态（比如通过virsh的dommemstat命令）或者在运行时改变客户机内存大小（尽管依然无法改变实际的内存大小，不过可以通过inflating balloon驱动限制内存的使用），那么请在客户机上安装balloon驱动吧。</p>
<h3 id="qemu-监视器">QEMU 监视器<a hidden class="anchor" aria-hidden="true" href="#qemu-监视器">#</a></h3>
<p>QEMU运行时会提供一个监视器console界面以方便用户同虚拟机进行交互。QEMU监视器提供了许多有趣的功能，例如获取当前虚拟机的信息，热插拔设备，创建快照等。在QEMU监视器console中运行<code>help</code>或<code>?</code>命令获得完整的命令列表。</p>
<h4 id="访问qemu监视器console">访问QEMU监视器Console<a hidden class="anchor" aria-hidden="true" href="#访问qemu监视器console">#</a></h4>
<p><strong>图形化界面</strong></p>
<p>当使用默认的<code>std</code>图形选项时，可以通过按下<code>Ctrl+Alt+2</code>组合键或从QEMU窗口上的<em>View &gt; compatmonitor0</em>访问到QEMU监视器。若要返回到虚拟机的图形界面，那么按下<code>Ctrl+Alt+1</code>或者<em>View &gt; VGA</em>就行。</p>
<p>然而，这种标准的访问方式不够方便，而且并不是在QEMU的所有图形化输出方式中都适用。</p>
<p><strong>Telnet</strong></p>
<p>启动QEMU时带上<code>-monitor telnet:127.0.0.1:*port*,server,nowait</code>参数可以启用<a href="https://wiki.archlinux.org/title/Telnet">telnet</a>。虚拟机启动后可以通过telnet访问到监视器：</p>
<pre tabindex="0"><code>$ telnet 127.0.0.1 port
</code></pre><p><strong>注意：</strong> 如果指定 <code>127.0.0.1</code> 作为监听地址，那么只能在运行QEMU的宿主机上连接到该监视器。如果想要远程访问，QEMU需要在<code>0.0.0.0</code>上进行监听：<code>-monitor telnet:0.0.0.0:*port*,server,nowait</code>。还要记住的是，最好对<a href="https://wiki.archlinux.org/title/Firewall">firewall</a>进行配置，该连接是完全不进行认证和加密的，因此需要通过防火墙确保本地网络环境是可信的。</p>
<p><strong>UNIX socket</strong></p>
<p>通过<code>-monitor unix:*socketfile*,server,nowait</code>参数运行QEMU，之后就可以通过<a href="https://archlinux.org/packages/?name=socat">socat</a>或<a href="https://archlinux.org/packages/?name=openbsd-netcat">openbsd-netcat</a>连接到监视器上。</p>
<p>例如，如果QEMU是通过如下命令启动：</p>
<pre tabindex="0"><code>$ qemu-system-x86_64 [...] -monitor unix:/tmp/monitor.sock,server,nowait [...]
</code></pre><p>就可以像这样连接到监视器上：</p>
<pre tabindex="0"><code>$ socat - UNIX-CONNECT:/tmp/monitor.sock
</code></pre><p>或者通过这种方式:</p>
<pre tabindex="0"><code>$ nc -U /tmp/monitor.sock
</code></pre><p><strong>TCP</strong></p>
<p>可以使用<code>-monitor tcp:127.0.0.1:*port*,server,nowait</code>参数将监视器暴露于TCP端口上，然后用netcat（<a href="https://archlinux.org/packages/?name=openbsd-netcat">openbsd-netcat</a>或<a href="https://archlinux.org/packages/?name=gnu-netcat">gnu-netcat</a>都可）进行连接：</p>
<pre tabindex="0"><code>$ nc 127.0.0.1 port
</code></pre><p><strong>注意：</strong> 为了能够从其它设备上通过TCP socket访问到监视器，而不仅仅从运行QEMU的主机上连接，需要像前面Telnet中描述的那样，在<code>0.0.0.0</code>地址上进行监听。</p>
<p><strong>标准 I/O</strong></p>
<p>如果以<code>-monitor stdio</code>参数运行QEMU，那么其实是可以在运行QEMU的终端下访问到监视器的。</p>
<h4 id="在monitor-conosle下向虚拟机发送按键行为">在Monitor conosle下向虚拟机发送按键行为<a hidden class="anchor" aria-hidden="true" href="#在monitor-conosle下向虚拟机发送按键行为">#</a></h4>
<p>由于在某些配置下，宿主机可能会拦截一些按键组合另作他用，这导致要在虚拟机中触发一些特定按键组合变得有些困难（一个显然的例子就是<code>Ctrl+Alt+F*</code>组合，该组合用于改变当前的tty）。我们采用在monitor console下发送按键组合的方式解决该问题。只需切换到monitor console下，然后使用<code>sendkey</code>命令，即可将按键转发至虚拟机中，例如：</p>
<pre tabindex="0"><code>(qemu) sendkey ctrl-alt-f2
</code></pre><h4 id="通过-monitor-console-创建快照和管理快照">通过 monitor console 创建快照和管理快照<a hidden class="anchor" aria-hidden="true" href="#通过-monitor-console-创建快照和管理快照">#</a></h4>
<p><strong>注意：</strong> 该特性&quot;只&quot;支持<em>qcow2</em>格式的虚拟机磁盘镜像，对于<em>raw</em>是无效的。</p>
<p>有时候我们很需要将虚拟机的当前状态进行保存，或是将虚拟机重置到之前的快照状态，而且最好是随时能进行这些操作。QEMU monitor console为用户提供了必要的功能，进行快照创建，快照管理，以及快照恢复。</p>
<ul>
<li>Use <code>savevm name</code> 用于创建一个名为<em>name</em>的快照。</li>
<li>Use <code>loadvm name</code> 用于将虚拟机状态恢复至快照<em>name</em>。</li>
<li>Use <code>delvm name</code> 用于删除快照<em>name</em>。</li>
<li>Use <code>info snapshots</code> 用于查看保存的快照列表，这些快照由一个自增长的ID和标签名（用户创建快照时赋予）进行标识。</li>
</ul>
<h4 id="以冻结模式运行虚拟机">以冻结模式运行虚拟机<a hidden class="anchor" aria-hidden="true" href="#以冻结模式运行虚拟机">#</a></h4>
<p>QEMU支持以冻结态运行虚拟机（需使用<code>-snapshot</code>参数），换句话说，虚拟机关闭时，对于虚拟机的一切修改都会丢弃。当用户对磁盘镜像写入时，这些变动最终写入的位置是<code>/tmp</code>目录下的一个临时文件，QEMU关机时将会把他们丢弃。</p>
<p>不过，即使虚拟机运行于冻结状态下，依旧可以通过monitor console将这些变化写入磁盘镜像（如果你想的话）。使用下面的命令：</p>
<pre tabindex="0"><code>(qemu) commit all
</code></pre><p>另外如果在冻结状态下创建快照，这些快照在QEMU退出时都会被丢弃，除非你显式地commit了他们。</p>
<h4 id="monitor-console中的开机和暂停命令">monitor console中的开机和暂停命令<a hidden class="anchor" aria-hidden="true" href="#monitor-console中的开机和暂停命令">#</a></h4>
<p>在QEMU monitor console下也可以模拟对物理机的一些操作：</p>
<ul>
<li><code>system_powerdown</code> 会向虚拟机发送ACPI关机信号，效果就类似物理机上按下电源按钮。</li>
<li><code>system_reset</code> 会重置虚拟机，类似物理机上的重置按钮。该操作可能导致数据丢失或文件系统的损坏，这是因为虚拟机并不是&quot;干净地&quot;重启的。</li>
<li><code>stop</code> 会暂停虚拟机。</li>
<li><code>cont</code> 使暂停的虚拟机恢复运行。</li>
</ul>
<h4 id="虚拟机截屏">虚拟机截屏<a hidden class="anchor" aria-hidden="true" href="#虚拟机截屏">#</a></h4>
<p>可以在monitor console下运行该命令，获取PPM格式的截屏图片：</p>
<pre tabindex="0"><code>(qemu) screendump file.ppm
</code></pre><h3 id="qemu-机器协议">QEMU 机器协议<a hidden class="anchor" aria-hidden="true" href="#qemu-机器协议">#</a></h3>
<p>QEMU机器协议（QMP）是一个基于JSON格式的协议，使得其他应用程序可以通过该协议控制QEMU实例。类似<a href="https://wiki.archlinux.org/title/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#QEMU_%E7%9B%91%E8%A7%86%E5%99%A8">#QEMU 监视器</a>，其提供了与运行中的虚拟机进行交互的能力，且能够编程进行控制。关于QMP各命令的描述可以在这个<a href="https://raw.githubusercontent.com/coreos/qemu/master/qmp-commands.hx">qmp-commands</a>链接中找到。</p>
<h3 id="技巧">技巧<a hidden class="anchor" aria-hidden="true" href="#技巧">#</a></h3>
<h4 id="改善虚拟机的性能表现">改善虚拟机的性能表现<a hidden class="anchor" aria-hidden="true" href="#改善虚拟机的性能表现">#</a></h4>
<p>底下是一些可以改善虚拟机性能表现的技术，例如：</p>
<ul>
<li>
<p>启用<a href="https://wiki.archlinux.org/title/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E5%90%AF%E7%94%A8_KVM">#启用 KVM</a>：QEMU的启动命令加上<code>-enable-kvm</code>选项。</p>
</li>
<li>
<p>通过<code>-cpu host</code>选项让QEMU模拟宿主机上的特定CPU，如果没有该选项QEMU尝试模拟的是一个更为通用的CPU。</p>
</li>
<li>
<p>特别的，如果客户机是Windows，启用<a href="https://blog.wikichoon.com/2014/07/enabling-hyper-v-enlightenments-with-kvm.html">Hyper-V enlightenments</a>可以改善性能：<code>-cpu host,hv_relaxed,hv_spinlocks=0x1fff,hv_vapic,hv_time</code>.</p>
</li>
<li>
<p>如果宿主机有多个核心，可以用<code>-smp</code>选项为客户机分配更多核心。</p>
</li>
<li>
<p>检查是否为虚拟机分配的足够的内存。默认情况下，QEMU仅仅为每台虚拟机分配128MiB的内存，可以使用<code>-m</code>选项分配更多的内存。例如，<code>-m 1024</code>代表启动一台内存为1024MiB的虚拟机。</p>
</li>
<li>
<p>如果客户机操作系统支持相关的驱动，可以使用<a href="https://wiki.libvirt.org/page/Virtio">virtio</a>创建网络设备或块设备。</p>
</li>
<li>
<p>使用TAP设备代替user-mode网络，参阅<a href="https://wiki.archlinux.org/title/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#Tap_%E7%BD%91%E7%BB%9C">#Tap 网络</a>。</p>
</li>
<li>
<p>如果客户机需要进行大量的磁盘写工作，在宿主机文件系统上设置合适的挂载选项可以优化该工作。例如，可以用<code>barrier=0</code>选项挂载一个<a href="https://wiki.archlinux.org/title/Ext4">ext4 file system</a>。在使用这些性能强化选项之前最好阅读相关文档，因为性能上的提升通常伴随着数据完整性下降的代价。</p>
</li>
<li>
<p>如果有一块原始磁盘镜像，你可能会想要禁用cache：</p>
<pre tabindex="0"><code>$ qemu-system-x86_64 -drive file=disk_image,if=virtio,cache=none
</code></pre></li>
<li>
<p>使用原生的Linux AIO：</p>
<pre tabindex="0"><code>$ qemu-system-x86_64 -drive file=disk_image,if=virtio,aio=native,cache.direct=on
</code></pre></li>
<li>
<p>如果正同时运行多台虚拟机，而它们拥有同样的操作系统，可以通过启用<a href="https://en.wikipedia.org/wiki/Kernel_SamePage_Merging_(KSM)">内核页归并</a>节省内存。参阅<a href="https://wiki.archlinux.org/title/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E5%BC%80%E5%90%AFKSM">#开启KSM</a>。</p>
</li>
<li>
<p>在一些情况下，可以在运行时从安装了balloon驱动的客户机上回收内存，这需要QEMU启动该客户机时使用<code>-device virtio-balloon</code>选项。</p>
</li>
<li>
<p>允许使用一个ICH-9 AHCI控制器的仿真层，尽管它并不稳定。AHCI的仿真模拟支持<a href="https://en.wikipedia.org/wiki/Native_Command_Queuing">NCQ</a>，因此可以同时处理多个读写请求：</p>
<pre tabindex="0"><code>$ qemu-system-x86_64 -drive id=disk,file=disk_image,if=none -device ich9-ahci,id=ahci -device ide-drive,drive=disk,bus=ahci.0
</code></pre></li>
</ul>
<p>参阅 <a href="https://www.linux-kvm.org/page/Tuning_KVM">https://www.linux-kvm.org/page/Tuning_KVM</a> 获取更多信息</p>
<h4 id="开机时启动qemu虚拟机">开机时启动QEMU虚拟机<a hidden class="anchor" aria-hidden="true" href="#开机时启动qemu虚拟机">#</a></h4>
<p><strong>通过libvirt实现</strong></p>
<p>如果虚拟机是通过<a href="https://wiki.archlinux.org/title/Libvirt">libvirt</a>设置的，可以用<code>virsh autostart</code>将其配置为开机自启，或者通过<em>virt-manager</em>GUI中虚拟机的Boot Options，选择&quot;Start virtual machine on host boot up&quot;实现开机自启。</p>
<p><strong>通过systemd service实现</strong></p>
<p>可以用如下的systemd unit和config配置开机时启动QEMU VM。</p>
<pre tabindex="0"><code>/etc/systemd/system/qemu@.service
[Unit]
Description=QEMU virtual machine

[Service]
Environment=&quot;haltcmd=kill -INT $MAINPID&quot;
EnvironmentFile=/etc/conf.d/qemu.d/%i
ExecStart=/usr/bin/qemu-system-x86_64 -name %i -enable-kvm -m 512 -nographic $args
ExecStop=/bin/bash -c ${haltcmd}
ExecStop=/bin/bash -c 'while nc localhost 7100; do sleep 1; done'

[Install]
WantedBy=multi-user.target
</code></pre><p><strong>注意：</strong> 为了方便地结束任务，该service会等待至console端口被释放（这意味着VM已被关闭）。</p>
<p>接着创建per-VM配置文件，命名为<code>/etc/conf.d/qemu.d/*vm_name*</code>，在其中设置好<code>args</code>和<code>haltcmd</code>变量，配置示例：</p>
<pre tabindex="0"><code>/etc/conf.d/qemu.d/one
args=&quot;-hda /dev/vg0/vm1 -serial telnet:localhost:7000,server,nowait,nodelay \
 -monitor telnet:localhost:7100,server,nowait,nodelay -vnc :0&quot;

haltcmd=&quot;echo 'system_powerdown' | nc localhost 7100&quot; # or netcat/ncat
/etc/conf.d/qemu.d/two
args=&quot;-hda /srv/kvm/vm2 -serial telnet:localhost:7001,server,nowait,nodelay -vnc :1&quot;

haltcmd=&quot;ssh powermanager@vm2 sudo poweroff&quot;
</code></pre><p>对该变量的描述如下：</p>
<ul>
<li><code>args</code> - 使用的QEMU命令行参数。</li>
<li><code>haltcmd</code> - 安全关闭虚拟机的命令，在第一个例子中，QEMU monitor是通过<code>-monitor telnet:..</code>选项暴露至telnet，因而关闭虚拟机是通过<code>nc</code>命令在monitor console中发送<code>system_powerdown</code>，完成ACPI关机的工作。在另一个例子里，使用的则是SSH。</li>
</ul>
<p>若要设置启动时运行哪个虚拟机，enable <code>qemu@*vm_name*.service</code>这个systemd单元</p>
<h4 id="鼠标整合">鼠标整合<a hidden class="anchor" aria-hidden="true" href="#鼠标整合">#</a></h4>
<p>添加<code>-usb -device usb-tablet</code>选项以避免点击客户机系统的窗口时鼠标被捕获。该选项代表QEMU能够在不捕获鼠标的情况下，向系统报告鼠标的位置，该选项启用时还会覆盖PS/2鼠标模拟功能。 命令示例：</p>
<pre tabindex="0"><code>$ qemu-system-x86_64 -hda disk_image -m 512 -usb -device usb-tablet
</code></pre><h4 id="宿主机的usb设备传递至虚拟机">宿主机的USB设备传递至虚拟机<a hidden class="anchor" aria-hidden="true" href="#宿主机的usb设备传递至虚拟机">#</a></h4>
<p>从客户机访问连接到宿主机USB口的设备是可能的，首先需要识别设备连接的位置，可以用<code>lsusb</code>命令找到设备连接位置，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ lsusb
...
Bus <span style="color:#ae81ff">003</span> Device 007: ID 0781:5406 SanDisk Corp. Cruzer Micro U3
</code></pre></div><p>上面以显示的数字分别用于标识</p>
<ul>
<li>003 host_bus</li>
<li>007 host_addr</li>
<li>0781 vendor_id</li>
<li>5406 product_id</li>
</ul>
<p>基本的思想是在QEMU中<code>-device usb-ehci,id=ehci</code>或<code>-device qemu-xhci,id=xhci</code>分别对EHCI (USB 2)或XHCI (USB 3)（在win7无法自动安装 USB3 驱动，因此应用 USB2）控制器进行模拟，然后将物理设备通过<code>-device usb-host,..</code>选项进行添加。</p>
<p>识别出该设备，并将其连接至任一总线以及宿主机上的地址，通用的语法如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">-device usb-host,bus<span style="color:#f92672">=</span>controller_id.0,vendorid<span style="color:#f92672">=</span>0xvendor_id,productid<span style="color:#f92672">=</span>0xproduct_id
</code></pre></div><p>应用于上面例子中使用的设备，它变成：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">-device usb-ehci,id<span style="color:#f92672">=</span>ehci -device usb-host,bus<span style="color:#f92672">=</span>ehci.0,vendorid<span style="color:#f92672">=</span>0x0781,productid<span style="color:#f92672">=</span>0x5406
</code></pre></div><p>运行QEMU时会遇到 <code>libusb couldn't open USB device Permission denied</code> 权限错误，可以通过 <a href="https://wiki.archlinux.org/title/Udev#About_udev_rules">udev</a> 为设备设定合适的权限。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ vi /etc/udev/rules.d/50-usbtinyisp.rules
SUBSYSTEMS<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;usb&#34;</span>, ATTRS<span style="color:#f92672">{</span>idVendor<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;0781&#34;</span>, ATTRS<span style="color:#f92672">{</span>idProduct<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;5406&#34;</span>, GROUP<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;vane&#34;</span>, MODE<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;0660&#34;</span>

$ ls -al /dve/bus/usb/003/007
crw-rw---- <span style="color:#ae81ff">1</span> root vane 189, <span style="color:#ae81ff">11</span> Nov  <span style="color:#ae81ff">7</span> 12:37 /dev/bus/usb/003/007
</code></pre></div><h4 id="使用spice进行usb重定向">使用SPICE进行USB重定向<a hidden class="anchor" aria-hidden="true" href="#使用spice进行usb重定向">#</a></h4>
<p>使用<a href="https://wiki.archlinux.org/title/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#SPICE">#SPICE</a>时可以将USB设备从客户端重定向至虚拟机中，无需使用QEMU命令。还支持为配置USB重定向插槽数（插槽数将决定可同时重定向的最大设备数）。相比于前面那种使用<code>-usbdevice</code>进行重定向的方法，SPICE方法的优势在于可以在虚拟机启动后USB设备热插拔，移除或添加USB设备时无需停机。这个方法还允许通过网络将客户端的USB设备重定向至服务端。总之，其是在QEMU虚拟机中使用USB设备最灵活的方法。</p>
<h4 id="开启ksm">开启KSM<a hidden class="anchor" aria-hidden="true" href="#开启ksm">#</a></h4>
<p>Kernel Samepage Merging (KSM) 是Linux内核的一个特性，允许应用程序向内核申请同其他申请页归并的进程进行页归并，KSM机制允许客户虚拟机之间进行页共享。当许多客户机运行相似的操作系统时，这个机制可以节省客观的内存。</p>
<h4 id="多屏支持">多屏支持<a hidden class="anchor" aria-hidden="true" href="#多屏支持">#</a></h4>
<p>Linux的QXL驱动支持默认支持四头（虚拟屏幕），可以通过<code>qxl.heads=N</code>这一内核参数进行变更。</p>
<h4 id="复制和粘贴">复制和粘贴<a hidden class="anchor" aria-hidden="true" href="#复制和粘贴">#</a></h4>
<p>在宿主机和客户机之间共享剪贴板的方法之一是使用SPICE远程桌面协议，通过SPICE客户端访问客户机，你需要遵照<a href="https://wiki.archlinux.org/title/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#SPICE">#SPICE</a>节中描述的步骤，通过该方式运行的客户机将支持与宿主机进行复制粘贴的操作。</p>
<h3 id="qemu-kvm-win7httpswwwcnblogscomsammyliup5740129html"><a href="https://www.cnblogs.com/sammyliu/p/5740129.html">QEMU-KVM Win7</a><a hidden class="anchor" aria-hidden="true" href="#qemu-kvm-win7httpswwwcnblogscomsammyliup5740129html">#</a></h3>
<h4 id="环境准备">环境准备<a hidden class="anchor" aria-hidden="true" href="#环境准备">#</a></h4>
<ol>
<li>
<p>安装QEMU：<code>sudo apt install qemu-kvm</code></p>
</li>
<li>
<p>下载 Windows virtio driver iso：https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/archive-virtio/virtio-win-0.1.102/，因为要将磁盘挂接为 virtio 磁盘。</p>
<p>需使用 virtio-win-0.1.102，我使用最新的 virtio-win-0.1.208.iso，Windows安装程序会提示驱动没有包含签名错误<code>No signed device drivers were found. Make sure that the installation media contains the correct drivers, and then click OK</code></p>
</li>
<li>
<p>创建系统盘 <code>qemu-img create -f qcow2 Windows7-VM.img 30G</code>，这将作为Win7的操作系统盘。</p>
</li>
<li>
<p>创建启动脚本</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ vi start_Windows7_VM.sh
<span style="color:#75715e">#!/bin/bash</span>
DISKIMG<span style="color:#f92672">=</span>$HOME/.vm/Windows7-VM.img
exec qemu-system-x86_64 --enable-kvm <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>	-cpu host,hv_relaxed,hv_spinlocks<span style="color:#f92672">=</span>0x1fff,hv_vapic,hv_time <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>	-drive file<span style="color:#f92672">=</span><span style="color:#e6db74">${</span>DISKIMG<span style="color:#e6db74">}</span>,if<span style="color:#f92672">=</span>virtio <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>	-net nic,model<span style="color:#f92672">=</span>virtio-net-pci -net user,smb<span style="color:#f92672">=</span>$HOME/Downloads <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>	-m <span style="color:#ae81ff">4096</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>	-smp cores<span style="color:#f92672">=</span>2,threads<span style="color:#f92672">=</span><span style="color:#ae81ff">4</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>	-monitor stdio <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>	-vga std <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>	-audiodev pa,id<span style="color:#f92672">=</span>snd0 -device ich9-intel-hda -device hda-output,audiodev<span style="color:#f92672">=</span>snd0 <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>	-usb -device usb-tablet <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>	-rtc base<span style="color:#f92672">=</span>localtime,clock<span style="color:#f92672">=</span>host  <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>	-name <span style="color:#e6db74">&#39;Windows7 VM&#39;</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>	$@

$ chmod u+x start_Windows7_VM.sh
</code></pre></div></li>
<li>
<p><code>./start_Windows7_VM.sh -boot d -cdrom $HOME/Downloads/cn_windows_7_ultimate_x64_dvd_x15-66043.iso -drive file=$HOME/Downloads/virtio-win-0.1.102.iso,index=3,media=cdrom</code></p>
</li>
</ol>
<h4 id="安装-win-7">安装 Win 7<a hidden class="anchor" aria-hidden="true" href="#安装-win-7">#</a></h4>
<ol>
<li>选择 Custom（advanced）</li>
</ol>
<p><img loading="lazy" src="/Distributions/697113-20160805095506903-82521289.jpg" alt="img"  />
</p>
<ol start="2">
<li>选择 CD Drive (E:) virtio-win</li>
</ol>
<p><img loading="lazy" src="/Distributions/697113-20160805095551856-1022452692.jpg" alt="img"  />
</p>
<ol start="3">
<li>选择 viostor</li>
</ol>
<p><img loading="lazy" src="/Distributions/697113-20160805095644122-1127564092.jpg" alt="img"  />
</p>
<ol start="4">
<li>安装 Win7 Virtio SCSI Driver</li>
</ol>
<p><img loading="lazy" src="/Distributions/697113-20160805095724137-1062705244.jpg" alt="img"  />
</p>
<ol start="5">
<li>安装好以后，就可以看到安装的目标磁盘了</li>
</ol>
<p><img loading="lazy" src="/Distributions/697113-20160805095804262-1125252105.jpg" alt="img"  />
</p>
<ol start="6">
<li>进入常规的 Win7 安装流程</li>
</ol>
<p><img loading="lazy" src="/Distributions/697113-20160805095838481-127974813.jpg" alt="img"  />
</p>
<h4 id="安装-virtio-网络驱动">安装 Virtio 网络驱动<a hidden class="anchor" aria-hidden="true" href="#安装-virtio-网络驱动">#</a></h4>
<p><img loading="lazy" src="/Distributions/697113-20160805100148122-512197961.jpg" alt="img"  />
</p>
<p>但是安装失败：</p>
<p><img loading="lazy" src="/Distributions/697113-20160805100403059-506876837.jpg" alt="img"  />
</p>
<p>尝试 device manager 安装：</p>
<p><img loading="lazy" src="/Distributions/697113-20160805100907340-1175076487.jpg" alt="img"  />
</p>
<h4 id="qemu-的内置smb服务器qemu-的内置smb服务器">[QEMU 的内置SMB服务器](#QEMU 的内置SMB服务器)<a hidden class="anchor" aria-hidden="true" href="#qemu-的内置smb服务器qemu-的内置smb服务器">#</a></h4>
<h4 id="宿主机的usb设备传递至虚拟机宿主机的usb设备传递至虚拟机"><a href="#%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%9A%84USB%E8%AE%BE%E5%A4%87%E4%BC%A0%E9%80%92%E8%87%B3%E8%99%9A%E6%8B%9F%E6%9C%BA">宿主机的USB设备传递至虚拟机</a><a hidden class="anchor" aria-hidden="true" href="#宿主机的usb设备传递至虚拟机宿主机的usb设备传递至虚拟机">#</a></h4>
<h3 id="qemu-kvm-winxp-sp3">QEMU-KVM WinXP SP3<a hidden class="anchor" aria-hidden="true" href="#qemu-kvm-winxp-sp3">#</a></h3>
<h4 id="windows_xpshhttpsgistgithubcomandrusha1000766"><a href="https://gist.github.com/andrusha/1000766">windows_xp.sh</a><a hidden class="anchor" aria-hidden="true" href="#windows_xpshhttpsgistgithubcomandrusha1000766">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">#!/bin/bash
</span><span style="color:#75715e"></span>DISKIMG<span style="color:#f92672">=</span>$HOME/.vm/WindowsXP-VM.img
exec qemu-system-x86_64 --enable-kvm <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>	-cpu host,hv_relaxed,hv_spinlocks<span style="color:#f92672">=</span>0x1fff,hv_vapic,hv_time <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>	-drive file<span style="color:#f92672">=</span><span style="color:#e6db74">${</span>DISKIMG<span style="color:#e6db74">}</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>	-net nic,model<span style="color:#f92672">=</span>rtl8139 -net user,smb<span style="color:#f92672">=</span>$HOME/Downloads <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>	-m <span style="color:#ae81ff">4096</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>	-cpu Nehalem <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>	-rtc base<span style="color:#f92672">=</span>localtime,clock<span style="color:#f92672">=</span>host  <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>	-usb -device usb-tablet <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>	-monitor stdio <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>	-vga std <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>	$@
</code></pre></div><h5 id="windows-xp-cannot-connect-to-samba-sharehttpsaskubuntucomquestions1268132windows-xp-cannot-connect-to-samba-share-linux-server-20-04"><a href="https://askubuntu.com/questions/1268132/windows-xp-cannot-connect-to-samba-share-linux-server-20-04">Windows XP cannot connect to samba share</a><a hidden class="anchor" aria-hidden="true" href="#windows-xp-cannot-connect-to-samba-sharehttpsaskubuntucomquestions1268132windows-xp-cannot-connect-to-samba-share-linux-server-20-04">#</a></h5>
<p>You have &lsquo;client min protocol = NT1&rsquo; set, there is another similar setting &lsquo;server min protocol&rsquo; which from Samba 4.11.0 is set to SMBv2. Your XP is probably only using SMBv1, so it will not be able to see or connect to your Samba server.</p>
<p>So you have to edit the <code>[global]</code> section in the <code>/etc/samba/smb.conf</code> and add the <code>server min protocol = NT1</code> option here. Then restart the Samba service.</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ps h -C smbd -o pid,args
<span style="color:#ae81ff">1707</span> /usr/sbin/smbd --foreground --no-process-group
$ vim /tmp/qemu-smb.SL95F1/smb.conf
<span style="color:#f92672">[</span>global<span style="color:#f92672">]</span>
server min protocol <span style="color:#f92672">=</span> NT1
$ sudo smbcontrol <span style="color:#ae81ff">1707</span> reload-config
</code></pre></div><p>或者编写如下脚本</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">#!/bin/bash
</span><span style="color:#75715e"></span>echo <span style="color:#e6db74">&#34;[global]
</span><span style="color:#e6db74">server min protocol = NT1&#34;</span> &gt;&gt; /tmp/**/smb.conf
sudo smbcontrol <span style="color:#66d9ef">$(</span>ps h -C smbd -o pid<span style="color:#66d9ef">)</span> reload-config
</code></pre></div><h5 id="windows-xp-上网提示您的时钟快了慢了httpsblogcsdnnetjohnnysun2015articledetails104888159"><a href="https://blog.csdn.net/JohnnySun2015/article/details/104888159">Windows XP 上网提示：您的时钟快了/慢了</a><a hidden class="anchor" aria-hidden="true" href="#windows-xp-上网提示您的时钟快了慢了httpsblogcsdnnetjohnnysun2015articledetails104888159">#</a></h5>
<p>此时，无论你怎么调整日期和时间，都不能解决上网问题。即使把日期从2020年调整到2015年，此时虽然不在提示 “您的时钟快了”，也有证书期限等异常。</p>
<p>出现这种问题的原因，是因为 Windows XP 确实太老了，Google Chrome、Mozilla Firefox 及其内核的浏览器已经不支持了。</p>
<h4 id="virtual-machine-manager">Virtual Machine Manager<a hidden class="anchor" aria-hidden="true" href="#virtual-machine-manager">#</a></h4>
<h5 id="键盘不能输入的问题httpsblog51ctocomwsxxsl1914181"><a href="https://blog.51cto.com/wsxxsl/1914181">键盘不能输入的问题</a><a hidden class="anchor" aria-hidden="true" href="#键盘不能输入的问题httpsblog51ctocomwsxxsl1914181">#</a></h5>
<p>在 Display 中，设定 keymap，比如 en-us</p>
<h5 id="无网络">无网络<a hidden class="anchor" aria-hidden="true" href="#无网络">#</a></h5>
<p>在 NIC 中，将 Device model 设置为 rtl8139</p>
<h3 id="qemu-kvm-gentoohttpswikigentooorgwikiqemulinux_guest"><a href="https://wiki.gentoo.org/wiki/QEMU/Linux_guest">QEMU-KVM Gentoo</a><a hidden class="anchor" aria-hidden="true" href="#qemu-kvm-gentoohttpswikigentooorgwikiqemulinux_guest">#</a></h3>
<h4 id="configuration">Configuration<a hidden class="anchor" aria-hidden="true" href="#configuration">#</a></h4>
<h5 id="host">Host<a hidden class="anchor" aria-hidden="true" href="#host">#</a></h5>
<p>To create a disk image for the virtual machine, run:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ qemu-img create -f qcow2 Gentoo-VM.img 30G
</code></pre></div><p>Download a minimal Gentoo LiveCD from <a href="https://www.gentoo.org/downloads/">here</a>.</p>
<p>Since QEMU requires a lot of <a href="https://wiki.gentoo.org/wiki/QEMU/Options">options</a>, it would be a good idea to put them into a shell script, e.g.:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ vim start_Gentoo_VM.sh
<span style="color:#75715e">#!/bin/bash</span>
DISKIMG<span style="color:#f92672">=</span>$HOME/VirtualMachine/Gentoo-VM.img
exec qemu-system-x86_64 -enable-kvm <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>        -bios /usr/share/edk2-ovmf/OVMF_CODE.fd <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>        -cpu host <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>        -drive file<span style="color:#f92672">=</span><span style="color:#e6db74">${</span>DISKIMG<span style="color:#e6db74">}</span>,if<span style="color:#f92672">=</span>virtio <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>        -netdev user,id<span style="color:#f92672">=</span>vmnic,hostname<span style="color:#f92672">=</span>Gentoo-VM,hostfwd<span style="color:#f92672">=</span>tcp::10022-:22 <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>        -device virtio-net,netdev<span style="color:#f92672">=</span>vmnic <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>        -device virtio-rng-pci <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>        -m 4G <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>        -smp <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>        -monitor stdio <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>        -vga std <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>        -audiodev pa,id<span style="color:#f92672">=</span>snd0 -device ich9-intel-hda -device hda-output,audiodev<span style="color:#f92672">=</span>snd0 <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>        -name <span style="color:#e6db74">&#34;Gentoo VM&#34;</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>        $@
        
$ chmod u+x start_Gentoo_VM.sh
</code></pre></div><p>Change the path to your disk image Gentoo-VM.img in the script. You can add more options when calling the script. To boot the disk image, run:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ./start_Gentoo_VM.sh -boot d -cdrom $HOME/Downloads/install-amd64-minimal-20211107T170547Z.iso
</code></pre></div><p>Install the guest per the <a href="https://wiki.gentoo.org/wiki/Handbook:Main_Page">Gentoo Handbook</a>. See the <a href="https://wiki.gentoo.org/wiki/QEMU/Linux_guest#Guest">guest section</a> for optimum support. After the installation start the script without the additional options.</p>
<h5 id="using-uefi-with-qemuhttpsfedoraprojectorgwikiusing_uefi_with_qemu"><a href="https://fedoraproject.org/wiki/Using_UEFI_with_QEMU">Using UEFI with QEMU</a><a hidden class="anchor" aria-hidden="true" href="#using-uefi-with-qemuhttpsfedoraprojectorgwikiusing_uefi_with_qemu">#</a></h5>
<p>UEFI for x86 QEMU/KVM VMs is called OVMF (Open Virtual Machine Firmware). It comes from EDK2 (EFI Development Kit), which is the UEFI reference implementation.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt-get install ovmf 
</code></pre></div><p><a href="https://www.ubuntubuzz.com/2021/04/how-to-boot-uefi-on-qemu.html">检查是否安装</a>，命令为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ dpkg -L ovmf | grep OVMF.fd 
/usr/share/ovmf/ OVMF.fd
/usr/share/qemu/ OVMF.fd
</code></pre></div><p>要在虚拟机中运行操作系统的映像文件，添加 <code>-bios /usr/share/ovmf/OVMF.fd</code>。该代码调用名为 OVMF.fd 的文件，该文件是 Qemu 的 UEFI 固件。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ qemu-system-x86_64 -bios /usr/share/ovmf/OVMF.fd -cdrom ubuntu-21.04-desktop-amd64.iso
</code></pre></div><p>这个名为<em>ovmf的</em>包其实就是名为TianoCore的程序。该名称本身代表<a href="https://github.com/tianocore/tianocore.github.io/wiki/OVMF-FAQ#what-is-open-virtual-machine-firmware-ovmf">开放虚拟机固件</a>)。</p>
<h4 id="bdsdxe-failed-to-load-boot0001httpsgithubcomutmapputmissues2333"><a href="https://github.com/utmapp/UTM/issues/2333">&ldquo;BdsDxe: failed to load Boot0001&rdquo;</a><a hidden class="anchor" aria-hidden="true" href="#bdsdxe-failed-to-load-boot0001httpsgithubcomutmapputmissues2333">#</a></h4>
<p><a href="https://www.reddit.com/r/Proxmox/comments/ckfthg/vm_no_longer_boots_after_creating_windows_10_vm/">solution</a>: Try hitting F2 to enter the OVMF settings during guest boot and manually pick a new boot drive option.</p>
<h3 id="tips">Tips<a hidden class="anchor" aria-hidden="true" href="#tips">#</a></h3>
<h4 id="通过-qemu-安装-windows-到硬盘">通过 Qemu 安装 Windows 到硬盘<a hidden class="anchor" aria-hidden="true" href="#通过-qemu-安装-windows-到硬盘">#</a></h4>
<p>双系统新思路。今天装windows, 在linux上先用虚拟机，把硬盘直通进去，在raw盘上装好，然后更新grub, 再重启就可以直接接进去了。</p>
<p>这样可以避免装机还要做启动盘，装机过程中的重启也可以避免了。</p>
<p>win的安装过程中驱动都是按照虚拟机的配置安装的，但是win10是自动装驱动的，重启进去后过了一会显卡驱动自动都装好了。</p>
<h4 id="looking-glasshttpslooking-glassiodocs"><a href="https://looking-glass.io/docs">Looking Glass</a><a hidden class="anchor" aria-hidden="true" href="#looking-glasshttpslooking-glassiodocs">#</a></h4>
<p><strong><a href="https://unwire.hk/2017/12/20/lookingglass/game-channel/">Looking Glass 讓 Linux 可完美玩 Windows 遊戲 超低延遲不掉格</a></strong></p>
<p>當用戶安裝了虛擬電腦（VM）實行 Windows，並執行遊戲時，它採用的 KVM frame relay 技術可將 Windows 顯示記憶體，透過 PCI pass-through 直接由 Windows VM 被配置的顯示卡，複製到 Linux 被配置的顯示卡，這樣 Linux 便可在極為低延遲的情況下，接近完美顯示 Windows 遊戲的內容。</p>
<p>簡單來說，就是一部 Linux 電腦裡面裝有虛擬電腦運行的 Windows，Windows 遊戲實行時，在被配置的顯示卡記憶體資料，在主機板 PCI 通道直接複製到 Linux 被配置的顯示卡。即是說 Windows 遊戲原本畫面，可高速反映到 Liunx 的虛擬電腦軟件上。這樣 Linux 用戶就算不 Dual boot 或使用兩個熒幕，在 Linux 上都可得到接近相同的打機體驗。</p>
<h4 id="xrdphttpsgithubcomneutrinolabsxrdp"><a href="https://github.com/neutrinolabs/xrdp">xrdp</a><a hidden class="anchor" aria-hidden="true" href="#xrdphttpsgithubcomneutrinolabsxrdp">#</a></h4>
<p>xrdp 使用 RDP（Microsoft 远程桌面协议）为远程计算机提供图形登录。xrdp 接受来自各种 RDP 客户端的连接：FreeRDP、rdesktop、NeutrinoRDP 和 Microsoft 远程桌面客户端（适用于 Windows、macOS、iOS 和 Android）。</p>
<p>正如 Windows 到 Windows 远程桌面一样，xrdp 不仅支持图形远程处理，还支持</p>
<ul>
<li>双向剪贴板传输（文本、位图、文件）</li>
<li>音频重定向</li>
<li>驱动器重定向（在远程机器上安装本地客户端驱动器）</li>
</ul>
<p>RDP 传输默认使用 TLS 加密。</p>
<h4 id="qemukvm-vs-virtualbox">QEMU/KVM VS Virtualbox<a hidden class="anchor" aria-hidden="true" href="#qemukvm-vs-virtualbox">#</a></h4>
<p><a href="https://linuxconfig.org/virtualization-solutions-on-linux-systems-kvm-and-virtualbox"><strong>Linux 系统上的虚拟化解决方案 – KVM 和 VirtualBox</strong></a></p>
<p>KVM 提供了一些 VirtualBox 没有的功能，反之亦然。IT 世界中没有通用工具，因此使用适合您需求的工具非常重要。基本思想是：如果你想安装二进制 Linux 发行版作为来宾，使用 KVM。它速度更快，并且它的驱动程序包含在官方内核树中。如果您的客户涉及大量编译并且需要一些更高级的功能，并且/或者不是 Linux 系统，那么最好使用 VirtualBox。</p>
<p>技术原因很简单：KVM 更好地与 Linux 集成，它更小更快，虽然你可以在 Linux 以外的其他客户机上使用它，但我们发现体验相当麻烦：BSD 的 I/O 和 Solaris 往往很慢（确切地说，是 OpenIndiana）在引导安装 ISO 后会立即出现恐慌。由于我们使用当前版本的 BSD（并且经常从源代码编译/更新系统）并且还需要 Solaris，我们发现 VirtualBox 是一个更好的选择。Oracle VirtualBox 的另一个优点是它支持挂起，即您可以将机器状态保存在主机的硬盘上并关闭 VirtualBox，当（重新)启动时，系统将从它离开的地方恢复。这就是为什么我们提到源代码编译：如果你有一台嘈杂的机器，你不想一夜之间离开，但你的 Gentoo 虚拟机只是编译一个新的 gcc 版本，暂停机器状态，关闭主机，明天继续。</p>
<p><a href="https://www.reddit.com/r/sysadmin/comments/by9fkb/desktop_virtualization_kvm_or_virtualbox/"><strong>桌面虚拟化、KVM 还是 Virtualbox？</strong></a></p>
<p>这两者中的哪一个更适合在 Linux 台式机/笔记本电脑上运行 Windows 10 虚拟机？</p>
<ul>
<li>
<p><a href="https://virt-manager.org/">带有virt-manager 的</a>QEMU/KVM应该可以与 Virtualbox 媲美。</p>
<p>Virtualbox 没问题，特别是如果跨主机操作系统使用相同的虚拟化很重要，但 QEMU/KVM 是更好的投资。QEMU/HAXM 也应该可以在 Mac 和 Windows 上运行，尽管它目前还不够成熟。</p>
</li>
<li>
<p>KVM, obviously. You&rsquo;re probably going to need to learn how to manage it, but it is a much better system and allows abstraction on completely unexposed CPU hardware so you can easily take your image and put it onto another KVM. Windows doesn&rsquo;t like to have it&rsquo;s CPUs exchange on it very often.</p>
</li>
</ul>
<p><a href="https://www.cpqlinux.com/kvm-vs-virtualbox/"><strong>KVM 与 VirtualBox</strong></a></p>
<ul>
<li>
<p>表现</p>
<p>这是要考虑的最重要的领域之一，即管理程序的性能将如何影响您的基础架构。KVM 是 1 类管理程序（这些虚拟机管理程序直接运行在宿主机的硬件上来控制硬件和管理客操作系统），而 VirtualBox 是 2 类管理程序（这些虚拟机管理程序运行在传统的操作系统上，就像其他计算机程序那样运行），这意味着 KVM 应该优于 VirtualBox。</p>
<p><a href="https://www.spec.org/virt_sc2013/">根据SPECvirt_sc2013 基准测试</a>，VirtualBox 通常比 KVM 需要更多时间来创建和启动服务器，而 KVM 以接近本机的速度运行应用程序，比其他行业管理程序更快。尽管对于典型负载，差异可能微不足道。</p>
</li>
<li>
<p>管理程序管理</p>
<p>这两个给定的应用程序都可以通过 GUI 进行管理。Virtualbox 相对来说有更好的 GUI，但 KVM 的当前 GUI 使其管理比以往任何时候都更容易。”</p>
<p>如果您更喜欢命令行，那么 KVM 中有各种命令行选项。Virtualbox 也提供了一个命令行界面，但它不如 KVM virsh 全面。您不能直接从 bash 启动 Virtualbox VM。</p>
</li>
<li>
<p>可扩展性</p>
<p>KVM 继承了 Linux 的性能，如果来宾机器和请求的数量增加，可以扩展以匹配需求负载。KVM 允许对要求最苛刻的应用程序工作负载进行虚拟化，并且是许多企业虚拟化设置的基础，例如数据中心和私有云。</p>
<p>VirtualBox 可以为每个 VM 提供多达 32 个虚拟 CPU，而不管主机上物理存在多少 CPU 内核。还可以为具有多达 1024 个 CPU 的主机提供支持。</p>
</li>
<li>
<p>安全</p>
<p>KVM 提供增强的安全性，因为它结合使用 SELinux 和安全虚拟化 (sVirt)。VirtualBox 可以执行虚拟机的安全实时迁移和磁盘映像加密。它还包括远程桌面协议 (RDP) 身份验证和用于创建进一步身份验证要求以帮助提高安全性的 SDK。<a href="https://docs.oracle.com/en/virtualization/virtualbox/6.0/admin/security-features.html">您可以在此页面</a>上看到 Virtualbox 的安全功能列表。</p>
</li>
<li>
<p>成本和定价</p>
<p>KVM 是一个开源的免费平台，由 Red Hat 等供应商提供有偿支持。虽然 Virtualbox 在限制范围内是免费的。一旦您超过一定的使用水平，您必须获得产品许可。</p>
</li>
<li>
<p>支持</p>
<p>对于 KVM，您需要依赖开源社区和您自己的 IT 组织或受支持的供应商（如红帽）的支持。Oracle 正在积极开发 Virtualbox，您可以从他们那里获得任何支持。</p>
</li>
</ul>
<h3 id="libvirthttpswikiarchlinuxorgtitlelibvirt_e7ae80e4bd93e4b8ade69687"><a href="https://wiki.archlinux.org/title/Libvirt_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">libvirt</a><a hidden class="anchor" aria-hidden="true" href="#libvirthttpswikiarchlinuxorgtitlelibvirt_e7ae80e4bd93e4b8ade69687">#</a></h3>
<p>Libvirt 是一组软件的汇集，提供了管理虚拟机和其它虚拟化功能（如：存储和网络接口等）的便利途径。这些软件包括：一个长期稳定的 C 语言 API、一个守护进程（libvirtd）和一个命令行工具（virsh）。Libvirt 的主要目标是提供一个单一途径以管理多种不同虚拟化方案以及虚拟化主机，<a href="https://libvirt.org/drivers.html">包括</a>：KVM/QEMU，Xen，LXC，OpenVZ 或 VirtualBox hypervisors。</p>
<p>Libvirt 的一些主要功能如下：</p>
<ul>
<li><strong>VM management（虚拟机管理）</strong>：各种虚拟机生命周期的操作，如：启动、停止、暂停、保存、恢复和迁移等；多种不同类型设备的热插拔操作，包括磁盘、网络接口、内存、CPU等。</li>
<li><strong>Remote machine support（支持远程连接）</strong>：Libvirt 的所有功能都可以在运行着 libvirt 守护进程的机器上执行，包括远程机器。通过最简便且无需额外配置的 SSH 协议，远程连接可支持多种网络连接方式。</li>
<li><strong>Storage management（存储管理）</strong>：任何运行 libvirt 守护进程的主机都可以用于管理多种类型的存储：创建多种类型的文件镜像（qcow2，vmdk，raw，&hellip;），挂载 NFS 共享，枚举现有 LVM 卷组，创建新的 LVM 卷组和逻辑卷，对裸磁盘设备分区，挂载 iSCSI 共享，以及更多&hellip;&hellip;</li>
<li><strong>Network interface management（网络接口管理）</strong>：任何运行 libvirt 守护进程的主机都可以用于管理物理的和逻辑的网络接口，枚举现有接口，配置（和创建）接口、桥接、VLAN、端口绑定。</li>
<li><strong>Virtual NAT and Route based networking（虚拟 NAT 和基于路由的网络）</strong>：任何运行 libvirt 守护进程的主机都可以管理和创建虚拟网络。Libvirt 虚拟网络使用防火墙规则实现一个路由器，为虚拟机提供到主机网络的透明访问。</li>
</ul>
<h4 id="安装httpsubuntucomserverdocsvirtualization-libvirt"><a href="https://ubuntu.com/server/docs/virtualization-libvirt">安装</a><a hidden class="anchor" aria-hidden="true" href="#安装httpsubuntucomserverdocsvirtualization-libvirt">#</a></h4>
<p>基于守护进程/客户端的架构的 libvirt 只需要安装在需要要实现虚拟化的机器上。注意，服务器和客户端可以是相同的物理机器。</p>
<p><strong>服务端</strong></p>
<p>安装 libvirt 以及至少一个虚拟运行环境（hypervisor）：<a href="https://libvirt.org/drvqemu.html">libvirt 的 KVM/QEMU 驱动</a> 是 <em>libvirt</em> 的首选驱动，如果 KVM 功能已启用，则支持全虚拟化和硬件加速的客户机。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt update
$ sudo apt install qemu-kvm libvirt-daemon-system
</code></pre></div><p>安装 libvirt-daemon-system 后，需要将用于管理虚拟机的用户添加到<em>libvirt</em>组中。这对于 sudo 组的成员是自动完成的，但对于应该访问系统范围的 libvirt 资源的其他任何人，都需要另外完成。这样做将授予用户访问高级网络选项的权限。</p>
<p>在终端中输入：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo adduser $USER libvirt
</code></pre></div><p>如果选择的用户是当前用户，您需要注销并重新登录才能使新的组成员身份生效。</p>
<p><strong>客户端</strong></p>
<p>客户端是用于管理和访问虚拟机的用户界面。</p>
<ul>
<li><strong>virsh</strong> — <em>virsh</em> 是用于管理和配置域（虚拟机）的命令行程序。</li>
<li><strong><a href="https://en.wikipedia.org/wiki/Virtual_Machine_Manager">Virtual Machine Manager</a></strong> — 使用libvirt对KVM，Xen，LXC进行管理的图形化工具。</li>
</ul>
<h4 id="配置-2">配置<a hidden class="anchor" aria-hidden="true" href="#配置-2">#</a></h4>
<p>对于<em><strong>系统</strong></em> 级别的管理任务（如：全局配置和镜像<em>卷</em> 位置），libvirt 要求至少要设置授权和启动守护进程。</p>
<p><strong>注意：</strong> 对于用户<em><strong>会话</strong></em> 级别的管理任务，守护进程的安装和设置<em>不是</em> 必须的。授权总是仅限本地，前台程序将启动一个 <strong>libvirtd</strong> 守护进程的本地实例。</p>
<h5 id="设置授权">设置授权<a hidden class="anchor" aria-hidden="true" href="#设置授权">#</a></h5>
<p>自 <a href="https://libvirt.org/auth.html#ACL_server_config">libvirt：连接授权</a>：Libvirt 守护进程允许管理员分别为客户端连接的每个网络 socket 选择不同授权机制。这主要是通过 libvirt 守护进程的主配置文件 <code>/etc/libvirt/libvirtd.conf</code> 来实现的。每个 libvirt socket 可以有独立的授权机制配置。目前的可选项有 <code>none</code>、<code>polkit</code> 和 <code>sasl</code>。</p>
<p>由于 libvirt 在安装时将把 polkit 作为依赖一并安装，所以 polkit 通常是 <code>unix_sock_auth</code> 参数的默认值。但基于文件的权限仍然可用。</p>
<p><strong>使用 polkit</strong></p>
<p><strong>注意：</strong> 为使 <code>polkit</code> 认证工作正常，应该重启一次系统。</p>
<p><em>libvirt</em> 守护进程在 polkit 策略配置文件（<code>/usr/share/polkit-1/actions/org.libvirt.unix.policy</code>）中提供了两种<strong>策略</strong>：</p>
<ul>
<li><code>org.libvirt.unix.manage</code> 面向完全的管理访问（读写模式后台 socket），以及</li>
<li><code>org.libvirt.unix.monitor</code> 面向仅监视察看访问（只读 socket）。</li>
</ul>
<p>默认的面向读写模式后台 socket 的策略将请求认证为管理员。这点类似于 sudo 认证，但它并不要求客户应用最终以 root 身份运行。默认策略下也仍然允许任何应用连接到只读 socket。</p>
<p><strong>基于文件的权限授权</strong></p>
<p>为了给 <em>libvirt</em> 组用户定义基于文件的权限以管理虚拟机，取消下列行的注释：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ vim /etc/libvirt/libvirtd.conf
<span style="color:#75715e">#unix_sock_group = &#34;libvirt&#34;</span>
<span style="color:#75715e">#unix_sock_ro_perms = &#34;0777&#34;  # set to 0770 to deny non-group libvirt users</span>
<span style="color:#75715e">#unix_sock_rw_perms = &#34;0770&#34;</span>
<span style="color:#75715e">#auth_unix_ro = &#34;none&#34;</span>
<span style="color:#75715e">#auth_unix_rw = &#34;none&#34;</span>
</code></pre></div><p>有些资料提到可以通过改变某些特定 libvirt 目录的权限以简化管理。需要记住的是：包更新时，这些变更会丢失。如要修改这些系统目录的权限，需要 root 用户权限。</p>
<h5 id="守护进程">守护进程<a hidden class="anchor" aria-hidden="true" href="#守护进程">#</a></h5>
<p><code>libvirtd.service</code> 和 <code>virtlogd.service</code>这两个服务单元都要启动。可以把 <code>libvirtd.service</code> 设置为启用，这时系统将同时启用 <code>virtlogd.service</code> 和 <code>virtlockd.socket</code> 两个服务单元，因此后二者不必再设置为<strong>启用</strong>。</p>
<h4 id="测试">测试<a hidden class="anchor" aria-hidden="true" href="#测试">#</a></h4>
<p>测试 libvirt 在<em>系统</em>级工作是否正常：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ virsh -c qemu:///system
</code></pre></div><p>测试 libvirt 在用户<em>会话</em>级工作是否正常：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ virsh -c qemu:///session
</code></pre></div><h4 id="管理-1">管理<a hidden class="anchor" aria-hidden="true" href="#管理-1">#</a></h4>
<p>绝大部分的 libvirt 管理可以通过三个工具实现：<code>virt-manager</code>（图形界面）、<code>virsh</code> 和 <code>guestfish</code>（它是 <code>libguestfs</code> 的一部分）。</p>
<h5 id="virsh">virsh<a hidden class="anchor" aria-hidden="true" href="#virsh">#</a></h5>
<p>Visrsh 用于管理客户<em>域</em>（虚拟机），在脚本式虚拟化管理环境中工作良好。由于需要通过通讯管道与虚拟运行环境通讯，绝大部分 virsh 命令需要管理员权限。尽管如此，一些典型的管理操作如域的创建、运行等也可以像VirtualBox 那样以普通用户身份执行。</p>
<p>Virsh 允许带命令行选项执行。如果不带则进入其内置的交互式终端：<code>virsh</code>。交互式终端支持 tab 键命令补全。</p>
<p>从命令行执行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ virsh <span style="color:#f92672">[</span>可选项<span style="color:#f92672">]</span> &lt;命令&gt; <span style="color:#f92672">[</span>参数<span style="color:#f92672">]</span>...
</code></pre></div><p>在交互式终端里运行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">virsh <span style="color:#75715e"># &lt;命令&gt; [参数]...</span>
</code></pre></div><p>帮助也是可用的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ virsh help <span style="color:#f92672">[</span>option*<span style="color:#f92672">]</span> or <span style="color:#f92672">[</span>group-keyword*<span style="color:#f92672">]</span>
</code></pre></div><h5 id="存储池">存储池<a hidden class="anchor" aria-hidden="true" href="#存储池">#</a></h5>
<p>存储池是指保存<em>卷</em>的位置。Libvirt 中<em>卷</em>的定义相当于其他系统中<em>虚拟磁盘</em>或<em>虚拟机镜像</em>的概念。存储池应该是一个目录、一个网络文件系统或一个分区（此处包括 LVM）。存储池可以在活动与不活动之间切换，可以为其分配存储空间。</p>
<p>以下示例为<em>添加</em>存储池、目录和 LVM 卷的方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ virsh pool-define-as name type <span style="color:#f92672">[</span>source-host<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>source-path<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>source-dev<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>source-name<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>&lt;target&gt;<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>--source-format format<span style="color:#f92672">]</span>
$ virsh pool-define-as poolname dir - - - - /home/username/.local/libvirt/images
$ virsh pool-define-as poolname fs - -  /dev/vg0/images - mntpoint
</code></pre></div><p>上述示例仅仅定义了存储池的信息，下面创建它：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ virsh pool-build     poolname
$ virsh pool-start     poolname
$ virsh pool-autostart poolname
</code></pre></div><p>删除它的命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ virsh pool-undefine  poolname
</code></pre></div><p><strong>提示：</strong> 对于 LVM 存储池而言：</p>
<ul>
<li>最佳实践是仅把一个卷组分配给一个存储池。</li>
<li>请为存储池选择一个与 LVM 卷组不同的名字。否则当存储池被删除时，该卷组也将被删除。</li>
</ul>
<p><strong>用 virt-manager 新建存储池</strong></p>
<p>首先，连接到虚拟运行环境（例如QEMU/KVM的系统/用户会话）。然后，右键点击一个<strong>连接</strong>（例如<strong>QEMU/KVM</strong>）选择<strong>详情</strong>，切换到<strong>存储</strong>选项卡，点击左下角的**+**，按照向导操作。</p>
<h5 id="存储卷">存储卷<a hidden class="anchor" aria-hidden="true" href="#存储卷">#</a></h5>
<p>存储池被创建之后，就可以在存储池中创建存储卷。如果你想新建一个域（虚拟机），那么这一步可以跳过，因为这一步可以在创建域的过程中完成。</p>
<p><strong>用 virsh 新建卷</strong></p>
<p>新建卷，列出卷，变更卷大小，删除卷：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ virsh vol-create-as      poolname volumename 10GiB --format aw|bochs|raw|qcow|qcow2|vmdk
$ virsh vol-upload  --pool poolname volumename volumepath
$ virsh vol-list           poolname
$ virsh vol-resize  --pool poolname volumename 12GiB
$ virsh vol-delete  --pool poolname volumename
$ virsh vol-dumpxml --pool poolname volumename  <span style="color:#75715e"># for details.</span>
</code></pre></div><h5 id="域">域<a hidden class="anchor" aria-hidden="true" href="#域">#</a></h5>
<p>虚拟机被称作**“域”**。如果你想在命令行下操作，使用<code>virsh</code>列出，创建，暂停，关闭……域。<code>virt-viewer</code>可以用来查看使用<code>virsh</code>启动的域。域的创建通常以图形化的<code>virt-manager</code>或者命令行下的<code>virt-install</code>完成。 创建新域通常需要安装媒介，例如存储池中的<code>iso</code>文件或是直接从光驱安装。</p>
<p>列出活动的和不活动的域：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># virsh list --all</span>
</code></pre></div><p><strong>用 virt-install 新建域</strong></p>
<p>对于很详细的域（虚拟机）配置，可以用 virt-manager 新建域更简单地完成。但是，基础配置同样可以用<code>virt-install</code>完成并且同样运行顺利。至少要配置<code>--name</code>, <code>--memory</code>, 存储(<code>--disk</code>, <code>--filesystem</code>,或<code>--nodisks</code>),和安装方法（通常来说是<code>.iso</code>文件或CD）。查看<a href="https://man.archlinux.org/man/virt-install.1">virt-install(1)</a>得到未列出的选项和更多的详情。</p>
<p>Windows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ virt-install <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  --name<span style="color:#f92672">=</span>windows7           <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  --memory <span style="color:#ae81ff">2048</span>             <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  --cdrom /dev/sr0          <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  --os-variant<span style="color:#f92672">=</span>win7         <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  --disk /mnt/storage/domains/windows7.qcow2,size<span style="color:#f92672">=</span>20GiB <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  --network network<span style="color:#f92672">=</span>vm-net  <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  --graphics spice
</code></pre></div><p>导入现有的卷：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ virt-install  <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  --name demo  <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  --memory <span style="color:#ae81ff">512</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  --disk /home/user/VMs/mydisk.img <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  --import
</code></pre></div><p><strong>用 virt-manager 新建域</strong></p>
<p>首先，连接到虚拟运行环境（例如 QEMU/KVM <em>system</em> 或用户 <em>session</em>，在连接上右击并选择 <em>新建</em>，然后跟随向导完成。</p>
<ul>
<li>在<strong>第四步</strong>中取消选中<strong>立即分配全部虚拟磁盘空间</strong>会加快创建过程并节省实际虚拟磁盘空间占用；<strong>然而</strong>，这将导致将来花费额外的磁盘整理时间。</li>
<li>在<strong>第五步</strong>中打开<strong>高级选项</strong>并确认<strong>虚拟化类型</strong>设为 <strong>kvm</strong>（这通常是首选模式）。如果要求附加的硬件配置，选中<strong>安装前定制</strong>选项。</li>
</ul>
<p><strong>管理域</strong></p>
<p>启动域：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ virsh start domain
$ virt-viewer --connect qemu:///session domain
</code></pre></div><p>正常关闭域；强制关闭域:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ virsh shutdown domain
$ virsh destroy  domain
</code></pre></div><p>在libvirtd启动时自动启动域:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ virsh autostart domain
$ virsh autostart domain --disable
</code></pre></div><p>在宿主机关闭时自动关闭域:</p>
<p>使用<code>libvirt-guests.service</code>Systemd服务，运行中的域可以在宿主机关闭时自动挂起/关闭。同时这个服务还可以让挂起/休眠的域在宿主机启动的时候自动恢复。查看<code>/etc/conf.d/libvirt-guests</code>并设置相关选项。</p>
<p>编辑一个域的XML配置：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ virsh edit domain
</code></pre></div><p><strong>注意：</strong> 直接被QEMU启动的虚拟机不被libvirt管理。</p>
<h5 id="网络-2">网络<a hidden class="anchor" aria-hidden="true" href="#网络-2">#</a></h5>
<p><a href="https://jamielinux.com/docs/libvirt-networking-handbook/">这里</a>是有关 libvirt 网络的一个正宗的概述。</p>
<p>默认情况下，当 <code>libvirtd</code> 服务启动后，即创建了一个名为 <em>default</em> 的 NAT 网桥与外部网络联通（仅 IPv4）。对于其他的网络连接需求，可创建下列四种类型的网络以连接到虚拟机：</p>
<ul>
<li>bridge — 这是一个虚拟设备，它通过一个物理接口直接共享数据。使用场景为：宿主机有 <em>静态</em> 网络、不需与其它域连接、要占用全部进出流量，并且域运行于 <em>系统</em> 层级。有关如何在现有默认网桥时增加另一个网桥的方法，请参阅 <a href="https://wiki.archlinux.org/title/%E7%BD%91%E6%A1%A5">网桥</a>。网桥创建后，需要将它指定到相应客户机的 <code>.xml</code> 配置文件中。</li>
<li>network — 这是一个虚拟网络，它可以与其它虚拟机共用。使用场景为：宿主机有 <em>动态</em> 网络（例如：NetworkManager）或使用无线网络。</li>
<li>macvtap — 直接连接到宿主机的一个物理网络接口。</li>
<li>user — 本地网络，仅用于用户 <em>会话</em>。</li>
</ul>
<p>绝大多数用户都可以通过 <code>virsh</code> 的各种可选项创建具有各种功能的网络，一般来说比通过 GUI 程序（像 <code>virt-manager</code> 之类）更容易做到。也可以按用 virt-install 新建域 所述实现。</p>
<p><strong>注意：</strong> libvirt 通过 dnsmasq 处理 DHCP 和 DNS 请求，以启动每个虚拟网络的不同实例。也会为特定的路由添加 iptables 规则并启用 <code>ip_forward</code> 内核参数。这也意味着宿主机上已运行的dnsmasq并不是libvirt所必须的（并可能干扰到libvirt的dnsmasq实例）。</p>
<h4 id="uefi-支持">UEFI 支持<a hidden class="anchor" aria-hidden="true" href="#uefi-支持">#</a></h4>
<p>Libvirt 可以通过 qemu 和 <a href="https://github.com/tianocore/edk2">OVMF</a> 来支持 UEFI 虚拟机。 安装 ovmf 。 添加下面的内容到 <code>/etc/libvirt/qemu.conf</code> 。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ vim /etc/libvirt/qemu.conf
nvram <span style="color:#f92672">=</span> <span style="color:#f92672">[</span>
	<span style="color:#e6db74">&#34;/usr/share/ovmf/x64/OVMF_CODE.fd:/usr/share/ovmf/x64/OVMF_VARS.fd&#34;</span>
<span style="color:#f92672">]</span>
</code></pre></div><p>重启 <code>libvirtd</code></p>
<p>现在你可以创建一个 UEFI 虚拟机了。 你可以通过 <a href="https://archlinux.org/packages/?name=virt-manager">virt-manager</a> 来创建。当你进行到向导的最后一步时：</p>
<ul>
<li>勾选<strong>在安装前自定义配置</strong>，之后点击<strong>完成</strong>。</li>
<li>在<strong>概况</strong>屏幕, 将固件改为&rsquo;UEFI x86_64&rsquo;。</li>
<li>点击<strong>开始安装</strong></li>
<li>在启动屏幕，你需要使用linuxefi命令来启动安装程序，并且你需要在系统中运行efibootmgr验证确实运行在UEFI模式下。</li>
</ul>
<h3 id="vm-相关">VM 相关<a hidden class="anchor" aria-hidden="true" href="#vm-相关">#</a></h3>
<h4 id="virtualbox">VirtualBox<a hidden class="anchor" aria-hidden="true" href="#virtualbox">#</a></h4>
<p><strong>执行 .vbs 文件</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cscript test.vbs
</code></pre></div><p><strong>删除备份</strong></p>
<p>删除虚拟机备份，当前状态前一个备份删除得快，两个备份之间的备份删除得慢。</p>
<p><strong>共享文件夹</strong></p>
<p>固定分配的共享文件夹对于定义共享文件夹的虚拟机是永久存在的；</p>
<p>临时分配的共享文件夹在虚拟机运行时添加/删除，虚拟机关闭后消失。</p>
<p><strong><a href="https://blog.csdn.net/lionwerson/article/details/104976028">把img系统镜像转为VDI或VMDK格式文件</a></strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ VBoxManage convertdd *.img  *.vdi
</code></pre></div><p>在 virtualbox 新建虚拟机时指定 vdi 硬盘文件，就可以安装系统</p>
<h5 id="增加现有虚拟机的磁盘大小httpslinuxcnarticle-12869-1html"><a href="https://linux.cn/article-12869-1.html">增加现有虚拟机的磁盘大小</a><a hidden class="anchor" aria-hidden="true" href="#增加现有虚拟机的磁盘大小httpslinuxcnarticle-12869-1html">#</a></h5>
<p>下面是你迟早会遇到的情况。</p>
<p>你在 <a href="https://www.virtualbox.org/">VirtualBox</a> 中安装了一个或多个操作系统。在创建这些虚拟操作系统的同时，你还在 VirtualBox 中为它们创建了虚拟硬盘。</p>
<p>你指定了虚拟磁盘的最大大小，比如说 15 或 20GB，但现在使用了一段时间后，你发现你的虚拟机已经没有空间了。</p>
<p>虽然在 Ubuntu 和其他操作系统上有释放磁盘空间的方法，但更稳健的处理方式是增加 VirtualBox 中创建的虚拟机的磁盘大小。</p>
<p>是的，你可以在 VirtualBox 中扩大虚拟硬盘，即使在创建之后也可以。虽然这是一个安全且经过测试的过程，但我们强烈建议你在执行这样的操作之前，先创建一个虚拟机的备份。</p>
<p>我将向你展示如何在 VirtualBox 中以图形和命令行（对于 Linux 极客）方式调整磁盘大小。这两种方法都很简单直接。</p>
<p><strong>方法 1：在 VirtualBox 中使用虚拟媒体管理器</strong></p>
<p>VirtualBox 6 增加了一个调整虚拟磁盘大小的图形化选项。你可以在 VirtualBox 主页的文件选项卡中找到它。</p>
<p>进入 “File -&gt; Virtual Media Manager”：</p>
<p>在列表中选择一个虚拟机，然后使用 “Size” 滑块或输入你需要的大小值。完成后点击 “Apply”。</p>
<p>请记住，虽然你增加了虚拟磁盘的大小，但<strong>如果你的空间是动态分配的，那么实际的分区大小仍然不变</strong>。</p>
<p><strong>方法 2：使用 Linux 命令行增加 VirtualBox 磁盘空间</strong></p>
<p>如果你使用 Linux 操作系统作为宿主机，在宿主机中打开终端并输入以下命令来调整 VDI 的大小：</p>
<pre tabindex="0"><code>VBoxManage modifymedium &quot;/path_to_vdi_file&quot; --resize &lt;megabytes&gt;
</code></pre><p>在你按下回车执行命令后，调整大小的过程应该马上结束。</p>
<blockquote>
<p>注意事项</p>
<p>VirtualBox 早期版本命令中的 <code>*modifyvdi</code> 和 <code>modifyhd</code> 命令也支持，并在内部映射到 <code>modifymedium</code> 命令。</p>
</blockquote>
<p>如果你不确定虚拟机的保存位置，可以在 VirtualBox 主页面点击 “Files -&gt; Preferences” 或使用键盘快捷键 <code>Ctrl+G</code> 找到默认位置。</p>
<h5 id="seamless-modehttpswwwtl80cnarticle43389"><a href="https://www.tl80.cn/article/43389">Seamless Mode</a><a hidden class="anchor" aria-hidden="true" href="#seamless-modehttpswwwtl80cnarticle43389">#</a></h5>
<p>虚拟机通常在一个窗口中运行来宾操作系统及其程序。但是，VirtualBox和VMware都有一些功能，允许您在主机桌面上运行虚拟化程序，从而将它们从监狱中释放出来。&hellip;</p>
<p>这意味着您可以在不使用虚拟机窗口和来宾操作系统桌面的情况下使用程序。如果使用多个监视器，甚至可以将虚拟机中的不同窗口放置在不同的监视器上。</p>
<p><strong>工作原理</strong></p>
<p>所有这些特性都同样工作。启动虚拟机，启动您想要使用的程序，然后启用“无缝模式”或“统一模式”。来宾操作系统的桌面和虚拟机窗口将消失，将来宾操作系统的窗口留在桌面上。它们看起来正在运行，好像它们在您的主机操作系统上运行，但虚拟机仍在后台运行。程序仍然是沙盒，因此它们无法访问主机操作系统的文件——它们似乎正在主机操作系统上运行。</p>
<p>无论您使用的是Windows、Linux还是Mac，这些技巧都有效。您可以在Linux桌面上无缝运行Windows程序，也可以在Windows桌面上运行Linux软件。</p>
<p><strong>使用virtualbox的无缝模式</strong></p>
<p>请注意，VirtualBox只允许您在Windows、Linux和Solaris客户机上使用此功能。如果你设法让MacOSX在VirtualBox虚拟机上运行，或者你正在使用像俳句这样的小众操作系统，你将无法使用这个功能。</p>
<p>在使用此功能之前，必须在要使用的来宾虚拟机内安装VirtualBox来宾添加软件包。如果您还没有这样做，请启动虚拟机，单击“设备”菜单，然后选择“安装来宾添加”。系统将提示您安装软件。</p>
<p>要使用此功能，请同时按“主机键”（通常是右Ctrl键，但它显示在虚拟机窗口的右下角）和“L”。也可以单击“视图”菜单，然后选择“切换到无缝模式”。</p>
<p>VirtualBox将隐藏来宾操作系统的桌面背景，使其看起来好像来宾操作系统的程序正在主机操作系统的桌面上运行。但是，正在运行的应用程序不会出现在操作系统的标准任务栏上。</p>
<p>要退出无缝模式，只需按主机键，然后再次按L。您还可以在任务栏上方找到VirtualBox菜单，您可以将鼠标悬停在上面查看。单击查看并再次选择切换到无缝模式以禁用无缝模式。</p>
<p><strong>使用vmware的unity模式</strong></p>
<p>VMware有一个类似的功能，名为Unity mode。它可以在免费的VMware Player、VMware Workstation和VMware的其他付费应用程序上使用。与VirtualBox一样，VMware的Unity模式适用于Windows和Linux客户机。</p>
<h5 id="vboxwinxp-sp3">VBox+WinXP SP3<a hidden class="anchor" aria-hidden="true" href="#vboxwinxp-sp3">#</a></h5>
<p><strong><a href="https://www.reddit.com/r/virtualbox/comments/l4yvpy/windows_xp_guest_additions_installation_stuck/">Windows XP; Guest Additions installation stuck; Virtualbox 6.1.18</a></strong></p>
<p>Disconnect network. It helps me.</p>
<h5 id="vs-vmwarehttpswwwzhihucomquestion33701295"><a href="https://www.zhihu.com/question/33701295">vs VMWare</a><a hidden class="anchor" aria-hidden="true" href="#vs-vmwarehttpswwwzhihucomquestion33701295">#</a></h5>
<p>工具是用来解决问题的，没必要看到开源就意识形态附体</p>
<p><strong><a href="https://winotes.net/fixing-piix4-host-smbus-controller-not-enabled-error-for-centos-on-vmware/">piix4_smbus Host SMBus controller not enabled</a></strong></p>
<p>从内核的说明文档来看，这个 piix4 实际上是 Intel 82371AB 南桥芯片，多功能总线控制器，而在 VMware 里面并没有这个真实的芯片组，但在启动时最会尝试载入这个驱动模块，所以会报错，但对系统没有任何影响。</p>
<h5 id="虚拟机网络模式httpswwwcnblogscomggjuchengarchive201208192646007html"><a href="https://www.cnblogs.com/ggjucheng/archive/2012/08/19/2646007.html">虚拟机网络模式</a><a hidden class="anchor" aria-hidden="true" href="#虚拟机网络模式httpswwwcnblogscomggjuchengarchive201208192646007html">#</a></h5>
<p><img loading="lazy" src="/Distributions/v2-82deb4be7068ec65b3ab251df22d5130_r.jpg" alt=""  />
</p>
<p><strong>桥接</strong></p>
<p>桥接网络是指本地物理网卡和虚拟网卡通过VMnet0虚拟交换机进行桥接，物理网卡和虚拟网卡在拓扑图上处于同等地位，那么物理网卡和虚拟网卡就相当于处于同一个网段，虚拟交换机就相当于一台现实网络中的交换机,所以两个网卡的IP地址也要设置为同一网段。</p>
<p>所以当我们要在局域网使用虚拟机，对局域网其他pc提供服务时，例如提供ftp，提供ssh，提供http服务，那么就要选择桥接模式。</p>
<p>例如大学宿舍里有一个路由器，宿舍里四个人连接这个路由器，路由器的wanip就不理会了，这个ip是动态获取的，而lanip默认是192.168.1.1,子网掩码是255.255.255.0。而其他四个人是自动获取ip，假设四个人的ip是:</p>
<p>A:192.168.1.100/255.255.255.0,</p>
<p>B:192.168.1.101/255.255.255.0</p>
<p>C:192.168.1.102/255.255.255.0</p>
<p>D:192.168.1.103/255.255.255.0</p>
<p>那么虚拟机的ip可以设置的ip地址是192.168.1.2-192.168.1.99,192.168.1.104-192.168.1.254 (即网络地址全0和全1的除外，再除去ABCD四个人的ip地址)</p>
<p>那么虚拟机的ip地址可以设置为192.168.1.98/255.255.255.0，设置了这个ip地址，ABCD这四个人就可以通过192.168.1.98访问虚拟机了，如果虚拟机需要上外网，那么还需要配置虚拟机的路由地址，就是192.168.1.1了，这样，虚拟机就可以上外网了，但是，上网我们一般是通过域名去访问外网的，所以我们还需要为虚拟机配置一个dns服务器，我们可以简单点，把dns服务器地址配置为google的dns服务器:8.8.8.8,到此，虚拟机就可以上网了。</p>
<p><strong>NAT</strong></p>
<p>NAT模式中，就是让虚拟机借助NAT(网络地址转换)功能，通过宿主机器所在的网络来访问公网。</p>
<p>NAT模式中，虚拟机的网卡和物理网卡的网络，不在同一个网络，虚拟机的网卡，是在vmware提供的一个虚拟网络。</p>
<p>NAT和桥接的比较:</p>
<ul>
<li>NAT模式和桥接模式虚拟机都可以上外网。</li>
<li>由于NAT的网络在vmware提供的一个虚拟网络里，所以局域网其他主机是无法访问虚拟机的，而宿主机可以访问虚拟机，虚拟机可以访问局域网的所有主机，因为真实的局域网相对于NAT的虚拟网络，就是NAT的虚拟网络的外网。</li>
<li>桥接模式下，多个虚拟机之间可以互相访问；NAT模式下，多个虚拟机之间也可以相互访问。</li>
</ul>
<p>如果你建一个虚拟机，只是给自己用，不需要给局域网其他人用，那么可以选择NAT，毕竟NAT模式下的虚拟系统的TCP/IP配置信息是由VMnet8(NAT)虚拟网络的DHCP服务器提供的，只要虚拟机的网路配置是DHCP，那么你不需要进行任何其他的配置，只需要宿主机器能访问互联网即可，就可以让虚拟机联网了。</p>
<p>例如你想建多个虚拟机集群，作为测试使用，而宿主机可能是一个笔记本，ip不固定。这种应用场景，我们需要采用nat模式了，但是我们要考虑一个问题，虚拟机之间是需要互访的，默认采用dhcp，虚拟机的ip每次重启，ip都是不固定的，所以我们需要手工设置虚拟机的ip地址。</p>
<p><strong>Host-Only</strong></p>
<p>在Host-Only模式下，虚拟网络是一个全封闭的网络，它唯一能够访问的就是主机。其实Host-Only网络和NAT网络很相似，不同的地方就是Host-Only网络没有NAT服务，所以虚拟网络不能连接到Internet。主机和虚拟机之间的通信是通过VMware Network Adepter VMnet1虚拟网卡来实现的。</p>
<p>Host-Only的宗旨就是建立一个与外界隔绝的内部网络，来提高内网的安全性。这个功能或许对普通用户来说没有多大意义，但大型服务商会常常利用这个功能。</p>
<h4 id="podmanhttpsgithubcomcontainerspodman"><a href="https://github.com/containers/podman">podman</a><a hidden class="anchor" aria-hidden="true" href="#podmanhttpsgithubcomcontainerspodman">#</a></h4>
<p>Podman: A tool for managing OCI containers and pods.</p>
<h4 id="android-x86httpslinuxcnarticle-11711-1html"><a href="https://linux.cn/article-11711-1.html">Android-x86</a><a hidden class="anchor" aria-hidden="true" href="#android-x86httpslinuxcnarticle-11711-1html">#</a></h4>
<p><a href="http://www.android-x86.org/">android x86</a> 是一个自由而开源的项目，将谷歌制作的安卓系统从 ARM 架构移植到了 x86 架构，可以让用户在他们的桌面电脑上运行安卓系统来享受所有的安卓功能和应用程序及游戏。</p>
<p>首次启动运行该安卓系统，运行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ qemu-img create -f qcow2 Android8-VM.img 30G
$ gedit start_Android8_VM.sh
<span style="color:#75715e">#!/bin/bash</span>
DISKIMG<span style="color:#f92672">=</span>/media/kurome/Ventoy/QemuKVM/Android8-VM.img
exec qemu-system-x86_64 --enable-kvm <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  -hda <span style="color:#e6db74">${</span>DISKIMG<span style="color:#e6db74">}</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  -net nic -net user <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  -m <span style="color:#ae81ff">4096</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  -smp cores<span style="color:#f92672">=</span>2,threads<span style="color:#f92672">=</span><span style="color:#ae81ff">4</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  -monitor stdio <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  -vga std <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  -soundhw es1370 <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  -usb -device usb-tablet <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  -name <span style="color:#e6db74">&#39;Andriod8 VM&#39;</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  $@
$ chmod u+x start_Android8_VM.sh
$ ./start_Android8_VM.sh -boot d -cdrom ~/Downloads/android-x86_64-9.0-r2.iso
</code></pre></div><p>在，安卓系统已经完全安装在你的 <code>android.img</code> 文件中，你应该使用下面的 QEMU 命令来启动它，而不是前面的命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ./start_Android8_VM.sh
</code></pre></div><h4 id="anboxhttpslinuxcnarticle-10843-1html"><a href="https://linux.cn/article-10843-1.html">Anbox</a><a hidden class="anchor" aria-hidden="true" href="#anboxhttpslinuxcnarticle-10843-1html">#</a></h4>
<h5 id="anbox-简介">Anbox 简介<a hidden class="anchor" aria-hidden="true" href="#anbox-简介">#</a></h5>
<p>Anbox 是 “Android in a box” 的缩写。Anbox 是一个基于容器的方法，可以在普通的 GNU/Linux 系统上启动完整的 Android 系统。</p>
<p>Anbox 可以让你在 Linux 系统上运行 Android，而没有虚拟化的迟钝，因为核心的 Android 操作系统已经使用 Linux 命名空间（LXE）放置到容器中了。</p>
<p>Android 容器不能直接访问到任何硬件，所有硬件的访问都是通过在主机上的守护进程进行的。</p>
<p>每个应用程序将在一个单独窗口打开，就像其它本地系统应用程序一样，并且它可以显示在启动器中。</p>
<h5 id="安装使用">安装使用<a hidden class="anchor" aria-hidden="true" href="#安装使用">#</a></h5>
<p>Anbox 也可作为 snap 软件包安装，请确保你已经在你的系统上启用了 snap 支持。</p>
<p>为使 Anbox 工作，确保需要的内核模块已经安装在你的系统中。对于基于 Ubuntu 的用户，使用下面的 PPA 来安装它。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo add-apt-repository ppa:morphis/anbox-support
$ sudo apt update
$ sudo apt install linux-headers-generic anbox-modules-dkms
</code></pre></div><p>在你安装 <code>anbox-modules-dkms</code> 软件包后，你必须手动重新加载内核模块，或需要系统重新启动。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo modprobe ashmem_linux
$ sudo modprobe binder_linux
</code></pre></div><p>安装 anbox。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install anbox
</code></pre></div><p>如果你已经在你的系统上安装 snap，其它的步骤可以忽略。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo snap install --devmode --beta anbox
</code></pre></div><p>默认情况下，Anbox 并没有带有 Google Play Store。因此，我们需要手动下载每个应用程序（APK），并使用 Android 调试桥（ADB）安装它。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install android-tools-adb
</code></pre></div><p>既然我们不能使用 Play Store ，你就得从信得过的网站来下载 APK 软件包，像 <a href="https://www.apkmirror.com/">APKMirror</a> ，然后手动安装它。</p>
<p>首先，你需要启动 ADB 服务。为做到这样，运行下面的命令。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ adb devices
</code></pre></div><p>安装语法格式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ adb install Name-Of-Your-Application.apk
</code></pre></div><h4 id="waydroidhttpswaydroid"><a href="https://waydro.id/">Waydroid</a><a hidden class="anchor" aria-hidden="true" href="#waydroidhttpswaydroid">#</a></h4>
<p>Waydroid是一个基于lxc容器技术，用以启动完整安卓系统的方案。</p>
<h4 id="genymotionhttpswwwgenymotioncom"><a href="https://www.genymotion.com/">Genymotion</a><a hidden class="anchor" aria-hidden="true" href="#genymotionhttpswwwgenymotioncom">#</a></h4>
<p>Android Virtual Devices for all your development &amp; testing needs</p>
<h4 id="looking-glasshttpslooking-glassio"><a href="https://looking-glass.io/">Looking Glass</a><a hidden class="anchor" aria-hidden="true" href="#looking-glasshttpslooking-glassio">#</a></h4>
<p>An extremely low latency KVMFR (KVM FrameRelay) implementation for guests with VGA PCI Passthrough.</p>
<h4 id="libvfiohttpsarccomputecombloglibvfio-commodity-gpu-multiplexing"><a href="https://arccompute.com/blog/libvfio-commodity-gpu-multiplexing/">LibVF.IO</a><a hidden class="anchor" aria-hidden="true" href="#libvfiohttpsarccomputecombloglibvfio-commodity-gpu-multiplexing">#</a></h4>
<p>Commodity GPU Multiplexing Driven By VFIO &amp; YAML.</p>
<h2 id="winehttpswikiarchlinuxorgtitlewine_e7ae80e4bd93e4b8ade69687"><a href="https://wiki.archlinux.org/title/Wine_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Wine</a><a hidden class="anchor" aria-hidden="true" href="#winehttpswikiarchlinuxorgtitlewine_e7ae80e4bd93e4b8ade69687">#</a></h2>
<h3 id="简介httpszhmwikipediaorgwikiwine"><a href="https://zh.m.wikipedia.org/wiki/Wine">简介</a><a hidden class="anchor" aria-hidden="true" href="#简介httpszhmwikipediaorgwikiwine">#</a></h3>
<p><a href="http://winehq.org/">Wine</a> 是在x86、x86-64容许类Unix操作系统在X Window System运行Microsoft Windows程序的软件。另外，Wine也提供程序运行库（Winelib）来帮助计算机程序设计师将Windows程序移植到类Unix系统；也有不少软件经过Wine测试后发布，比如Picasa、uTorrent、MediaCoder。</p>
<p>Wine通过提供一个兼容层来将Windows的系统调用转换成与POSIX标准的系统调用。它还提供了Windows系统运行库的替代品和一些系统组件的替代品。为了避免著作权问题，Wine主要使用黑箱测试逆向工程来编写。</p>
<p>Wine最早是“Windows Emulator”，即Windows模拟器的缩写，但Wine现在为“Wine Is Not an Emulator”的递归缩写，即Wine不是模拟器。Wine的正确名称是“Wine”，而不是全大写或全小写。</p>
<p>Wine计划在1993年由Bob Amstadt及Eric Youngdale发起，最初目的是为了让16位Windows 3.1程序可以在Linux上执行，但随着电脑和时代的演进，Wine也一路支持到更新的Windows和64位的计算机体系结构。</p>
<p>由于Windows的DLL为封闭源代码，所以程序员只能由最底层的设计开始，耗费大量的时间来编写和测试，最后达至兼容，这过程是困难且缓慢的。</p>
<p>在1999年期间，当Corel加入这个计划后，Wine很快便能兼容WordPerfect Office，但Corel不久便停止支持这项计划，所以Wine的发展又逐渐趋缓，一直到2006年Google积极参与这个计划后，Wine的发展才又恢复起色，最后终于在2008年发布首个稳定版，其后便以每两周发布一个新版的速度发展着，除此之外，Google每年所举办的夏日代码大赛活动也对Wine有着不少贡献。</p>
<p>Wine虽然是从Linux开始发展，但现在已经支持多种平台，有BSD、Mac OS X与Solaris-x86，在2013年的自由及开源软件开发者欧洲会议上，Wine的项目领导人Alexandre Julliard（英语：Alexandre Julliard）表示目前将积极支持Android平台。</p>
<p>在2008年，Wine已经能够完美运行很多知名程序，例如Lotus Notes及Microsoft Office 2007，Photoshop CS2，但其可靠性及稳定性仍有待改善。<strong>如果该程序包含本地的微软Windows系统的库，那样Wine便可很顺利运行该程序。</strong></p>
<p>有些Wine DLLs亦已能完美地取代Windows原来的DLLs，使得有些程序可完美运行。</p>
<p>最晚到2006年，Wine上面已经可以完全基于Wine DLL完美地运行暴雪发行的多款3D游戏了，如魔兽世界、魔兽争霸等。</p>
<p><strong>注</strong>：以下如果使用zsh，<code>~</code> 应替换为 <code>$HOME</code>才能正常使用</p>
<h3 id="安装httpswikiwinehqorgubuntu"><a href="https://wiki.winehq.org/Ubuntu">安装</a><a hidden class="anchor" aria-hidden="true" href="#安装httpswikiwinehqorgubuntu">#</a></h3>
<p><strong>使用 Ubuntu 仓库版本</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install wine
</code></pre></div><p><strong>使用 wine 仓库安装最新版本</strong></p>
<p>如果您之前安装过来自其他仓库的 Wine 安装包，请在尝试安装 WineHQ 安装包之前删除它及依赖它的所有安装包（如：wine-mono、wine-gecko、winetricks），否则可能导致依赖冲突。</p>
<p>如果您使用的是 64 位系统，请<a href="https://www.unixmen.com/enable-32-bit-support-64-bit-ubuntu-13-10-greater/">开启 32 bit 架构支持</a>（如果您之前没有开启的话）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># Verifying you have 64-bit kernel architecture.</span>
$ dpkg --print-architecture
<span style="color:#75715e"># Verifying you have multi-arch support enabled. </span>
$ dpkg --print-foreign-architectures
<span style="color:#75715e"># Enabling multi-arch support.</span>
$ sudo dpkg --add-architecture i386 
$ sudo apt update
</code></pre></div><p>下载添加仓库密钥：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ wget -nc https://dl.winehq.org/wine-builds/winehq.key
$ sudo apt-key add winehq.key
</code></pre></div><p>并添加 Ubuntu 20.04 仓库：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo add-apt-repository <span style="color:#e6db74">&#39;deb https://dl.winehq.org/wine-builds/ubuntu/ focal main&#39;</span>
</code></pre></div><p>安装：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt update
$ sudo apt install --install-recommends winehq-stable
</code></pre></div><h3 id="配置-3">配置<a hidden class="anchor" aria-hidden="true" href="#配置-3">#</a></h3>
<p>配置Wine的方式通常有：</p>
<ul>
<li><a href="https://wiki.winehq.org/winecfg">winecfg</a>是Wine的图形界面配置程序。控制台下调用<code>$ winecfg</code>（或指定系统目录：<code>$ WINEPREFIX=~/.系统目录 winecfg</code>）即可启动</li>
<li><a href="https://wiki.winehq.org/control">control.exe</a>是Windows控制面板的Wine实现，通过<code>$ wine control</code>命令启动</li>
<li><a href="https://wiki.winehq.org/regedit">regedit</a>是Wine的注册表编辑器，比较前两者，该工具能配置更多东西。部分常用键值参见：<a href="https://wiki.winehq.org/UsefulRegistryKeys">WineHQ&rsquo;s article on Useful Registry Keys</a></li>
</ul>
<h4 id="初始设置httpswikiubuntuorgcnubuntuhelpwinezh"><a href="https://wiki.ubuntu.org.cn/UbuntuHelp:Wine/zh">初始设置</a><a hidden class="anchor" aria-hidden="true" href="#初始设置httpswikiubuntuorgcnubuntuhelpwinezh">#</a></h4>
<p>通过全局菜单，应用程序 - &gt;附件 - &gt;终端 ，输入命令： <code>winecfg</code> 这将在你的家目录中创建一个隐藏文件夹（.wine），其中包含类似于在Windows中的虚拟C：驱动器以及注册表文件。一旦该目录中创建完，wine配置窗口将出现。该窗口将允许您定制wine的各种设置，其中包括Windows版本，DLL替换，显示设置，驱动器映射，以及应用程序的特定设置。单击OK按钮关闭该窗口。</p>
<h4 id="wineprefix">WINEPREFIX<a hidden class="anchor" aria-hidden="true" href="#wineprefix">#</a></h4>
<p>Wine默认将配置文件和安装的Windows程序保存在<code>~/.wine</code>。这样的目录称为一个&quot;Wine prefix&quot;或&quot;Wine bottle&quot;（下文称“系统目录”）。每次运行Windows程序（包括内置程序，如<code>winecfg</code>）时，系统目录会自动创建（如果缺失）或更新。系统目录中存放有文件夹 <code>~/.wine/drive_c</code> 相当于Windows下<code>C:\</code>C盘（更确切的说应是系统盘）。</p>
<p>通过设置<code>WINEPREFIX</code>环境变量，可以更改Wine系统目录的位置。如果希望让不同的Windows程序使用不同的系统环境或配置，这一变量会非常有用。建议把你安装的不同的Windows程序分给不同的WINEPREFIX，便于打包和隔离。当你要启动这个Windows程序前也记得要设置WINEPREFIX。</p>
<p>例如，如果您使用 <code>$ env WINEPREFIX=~/.win-a wine-A程序.exe</code>参数来运行一个程序。另一个使用 <code>$ env WINEPREFIX=~/.win-b wine-B程序.exe</code>参数，这两个程序将使用独立的C盘和注册表配置。</p>
<p>以下命令会建立一个默认的系统目录，且不启动任何Windows程序：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ env WINEPREFIX<span style="color:#f92672">=</span>~/.customprefix wineboot -u
</code></pre></div><h4 id="winearch">WINEARCH<a hidden class="anchor" aria-hidden="true" href="#winearch">#</a></h4>
<p>这个WINEARCH 决定了你模拟的Windows是32位或是64位的x86。对应的值为win32及win64，如果你的Unix系统是64位的它就默认是win64。</p>
<p>发行版所提供的wine一般都有32位及64位两个包，直接对应所模拟的Windows位数，包里面的Unix二进制及运行库也都是对应位数。</p>
<p>对于64位用户，默认创建的系统目录是64位环境的。若想使用纯32位环境，修改<code>WINEARCH</code> 变量win32为即可： <code>$ WINEARCH=win32 winecfg</code>这样就会生成32位Wine环境。若不设置<code>WINEARCH</code>得到的就是64位环境。</p>
<p>通过<code>WINEPREFIX</code>变量，在不同的系统目录分别创建32位和64位环境：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ WINEARCH<span style="color:#f92672">=</span>win32 WINEPREFIX<span style="color:#f92672">=</span>~/win32 winecfg
$ WINEPREFIX<span style="color:#f92672">=</span>~/win64 winecfg
</code></pre></div><p><strong>注意：</strong> 系统目录创建过程中，64位版本的wine将视全部目录如同64位系统目录，也将不会在已存在的目录中创建任何32位的。创建32位系统目录，您必须让Wine创建指定的<code>WINEPREFIX</code>目录。</p>
<p>winetricks也接受<code>WINEPREFIX</code>变量，以安装Steam为例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ WINEARCH<span style="color:#f92672">=</span>win32 WINEPREFIX<span style="color:#f92672">=</span>~/.local/share/wineprefixes/steam winetricks steam
</code></pre></div><p>编辑 <code>~/.bashrc</code>，使得 WINEPREFIX 和 WINEARCH 永久生效</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">export WINEPREFIX<span style="color:#f92672">=</span>$HOME/.config/wine/
export WINEARCH<span style="color:#f92672">=</span>win32
</code></pre></div><h4 id="图形驱动">图形驱动<a hidden class="anchor" aria-hidden="true" href="#图形驱动">#</a></h4>
<p>你需要安装32位的显卡驱动。缺少或未能正确配置驱动的一个标志是 Wine 在终端窗口里报告如下内容：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">Direct rendering is disabled, most likely your OpenGL drivers have not been installed correctly
</code></pre></div><p><strong>注意：</strong> 在安装对应的库以后，你可能需要重启 X</p>
<h4 id="声音">声音<a hidden class="anchor" aria-hidden="true" href="#声音">#</a></h4>
<p>Wine程序有可能遇到某些声音问题。首先，确保<code>winecfg</code>中只启用了一种声卡驱动。目前，Wine对<a href="https://wiki.archlinux.org/title/Alsa_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Alsa</a>的支持最好。</p>
<p><strong>MIDI 支持</strong></p>
<p><a href="https://wiki.archlinux.org/title/MIDI">MIDI</a> 是九十年代非常流行的游戏声音系统。如果你尝试运行老一点的游戏，音乐无法开箱即用的情况并不罕见。 Wine 拥有非常优秀的 MIDI 支持。但是首先你需要确保 Wine 会使用正确的 MIDI 输出。详细设置参考 <a href="https://wiki.winehq.org/MIDI">Wine Wiki</a></p>
<h4 id="字体">字体<a hidden class="anchor" aria-hidden="true" href="#字体">#</a></h4>
<p><a href="https://www.jianshu.com/p/df2c679f0d12"><strong>中文乱码</strong></a></p>
<p>将中文字体copy到对应wine的目录（本地安装的wine是<code>~/.wine</code>，playonlinux是<code>.PlayOnLinux/wineprefix/对应目录</code>）下的<code>drive_c/windows/Fonts/</code>。</p>
<p>在wine目录下任意位置添加<code>modify_font.reg</code>文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ini" data-lang="ini"><span style="color:#a6e22e">REGEDIT4</span>

<span style="color:#66d9ef">[HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\FontLink\SystemLink]</span>
<span style="color:#a6e22e">&#34;Lucida Sans Unicode&#34;</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;SourceHanSans.ttc&#34;</span>
<span style="color:#a6e22e">&#34;Microsoft Sans Serif&#34;</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;SourceHanSans.ttc&#34;</span>
<span style="color:#a6e22e">&#34;MS Sans Serif&#34;</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;SourceHanSans.ttc&#34;</span>
<span style="color:#a6e22e">&#34;Tahoma&#34;</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;SourceHanSans.ttc&#34;</span>
<span style="color:#a6e22e">&#34;Tahoma Bold&#34;</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;SourceHanSans.ttc&#34;</span>
<span style="color:#a6e22e">&#34;msyh&#34;</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;SourceHanSans.ttc&#34;</span>
<span style="color:#a6e22e">&#34;Arial&#34;</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;SourceHanSans.ttc&#34;</span>
<span style="color:#a6e22e">&#34;Arial Black&#34;</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;SourceHanSans.ttc&#34;</span>
</code></pre></div><p>将<code>SourceHanSans.ttc</code>改成自己想改的中文字体。</p>
<p>在wine命令提示符运行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ regedit modify_font.reg
</code></pre></div><p><strong><a href="https://www.twblogs.net/a/5cb32a72bd9eee48d788acae">语言区域</a></strong></p>
<p>如果安装的系统LANG不为zh-CN，那么wine运行程序的默认语种也不会是中文，这可能导致一部分乱码。解决这个问题，用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ env LANG<span style="color:#f92672">=</span>zh_CN.UTF-8 wine example.exe
</code></pre></div><p>运行程序</p>
<h4 id="启动器和菜单">启动器和菜单<a hidden class="anchor" aria-hidden="true" href="#启动器和菜单">#</a></h4>
<p>Wine不会为内置程序（如<code>winecfg</code>、<code>winebrowser</code>）创建桌面启动器和菜单项。但手动安装的Windows程序通常会自动创建启动器和菜单项。在Windows下，安装程序（如<code>setup.exe</code>）通常会在桌面和开始菜单建立快捷方式，而Wine下会创建遵循freedesktop.org规范的.desktop文件（即启动器，相当于快捷方式）。</p>
<p><strong>提示：</strong> 如果启动器<em>没有</em>自动创建，或者这些文件丢失了，可以尝试使用<a href="https://wiki.winehq.org/winemenubuilder">winemenubuilder</a>修复。</p>
<p><strong>Gnome3 中清理 Wine 菜单启动项</strong></p>
<p>系统全局的菜单启动器安装在 <code>/usr/share/applications/</code>，清除相应程序的“.desktop”文件即可从整个系统删除该启动器。</p>
<p>如果这样还是无法解决问题，那么很可能 Wine 的启动器存放在用户级别的 <code>~/.local/share/applications/wine/Programs/</code> 目录中。删除相应的“.desktop”文件即可清理对应启动项。删除整个 Programs 文件夹将清理所有 Wine 程序的启动项。</p>
<h3 id="安装运行卸载-windows-程序">安装/运行/卸载 Windows 程序<a hidden class="anchor" aria-hidden="true" href="#安装运行卸载-windows-程序">#</a></h3>
<p><strong>警告：</strong> 千万不要以root身份运行Wine！详情参见<a href="https://wiki.winehq.org/FAQ#Should_I_run_Wine_as_root.3F">本文</a>。</p>
<p>使用wine安装应用程序，可以按照以下步骤：</p>
<ol>
<li>从某个地址下载Windows应用程序.exe（可执行文件）.</li>
<li>把它放在一个方便的目录（例如，桌面或个人文件夹）</li>
<li>打开终端，并且切换到.exe文件所在的目录。</li>
<li>输入命令 <code>wine application-name.exe</code> 。</li>
</ol>
<p>这将使用Wine启动.EXE。如果它是一个安装程序，它应该像在windows一样的运行。如果应用程序要求目录来安装应用程序，选择把它放在 C:\Program Files 。</p>
<p>运行Windows程序格式为 <code>WINEPREFIX=&quot;wine配置文件存放地&quot; wine [路径]程序.exe 参数</code> ，如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ wine notepad.exe c:/abc.txt
$ wine notepad.exe ~/.wine/drive_c/abc.txt
</code></pre></div><p>路径可以是Unix路径，也可以是（在有WINEPREFIX情况下的）Windows路径，wine会自动判断。</p>
<p>对wine来说，你Unix系统里的其他文件（即模拟的C盘之外的文件）的Windows路径都以Z盘开头：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ wine notepad.exe z:/home/username/.wine/drive_c/abc.txt
</code></pre></div><p>内置的msiexec程序可以运行MSI安装包：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ <span style="color:#f92672">[</span>wine<span style="color:#f92672">]</span> msiexec /i path_to_msi
</code></pre></div><p>还可以通过在终端运行 winefile 使用 Wine 文件浏览器。</p>
<p>在某些情况下，应用程序需要被从一个特定位置上运行。在这种情况下创建命令启动</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sh -c <span style="color:#e6db74">&#34;cd /home/USER/.wine/drive_c/Program Files/APPDIR; wine game.exe&#34;</span>
</code></pre></div><p><code>wine uninstaller</code> 这将打开一个类似于Windows的程序“添加/删除程序”控制面板，让您卸载wine安装的应用程序。通过 wine 直接运行卸载程序也应该正常工作。或者，您也可以简单地删除应用程序的文件夹。</p>
<h3 id="技巧-1">技巧<a hidden class="anchor" aria-hidden="true" href="#技巧-1">#</a></h3>
<p><strong>提示：</strong> 此外您可能会感兴趣以下文章的开始所提供的链接</p>
<ul>
<li><a href="https://appdb.winehq.org/">Wine程序数据库 (Wine Application Database, AppDB)</a> —— 特定Windows程序的Wine兼容情况（运行时的已知问题、用户评分、指南等等），Rating一列由运行结果好到坏为Platinum、Gold、Silver、Bronze、Garbage，无近期结果或近期仍然Silver以下的就放弃吧。</li>
<li><a href="https://forum.winehq.org/">WineHQ论坛</a> —— 要是看完上述网页还有问题，可以到这里咨询</li>
</ul>
<h4 id="opengl-模式">OpenGL 模式<a hidden class="anchor" aria-hidden="true" href="#opengl-模式">#</a></h4>
<p>很多游戏（比如魔兽争霸啦）都支持OpenGL模式，在Wine下<em>可能</em>比默认DirectX模式性能更好。一般添加<code>-opengl</code>启动程序即可，但<em>不同程序可能有所不同</em>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ wine /path/to/3d_game.exe -opengl
</code></pre></div><p>请参考<a href="https://appdb.winehq.org/">AppDB</a>，了解特定程序的相关信息。</p>
<h4 id="wine-控制台">Wine 控制台<a hidden class="anchor" aria-hidden="true" href="#wine-控制台">#</a></h4>
<p>有些时候，可能需要运行<code>.exe</code>给游戏打补丁，比如给古董游戏添加宽屏支持。这时直接通过Wine运行可能没有用。那么，打开终端，运行一下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ wineconsole cmd
</code></pre></div><p>将进入一个和Windows下cmd一样的命令行环境。在该环境下试试也许就可以了。</p>
<h4 id="winetrickshttpswikiwinehqorgwinetricks"><a href="https://wiki.winehq.org/Winetricks">winetricks</a><a hidden class="anchor" aria-hidden="true" href="#winetrickshttpswikiwinehqorgwinetricks">#</a></h4>
<p>使用<a href="https://github.com/Winetricks/winetricks">Winetricks</a>快速脚本，能够方便地安装许多Windows组件，包括DirectX、msxml（被Office 2007、IE浏览器依赖）visual运行库还有其他更多的。</p>
<p><strong>使用 Ubuntu 仓库版本</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install winetricks
</code></pre></div><p><strong>使用 Github 安装最新版本</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cd <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>HOME<span style="color:#e6db74">}</span><span style="color:#e6db74">/.local/bin&#34;</span>
$ wget  https://raw.githubusercontent.com/Winetricks/winetricks/master/src/winetricks
$ chmod u+x winetricks
</code></pre></div><p>可以用<code>winetricks list-all</code>来看看它支持什么。</p>
<p><strong>Using winetricks</strong></p>
<p>获得 winetricks 后，您只需在控制台输入<code>sh winetricks</code>即可运行它。如果你先<code>chmod +x winetricks</code> ，你也可以使用<code>./winetricks</code>。如果不带参数运行，winetricks 会显示一个带有可用包列表的 GUI。如果您知道要安装的软件包的名称，可以将它们附加到 winetricks 命令，它将立即开始安装过程。例如，</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sh winetricks corefonts vcrun6 
</code></pre></div><p>将安装 corefonts 和 vcrun6 软件包。</p>
<p>所有 Wine 命令一样，winetricks 知道 <code>WINEPREFIX</code> 环境变量。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ env WINEPREFIX<span style="color:#f92672">=</span>~/.winetest sh winetricks mfc40 
</code></pre></div><p>拥有多个 Wine 版本的用户可以指定 winetricks 应该使用哪个版本</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ env WINE<span style="color:#f92672">=</span>~/wine-git/wine sh winetricks mfc40 
</code></pre></div><p>使用 ~/wine-git 目录中的 Wine 安装 mfc40 包。</p>
<h4 id="monohttpswikiwinehqorgmono--geckohttpswikiwinehqorggecko"><a href="https://wiki.winehq.org/Mono">Mono</a> &amp; <a href="https://wiki.winehq.org/Gecko">Gecko</a><a hidden class="anchor" aria-hidden="true" href="#monohttpswikiwinehqorgmono--geckohttpswikiwinehqorggecko">#</a></h4>
<p>Mono 是 .NET Framework 的开源和跨平台实现。Wine 可以使用 Windows 构建的 Mono 来运行 .NET 应用程序。</p>
<p>Wine 实现了自己的 Internet Explorer 版本。该实现基于<a href="http://en.wikipedia.org/wiki/Gecko_(layout_engine)">Mozilla 的 Gecko Layout Engine</a>的自定义版本。</p>
<p>在 <a href="http://mirrors.ustc.edu.cn/wine/wine/">USTC MIRROR</a> 分别下载对应的版本，放入<code>~/.cache/wine</code>就可以了。</p>
<h3 id="crossoverhttpswwwcodeweaverscom"><a href="https://www.codeweavers.com">CrossOver</a><a hidden class="anchor" aria-hidden="true" href="#crossoverhttpswwwcodeweaverscom">#</a></h3>
<p>CrossOver是Wine的付费、商业化版本，提供更全面的终端用户支持。它包括脚本、补丁、GUI和可能永远不会被Wine项目接受的第三方软件。这种组合使得那些不太懂技术的人运行Windows程序变得相当容易。</p>
<p>首先在 <a href="https://www.codeweavers.com/crossover/download">CrossOver</a> 下载 .bin 安装包，然后要把 .bin 文件设置成可执行的：<code>chmod u+x crossover.bin</code>，接下来运行该文件：<code>./crossover.bin</code>。</p>
<p><strong><a href="https://www.tspweb.com/key/crossover%E6%97%A0%E9%99%90%E8%AF%95%E7%94%A8.html">无限试用</a></strong></p>
<p>crossover 有15天的试用期，crossover的时间验证信息写在每一个winebottle容器中，相互是完全隔离（不是写在全局配置中）。即使一个容器过期了，依然可以创建新的容器，并重新计算试用期，所以不需要重装软件本身。</p>
<p>即使重装程序，已经过期的容器依旧不能用，不过可以删除该容器，或者删除容器下的.eval文件。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ rm ~/.cxoffice/**/.eval
</code></pre></div><h4 id="tutorialshttpswwwcodeweaverscomsupportwikilinuxlinuxtutorial"><a href="https://www.codeweavers.com/support/wiki/linux/linuxtutorial">Tutorials</a><a hidden class="anchor" aria-hidden="true" href="#tutorialshttpswwwcodeweaverscomsupportwikilinuxlinuxtutorial">#</a></h4>
<p>相对于 wine 而言，CrossOver 更加简洁方便，全程使用 GUI。</p>
<p>在 Select Application 的时候，即使列表中没有列出你需要安装的 Windows 软件，依旧可以尝试使用默认的 Unlisted application，如一些 roguelike、galgame 游戏是可以直接运行的。</p>
<p>如果无法运行：</p>
<ul>
<li>如果报错缺少dll，这时就在网上查找一下，比如 <a href="https://techdot.tech/how-to-fix/wine-runtime-error-cannot-import-dll-isskin-dll/">sskin.dll</a>，如果教程使用的 winetricks，则可以在 <a href="https://github.com/Winetricks/winetricks/blob/master/files/verbs/all.txt">winetricks/files/verbs/all.txt</a> 找到具体的依赖名称，如 Visual C++ 6 SP4 libraries，然后可以在 Select Application 输入依赖名来安装，如果下载慢，也可以通过软件显示的下载链接直接下载。</li>
<li>如果什么错也没报，那么就需要参考  <a href="https://www.codeweavers.com/support/wiki/linux/linuxtutorial/unsupported_deps">Unsupported Troubleshooting</a> 安装依赖或配置 winecfg，确保在安装游戏的时候没有选择升级依赖（比如 DirectX ）并且之后安装了必要的依赖项。推荐游戏自带的 <strong>CommonRedist</strong> 或在 <a href="https://appdb.winehq.org/objectManager.php?sClass=application&amp;sTitle=Browse%20Applications&amp;sOrderBy=appName&amp;bAscending=true">WineHQ  - Browse Applications</a>、<a href="https://www.playonlinux.com/en/supported_apps-1-0.html">PlayOnLinux</a>、<a href="https://www.pcgamingwiki.com/wiki/Home">PCGamingWiki</a> 上找依赖，可以但不推荐在虚拟机中运行一下看报错。</li>
<li>如果先是正常运行，之后 wine 报错 page fault 退出，那么可以参考 <a href="https://www.codeweavers.com/support/wiki/linux/linuxtutorial/debug">Gathering debug logs in Crossover Linux</a> 创建 crash log。</li>
</ul>
<p>凡是依赖解决了，游戏一般是能够运行了，但是运行的好不好，有没有bug就不敢保证了，比如 Skul - The Hero Slayer  是可以直接运行的，但是无法正常显示血量，即使重新安装依赖也是如此。</p>
<p>以下测试的是运行游戏所必须的依赖：</p>
<ul>
<li>
<p>Sekiro Shadows Die Twice</p>
<ul>
<li>Microsoft Visual C++ 6.0 (4.2 &amp; 6.0) Redistributable</li>
</ul>
</li>
<li>
<p>The Elder Scrolls V Skyrim Special Edition</p>
<ul>
<li>DirectX for Modern Games</li>
<li>使用 SkyrimSELauncher.exe 配置，使用 SkyrimSE.exe 启动</li>
</ul>
</li>
<li>
<p>Life is Strange - Before the Storm</p>
<ul>
<li>先安装下面两个依赖，如果 FitGirl 报 <a href="https://www.reddit.com/r/CrackSupport/comments/ggamia/getting_unarcdll_returned_an_error_code_6_on/">Getting unarc.dll returned an error code -6</a>，就 try using the set memory limit to 2 gb option；如果是 Miss files，那么就重装。</li>
<li>Microsoft Visual C++ 6.0 (4.2 &amp; 6.0) Redistributable</li>
<li>DirectX for Modern Games</li>
<li>游戏需要加载一会儿，这个时候屏幕没反应。</li>
</ul>
</li>
<li>
<p>NieR - Automata</p>
<ul>
<li>DirectX for Modern Games</li>
<li>如果 <a href="https://www.codeweavers.com/support/forums/general/?t=27;forumc__=;forumthreadcurPos=0;forumcurPos=0;msg=244698">unable to input name for profile creation</a>，可以尝试将 CrossOver 升级到最新版本。</li>
</ul>
</li>
<li>
<p>Dead Cells</p>
<ul>
<li>参考 [playonlinux/dead cells](playonlinux/dead cells) 的 SourceCode 安装依赖后能够运行</li>
<li>DirectX for Modern Games</li>
<li>OpenAL，安装后要在 Wine Configuration &gt; Libraries 中添加 openal32（不加，点击无反应、闪退）（Libraries 中是运行时自动加载进来的库，而需要的 openal32 没有自动加载进来，因此手动添加）</li>
<li>Microsoft Visual C++ 6.0 (4.2 &amp; 6.0) Redistributable</li>
</ul>
</li>
<li>
<p>The Binding of Isaac Rebirth Repentance</p>
<ul>
<li>要在 Wine Configuration &gt; Libraries 中添加 openal32（不加，点击无反应、闪退）</li>
<li><a href="https://steamcommunity.com/sharedfiles/filedetails/?id=1581384665">《以撒的結合：重生》給新玩家的基本攻略</a></li>
</ul>
</li>
<li>
<p>Valiant Hearts The Great War</p>
<ul>
<li>Copy over the cracked content from the /Crack directory on the image to your game install directory manually.</li>
</ul>
</li>
<li>
<p>DARK SOULS REMASTERED</p>
<ul>
<li>更改语言：In the game installation folder find the &ldquo;steam_emu.ini&rdquo;, open it and find the line with language, change it to schinese.（在 font 目录可以找到所有语言）</li>
</ul>
</li>
<li>
<p>Braid</p>
<ul>
<li>DirectX for Modern Games</li>
</ul>
</li>
<li>
<p>Dying Light Platinum Edition</p>
<ul>
<li>Microsoft Visual C++ 6.0 (4.2 &amp; 6.0) Redistributable</li>
</ul>
</li>
</ul>
<h4 id="dxvkhttpswwwcodeweaverscomsupportwikilinuxlinuxtutorialdxvk"><a href="https://www.codeweavers.com/support/wiki/linux/linuxtutorial/dxvk">DXVK</a><a hidden class="anchor" aria-hidden="true" href="#dxvkhttpswwwcodeweaverscomsupportwikilinuxlinuxtutorialdxvk">#</a></h4>
<p>游戏使用 Vulkan 将获取更好的性能，为使用 Vulkan，需启用 <a href="https://github.com/doitsujin/dxvk">DXVK</a>。DXVK provides a Vulkan-based translation layer for DXGI, D3D10 and D3D11, which can be used on Linux with Wine.</p>
<p>打开 System Information，如果在属性下找到了 <strong>&ldquo;vulkan.present&rdquo;=&ldquo;yes&rdquo;</strong>，则表示支持 vulkan 并可以安装 DXVK。</p>
<p>首先安装驱动程序</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install mesa-vulkan-drivers mesa-vulkan-drivers:i386 libvulkan1 libvulkan1:i386 vulkan-utils
</code></pre></div><p>然后像安装普通软件那样，在 Select an Application to install 搜索并选择 DXVK (Upstream) 安装——DXVK (Builtin) 可能会导致游戏无法运行。安装后就自动启用了，也可以通过右键一个 Bottle&gt;Settings&gt;DXVK Vulkan backand for D3D11(Custom) 启用。</p>
<h4 id="esynchttpsgithubcomzfigurawineblobesyncreadmeesync"><a href="https://github.com/zfigura/wine/blob/esync/README.esync">Esync</a><a hidden class="anchor" aria-hidden="true" href="#esynchttpsgithubcomzfigurawineblobesyncreadmeesync">#</a></h4>
<p>注：Some Windows applications will not work correctly which ESync enabled. 例如 My Friend Pedro 开了后闪退，应该先保证正确运行，再考虑提升性能。</p>
<p><a href="https://www.reddit.com/r/wine_gaming/comments/8vf1ka/what_is_wine_esync_and_how_should_i_set_it_up/"><strong>What is &ldquo;wine esync&rdquo; and how should I set it up?</strong></a></p>
<p>the thing with Far Cry 4, 3 and Primal also Dirt Rally in wine is that it massively loads wineserver and synchronizing all the time, so it is stuck at around 20 fps on ryzen, all those games mentioned. with esync, wineserver is skipped for synchronizing and eventfd is being used, thus increasing performance that much. Games that are CPU bound with wineserver having huge load (wineserver is singlethreaded) benefit the most of this</p>
<p><a href="https://www.reddit.com/r/SteamPlay/comments/b66mz2/what_is_the_function_of_esync_why_most_games_need/"><strong>What is the function of esync? Why most games need it disabled?</strong></a></p>
<p>The function of esync is to provide lightweight thread synchronization facilities (events/semaphores/mutexes) so that game code that uses them heavily will run faster.</p>
<p>It does this using a linux-specific facility called eventfd, which is built around file descriptors. These are a limited resource normally not needed in large quantities, and therefore traditionally made available to a process only in moderate quantities. This helps prevent runaway processes and malicious code from consuming so many descriptors that none are left for other processes (a denial of service).</p>
<p>Therefore, when a game that uses tens of thousands of thread synchronization objects is run with esync, it will fail unless the system&rsquo;s per-process file descriptor limit is much higher than the traditional default. Some linux distributions have already adopted a high default, while others still default to a thousand or so. That&rsquo;s why these games run fine with esync on some distributions but fail on others unless the system&rsquo;s DefaultLimitNOFILE setting is increased.</p>
<p>Edit: If you&rsquo;re interested in esync technical issues that are not distribution-specific, check out <a href="https://github.com/zfigura/wine/issues/11#issuecomment-483060181">this comment</a>.</p>
<h5 id="howtoesynchttpsgithubcomlutrisdocsblobmasterhowtoesyncmd"><a href="https://github.com/lutris/docs/blob/master/HowToEsync.md">HowToEsync</a><a hidden class="anchor" aria-hidden="true" href="#howtoesynchttpsgithubcomlutrisdocsblobmasterhowtoesyncmd">#</a></h5>
<p><strong>What is Esync?</strong></p>
<p>Esync removes wineserver overhead for synchronization objects. This increases performance for a lot of games, especially ones that rely heavily on multithreading.</p>
<p><a href="https://github.com/zfigura/wine/blob/esync/README.esync">A more detailed explanation can be found here</a>.</p>
<p><strong>How to check Esync compatibility</strong></p>
<p>Systems using Systemd 240 and newer are already compatible with Esync.</p>
<p>If you&rsquo;re unsure that your system is compatible, run the <code>ulimit -Hn</code> command. If the value printed is equal to or greater than 524288, then your system is Esync-compatible.</p>
<p><strong>How to make your system Esync compatible</strong></p>
<p>If your system is not Esync-compatible (<code>ulimit -Hn</code>, which prints the limit for number of opened files for a process, prints a value lower than 524288, like 4096), you have 2 different methods of solving this problem. Which method is preferable depends on the distribution currently in use. Applying both methods should have no negative side effect.</p>
<ol>
<li>Modifying Systemd configuration</li>
</ol>
<p>This method applies to Ubuntu and other systems using systemd. You (with root privileges or <code>sudo</code>) need to edit both <code>/etc/systemd/system.conf</code> and <code>/etc/systemd/user.conf</code> by adding <code>DefaultLimitNOFILE=524288</code>. If <code>DefaultLimitNOFILE=</code> already exists in both <code>system.conf</code> and <code>user.conf</code>, add <code>524288</code> after <code>=</code> and make sure to uncomment the line (remove the <code>#</code> in the beginning of the line) to make it functional.</p>
<p>Once the files are edited, restart your computer for the changes to take effect. To verify if the limits were applied, run <code>ulimit -Hn</code> to see <code>524288</code> being reported.</p>
<p>If the value printed still says something like 4096, try the ulimits method below.</p>
<ol start="2">
<li>Modifying ulimits.conf</li>
</ol>
<p>On Linux distributions not using Systemd or distributions using pam-limits.conf (Arch Linux, Fedora, Solus,&hellip; ), you (with root privileges or <code>sudo</code>) need to edit <code>/etc/security/limits.conf</code>.</p>
<p>Change <code>username</code> to your actual username. Once the file is edited, reboot for the changes to take effect, and verify by running <code>ulimit -Hn</code> to see the new limit (<code>524288</code>).</p>
<pre tabindex="0"><code>username hard nofile 524288
</code></pre><h4 id="中文乱码httpsblogcsdnnetqq_35503971articledetails107296647"><a href="https://blog.csdn.net/qq_35503971/article/details/107296647">中文乱码</a><a hidden class="anchor" aria-hidden="true" href="#中文乱码httpsblogcsdnnetqq_35503971articledetails107296647">#</a></h4>
<p><strong>注</strong>：某些游戏会因为语言设置而无法运行。</p>
<p>修改步骤：打开容器 C:Drive，返回到顶层文件夹（即容器名称），即可找到<code>cxbottle.conf</code>，在文件最后面添加如下内容：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#a6e22e">[EnvironmentVariables]</span>
<span style="color:#e6db74">&#34;LANG&#34;</span> = <span style="color:#e6db74">&#34;zh_CN.UTF-8&#34;</span>
</code></pre></div><h3 id="实例">实例<a hidden class="anchor" aria-hidden="true" href="#实例">#</a></h3>
<h4 id="cemuhttpsgithubcomleomaurodesenvcemu-linux"><a href="https://github.com/leomaurodesenv/cemu-linux">Cemu</a><a hidden class="anchor" aria-hidden="true" href="#cemuhttpsgithubcomleomaurodesenvcemu-linux">#</a></h4>
<p>用 Crossover 试了一下，不能用 vulkan，很卡，鼠标延迟很高。</p>
<h4 id="office-2013-prohttpsaskubuntucomquestions879304wine-2-0-says-it-supports-office-2013-how-do-i-actually-install-it"><a href="https://askubuntu.com/questions/879304/wine-2-0-says-it-supports-office-2013-how-do-i-actually-install-it">Office 2013 Pro</a><a hidden class="anchor" aria-hidden="true" href="#office-2013-prohttpsaskubuntucomquestions879304wine-2-0-says-it-supports-office-2013-how-do-i-actually-install-it">#</a></h4>
<p><strong>注</strong>：在安装前先在 <a href="https://appdb.winehq.org/">AppDB</a> 中查找要安装的应用，在 Test Results 部分有相关教程，如 <a href="https://appdb.winehq.org/objectManager.php?sClass=version&amp;iId=28170#testdata">Microsoft Office 2013 Test Results</a></p>
<p><strong>注</strong>：要提高安装成功率，第一，不同 wine 版本安装结果是不同的，AppDB 有相应的信息；第二，winetricks 如果提供安装镜像的话，一定要用该镜像，winetrics 是一个很大的脚本，打开脚本搜索 office2013pro 即可找到官方镜像下载链接；第三，如果第一次安装失败，可以再尝试安装一次。</p>
<p>I installed office 2013 and I used to get a black window after starting it up. I fixed the black screen by following the solution posted in the [WineHQ-Forum](<a href="https://forum.winehq.org/viewtopic.php?f=8&amp;t=28446&amp;p=109296&amp;hilit=office">https://forum.winehq.org/viewtopic.php?f=8&amp;t=28446&amp;p=109296&amp;hilit=office</a> 2013#p109284).</p>
<p>Here&rsquo;s what I did:</p>
<p><strong>Install Components</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install winbind cabextract
</code></pre></div><p><strong>Create Clean 32bit Prefix for Win7</strong></p>
<p>Crete a clean 32 bit prefix and start up winecfg:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ env WINEPREFIX<span style="color:#f92672">=</span>~/.wine-office2013pro WINEARCH<span style="color:#f92672">=</span>win32 winecfg
</code></pre></div><p>In the winecfg applications tab select &ldquo;<strong>Windows version: Windows 7</strong>&rdquo; Close wine config and install winetricks</p>
<p><strong>Install Libraries</strong></p>
<p>Then start winetricks for your prefix</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ env WINEPREFIX<span style="color:#f92672">=</span>~/.wine-office2013pro WINEARCH<span style="color:#f92672">=</span>win32 winetricks
</code></pre></div><p>accept &ldquo;<strong>select the default wineprefix</strong>&rdquo; with OK. Now, select &ldquo;<strong>Install Windows DLL components</strong>&rdquo; and go and install <strong>msxml6</strong>（这个时候会下载 msxml6，可以手动下载后移动到<code>~/.cache/winetricks</code>中）</p>
<p>To fix the problem in PowerPoint (not enough memory), I added two overrides with winecfg in Library section: &ldquo;riched20&rdquo; and &ldquo;usp10&rdquo;.</p>
<p>如果是中文软件需安装中文字体。</p>
<p>在这里我直接使用 winetrics 成功安装 office2013pro（wine 6）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ env WINEPREFIX<span style="color:#f92672">=</span>~/.wine-office2013pro WINEARCH<span style="color:#f92672">=</span>win32 winetricks office2013pro
</code></pre></div><p>这样下面步骤不需要了。</p>
<p><strong>Fix Black Window</strong></p>
<p>In order to fix the black window that impedes Office 13 to be used, add the HKCU\Software\Wine\Direct3D\MaxVersionGL new DWORD value 30002 (hexa) to the registry.</p>
<p>Here&rsquo;s how to do this: In Winetricks select <strong>Run regedit</strong> and wait for the <em>Registry Editor</em> window to open. In the folder tree expand HKEY_CURRENT_USER - Software - Wine and create a new key in the Wine folder. To do so, right click, select <em>new&ndash;&gt;key</em> and name it <strong>Direct3D</strong>. Now create <em>new&ndash;&gt;DWORD Value</em>, rename the file to <strong>MaxVersionGL</strong> and set the value data to <strong>30002</strong> (hexadecimal). Close the Registry Editor window.</p>
<p>Close the winetricks window and run installer:</p>
<p><strong>Install Office 2013</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ env LANG<span style="color:#f92672">=</span>zh_CN.UTF-8 WINEPREFIX<span style="color:#f92672">=</span>~/.wine-office2013pro WINEARCH<span style="color:#f92672">=</span>win32 wine ~/PathTo/Office2013Setup.x86.exe
</code></pre></div><p>From here, the install runs and completes 100%.</p>
<p>安装后可以在 <code>~/.local/share/applications/wine</code> 下找到 微信、QQ 的 .desktop 文件，右键编辑，将 Exec=env 行改为 Exec=env LANG=zh_CN.utf8</p>
<h4 id="wechathttpswwwtechgrowcnpostsa1930361html"><a href="https://www.techgrow.cn/posts/a1930361.html">WeChat</a><a hidden class="anchor" aria-hidden="true" href="#wechathttpswwwtechgrowcnpostsa1930361html">#</a></h4>
<p><strong>Linux 安装微信的可选方案总结</strong></p>
<ul>
<li>腾讯官方 Web 版微信</li>
<li><a href="https://meetfranz.com/">Franz</a> + 微信（基于 Web 版）</li>
<li>Electronic-Wechat（基于 Web 版）</li>
<li>虚拟机 + 微信原生 PC 客户端</li>
<li>CrossOver + 微信原生 PC 客户端</li>
<li><a href="https://github.com/Winetricks/winetricks">Winetricks（基于 Wine）</a> + 微信原生 PC 客户端</li>
<li><a href="https://github.com/hillwoodroc/winetricks-zh">Winetricks-ZH（基于 Wine）</a> + 微信原生 PC 客户端</li>
<li>AppImage + <a href="https://github.com/Hackerl/Wine_Appimage">AppImage 打包构建的（Wine + 微信原生 PC 客户端）</a></li>
<li>Flatpak + <a href="https://gitee.com/wsgalaxy/flatpak-deepinwine-wiki">Flatpak 打包构建的（Deepin-Wine + 微信原生 PC 客户端）</a></li>
<li>Wine + PlayonLinux + 微信原生 PC 客户端</li>
</ul>
<h4 id="genshin-impact">Genshin Impact<a hidden class="anchor" aria-hidden="true" href="#genshin-impact">#</a></h4>
<ul>
<li><a href="https://lutris.net/games/genshin-impact/">Lutris</a></li>
<li><a href="https://gitlab.com/KRypt0n_/an-anime-game-launcher">An Anime Game Launcher</a></li>
<li><a href="https://winegame.net/home">葡萄玩</a>：跑腾讯云游戏，再用云游戏玩国服原神。</li>
</ul>
<h2 id="fstabhttpswwwcnblogscomfenggeblogp10178824html"><a href="https://www.cnblogs.com/FengGeBlog/p/10178824.html">fstab</a><a hidden class="anchor" aria-hidden="true" href="#fstabhttpswwwcnblogscomfenggeblogp10178824html">#</a></h2>
<p><code>/etc/fstab</code>是用来存放文件系统的静态信息的文件。当系统启动的时候，系统会自动地从这个文件读取信息，并且会自动将此文件中指定的文件系统挂载到指定的目录。</p>
<p>查看<code>/etc/fstab</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># cat /etc/fstab</span>
&lt;file system&gt;        &lt;dir&gt;         &lt;type&gt;    &lt;options&gt;             &lt;dump&gt; &lt;pass&gt;
tmpfs                  /tmp          tmpfs     nodev,nosuid          <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>
/dev/sda1              /             ext4      defaults,noatime      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">1</span>
/dev/sda2              none          swap      defaults,nodelalloc              <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>
/dev/sda3              /home         ext4      defaults,noatime      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">2</span>
</code></pre></div><p>分别解释一下各字段的用处：</p>
<ul>
<li><code>&lt;file system&gt;</code> 要挂载的分区或存储设备</li>
<li><code>&lt;dir&gt;</code>  挂载的目录位置</li>
<li><code>&lt;type&gt;</code> 挂载分区的文件系统类型，比如：ext3、ext4、xfs、swap</li>
<li><code>&lt;options&gt;</code> 挂载使用的参数有哪些。举例如下：
<ul>
<li>auto - 在启动时或键入了 mount -a 命令时自动挂载。</li>
<li>noauto - 只在你的命令下被挂载。</li>
<li>exec - 允许执行此分区的二进制文件。</li>
<li>noexec - 不允许执行此文件系统上的二进制文件。</li>
<li>ro - 以只读模式挂载文件系统。</li>
<li>rw - 以读写模式挂载文件系统。</li>
<li>user - 允许任意用户挂载此文件系统，若无显示定义，隐含启用 noexec, nosuid, nodev 参数。</li>
<li>users - 允许所有 users 组中的用户挂载文件系统.</li>
<li>nouser - 只能被 root 挂载。</li>
<li>owner - 允许设备所有者挂载。</li>
<li>sync - I/O 同步进行。</li>
<li>async - I/O 异步进行。</li>
<li>dev - 解析文件系统上的块特殊设备。</li>
<li>nodev - 不解析文件系统上的块特殊设备。</li>
<li>suid - 允许 suid 操作和设定 sgid 位。这一参数通常用于一些特殊任务，使一般用户运行程序时临时提升权限。</li>
<li>nosuid - 禁止 suid 操作和设定 sgid 位。</li>
<li>noatime - 不更新文件系统上 inode 访问记录，可以提升性能。</li>
<li>nodiratime - 不更新文件系统上的目录 inode 访问记录，可以提升性能(参见 atime 参数)。</li>
<li>relatime - 实时更新 inode access 记录。只有在记录中的访问时间早于当前访问才会被更新。（与</li>
<li>noatime 相似，但不会打断如 mutt 或其它程序探测文件在上次访问后是否被修改的进程。），可以提升性能。</li>
<li>flush - vfat 的选项，更频繁的刷新数据，复制对话框或进度条在全部数据都写入后才消失。</li>
<li>defaults - 使用文件系统的默认挂载参数，例如 ext4 的默认参数为:rw, suid, dev, exec, auto, nouser, async.</li>
</ul>
</li>
<li><code>&lt;dump&gt;</code> dump 工具通过它决定何时作备份。dump 会检查其内容，并用数字来决定是否对这个文件系统进行备份。 允许的数字是 0 和 1 。0 表示忽略， 1 则进行备份。大部分的用户是没有安装 dump 的 ，对他们而言 <code>&lt;dump&gt;</code> 应设为 0。</li>
<li><code>&lt;pass&gt;</code> fsck 读取 <code>&lt;pass&gt;</code> 的数值来决定需要检查的文件系统的检查顺序。允许的数字是0, 1, 和2。 根目录应当获得最高的优先权 1, 其它所有需要被检查的设备设置为 2。 0 表示设备不会被 fsck 所检查。</li>
</ul>
<p>示例：</p>
<pre tabindex="0"><code>/dev/sda1 /mnt/LinuxOSBuckup ext4 defaults 0 2
</code></pre><h3 id="uuid-of-storage-deviceshttpslinuxhintcomuuid_storage_devices_linux"><a href="https://linuxhint.com/uuid_storage_devices_linux/">UUID of Storage Devices</a><a hidden class="anchor" aria-hidden="true" href="#uuid-of-storage-deviceshttpslinuxhintcomuuid_storage_devices_linux">#</a></h3>
<p><strong>Finding UUID with blkid</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo blkid
</code></pre></div><p><strong>Finding UUID with ls</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ls -l /dev/disk/by-uuid
</code></pre></div><p><strong>Finding UUID with lsblk</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo lsblk -f
</code></pre></div><h2 id="package-management">Package Management<a hidden class="anchor" aria-hidden="true" href="#package-management">#</a></h2>
<h3 id="dpkg">dpkg<a hidden class="anchor" aria-hidden="true" href="#dpkg">#</a></h3>
<h4 id="管理软件包httpslinuxcnarticle-7953-1html"><a href="https://linux.cn/article-7953-1.html">管理软件包</a><a hidden class="anchor" aria-hidden="true" href="#管理软件包httpslinuxcnarticle-7953-1html">#</a></h4>
<p><a href="https://wiki.debian.org/Teams/Dpkg">dpkg</a> 意即 Debian 包管理器（Debian PacKaGe manager）。dpkg 是一个可以安装、构建、删除及管理 Debian 软件包的命令行工具。</p>
<p>其它的一些工具如 dpkg-deb 和 dpkg-query 等使用 dpkg 作为执行某些操作的前端。</p>
<p>现在大多数系统管理员使用 Apt、Apt-Get 及 Aptitude 等工具，不用费心就可以轻松地管理软件。</p>
<p>尽管如此，必要的时候还是需要用 dpkg 来安装某些软件。</p>
<h5 id="常见命令及文件位置">常见命令及文件位置<a hidden class="anchor" aria-hidden="true" href="#常见命令及文件位置">#</a></h5>
<p>dpkg 命令的语法:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ dpkg <span style="color:#f92672">[</span>&lt;option&gt; ...<span style="color:#f92672">]</span> &lt;command&gt;
</code></pre></div><p>dpkg 相关文件的位置在 <code>/var/lib/dpkg</code></p>
<p><code>/var/lib/dpkg/status</code> 包含了被 dpkg 命令（install、remove 等）所修改的包的信息</p>
<p><code>/var/lib/dpkg/status</code> 包含了可用包的列表</p>
<h5 id="安装升级软件">安装/升级软件<a hidden class="anchor" aria-hidden="true" href="#安装升级软件">#</a></h5>
<p>在基于 Debian 的系统里，用以下命令来安装 <code>.deb</code> 软件包。要是已经安装了软件包，就会升级它。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo dpkg -i package.deb
</code></pre></div><h5 id="从文件夹里安装软件">从文件夹里安装软件<a hidden class="anchor" aria-hidden="true" href="#从文件夹里安装软件">#</a></h5>
<p>在基于 Debian 的系统里，用下列命令从目录中逐个安装软件。这会安装 <code>/opt/software</code> 目录下的所有以 .deb 为后缀的软件。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo dpkg -iR /opt/software
</code></pre></div><h5 id="显示已安装软件列表">显示已安装软件列表<a hidden class="anchor" aria-hidden="true" href="#显示已安装软件列表">#</a></h5>
<p>以下命令可以列出 Debian 系的系统中所有已安装的软件，同时会显示软件版本和描述信息。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ dpkg -l
</code></pre></div><h5 id="查看指定的已安装软件">查看指定的已安装软件<a hidden class="anchor" aria-hidden="true" href="#查看指定的已安装软件">#</a></h5>
<p>用以下命令列出指定的一个已安装软件，同时会显示软件版本和描述信息。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ dpkg -l package
</code></pre></div><h5 id="查看软件安装目录">查看软件安装目录<a hidden class="anchor" aria-hidden="true" href="#查看软件安装目录">#</a></h5>
<p>以下命令可以在基于 Debian 的系统上查看软件的安装路径。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ dpkg -L package
</code></pre></div><h5 id="查看-deb-包内容">查看 deb 包内容<a hidden class="anchor" aria-hidden="true" href="#查看-deb-包内容">#</a></h5>
<p>下列命令可以查看 deb 包内容。它会显示 .deb 包中的一系列文件。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ dpkg -c package.deb
</code></pre></div><h5 id="显示软件的详细信息">显示软件的详细信息<a hidden class="anchor" aria-hidden="true" href="#显示软件的详细信息">#</a></h5>
<p>以下命令可以显示软件的详细信息，如软件名、软件类别、版本、维护者、软件架构、依赖的软件、软件描述等等。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ dpkg -s package
</code></pre></div><h5 id="查看文件属于哪个软件">查看文件属于哪个软件<a hidden class="anchor" aria-hidden="true" href="#查看文件属于哪个软件">#</a></h5>
<p>用以下命令来查看文件属于哪个软件。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ dpkg -S /path/file
</code></pre></div><h5 id="移除删除软件">移除/删除软件<a hidden class="anchor" aria-hidden="true" href="#移除删除软件">#</a></h5>
<p>以下命令可以用来移除/删除一个已经安装的软件，但不删除配置文件。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo dpkg -r package
</code></pre></div><h5 id="清除软件">清除软件<a hidden class="anchor" aria-hidden="true" href="#清除软件">#</a></h5>
<p>以下命令可以用来移除/删除包括配置文件在内的所有文件。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo dpkg -P package
</code></pre></div><h4 id="debian-打包入门httpslinuxcnarticle-9878-1html"><a href="https://linux.cn/article-9878-1.html">Debian 打包入门</a><a hidden class="anchor" aria-hidden="true" href="#debian-打包入门httpslinuxcnarticle-9878-1html">#</a></h4>
<p>deb包本身有三部分组成：</p>
<p><img loading="lazy" src="/Distributions/955092-20210622185420433-515372381.png" alt=""  />
</p>
<p><strong>注</strong>：原文写的不是很好，具体学习还是看官方的 <a href="https://www.debian.org/doc/manuals/maint-guide/index.zh-cn.html"><strong>Debian 新维护者手册</strong></a></p>
<p><a href="https://addons.mozilla.org/nn-NO/thunderbird/addon/cardbook/?src=hp-dl-featured">Cardbook</a> 是用于管理基于 CardDav 和 vCard 标准的联系人的Thunderbird扩展。</p>
<p>使用 <code>dh_make</code> 在当前目录下创建一个 <code>debian</code> 目录。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ dh_make<span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>	--native <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>	--single <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>	--packagename cardbook_1.0.0 <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>	--email minkush@example.com
</code></pre></div><p>一些重要的文件，比如 <code>control</code>、<code>rules</code>、<code>changelog</code>、<code>copyright</code> 等文件被初始化其中。所创建的文件的完整列表如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ find debian
debian
debian/manpage.sgml.ex
debian/cardbook.doc-base.EX
debian/changelog
debian/control
debian/postrm.ex
debian/postinst.ex
debian/source
debian/source/format
debian/README.Debian
debian/manpage.1.ex
debian/salsa-ci.yml.ex
debian/rules
debian/cardbook.cron.d.ex
debian/README.source
debian/preinst.ex
debian/prerm.ex
debian/copyright
debian/cardbook-docs.docs
debian/README
debian/manpage.xml.ex
</code></pre></div><p>在当前目录执行 <code>dpkg-buildpackage -us -uc -ui</code> 将会在上层目录创建一个空的包文件以及四个名为 <code>.changes</code>、<code>.deb</code>、 <code>.dsc</code>、 <code>.tar.gz</code> 的文件。</p>
<ul>
<li><code>.dsc</code> 文件包含了所发生的修改和签名</li>
<li><code>.deb</code> 文件是用于安装的主要包文件。</li>
<li><code>.tar.gz</code> （tarball）包含了源代码。</li>
</ul>
<p>这个过程也在 <code>debian/cardbook/usr/share/doc/cardbook</code> 目录下创建了 <code>README</code> 和 <code>changelog</code> 文件。它们包含了关于这个包的基本信息比如描述、作者、版本。</p>
<p>检查这个包安装的内容：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ dpkg -c cardbook_1.0.0_amd64.deb
/usr
/usr/share
/usr/share/doc
/usr/share/doc/cardbook
/usr/share/doc/cardbook/README.Debian
/usr/share/doc/cardbook/changelog.gz
/usr/share/doc/cardbook/copyright
</code></pre></div><h5 id="build-essentialhttpslinuxcnarticle-13953-1html"><a href="https://linux.cn/article-13953-1.html">build-essential</a><a hidden class="anchor" aria-hidden="true" href="#build-essentialhttpslinuxcnarticle-13953-1html">#</a></h5>
<p>在 Ubuntu 中安装构建基础包（<code>build-essential</code>），只需要在终端中简单输入这个命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt update <span style="color:#f92672">&amp;&amp;</span> sudo apt install build-essential
</code></pre></div><p>构建基础包（<code>build-essential</code>）实际上是属于 Debian 的。在它里面其实并不是一个软件。它包含了创建一个 Debian 包（<code>.deb</code>）所需的软件包列表。这些软件包包括 <code>libc</code>、<code>gcc</code>、<code>g++</code>、<code>make</code>、<code>dpkg-dev</code> 等。构建基础包包含这些所需的软件包作为依赖，所以当你安装它时，你只需一个命令就能安装所有这些软件包。</p>
<p>请不要认为构建基础包是一个可以在一个命令中神奇地安装从 Ruby 到 Go 的所有开发工具的超级软件包。它包含一些开发工具，但不是全部。</p>
<h4 id="package-converter">Package converter<a hidden class="anchor" aria-hidden="true" href="#package-converter">#</a></h4>
<ul>
<li><a href="https://github.com/mildred/alien">alien</a>：Alien is really designed to be used to convert from alien file formats to
the packaging format used by the distribution you run it on.</li>
<li><a href="https://github.com/microcai/gentoo-zh">gentoo-zh</a>：gentoo 本质是通过 bash 安装软件，因此，可以参考此仓库尝试手动安装软件。</li>
</ul>
<p><a href="https://askubuntu.com/questions/23818/is-linux-binary-universal-to-all-kinds-of-distributions"><strong>Is linux binary universal to all kinds of distributions?</strong></a></p>
<p>This is two questions:</p>
<p><em>Is a Linux binary universal to all distributions?</em></p>
<p>It depends:</p>
<ul>
<li>If the program is using nothing outside the Linux kernel, it will be universal except for the 32- or 64-bit question. A Linux &ldquo;hello world&rdquo; (a minimalistic program that just prints &ldquo;hello world&rdquo; to a terminal window) could probably be independent of the distribution.</li>
<li>If the program is using any non-kernel library or service (which is most of Linux, the kernel is fairly small), there are differences in which libraries are included, which versions these libraries are and where they are located. So in this (most common) case distributions are not equal.</li>
</ul>
<p><em>Why do many commercial programs say that they only work on one or a few distributions?</em></p>
<p>Because there is a <a href="http://en.wikipedia.org/wiki/List_of_Linux_distributions">very large number of Linux distributions</a>, and nobody wants to test their program on all of them.</p>
<p>A commercial vendor will normally say that they support only the distributions they have tested their software on. It may or may not work on other distributions, from the vendor&rsquo;s perspective the point is just that you can&rsquo;t complain if it does not work on a distribution they don&rsquo;t support.</p>
<p>Which distributions are selected for testing depends on what the vendor expects their customers to be using. Commercial/professional programs commonly pick enterprise distributions, possibly through a reasoning similar to &ldquo;people who paid for their OS are more likely to pay for our software&rdquo;, possibly simply by counting the distributions used by their existing customers.</p>
<p><em>See also Mark Shuttleworth (the guy that is the reason we have an Ubuntu in the first place) on [binary compatibility between Ubuntu and Debian](<a href="https://wiki.ubuntu.com/MarkShuttleworth#What">https://wiki.ubuntu.com/MarkShuttleworth#What</a> about binary compatibility) - Debian is the <a href="http://www.ubuntu.com/community/ubuntu-and-debian">closest distribution relative</a> of Ubuntu.</em></p>
<h3 id="apt">APT<a hidden class="anchor" aria-hidden="true" href="#apt">#</a></h3>
<p>Debian 使用一套名为 Advanced Packaging Tool（APT）的工具来管理包系统。在基于 Debian 的 Linux 发行版中，有各种工具可以与 APT 进行交互，以方便用户安装、删除和管理的软件包。apt-get 便是其中一款广受欢迎的命令行工具，但是最常用的命令都被分散在了 apt-get、apt-cache 和 apt-config 这三条命令当中，apt 命令的引入就是为了解决命令过于分散的问题。（简单来说就是：apt = apt-get、apt-cache 和 apt-config 中最常用命令选项的集合）</p>
<table>
<thead>
<tr>
<th style="text-align:center">apt 命令</th>
<th style="text-align:center">取代的命令</th>
<th style="text-align:center">命令的功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">apt install</td>
<td style="text-align:center">apt-get install</td>
<td style="text-align:center">安装软件包</td>
</tr>
<tr>
<td style="text-align:center">apt remove</td>
<td style="text-align:center">apt-get remove</td>
<td style="text-align:center">移除软件包</td>
</tr>
<tr>
<td style="text-align:center">apt purge</td>
<td style="text-align:center">apt-get purge</td>
<td style="text-align:center">移除软件包及配置文件</td>
</tr>
<tr>
<td style="text-align:center">apt update</td>
<td style="text-align:center">apt-get update</td>
<td style="text-align:center">刷新存储库索引</td>
</tr>
<tr>
<td style="text-align:center">apt upgrade</td>
<td style="text-align:center">apt-get upgrade</td>
<td style="text-align:center">升级所有可升级的软件包</td>
</tr>
<tr>
<td style="text-align:center">apt autoremove</td>
<td style="text-align:center">apt-get autoremove</td>
<td style="text-align:center">自动删除不需要的包</td>
</tr>
<tr>
<td style="text-align:center">apt full-upgrade</td>
<td style="text-align:center">apt-get dist-upgrade</td>
<td style="text-align:center">在升级软件包时自动处理依赖关系</td>
</tr>
<tr>
<td style="text-align:center">apt search</td>
<td style="text-align:center">apt-cache search</td>
<td style="text-align:center">搜索应用程序</td>
</tr>
<tr>
<td style="text-align:center">apt show</td>
<td style="text-align:center">apt-cache show</td>
<td style="text-align:center">显示装细节</td>
</tr>
<tr>
<td style="text-align:center">apt list</td>
<td style="text-align:center"></td>
<td style="text-align:center">列出包含条件的包（已安装，可升级等）</td>
</tr>
<tr>
<td style="text-align:center">apt edit-sources</td>
<td style="text-align:center"></td>
<td style="text-align:center">编辑源列表</td>
</tr>
</tbody>
</table>
<h4 id="列出所有手动安装软件">列出所有手动安装软件<a hidden class="anchor" aria-hidden="true" href="#列出所有手动安装软件">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ apt-mark showmanual
</code></pre></div><h4 id="查看软件包依赖">查看软件包依赖<a hidden class="anchor" aria-hidden="true" href="#查看软件包依赖">#</a></h4>
<p>当你在 Linux 中安装一个软件包，有时这个软件包还需要其他的软件包来使它工作正常。这些额外的软件包就叫作这个包的依赖。假如这些软件包之前没有在系统中被安装，那么这些依赖在安装这个软件包的同时会被自动安装上。</p>
<p><strong>使用 apt show 来查看依赖</strong></p>
<p>你可以使用 apt show 命令 来展示一个包的详细信息。其中依赖信息就是其中一部分，你可以在以 “Depends” 打头的那些行中看到它们。</p>
<p>例如，下面展示的是使用 <code>apt show</code> 展示 ubuntu-restricted-extras 这个包的详细信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ apt show ubuntu-restricted-extras 
Package: ubuntu-restricted-extras
Version: <span style="color:#ae81ff">67</span>
...
Depends: ubuntu-restricted-addons
Recommends: libavcodec-extra, ttf-mscorefonts-installer, unrar
...
</code></pre></div><p>如你所见，<code>ubuntu-restricted-extras</code> 包依赖于 <code>ubuntu-restricted-addons</code> 这个软件包。</p>
<p>但你得小心的是依赖包还可能依赖于其他包，这样一直循环往复直到尽头。但幸好 APT 包管理器可以为你处理这些复杂的依赖关系，自动地安装所有的依赖（大多数情况下）。</p>
<p><strong>什么是推荐包？</strong></p>
<p>你注意到了上面结果输出中以 “Recommends” 开头的那些行了吗？</p>
<p>推荐包不是软件包的直接依赖，但它们可以开启软件包的一些额外功能。</p>
<p>正如你上面看到的那样， <code>ubuntu-restricted-extras</code> 包有 <code>ttf-mscorefonts-installer</code> 这个推荐包，用来在 Ubuntu 上安装 Microsoft 的字体。</p>
<p>这些推荐包也会默认被一同安装上，假如你想显式地禁止这些推荐包的安装，你可以像下面这样使用 <code>–-no-install-recommends</code> 选项。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install --no-install-recommends package_name
</code></pre></div><p><strong>使用 apt-cache 来直接获取依赖信息</strong></p>
<p>上面通过 <code>apt show</code> 的方式会获取到大量信息，假如你想在脚本中获取到依赖信息，那么 <code>apt-cache</code> 命令将会给你一个更好且更简洁的输出结果。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ apt-cache depends package_name
</code></pre></div><p><strong>使用 dpkg 来查看一个 DEB 文件的依赖</strong></p>
<p><code>apt</code> 和 <code>apt-cache</code> 都作用于软件仓库中的软件包，但假如你下载了一个 DEB 文件，那么这两个命令就不起作用了。</p>
<p>在这种情形下，你可以使用 <code>dpkg</code> 命令的 <code>-I</code> 或 <code>--info</code> 选项。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ dpkg -I path_to_deb_file
</code></pre></div><p>依赖信息就可以在以 “Depends” 开头的那些行中找到。</p>
<p><strong>使用 apt-rdepends 来查看依赖及依赖的依赖</strong></p>
<p>假如你想查看更多关于依赖的信息，那么你可以使用 <code>apt-rdepends</code> 工具。这个工具可以创建完整的依赖树。这样你就可以得到一个软件包的依赖以及这些依赖的依赖。</p>
<p>它不是一个常规的 <code>apt</code> 命令，所以你需要从 universe 软件仓库中安装上它：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install apt-rdepends
</code></pre></div><p>这个命令的输出通常很多，取决于依赖树的大小。</p>
<pre tabindex="0"><code>eading package lists... Done
Building dependency tree
Reading state information... Done
shutter
  Depends: procps
  Depends: xdg-utils
imagemagick
  Depends: imagemagick-6.q16 (&gt;= 8:6.9.2.10+dfsg-2~)
imagemagick-6.q16
  Depends: hicolor-icon-theme
  Depends: libc6 (&gt;= 2.4)
  Depends: libmagickcore-6.q16-6 (&gt;= 8:6.9.10.2)
  Depends: libmagickwand-6.q16-6 (&gt;= 8:6.9.10.2)
hicolor-icon-theme
libc6
  Depends: libcrypt1 (&gt;= 1:4.4.10-10ubuntu4)
  Depends: libgcc-s1
libcrypt1
  Depends: libc6 (&gt;= 2.25)
</code></pre><p><code>apt-rdepends</code> 工具的功能非常多样，它还可以用来计算反向依赖。这意味着你可以查看某个特定的包被哪些软件包依赖。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ apt-rdepends -r package_name
</code></pre></div><p>输出可能会非常多，因为它将打印出反向依赖树。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ apt-rdepends -r ffmpeg
Reading package lists... Done
Building dependency tree       
Reading state information... Done
ffmpeg
  Reverse Depends: ardour-video-timeline <span style="color:#f92672">(</span>&gt;<span style="color:#f92672">=</span> 1:5.12.0-3ubuntu4<span style="color:#f92672">)</span>
  Reverse Depends: deepin-screen-recorder <span style="color:#f92672">(</span>5.0.0-1build2<span style="color:#f92672">)</span>
  Reverse Depends: devede <span style="color:#f92672">(</span>4.15.0-2<span style="color:#f92672">)</span>
  Reverse Depends: dvd-slideshow <span style="color:#f92672">(</span>0.8.6.1-1<span style="color:#f92672">)</span>
  Reverse Depends: green-recorder <span style="color:#f92672">(</span>&gt;<span style="color:#f92672">=</span> 3.2.3<span style="color:#f92672">)</span>
</code></pre></div><h4 id="repository-mirror">Repository Mirror<a hidden class="anchor" aria-hidden="true" href="#repository-mirror">#</a></h4>
<p><a href="https://askubuntu.com/questions/39922/how-do-you-select-the-fastest-mirror-from-the-command-line"><strong>Select the fastest mirror</strong></a></p>
<p>You can use <code>deb mirror</code> to have the best mirror picked for you automatically.</p>
<p>apt-get <a href="http://mvogt.wordpress.com/2011/03/21/the-apt-mirror-method/">now supports</a> a &lsquo;mirror&rsquo; method that will automatically select a good mirror based on your location. Putting:</p>
<pre tabindex="0"><code>deb mirror://mirrors.ubuntu.com/mirrors.txt precise main restricted universe multiverse
deb mirror://mirrors.ubuntu.com/mirrors.txt precise-updates main restricted universe multiverse
deb mirror://mirrors.ubuntu.com/mirrors.txt precise-backports main restricted universe multiverse
deb mirror://mirrors.ubuntu.com/mirrors.txt precise-security main restricted universe multiverse
</code></pre><p>on the top in your <code>/etc/apt/sources.list</code> file should be all that is needed to make it automatically pick a mirror for you based on your geographical location.</p>
<p><a href="https://ostechnix.com/how-to-find-best-ubuntu-apt-repository-mirror/"><strong>The command line way</strong></a></p>
<p>There are many command line tools available to find the best APT mirrors based on download speed. I have tested the following tools and they are working just fine in my Ubuntu 20.04 LTS desktop.</p>
<ol>
<li>Apt-select</li>
<li>Apt-smart</li>
</ol>
<h4 id="apt-fasthttpsvituxcomhow-to-speed-up-package-downloads-and-updates-with-apt-fast-on-ubuntu"><a href="https://vitux.com/how-to-speed-up-package-downloads-and-updates-with-apt-fast-on-ubuntu/">apt-fast</a><a hidden class="anchor" aria-hidden="true" href="#apt-fasthttpsvituxcomhow-to-speed-up-package-downloads-and-updates-with-apt-fast-on-ubuntu">#</a></h4>
<p><a href="https://github.com/ilikenwf/apt-fast">apt-fast</a>: A shellscript wrapper for apt that speeds up downloading of packages.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt-get install aria2
$ sudo add-apt-repository ppa:apt-fast/stable
$ sudo apt-get update
$ sudo apt-get -y install apt-fast
$ sudo nano /etc/apt-fast.conf
MIRRORS<span style="color:#f92672">=(</span><span style="color:#e6db74">&#39;https://mirrors.bfsu.edu.cn/ubuntu/,https://mirrors.tuna.tsinghua.edu.cn/ubuntu/&#39;</span><span style="color:#f92672">)</span>
</code></pre></div><h4 id="apt-aria2httplinuxundertheskyblogspotcom201109accelerate-download-of-apt-get-viahtml"><a href="http://linuxunderthesky.blogspot.com/2011/09/accelerate-download-of-apt-get-via.html">apt-aria2</a><a hidden class="anchor" aria-hidden="true" href="#apt-aria2httplinuxundertheskyblogspotcom201109accelerate-download-of-apt-get-viahtml">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">#!/bin/bash
</span><span style="color:#75715e"></span>
<span style="color:#75715e">## apt-aria2: To help download packages faster via aria2, instead of wget.</span>
<span style="color:#75715e">## Author: Anjishnu Sarkar</span>
<span style="color:#75715e">## Version: 0.5</span>
<span style="color:#75715e">## Acknowledgement: This script is a rewrite of the apt-fast script by</span>
<span style="color:#75715e">## Matt Parnell (admin@mattparnell.com) (http://www.mattparnell.com)</span>
<span style="color:#75715e">## Usage: Same as apt-get. Using the option &#34;-y&#34; always.</span>

<span style="color:#75715e">## BUG:</span>
<span style="color:#75715e">## *) If this script is interuppted, then next time aria2 starts downloading</span>
<span style="color:#75715e">## the same from the begining. Can be solved - something to do with .st file.</span>

<span style="color:#75715e">## TODO:</span>
<span style="color:#75715e">## *) Start installing via apt-get as soon as first package is downloaded</span>
<span style="color:#75715e">##    and also keep downloading at the same time. This however might lead</span>
<span style="color:#75715e">##    to dependencies not being satisfied.</span>

<span style="color:#75715e">## Initialization(s):</span>
Download<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;False&#34;</span>
Install<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;True&#34;</span>
Confirm<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;True&#34;</span>
UniqueName<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$RANDOM<span style="color:#e6db74">&#34;</span>
Options<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$@<span style="color:#e6db74">&#34;</span>

<span style="color:#75715e">## Checking for commands which requires download</span>
<span style="color:#66d9ef">while</span> test -n <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>1<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>
<span style="color:#66d9ef">do</span>
    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>1<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span> in
      install|upgrade|dist-upgrade|source|build-dep<span style="color:#f92672">)</span>
        <span style="color:#75715e">## Download</span>
        Download<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;True&#34;</span>
        ;;
      update|remove|autoremove|purge|dselect-upgrade|clean|autoclean|check<span style="color:#f92672">)</span>
        <span style="color:#75715e">## Anything other than download</span>
        Download<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;False&#34;</span>
        ;;
     -d<span style="color:#f92672">)</span> <span style="color:#75715e">## Download only (don&#39;t install)</span>
        Install<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;False&#34;</span>
        ;;
     -y<span style="color:#f92672">)</span> <span style="color:#75715e">## No need to ask for confirmation</span>
        Confirm<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;False&#34;</span>
        ;;
      *<span style="color:#f92672">)</span>
        <span style="color:#75715e">## Nothing to be done. If any wrong options/commands are given then</span>
        <span style="color:#75715e">## let apt-get handle it.</span>
        ;;
    <span style="color:#66d9ef">esac</span>
    shift
<span style="color:#66d9ef">done</span>

<span style="color:#75715e">## In case download is true</span>
<span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> <span style="color:#e6db74">&#34;</span>$Download<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;True&#34;</span> <span style="color:#f92672">]</span>;<span style="color:#66d9ef">then</span>

    <span style="color:#75715e">## Installing pre-requisite(s): aria2</span>
    <span style="color:#66d9ef">if</span> ! which aria2c &gt; /dev/null; <span style="color:#66d9ef">then</span>
        echo <span style="color:#e6db74">&#34;Aria2 not installed. Installing aria2 first via apt-get&#34;</span>
        apt-get -y --force-yes install aria2
    <span style="color:#66d9ef">fi</span>

    ArchiveDir<span style="color:#f92672">=</span>/var/cache/apt/archives/
    cd <span style="color:#e6db74">${</span>ArchiveDir<span style="color:#e6db74">}</span>/partial

    PrintUris<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>apt-get --yes --print-uris <span style="color:#e6db74">${</span>Options<span style="color:#e6db74">}</span><span style="color:#66d9ef">)</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> $? -ne <span style="color:#ae81ff">0</span> <span style="color:#f92672">]</span>;<span style="color:#66d9ef">then</span>
        echo <span style="color:#e6db74">&#34;Aborting.&#34;</span>
        exit <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">fi</span>

    PackageInfo<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>echo <span style="color:#e6db74">&#34;</span>$PrintUris<span style="color:#e6db74">&#34;</span> | awk <span style="color:#e6db74">&#39;/Reading package/,/After this operation/&#39;</span><span style="color:#66d9ef">)</span>
<span style="color:#75715e">#     echo &#34;$PrintUris&#34; | grep ^\&#39; | cut -d\&#39; -f2 &gt; &#34;$UniqueName&#34;-uris.txt</span>
    echo <span style="color:#e6db74">&#34;</span>$PrintUris<span style="color:#e6db74">&#34;</span> | grep <span style="color:#e6db74">&#34;http:&#34;</span> | cut -d<span style="color:#ae81ff">\&#39;</span> -f2 &gt; <span style="color:#e6db74">&#34;</span>$UniqueName<span style="color:#e6db74">&#34;</span>-uris.txt
    NumberOfPackages<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>wc -l <span style="color:#e6db74">&#34;</span>$UniqueName<span style="color:#e6db74">&#34;</span>-uris.txt | awk <span style="color:#e6db74">&#39;{print $1}&#39;</span><span style="color:#66d9ef">)</span>

    <span style="color:#75715e">## Print info</span>
    echo <span style="color:#e6db74">&#34;</span>$PackageInfo<span style="color:#e6db74">&#34;</span>
    echo <span style="color:#e6db74">&#34;Number of packages to be downloaded: </span>$NumberOfPackages<span style="color:#e6db74">&#34;</span>

    <span style="color:#75715e">## Check whether package has already been installed or not</span>
    InstallUpgradeMsg<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>echo <span style="color:#e6db74">&#34;</span>$PackageInfo<span style="color:#e6db74">&#34;</span> | grep <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>        -e <span style="color:#e6db74">&#34;The following NEW packages will be installed:&#34;</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>        -e <span style="color:#e6db74">&#34;The following packages will be upgraded:&#34;</span><span style="color:#66d9ef">)</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> -z <span style="color:#e6db74">&#34;</span>$InstallUpgradeMsg<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span>;<span style="color:#66d9ef">then</span>
        rm -f <span style="color:#e6db74">&#34;</span>$UniqueName<span style="color:#e6db74">&#34;</span>-uris.txt
        exit <span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">fi</span>
    <span style="color:#75715e">## In $InstallUpgradeMsg is not null, then proceed...</span>

    <span style="color:#75715e">## If confirm is true</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> <span style="color:#e6db74">&#34;</span>$Confirm<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;True&#34;</span> <span style="color:#f92672">]</span>;<span style="color:#66d9ef">then</span>
        echo -n <span style="color:#e6db74">&#34;Do you want to continue [y|n]? &#34;</span>
        read Ans

        <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;</span>$Ans<span style="color:#e6db74">&#34;</span> in
            y|yes|<span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">)</span>   ;;

            n|no|*<span style="color:#f92672">)</span>     echo <span style="color:#e6db74">&#34;Abort.&#34;</span>
                        rm -f <span style="color:#e6db74">&#34;</span>$UniqueName<span style="color:#e6db74">&#34;</span>-uris.txt
                        exit <span style="color:#ae81ff">1</span> ;;
        <span style="color:#66d9ef">esac</span>
    <span style="color:#66d9ef">fi</span>

    <span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> $NumberOfPackages -ne <span style="color:#ae81ff">0</span> <span style="color:#f92672">]</span>;<span style="color:#66d9ef">then</span>
        <span style="color:#75715e">## Downloading the packages</span>
        echo <span style="color:#e6db74">&#34;Proceeding with downloading ...&#34;</span>
        <span style="color:#66d9ef">while</span> read DebUrl
        <span style="color:#66d9ef">do</span>
            DebName<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>basename <span style="color:#e6db74">&#34;</span>$DebUrl<span style="color:#e6db74">&#34;</span><span style="color:#66d9ef">)</span>
            echo <span style="color:#e6db74">&#34;</span>$DebName<span style="color:#e6db74">&#34;</span>

            AptConf<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;/etc/apt/apt.conf&#34;</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> -f <span style="color:#e6db74">&#34;</span>$AptConf<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span>;<span style="color:#66d9ef">then</span>
                http_proxy<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>grep -i <span style="color:#e6db74">&#34;http::proxy&#34;</span> <span style="color:#e6db74">&#34;</span>$AptConf<span style="color:#e6db74">&#34;</span> | cut -d <span style="color:#ae81ff">\&#34;</span> -f2<span style="color:#66d9ef">)</span>
            <span style="color:#66d9ef">fi</span>

            <span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> -n <span style="color:#e6db74">&#34;</span>$http_proxy<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span>;<span style="color:#66d9ef">then</span>
                echo <span style="color:#e6db74">&#34;Using proxy...&#34;</span>
                aria2c -c -s <span style="color:#ae81ff">10</span> -j <span style="color:#ae81ff">10</span> --http-proxy<span style="color:#f92672">=</span>$http_proxy <span style="color:#e6db74">&#34;</span>$DebUrl<span style="color:#e6db74">&#34;</span>
            <span style="color:#66d9ef">else</span>
                echo <span style="color:#e6db74">&#34;Not using proxy...&#34;</span>
                aria2c -c -s <span style="color:#ae81ff">10</span> -j <span style="color:#ae81ff">10</span> <span style="color:#e6db74">&#34;</span>$DebUrl<span style="color:#e6db74">&#34;</span>
            <span style="color:#66d9ef">fi</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> $? -eq <span style="color:#ae81ff">0</span> <span style="color:#f92672">]</span>;<span style="color:#66d9ef">then</span>
                mv $DebName <span style="color:#e6db74">${</span>ArchiveDir<span style="color:#e6db74">}</span>
            <span style="color:#66d9ef">fi</span>
        <span style="color:#66d9ef">done</span> &lt; <span style="color:#e6db74">&#34;</span>$UniqueName<span style="color:#e6db74">&#34;</span>-uris.txt
    <span style="color:#66d9ef">fi</span>
    rm -f <span style="color:#e6db74">&#34;</span>$UniqueName<span style="color:#e6db74">&#34;</span>-uris.txt

<span style="color:#75715e">#     echo &#34;Installing...&#34;</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> <span style="color:#e6db74">&#34;</span>$Install<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;True&#34;</span> <span style="color:#f92672">]</span>;<span style="color:#66d9ef">then</span>
        apt-get -y --force-yes <span style="color:#e6db74">${</span>Options<span style="color:#e6db74">}</span>
    <span style="color:#66d9ef">fi</span>
<span style="color:#66d9ef">else</span>
<span style="color:#75715e">## Cases when download is false</span>
    apt-get <span style="color:#e6db74">${</span>Options<span style="color:#e6db74">}</span>
<span style="color:#66d9ef">fi</span>
</code></pre></div><h3 id="ppahttpslinuxcnarticle-10456-1html"><a href="https://linux.cn/article-10456-1.html">PPA</a><a hidden class="anchor" aria-hidden="true" href="#ppahttpslinuxcnarticle-10456-1html">#</a></h3>
<p>软件仓库是一组文件，其中包含各种软件及其版本的信息，以及校验和等其他一些详细信息。每个版本的 Ubuntu 都有自己的四个官方软件仓库：</p>
<ul>
<li>Main - Canonical 支持的自由开源软件。</li>
<li>Universe - 社区维护的自由开源软件。</li>
<li>Restricted - 设备的专有驱动程序。</li>
<li>Multiverse - 受版权或法律问题限制的软件。</li>
</ul>
<p>你可以在 <a href="http://archive.ubuntu.com/ubuntu/dists/">这里</a> 看到所有版本的 Ubuntu 的软件仓库。你可以浏览并转到各个仓库。</p>
<p>这些信息存储在系统的 <code>/etc/apt/sources.list</code> 文件中。如果查看此文件的内容，你就会看到里面有软件仓库的网址。<code>#</code> 开头的行将被忽略。</p>
<p>Ubuntu 不会在官方仓库中立即提供新版本的软件。他们需要一个步骤来检查此新版本的软件是否与系统兼容，从而可以确保系统的稳定性。这意味着它需要经过几周才能在 Ubuntu 上可用，在某些情况下，这可能需要几个月的时间。</p>
<p>为获取最新版本的软件，需要使用 PPA，PPA (Personal Package Archives) 允许开发者上传要构建的 Ubuntu 源包，并通过 <a href="https://launchpad.net/">Launchpad</a> 作为 apt 的软件仓库发布。</p>
<p>通过如下命令添加 PPA 软件仓库并获取最新版本软件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo add-apt-repository &lt;PPA_info&gt;
$ sudo apt-get update
$ sudo apt-get install &lt;package_in_PPA&gt;
</code></pre></div><p>当你使用 PPA 时，它不会更改原始的 <code>sources.list</code> 文件。相反，它在 <code>/etc/apt/sources.d</code> 目录中创建了两个文件，一个 <code>.list</code> 文件和一个带有 <code>.save</code> 后缀的备份文件。这是一种安全措施，可以确保添加的 PPA 不会和原始的 <code>sources.list</code> 文件弄混，它还有助于移除 PPA。</p>
<p>开发人员为他们的软件创建的 PPA 称为官方 PPA。但有时，个人会创建由其他开发人员所创建的项目的 PPA。为什么会有人这样做？ 因为许多开发人员只提供软件的源代码。</p>
<p>如果 PPA 不适用于你的系统版本，你可以点击应用程序 PPA 页面的 View package details，在这里，你可以单击软件包以显示更多详细信息，还可以在此处找到包的源代码和 DEB 文件。建议 <a href="https://itsfoss.com/gdebi-default-ubuntu-software-center/">使用 Gdebi 安装这些 DEB 文件</a> 而不是通过软件中心，因为 Gdebi 在处理依赖项方面要好得多。</p>
<p>就安全性而言，很少见到因为使用 PPA 之后你的 Linux 系统被黑客攻击或注入恶意软件。到目前为止，我不记得发生过这样的事件。官方 PPA 可以不加考虑的使用，使用非官方 PPA 完全是你自己的决定。根据经验，如果程序需要 sudo 权限，则应避免通过第三方 PPA 进行安装。</p>
<h3 id="snap--flatpak">Snap &amp; Flatpak<a hidden class="anchor" aria-hidden="true" href="#snap--flatpak">#</a></h3>
<p><strong><a href="https://merlijn.sebrechts.be/blog/2020-07-03-snap-vs-flatpak/">A fundamental difference between Snap and Flatpak</a></strong></p>
<p>Flatpak is designed to install and update “apps”; user-facing software such as video editors, chat programs and more.</p>
<p>snaps can install anything which contains a kernel, printer drivers, audio subsystems and more.</p>
<p>Snap and Flatpak are the software behind two universal Linux app stores: the <a href="https://snapcraft.io/store">Snap Store</a> and <a href="https://flathub.org/">Flathub</a><em>.</em></p>
<h4 id="讨论">讨论<a hidden class="anchor" aria-hidden="true" href="#讨论">#</a></h4>
<p><strong>openSUSE 群</strong></p>
<p>Flatpak使用bubblewrap来隔离应用程序，bwrap是非常轻量化的沙箱程序，因此攻击面极小。但bwrap需要用户对Linux程序工作方式有准确的了解（使用哪些syscall），Flatpak相当于充当了一个bwrap的前端帮助控制bwrap权限。</p>
<p>目前Flatpak的问题在于seccomp权限太过广泛，但目前Flatpak维护者已经意识到了这个问题（注释：在他们踩了一次坑之后），已经计划打算解决了。</p>
<p>另一个问题是程序请求的权限过于广泛，但这更多是一个决策问题而不是技术问题，而且你可以用Flatseal手动调整权限。</p>
<p>Flatpak你不能用常规程序方式来理解，每个程序都是一个完全独立的空间，只有给予了权限才有对应访问权，也可以用Portals调用文件选择器来获得单独一个文件的完全访问权，Flatpak版的Steam是把所有程序配置文件放在~/.var/app里面了，类似安卓下面的分区存储做法。</p>
<p>AppImage就只是个自挂载程序，自带的文件透明挂载到它自己的根文件系统下面，所以依然依赖主机的一部分库。所以是的，跟打包者用的系统有关系。</p>
<p>Flatpak不是这种机制，每个Flatpak空间是完全空白的，需要打包者自己选择加入哪些东西，所以Flatpak跨发行版的兼容性也更好。</p>
<p>良好打包的AppImage可以有很好的跨发行版兼容性，但是代价就是需要手工测试每个发行版下面的效果。在跨发行版兼容性这点上我更看好Flatpak。</p>
<p>最后，不要跟我提Snap，我不想碰那个东西，也对它没有研究的兴趣。</p>
<p>Flatpak确实有很多可取之处，或者不能说是Flatpak可取，而是Linux桌面软件生态现状决定了，只有更激进的手段才能改变现状。</p>
<p>AppImage那种策略还是过于不痛不痒了，结果就是程序仅仅是被打包成一个个单文件，但背后的库依赖地狱、权限隔离问题一个都没解决。</p>
<p>但AppImage作者的想法本来也不是靠AppImage颠覆，他是希望Linux能够重新恢复LSB，确保发行版之间的兼容性本身可靠而不是依赖Flatpak这些技术，就类似于Windows上的软件不需要什么沙箱模拟器，你几乎可以保证旧版本的软件能在新版本运行。</p>
<p>其实也可以说明，微软那种在桌面上采取的策略，很可能难以在Linux社区里推广开来，微软那种做法，确保绝对的向下兼容性，不是谁都有精力来做的。</p>
<p>比如说如果让微软来做Wayland，那微软根本就不会把Wayland做出来，而是把X11一直迭代、削减臃肿功能直到性能和现代化图形技术栈的性能相匹敌，同时确保向下兼容性。而最新一代的X11很可能和最早的X11已经彻底不一样了，甚至会有“检测程序版本然后自动匹配对应的X11功能”这些奇怪的兼容性策略出来。或许有一天微软会把新项目叫做Wayland，但这个改名也仅仅是营销目的而不是技术目的。</p>
<p>毕竟LSB已经没了，Ubuntu甚至砍掉32位兼容性，也可以说明其实Linux这边并没有太多人在乎这问题。</p>
<p>毕竟“反正源代码都在那，重新编译一遍不就好了吗”</p>
<p><strong>Fedora 群</strong></p>
<p>空のあお, [2/28/22 8:25 PM]
软件有不同版本的依赖
这些依赖很难共存
有些旧版依赖还有更旧的依赖
不说二进制兼容，有些连源码兼容都搞不定
就算搞定了，一段时间过后依赖升级了，还是得坏
flatpak的做法是维护abi稳定的qt和gtk两大ui库和必要桌面库的runtime，用来公用
通过容器隔离app，让每个app自己构建所需的特定依赖到容器里</p>
<p>竹林里有冰, [2/28/22 8:33 PM]
sandbox他是用bubblewrap实现的吧，你可以直接使用bubblewrap，应该一样可以做到他的沙盒化，更小巧一点
bubblewrap的缺点就是需要针对每个程序写上配置，除了有点麻烦其他倒还不错</p>
<p>Neomonk Zen, [2/28/22 8:36 PM]
也不知flatpak的软件仓库，有没什么审核机制来防止恶意软件，如果没有的话，那还蛮可怕的，想想Chrome和Android的软件市场，都有很多恶意软件</p>
<p>Robin Lee, [2/28/22 8:39 PM]
没有深入的审核，跟各大发行版的官方包差不多，但flatpak可以限制应用权限</p>
<h4 id="在-ubuntu-上使用-flatpakhttpsflatpakorgsetupubuntu"><a href="https://flatpak.org/setup/Ubuntu/">在 Ubuntu 上使用 Flatpak</a><a hidden class="anchor" aria-hidden="true" href="#在-ubuntu-上使用-flatpakhttpsflatpakorgsetupubuntu">#</a></h4>
<p>The official Flatpak PPA is the recommended way to install Flatpak. To install it, run the following in a terminal:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo add-apt-repository ppa:flatpak/stable
$ sudo apt update
$ sudo apt install flatpak
</code></pre></div><p>Flathub is the best place to get Flatpak apps. To enable it, run:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo
</code></pre></div><p>To complete setup, <strong>restart</strong> your system. Now all you have to do is <a href="https://flathub.org/">install some apps</a>!</p>
<h4 id="questions-1">Questions<a hidden class="anchor" aria-hidden="true" href="#questions-1">#</a></h4>
<p><strong><a href="https://blog.csdn.net/u011870280/article/details/80213866">snap &ldquo;canonical-livepatch&rdquo; has &ldquo;install-snap&rdquo; change in progress</a></strong></p>
<p>Snap 包是 Ubuntu 16.04 LTS 发布时引入的新应用格式包。目前已流行在很多 Linux 发行版上。并且可以很方便地安装常用软件，如 VLC、Sublime Text、VSCode、Node、WPS等</p>
<p>当你在安装完 Snap 后，你会发现在在根目录下会出现如 /dev/loop0 的挂载点，这些挂载点正是 Snap 软件包的目录。</p>
<ul>
<li>
<p>原因是软件之前安装了一次，只是安装失败。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ snap changessnap abort 5		<span style="color:#75715e">## 5 为安装失败软件的 ID</span>
</code></pre></div></li>
<li>
<p>现在重新安装</p>
</li>
</ul>
<p>一些软件最好在官网下载或在 Snap 中下载，官方 Repository 可能并不新，比如 VLC。</p>
<h3 id="tasksel-install-group-softwarehttpswwwcybercitibizfaqtasksel-install-group-software-in-command-line"><a href="https://www.cyberciti.biz/faq/tasksel-install-group-software-in-command-line/">tasksel: Install Group Software</a><a hidden class="anchor" aria-hidden="true" href="#tasksel-install-group-softwarehttpswwwcybercitibizfaqtasksel-install-group-software-in-command-line">#</a></h3>
<p>安装</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install tasksel
</code></pre></div><p>list tasks</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ tasksel --list-tasks
</code></pre></div><p>displays description</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ tasksel --task-desc dns-server
</code></pre></div><p>install</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install dns-server
</code></pre></div><h3 id="pacstallhttpsgithubcompacstallpacstall"><a href="https://github.com/pacstall/pacstall">pacstall</a><a hidden class="anchor" aria-hidden="true" href="#pacstallhttpsgithubcompacstallpacstall">#</a></h3>
<p>An AUR-inspired package manager for Ubuntu</p>
<h3 id="appimagehttpsappimageorg"><a href="https://appimage.org/">AppImage</a><a hidden class="anchor" aria-hidden="true" href="#appimagehttpsappimageorg">#</a></h3>
<p>Linux apps that run anywhere</p>
<h3 id="包管理器的进化httpslinuxcnarticle-9931-1html"><a href="https://linux.cn/article-9931-1.html">包管理器的进化</a><a hidden class="anchor" aria-hidden="true" href="#包管理器的进化httpslinuxcnarticle-9931-1html">#</a></h3>
<p>今天，每个可计算设备都会使用某种软件来完成预定的任务。在软件开发的上古时期，为了找出软件中的 bug 和其它缺陷，软件会被严格的测试。在近十年间，软件被通过互联网来频繁分发，以试图通过持续不断的安装新版本的软件来解决软件的缺陷问题。在很多情况下，每个独立的应用软件都有其自带的更新器。而其它一些软件则让用户自己去搞明白如何获取和升级软件。</p>
<p>Linux 较早采用了维护一个中心化的软件仓库来发布软件更新这种做法，用户可以在这个软件仓库里查找并安装软件。在这篇文章里， 笔者将回顾在 Linux 上的如何进行软件安装的历史，以及现代操作系统如何保持更新以应对<a href="https://en.wikipedia.org/wiki/Common_Vulnerabilities_and_Exposures">软件安全漏洞（CVE）</a>不断的曝光。</p>
<h4 id="手动安装软件">手动安装软件<a hidden class="anchor" aria-hidden="true" href="#手动安装软件">#</a></h4>
<p>曾几何时，软件都是通过 FTP 或邮件列表（LCTT 译注：即通过邮件列表发布源代码的补丁包）来分发的（最终这些发布方式在互联网的迅猛发展下都演化成为一个个现今常见的软件发布网站）。（一般在一个 tar 文件中）只有一个非常小的文件包含了创建二进制的说明。你需要做的是先解压这个包，然后仔细阅读当中的 <code>README</code> 文件， 如果你的系统上恰好有 GCC（LCTT 译注：GNU C Compiler）或者其它厂商的 C 编译器的话，你得首先运行 <code>./configure</code> 脚本，并在脚本后添加相应的参数，如库函数的路径、创建可执行文件的路径等等。除此之外，这个配置过程也会检查你操作系统上的软件依赖是否满足安装要求。如果缺失了任何主要的依赖，该配置脚本会退出不再继续安装，直到你满足了该依赖。如果该配置脚本正常执行完毕，将会创建一个 <code>Makefile</code> 文件。</p>
<p>当有了一个 <code>Makefile</code> 文件时， 你就可以接下去执行 <code>make</code> 命令（该命令由你所使用的编译器提供）。<code>make</code> 命令也有很多参数，被称为 <code>make</code> 标识flag，这些标识能为你的系统优化最终生成出来的二进制可执行文件。在计算机世界的早期，这些优化是非常重要的，因为彼时的计算机硬件正在为了跟上软件迅速的发展而疲于奔命。今日今时，编译标识变得更加通用而不是为了优化哪些具体的硬件型号，这得益于现代硬件和现代软件相比已经变得成本低廉，唾手可得。</p>
<p>最后，在 <code>make</code> 完成之后， 你需要运行 <code>make install</code> （或 <code>sudo make install</code>）（LCTT 译注：依赖于你的用户权限） 来“真正”将这个软件安装到你的系统上。可以想象，为你系统上的每一个软件都执行上述的流程将是多么无聊费时，更不用说如果更新一个已经安装的软件将会多复杂，多么需要精力投入。（LCTT 译注：上述流程也称 CMMI 安装， 即Configure、Make、Make Install）</p>
<h4 id="软件包">软件包<a hidden class="anchor" aria-hidden="true" href="#软件包">#</a></h4>
<p>package（LCTT 译注：下文简称“包”）这个概念是用来解决在软件安装、升级过程中的复杂性的。包将软件安装升级中需要的多个数据文件合并成一个单独的文件，这将便于传输和（通过压缩文件来）减小存储空间（LCTT 译注：减少存储空间这一点在现在已经不再重要），包中的二进制可执行文件已根据开发者所选择的编译标识预编译。包本身包括了所有需要的元数据，如软件的名字、软件的说明、版本号，以及要运行这个软件所需要的依赖包等等。</p>
<p>不同流派的 Linux 发行版都创造了它们自己的包格式，其中最常用的包格式有：</p>
<ul>
<li>.deb：这种包格式由 Debian、Ubuntu、Linux Mint 以及其它的变种使用。这是最早被发明的包类型。</li>
<li>.rpm：这种包格式最初被称作红帽包管理器Red Hat Package Manager（LCTT 译注： 取自英文的首字母）。使用这种包的 Linux 发行版有 Red Hat、Fedora、SUSE 以及其它一些较小的发行版。</li>
<li>.tar.xz：这种包格式只是一个软件压缩包而已，这是 Arch Linux 所使用的格式。</li>
</ul>
<p>尽管上述的包格式自身并不能直接管理软件的依赖问题，但是它们的出现将 Linux 软件包管理向前推进了一大步。</p>
<h4 id="软件仓库">软件仓库<a hidden class="anchor" aria-hidden="true" href="#软件仓库">#</a></h4>
<p>多年以前（当智能电话还没有像现在这样流行时），非 Linux 世界的用户是很难理解软件仓库的概念的。甚至今时今日，大多数完全工作在 Windows 下的用户还是习惯于打开浏览器，搜索要安装的软件（或升级包），下载然后安装。但是，智能电话传播了软件“商店”（LCTT 译注： 对应 Linux 里的软件仓库）这样一个概念。智能电话用户获取软件的方式和包管理器的工作方式已经非常相近了。些许不同的是，尽管大多数软件商店还在费力美化它的图形界面来吸引用户，大多数 Linux 用户还是愿意使用命令行来安装软件。总而言之，软件仓库是一个中心化的可安装软件列表，上面列举了在当前系统中预先配置好的软件仓库里所有可以安装的软件。</p>
<h4 id="包管理器">包管理器<a hidden class="anchor" aria-hidden="true" href="#包管理器">#</a></h4>
<p>包管理器用来和相应的软件仓库交互，获取软件的相应信息。下面对流行做一个简短介绍。</p>
<h5 id="基于-prm-包格式的包管理器">基于 PRM 包格式的包管理器<a hidden class="anchor" aria-hidden="true" href="#基于-prm-包格式的包管理器">#</a></h5>
<p>更新基于 RPM 的系统，特别是那些基于 Red Hat 技术的系统，有着非常有趣而又详实的历史。实际上，现在的 <a href="https://en.wikipedia.org/wiki/Yum_(software)">YUM</a> 版本（用于 企业级发行版）和 <a href="https://fedoraproject.org/wiki/DNF">DNF</a>（用于社区版）就融合了好几个开源项目来提供它们现在的功能。</p>
<p>Red Hat 最初使用的包管理器，被称为 <a href="https://en.wikipedia.org/wiki/Rpm_(software)">RPM</a>（红帽包管理器Red Hat Package Manager），时至今日还在使用着。不过，它的主要作用是安装本地的 RPM 包，而不是去在软件仓库搜索软件。后来开发了一个叫 <code>up2date</code> 的包管理器，它被用来通知用户包的最新更新，还能让用户在远程仓库里搜索软件并便捷的安装软件的依赖。尽管这个包管理器尽职尽责，但一些社区成员还是感觉 <code>up2date</code> 有着明显的不足。</p>
<p>现在的 YUM 来自于好几个不同社区的努力。1999-2001 年一群在 Terra Soft Solution 的伙计们开发了Yellowdog Updater（YUP），将其作为 <a href="https://en.wikipedia.org/wiki/Yellow_Dog_Linux">Yellow Dog Linux</a> 图形安装器的后端。杜克大学Duke University喜欢这个主意就决定去增强它的功能，它们开发了<a href="https://www.archlinux.org/">Yellowdog Updater, Modified（YUM）</a>，这最终被用来帮助管理杜克大学的 Red Hat 系统。Yum 壮大的很快，到 2005 年，它已经被超过一半的 Linux 市场所采用。今日，几乎所有的使用 RPM 的的 Linux 都会使用 YUM 来进行包管理（当然也有一些例外）。</p>
<p><a href="https://en.wikipedia.org/wiki/DNF_(software)">Dandified Yum（DNF）</a>是 YUM 的下一代接班人。从 Fedora 18 开始被作为包管理器引入系统，不过它并没有被企业版所采用，所以它只在 Fedora（以及变种）上占据了主导地位。DNF 的用法和 YUM 几乎一模一样，它主要是用来解决性能问题、晦涩无说明的API、缓慢/不可靠的依赖解析，以及偶尔的高内存占用。DNF 是作为 YUM 的直接替代品来开发的，因此这里笔者就不重复它的用法了，你只用简单的将 <code>yum</code> 替换为 <code>dnf</code> 就行了。</p>
<p><a href="https://en.opensuse.org/Portal:Zypper">Zypper</a> 是用来管理 RPM 包的另外一个包管理器。这个包管理器主要用于 <a href="https://www.suse.com/">SUSE</a>（和 <a href="https://www.opensuse.org/">openSUSE</a>），在<a href="https://en.wikipedia.org/wiki/MeeGo">MeeGo</a>、<a href="https://sailfishos.org/">Sailfish OS</a>、<a href="https://www.tizen.org/">Tizen</a> 上也有使用。它最初开发于 2006 年，已经经过了多次迭代。除了作为系统管理工具 <a href="https://en.wikipedia.org/wiki/YaST">YaST</a> 的后端和有些用户认为它比 YUM 要快之外也没有什么好多说的。</p>
<h5 id="基于-debian-的包管理器">基于 Debian 的包管理器<a hidden class="anchor" aria-hidden="true" href="#基于-debian-的包管理器">#</a></h5>
<p>作为一个现今仍在被积极维护的最古老的 Linux 发行版之一，Debian 的包管理系统和基于 RPM 的系统的包管理系统非常类似。它使用扩展名为 “.deb” 的包，这种文件能被一个叫做 <code>dpkg</code> 的工具所管理。<code>dpgk</code> 同 <code>rpm</code> 非常相似，它被设计成用来管理在存在于本地（硬盘）的包。它不会去做包依赖关系解析（它会做依赖关系检查，不过仅此而已），而且在同远程软件仓库交互上也并无可靠的途径。为了提高用户体验并便于使用，Debian 项目开始了一个软件项目：Deity，最终这个代号被丢弃并改成了现在的 <a href="https://en.wikipedia.org/wiki/APT_(Debian)">Advanced Pack Tool（APT）</a>。</p>
<p>在 1998 年，APT 测试版本发布（甚至早于 1999 年的 Debian 2.1 发布），许多用户认为 APT 是基于 Debian 系统标配功能之一。APT 使用了和 RPM 一样的风格来管理仓库，不过和 YUM 使用单独的 .repo 文件不同，APT 曾经使用 <code>/etc/apt/sources.list</code> 文件来管理软件仓库，后来的变成也可以使用 <code>/etc/apt/sources.d</code> 目录来管理。如同基于 RPM 的系统一样，你也有很多很多选项配置来完成同样的事情。你可以编辑和创建前述的文件，或者使用图形界面来完成上述工作（如 Ubuntu 的“Software &amp; Updates”）。</p>
<p>现今大多数的 Ubuntu 教程里都径直使用了 <code>apt</code>。 单独一个 <code>apt</code> 设计用来实现那些最常用的 APT 命令的。<code>apt</code> 命令看上去是用来整合那些被分散在 <code>apt-get</code>、<code>apt-cache</code> 以及其它一些命令的的功能的。它还加上了一些额外的改进，如色彩、进度条以及其它一些小功能。</p>
<h5 id="基于-arch-的包管理器">基于 Arch 的包管理器<a hidden class="anchor" aria-hidden="true" href="#基于-arch-的包管理器">#</a></h5>
<p><a href="https://www.archlinux.org/">Arch Linux</a> 使用称为 <a href="https://wiki.archlinux.org/index.php/pacman">packman</a> 的包管理器。和 .deb 以及 .rpm 不同，它使用更为传统的 LZMA2 压缩包形式 .tar.xz 。这可以使 Arch Linux 包能够比其它形式的压缩包（如 gzip）有更小的尺寸。自从 2002 年首次发布以来， <code>pacman</code> 一直在稳定发布和改善。使用它最大的好处之一是它支持 <a href="https://wiki.archlinux.org/index.php/Arch_Build_System">Arch Build System</a>，这是一个从源代码级别构建包的构建系统。该构建系统借助一个叫 <code>PKGBUILD</code> 的文件，这个文件包含了如版本号、发布号、依赖等等的元数据，以及一个为编译遵守 Arch Linux 需求的包所需要的带有必要的编译选项的脚本。而编译的结果就是前文所提的被 <code>pacman</code> 所使用的 .tar.xz 的文件。</p>
<p>上述的这套系统技术上导致了 <a href="https://aur.archlinux.org/">Arch User Respository（AUR）</a>的产生，这是一个社区驱动的软件仓库，仓库里包括有 <code>PKGBUILD</code> 文件以及支持补丁或脚本。这给 Arch Linux 带了无穷无尽的软件资源。最为明显的好处是如果一个用户（或开发者）希望他开发的软件能被广大公众所使用，他不必通过官方途径去在主流软件仓库获得许可。而不利之处则是它必须将依赖社区的流程，类似于 <a href="https://hub.docker.com/">Docker Hub</a>、 Canonical 的 Snap Packages（LCTT 译注： Canonical 是 Ubuntu 的发行公司），或者其它类似的机制。</p>
<p>有很多特定于 AUR 的包管理器能被用来从 AUR 里的 <code>PGKBUILD</code> 文件下载、编译、安装。其中 <code>yaourt</code> 和 <code>pacaur</code> 颇为流行。不过，这两个项目已经被 <a href="https://wiki.archlinux.org/index.php/AUR_helpers#Discontinued_or_problematic">Arch Wiki</a> 列为“不继续开发以及有已知的问题未解决”。因为这个原因，这里直接讨论 <code>aurman</code>，除了会搜索 AUR 以及包含几个有帮助的（其实很危险）的选项之外，它的工作机制和 <code>pacman</code> 极其类似。</p>
<h3 id="condahttpswwwjianshucompedaa744ea47d"><a href="https://www.jianshu.com/p/edaa744ea47d">conda</a><a hidden class="anchor" aria-hidden="true" href="#condahttpswwwjianshucompedaa744ea47d">#</a></h3>
<h4 id="简介-5">简介<a hidden class="anchor" aria-hidden="true" href="#简介-5">#</a></h4>
<p>Conda 是一个开源的软件包管理系统和环境管理系统，用于安装多个版本的软件包及其依赖关系，并在它们之间轻松切换。 Conda 是为 Python 程序创建的，适用于 Linux，OS X 和 Windows，也可以打包和分发其他软件。</p>
<h4 id="安装-4">安装<a hidden class="anchor" aria-hidden="true" href="#安装-4">#</a></h4>
<p>conda分为anaconda和miniconda。anaconda是包含一些常用包的版本（这里的常用不代表你常用），miniconda则是精简版，需要啥装啥，所以推荐使用miniconda。</p>
<p>miniconda官网：https://conda.io/miniconda.html</p>
<p>选择适合自己的版本下载：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ wget -c https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh
</code></pre></div><p>这里选择的是<code>latest-Linux</code>版本，所以下载的程序会随着python的版本更新而更新。</p>
<p>安装：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ chmod <span style="color:#ae81ff">777</span> Miniconda3-latest-Linux-x86_64.sh
$ bash Miniconda3-latest-Linux-x86_64.sh
</code></pre></div><p>加不加入环境变量都可以。所谓的会污染环境等等问题可能都是将大量的软件直接安装在conda的base环境中引起的，只要养成好的使用习惯，灵活使用conda create 命令将不同的软件安装到自己单独的虚拟环境中就可以了。把conda这条蟒蛇关进一个一个的笼子里，才能更好的为我们的科研服务~</p>
<h4 id="添加频道">添加频道<a hidden class="anchor" aria-hidden="true" href="#添加频道">#</a></h4>
<p>这个道理跟家里的电视机是一样一样的，安装conda就相当于买了一台电视机，但是有电视了不意味着你就能看节目了，你要手动添加频道才能看你想看的电视节目。</p>
<p>添加清华的镜像channels：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/
$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/
$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/
$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/
</code></pre></div><p>为了分担清华源镜像的压力，北京外国语大学也开启了镜像站点，同样是由清华TUNA团队维护的，如果有小伙伴遇到清华源速度很慢的情况的话，可以考虑换成北外的镜像。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ conda config --add channels https://mirrors.bfsu.edu.cn/anaconda/cloud/bioconda/
$ conda config --add channels https://mirrors.bfsu.edu.cn/anaconda/cloud/conda-forge/
$ conda config --add channels https://mirrors.bfsu.edu.cn/anaconda/pkgs/free/
$ conda config --add channels https://mirrors.bfsu.edu.cn/anaconda/pkgs/main/
</code></pre></div><p>显示安装的频道</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ conda config --set show_channel_urls yes 
</code></pre></div><p>查看已经添加的channels</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ conda config --get channels
</code></pre></div><p>已添加的channel在哪里查看</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ vim ~/.condarc
</code></pre></div><h4 id="软件包管理">软件包管理<a hidden class="anchor" aria-hidden="true" href="#软件包管理">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ conda install gatk
</code></pre></div><h5 id="搜索安装包">搜索安装包<a hidden class="anchor" aria-hidden="true" href="#搜索安装包">#</a></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ conda search gatk
</code></pre></div><p>安装完成后，可以用“which 软件名”来查看该软件安装的位置：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ which gatk
</code></pre></div><h5 id="安装特定版本">安装特定版本<a hidden class="anchor" aria-hidden="true" href="#安装特定版本">#</a></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ conda install 软件名<span style="color:#f92672">=</span>版本号
$ conda install gatk<span style="color:#f92672">=</span>3.7
</code></pre></div><p>这时conda会先卸载已安装版本，然后重新安装指定版本。</p>
<h5 id="查看已安装软件">查看已安装软件<a hidden class="anchor" aria-hidden="true" href="#查看已安装软件">#</a></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ conda list
</code></pre></div><h5 id="更新指定软件">更新指定软件<a hidden class="anchor" aria-hidden="true" href="#更新指定软件">#</a></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ conda update gatk
</code></pre></div><h5 id="卸载指定软件">卸载指定软件<a hidden class="anchor" aria-hidden="true" href="#卸载指定软件">#</a></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ conda remove gatk
</code></pre></div><h4 id="环境管理">环境管理<a hidden class="anchor" aria-hidden="true" href="#环境管理">#</a></h4>
<h5 id="退出conda环境">退出conda环境<a hidden class="anchor" aria-hidden="true" href="#退出conda环境">#</a></h5>
<p>退出也很简单，之前我们是<code>. ./activate 或者 (. ~/miniconda3/bin/activate)</code>现在退出只要:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ . ./deactivate
<span style="color:#75715e"># 或者用 </span>
$ conda deactivate
</code></pre></div><p>就退出当前的环境了</p>
<h5 id="创建conda环境">创建conda环境<a hidden class="anchor" aria-hidden="true" href="#创建conda环境">#</a></h5>
<p>之前创建的时候显示的是（base）这是conda的基本环境，有些软件依赖的是python2的版本，当你还是使用你的base的时候你的base里的python会被自动降级，有可能会引发别的软件的报错，所以，可以给一些特别的软件一些特别的关照，比如创建一个单独的环境。</p>
<p>在conda环境下，输入<code>conda env list</code>（或者输入<code>conda info --envs</code>也是一样滴）查看当前存在的环境：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ conda env list
</code></pre></div><p>创建一个新的环境</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ conda create -n python2 python<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>
</code></pre></div><ul>
<li>-n: 设置新的环境的名字</li>
<li>python=2 指定新环境的python的版本，非必须参数</li>
<li>这里也可以用一个-y参数，可以直接跳过安装的确认过程。</li>
</ul>
<p>conda会创建一个新的python2的环境，并且会很温馨的提示你只要输入conda activate python2就可以启动这个环境了。</p>
<h5 id="删除环境">删除环境<a hidden class="anchor" aria-hidden="true" href="#删除环境">#</a></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ conda remove -n myenv --all
</code></pre></div><h5 id="重命名环境">重命名环境<a hidden class="anchor" aria-hidden="true" href="#重命名环境">#</a></h5>
<p>实际上conda并没有提供这样的功能，但是可以曲线救国，原理是先克隆一个原来的环境，命名成想要的名字，再把原来的环境删掉即可</p>
<p>接下来演示把一个原来叫做py2的环境重新命名成python2：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ conda create -n python2 --clone py2
$ conda remove -n py2 --all
</code></pre></div><h3 id="自动更新httpswwwcnblogscomsparkdevp11376560html"><a href="https://www.cnblogs.com/sparkdev/p/11376560.html">自动更新</a><a hidden class="anchor" aria-hidden="true" href="#自动更新httpswwwcnblogscomsparkdevp11376560html">#</a></h3>
<p>Ubuntu 默认的配置会每天自动安装安全更新而忽略其它包的更新。</p>
<h4 id="更新机制">更新机制<a hidden class="anchor" aria-hidden="true" href="#更新机制">#</a></h4>
<p>Ubuntu 默认定义了 4 个 systemd unit 执行更新任务，它们分别是：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">/lib/systemd/system/apt-daily-upgrade.service
/lib/systemd/system/apt-daily-upgrade.timer
/lib/systemd/system/apt-daily.service
/lib/systemd/system/apt-daily.timer
</code></pre></div><p>中的 apt-daily.timer 和 apt-daily-upgrade.timer 是两个触发器，分别在每天指定的时间触发 apt-daily.service 和 apt-daily-upgrade.service。这两个 service 的类型都是 oneshot，意思是当任务完成后 service 进程退出。这两个 service 其实调用的是同一个脚本： <code>/usr/lib/apt/apt.systemd.daily</code>。apt-daily.service 为脚本传入参数 &ldquo;update&rdquo;，其功能为检查系统的更新并下载对应的更新包。apt-daily-upgrade.service 为脚本传入参数 &ldquo;install&rdquo;，其功能为安装更新并删除缓存在本地的更新包。</p>
<p>apt-daily.timer 默认每天触发两次，分别为 6 点和 18 点，主要是为了缓解服务器端的下载压力。我们可以根据自身业务的特点设置合适的触发时间。</p>
<p>apt-daily-upgrade.service 默认每天在 6 点触发一次，我们也可以设置为其它时间，比如午夜。</p>
<h4 id="aptsystemddaily">apt.systemd.daily<a hidden class="anchor" aria-hidden="true" href="#aptsystemddaily">#</a></h4>
<p><code>/usr/lib/apt/apt.systemd.daily</code> 脚本负责完成与更新相关的一系列工作，这些工作主要分为两大块：</p>
<ul>
<li>检查更新并下载更新包</li>
<li>安装更新并清理更新包</li>
</ul>
<p>apt.systemd.daily 脚本中调用 apt-config 命令从 <code>/etc/apt/apt.conf.d/10periodic</code> 文件和 <code>/etc/apt/apt.conf.d/20auto-upgrades</code> 读中取配变量，并根据这些变量的值来控制系统的更新策略。下面我们介绍几个比较重要的配置项。</p>
<p>隔多少天执行一次 apt-get update，默认是 1 天，0 表示不执行该操作：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">APT::Periodic::Update-Package-Lists <span style="color:#e6db74">&#34;1&#34;</span>;
</code></pre></div><p>隔多少天执行一次 apt-get upgrade &ndash;download-only 下载更新包，0 表示不执行该操作：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">APT::Periodic::Download-Upgradeable-Packages <span style="color:#e6db74">&#34;0&#34;</span>;
</code></pre></div><p>下载的更新版被缓存在目录 <code>/var/cache/apt/archives/</code> 中，执行升级操作时直接从缓存目录中读取包文件而不是从网络上下载。</p>
<p>隔多少天执行一次 apt-get autoclean 清除无用的更新包，0 表示不执行该操作：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">APT::Periodic::AutocleanInterval <span style="color:#e6db74">&#34;0&#34;</span>;
</code></pre></div><p>隔多少天执行一次 Unattended-Upgrade 执行系统安全更新(或者所有包的更新)，0 表示不执行该操作：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">APT::Periodic::Unattended-Upgrade <span style="color:#e6db74">&#34;1&#34;</span>;
</code></pre></div><p>通过这些配置，我们可以控制自动更新的频率和行为。注意，<em>到目前为止的配置还只能安装系统的安全更新</em>，如果要想安装所有包的更新还需要其它的配置。</p>
<p>在继续介绍后面的内容前，让我们先来了解一下 apt.systemd.daily 脚本中用到的 apt-config 命令和 apt.systemd.daily 脚本依赖的配置文件。</p>
<p><strong>apt-config 命令</strong></p>
<p>apt-config 是一个被 APT 套件使用的内部命令，使用它可以在脚本中提取 <code>/etc/apt/apt.conf</code> 目录下配置文件中的信息。</p>
<p>比如，如果要在脚本中获取 APT::Periodic::Update-Package-Lists 的设置，可以使用下面的代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">#!/bin/bash
</span><span style="color:#75715e"></span>ABC<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>
eval <span style="color:#66d9ef">$(</span>apt-config shell ABC APT::Periodic::Update-Package-Lists<span style="color:#66d9ef">)</span>
echo <span style="color:#e6db74">${</span>ABC<span style="color:#e6db74">}</span>
</code></pre></div><p>此时脚本变量 ABC 中保存的就是 APT::Periodic::Update-Package-Lists 的值。</p>
<p><strong>10periodic 和 20auto-upgrades</strong></p>
<p><code>/etc/apt/apt.conf.d/10periodic</code> 是 update-notifier-common 的配置文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ dpkg-query -S /etc/apt/apt.conf.d/10periodic
update-notifier-common: /etc/apt/apt.conf.d/10periodic
</code></pre></div><p>在 ubuntu 16.04 和 18.04 中，这两个文件的默认内容是一样的。apt.systemd.daily 脚本在注释中说我们可以通过 <code>/etc/apt/apt.conf.d/10periodic</code> 文件自定义相关的变量值，它通过 get-config 命令来获得这些变量的值。但是测试的结果是 <code>/etc/apt/apt.conf.d/20auto-upgrades</code> 文件中的变量会覆盖 <code>/etc/apt/apt.conf.d/10periodic</code> 文件中的变量。看来是 get-config 命令根据文件名称的顺序，排在后面的文件中的变量会覆盖前面文件中的变量。</p>
<p>在 desktop 版本中，通过 GUI 程序修改相关的变量，这两个文件都会被修改并保持一致，所以在 server 版中我们最好也同时修改这两个文件并保持其内容一致。</p>
<h4 id="unattended-upgrades">unattended-upgrades<a hidden class="anchor" aria-hidden="true" href="#unattended-upgrades">#</a></h4>
<p>Ubuntu 实际上是通过 unattended-upgrades 命令来自动安装更新的。Ubuntu 16.04/18.04 默认安装了这个包，如果碰到没有安装的情况你还可以通过下面的命令自行安装：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install unattended-upgrades
</code></pre></div><p>unattended-upgrades 的配置文件为 <code>/etc/apt/apt.conf.d/50unattended-upgrades</code>。</p>
<p>注意，unattended-upgrades 不仅能够安装系统的安全更新，还可以安装所有包的更新。但是默认的配置只安装安全更新，我们可以通过配置项让 unattended-upgrades 安装所有的包更新或者只安装安全更新。</p>
<p>unattended-upgrades 命令被设计为通过 cron 定时执行系统更新，但在 Ubuntu 16.04/18.04 中是通过 systemd 的 timer unit 定时触发 service unit 执行的。</p>
<p>unattended-upgrades 命令的日志文件存放在 <code>/var/log/unattended-upgrades</code> 目录下。</p>
<p>unattended-upgrade 命令常见的用法之一是检查系统是否有更新：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo unattended-upgrade --dry-run
</code></pre></div><p>另一种用法是安装更新：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo unattended-upgrade
</code></pre></div><p>在 apt.systemd.daily 脚本中执行 unattended-upgrade 命令时，由于更新包已经提前下载到缓存目录了(<code>/var/cache/apt/archives</code>)，所以直接它直接使用缓存中的更新包。</p>
<p><strong>配置文件 50unattended-upgrades</strong></p>
<p>50unattended-upgrades 文件中的默认配置只是安装安全更新：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">Unattended-Upgrade::Allowed-Origins <span style="color:#f92672">{</span>
        <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>distro_id<span style="color:#e6db74">}</span><span style="color:#e6db74">:</span><span style="color:#e6db74">${</span>distro_codename<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>;
        <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>distro_id<span style="color:#e6db74">}</span><span style="color:#e6db74">:</span><span style="color:#e6db74">${</span>distro_codename<span style="color:#e6db74">}</span><span style="color:#e6db74">-security&#34;</span>;
        <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>distro_id<span style="color:#e6db74">}</span><span style="color:#e6db74">ESM:</span><span style="color:#e6db74">${</span>distro_codename<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>;
//      <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>distro_id<span style="color:#e6db74">}</span><span style="color:#e6db74">:</span><span style="color:#e6db74">${</span>distro_codename<span style="color:#e6db74">}</span><span style="color:#e6db74">-updates&#34;</span>;
//      <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>distro_id<span style="color:#e6db74">}</span><span style="color:#e6db74">:</span><span style="color:#e6db74">${</span>distro_codename<span style="color:#e6db74">}</span><span style="color:#e6db74">-proposed&#34;</span>;
//      <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>distro_id<span style="color:#e6db74">}</span><span style="color:#e6db74">:</span><span style="color:#e6db74">${</span>distro_codename<span style="color:#e6db74">}</span><span style="color:#e6db74">-backports&#34;</span>;
<span style="color:#f92672">}</span>;
</code></pre></div><p>如果要自动安装所有包的更新，只要取消下面行的注释就行了：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>distro_id<span style="color:#e6db74">}</span><span style="color:#e6db74">:</span><span style="color:#e6db74">${</span>distro_codename<span style="color:#e6db74">}</span><span style="color:#e6db74">-updates&#34;</span>;
</code></pre></div><p>我们还可以通过黑名单的方式指定不更新哪些包：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">Unattended-Upgrade::Package-Blacklist <span style="color:#f92672">{</span>
      <span style="color:#e6db74">&#34;vim&#34;</span>;
      <span style="color:#e6db74">&#34;libc6&#34;</span>;
      <span style="color:#e6db74">&#34;libc6-dev&#34;</span>;
      <span style="color:#e6db74">&#34;libc6-i686&#34;</span>;
<span style="color:#f92672">}</span>;
</code></pre></div><p>下面的配置项指定在更新后移除无用的包：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">Unattended-Upgrade::Remove-Unused-Kernel-Packages <span style="color:#e6db74">&#34;true&#34;</span>;
Unattended-Upgrade::Remove-Unused-Dependencies <span style="color:#e6db74">&#34;true&#34;</span>;
</code></pre></div><p>有些更新需要重启系统，而默认的配置是不重启系统的。下面的配置允许重启系统(更新完成后，如果需要重启，立即重启系统)：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">Unattended-Upgrade::Automatic-Reboot <span style="color:#e6db74">&#34;true&#34;</span>;
</code></pre></div><p>但是多数情况下我们更期望指定一个时间让系统重启(如果需要重启，在下面配置中指定的时间重启系统)：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">Unattended-Upgrade::Automatic-Reboot-Time <span style="color:#e6db74">&#34;02:38&#34;</span>;
</code></pre></div><p>在系统更新的过程中发生了错误怎么办？当然是通知管理员啦！下面的配置在发生错误时给管理员发送邮件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">Unattended-Upgrade::Mail <span style="color:#e6db74">&#34;user@example.com&#34;</span>;
Unattended-Upgrade::MailOnlyOnError <span style="color:#e6db74">&#34;true&#34;</span>;
</code></pre></div><p>注意：如果要向外网发送邮件，需要安装 mailx 等工具。</p>
<h4 id="关闭自动更新">关闭自动更新<a hidden class="anchor" aria-hidden="true" href="#关闭自动更新">#</a></h4>
<p>如果你的主机运行在封闭的环境中，并且无法连接到有效的更新源，此时可以选择关闭自动更新功能。首选的方法是停止相关的服务：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo systemctl stop apt-daily.service
$ sudo systemctl stop apt-daily.timer
$ sudo systemctl stop apt-daily-upgrade.service
$ sudo systemctl stop apt-daily-upgrade.timer
$ sudo systemctl disable apt-daily.service
$ sudo systemctl disable apt-daily.timer
$ sudo systemctl disable apt-daily-upgrade.service
$ sudo systemctl disable apt-daily-upgrade.timer
</code></pre></div><p>或者修改自动更新程序的配置文件也可以，同时更新 <code>/etc/apt/apt.conf.d/10periodic</code> 和 <code>/etc/apt/apt.conf.d/20auto-upgrades</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">APT::Periodic::Update-Package-Lists <span style="color:#e6db74">&#34;1&#34;</span>;
APT::Periodic::Unattended-Upgrade <span style="color:#e6db74">&#34;1&#34;</span>;
</code></pre></div><p>改为</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">APT::Periodic::Update-Package-Lists <span style="color:#e6db74">&#34;0&#34;</span>;
APT::Periodic::Unattended-Upgrade <span style="color:#e6db74">&#34;0&#34;</span>;
</code></pre></div><h2 id="lvmhttpswwwcnblogscomsparkdevp10130934html"><a href="https://www.cnblogs.com/sparkdev/p/10130934.html">LVM</a><a hidden class="anchor" aria-hidden="true" href="#lvmhttpswwwcnblogscomsparkdevp10130934html">#</a></h2>
<p>在对磁盘分区的大小进行规划时，往往不能确定这个分区要使用的空间的大小。而使用 fdisk、gdisk 等工具对磁盘分区后，每个分区的大小就固定了。如果分区设置的过大，就白白浪费了磁盘空间；如果分区设置的过小，就会导致空间不够用的情况出现。对于分区过小的问题，可以从新划分磁盘的分区，或者通过软连接的方式将此分区的目录链接到另外一个分区。这样虽然能够临时解决问题，但是给管理带来了麻烦。类似的问题可以通过 LVM 来解决。</p>
<h3 id="lvm-是什么">LVM 是什么<a hidden class="anchor" aria-hidden="true" href="#lvm-是什么">#</a></h3>
<p>LVM 是 Logical Volume Manager 的缩写，中文一般翻译为 &ldquo;逻辑卷管理&rdquo;，它是 Linux 下对磁盘分区进行管理的一种机制。LVM 是建立在磁盘分区和文件系统之间的一个逻辑层，系统管理员可以利用 LVM <strong>在不重新对磁盘分区的情况下动态的调整分区的大小</strong>。如果系统新增了一块硬盘，通过 LVM 就可以将新增的硬盘空间直接扩展到原来的磁盘分区上。</p>
<p>LVM 的优点如下：</p>
<ul>
<li>文件系统可以跨多个磁盘，因此大小不再受物理磁盘的限制。</li>
<li>可以在系统运行状态下动态地扩展文件系统大小。</li>
<li>可以以镜像的方式冗余重要数据到多个物理磁盘上。</li>
<li>可以很方便地导出整个卷组，并导入到另外一台机器上。</li>
</ul>
<p>LVM 也有一些缺点：</p>
<ul>
<li>在从卷组中移除一个磁盘的时候必须使用 reducevg 命令(这个命令要求root权限，并且不允许在快照卷组中使用)。</li>
<li>当卷组中的一个磁盘损坏时，整个卷组都会受影响。</li>
<li>因为增加了一个逻辑层，存储的性能会受影响。</li>
</ul>
<p>LVM 的优点对服务器的管理非常有用，但对于桌面系统的帮助则没有那么显著，所以需要我们根据使用的场景来决定是否应用 LVM。</p>
<h3 id="lvm-中的基本概念">LVM 中的基本概念<a hidden class="anchor" aria-hidden="true" href="#lvm-中的基本概念">#</a></h3>
<p>通过 LVM 技术，可以屏蔽掉磁盘分区的底层差异，在逻辑上给文件系统提供了一个卷的概念，然后在这些卷上建立相应的文件系统。下面是 LVM 中主要涉及的一些概念。</p>
<ul>
<li>**物理存储设备(Physical Media)：**指系统的存储设备文件，比如 /dev/sda、/dev/sdb 等。</li>
<li>**PV(物理卷 Physical Volume)：**指硬盘分区或者从逻辑上看起来和硬盘分区类似的设备(比如 RAID 设备)。</li>
<li>**VG(卷组 Volume Group)：**类似于非 LVM 系统中的物理硬盘，一个 LVM 卷组由一个或者多个 PV(物理卷)组成。</li>
<li>**LV(逻辑卷 Logical Volume)：**类似于非 LVM 系统上的磁盘分区，LV 建立在 VG 上，可以在 LV 上建立文件系统。</li>
<li>**PE(Physical Extent)：**PV(物理卷)中可以分配的最小存储单元称为 PE，PE 的大小是可以指定的。</li>
<li>**LE(Logical Extent)：**LV(逻辑卷)中可以分配的最小存储单元称为 LE，在同一个卷组中，LE 的大小和 PE 的大小是一样的，并且一一对应。</li>
</ul>
<p>可以这么理解，LVM 是把硬盘的分区分成了更小的单位(PE)，再用这些单元拼成更大的看上去像分区的东西(PV)，进而用 PV 拼成看上去像硬盘的东西(VG)，最后在这个新的硬盘上创建分区(LV)。文件系统则建立在 LV 之上，这样就在物理硬盘和文件系统中间添加了一层抽象(LVM)。下图大致描述了这些概念之间的关系：</p>
<p><img loading="lazy" src="/Distributions/LVM.png" alt=""  />
</p>
<p>对上图中的结构做个简单的介绍：</p>
<p>两块物理硬盘 A 和 B 组成了 LVM 的底层结构，这两块硬盘的大小、型号可以不同。PV 可以看做是硬盘上的分区，因此可以说物理硬盘 A 划分了两个分区，物理硬盘 B 划分了三个分区。然后将前三个 PV 组成一个卷组 VG1，后两个 PV 组成一个卷组 VG2。接着在卷组 VG1 上划分了两个逻辑卷 LV1 和 LV2，在卷组 VG2 上划分了一个逻辑卷 LV3。最后，在逻辑卷 LV1、LV2 和 LV3 上创建文件系统，分别挂载在 /usr、/home 和 /var 目录。</p>
<h3 id="lvm-工具">LVM 工具<a hidden class="anchor" aria-hidden="true" href="#lvm-工具">#</a></h3>
<p>在安装 Linux 时，如果选择使用 LVM 创建分区，就会安装 LVM 相关的工具。当前这个软件包的名称为 lvm2，其中包含了大量 LVM 工具。比如单是查看 LVM 相关实体状态的命令就有如下一些：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo pvscan
$ sudo pvs
$ sudo pvdisplay

$ sudo vgscan
$ sudo vgs
$ sudo vgdisplay

$ sudo lvscan
$ sudo lvs
$ sudo lvdisplay
</code></pre></div><p>如果安装系统时没有默认安装 LVM 工具包，可以通过下面的命令安装它们：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt update
$ sudo apt install lvm2
</code></pre></div><p>接下来我们通过例子来演示如何使用 LVM 来一步步的创建出逻辑卷(LV)，然后在 LV 上创建文件系统并挂载到 Linux 系统中。</p>
<h3 id="使用-gdisk-对物理磁盘进行分区">使用 gdisk 对物理磁盘进行分区<a hidden class="anchor" aria-hidden="true" href="#使用-gdisk-对物理磁盘进行分区">#</a></h3>
<p>目前常见的磁盘分区格式有两种，MBR 分区和 GPT 分区。</p>
<p>MBR 分区，MBR 的意思是 &ldquo;主引导记录&rdquo;。MBR 最大支持 2TB 容量，在容量方面存在着极大的瓶颈。</p>
<p>GPT 分区，GPT 意为 GUID 分区表，它支持的磁盘容量比 MBR 大得多。这是一个正逐渐取代 MBR 的新标准，它是由 UEFI 辅住而形成的，将来 UEFI 用于取代老旧的 BIOS，而 GPT 则取代老旧的 MBR。</p>
<p>使用 fdisk 工具创建 MBR 磁盘分区，而 gdisk 是 Linux 系统中 GPT 格式的磁盘分区管理工具。</p>
<p>假设我们的 Linux 系统中增加了一块新的磁盘，系统对应的设备名为 /dev/sdb，下面我们通过 gdisk 命令对这个磁盘进行分区。</p>
<p>在用 gdisk 命令对磁盘分区前，我们先用 parted 命令查看 /dev/sdb 当前的分区情况：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo parted /dev/sdb print
</code></pre></div><p>下面通过 gdisk 命令创建分区：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo gdisk /dev/sdb
</code></pre></div><p>通过 p 命令可以查看磁盘当前的状态：输出中的前几行是磁盘的基本信息，比如总大小，一共有多少个扇区(sector)，每个扇区的大小，当前剩余的空间等等。</p>
<p>然后是已经存在的分区信息：</p>
<ul>
<li><strong>第一列 Number</strong> 显示了分区的编号，比如 1 号指 /dev/sdb1。</li>
<li><strong>第二列 Start</strong> 表示磁盘分区的起始位置。</li>
<li><strong>第三列 End</strong> 表示磁盘分区的结束位置。</li>
<li><strong>第四列 Size</strong> 显示分区的容量。</li>
<li><strong>第五列 Code 和第六列 Name</strong> 显示分区类型的 ID和名称，比如 Linux filesystem 为 8300，Linux swap 为 8200，Linux LVM 为 8e00。</li>
</ul>
<p>通过 n 命令来创建新分区：</p>
<p>分区编号和开始/结束的扇区都直接通过回车选择默认值，这样所有的磁盘空间都划分到了一个分区中，然后输入 8e00 说明我们要创建的分区类型为 Linux LVM。最后输入 w 命令并确认执行分区操作。分区成功后可通过 p 命令查看我们创建的分区的信息。</p>
<h3 id="创建物理卷-pv">创建物理卷 PV<a hidden class="anchor" aria-hidden="true" href="#创建物理卷-pv">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># pvcreate DEVICE</span>
</code></pre></div><p>现在我们可以基于磁盘分区 /dev/sdb1 来创建 LVM 物理卷(LV)，可以通过 pvcreate 命令来完成：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo pvcreate /dev/sdb1
</code></pre></div><p>此时 /dev/sdb1 已经完成了从磁盘分区到 PV 的华丽转身！注意上面的命令，<strong>磁盘分区被直接转换成了 PV</strong>，连名称都没有变化！我们可以通过 pvs 命令查看 /dev/sdb1，目前它还没有被加入到 VG 中。</p>
<h3 id="创建卷组-vg">创建卷组 VG<a hidden class="anchor" aria-hidden="true" href="#创建卷组-vg">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># vgcreate &lt;volume_group&gt; &lt;physical_volume1&gt; &lt;physical_volume2&gt; ...</span>
</code></pre></div><p>基于一个或多个 PV，可以创建 VG。我们使用刚才创建的 PV /dev/sdb1 来创建一个名称为 nickvg 的 VG：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo vgcreate -s 32G nickvg /dev/sdb1
</code></pre></div><p><strong>注意 vgcreate 命令中的 -s 选项，它指定了 PE(Physical Extent) 的大小</strong>。可以通 vgs 命令观察 VG 的信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo vgs nickvg
</code></pre></div><p>如果目标 VG 已经存在，则使用 vgextend 把 PV 加入到 VG 中即可。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># vgextend &lt;卷组名&gt; &lt;物理卷&gt;</span>
</code></pre></div><h3 id="创建逻辑卷-lv">创建逻辑卷 LV<a hidden class="anchor" aria-hidden="true" href="#创建逻辑卷-lv">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># lvcreate -L &lt;卷大小&gt; &lt;卷组名&gt; -n &lt;卷名&gt;</span>
</code></pre></div><p>有了 VG 就可以创建逻辑卷 LV 了，lvcreate 命令用来创建 LV，让我们在前面创建的 nickvg 上创建名称为 nicklv00 的 LV：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo lvcreate -L 15G -n nicklv00 nickvg
</code></pre></div><p><strong>选项 -L 指定新建 LV 的容量</strong>，这里是 15G；选项 -n 则指定新建 LV 的名称，这里为 nicklv00。可以通过 lvs 命令观察 LV 的信息，注意需要同时指出 LV 所在的 VG：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo lvs nickvg/nicklv00
</code></pre></div><p>如果你想让要创建的逻辑卷拥有卷组（VG）的所有未使用空间，请使用以下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># lvcreate -l +100%FREE  &lt;volume_group&gt; -n &lt;logical_volume&gt;</span>
</code></pre></div><h3 id="格式化逻辑卷创建文件系统">格式化逻辑卷(创建文件系统)<a hidden class="anchor" aria-hidden="true" href="#格式化逻辑卷创建文件系统">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># mkfs.&lt;类型&gt; /dev/mapper/&lt;卷组名&gt;-&lt;卷名&gt;</span>
<span style="color:#75715e"># mount /dev/mapper/&lt;卷组名&gt;-&lt;卷名&gt; &lt;挂载点&gt;</span>
</code></pre></div><p>当我们创建 LV nickvg/nicklv00 时，其实是创建了名称为 /dev/nickvg/nicklv00 的设备文件。</p>
<p>现在你的逻辑卷应该已经在<code>/dev/mapper/</code>和<code>/dev/YourVolumeGroupName</code>中了。</p>
<p>现在我们来格式化这个逻辑卷(在该 LV 上创建文件系统)，目标为比较常见的 ext4 格式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo mkfs.ext4 /dev/nickvg/nicklv00
</code></pre></div><p>然后创建个目录，比如 /home/doc，并把新建的文件系统挂载到这个目录上：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo mkdir /home/doc
$ sudo mount /dev/nickvg/nicklv00 /home/doc
</code></pre></div><p>最后可以通过 df 命令查看这个文件系统的使用情况。</p>
<h3 id="开机自动挂载">开机自动挂载<a hidden class="anchor" aria-hidden="true" href="#开机自动挂载">#</a></h3>
<p>编辑 /etc/fstab 文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo vim /etc/fstab
</code></pre></div><p>把下面的行添加的文件末尾并保存文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">/dev/mapper/nickvg-nicklv00 /home/doc       ext4    defaults       <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">2</span>
</code></pre></div><h3 id="调整逻辑卷httpswikiarchlinuxorgtitlelvm_e7ae80e4bd93e4b8ade69687e980bbe8be91e58db7"><a href="https://wiki.archlinux.org/title/LVM_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E9%80%BB%E8%BE%91%E5%8D%B7">调整逻辑卷</a><a hidden class="anchor" aria-hidden="true" href="#调整逻辑卷httpswikiarchlinuxorgtitlelvm_e7ae80e4bd93e4b8ade69687e980bbe8be91e58db7">#</a></h3>
<p><strong>同时缩小逻辑卷和其文件系统</strong></p>
<blockquote>
<p>注意： 只有ext2，ext3，ext4，ReiserFS和 XFS 文件系统支持以下操作。</p>
</blockquote>
<p>将<code>MyVolGroup</code>组中的逻辑卷<code>mediavol</code>扩大10GiB，并同时扩大其文件系统：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># lvresize -L +10G --resizefs MyVolGroup/mediavol</span>
</code></pre></div><p>将<code>MyVolGroup</code>组中的逻辑卷<code>mediavol</code>大小调整为15GiB，并同时调整其文件系统：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># lvresize -L 15G --resizefs MyVolGroup/mediavol</span>
</code></pre></div><p>将卷组中的所有剩余空间分配给<code>mediavol</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># lvresize -l +100%FREE --resizefs MyVolGroup/mediavol</span>
</code></pre></div><h3 id="重命名卷">重命名卷<a hidden class="anchor" aria-hidden="true" href="#重命名卷">#</a></h3>
<p><strong>重命名卷组</strong></p>
<p>要重命名一个卷组，请使用vgrename(8)命令。</p>
<p>可使用下面的任意一条命令将卷组<code>vg02</code>重命名为<code>my_volume_group</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># vgrename /dev/vg02 /dev/my_volume_group</span>
<span style="color:#75715e"># vgrename vg02 my_volume_group</span>
</code></pre></div><p><strong>重命名逻辑卷</strong></p>
<p>要重命名一个逻辑卷，请使用lvrename(8)命令。</p>
<p>可使用下面的任意一条命令将<code>vg02</code>组中的逻辑卷<code>lvold</code>重命名为<code>lvnew</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># lvrename /dev/vg02/lvold /dev/vg02/lvnew</span>
<span style="color:#75715e"># lvrename vg02 lvold lvnew</span>
</code></pre></div><h3 id="移除逻辑卷">移除逻辑卷<a hidden class="anchor" aria-hidden="true" href="#移除逻辑卷">#</a></h3>
<p><strong>警告：</strong> 在移除逻辑卷之前，请先备份好数据以免丢失！</p>
<p>首先，找到你所要移除的逻辑卷的名称。你可以使用以下命令来查看系统的所有逻辑卷：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># lvs</span>
</code></pre></div><p>接下来，找到你所要移除的逻辑卷的挂载点</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ lsblk
</code></pre></div><p>并卸载它：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># umount /&lt;mountpoint&gt;</span>
</code></pre></div><p>最后，使用以下命令来移除逻辑卷：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># lvremove &lt;volume_group&gt;/&lt;logical_volume&gt;</span>
</code></pre></div><p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># lvremove VolGroup00/lvolhome</span>
</code></pre></div><p>请输入<code>y</code>来确定你要执行移除逻辑卷操作。</p>
<p>此外，请不要忘了更新<code>/etc/fstab</code>。</p>
<p>你可以再次使用<code>lvs</code>命令来确认你的逻辑卷已被移除。</p>
<h3 id="lvm-快照httpswwwcnblogscomsparkdevp10232567html"><a href="https://www.cnblogs.com/sparkdev/p/10232567.html">LVM 快照</a><a hidden class="anchor" aria-hidden="true" href="#lvm-快照httpswwwcnblogscomsparkdevp10232567html">#</a></h3>
<p>LVM 机制还提供了对 LV 做快照的功能，也就是说可以<strong>给文件系统做一个备份</strong>，这也是设计 LVM 快照的主要目的。LVM 的快照功能采用写时复制技术(Copy-On-Write，COW)，这比传统的备份技术的效率要高很多。创建快照时不用停止服务，就可以对数据进行备份。说明：LVM 还支持 thin 类型的快照，但是本文中的快照都是指 COW 类型的快照。</p>
<p>LVM 采用的写时复制，是指当 LVM 快照创建的时候，仅创建到实际数据的 inode 的硬链接(hark-link)而已。只要实际的数据没有改变，快照就只包含指向数据的 inode 的指针，而非数据本身。快照会跟踪原始卷中块的改变，一旦你更改了快照对应的文件或目录，这个时候原始卷上将要改变的数据会在改变之前拷贝到快照预留的空间。</p>
<p><strong>LVM 快照的原理</strong></p>
<p>创建快照实际上也是创建了一个逻辑卷，只不过该卷的属性与普通逻辑卷的属性有些不一样。我们可以通过下图来理解快照数据卷(图中的实线框表示快照区域，虚线框表示文件系统)：</p>
<p><img loading="lazy" src="/Distributions/LVMSnapshot.png" alt=""  />
</p>
<p>左图为最初创建的快照数据卷状况，LVM 会预留一个区域 (比如左图的左侧三个 PE 区块) 作为数据存放处。 此时快照数据卷内并没有任何数据，而快照数据卷与源数据卷共享所有的 PE 数据， 因此你会看到快照数据卷的内容与源数据卷中的内容是一模一样的。 等到系统运行一阵子后，假设 A 区域的数据被更新了(上面右图所示)，则更新前系统会将该区域的数据移动到快照数据卷中， 所以在右图的快照数据卷中被占用了一块 PE 成为 A，而其他 B 到 I 的区块则还是与源数据卷共享！</p>
<p>由於快照区与原本的 LV 共享很多 PE 区块，因此快照区与被快照的 LV 必须要在同一个 VG 上头，下面两点非常重要：</p>
<ul>
<li>VG中需要预留存放快照本身的空间，不能全部被占满。</li>
<li>快照所在的 VG 必须与被备份的 LV 的 VG 相同，否则创建快照会失败。</li>
</ul>
<p><strong>创建 LVM 快照</strong></p>
<p>其实快照就是一个特殊类型的数据卷，所以创建快照的命令和创建数据卷的命令相同，也是 lvcreate：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># lvcreate --size 100M --snapshot --name snap01 /dev/vg0/lv</span>
</code></pre></div><p>此时如果把 LV snap01 挂载到系统中，里面的内容和 LV /dev/vg0/lv 中的内容是一样的。</p>
<p>创建的快照的大小可以比源数据卷小，但是当源数据卷中的数据更新过多时会导致快照容量不足而引起的错误并丢失数据。如上你可以修改少于100M的数据，直到该快照逻辑卷空间不足为止。</p>
<p>创建快照后，如果源数据卷中的文件被更新了，快照系统中则保存着其创建快照时的版本。</p>
<p><strong>还原部分数据</strong></p>
<p>如果我们明确的知道需要还原某个文件，可以挂载快照数据卷，直接拷贝其中旧版本的文件即可。</p>
<p><strong>合并快照(merge snapshot)</strong></p>
<p>要将逻辑卷卷&rsquo;lv&rsquo; 恢复到创建快照&rsquo;snap01&rsquo;时的状态，即还原整个数据卷上的数据，请使用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># lvconvert --merge /dev/vg0/snap01</span>
</code></pre></div><p>如果逻辑卷处于活动状态，则在下次重新启动时将进行合并（merging）(合并（merging）甚至可在LiveCD中进行)。</p>
<p><strong>注意：</strong> 合并后快照将被删除。</p>
<p>可以拍摄多个快照，每个快照都可以任意与对应的逻辑卷合并。</p>
<p>快照可以被挂载，并可用<strong>dd</strong>或者<strong>tar</strong>备份。使用<strong>dd</strong>备份的快照的大小为拍摄快照后对应逻辑卷中变更过文件的大小。 要使用备份，只需创建并挂载一个快照，并将备份写入或解压到其中。再将快照合并到对应逻辑卷即可。</p>
<p>快照主要用于提供一个文件系统的拷贝，以用来备份; 比起直接备份分区，使用快照备份可以提供一个更符合原文件系统的镜像。</p>
<h2 id="zfshttpslinuxcnarticle-10034-1html"><a href="https://linux.cn/article-10034-1.html">ZFS</a><a hidden class="anchor" aria-hidden="true" href="#zfshttpslinuxcnarticle-10034-1html">#</a></h2>
<h3 id="历史">历史<a hidden class="anchor" aria-hidden="true" href="#历史">#</a></h3>
<p>ZFS 是由 Matthew Ahrens 和 Jeff Bonwick 在 2001 年开发的。ZFS 是作为 <a href="http://en.wikipedia.org/wiki/Sun_Microsystems">Sun MicroSystem</a> 公司的 <a href="http://en.wikipedia.org/wiki/Opensolaris">OpenSolaris</a> 的下一代文件系统而设计的。在 2008 年，ZFS 被移植到了 FreeBSD 。同一年，一个移植 <a href="https://zfsonlinux.org/">ZFS on Linux</a> 的项目也启动了。然而，由于 ZFS 是<a href="https://en.wikipedia.org/wiki/Common_Development_and_Distribution_License">CDDL</a> 许可的，它和 <a href="https://en.wikipedia.org/wiki/GNU_General_Public_License">GPL</a> 不兼容，因此不能将它迁移到 Linux 内核中。为了解决这个问题，绝大多数 Linux 发行版提供了一些方法来安装 ZFS　。</p>
<p>在甲骨文公司收购太阳微系统公司之后不久，OpenSolaris 就闭源了，这使得 ZFS 的之后的开发也变成闭源的了。许多 ZFS 开发者对这件事情非常不满。三分之二的 ZFS 核心开发者，包括 Ahrens 和 Bonwick，因为这个决定而离开了甲骨文公司。他们加入了其它公司，并于 2013 年 9 月创立了 <a href="http://www.open-zfs.org/wiki/Main_Page">OpenZFS</a> 这一项目。该项目引领着 ZFS 的开源开发。</p>
<p>让我们回到上面提到的许可证问题上。既然 OpenZFS 项目已经和 Oracle 公司分离开了，有人可能好奇他们为什么不使用和 GPL 兼容的许可证，这样就可以把它加入到 Linux 内核中了。根据 <a href="http://www.open-zfs.org/wiki/FAQ#Do_you_plan_to_release_OpenZFS_under_a_license_other_than_the_CDDL.3F">OpenZFS 官网</a> 的介绍，更改许可证需要联系所有为当前 OpenZFS 实现贡献过代码的人（包括初始的公共 ZFS 代码以及 OpenSolaris 代码），并得到他们的许可才行。这几乎是不可能的（因为一些贡献者可能已经去世了或者很难找到），因此他们决定保留原来的许可证。</p>
<h3 id="特性httpslinuxcnarticle-7422-1html"><a href="https://linux.cn/article-7422-1.html">特性</a><a hidden class="anchor" aria-hidden="true" href="#特性httpslinuxcnarticle-7422-1html">#</a></h3>
<p>正如前面所说过的，ZFS 是一个先进的文件系统。因此，它有一些有趣的特性。</p>
<h4 id="存储池-1">存储池<a hidden class="anchor" aria-hidden="true" href="#存储池-1">#</a></h4>
<p>与大多数文件系统不同，ZFS 结合了文件系统和卷管理器的特性。这意味着，它与其他文件系统不同，ZFS 可以创建跨越一系列硬盘或池的文件系统。不仅如此，你还可以通过添加硬盘来增大池的存储容量。ZFS 可以进行分区和格式化。</p>
<p><img loading="lazy" src="/Distributions/231710te5zjh04sahk0zep.png" alt="ZFS 存储池"  />
</p>
<h4 id="写时拷贝">写时拷贝<a hidden class="anchor" aria-hidden="true" href="#写时拷贝">#</a></h4>
<p>Copy-on-write 是另一个有趣并且很酷的特性。在大多数文件系统上，当数据被重写时，它将永久丢失。而在 ZFS 中，新数据会写到不同的块。写完成之后，更新文件系统元数据信息，使之指向新的数据块（LCTT 译注：更新之后，原数据块成为磁盘上的垃圾，需要有对应的垃圾回收机制）。这确保了如果在写新数据的时候系统崩溃（或者发生其它事，比如突然断电），那么原数据将会保存下来。这也意味着，在系统发生崩溃之后，不需要运行 <a href="https://en.wikipedia.org/wiki/Fsck">fsck</a> 来检查和修复文件系统。</p>
<h4 id="快照">快照<a hidden class="anchor" aria-hidden="true" href="#快照">#</a></h4>
<p>写时拷贝使得 ZFS 有了另一个特性：snapshots。ZFS 使用快照来跟踪文件系统中的更改。快照包含文件系统的原始版本（文件系统的一个只读版本），实时文件系统则包含了自从快照创建之后的任何更改。没有使用额外的空间。因为新数据将会写到实时文件系统新分配的块上。如果一个文件被删除了，那么它在快照中的索引也会被删除。所以，快照主要是用来跟踪文件的更改，而不是文件的增加和创建。</p>
<p>快照可以挂载成只读的，以用来恢复一个文件的过去版本。实时文件系统也可以回滚到之前的快照。回滚之后，自从快照创建之后的所有更改将会丢失。</p>
<h4 id="数据完整性验证和自动修复">数据完整性验证和自动修复<a hidden class="anchor" aria-hidden="true" href="#数据完整性验证和自动修复">#</a></h4>
<p>当向 ZFS 写入新数据时，会创建该数据的校验和。在读取数据的时候，使用校验和进行验证。如果前后校验和不匹配，那么就说明检测到了错误，然后，ZFS 会尝试自动修正错误。</p>
<h4 id="raid-z">RAID-Z<a hidden class="anchor" aria-hidden="true" href="#raid-z">#</a></h4>
<p>ZFS 不需要任何额外软件或硬件就可以处理 RAID（磁盘阵列）。毫不奇怪，因为 ZFS 有自己的 RAID 实现：RAID-Z 。RAID-Z 是 RAID-5 的一个变种，不过它克服了 RAID-5 的写漏洞：意外重启之后，数据和校验信息会变得不同步（LCTT 译注：RAID-5 的条带在正写入数据时，如果这时候电源中断，那么奇偶校验数据将跟该部分数据不同步，因此前边的写无效；RAID-Z 用了 “可变宽的 RAID 条带” 技术，因此所有的写都是全条带写入）。为了使用基本级别的 RAID-Z（RAID-Z1），你需要至少三块磁盘，其中两块用来存储数据，另外一块用来存储奇偶校验信息。而 RAID-Z2 需要至少两块磁盘存储数据以及两块磁盘存储校验信息。RAID-Z3 需要至少两块磁盘存储数据以及三块磁盘存储校验信息。另外，只能向 RAID-Z 池中加入偶数倍的磁盘，而不能是奇数倍的。</p>
<h4 id="巨大的存储潜力">巨大的存储潜力<a hidden class="anchor" aria-hidden="true" href="#巨大的存储潜力">#</a></h4>
<p>创建 ZFS 的时候，它是作为<a href="https://web.archive.org/web/20060428092023/http://www.sun.com/2004-0914/feature/">最后一个文件系统</a>而设计的 。那时候，大多数文件系统都是 64 位的，ZFS 的创建者决定直接跳到 128 位，等到将来再来证明这是对的。这意味着 ZFS 的容量大小是 32 位或 64 位文件系统的 1600 亿亿倍。事实上，Jeff Bonwick（其中一个创建者）说：“完全填满一个 128 位的存储池所需要的<a href="https://blogs.oracle.com/bonwick/128-bit-storage:-are-you-high">能量</a>，从字面上讲，比煮沸海洋需要的还多。”</p>
<h3 id="如何安装-zfs">如何安装 ZFS？<a hidden class="anchor" aria-hidden="true" href="#如何安装-zfs">#</a></h3>
<p>如果你想立刻使用 ZFS（开箱即用），那么你需要安装 FreeBSD 或一个<a href="https://wiki.illumos.org/display/illumos/Distributions">使用 illumos 内核的操作系统</a>。<a href="https://wiki.illumos.org/display/illumos/illumos+Home">illumos</a> 是 OpenSolaris 内核的一个克隆版本。</p>
<p>事实上，支持 ZFS 是一些有经验的 Linux 用户选择 BSD 的主要原因。</p>
<p>如果你想在 Linux 上尝试 ZFS，那么只能在存储文件系统上使用。据我所知，没有任何 Linux 发行版可以在根目录上安装 ZFS，实现开箱即用。如果你对在 Linux 上尝试 ZFS 感兴趣，那么 <a href="https://zfsonlinux.org/">ZFS on Linux 项目</a> 上有大量的教程可以指导你怎么做。</p>
<h3 id="在-ubuntu-上使用-zfshttpslinuxcnarticle-9346-1html"><a href="https://linux.cn/article-9346-1.html">在 Ubuntu 上使用 ZFS</a><a hidden class="anchor" aria-hidden="true" href="#在-ubuntu-上使用-zfshttpslinuxcnarticle-9346-1html">#</a></h3>
<p>如果您正在考虑将 ZFS 用于您的超高速 NVMe SSD，这可能不是一个最佳选择。 它比别的文件系统要慢，不过，这完全没有问题， 它旨在<strong>存储大量的数据并保持安全</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt-get install zfsutils-linux
</code></pre></div><h4 id="创建池">创建池<a hidden class="anchor" aria-hidden="true" href="#创建池">#</a></h4>
<p>在 ZFS 中，池大致相当于 RAID 。 它们很灵活且易于操作。</p>
<h5 id="raid0">RAID0<a hidden class="anchor" aria-hidden="true" href="#raid0">#</a></h5>
<p>RAID0 只是把你的硬盘集中到一个池子里面，就像一个巨大的驱动器一样。 它可以提高你的驱动器速度，（LCTT 译注：数据条带化后，并行访问，可以提高文件读取速度）但是如果你的驱动器有损坏，你可能会失丢失数据。</p>
<p>在计算机数据存储中，数据条带化是一种对逻辑顺序数据（例如文件）进行分段的技术，以便将连续的段存储在不同的物理存储设备上。</p>
<p>要使用 ZFS 实现 RAID0，只需创建一个普通的池。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo zpool create your-pool /dev/sdc /dev/sdd
</code></pre></div><h5 id="raid1镜像">RAID1（镜像）<a hidden class="anchor" aria-hidden="true" href="#raid1镜像">#</a></h5>
<p>您可以在 ZFS 中使用 <code>mirror</code> 关键字来实现 RAID1 功能。 RAID1 会创建一个一对一的驱动器副本。 这意味着您的数据一直在备份。 它也提高了性能。 当然，你将一半的存储空间用于了复制。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo zpool create your-pool mirror /dev/sdc /dev/sdd
</code></pre></div><h5 id="raid5raidz1">RAID5/RAIDZ1<a hidden class="anchor" aria-hidden="true" href="#raid5raidz1">#</a></h5>
<p>ZFS 将 RAID5 功能实现为 RAIDZ1。 RAID5 要求驱动器至少是 3 个。并允许您通过将备份奇偶校验数据写入驱动器空间的 1/n（n 是驱动器数），留下的是可用的存储空间。 如果一个驱动器发生故障，阵列仍将保持联机状态，但应尽快更换发生故障的驱动器（LCTT 译注：与原文翻译略有不同，原文是驱动器的数目是三的倍数，根据 wiki， RAID5 至少需要 3 块驱动器，也可以从下面的命令中猜测)。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo zpool create your-pool raidz1 /dev/sdc /dev/sdd /dev/sde
</code></pre></div><h5 id="raid6raidz2">RAID6/RAIDZ2<a hidden class="anchor" aria-hidden="true" href="#raid6raidz2">#</a></h5>
<p>RAID6 与 RAID5 几乎完全相同，但它至少需要四个驱动器。 它将奇偶校验数据加倍，最多允许两个驱动器损坏，而不会导致阵列关闭（LCTT 译注：这里也与原文略有出入，原文是驱动器的数目是四的倍数，根据 wiki ，RAID6 至少需要四个驱动器)。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo zpool create your-pool raidz2 /dev/sdc /dev/sdd /dev/sde /dev/sdf
</code></pre></div><h5 id="raid10条带化镜像">RAID10（条带化镜像）<a hidden class="anchor" aria-hidden="true" href="#raid10条带化镜像">#</a></h5>
<p>RAID10 旨在通过数据条带化提高存取速度和数据冗余来成为一个两全其美的解决方案。 你至少需要四个驱动器，但只能使用一半的空间。 您可以通过在同一个池中创建两个镜像来创建 RAID10 中的池（LCTT 译注：这里也与原文略有出入，原文是驱动器的数目是四的倍数，根据 wiki， RAID10 至少需要四个驱动器）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo zpool create your-pool mirror /dev/sdc /dev/sdd mirror /dev/sde /dev/sdf
</code></pre></div><h4 id="池的操作">池的操作<a hidden class="anchor" aria-hidden="true" href="#池的操作">#</a></h4>
<p>还有一些管理工具，一旦你创建了你的池，你就必须使用它们来操作。 首先，检查你的池的状态。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo zpool status
</code></pre></div><h5 id="更新">更新<a hidden class="anchor" aria-hidden="true" href="#更新">#</a></h5>
<p>当你更新 ZFS 时，你也需要更新你的池。 当您检查它们的状态时，您的池会通知您任何更新。 要更新池，请运行以下命令。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo zpool upgrade your-pool
</code></pre></div><p>你也可以更新全部池。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo zpool upgrade -a
</code></pre></div><h5 id="添加驱动器">添加驱动器<a hidden class="anchor" aria-hidden="true" href="#添加驱动器">#</a></h5>
<p>您也可以随时将驱动器添加到池中。 告诉 <code>zpool</code> 池的名称和驱动器的位置，它会处理好一切。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo zpool add your-pool /dev/sdx
</code></pre></div><h3 id="实例-1">实例<a hidden class="anchor" aria-hidden="true" href="#实例-1">#</a></h3>
<p>使用两块硬盘上的等容量分区建立 raid 1。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ls -l /dev/disk/by-id
usb-JMicron_Generic_DISK00_0123456789ABCDEF-0:0-part1 -&gt; ../../sdb1
usb-JMicron_Generic_DISK01_0123456789ABCDEF-0:1-part2 -&gt; ../../sdc2
$ sudo zpool create -f -o ashift<span style="color:#f92672">=</span><span style="color:#ae81ff">12</span> -o cachefile<span style="color:#f92672">=</span>/etc/zfs/zpool.cache -O compression<span style="color:#f92672">=</span>lz4 -O xattr<span style="color:#f92672">=</span>sa -O relatime<span style="color:#f92672">=</span>on -O acltype<span style="color:#f92672">=</span>posixacl -O dedup<span style="color:#f92672">=</span>off -m none dpool mirror usb-JMicron_Generic_DISK00_0123456789ABCDEF-0:0-part1 usb-JMicron_Generic_DISK01_0123456789ABCDEF-0:1-part2
$ sudo zfs create -o mountpoint<span style="color:#f92672">=</span>none -o canmount<span style="color:#f92672">=</span>off dpool/DATA
$ sudo zfs create -o mountpoint<span style="color:#f92672">=</span>/home/kurome/DataPool dpool/DATA/important
$ sudo zpool export dpool
$ sudo zpool import dpool
</code></pre></div><h2 id="systemd">Systemd<a hidden class="anchor" aria-hidden="true" href="#systemd">#</a></h2>
<h3 id="linux-pid-1-和-systemdhttpscoolshellcnarticles17998htmlsysv_init"><a href="https://coolshell.cn/articles/17998.html#SysV_Init">LINUX PID 1 和 SYSTEMD</a><a hidden class="anchor" aria-hidden="true" href="#linux-pid-1-和-systemdhttpscoolshellcnarticles17998htmlsysv_init">#</a></h3>
<p>要说清 Systemd，得先从Linux操作系统的启动说起。Linux 操作系统的启动首先从 BIOS 开始，然后由 Boot Loader 载入内核，并初始化内核。内核初始化的最后一步就是启动 init 进程。这个进程是系统的第一个进程，PID 为 1，又叫超级进程，也叫根进程。它负责产生其他所有用户进程。所有的进程都会被挂在这个进程下，如果这个进程退出了，那么所有的进程都被 kill 。如果一个子进程的父进程退了，那么这个子进程会被挂到 PID 1 下面。（注：PID 0 是内核的一部分，主要用于内进换页，参看：<a href="https://en.wikipedia.org/wiki/Process_identifier">Process identifier</a>）</p>
<h4 id="sysv-init">SysV Init<a hidden class="anchor" aria-hidden="true" href="#sysv-init">#</a></h4>
<p>PID 1 这个进程非常特殊，其主要就任务是把整个操作系统带入可操作的状态。比如：启动 UI – Shell 以便进行人机交互，或者进入 X 图形窗口。传统上，PID 1 和传统的 Unix System V 相兼容的，所以也叫 <code>sysvinit</code>，这是使用得最悠久的 init 实现。Unix System V 于1983年 release。</p>
<p>在 <code>sysvint</code> 下，有好几个运行模式，又叫 <code>runlevel</code>。比如：常见的 3 级别指定启动到多用户的字符命令行界面，5 级别指定启起到图形界面，0 表示关机，6 表示重启。其配置在 <code>/etc/inittab</code> 文件中。</p>
<p>与此配套的还有 <code>/etc/init.d/</code> 和 <code>/etc/rc[X].d</code>，前者存放各种进程的启停脚本（需要按照规范支持 <code>start</code>，<code>stop</code>子命令），后者的 X 表示不同的 runlevel 下相应的后台进程服务，如：<code>/etc/rc3.d</code> 是 runlevel=3 的。 里面的文件主要是 link 到  <code>/etc/init.d/</code> 里的启停脚本。其中也有一定的命名规范：S 或 K 打头的，后面跟一个数字，然后再跟一个自定义的名字，如：<code>S01rsyslog</code>，<code>S02ssh</code>。S 表示启动，K表示停止，数字表示执行的顺序。</p>
<h4 id="upstart">UpStart<a hidden class="anchor" aria-hidden="true" href="#upstart">#</a></h4>
<p>Unix 和 Linux 在 <code>sysvint</code> 运作多年后，大约到了2006年的时候，Linux内核进入2.6时代，Linux有了很多更新。并且，Linux开始进入桌面系统，而桌面系统和服务器系统不一样的是，桌面系统面临频繁重启，而且，用户会非常频繁的使用硬件的热插拔技术。于是，这些新的场景，让 <code>sysvint</code> 受到了很多挑战。</p>
<p>比如，打印机需要CUPS等服务进程，但是如果用户没有打机印，启动这个服务完全是一种浪费，而如果不启动，如果要用打印机了，就无法使用，因为<code>sysvint</code> 没有自动检测的机制，它只能一次性启动所有的服务。另外，还有网络盘挂载的问题。在 <code>/etc/fstab</code> 中，负责硬盘挂载，有时候还有网络硬盘（NFS 或 iSCSI）在其中，但是在桌面机上，有很可能开机的时候是没有网络的， 于是网络硬盘都不可以访问，也无法挂载，这会极大的影响启动速度。<code>sysvinit</code> 采用 <code>netdev</code> 的方式来解决这个问题，也就是说，需要用户自己在 <code>/etc/fstab</code> 中给相应的硬盘配置上 <code>netdev</code> 属性，于是 <code>sysvint</code> 启动时不会挂载它，只有在网络可用后，由专门的 <code>netfs</code> 服务进程来挂载。这种管理方式比较难以管理，也很容易让人掉坑。</p>
<p>所以，Ubuntu 开发人员在评估了当时几个可选的 init 系统后，决定重新设计这个系统，于是，这就是我们后面看到的 <code>upstart</code> 。 <code>upstart</code> 基于事件驱动的机制，把之前的完全串行的同步启动服务的方式改成了由事件驱动的异步的方式。比如：如果有U盘插入，<code>udev</code> 得到通知，<code>upstart</code> 感知到这个事件后触发相应的服务程序，比如挂载文件系统等等。因为使用一个事件驱动的玩法，所以，启动操作系统时，很多不必要的服务可以不用启动，而是等待通知，lazy 启动。而且事件驱动的好处是，可以并行启动服务，他们之间的依赖关系，由相应的事件通知完成。</p>
<p>upstart 有着很不错的设计，其中最重要的两个概念是 Job 和 Event。</p>
<p><strong>Job</strong> 有一般的Job，也有service的Job，并且，<code>upstart</code> 管理了整个 Job 的生命周期，比如：Waiting, Starting, pre-Start, Spawned, post-Start, Running, pre-Stop, Stopping, Killed, post-Stop等等，并维护着这个生命周期的状态机。</p>
<p><strong>Event</strong> 分成三类，<code>signal</code>, <code>method</code> 和 <code>hooks</code>。<code>signal</code> 就是异步消息，<code>method</code> 是同步阻塞的。<code>hooks</code> 也是同步的，但介于前面两者之间，发出hook事件的进程必须等到事件完成，但不检查是否成功。</p>
<p>但是，<code>upstart</code> 的事件非常复杂，也非常纷乱，各种各样的事件（事件没有归好类）导致有点凌乱。不过因为整个事件驱动的设计比之前的 <code>sysvinit</code> 来说好太多，所以，也深得欢迎。</p>
<h4 id="systemd-1">Systemd<a hidden class="anchor" aria-hidden="true" href="#systemd-1">#</a></h4>
<p>直到2010的有一天，一个在 RedHat工作的工程师 <a href="https://en.wikipedia.org/wiki/Lennart_Poettering">Lennart Poettering</a> 和 <a href="https://en.wikipedia.org/wiki/Kay_Sievers">Kay Sievers</a> ，开始引入了一个新的 <code>init</code> 系统—— <code>systemd</code>。这是一个非常非常有野心的项目，这个项目几乎改变了所有的东西，<code>systemd</code> 不但想取代已有的 init 系统，而且还想干更多的东西。</p>
<p>Lennart 同意 <code>upstart</code> 干的不错，代码质量很好，基于事件的设计也很好。但是他觉得 <code>upstart</code> 也有问题，其中最大的问题还是不够快，虽然 <code>upstart</code> 用事件可以达到一定的启动并行度，但是，本质上来说，这些事件还是会让启动过程串行在一起。  如：<code>NetworkManager</code> 在等 <code>D-Bus</code> 的启动事件，而 <code>D-Bus</code> 在等 <code>syslog</code> 的启动事件。</p>
<p>Lennart 认为，实现上来说，<code>upstart</code> 其实是在管理一个逻辑上的服务依赖树，但是这个服务依赖树在表现形式上比较简单，你只需要配置——“启动 B好了就启动A”或是“停止了A后就停止B”这样的规则。但是，Lennart 说，这种简单其实是有害的（this simplification is actually detrimental）。他认为，</p>
<ul>
<li>
<p>从一个系统管理的角度出来，他一开始会设定好整个系统启动的服务依赖树，但是这个系统管理员要人肉的把这个本来就非常干净的服务依整树给翻译成计算机看的懂的 Event/Action 形式，而且 Event/Action 这种配置方式是运行时的，所以，你需要运行起来才知道是什么样的。</p>
</li>
<li>
<p>Event逻辑从头到脚到处都是，这个事件扩大了运维的复杂度，还不如之前的 <code>sysvint</code>。 也就是说，当用户配置了 “启动 <code>D-Bus</code> 后请启动 <code>NetworkManager</code>”， 这个 <code>upstart</code> 可以干，但是反过来，如果，用户启动 <code>NetworkManager</code>，我们应该先去启动他的前置依赖 <code>D-Bus</code>，然而你还要配置相应的反向 Event。本来，我只需要配置一条依赖的，结果现在我要配置很多很多情况下的Event。</p>
</li>
<li>
<p>最后，<code>upstart</code> 里的 Event 的并不标准，很混乱，没有良好的定义。比如：既有，进程启动，运行，停止的事件，也有USB设备插入、可用、拔出的事件，还有文件系统设备being mounted、 mounted 和 umounted 的事件，还有AC电源线连接和断开的事件。你会发现，这进程启停的、USB的、文件系统的、电源线的事件，看上去长得很像， 但是没有被标准化抽像出来掉，因为绝大多数的事件都是三元组：start, condition, stop 。这种概念设计模型并没有在 <code>upstart</code> 中出现。因为 <code>upstart</code> 被设计为单一的事件，而忽略了逻辑依赖。</p>
</li>
</ul>
<p>当然，如果 <code>systemd</code> 只是解决 <code>upstart</code> 的问题，他就改造 <code>upstart</code> 就好了，但是 Lennart 的野心不只是想干个这样的事，他想干的更多。</p>
<p>首先，<code>systemd</code> 清醒的认识到了 init 进程的首要目标是要让用户快速的进入可以操作OS的环境，所以，这个速度一定要快，越快越好，所以，<code>systemd</code> 的设计理念就是两条：</p>
<ul>
<li>To start <strong>less</strong>.</li>
<li>And to start <strong>more</strong> in <em>parallel</em>.</li>
</ul>
<p>也就是说，按需启动，能不启动就不启动，如果要启动，能并行启动就并行启动，包括你们之间有依赖，我也并行启动。按需启动还好理解，那么，有依赖关系的并行启动，它是怎么做到的？这里，<code>systemd</code> 借鉴了 MacOS 的 <code>Launchd</code> 的玩法（在Youtube上有一个分享——<a href="https://www.youtube.com/watch?v=SjrtySM9Dns">Launchd: One Program to Rule them All</a>，在苹果的开源网站上也有相关的设计文档——<a href="https://developer.apple.com/library/content/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/Introduction.html">About Daemons and Services</a>）</p>
<p>要解决这些依赖性，systemd 需要解决好三种底层依赖—— Socket， D-Bus ，文件系统。</p>
<ul>
<li>
<p><strong>Socket依赖</strong>。如果服务C依赖于服务S的socket，那么就要先启动S，然后再启动C，因为如果C启动时找不到S的Socket，那么C就会失败。<code>systemd</code> 可以帮你在S还没有启动好的时候，建立一个socket，用来接收所有的C的请求和数据，并缓存之，一旦S全部启动完成，把systemd替换好的这个缓存的数据和Socket描述符替换过去。</p>
</li>
<li>
<p><strong>D-Bus依赖</strong>。<code>D-Bus</code> 全称 Desktop Bus，是一个用来在进程间通信的服务。除了用于用户态进程和内核态进程通信，也用于用户态的进程之前。现在，很多的现在的服务进程都用 <code>D-Bus</code> 而不是Socket来通信。比如：<code>NetworkManager</code> 就是通过 <code>D-Bus</code> 和其它服务进程通讯的，也就是说，如果一个进程需要知道网络的状态，那么就必需要通过 <code>D-Bus</code> 通信。<code>D-Bus</code> 支持 “Bus Activation”的特性。也就是说，A要通过 <code>D-Bus</code> 服务和B通讯，但是B没有启动，那么 <code>D-Bus</code> 可以把B起来，在B启动的过程中，<code>D-Bus</code> 帮你缓存数据。<code>systemd</code> 可以帮你利用好这个特性来并行启动 A 和 B。</p>
</li>
<li>
<p><strong>文件系统依赖</strong>。系统启动过程中，文件系统相关的活动是最耗时的，比如挂载文件系统，对文件系统进行磁盘检查（fsck），磁盘配额检查等都是非常耗时的操作。在等待这些工作完成的同时，系统处于空闲状态。那些想使用文件系统的服务似乎必须等待文件系统初始化完成才可以启动。<code>systemd</code> 参考了 <code>autofs</code> 的设计思路，使得依赖文件系统的服务和文件系统本身初始化两者可以并发工作。<code>autofs</code> 可以监测到某个文件系统挂载点真正被访问到的时候才触发挂载操作，这是通过内核 <code>automounter</code> 模块的支持而实现的。比如一个 <code>open()</code> 系统调用作用在某个文件系统上的时候，而这个文件系统尚未执行挂载，此时 <code>open()</code> 调用被内核挂起等待，等到挂载完成后，控制权返回给 <code>open()</code> 系统调用，并正常打开文件。这个过程和 <code>autofs</code> 是相似的。</p>
</li>
</ul>
<p>下图来自 Lennart 的演讲里的一页PPT，展示了不同 init 系统的启动。</p>
<p><img loading="lazy" src="/Distributions/boot.png" alt="img"  />
</p>
<p>除此之外，systemd 还在启动时管理好了一些下面的事。</p>
<p>用C语言取代传统的脚本式的启动。前面说过，<code>sysvint</code> 用 <code>/etc/rcX.d</code> 下的各种脚本启动。然而这些脚本中需要使用 <code>awk</code>, <code>sed</code>, <code>grep</code>, <code>find</code>, <code>xargs</code> 等等这些操作系统的命令，这些命令需要生成进程，生成进程的开销很大，关键是生成完这些进程后，这个进程就干了点屁大的事就退了。换句话说就是，我操作系统干了那么多事为你拉个进程起来，结果你就把个字串转成小写就退了，把我操作系统当什么了？</p>
<p>在正常的一个 <code>sysvinit</code> 的脚本里，可能会有成百上千个这样的命令。所以，慢死。因此，<code>systemd</code> 全面用 C 语言全部取代了。一般来说，<code>sysvinit</code> 下，操作系统启动完成后，用 <code>echo $$</code> 可以看到，pid 被分配到了上千的样子，而 <code>systemd</code> 的系统只是上百。</p>
<p>另外，systemd 是真正一个可以管住服务进程的——可以跟踪上服务进程所fork/exec出来的所有进程。</p>
<ul>
<li>
<p>我们知道， 传统 Unix/Linux 的 Daemon 服务进程的最佳实践基本上是这个样子的（具体过程可参看这篇文章“[SysV Daemon](<a href="http://0pointer.de/public/systemd-man/daemon.html#SysV">http://0pointer.de/public/systemd-man/daemon.html#SysV</a> Daemons)”）</p>
<ol>
<li>进程启动时，关闭所有的打开的文件描述符（除了标准描述符0,1,2），然后重置所有的信号处理。</li>
<li>调用 <code>fork()</code> 创建子进程，在子进程中 <code>setsid()</code>，然后父进程退出（为了后台执行）</li>
<li>在子进程中，再调用一次 <code>fork()</code>，创建孙子进程，确定没有交互终端。然后子进程退出。</li>
<li>在孙子进程中，把标准输入标准输出标准错误都连到 <code>/dev/null</code> 上，还要创建 pid 文件，日志文件，处理相关信号 ……</li>
<li>最后才是真正开始提供服务。</li>
</ol>
</li>
<li>
<p>在上面的这个过程中，服务进程除了两次 <code>fork</code> 外还会 <code>fork</code> 出很多很多的子进程（比如说一些Web服务进程，会根据用户的请求链接来 <code>fork</code> 子进程），这个进程树是相当难以管理的，因为，一旦父进程退出来了，子进程就会被挂到 PID 1下，所以，基本上来说，你无法通过服务进程自已给定的一个pid文件来找到所有的相关进程（这个对开发者的要求太高了），所以，在传统的方式下用脚本启停服务是相当相当的 Buggy 的，因为无法做对所有的服务生出来的子子孙孙做到监控。</p>
</li>
<li>
<p>为了解决这个问题，<code>upstart</code> 通过变态的 <code>strace</code> 来跟踪进程中的 <code>fork()</code> 和 <code>exec()</code> 或 <code>exit()</code> 等相关的系统调用。这种方法相当笨拙。 <code>systemd</code> 使用了一个非常有意思的玩法来 tracking 服务进程生出来的所有进程，那就是用 <code>cgroup</code> （我在 <a href="https://coolshell.cn/articles/17049.html">Docker 的基础技术“cgroup篇”</a>中讲过这个东西）。cgroup主要是用来管理进程组资源配额的事，所以，无论服务如何启动新的子进程，所有的这些相关进程都会同属于一个 <code>cgroup</code>，所以，<code>systemd</code> 只需要简单的去遍历一下相应的 <code>cgroup</code> 的那个虚文件系统目录下的文件，就可以正确的找到所有的相关进程，并将他们一一停止。</p>
</li>
</ul>
<p>另外，<code>systemd</code> 简化了整个 daemon 开发的过程：</p>
<ul>
<li>不需要两次 <code>fork()</code>，只需要实现服务本身的主逻辑就可以了。</li>
<li>不需要 <code>setsid()</code>，<code>systemd</code> 会帮你干</li>
<li>不需要维护 <code>pid文件</code>，<code>systemd</code> 会帮处理。</li>
<li>不需要管理日志文件或是使用<code>syslog</code>，或是处理<code>HUP</code>的日志reload信号。把日志打到 <code>stderr</code> 上，<code>systemd</code> 帮你管理。</li>
<li>处理 <code>SIGTERM</code> 信号，这个信号就是正确退出当前服务，不要做其他的事。</li>
<li>……</li>
</ul>
<p>除此之外，<code>systemd</code> 还能——</p>
<ul>
<li>自动检测启动的服务间有没有环形依赖。</li>
<li>内建 autofs 自动挂载管理功能。</li>
<li>日志服务。<code>systemd</code> 改造了传统的 syslog 的问题，采用二进制格式保存日志，日志索引更快。</li>
<li>快照和恢复。对当前的系统运行的服务集合做快照，并可以恢复。</li>
<li>……</li>
</ul>
<p>还有好多好多，他接管很多很多东西，于是就让很多人不爽了，因为他在干了很多本不属于 PID 1 的事。</p>
<h4 id="systemd-争论和八卦">Systemd 争论和八卦<a hidden class="anchor" aria-hidden="true" href="#systemd-争论和八卦">#</a></h4>
<p>于是 <code>systemd</code> 这个东西成了可能是有史以来口水战最多的一个开源软件了。<code>systemd</code> 饱受各种争议，最大的争议就是他破坏了 Unix 的设计哲学（相关的哲学可以读一下《<a href="https://book.douban.com/subject/1467587/">Unix编程艺术</a>》），干了一个大而全而且相当复杂的东西。当然，Lennart 并不同意这样的说法，他后来又写一篇blog “<a href="http://0pointer.de/blog/projects/the-biggest-myths.html">The Biggest Myths</a>”来解释 <code>systemd</code> 并不是这样的，大家可以前往一读。</p>
<p>这个争议大到什么样子呢？2014 年，Debian Linux 因为想准备使用 <code>systemd</code> 来作为标准的 init 守护进程来替换 <code>sysvinit</code> 。而围绕这个事的争论达到了空前的热度，争论中充满着仇恨，<code>systemd</code> 的支持者和反对者都在互相辱骂，导致当时 Debian 阵营开始分裂。还有人给 Lennart 发了死亡威胁的邮件，用比特币雇凶买杀手，扬言要取他的性命，在Youbute上传了侮辱他的歌曲，在IRC和各种社交渠道上给他发下流和侮辱性的消息。这已经不是争议了，而是一种不折不扣的仇恨！</p>
<p>于是，Lennart 在 <a href="https://plus.google.com/+LennartPoetteringTheOneAndOnly/posts/J2TZrTvu7vd">Google Plus 上发了贴子</a>，批评整个 Linux 开源社区和 Linus 本人。他大意说，</p>
<blockquote>
<p>这个社区太病态了，全是 ass holes，你们不停用各种手段在各种地方用不同的语言和方式来侮辱和漫骂我。我还是一个年轻人，我从来没有经历过这样的场面，但是今天我已经对这种场面很熟悉了。我有时候说话可能不准确，但是我不会像他样那样说出那样的话，我也没有被这些事影响，因为我脸皮够厚，所以，为什么我可以在如何大的反对声面前让 <code>systemd</code> 成功，但是，你们 Linux 社区太可怕了。你们里面的有精神病的人太多了。另外，对于Linus Torvalds，你是这个社区的 Role Model，但可惜你是一个 Bad Role Model，你在社区里的刻薄和侮辱性的言行，基本从一定程度上鼓励了其它人跟你一样，当然，并不只是你一个人的问题，而是在你周围聚集了一群和你一样的这样干的人。送你一句话—— A fish rots from the head down ！一条鱼是从头往下腐烂的……</p>
</blockquote>
<p>这篇契文很长，喜欢八卦的同学可以前往一读。感受一下 Lennart 当时的心态（我觉得能算上是非常平稳了）。</p>
<p>Linus也在被一媒体问起 <code>systemd</code> 这个事来（参看“<a href="https://www.itwire.com/business-it-news/open-source/65402-torvalds-says-he-has-no-strong-opinions-on-systemd">Torvalds says he has no strong opinions on systemd</a>”），Linus在采访里说，</p>
<blockquote>
<p>我对 <code>systemd</code> 和 Lennart 的贴子没有什么强烈的想法。虽然，传统的 Unix 设计哲学—— “Do one thing and Do it well”，很不错，而且我们大多数人也实践了这么多年，但是这并不代表所有的真实世界。在历史上，也不只有<code>systemd</code> 这么干过。但是，我个人还是 old-fashioned 的人，至少我喜欢文本式的日志，而不是二进制的日志。但是 <code>systemd</code> 没有必要一定要有这样的品味。哦，我说细节了……</p>
</blockquote>
<p>今天，<code>systemd</code> 占据了几乎所有的主流的 Linux 发行版的默认配置，包括：Arch Linux、CentOS、CoreOS、Debian、Fedora、Megeia、OpenSUSE、RHEL、SUSE企业版和 Ubuntu。而且，对于 CentOS, CoreOS, Fedora, RHEL, SUSE这些发行版来说，不能没有 <code>systemd</code>。（Ubuntu 还有一个不错的wiki – <a href="https://wiki.ubuntu.com/SystemdForUpstartUsers">Systemd for Upstart Users</a> 阐述了如何在两者间切换）</p>
<h4 id="其它">其它<a hidden class="anchor" aria-hidden="true" href="#其它">#</a></h4>
<p>还记得在《<a href="https://coolshell.cn/articles/17416.html">缓存更新的套路</a>》一文中，我说过，<strong>如果你要做好架构，首先你得把计算机体系结构以及很多老古董的基础技术吃透了</strong>。因为里面会有很多可以借鉴和相通的东西。那么，你是否从这篇文章里看到了一些有分布式架构相似的东西？</p>
<p>比如：从 <code>sysvinit</code> 到 <code>upstart</code> 再到 <code>systemd</code>，像不像是服务治理？Linux系统下的这些服务进程，是不是很像分布式架构中的微服务？还有那个D-Bus，是不是很像SOA里的ESB？而 init 系统是不是很像一个控制系统？甚至像一个服务编排（Service Orchestration）系统？</p>
<p>分布式系统中的服务之间也有很多依赖，所以，在启动一个架构的时候，如果我们可以做到像 systemd 那样并行启动的话，那么是不是就像是一个微服务的玩法了？</p>
<p>嗯，你会发现，技术上的很多东西是相通的，也是互相有对方的影子，所以，其实技术并不多。关键是我们学在了表面还是看到了本质。</p>
<h3 id="命令httpswwwruanyifengcomblog201603systemd-tutorial-commandshtml"><a href="https://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html">命令</a><a hidden class="anchor" aria-hidden="true" href="#命令httpswwwruanyifengcomblog201603systemd-tutorial-commandshtml">#</a></h3>
<p>Systemd 是 Linux 系统工具，用来启动守护进程，已成为大多数发行版的标准配置。</p>
<h4 id="系统管理">系统管理<a hidden class="anchor" aria-hidden="true" href="#系统管理">#</a></h4>
<p>Systemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面。</p>
<p><strong>systemctl</strong></p>
<p><code>systemctl</code>是 Systemd 的主命令，用于管理系统。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 重启系统</span>
$ sudo systemctl reboot
<span style="color:#75715e"># 关闭系统，切断电源</span>
$ sudo systemctl poweroff
<span style="color:#75715e"># CPU停止工作</span>
$ sudo systemctl halt
<span style="color:#75715e"># 暂停系统</span>
$ sudo systemctl suspend
<span style="color:#75715e"># 让系统进入冬眠状态</span>
$ sudo systemctl hibernate
<span style="color:#75715e"># 让系统进入交互式休眠状态</span>
$ sudo systemctl hybrid-sleep
<span style="color:#75715e"># 启动进入救援状态（单用户状态）</span>
$ sudo systemctl rescue
</code></pre></div><p><strong>systemd-analyze</strong></p>
<p><code>systemd-analyze</code>命令用于查看启动耗时。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 查看启动耗时</span>
$ systemd-analyze   
<span style="color:#75715e"># 查看每个服务的启动耗时</span>
$ systemd-analyze blame
<span style="color:#75715e"># 显示瀑布状的启动过程流$</span>
$ systemd-analyze critical-chain
<span style="color:#75715e"># 显示指定服务的启动流</span>
$ systemd-analyze critical-chain atd.service
</code></pre></div><p><strong>hostnamectl</strong></p>
<p><code>hostnamectl</code>命令用于查看当前主机的信息。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 显示当前主机的信息</span>
$ hostnamectl
<span style="color:#75715e"># 设置主机名。</span>
$ sudo hostnamectl set-hostname rhel7
</code></pre></div><p><strong>localectl</strong></p>
<p><code>localectl</code>命令用于查看本地化设置。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 查看本地化设置</span>
$ localectl
<span style="color:#75715e"># 设置本地化参数。</span>
$ sudo localectl set-locale LANG<span style="color:#f92672">=</span>en_GB.utf8
$ sudo localectl set-keymap en_GB
</code></pre></div><p><strong>timedatectl</strong></p>
<p><code>timedatectl</code>命令用于查看当前时区设置。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 查看当前时区设置</span>
$ timedatectl
<span style="color:#75715e"># 显示所有可用的时区</span>
$ timedatectl list-timezones                                    
<span style="color:#75715e"># 设置当前时区</span>
$ sudo timedatectl set-timezone America/New_York
$ sudo timedatectl set-time YYYY-MM-DD
$ sudo timedatectl set-time HH:MM:SS
</code></pre></div><p><strong>loginctl</strong></p>
<p><code>loginctl</code>命令用于查看当前登录的用户。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 列出当前session</span>
$ loginctl list-sessions
<span style="color:#75715e"># 列出当前登录用户</span>
$ loginctl list-users
<span style="color:#75715e"># 列出显示指定用户的信息</span>
$ loginctl show-user ruanyf
</code></pre></div><h4 id="unit">Unit<a hidden class="anchor" aria-hidden="true" href="#unit">#</a></h4>
<p><strong>含义</strong></p>
<p>Systemd 可以管理所有系统资源。不同的资源统称为 Unit（单元）。简单说，单元就是 Systemd 的最小功能单位，是单个进程的描述。一个个小的单元互相调用和依赖，组成一个庞大的任务管理系统，这就是 Systemd 的基本思想。</p>
<p>由于 Systemd 要做的事情太多，导致单元有很多不同的种类，大概一共有12种。</p>
<ul>
<li>Service unit：系统服务</li>
<li>Target unit：多个 Unit 构成的一个组</li>
<li>Device Unit：硬件设备</li>
<li>Mount Unit：文件系统的挂载点</li>
<li>Automount Unit：自动挂载点</li>
<li>Path Unit：文件或路径</li>
<li>Scope Unit：不是由 Systemd 启动的外部进程</li>
<li>Slice Unit：进程组，资源分配</li>
<li>Snapshot Unit：Systemd 快照，可以切回某个快照</li>
<li>Socket Unit：进程间通信的 socket</li>
<li>Swap Unit：swap 文件</li>
<li>Timer Unit：定时器</li>
</ul>
<p><code>systemctl list-units</code>命令可以查看当前系统的所有 Unit 。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 列出正在运行的 Unit</span>
$ systemctl list-units
<span style="color:#75715e"># 列出所有Unit，包括没有找到配置文件的或者启动失败的</span>
$ systemctl list-units --all
<span style="color:#75715e"># 列出所有没有运行的 Unit</span>
$ systemctl list-units --all --state<span style="color:#f92672">=</span>inactive
<span style="color:#75715e"># 列出所有加载失败的 Unit</span>
$ systemctl list-units --failed
<span style="color:#75715e"># 列出所有正在运行的、类型为 service 的 Unit</span>
$ systemctl list-units --type<span style="color:#f92672">=</span>service
</code></pre></div><p><strong>Unit 的状态</strong></p>
<p><code>systemctl status</code>命令用于查看系统状态和单个 Unit 的状态。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 显示系统状态</span>
$ systemctl status
<span style="color:#75715e"># 显示单个 Unit 的状态</span>
$ sysystemctl status bluetooth.service
<span style="color:#75715e"># 显示远程主机的某个 Unit 的状态</span>
$ systemctl -H root@rhel7.example.com status httpd.service
</code></pre></div><p>例如查看 httpd 状态</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo systemctl status httpd

httpd.service - The Apache HTTP Server
   Loaded: loaded <span style="color:#f92672">(</span>/usr/lib/systemd/system/httpd.service; enabled<span style="color:#f92672">)</span>
   Active: active <span style="color:#f92672">(</span>running<span style="color:#f92672">)</span> since 金 2014-12-05 12:18:22 JST; 7min ago
 Main PID: <span style="color:#ae81ff">4349</span> <span style="color:#f92672">(</span>httpd<span style="color:#f92672">)</span>
   Status: <span style="color:#e6db74">&#34;Total requests: 1; Current requests/sec: 0; Current traffic:   0 B/sec&#34;</span>
   CGroup: /system.slice/httpd.service
           ├─4349 /usr/sbin/httpd -DFOREGROUND
           ├─4350 /usr/sbin/httpd -DFOREGROUND
           ├─4351 /usr/sbin/httpd -DFOREGROUND
           ├─4352 /usr/sbin/httpd -DFOREGROUND
           ├─4353 /usr/sbin/httpd -DFOREGROUND
           └─4354 /usr/sbin/httpd -DFOREGROUND

12月 <span style="color:#ae81ff">05</span> 12:18:22 localhost.localdomain systemd<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span>: Starting The Apache HTTP Server...
12月 <span style="color:#ae81ff">05</span> 12:18:22 localhost.localdomain systemd<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span>: Started The Apache HTTP Server.
12月 <span style="color:#ae81ff">05</span> 12:22:40 localhost.localdomain systemd<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span>: Started The Apache HTTP Server.
</code></pre></div><p>上面的输出结果含义如下。</p>
<ul>
<li><code>Loaded</code>行：配置文件的位置，是否设为开机启动</li>
<li><code>Active</code>行：表示正在运行</li>
<li><code>Main PID</code>行：主进程ID</li>
<li><code>Status</code>行：由应用本身（这里是 httpd ）提供的软件当前状态</li>
<li><code>CGroup</code>块：应用的所有子进程</li>
<li>日志块：应用的日志</li>
</ul>
<p>除了<code>status</code>命令，<code>systemctl</code>还提供了三个查询状态的简单方法，主要供脚本内部的判断语句使用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 显示某个 Unit 是否正在运行</span>
$ systemctl is-active application.service
<span style="color:#75715e"># 显示某个 Unit 是否处于启动失败状态</span>
$ systemctl is-failed application.service
<span style="color:#75715e"># 显示某个 Unit 服务是否建立了启动链接</span>
$ systemctl is-enabled application.service
</code></pre></div><p><strong>Unit 管理</strong></p>
<p>对于用户来说，最常用的是下面这些命令，用于启动和停止 Unit（主要是 service）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 立即启动一个服务</span>
$ sudo systemctl start apache.service
<span style="color:#75715e"># 立即停止一个服务</span>
$ sudo systemctl stop apache.service
<span style="color:#75715e"># 重启一个服务</span>
$ sudo systemctl restart apache.service
<span style="color:#75715e"># 杀死一个服务的所有子进程</span>
$ sudo systemctl kill apache.service
<span style="color:#75715e"># 重新加载一个服务的配置文件</span>
$ sudo systemctl reload apache.service
<span style="color:#75715e"># 重载所有修改过的配置文件</span>
$ sudo systemctl daemon-reload
<span style="color:#75715e"># 显示某个 Unit 的所有底层参数</span>
$ systemctl show httpd.service
<span style="color:#75715e"># 显示某个 Unit 的指定属性的值</span>
$ systemctl show -p CPUShares httpd.service
<span style="color:#75715e"># 设置某个 Unit 的指定属性</span>
$ sudo systemctl set-property httpd.service CPUShares<span style="color:#f92672">=</span><span style="color:#ae81ff">500</span>
</code></pre></div><p>有时候，该命令可能没有响应，执行<code>systemctl stop</code>服务停不下来。这时候就不得不&quot;杀进程&quot;了，向正在运行的进程发出<code>kill</code>信号，执行<code>systemctl kill</code>。</p>
<p><strong>依赖关系</strong></p>
<p>Unit 之间存在依赖关系：A 依赖于 B，就意味着 Systemd 在启动 A 的时候，同时会去启动 B。</p>
<p><code>systemctl list-dependencies</code>命令列出一个 Unit 的所有依赖。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ systemctl list-dependencies nginx.service
</code></pre></div><p>上面命令的输出结果之中，有些依赖是 Target 类型（详见下文），默认不会展开显示。如果要展开 Target，就需要使用<code>--all</code>参数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ systemctl list-dependencies --all nginx.service
</code></pre></div><h4 id="unit-的配置文件">Unit 的配置文件<a hidden class="anchor" aria-hidden="true" href="#unit-的配置文件">#</a></h4>
<p><strong>概述</strong></p>
<p>每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit 。</p>
<p>除了系统默认的单元文件<code>/lib/systemd/system</code>，Systemd 默认从目录<code>/etc/systemd/system/</code>读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录<code>/usr/lib/systemd/system/</code>。那些支持 Systemd 的软件，安装的时候，也会自动在<code>/usr/lib/systemd/system</code>目录添加一个配置文件。</p>
<p><code>systemctl enable</code>命令用于在<code>/etc/systemd/system/</code>和<code>/usr/lib/systemd/system</code>之间，建立符号链接关系。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo systemctl enable clamd@scan.service
<span style="color:#75715e"># 等同于</span>
$ sudo ln -s <span style="color:#e6db74">&#39;/usr/lib/systemd/system/clamd@scan.service&#39;</span> <span style="color:#e6db74">&#39;/etc/systemd/system/multi-user.target.wants/clamd@scan.service&#39;</span>
</code></pre></div><p>如果配置文件里面设置了开机启动，<code>systemctl enable</code>命令相当于激活开机启动。</p>
<p>与之对应的，<code>systemctl disable</code>命令用于在两个目录之间，撤销符号链接关系，相当于撤销开机启动。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo systemctl disable clamd@scan.service
</code></pre></div><p>配置文件的后缀名，就是该 Unit 的种类，比如<code>sshd.socket</code>。如果省略，Systemd 默认后缀名为<code>.service</code>，所以<code>sshd</code>会被理解成<code>sshd.service</code>。</p>
<p>设置开机启动以后，软件并不会立即启动，必须等到下一次开机。如果想现在就运行该软件，那么要执行<code>systemctl start</code>命令。</p>
<p><strong>配置文件的状态</strong></p>
<p><code>systemctl list-unit-files</code>命令用于列出所有配置文件。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 列出所有配置文件</span>
$ systemctl list-unit-files
<span style="color:#75715e"># 列出指定类型的配置文件</span>
$ systemctl list-unit-files --type<span style="color:#f92672">=</span>service
</code></pre></div><p>这个命令会输出一个列表。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ systemctl list-unit-filesUNIT FILE              STATEchronyd.service        enabledclamd@.service         staticclamd@scan.service     disabled
</code></pre></div><p>这个列表显示每个配置文件的状态，一共有四种。</p>
<ul>
<li>enabled：已建立启动链接</li>
<li>disabled：没建立启动链接</li>
<li>static：该配置文件没有<code>[Install]</code>部分（无法执行），只能作为其他配置文件的依赖</li>
<li>masked：该配置文件被禁止建立启动链接</li>
</ul>
<p>注意，从配置文件的状态无法看出，该 Unit 是否正在运行。这必须执行前面提到的<code>systemctl status</code>命令。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ systemctl status bluetooth.service
</code></pre></div><p>一旦修改配置文件，就要让 Systemd 重新加载配置文件，然后重新启动，否则修改不会生效。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo systemctl daemon-reload
$ sudo systemctl restart httpd.service
</code></pre></div><p><strong>配置文件的格式</strong></p>
<p>配置文件就是普通的文本文件，可以用文本编辑器打开。</p>
<p><code>systemctl cat</code>命令可以查看配置文件的内容。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ systemctl cat sshd.service

<span style="color:#f92672">[</span>Unit<span style="color:#f92672">]</span>
Description<span style="color:#f92672">=</span>OpenSSH server daemon
Documentation<span style="color:#f92672">=</span>man:sshd<span style="color:#f92672">(</span>8<span style="color:#f92672">)</span> man:sshd_config<span style="color:#f92672">(</span>5<span style="color:#f92672">)</span>
After<span style="color:#f92672">=</span>network.target sshd-keygen.service
Wants<span style="color:#f92672">=</span>sshd-keygen.service

<span style="color:#f92672">[</span>Service<span style="color:#f92672">]</span>
EnvironmentFile<span style="color:#f92672">=</span>/etc/sysconfig/sshd
ExecStart<span style="color:#f92672">=</span>/usr/sbin/sshd -D $OPTIONS
ExecReload<span style="color:#f92672">=</span>/bin/kill -HUP $MAINPID
Type<span style="color:#f92672">=</span>simpleKill
Mode<span style="color:#f92672">=</span>process
Restart<span style="color:#f92672">=</span>on-failure
RestartSec<span style="color:#f92672">=</span>42s

<span style="color:#f92672">[</span>Install<span style="color:#f92672">]</span>
WantedBy<span style="color:#f92672">=</span>multi-user.target
</code></pre></div><p>从上面的输出可以看到，配置文件分成几个区块。每个区块的第一行，是用方括号表示的区别名，比如<code>[Unit]</code>。注意，配置文件的区块名和字段名，都是大小写敏感的。</p>
<p>每个区块内部是一些等号连接的键值对。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>Section<span style="color:#f92672">]</span>
Directive1<span style="color:#f92672">=</span>value
Directive2<span style="color:#f92672">=</span>value
. . .
</code></pre></div><p>注意，键值对的等号两侧不能有空格。</p>
<p><strong>配置文件的区块</strong></p>
<p><code>[Unit]</code>区块通常是配置文件的第一个区块，用来定义 Unit 的元数据，以及配置与其他 Unit 的关系。它的主要字段如下。</p>
<ul>
<li>
<p><code>Description</code>：当前服务的简单描述</p>
</li>
<li>
<p><code>Documentation</code>：文档地址</p>
</li>
<li>
<p>启动顺序</p>
<ul>
<li><code>Before</code>：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动</li>
<li><code>After</code>：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之前启动。如<code>network.target</code>或<code>sshd-keygen.service</code>需要启动，那么<code>sshd.service</code>应该在它们之后启动。</li>
</ul>
</li>
<li>
<p>依赖关系：</p>
<p>举例来说，某 Web 应用需要 postgresql 数据库储存数据。在配置文件中，<code>Before</code>、<code>After</code> 只定义要在 postgresql 之后启动，而没有定义依赖 postgresql 。上线后，由于某种原因，postgresql 需要重新启动，在停止服务期间，该 Web 应用就会无法建立数据库连接。</p>
<p>注意，<code>Wants</code>字段与<code>Requires</code>字段只涉及依赖关系，与启动顺序无关，默认情况下是同时启动的。</p>
<ul>
<li><code>Wants</code>：与当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败。如<code>sshd.service</code>与<code>sshd-keygen.service</code>之间存在&quot;弱依赖&quot;关系，即如果&quot;sshd-keygen.service&quot;启动失败或停止运行，不影响<code>sshd.service</code>继续执行。</li>
<li><code>Requires</code>：当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败。<code>Requires</code>字段则表示&quot;强依赖&quot;关系，即如果该服务启动失败或异常退出，那么<code>sshd.service</code>也必须退出。</li>
</ul>
</li>
<li>
<p><code>BindsTo</code>：与<code>Requires</code>类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行</p>
</li>
<li>
<p><code>Conflicts</code>：这里指定的 Unit 不能与当前 Unit 同时运行</p>
</li>
<li>
<p><code>Condition...</code>：当前 Unit 运行必须满足的条件，否则不会运行</p>
</li>
<li>
<p><code>Assert...</code>：当前 Unit 运行必须满足的条件，否则会报启动失败</p>
</li>
<li>
<p><a href="http://www.jinbuguo.com/systemd/systemd.unit.html#StartLimitIntervalSec=interval"><code>StartLimitIntervalSec=interval, StartLimitBurst=burst</code></a>：设置单元的启动频率限制。 也就是该单元在 <em><code>interval</code></em> 时间内最多允许启动 <em><code>burst</code></em> 次。</p>
</li>
</ul>
<hr>
<p><code>[Service]</code>区块用来定义如何启动当前服务，只有 Service 类型的 Unit 才有这个区块。它的主要字段如下。</p>
<ul>
<li><code>EnvironmentFile</code>字段：指定当前服务的环境参数文件。该文件内部的<code>key=value</code>键值对，可以用<code>$key</code>的形式，在当前配置文件中获取。sshd 的环境参数文件是<code>/etc/sysconfig/sshd</code>。</li>
<li><code>ExecStart</code>字段：定义启动进程时执行的命令。是配置文件里面最重要的字段。上面的例子中，启动<code>sshd</code>，执行的命令是<code>/usr/sbin/sshd -D $OPTIONS</code>，其中的变量<code>$OPTIONS</code>就来自<code>EnvironmentFile</code>字段指定的环境参数文件。与之作用相似的，还有如下这些字段。
<ul>
<li><code>ExecReload</code>字段：重启服务时执行的命令</li>
<li><code>ExecStop</code>字段：停止服务时执行的命令</li>
<li><code>ExecStartPre</code>字段：启动服务之前执行的命令</li>
<li><code>ExecStartPost</code>字段：启动服务之后执行的命令</li>
<li><code>ExecStopPost</code>字段：停止服务之后执行的命令</li>
</ul>
</li>
<li><code>Type</code>：字段定义启动类型。它可以设置的值如下。
<ul>
<li>simple（默认值）：<code>ExecStart</code>字段启动的进程为主进程</li>
<li>forking：<code>ExecStart</code>字段将以<code>fork()</code>方式启动，此时父进程将会退出，子进程将成为主进程</li>
<li>oneshot：类似于<code>simple</code>，但只执行一次，Systemd 会等它执行完，才启动其他服务</li>
<li>dbus：类似于<code>simple</code>，但会等待 D-Bus 信号后启动</li>
<li>notify：类似于<code>simple</code>，启动结束后会发出通知信号，然后 Systemd 再启动其他服务</li>
<li>idle：类似于<code>simple</code>，但是要等到其他任务都执行完，才会启动该服务。一种使用场合是为让该服务的输出，不与其他服务的输出相混合</li>
</ul>
</li>
<li><code>KillMode</code>字段：定义 Systemd 如何停止服务。
<ul>
<li>control-group（默认值）：当前控制组里面的所有子进程，都会被杀掉</li>
<li>process：只杀主进程。比如sshd的<code>KillMode</code>设为<code>process</code>，子进程打开的 SSH session 仍然保持连接。</li>
<li>mixed：主进程将收到 SIGTERM 信号，子进程收到 SIGKILL 信号</li>
<li>none：没有进程会被杀掉，只是执行服务的 stop 命令。</li>
</ul>
</li>
<li><code>Restart</code>：<code>Restart</code>字段：定义了服务退出后，Systemd 重启该服务的方式。
<ul>
<li>no（默认值）：退出后不会重启</li>
<li>on-success：只有正常退出时（退出状态码为0），才会重启</li>
<li>on-failure：非正常退出时（退出状态码非0），包括被信号终止和超时，才会重启。比如sshd任何意外的失败，都将重启sshd；如果 sshd 正常停止（比如执行<code>systemctl stop</code>命令），它就不会重启。对于守护进程，推荐设为<code>on-failure</code>。</li>
<li>on-abnormal：只有被信号终止和超时，才会重启。对于那些允许发生错误退出的服务，可以设为<code>on-abnormal</code>。</li>
<li>on-abort：只有在收到没有捕捉到的信号终止时，才会重启</li>
<li>on-watchdog：超时退出，才会重启</li>
<li>always：不管是什么退出原因，总是重启</li>
</ul>
</li>
<li><code>RestartSec</code>字段：表示 Systemd 重启服务之前，需要等待的秒数。</li>
<li><code>TimeoutSec</code>：定义 Systemd 停止当前服务之前等待的秒数</li>
</ul>
<p>所有的启动设置之前，都可以加上一个连词号（<code>-</code>），表示&quot;抑制错误&quot;，即发生错误的时候，不影响其他命令的执行。比如，<code>EnvironmentFile=-/etc/sysconfig/sshd</code>（注意等号后面的那个连词号），就表示即使<code>/etc/sysconfig/sshd</code>文件不存在，也不会抛出错误。</p>
<hr>
<p><code>[Install]</code>通常是配置文件的最后一个区块，定义如何安装这个配置文件，即怎样做到开机启动。它的主要字段如下。</p>
<ul>
<li><code>WantedBy</code>字段：表示该服务所在的 Target，它的值是一个或多个 Target。<code>Target</code>的含义是服务组，表示一组服务。<code>WantedBy=multi-user.target</code>指的是，sshd 所在的 Target 是<code>multi-user.target</code>。当前 Unit 激活时（enable）符号链接会放入<code>/etc/systemd/system</code>目录下面 <code>[Target 名].wants</code>子目录中，如<code>multi-user.target.wants</code>子目录。</li>
<li><code>RequiredBy</code>：它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入<code>/etc/systemd/system</code>目录下面以 Target 名 + <code>.required</code>后缀构成的子目录中</li>
<li><code>Alias</code>：当前 Unit 可用于启动的别名</li>
<li><code>Also</code>：当前 Unit 激活（enable）时，会被同时激活的其他 Unit</li>
</ul>
<p>Unit 配置文件的完整字段清单，请参考<a href="https://www.freedesktop.org/software/systemd/man/systemd.unit.html">官方文档</a>。</p>
<h4 id="target">Target<a hidden class="anchor" aria-hidden="true" href="#target">#</a></h4>
<p>启动计算机的时候，需要启动大量的 Unit。如果每一次启动，都要一一写明本次启动需要哪些 Unit，显然非常不方便。Systemd 的解决方案就是 Target。</p>
<p>简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于&quot;状态点&quot;，启动某个 Target 就好比启动到某种状态。</p>
<p>传统的<code>init</code>启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 查看当前系统的所有 Target</span>
$ systemctl list-unit-files --type<span style="color:#f92672">=</span>target
<span style="color:#75715e"># 查看一个 Target 包含的所有 Unit</span>
$ systemctl list-dependencies multi-user.target
<span style="color:#75715e"># 查看启动时的默认 Target，在这个组里的所有服务，都将开机启动。</span>
$ systemctl get-default
<span style="color:#75715e"># 设置启动时的默认 Target</span>
$ sudo systemctl set-default multi-user.target
<span style="color:#75715e"># 切换 Target 时，默认不关闭前一个 Target 启动的进程，</span>
<span style="color:#75715e"># systemctl isolate 命令改变这种行为，</span>
<span style="color:#75715e"># 关闭前一个 Target 里面所有不属于后一个 Target 的进程</span>
$ sudo systemctl isolate multi-user.target
</code></pre></div><p>Target 与 传统 RunLevel 的对应关系如下。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">Traditional runlevel      New target name     Symbolically linked to...

Runlevel <span style="color:#ae81ff">0</span>           |    runlevel0.target -&gt; poweroff.target
Runlevel <span style="color:#ae81ff">1</span>           |    runlevel1.target -&gt; rescue.target
Runlevel <span style="color:#ae81ff">2</span>           |    runlevel2.target -&gt; multi-user.target
Runlevel <span style="color:#ae81ff">3</span>           |    runlevel3.target -&gt; multi-user.target
Runlevel <span style="color:#ae81ff">4</span>           |    runlevel4.target -&gt; multi-user.target
Runlevel <span style="color:#ae81ff">5</span>           |    runlevel5.target -&gt; graphical.target
Runlevel <span style="color:#ae81ff">6</span>           |    runlevel6.target -&gt; reboot.target
</code></pre></div><p>它与<code>init</code>进程的主要差别如下。</p>
<p><strong>（1）默认的 RunLevel</strong>（在<code>/etc/inittab</code>文件设置）现在被默认的 Target 取代，位置是<code>/etc/systemd/system/default.target</code>，通常符号链接到<code>graphical.target</code>（图形界面）或者<code>multi-user.target</code>（多用户命令行）。</p>
<p><strong>（2）启动脚本的位置</strong>，以前是<code>/etc/init.d</code>目录，符号链接到不同的 RunLevel 目录 （比如<code>/etc/rc3.d</code>、<code>/etc/rc5.d</code>等），现在则存放在<code>/lib/systemd/system</code>和<code>/etc/systemd/system</code>目录。</p>
<p><strong>（3）配置文件的位置</strong>，以前<code>init</code>进程的配置文件是<code>/etc/inittab</code>，各种服务的配置文件存放在<code>/etc/sysconfig</code>目录。现在的配置文件主要存放在<code>/lib/systemd</code>目录，在<code>/etc/systemd</code>目录里面的修改可以覆盖原始设置。</p>
<h4 id="日志管理">日志管理<a hidden class="anchor" aria-hidden="true" href="#日志管理">#</a></h4>
<p>Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用<code>journalctl</code>一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是<code>/etc/systemd/journald.conf</code>。</p>
<p><code>journalctl</code>功能强大，用法非常多。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 查看所有日志（默认情况下 ，只保存本次启动的日志）</span>
$ sudo journalctl

<span style="color:#75715e"># 查看内核日志（不显示应用日志）</span>
$ sudo journalctl -k

<span style="color:#75715e"># 查看系统本次启动的日志</span>
$ sudo journalctl -b
$ sudo journalctl -b -0

<span style="color:#75715e"># 查看上一次启动的日志（需更改设置）</span>
$ sudo journalctl -b -1

<span style="color:#75715e"># 查看指定时间的日志</span>
$ sudo journalctl --since<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;2012-10-30 18:17:16&#34;</span>
$ sudo journalctl --since <span style="color:#e6db74">&#34;20 min ago&#34;</span>
$ sudo journalctl --since yesterday
$ sudo journalctl --since <span style="color:#e6db74">&#34;2015-01-10&#34;</span> --until <span style="color:#e6db74">&#34;2015-01-11 03:00&#34;</span>
$ sudo journalctl --since 09:00 --until <span style="color:#e6db74">&#34;1 hour ago&#34;</span>

<span style="color:#75715e"># 显示尾部的最新10行日志</span>
$ sudo journalctl -n

<span style="color:#75715e"># 显示尾部指定行数的日志</span>
$ sudo journalctl -n <span style="color:#ae81ff">20</span>

<span style="color:#75715e"># 实时滚动显示最新日志</span>
$ sudo journalctl -f

<span style="color:#75715e"># 查看指定服务的日志</span>
$ sudo journalctl /usr/lib/systemd/systemd

<span style="color:#75715e"># 查看指定进程的日志</span>
$ sudo journalctl _PID<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>

<span style="color:#75715e"># 查看某个路径的脚本的日志</span>
$ sudo journalctl /bin/bash

<span style="color:#75715e"># 查看指定用户的日志</span>
$ sudo journalctl _UID<span style="color:#f92672">=</span><span style="color:#ae81ff">33</span> --since today

<span style="color:#75715e"># 查看某个 Unit 的日志</span>
$ sudo journalctl -u nginx.service
$ sudo journalctl -u nginx.service --since today

<span style="color:#75715e"># 实时滚动显示某个 Unit 的最新日志</span>
$ sudo journalctl -u nginx.service -f

<span style="color:#75715e"># 合并显示多个 Unit 的日志</span>
$ journalctl -u nginx.service -u php-fpm.service --since today

<span style="color:#75715e"># 查看指定优先级（及其以上级别）的日志，共有8级</span>
<span style="color:#75715e"># 0: emerg</span>
<span style="color:#75715e"># 1: alert</span>
<span style="color:#75715e"># 2: crit</span>
<span style="color:#75715e"># 3: err</span>
<span style="color:#75715e"># 4: warning</span>
<span style="color:#75715e"># 5: notice</span>
<span style="color:#75715e"># 6: info</span>
<span style="color:#75715e"># 7: debug</span>
$ sudo journalctl -p err -b

<span style="color:#75715e"># 日志默认分页输出，--no-pager 改为正常的标准输出</span>
$ sudo journalctl --no-pager

<span style="color:#75715e"># 以 JSON 格式（单行）输出</span>
$ sudo journalctl -b -u nginx.service -o json

<span style="color:#75715e"># 以 JSON 格式（多行）输出，可读性更好</span>
$ sudo journalctl -b -u nginx.serviceqq -o json-pretty

<span style="color:#75715e"># 显示日志占据的硬盘空间</span>
$ sudo journalctl --disk-usage

<span style="color:#75715e"># 指定日志文件占据的最大空间</span>
$ sudo journalctl --vacuum-size<span style="color:#f92672">=</span>1G

<span style="color:#75715e"># 指定日志文件保存多久</span>
$ sudo journalctl --vacuum-time<span style="color:#f92672">=</span>1years
</code></pre></div><h3 id="定时器示例httpwwwruanyifengcomblog201803systemd-timerhtml"><a href="http://www.ruanyifeng.com/blog/2018/03/systemd-timer.html">定时器示例</a><a hidden class="anchor" aria-hidden="true" href="#定时器示例httpwwwruanyifengcomblog201803systemd-timerhtml">#</a></h3>
<h4 id="邮件脚本">邮件脚本<a hidden class="anchor" aria-hidden="true" href="#邮件脚本">#</a></h4>
<p>先写一个发邮件的脚本<code>mail.sh</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">#!/usr/bin/env bash
</span><span style="color:#75715e"></span>echo <span style="color:#e6db74">&#34;This is the body&#34;</span> | /usr/bin/mail -s <span style="color:#e6db74">&#34;Subject&#34;</span> someone@example.com
</code></pre></div><p>上面代码的<code>someone@example.com</code>，请替换成你的邮箱地址。</p>
<p>然后，执行这个脚本。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ bash mail.sh
</code></pre></div><p>执行后，你应该就会收到一封邮件，标题为<code>Subject</code>。</p>
<p>如果你的 Linux 系统不能发邮件，建议安装 <a href="http://tombuntu.com/index.php/2008/10/21/sending-email-from-your-system-with-ssmtp/">ssmtp</a> 或者 <a href="https://wiki.archlinux.org/index.php/msmtp">msmtp</a>。另外，<code>mail</code>命令的用法，可以参考<a href="https://www.binarytides.com/linux-mail-command-examples/">这里</a>。</p>
<h4 id="service-单元">Service 单元<a hidden class="anchor" aria-hidden="true" href="#service-单元">#</a></h4>
<p>Service 单元就是所要执行的任务，比如发送邮件就是一种 Service。</p>
<p>新建 Service 非常简单，就是在<code>/usr/lib/systemd/system</code>目录里面新建一个文件，比如<code>mytimer.service</code>文件，你可以写入下面的内容。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>Unit<span style="color:#f92672">]</span>
Description<span style="color:#f92672">=</span>MyTimer

<span style="color:#f92672">[</span>Service<span style="color:#f92672">]</span>
ExecStart<span style="color:#f92672">=</span>/bin/bash /path/to/mail.sh
</code></pre></div><p>注意，定义的时候，所有路径都要写成绝对路径，比如<code>bash</code>要写成<code>/bin/bash</code>，否则 Systemd 会找不到。</p>
<p>现在，启动这个 Service。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo systemctl start mytimer.service
</code></pre></div><p>如果一切正常，你应该就会收到一封邮件。</p>
<h4 id="timer-单元">Timer 单元<a hidden class="anchor" aria-hidden="true" href="#timer-单元">#</a></h4>
<p>Service 单元只是定义了如何执行任务，要定时执行这个 Service，还必须定义 Timer 单元。</p>
<p><code>/usr/lib/systemd/system</code>目录里面，新建一个<code>mytimer.timer</code>文件，写入下面的内容。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>Unit<span style="color:#f92672">]</span>
Description<span style="color:#f92672">=</span>Runs mytimer every hour

<span style="color:#f92672">[</span>Timer<span style="color:#f92672">]</span>
OnUnitActiveSec<span style="color:#f92672">=</span>1h
Unit<span style="color:#f92672">=</span>mytimer.service

<span style="color:#f92672">[</span>Install<span style="color:#f92672">]</span>
WantedBy<span style="color:#f92672">=</span>multi-user.target
</code></pre></div><p>这个 Timer 单元文件分成几个部分。</p>
<p><code>[Timer]</code>部分定制定时器。Systemd 提供以下一些字段。</p>
<ul>
<li><code>OnActiveSec</code>：定时器生效后，多少时间开始执行任务</li>
<li><code>OnBootSec</code>：系统启动后，多少时间开始执行任务</li>
<li><code>OnStartupSec</code>：Systemd 进程启动后，多少时间开始执行任务</li>
<li><code>OnUnitActiveSec</code>：该单元上次执行后，等多少时间再次执行</li>
<li><code>OnUnitInactiveSec</code>： 定时器上次关闭后多少时间，再次执行</li>
<li><code>OnCalendar</code>：基于绝对时间，而不是相对时间执行</li>
<li><code>AccuracySec</code>：如果因为各种原因，任务必须推迟执行，推迟的最大秒数，默认是60秒</li>
<li><code>Unit</code>：真正要执行的任务，默认是同名的带有<code>.service</code>后缀的单元</li>
<li><code>Persistent</code>：如果设置了该字段，即使定时器到时没有启动，也会自动执行相应的单元</li>
<li><code>WakeSystem</code>：如果系统休眠，是否自动唤醒系统</li>
</ul>
<p>上面的脚本里面，<code>OnUnitActiveSec=1h</code>表示一小时执行一次任务。其他的写法还有<code>OnCalendar=*-*-* 02:00:00</code>表示每天凌晨两点执行，<code>OnCalendar=Mon *-*-* 02:00:00</code>表示每周一凌晨两点执行，具体请参考<a href="http://www.jinbuguo.com/systemd/systemd.time.html">中文手册</a>。</p>
<h3 id="system-timehttpswikiarchlinuxorgtitlesystem_time_e7ae80e4bd93e4b8ade69687"><a href="https://wiki.archlinux.org/title/System_time_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">System time</a><a hidden class="anchor" aria-hidden="true" href="#system-timehttpswikiarchlinuxorgtitlesystem_time_e7ae80e4bd93e4b8ade69687">#</a></h3>
<p>一个操作系统通过如下内容确定时间：时间数值、时间标准、时区和夏令时调节(中国已经废止)。本文分别介绍各个部分的定义及如何设置他们。要维护准确的系统时间，请参考 <a href="https://wiki.archlinux.org/title/Network_Time_Protocol_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">网络时间协议</a> 一文。</p>
<h4 id="硬件时钟和系统时钟">硬件时钟和系统时钟<a hidden class="anchor" aria-hidden="true" href="#硬件时钟和系统时钟">#</a></h4>
<p>系统用两个时钟保存时间：硬件时钟和系统时钟。</p>
<p><strong>硬件时钟</strong>(即实时时钟 RTC 或 CMOS 时钟)仅能保存：年、月、日、时、分、秒这些时间数值，无法保存时间标准(UTC 或 localtime)和是否使用夏令时调节。</p>
<p><strong>系统时钟</strong>(即软件时间) 与硬件时间分别维护，保存了：时间、时区和夏令时设置。Linux 内核保存为自 UTC 时间 1970 年1月1日经过的秒数。初始系统时钟是从硬件时间计算得来，计算时会考虑<code>/etc/adjtime</code>的设置。系统启动之后，系统时钟与硬件时钟独立运行，Linux 通过时钟中断计数维护系统时钟。</p>
<p>如果系统时间是按 32 位整数保存的，最大只能记到 2038 年，所以 32 位 Linux 系统将在 2038 年停止工作。</p>
<p>大部分操作系统的时间管理包括如下方面：</p>
<ul>
<li>启动时根据硬件时钟设置系统时间</li>
<li>运行时通过时间同步联网校正时间</li>
<li>关机时根据系统时间设置硬件时间</li>
</ul>
<h4 id="读取时间">读取时间<a hidden class="anchor" aria-hidden="true" href="#读取时间">#</a></h4>
<p>下面命令可以获得硬件时间和系统时间(硬件时钟按 localtime 显示):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ timedatectl
               Local time: Thu 2022-01-27 10:35:26 CST
           Universal time: Thu 2022-01-27 02:35:26 UTC
                 RTC time: Thu 2022-01-27 02:35:26    
                Time zone: Asia/Shanghai <span style="color:#f92672">(</span>CST, +0800<span style="color:#f92672">)</span> 
System clock synchronized: yes                        
              NTP service: active                     
          RTC in local TZ: no 
</code></pre></div><p><strong>名词解释</strong>：</p>
<ul>
<li>CST：(China Standard Time,UTC+8:00) 中国沿海时间(北京时间)</li>
<li>UTC：(Universal Time Coordinated,UTC) 世界协调时间</li>
<li>GMT：(Greenwich Mean Time ,GMT）格林威治时间</li>
<li>LT：(locale time）本地时间</li>
</ul>
<h4 id="设置时间">设置时间<a hidden class="anchor" aria-hidden="true" href="#设置时间">#</a></h4>
<p>设置系统时间的本地时间：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># timedatectl set-time &#34;yyyy-MM-dd hh:mm:ss&#34;</span>
</code></pre></div><p>例如:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># timedatectl set-time &#34;2014-05-26 11:13:54&#34;</span>
</code></pre></div><p>设置时间为2014年，5月26日，11时13分54秒。</p>
<h4 id="时间标准">时间标准<a hidden class="anchor" aria-hidden="true" href="#时间标准">#</a></h4>
<p>时间表示有两个标准：<strong>localtime</strong> 和 <strong>UTC</strong>(<strong>C</strong>oordinated <strong>U</strong>niversal <strong>T</strong>ime) 。UTC 是与时区无关的全球时间标准。尽管概念上有差别，UTC 和 GMT (格林威治时间) 是一样的。localtime 标准则依赖于当前时区。</p>
<p>时间标准由操作系统设定，Windows 默认使用 localtime，Mac OS 默认使用 UTC，而 UNIX 系列的操作系统两者都有。使用 Linux 时，最好将硬件时钟设置为 UTC 标准，并在所有操作系统中使用。这样 Linux 系统就可以自动调整夏令时设置，而如果使用 localtime 标准那么系统时间不会根据夏令时自动调整。</p>
<p>通过如下命令可以检查当前设置，<strong>systemd</strong> 默认硬件时钟为协调世界时（UTC）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ timedatectl status | grep local
RTC in local TZ: no
</code></pre></div><p>硬件时间可以用 <code>hwclock</code> 命令设置，将硬件时间设置为 localtime：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># timedatectl set-local-rtc 1</span>
</code></pre></div><p>硬件时间设置成 UTC：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># timedatectl set-local-rtc 0</span>
</code></pre></div><p>上述命令会自动生成<code>/etc/adjtime</code>，无需单独设置。</p>
<p><strong>注意：</strong> 如果不存在 <code>/etc/adjtime</code>，systemd 会假定硬件时间按 UTC 设置。</p>
<p>系统启动装入 rtc 驱动时可能会根据系统时钟设置硬件时钟。是否设置依赖于平台、内核版本和内核编译选项。如果进行了设置，此时会假定硬件时钟为 UTC 标准，<code>/sys/class/rtc/rtcN/hctosys</code>(N=0,1,2,..) 会设置成 1。后面 systemd 会根据<code>/etc/adjtime</code>重新设置。</p>
<p>如果设置成本地时间，处理夏令时有些麻烦。如果夏令时调整发生在关机时，下次启动时时间会出现问题（<a href="https://www.cl.cam.ac.uk/~mgk25/mswish/ut-rtc.html">更多信息</a>）。最新的内核直接从实时时钟芯片（RTC）读取时间，不使用 <code>hwclock</code>，内核把从 RTC 读取的时间当作 UTC 处理。所以如果硬件时间是地方时，系统启动一开始识别的时间是错误的，之后很快会进行矫正。这可能导致一些问题（尤其是时间倒退时）。</p>
<h4 id="windows-系统使用-utc">Windows 系统使用 UTC<a hidden class="anchor" aria-hidden="true" href="#windows-系统使用-utc">#</a></h4>
<p>如果同时安装了 Windows 操作系统（<a href="https://devblogs.microsoft.com/oldnewthing/2004/09/02">默认使用地方时</a>），那么一般 RTC 会被设置为地方时。Windows 其实也能处理 UTC，需要<a href="https://wiki.archlinux.org/title/System_time_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#Windows_%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8_UTC">修改注册表</a>。建议让 Windows 使用 UTC，而非让 Linux 使用地方时。Windows 使用 UTC 后，请记得禁用 Windows 的时间同步功能，以防 Windows 错误设置硬件时间。如上文所说，Linux 可以使用<a href="https://wiki.archlinux.org/title/NTP_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">NTP服务</a>来在线同步硬件时钟。</p>
<p>使用 <code>regedit</code>,新建如下 DWORD 值，并将其值设为十六进制的 <code>1</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cmd" data-lang="cmd">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\TimeZoneInformation\RealTimeIsUniversal
</code></pre></div><p>也可以用管理员权限启动命令行来完成：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cmd" data-lang="cmd">reg add <span style="color:#e6db74">&#34;HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\TimeZoneInformation&#34;</span> /v RealTimeIsUniversal /d 1 /t REG_DWORD /f
</code></pre></div><p>如果以上操作不起作用，并且你使用的是 Windows 64位系统，将 <code>DWORD</code> 修改为 <code>QWORD</code>。</p>
<p>如果 Windows 要求根据夏令时更新时钟，可以允许。时钟仍然是 UTC，仅是显示时间会改变。</p>
<p>设置时间标准后需要重新设置硬件时间和系统时间。</p>
<p>如果你有时间偏移问题，再次设置你的时区:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># timedatectl set-timezone Asia/Shanghai</span>
</code></pre></div><h4 id="utc-在ubuntu的设置">UTC 在Ubuntu的设置<a hidden class="anchor" aria-hidden="true" href="#utc-在ubuntu的设置">#</a></h4>
<p>Ubuntu及其衍生发行版会在安装时检测计算机上是否存在Windows，若存在则会默认使用localtime。这是为了让Windows用户能够在不修改注册表的情况下，在Ubuntu内看到正确的时间。</p>
<p>要改变这种行为，请参见上面的内容。</p>
<h4 id="时区">时区<a hidden class="anchor" aria-hidden="true" href="#时区">#</a></h4>
<p>检查当前时区：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ timedatectl status
</code></pre></div><p>显示可用时区：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ timedatectl list-timezones
</code></pre></div><p>修改时区：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># timedatectl set-timezone &lt;Zone&gt;/&lt;SubZone&gt;</span>
</code></pre></div><p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># timedatectl set-timezone Asia/Shanghai</span>
</code></pre></div><p>此命令会创建一个<code>/etc/localtime</code>软链接，指向<code>/usr/share/zoneinfo/</code>中的时区文件，如果手动创建此链接请确保是相对链接而不是绝对链接。</p>
<p><strong>注意：</strong> 如果pre-systemd配置的/etc/timezone仍然存在于你的系统，你可以放心地将其删除，因为它不再使用。</p>
<h4 id="时钟偏移">时钟偏移<a hidden class="anchor" aria-hidden="true" href="#时钟偏移">#</a></h4>
<p>最能代表“真实时间”的是<a href="https://en.wikipedia.org/wiki/International_Atomic_Time">国际原子时钟</a>)，所有的时钟都是有误差的。电子时钟的时间是不准的，但是一般有固定的偏移。这种于基值的差称为“time skew”或“时间偏移”。用 <code>hwclock</code> 设置硬件时间时，会计算每天偏移的秒数。偏移值是原硬件时间与新设置硬件时间的差，并且考虑上次硬件时间设置时的偏移。新的偏移值会在设置时钟时写到文件 <code>/etc/adjtime</code> 。</p>
<p><strong>注意：</strong> 如果硬件时间值与原值的差小于 24 小时，偏移量不会重新计算，因为时间过短，无法精确设置偏移。</p>
<p>如果硬件时钟总是过快或过慢，可能是计算了错误的偏移值。硬件时钟设置错误或者时间标准与其他操作系统不一致导致。删除文件 <code>/etc/adjtime</code> 可以删除偏移值，然后设置正确的硬件时钟和系统时钟，并检查时间标准是不是设置正确。</p>
<p><strong>注意：</strong> 使用 Systemd 时，要使用 <code>/etc/adjtime</code>中的 drift 值(即无法或不想使用 NTP 时); 需要每次调用 <code>hwclock --adjust</code>命令，可以通过 cron 任务实现。</p>
<p>提高系统时间精度的方法有：</p>
<p><a href="https://wiki.archlinux.org/title/NTP">NTP</a> 可以通过网络时间协议同步 Linux 系统的时间。NTP 也会修正中断频率和每秒滴答数以减少时间偏移。并且每隔 11 分钟同步一次硬件时钟。</p>
<h4 id="时钟同步">时钟同步<a hidden class="anchor" aria-hidden="true" href="#时钟同步">#</a></h4>
<p><a href="https://en.wikipedia.org/wiki/Network_Time_Protocol">网络时间协议</a> (NTP) 是一个通过包交换和可变延迟网络来同步计算机系统时间的协议。下列为这个协议的实现：</p>
<ul>
<li><a href="https://wiki.archlinux.org/title/Network_Time_Protocol_daemon">NTP 守护进程</a>是这个协议的<a href="https://en.wikipedia.org/wiki/reference_implementation">参考实现</a>，推荐用于时间服务器。它也可以调节中断频率和每秒滴答次数以减少系统时钟误差，使得硬件时钟每隔11秒重新同步一次。</li>
<li><strong>sntp</strong> 是一个 <a href="https://en.wikipedia.org/wiki/Network_Time_Protocol#SNTP">SNTP</a> 客户端。它取代了 <em>ntpdate</em> ，并被推荐用于非服务器环境。</li>
<li><a href="https://wiki.archlinux.org/title/Systemd-timesyncd">systemd-timesyncd</a> 是一个简单的 <a href="https://en.wikipedia.org/wiki/Network_Time_Protocol#SNTP">SNTP</a> 守护进程。它只实现了客户端，专用于从远程服务器查询时间，更适用于绝大部分安装的情形。</li>
<li><a href="https://wiki.archlinux.org/title/OpenNTPD">OpenNTPD</a> 是 OpenBSD 项目的一部分，同时实现了客户端和服务器。</li>
<li><a href="https://wiki.archlinux.org/title/Chrony">Chrony</a> 是一个客户端和服务器，更适合漫游，是为不能始终保持在线的系统而特别设计。</li>
<li>ntpclient 是简单的命令行 NTP 客户端</li>
</ul>
<h2 id="防火墙httpswwwlinuxprobecombasic-learning-08html"><a href="https://www.linuxprobe.com/basic-learning-08.html">防火墙</a><a hidden class="anchor" aria-hidden="true" href="#防火墙httpswwwlinuxprobecombasic-learning-08html">#</a></h2>
<p>保障数据的安全性是继保障数据的可用性之后最为重要的一项工作。防火墙作为公网与内网之间的保护屏障，在保障数据的安全性方面起着至关重要的作用。</p>
<h3 id="防火墙管理工具">防火墙管理工具<a hidden class="anchor" aria-hidden="true" href="#防火墙管理工具">#</a></h3>
<p>众所周知，相较于企业内网，外部的公网环境更加恶劣，罪恶丛生。在公网与企业内网之间充当保护屏障的防火墙虽然有软件或硬件之分，但主要功能都是依据策略对穿越防火墙自身的流量进行过滤。就像家里安装的防盗门一样，目的是保护亲人和财产安全。防火墙策略可以基于流量的源目地址、端口号、协议、应用等信息来定制，然后防火墙使用预先定制的策略规则监控出入的流量，若流量与某一条策略规则相匹配，则执行相应的处理，反之则丢弃。这样一来，就能够保证仅有合法的流量在企业内网和外部公网之间流动了。</p>
<p><img loading="lazy" src="/Distributions/BAE585ACE7BD91E4B88EE58685E7BD91E4B98BE997B4E79A84E4BF9DE68AA4E5B18FE99A9C-2.jpg" alt=""  />
</p>
<p>从RHEL 7系统开始，firewalld防火墙正式取代了iptables防火墙。对于接触Linux系统比较早或学习过RHEL 5/6系统的读者来说，当他们发现曾经掌握的知识在RHEL 7/8中不再适用，需要全新学习firewalld时，难免会有抵触心理。其实，iptables与firewalld都不是真正的防火墙，它们都只是用来定义防火墙策略的防火墙管理工具而已；或者说，它们只是一种服务。iptables服务会把配置好的防火墙策略交由内核层面的netfilter网络过滤器来处理，而firewalld服务则是把配置好的防火墙策略交由内核层面的nftables包过滤框架来处理。换句话说，当前在Linux系统中其实存在多个防火墙管理工具，旨在方便运维人员管理Linux系统中的防火墙策略，我们只需要配置妥当其中的一个就足够了。</p>
<p>虽然这些工具各有优劣，但它们在防火墙策略的配置思路上是保持一致的。大家甚至可以不用完全掌握本章介绍的内容，只要在这多个防火墙管理工具中任选一款并将其学透，就足以满足日常的工作需求了。</p>
<h3 id="iptables">Iptables<a hidden class="anchor" aria-hidden="true" href="#iptables">#</a></h3>
<p>在早期的Linux系统中，默认使用的是iptables防火墙管理服务来配置防火墙。尽管新型的firewalld防火墙管理服务已经被投入使用多年，但是大量的企业在生产环境中依然出于各种原因而继续使用iptables。</p>
<h4 id="策略与规则链">策略与规则链<a hidden class="anchor" aria-hidden="true" href="#策略与规则链">#</a></h4>
<p>防火墙会按照从上到下的顺序来读取配置的策略规则，在找到匹配项后就立即结束匹配工作并去执行匹配项中定义的行为（即放行或阻止）。如果在读取完所有的策略规则之后没有匹配项，就去执行默认的策略。一般而言，防火墙策略规则的设置有两种：“通”（即放行）和“堵”（即阻止）。当防火墙的默认策略为拒绝时（堵），就要设置允许规则（通），否则谁都进不来；如果防火墙的默认策略为允许，就要设置拒绝规则，否则谁都能进来，防火墙也就失去了防范的作用。</p>
<p>iptables服务把用于处理或过滤流量的策略条目称之为规则，多条规则可以组成一个规则链，而规则链则依据数据包处理位置的不同进行分类，具体如下：</p>
<ul>
<li>在进行路由选择前处理数据包（PREROUTING）；</li>
<li>处理流入的数据包（INPUT）；</li>
<li>处理流出的数据包（OUTPUT）；</li>
<li>处理转发的数据包（FORWARD）；</li>
<li>在进行路由选择后处理数据包（POSTROUTING）。</li>
</ul>
<p>一般来说，从内网向外网发送的流量一般都是可控且良性的，因此使用最多的就是INPUT规则链，该规则链可以增大黑客人员从外网入侵内网的难度。</p>
<p>比如在您居住的社区内，物业管理公司有两条规定：禁止小商小贩进入社区；各种车辆在进入社区时都要登记。显而易见，这两条规定应该是用于社区的正门的（流量必须经过的地方），而不是每家每户的防盗门上。根据前面提到的防火墙策略的匹配顺序，可能会存在多种情况。比如，来访人员是小商小贩，则直接会被物业公司的保安拒之门外，也就无须再对车辆进行登记。如果来访人员乘坐一辆汽车进入社区正门，则“禁止小商小贩进入社区”的第一条规则就没有被匹配到，因此按照顺序匹配第二条策略，即需要对车辆进行登记。如果是社区居民要进入正门，则这两条规定都不会匹配到，因此会执行默认的放行策略。</p>
<p>但是，仅有策略规则还不能保证社区的安全，保安还应该知道采用什么样的动作来处理这些匹配的流量，比如“允许”“拒绝”“登记”“不理它”。这些动作对应到iptables服务的术语中分别是ACCEPT（允许流量通过）、REJECT（拒绝流量通过）、LOG（记录日志信息）、DROP（拒绝流量通过）。“允许流量通过”和“记录日志信息”都比较好理解，这里需要着重讲解的是REJECT和DROP的不同点。就DROP来说，它是直接将流量丢弃而且不响应；REJECT则会在拒绝流量后再回复一条“信息已经收到，但是被扔掉了”信息，从而让流量发送方清晰地看到数据被拒绝的响应信息。</p>
<p>下面举一个例子，让各位读者更直观地理解这两个拒绝动作的不同之处。比如有一天您正在家里看电视，突然听到有人敲门，您透过防盗门的猫眼一看是推销商品的，便会在不需要的情况下开门并拒绝他们（REJECT）。但如果看到的是债主带了十几个小弟来讨债，此时不仅要拒绝开门，还要默不作声，伪装成自己不在家的样子（DROP）。</p>
<p>当把Linux系统中的防火墙策略设置为REJECT动作后，流量发送方会看到端口不可达的响应：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># ping -c 4 192.168.10.10</span>
PING 192.168.10.10 <span style="color:#f92672">(</span>192.168.10.10<span style="color:#f92672">)</span> 56<span style="color:#f92672">(</span>84<span style="color:#f92672">)</span> bytes of data.
From 192.168.10.10 icmp_seq<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> Destination Port Unreachable
From 192.168.10.10 icmp_seq<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span> Destination Port Unreachable
From 192.168.10.10 icmp_seq<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span> Destination Port Unreachable
From 192.168.10.10 icmp_seq<span style="color:#f92672">=</span><span style="color:#ae81ff">4</span> Destination Port Unreachable
--- 192.168.10.10 ping statistics ---
<span style="color:#ae81ff">4</span> packets transmitted, <span style="color:#ae81ff">0</span> received, +4 errors, <span style="color:#ae81ff">100</span> packet loss, time 3002ms
</code></pre></div><p>而把Linux系统中的防火墙策略修改成DROP动作后，流量发送方会看到响应超时的提醒。但是流量发送方无法判断流量是被拒绝，还是接收方主机当前不在线：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># ping -c 4 192.168.10.10</span>
PING 192.168.10.10 <span style="color:#f92672">(</span>192.168.10.10<span style="color:#f92672">)</span> 56<span style="color:#f92672">(</span>84<span style="color:#f92672">)</span> bytes of data.

--- 192.168.10.10 ping statistics ---
<span style="color:#ae81ff">4</span> packets transmitted, <span style="color:#ae81ff">0</span> received, <span style="color:#ae81ff">100</span> packet loss, time 3000ms
</code></pre></div><h4 id="基本的命令参数httpswwwjianshucomp5a604b4ef342"><a href="https://www.jianshu.com/p/5a604b4ef342">基本的命令参数</a><a hidden class="anchor" aria-hidden="true" href="#基本的命令参数httpswwwjianshucomp5a604b4ef342">#</a></h4>
<p>iptables是一款基于<a href="https://www.linuxcool.com/">命令</a>行的防火墙策略管理工具，具有大量的参数，学习难度较大。好在对于日常的防火墙策略配置来讲，大家无须深入了解诸如“四表五链”的理论概念，只需要掌握常用的参数并做到灵活搭配即可，这就足以应对日常工作了。</p>
<p>根据OSI七层模型的定义，iptables属于数据链路层的服务，所以可以根据流量的源地址、目的地址、传输协议、服务类型等信息进行匹配；一旦匹配成功，iptables就会根据策略规则所预设的动作来处理这些流量。另外，再次提醒一下，防火墙策略规则的匹配顺序是从上到下的，因此要把较为严格、优先级较高的策略规则放到前面，以免发生错误。表8-1总结归纳了常用的iptables命令参数。再次强调，无须死记硬背这些参数，只需借助下面的实验来理解掌握即可。</p>
<h5 id="命令格式">命令格式<a hidden class="anchor" aria-hidden="true" href="#命令格式">#</a></h5>
<pre tabindex="0"><code>iptables [-t table] COMMAND chain CRETIRIA -j ACTION
</code></pre><ul>
<li>-t table ：filter/nat/mangle</li>
<li>COMMAND：定义如何对规则进行管理</li>
<li>chain：指定你接下来的规则到底是在哪个链上操作的，当定义策略的时候，是可以省略的</li>
<li>CRETIRIA:指定匹配标准</li>
<li>-j ACTION :指定如何进行处理</li>
</ul>
<h5 id="参数说明">参数说明<a hidden class="anchor" aria-hidden="true" href="#参数说明">#</a></h5>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>-F</td>
<td>清空规则链</td>
<td>iptables -F</td>
</tr>
<tr>
<td>-L</td>
<td>查看规则链</td>
<td>iptables -L</td>
</tr>
<tr>
<td>-A</td>
<td>追加规则</td>
<td>iptables -A INPUT</td>
</tr>
<tr>
<td>-D</td>
<td>删除规则</td>
<td>iptables -D INPUT 1</td>
</tr>
<tr>
<td>-R</td>
<td>修改规则</td>
<td>iptable -R INPUT 1 -s 192.168.120.0 -j DROP</td>
</tr>
<tr>
<td>-I</td>
<td>在头部插入规则</td>
<td>iptables -I INPUT 1 &ndash;dport 80 -j ACCEPT</td>
</tr>
<tr>
<td>-L</td>
<td>查看规则</td>
<td>iptables -L INPUT</td>
</tr>
<tr>
<td>-N</td>
<td>新的规则</td>
<td>iptables -N allowed</td>
</tr>
<tr>
<td>-V</td>
<td>查看iptables版本</td>
<td>iptables -V</td>
</tr>
<tr>
<td>-p</td>
<td>协议（tcp/udp/icmp）</td>
<td>iptables -A INPUT -p tcp</td>
</tr>
<tr>
<td>-s</td>
<td>匹配原地址，加&quot; ! &ldquo;表示除这个IP外</td>
<td>iptables -A INPUT -s 192.168.1.1</td>
</tr>
<tr>
<td>-d</td>
<td>匹配目的地址</td>
<td>iptables -A INPUT -d 192.168.12.1</td>
</tr>
<tr>
<td>&ndash;sport</td>
<td>匹配源端口流入的数据</td>
<td>iptables -A INPUT -p tcp &ndash;sport 22</td>
</tr>
<tr>
<td>&ndash;dport</td>
<td>匹配目的端口流出的数据</td>
<td>iptables -A INPUT -p tcp &ndash;dport 22</td>
</tr>
<tr>
<td>-i</td>
<td>匹配入口网卡流入的数据</td>
<td>iptables -A INPUT -i eth0</td>
</tr>
<tr>
<td>-o</td>
<td>匹配出口网卡流出的数据</td>
<td>iptables -A FORWARD -o eth0</td>
</tr>
<tr>
<td>-j</td>
<td>要进行的处理动作:DROP(丢弃)，REJECT(拒绝)，ACCEPT(接受)，SANT(基于原地址的转换)</td>
<td>iptable -A INPUT 1 -s 192.168.120.0 -j DROP</td>
</tr>
<tr>
<td>&ndash;to-source</td>
<td>指定SANT转换后的地址</td>
<td>iptables -t nat -A POSTROUTING -s 192.168.10.0/24 -j SANT &ndash;to-source 172.16.100.1</td>
</tr>
<tr>
<td>-t</td>
<td>表名(raw、mangle、nat、filter)</td>
<td>iptables -t nat</td>
</tr>
<tr>
<td>-m</td>
<td>使用扩展模块来进行数据包的匹配(multiport/tcp/state/addrtype)</td>
<td>iptables -m multiport</td>
</tr>
</tbody>
</table>
<h5 id="动作说明">动作说明<a hidden class="anchor" aria-hidden="true" href="#动作说明">#</a></h5>
<p>处理动作除了 ACCEPT、REJECT、DROP、REDIRECT 和 MASQUERADE 以外，还多出 LOG、ULOG、DNAT、SNAT、MIRROR、QUEUE、RETURN、TOS、TTL、MARK 等，其中某些处理动作不会中断过滤程序，某些处理动作则会中断同一规则链的过滤，并依照前述流程继续进行下一个规则链的过滤，一直到堆栈中的规则检查完毕为止。透过这种机制所带来的好处是，我们可以进行复杂、多重的封包过滤，简单的说，iptables 可以进行纵横交错式的过滤（tables）而非链状过滤（chains）。</p>
<table>
<thead>
<tr>
<th>动作</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>ACCEPT</td>
<td>将封包放行，进行完此处理动作后，将不再比对其它规则，直接跳往下一个规则链（nat:postrouting）</td>
<td></td>
</tr>
<tr>
<td>REJECT</td>
<td>拦阻该封包，并传送封包通知对方，可以传送的封包有几个选择：ICMP port-unreachable、ICMP echo-reply 或是 tcp-reset（这个封包会要求对方关闭联机），进行完此处理动作后，将不再比对其它规则，直接 中断过滤程序。</td>
<td>iptables -A FORWARD -p TCP &ndash;dport 22 -j REJECT &ndash;reject-with tcp-reset</td>
</tr>
<tr>
<td>DROP</td>
<td>丢弃封包不予处理，进行完此处理动作后，将不再比对其它规则，直接中断过滤程序。</td>
<td></td>
</tr>
<tr>
<td>REDIRECT</td>
<td>将封包重新导向到另一个端口（PNAT），进行完此处理动作后，将 会继续比对其它规则。 这个功能可以用来实作通透式 porxy 或用来保护 web 服务器。</td>
<td>iptables -t nat -A PREROUTING -p tcp &ndash;dport 80 -j REDIRECT &ndash;to-ports 8080</td>
</tr>
<tr>
<td>MASQUERADE</td>
<td>改写封包来源 IP 为防火墙 NIC IP，可以指定 port 对应的范围，进行完此处理动作后，直接跳往下一个规则链（mangle:postrouting）。这个功能与 SNAT 略有不同，当进行 IP 伪装时，不需指定要伪装成哪个 IP，IP 会从网卡直接读取，当使用拨接连线时，IP 通常是由 ISP 公司的 DHCP 服务器指派的，这个时候 MASQUERADE 特别有用。</td>
<td>iptables -t nat -A POSTROUTING -p TCP -j MASQUERADE &ndash;to-ports 1024-31000</td>
</tr>
<tr>
<td>LOG</td>
<td>将封包相关讯息纪录在 /var/log 中，详细位置请查阅 /etc/syslog.conf 组态档，进行完此处理动作后，将会继续比对其它规则。</td>
<td>iptables -A INPUT -p tcp -j LOG &ndash;log-prefix &ldquo;INPUT packets&rdquo;</td>
</tr>
<tr>
<td>SNAT</td>
<td>改写封包来源 IP 为某特定 IP 或 IP 范围，可以指定 port 对应的范围，进行完此处理动作后，将直接跳往下一个规则链（mangle:postrouting）。</td>
<td>iptables -t nat -A POSTROUTING -p tcp-o eth0 -j SNAT &ndash;to-source 194.236.50.155-194.236.50.160:1024-32000</td>
</tr>
<tr>
<td>DNAT</td>
<td>改写封包目的地 IP 为某特定 IP 或 IP 范围，可以指定 port 对应的范围，进行完此处理动作后，将会直接跳往下一个规则链（filter:input 或 filter:forward）。</td>
<td>iptables -t nat -A PREROUTING -p tcp -d 15.45.23.67 &ndash;dport 80 -j DNAT &ndash;to-destination 192.168.1.1-192.168.1.10:80-100</td>
</tr>
<tr>
<td>MIRROR</td>
<td>镜射封包，也就是将来源 IP 与目的地 IP 对调后，将封包送回，进行完此处理动作后，将会中断过滤程序。</td>
<td></td>
</tr>
<tr>
<td>QUEUE</td>
<td>中断过滤程序，将封包放入队列，交给其它程序处理。透过自行开发的处理程序，可以进行其它应用，例如：计算联机费用……等。</td>
<td></td>
</tr>
<tr>
<td>RETURN</td>
<td>结束在目前规则链中的过滤程序，返回主规则链继续过滤，如果把自订规则链看成是一个子程序，那么这个动作，就相当于提早结束子程序并返回到主程序中。</td>
<td></td>
</tr>
<tr>
<td>MARK</td>
<td>将封包标上某个代号，以便提供作为后续过滤的条件判断依据，进行完此处理动作后，将会继续比对其它规则。</td>
<td>iptables -t mangle -A PREROUTING -p tcp &ndash;dport 22 -j MARK &ndash;set-mark 2</td>
</tr>
</tbody>
</table>
<h5 id="例子">例子<a hidden class="anchor" aria-hidden="true" href="#例子">#</a></h5>
<p><strong>1．在iptables命令后添加-L参数查看已有的防火墙规则链。</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># iptables -L</span>
Chain INPUT <span style="color:#f92672">(</span>policy ACCEPT<span style="color:#f92672">)</span>
target     prot opt source               destination         
ACCEPT     udp  --  anywhere             anywhere             udp dpt:domain
ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:domain
ACCEPT     udp  --  anywhere             anywhere             udp dpt:bootps
ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:bootps

Chain FORWARD <span style="color:#f92672">(</span>policy ACCEPT<span style="color:#f92672">)</span>
target     prot opt source               destination         
ACCEPT     all  --  anywhere             192.168.122.0/24     ctstate RELATED,ESTABLISHED
ACCEPT     all  --  192.168.122.0/24     anywhere            
ACCEPT     all  --  anywhere             anywhere            
REJECT     all  --  anywhere             anywhere             reject-with icmp-port-unreachable
REJECT     all  --  anywhere             anywhere             reject-with icmp-port-unreachable

Chain OUTPUT <span style="color:#f92672">(</span>policy ACCEPT<span style="color:#f92672">)</span>
target     prot opt source               destination         
ACCEPT     udp  --  anywhere             anywhere             udp dpt:bootpc
</code></pre></div><p><strong>2．在iptables命令后添加-F参数清空已有的防火墙规则链。</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># iptables -F</span>
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># iptables -L</span>
Chain INPUT <span style="color:#f92672">(</span>policy ACCEPT<span style="color:#f92672">)</span>
target     prot opt source               destination         

Chain FORWARD <span style="color:#f92672">(</span>policy ACCEPT<span style="color:#f92672">)</span>
target     prot opt source               destination         

Chain OUTPUT <span style="color:#f92672">(</span>policy ACCEPT<span style="color:#f92672">)</span>
target     prot opt source               destination
</code></pre></div><p><strong>3．把INPUT规则链的默认策略设置为拒绝。</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># iptables -P INPUT DROP</span>
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># iptables -L</span>
Chain INPUT <span style="color:#f92672">(</span>policy DROP<span style="color:#f92672">)</span>
target     prot opt source               destination         

Chain FORWARD <span style="color:#f92672">(</span>policy ACCEPT<span style="color:#f92672">)</span>
target     prot opt source               destination         

Chain OUTPUT <span style="color:#f92672">(</span>policy ACCEPT<span style="color:#f92672">)</span>
target     prot opt source               destination
</code></pre></div><p>前文提到，防火墙策略规则的设置无非有两种方式：“通”和“堵”。当把INPUT链设置为默认拒绝后，就要往里面写入允许策略了，否则所有流入的数据包都会被默认拒绝掉。同学们需要留意的是，规则链的默认策略拒绝动作只能是DROP，而不能是REJECT。</p>
<p><strong>4．向INPUT链中添加允许ICMP流量进入的策略规则。</strong></p>
<p>在日常运维工作中，经常会使用ping命令来检查对方主机是否在线，而向防火墙的INPUT规则链中添加一条允许ICMP流量进入的策略规则就默认允许了这种ping命令检测行为。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># iptables -I INPUT -p icmp -j ACCEPT</span>
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># ping -c 4 192.168.10.10</span>
PING 192.168.10.10 <span style="color:#f92672">(</span>192.168.10.10<span style="color:#f92672">)</span> 56<span style="color:#f92672">(</span>84<span style="color:#f92672">)</span> bytes of data.
<span style="color:#ae81ff">64</span> bytes from 192.168.10.10: icmp_seq<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> ttl<span style="color:#f92672">=</span><span style="color:#ae81ff">64</span> time<span style="color:#f92672">=</span>0.154 ms
<span style="color:#ae81ff">64</span> bytes from 192.168.10.10: icmp_seq<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span> ttl<span style="color:#f92672">=</span><span style="color:#ae81ff">64</span> time<span style="color:#f92672">=</span>0.041 ms
<span style="color:#ae81ff">64</span> bytes from 192.168.10.10: icmp_seq<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span> ttl<span style="color:#f92672">=</span><span style="color:#ae81ff">64</span> time<span style="color:#f92672">=</span>0.038 ms
<span style="color:#ae81ff">64</span> bytes from 192.168.10.10: icmp_seq<span style="color:#f92672">=</span><span style="color:#ae81ff">4</span> ttl<span style="color:#f92672">=</span><span style="color:#ae81ff">64</span> time<span style="color:#f92672">=</span>0.046 ms

--- 192.168.10.10 ping statistics ---
<span style="color:#ae81ff">4</span> packets transmitted, <span style="color:#ae81ff">4</span> received, <span style="color:#ae81ff">0</span> packet loss, time 104ms
rtt min/avg/max/mdev <span style="color:#f92672">=</span> 0.038/0.069/0.154/0.049 ms
</code></pre></div><p><strong>5．删除INPUT规则链中刚刚加入的那条策略（允许ICMP流量），并把默认策略设置为允许。</strong></p>
<p>使用-F参数会清空已有的所有防火墙策略；使用-D参数可以删除某一条指定的策略，因此更加安全和准确。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># iptables -D INPUT 1</span>
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># iptables -P INPUT ACCEPT</span>
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># iptables -L</span>
Chain INPUT <span style="color:#f92672">(</span>policy ACCEPT<span style="color:#f92672">)</span>
target     prot opt source               destination         

Chain FORWARD <span style="color:#f92672">(</span>policy ACCEPT<span style="color:#f92672">)</span>
target     prot opt source               destination         

Chain OUTPUT <span style="color:#f92672">(</span>policy ACCEPT<span style="color:#f92672">)</span>
target     prot opt source               destination
</code></pre></div><p><strong>6．将INPUT规则链设置为只允许指定网段的主机访问本机的22端口，拒绝来自其他所有主机的流量。</strong></p>
<p>要对某台主机进行匹配，可直接写出它的IP地址；如需对网段进行匹配，则需要写为子网掩码的形式（比如192.168.10.0/24）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># iptables -I INPUT -s 192.168.10.0/24 -p tcp --dport 22 -j ACCEPT</span>
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># iptables -A INPUT -p tcp --dport 22 -j REJECT</span>
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># iptables -L</span>
Chain INPUT <span style="color:#f92672">(</span>policy ACCEPT<span style="color:#f92672">)</span>
target prot opt source destination
 ACCEPT tcp -- 192.168.10.0/24 anywhere tcp dpt:ssh 
 REJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachable
………………省略部分输出信息………………
</code></pre></div><p>再次重申，防火墙策略规则是按照从上到下的顺序匹配的，因此一定要把允许动作放到拒绝动作前面，否则所有的流量就将被拒绝掉，从而导致任何主机都无法访问我们的服务。另外，这里提到的22号端口是ssh服务使用的。</p>
<p>在设置完上述INPUT规则链之后，使用IP地址在192.168.10.0/24网段内的主机访问服务器（即前面提到的设置了INPUT规则链的主机）的22端口，效果如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@Client A ~<span style="color:#f92672">]</span><span style="color:#75715e"># ssh 192.168.10.10</span>
The authenticity of host <span style="color:#e6db74">&#39;192.168.10.10 (192.168.10.10)&#39;</span> can<span style="color:#e6db74">&#39;t be established.
</span><span style="color:#e6db74">ECDSA key fingerprint is SHA256:5d52kZi1la/FJK4v4jibLBZhLqzGqbJAskZiME6ZXpQ.
</span><span style="color:#e6db74">Are you sure you want to continue connecting (yes/no)? yes
</span><span style="color:#e6db74">Warning: Permanently added &#39;</span>192.168.10.10<span style="color:#e6db74">&#39; (ECDSA) to the list of known hosts.
</span><span style="color:#e6db74">root@192.168.10.10&#39;</span>s password: 此处输入服务器密码
Activate the web console with: systemctl enable --now cockpit.socket

Last login: Wed Jan <span style="color:#ae81ff">20</span> 16:30:28 <span style="color:#ae81ff">2021</span> from 192.168.10.1
</code></pre></div><p>然后，再使用IP地址在192.168.20.0/24网段内的主机访问服务器的22端口（虽网段不同，但已确认可以相互通信），效果如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@Client B ~<span style="color:#f92672">]</span><span style="color:#75715e"># ssh 192.168.10.10</span>
Connecting to 192.168.10.10:22...
Could not connect to <span style="color:#e6db74">&#39;192.168.10.10&#39;</span> <span style="color:#f92672">(</span>port 22<span style="color:#f92672">)</span>: Connection failed.
</code></pre></div><p>由上可以看到，提示连接请求被拒绝了（Connection failed）。</p>
<p><strong>7．向INPUT规则链中添加拒绝所有人访问本机12345端口的策略规则。</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># iptables -I INPUT -p tcp --dport 12345 -j REJECT</span>
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># iptables -I INPUT -p udp --dport 12345 -j REJECT</span>
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># iptables -L</span>
Chain INPUT <span style="color:#f92672">(</span>policy ACCEPT<span style="color:#f92672">)</span>
target prot opt source destination 
 REJECT udp -- anywhere anywhere udp dpt:italk reject-with icmp-port-unreachable
 REJECT tcp -- anywhere anywhere tcp dpt:italk reject-with icmp-port-unreachable
 ACCEPT tcp -- 192.168.10.0/24 anywhere tcp dpt:ssh
 REJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachable
………………省略部分输出信息………………
</code></pre></div><p><strong>8．向INPUT规则链中添加拒绝192.168.10.5主机访问本机80端口（Web服务）的策略规则。</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># iptables -I INPUT -p tcp -s 192.168.10.5 --dport 80 -j REJECT</span>
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># iptables -L</span>
Chain INPUT <span style="color:#f92672">(</span>policy ACCEPT<span style="color:#f92672">)</span>
target prot opt source destination 
 REJECT tcp -- 192.168.10.5 anywhere tcp dpt:http reject-with icmp-port-unreachable
 REJECT udp -- anywhere anywhere udp dpt:italk reject-with icmp-port-unreachable
 REJECT tcp -- anywhere anywhere tcp dpt:italk reject-with icmp-port-unreachable
 ACCEPT tcp -- 192.168.10.0/24 anywhere tcp dpt:ssh
 REJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachable
………………省略部分输出信息………………
</code></pre></div><p><strong>9．向INPUT规则链中添加拒绝所有主机访问本机1000～1024端口的策略规则。</strong></p>
<p>前面在添加防火墙策略时，使用的是-I参数，它默认会把规则添加到最上面的位置，因此优先级是最高的。如果工作中需要添加一条最后“兜底”的规则，那就用-A参数吧。这两个参数的效果差别还是很大的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># iptables -A INPUT -p tcp --dport 1000:1024 -j REJECT</span>
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># iptables -A INPUT -p udp --dport 1000:1024 -j REJECT</span>
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># iptables -L</span>
Chain INPUT <span style="color:#f92672">(</span>policy ACCEPT<span style="color:#f92672">)</span>
target prot opt source destination 
 REJECT tcp -- 192.168.10.5 anywhere tcp dpt:http reject-with icmp-port-unreachable
 REJECT udp -- anywhere anywhere udp dpt:italk reject-with icmp-port-unreachable
 REJECT tcp -- anywhere anywhere tcp dpt:italk reject-with icmp-port-unreachable
 ACCEPT tcp -- 192.168.10.0/24 anywhere tcp dpt:ssh
 REJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachable
 REJECT tcp -- anywhere anywhere tcp dpts:cadlock2:1024 reject-with icmp-port-unreachable
 REJECT udp -- anywhere anywhere udp dpts:cadlock2:1024 reject-with icmp-port-unreachable
………………省略部分输出信息………………
</code></pre></div><p>有关iptables命令的知识讲解到此就结束了，大家是不是意犹未尽？考虑到Linux防火墙的发展趋势，大家只要能把上面的实例吸收消化，就可以完全搞定日常的iptables配置工作了。但是请特别注意，使用iptables命令配置的防火墙规则默认会在系统下一次重启时失效，如果想让配置的防火墙策略永久生效，还要执行保存命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># iptables-save </span>
<span style="color:#75715e"># Generated by xtables-save v1.8.2 on Wed Jan 20 16:56:27 2021</span>
………………省略部分输出信息………………
</code></pre></div><p>对了，如果公司服务器是5/6/7版本的话，对应的保存命令应该是：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># service iptables save</span>
iptables: Saving firewall rules to /etc/sysconfig/iptables: <span style="color:#f92672">[</span> OK <span style="color:#f92672">]</span>
</code></pre></div><h4 id="基本概念httpswikiarchlinuxorgtitleiptables_e7ae80e4bd93e4b8ade69687e59fbae69cace6a682e5bfb5"><a href="https://wiki.archlinux.org/title/iptables_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">基本概念</a><a hidden class="anchor" aria-hidden="true" href="#基本概念httpswikiarchlinuxorgtitleiptables_e7ae80e4bd93e4b8ade69687e59fbae69cace6a682e5bfb5">#</a></h4>
<p><em>iptables</em> 是一个配置 Linux 内核 防火墙 的命令行工具，是 <a href="https://en.wikipedia.org/wiki/Netfilter">Netfilter</a> 项目的一部分。术语 <em>iptables</em> 也经常代指该内核级防火墙。iptables 可以直接配置，也可以通过许多 控制台 和 图形化 前端配置。iptables 用于 <a href="https://en.wikipedia.org/wiki/Ipv4">ipv4</a>，<em>ip6tables</em> 用于 <a href="https://wiki.archlinux.org/title/IPv6">IPv6</a>。<em>iptables</em>和<em>ip6tables</em> 拥有相同的语法，但是有些特别的选项，对 IPv4 和 IPv6 有些不同的。</p>
<p>iptables 可以检测、修改、转发、重定向和丢弃 IPv4 数据包。过滤 IPv4 数据包的代码已经内置于内核中，并且按照不同的目的被组织成 <strong>表</strong> 的集合。表 由一组预先定义的 <strong>链</strong> 组成，链 包含遍历顺序<strong>规则</strong>。每一条规则包含一个谓词的潜在匹配和相应的动作（称为 <strong>目标</strong>），如果谓词为真，该动作会被执行。也就是说条件匹配。iptables 是用户工具，允许用户使用 链 和 规则。很多新手面对复杂的 linux IP 路由时总是感到气馁，但是，实际上最常用的一些应用案例（NAT 或者基本的网络防火墙）并不是很复杂。</p>
<p><img loading="lazy" src="/Distributions/tables_traverse.jpg" alt=""  />
</p>
<p>理解 iptables 如何工作的关键是上面这张图。图中在上面的小写字母代表 <strong>表</strong>，在下面的大写字母代表 <strong>链</strong>。<strong>从任何网络端口</strong> 进来的每一个 IP 数据包都要从上到下的穿过这张图。一种常见的错误认知是认为 iptables 对从内部端口进入的数据包和从面向互联网端口进入的数据包采取不同的处理方式，相反，iptabales 对从任何端口进入的数据包都会采取相同的处理方式。可以定义规则使 iptables 采取不同的方式对待从不同端口进入的数据包。当然一些数据包是用于本地进程的，因此在图中表现为从顶端进入，到 <code>&lt;Local Process&gt;</code> 停止，而另一些数据包是由本地进程生成的，因此在图中表现为从 <code>&lt;Local Process&gt;</code> 发出，一直向下穿过该流程图。一份关于该流程图如何工作的详细解释请参考<a href="https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html#TRAVERSINGOFTABLES">这里</a>。</p>
<p>在大多数使用情况下都不会用到 <strong>raw</strong>，<strong>mangle</strong> 和 <strong>security</strong> 表。</p>
<h5 id="表tables">表(Tables)<a hidden class="anchor" aria-hidden="true" href="#表tables">#</a></h5>
<p>ptables 包含 5 张表（tables）:</p>
<ol>
<li><code>raw</code> 用于配置数据包，<code>raw</code> 中的数据包不会被系统跟踪。</li>
<li><code>filter</code> 是用于存放所有与防火墙相关操作的默认表。</li>
<li><code>nat</code> 用于 <a href="https://en.wikipedia.org/wiki/Network_address_translation">网络地址转换</a>（例如：端口转发）。</li>
<li><code>mangle</code> 用于对特定数据包的修改（参考 <a href="https://en.wikipedia.org/wiki/Mangled_packet">损坏数据包</a>）。</li>
<li><code>security</code> 用于 <a href="https://wiki.archlinux.org/title/Security#Mandatory_access_control">强制访问控制</a> 网络规则（例如： SELinux &ndash; 详细信息参考 <a href="https://lwn.net/Articles/267140/">该文章</a>）。</li>
</ol>
<p>大部分情况仅需要使用 <strong>filter</strong> 和 <strong>nat</strong>。其他表用于更复杂的情况——包括多路由和路由判定——已经超出了本文介绍的范围。</p>
<h5 id="链chains">链(Chains)<a hidden class="anchor" aria-hidden="true" href="#链chains">#</a></h5>
<p>表由链组成，链是一些按顺序排列的规则的列表。默认的 <code>filter</code> 表包含 <code>INPUT</code>， <code>OUTPUT</code> 和 <code>FORWARD</code> 3条内建的链，这3条链作用于数据包过滤过程中的不同时间点，如该上面流程图所示。<code>nat</code> 表包含<code>PREROUTING</code>， <code>POSTROUTING</code> 和 <code>OUTPUT</code> 链。</p>
<p>使用 <a href="https://man.archlinux.org/man/iptables.8">iptables(8)</a> 查看其他表中内建链的描述。</p>
<p>默认情况下，任何链中都没有规则。可以向链中添加自己想用的规则。链的默认规则通常设置为 <code>ACCEPT</code>，如果想确保任何包都不能通过规则集，那么可以重置为 <code>DROP</code>。默认的规则总是在一条链的最后生效，所以在默认规则生效前数据包需要通过所有存在的规则。</p>
<p>用户可以加入自己定义的链，从而使规则集更有效并且易于修改。如何使用自定义链请参考 <a href="https://wiki.archlinux.org/title/Simple_stateful_firewall">Simple stateful firewall</a>。</p>
<h5 id="规则-rules">规则 (Rules)<a hidden class="anchor" aria-hidden="true" href="#规则-rules">#</a></h5>
<p>数据包的过滤基于 <strong>规则</strong>。<strong>规则</strong>由一个<em>目标</em>（数据包包匹配所有条件后的动作）和很多<em>匹配</em>（导致该规则可以应用的数据包所满足的条件）指定。一个规则的典型匹配事项是数据包进入的端口（例如：eth0 或者 eth1）、数据包的类型（ICMP, TCP, 或者 UDP）和数据包的目的端口。</p>
<p>目标使用 <code>-j</code> 或者 <code>--jump</code> 选项指定。目标可以是用户定义的链（例如，如果条件匹配，跳转到之后的用户定义的链，继续处理）、一个内置的特定目标或者是一个目标扩展。内置目标是 <code>ACCEPT</code>， <code>DROP</code>， <code>QUEUE</code> 和 <code>RETURN</code>，目标扩展是 <code>REJECT</code> 和 <code>LOG</code>。如果目标是内置目标，数据包的命运会立刻被决定并且在当前表的数据包的处理过程会停止。如果目标是用户定义的链，并且数据包成功穿过第二条链，目标将移动到原始链中的下一个规则。目标扩展可以被<em>终止</em>（像内置目标一样）或者<em>不终止</em>（像用户定义链一样）。详细信息参阅 <a href="https://man.archlinux.org/man/iptables-extensions.8">iptables-extensions(8)</a>。</p>
<h5 id="遍历链traversing-chains">遍历链(Traversing Chains)<a hidden class="anchor" aria-hidden="true" href="#遍历链traversing-chains">#</a></h5>
<p>该流程图描述链了在任何接口上收到的网络数据包是按照怎样的顺序穿过表的交通管制链。第一个路由策略包括决定数据包的目的地是本地主机（这种情况下，数据包穿过 <code>INPUT</code> 链），还是其他主机（数据包穿过 <code>FORWARD</code> 链）；中间的路由策略包括决定给传出的数据包使用那个源地址、分配哪个接口；最后一个路由策略存在是因为先前的 mangle 与 nat 链可能会改变数据包的路由信息。数据包通过路径上的每一条链时，链中的每一条规则按顺序匹配；无论何时匹配了一条规则，相应的 target/jump 动作将会执行。最常用的3个 target 是 <code>ACCEPT</code>, <code>DROP</code> ,或者 jump 到用户自定义的链。内置的链有默认的策略，但是用户自定义的链没有默认的策略。在 jump 到的链中，若每一条规则都不能提供完全匹配，那么数据包像下面这张图片描述的一样返回到调用链。在任何时候，若 <code>DROP</code> target 的规则实现完全匹配，那么被匹配的数据包会被丢弃，不会进行进一步处理。如果一个数据包在链中被 <code>ACCEPT</code>，那么它也会被所有的父链 <code>ACCEPT</code>，并且不再遍历其他父链。然而，要注意的是，数据包还会以正常的方式继续遍历其他表中的其他链。</p>
<p><img loading="lazy" src="/Distributions/table_subtraverse.jpg" alt=""  />
</p>
<h5 id="模块modules">模块(Modules)<a hidden class="anchor" aria-hidden="true" href="#模块modules">#</a></h5>
<p>有许多模块可以用来扩展 iptables，例如 connlimit, conntrack, limit 和 recent。这些模块增添了功能，可以进行更复杂的过滤。</p>
<h3 id="firewalld">Firewalld<a hidden class="anchor" aria-hidden="true" href="#firewalld">#</a></h3>
<p>RHEL 8系统中集成了多款防火墙管理工具，其中firewalld（Dynamic Firewall Manager of Linux systems，Linux系统的动态防火墙管理器）服务是默认的防火墙配置管理工具，它拥有基于CLI（命令行界面）和基于GUI（图形用户界面）的两种管理方式。</p>
<p>RHEL 8系统中集成了多款防火墙管理工具，其中firewalld（Dynamic Firewall Manager of Linux systems，Linux系统的动态防火墙管理器）服务是默认的防火墙配置管理工具，它拥有基于CLI（命令行界面）和基于GUI（图形用户界面）的两种管理方式。</p>
<p>相较于传统的防火墙管理配置工具，firewalld支持动态更新技术并加入了区域（zone）的概念。简单来说，区域就是firewalld预先准备了几套防火墙策略集合（策略模板），用户可以根据生产场景的不同而选择合适的策略集合，从而实现防火墙策略之间的快速切换。例如，我们有一台笔记本电脑，每天都要在办公室、咖啡厅和家里使用。按常理来讲，这三者的安全性按照由高到低的顺序来排列，应该是家庭、公司办公室、咖啡厅。当前，我们希望为这台笔记本电脑制定如下防火墙策略规则：在家中允许访问所有服务；在办公室内仅允许访问文件共享服务；在咖啡厅仅允许上网浏览。在以往，我们需要频繁地手动设置防火墙策略规则，而现在只需要预设好区域集合，然后轻点鼠标就可以自动切换了，从而极大地提升了防火墙策略的应用效率。firewalld中常见的区域名称（默认为public）以及相应的策略规则如表所示。</p>
<table>
<thead>
<tr>
<th>区域</th>
<th>默认规则策略</th>
</tr>
</thead>
<tbody>
<tr>
<td>trusted</td>
<td>允许所有的数据包</td>
</tr>
<tr>
<td>home</td>
<td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、mdns、ipp-client、amba-client与dhcpv6-client服务相关，则允许流量</td>
</tr>
<tr>
<td>internal</td>
<td>等同于home区域</td>
</tr>
<tr>
<td>work</td>
<td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、ipp-client与dhcpv6-client服务相关，则允许流量</td>
</tr>
<tr>
<td>public</td>
<td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、dhcpv6-client服务相关，则允许流量</td>
</tr>
<tr>
<td>external</td>
<td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量</td>
</tr>
<tr>
<td>dmz</td>
<td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量</td>
</tr>
<tr>
<td>block</td>
<td>拒绝流入的流量，除非与流出的流量相关</td>
</tr>
<tr>
<td>drop</td>
<td>拒绝流入的流量，除非与流出的流量相关</td>
</tr>
</tbody>
</table>
<h4 id="终端管理工具">终端管理工具<a hidden class="anchor" aria-hidden="true" href="#终端管理工具">#</a></h4>
<p>命令行终端是一种极富效率的工作方式，firewall-cmd是firewalld防火墙配置管理工具的CLI（命令行界面）版本。它的参数一般都是以“长格式”来提供的。大家不要一听到长格式就头大，因为RHEL 8系统支持部分命令的参数补齐，其中就包含这条命令（很酷吧）。也就是说，现在除了能用Tab键自动补齐命令或文件名等内容之外，还可以用Tab键来补齐表所示的长格式参数。这太棒了！</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>&ndash;get-default-zone</td>
<td>查询默认的区域名称</td>
</tr>
<tr>
<td>&ndash;set-default-zone=&lt;区域名称&gt;</td>
<td>设置默认的区域，使其永久生效</td>
</tr>
<tr>
<td>&ndash;get-zones</td>
<td>显示可用的区域</td>
</tr>
<tr>
<td>&ndash;get-services</td>
<td>显示预先定义的服务</td>
</tr>
<tr>
<td>&ndash;get-active-zones</td>
<td>显示当前正在使用的区域与网卡名称</td>
</tr>
<tr>
<td>&ndash;add-source=</td>
<td>将源自此IP或子网的流量导向指定的区域</td>
</tr>
<tr>
<td>&ndash;remove-source=</td>
<td>不再将源自此IP或子网的流量导向某个指定区域</td>
</tr>
<tr>
<td>&ndash;add-interface=&lt;网卡名称&gt;</td>
<td>将源自该网卡的所有流量都导向某个指定区域</td>
</tr>
<tr>
<td>&ndash;change-interface=&lt;网卡名称&gt;</td>
<td>将某个网卡与区域进行关联</td>
</tr>
<tr>
<td>&ndash;list-all</td>
<td>显示当前区域的网卡配置参数、资源、端口以及服务等信息</td>
</tr>
<tr>
<td>&ndash;list-all-zones</td>
<td>显示所有区域的网卡配置参数、资源、端口以及服务等信息</td>
</tr>
<tr>
<td>&ndash;add-service=&lt;服务名&gt;</td>
<td>设置默认区域允许该服务的流量</td>
</tr>
<tr>
<td>&ndash;add-port=&lt;端口号/协议&gt;</td>
<td>设置默认区域允许该端口的流量</td>
</tr>
<tr>
<td>&ndash;remove-service=&lt;服务名&gt;</td>
<td>设置默认区域不再允许该服务的流量</td>
</tr>
<tr>
<td>&ndash;remove-port=&lt;端口号/协议&gt;</td>
<td>设置默认区域不再允许该端口的流量</td>
</tr>
<tr>
<td>&ndash;reload</td>
<td>让“永久生效”的配置规则立即生效，并覆盖当前的配置规则</td>
</tr>
<tr>
<td>&ndash;panic-on</td>
<td>开启应急状况模式</td>
</tr>
<tr>
<td>&ndash;panic-off</td>
<td>关闭应急状况模式</td>
</tr>
</tbody>
</table>
<p>与Linux系统中其他的防火墙策略配置工具一样，使用firewalld配置的防火墙策略默认为运行时（Runtime）模式，又称为当前生效模式，而且会随着系统的重启而失效。如果想让配置策略一直存在，就需要使用永久（Permanent）模式了，方法就是在用firewall-cmd命令正常设置防火墙策略时添加&ndash;permanent参数，这样配置的防火墙策略就可以永久生效了。但是，永久生效模式有一个“不近人情”的特点，就是使用它设置的策略只有在系统重启之后才能自动生效。如果想让配置的策略立即生效，需要手动执行firewall-cmd &ndash;reload命令。</p>
<p>接下来的实验都很简单，但是提醒大家一定要仔细查看使用的是Runtime模式还是Permanent模式。如果不关注这个细节，就算正确配置了防火墙策略，也可能无法达到预期的效果。</p>
<p><strong>1．查看firewalld服务当前所使用的区域。</strong></p>
<p>这是一步非常重要的操作。在配置防火墙策略前，必须查看当前生效的是哪个区域，否则配置的防火墙策略将不会立即生效。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --get-default-zone</span>
public
</code></pre></div><p><strong>2．查询指定网卡在firewalld服务中绑定的区域。</strong></p>
<p>在生产环境中，服务器大多不止有一块网卡。一般来说，充当网关的服务器有两块网卡，一块对公网，另外一块对内网，那么这两块网卡在审查流量时所用的策略肯定也是不一致的。因此，可以根据网卡针对的流量来源，为网卡绑定不同的区域，实现对防火墙策略的灵活管控。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --get-zone-of-interface=ens160</span>
public
</code></pre></div><p><strong>3．把网卡默认区域修改为external，并在系统重启后生效。</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --permanent --zone=external --change-interface=ens160</span>
The interface is under control of NetworkManager, setting zone to <span style="color:#e6db74">&#39;external&#39;</span>.
success
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --permanent --get-zone-of-interface=ens160</span>
external
</code></pre></div><p><strong>4．把firewalld服务的默认区域设置为public。</strong></p>
<p>默认区域也叫全局配置，指的是对所有网卡都生效的配置，优先级较低。在下面的代码中可以看到，当前默认区域为public，而ens160网卡的区域为external。此时便是以网卡的区域名称为准。</p>
<p>通俗来说，默认区域就是一种通用的政策。例如，食堂为所有人准备了一次性餐具，而环保主义者则会自己携带碗筷。如果您自带了碗筷，就可以用自己的；反之就用食堂统一提供的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --set-default-zone=public</span>
Warning: ZONE_ALREADY_SET: public
success
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --get-default-zone </span>
public
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --get-zone-of-interface=ens160</span>
external
</code></pre></div><p><strong>5．启动和关闭firewalld防火墙服务的应急状况模式。</strong></p>
<p>如果想在1s的时间内阻断一切网络连接，有什么好办法呢？大家下意识地会说：“拔掉网线！”这是一个物理级别的高招。但是，如果人在北京，服务器在异地呢？panic紧急模式在这个时候就派上用场了。使用&ndash;panic-on参数会立即切断一切网络连接，而使用&ndash;panic-off则会恢复网络连接。切记，紧急模式会切断一切网络连接，因此在远程管理服务器时，在按下回车键前一定要三思。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --panic-on</span>
success
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --panic-off</span>
success
</code></pre></div><p><strong>6．查询SSH和HTTPS协议的流量是否允许放行。</strong></p>
<p>在工作中可以不使用&ndash;zone参数指定区域名称，firewall-cmd命令会自动依据默认区域进行查询，从而减少用户输入量。但是，如果默认区域与网卡所绑定的不一致时，就会发生冲突，因此规范写法的zone参数是一定要加的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --zone=public --query-service=ssh</span>
yes
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --zone=public --query-service=https</span>
no
</code></pre></div><p><strong>7．把HTTPS协议的流量设置为永久允许放行，并立即生效。</strong></p>
<p>默认情况下进行的修改都属于Runtime模式，即当前生效而重启后失效，因此在工作和考试中尽量避免使用。而在使用&ndash;permanent参数时，则是当前不会立即看到效果，而在重启或重新加载后方可生效。于是，在添加了允许放行HTTPS流量的策略后，查询当前模式策略，发现依然是不允许放行HTTPS协议的流量：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --permanent --zone=public --add-service=https</span>
success
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --zone=public --query-service=https</span>
no
</code></pre></div><p>不想重启服务器的话，就用&ndash;reload参数吧：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --reload</span>
success
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --zone=public --query-service=https</span>
yes
</code></pre></div><p><strong>8．把HTTP协议的流量设置为永久拒绝，并立即生效。</strong></p>
<p>由于在默认情况下HTTP协议的流量就没有被允许，所以会有“Warning: NOT_ENABLED: http”这样的提示信息，因此对实际操作没有影响。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --permanent --zone=public --remove-service=http</span>
Warning: NOT_ENABLED: http
success
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --reload </span>
success
</code></pre></div><p><strong>9．把访问8080和8081端口的流量策略设置为允许，但仅限当前生效。</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --zone=public --add-port=8080-8081/tcp</span>
success
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --zone=public --list-ports</span>
8080-8081/tcp
</code></pre></div><p><strong>10．把原本访问本机888端口的流量转发到22端口，要且求当前和长期均有效。</strong></p>
<p>SSH远程控制协议是基于TCP/22端口传输控制指令的，如果想让用户通过其他端口号也能访问ssh服务，就可以试试端口转发技术了。通过这项技术，新的端口号在收到用户请求后会自动转发到原本服务的端口上，使得用户能够通过新的端口访问到原本的服务。</p>
<p>来举个例子帮助大家理解。假设小强是电子厂的工人，他喜欢上了三号流水线上的工人小花，但不好意思表白，于是写了一封情书并交给门卫张大爷，希望由张大爷转交给小花。这样一来，情书（信息）的传输由从小强到小花，变成了小强到张大爷再到小花，情书（信息）依然能顺利送达。</p>
<p>使用firewall-cmd命令实现端口转发的格式有点长，这里为大家总结好了：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">firewall-cmd --permanent --zone<span style="color:#f92672">=</span>&lt;区域&gt; --add-forward-port<span style="color:#f92672">=</span>port<span style="color:#f92672">=</span>&lt;源端口号&gt;:proto<span style="color:#f92672">=</span>&lt;协议&gt;:toport<span style="color:#f92672">=</span>&lt;目标端口号&gt;:toaddr<span style="color:#f92672">=</span>&lt;目标IP地址&gt;
</code></pre></div><p>上述命令中的目标IP地址一般是服务器本机的IP地址：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --permanent --zone=public --add-forward-port=port=888:proto=tcp:toport=22:toaddr=192.168.10.10</span>
success
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --reload</span>
success
</code></pre></div><p>在客户端使用ssh命令尝试访问192.168.10.10主机的888端口，访问成功：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@client A ~<span style="color:#f92672">]</span><span style="color:#75715e"># ssh -p 888 192.168.10.10</span>
The authenticity of host <span style="color:#e6db74">&#39;[192.168.10.10]:888 ([192.168.10.10]:888)&#39;</span> can<span style="color:#e6db74">&#39;t be established.
</span><span style="color:#e6db74">ECDSA key fingerprint is b8:25:88:89:5c:05:b6:dd:ef:76:63:ff:1a:54:02:1a.
</span><span style="color:#e6db74">Are you sure you want to continue connecting (yes/no)? yes
</span><span style="color:#e6db74">Warning: Permanently added &#39;</span><span style="color:#f92672">[</span>192.168.10.10<span style="color:#f92672">]</span>:888<span style="color:#e6db74">&#39; (ECDSA) to the list of known hosts.
</span><span style="color:#e6db74">root@192.168.10.10&#39;</span>s password:此处输入远程root管理员的密码
Last login: Sun Jul <span style="color:#ae81ff">19</span> 21:43:48 <span style="color:#ae81ff">2021</span> from 192.168.10.10
</code></pre></div><p><strong>11．富规则的设置。</strong></p>
<p>富规则也叫复规则，表示更细致、更详细的防火墙策略配置，它可以针对系统服务、端口号、源地址和目标地址等诸多信息进行更有针对性的策略配置。它的优先级在所有的防火墙策略中也是最高的。比如，我们可以在firewalld服务中配置一条富规则，使其拒绝192.168.10.0/24网段的所有用户访问本机的ssh服务（22端口）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --permanent --zone=public --add-rich-rule=&#34;rule family=&#34;ipv4&#34; source address=&#34;192.168.10.0/24&#34; service name=&#34;ssh&#34; reject&#34;</span>
success
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --reload</span>
success
</code></pre></div><p>在客户端使用ssh命令尝试访问192.168.10.10主机的ssh服务（22端口）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@client A ~<span style="color:#f92672">]</span><span style="color:#75715e"># ssh 192.168.10.10</span>
Connecting to 192.168.10.10:22...
Could not connect to <span style="color:#e6db74">&#39;192.168.10.10&#39;</span> <span style="color:#f92672">(</span>port 22<span style="color:#f92672">)</span>: Connection failed.
</code></pre></div><h4 id="图形管理工具">图形管理工具<a hidden class="anchor" aria-hidden="true" href="#图形管理工具">#</a></h4>
<p>在各种版本的Linux系统中，几乎没有能让刘遄老师欣慰并推荐的图形化工具，但是firewall-config做到了。它是firewalld防火墙配置管理工具的GUI（图形用户界面）版本，几乎可以实现所有以命令行来执行的操作。毫不夸张地说，即使读者没有扎实的Linux命令基础，也完全可以通过它来妥善配置RHEL 8中的防火墙策略。</p>
<p>成功 firewall-config 安装后，其工具的界面如图所示：</p>
<p><img loading="lazy" src="/Distributions/firewall-configE79A84E59BBEE5BDA2E7958CE99DA2-1.jpg" alt=""  />
</p>
<p>其功能具体如下。</p>
<p>1：选择运行时（Runtime）或永久（Permanent）模式的配置。</p>
<p>2：可选的策略集合区域列表。</p>
<p>3：常用的系统服务列表。</p>
<p>4：主机地址的黑白名单。</p>
<p>5：当前正在使用的区域。</p>
<p>6：管理当前被选中区域中的服务。</p>
<p>7：管理当前被选中区域中的端口。</p>
<p>8：设置允许被访问的协议。</p>
<p>9：设置允许被访问的端口。</p>
<p>10：开启或关闭SNAT（源网络地址转换）技术。</p>
<p>11：设置端口转发策略。</p>
<p>12：控制请求icmp服务的流量。</p>
<p>13：管理防火墙的富规则。</p>
<p>14：被选中区域的服务，若勾选了相应服务前面的复选框，则表示允许与之相关的流量。</p>
<p>15：firewall-config工具的运行状态。</p>
<p>除了图中列出的功能，还有用于将网卡与区域绑定的Interfaces选项，以及用于将IP地址与区域绑定的Sources选项。另外再啰唆一句。在使用firewall-config工具配置完防火墙策略之后，无须进行二次确认，因为只要有修改内容，它就自动进行保存。</p>
<p><strong>下面进行动手实践环节。</strong></p>
<p>先将当前区域中请求http服务的流量设置为允许放行，但仅限当前生效。具体配置如图所示：</p>
<p><img loading="lazy" src="/Distributions/E694BEE8A18CE8AFB7E6B182httpE69C8DE58AA1E79A84E6B581E9878F.png" alt=""  />
</p>
<p>尝试添加一条防火墙策略规则，使其放行访问8080～8088端口（TCP协议）的流量，并将其设置为永久生效，以达到系统重启后防火墙策略依然生效的目的。在按照下图所示的界面配置完毕之后，还需要在Options菜单中单击Reload Firewalld命令，让配置的防火墙策略立即生效。这与在命令行中使用&ndash;reload参数的效果一样。</p>
<p>放行访问8080～8088端口的流量：</p>
<p><img loading="lazy" src="/Distributions/E694BEE8A18CE8AEBFE997AE8080EFBD9E8088E7ABAFE58FA3E79A84E6B581E9878F.png" alt=""  />
</p>
<p>让配置的防火墙策略规则立即生效：</p>
<p><img loading="lazy" src="/Distributions/E8AEA9E9858DE7BDAEE79A84E998B2E781ABE5A299E7AD96E795A5E8A784E58899E7AB8BE58DB3E7949FE69588.png" alt=""  />
</p>
<p>前面在讲解firewall-config工具的功能时，曾经提到了SNAT（Source Network Address Translation，源网络地址转换）技术。SNAT是一种为了解决IP地址匮乏而设计的技术，它可以使得多个内网中的用户通过同一个外网IP接入Internet。该技术的应用非常广泛，甚至可以说我们每天都在使用，只不过没有察觉到罢了。比如，当通过家中的网关设备（无线路由器）访问本书配套站点<a href="https://www.linuxprobe.com/">www.linuxprobe.com</a>时，就用到了SNAT技术。</p>
<p>大家可以看一下在网络中不使用SNAT技术和使用SNAT技术时的情况。在没有使用SNAT技术的局域网中有多台PC，如果网关服务器没有应用SNAT技术，则互联网中的网站服务器在收到PC的请求数据包，并回送响应数据包时，将无法在网络中找到这个私有网络的IP地址，所以PC也就收不到响应数据包了。在使用SNAT技术处理过的局域网中，由于网关服务器应用了SNAT技术，所以互联网中的网站服务器会将响应数据包发给网关服务器，再由后者转发给局域网中的PC。</p>
<p>没有使用SNAT技术的网络：</p>
<p><img loading="lazy" src="/Distributions/E69CAAE794A8SNAT1.png" alt=""  />
</p>
<p>使用SNAT技术处理过的网络：</p>
<p><img loading="lazy" src="/Distributions/E4BDBFE794A8SNAT1.png" alt=""  />
</p>
<p>使用iptables命令实现SNAT技术是一件很麻烦的事情，但是在firewall-config中却是小菜一碟了。用户只需按照下图进行配置，并选中Masquerade zone复选框，就自动开启了SNAT技术。</p>
<p><img loading="lazy" src="/Distributions/E5BC80E590AFE998B2E781ABE5A299E79A84SNATE68A80E69CAF.png" alt=""  />
</p>
<p>为了让大家直观查看不同工具在实现相同功能时的区别，针对前面使用firewall-cmd配置的防火墙策略规则，这里使用firewall-config工具进行了重新演示：将本机888端口的流量转发到22端口，且要求当前和长期均有效，具体如下图所示：</p>
<p>配置本地的端口转发：</p>
<p><img loading="lazy" src="/Distributions/E9858DE7BDAEE69CACE59CB0E79A84E7ABAFE58FA3E8BDACE58F91.png" alt=""  />
</p>
<p>让防火墙效策略规则立即生效：</p>
<p><img loading="lazy" src="/Distributions/E8AEA9E998B2E781ABE5A299E69588E7AD96E795A5E8A784E58899E7AB8BE58DB3E7949FE69588.png" alt=""  />
</p>
<p>用命令配置富规则可真辛苦，幸好我们现在有了图形用户界面的工具。让192.168.10.20主机访问本机的1234端口号，如下图所示。其中Element选项能够根据服务名称、端口号、协议等信息进行匹配；Source与Destination选项后的inverted复选框代表反选功能，将其选中则代表对已填写信息进行反选，即选中填写信息以外的主机地址；Log复选框在选中后，日志不仅会被记录到日志文件中，而且还可以在设置日志的级别（Level）后，再将日志记录到日志文件中，以方便后续的筛查。</p>
<p><img loading="lazy" src="/Distributions/E9858DE7BDAEE998B2E781ABE5A299E5AF8CE8A784E58899E7AD96E795A5-1.png" alt=""  />
</p>
<p>如果生产环境中的服务器有多块网卡在同时提供服务（这种情况很常见），则对内网和对外网提供服务的网卡要选择的防火墙策略区域也是不一样的。也就是说，可以把网卡与防火墙策略区域进行绑定，这样就可以使用不同的防火墙区域策略，对源自不同网卡的流量进行有针对性的监控，效果会更好。</p>
<p>把网卡与防火墙策略区域进行绑定：</p>
<p><img loading="lazy" src="/Distributions/E68A8AE7BD91E58DA1E4B88EE998B2E781ABE5A299E7AD96E795A5E58CBAE59F9FE8BF9BE8A18CE7BB91E5AE9A.png" alt=""  />
</p>
<p>网卡与策略区域绑定完成：</p>
<p><img loading="lazy" src="/Distributions/E7BD91E58DA1E4B88EE7AD96E795A5E58CBAE59F9FE7BB91E5AE9AE5AE8CE68890.png" alt=""  />
</p>
<p>最后再提一句，firewall-config工具真的非常实用，很多原本复杂的长命令被图形化按钮替代，设置规则也简单明了，足以应对日常工作。所以再次向大家强调配置防火墙策略的原则—只要能实现所需的功能，用什么工具请随君便。</p>
<h3 id="服务的访问控制列表">服务的访问控制列表<a hidden class="anchor" aria-hidden="true" href="#服务的访问控制列表">#</a></h3>
<p>TCP Wrapper是RHEL 6/7系统中默认启用的一款流量监控程序，它能够根据来访主机的地址与本机的目标服务程序做出允许或拒绝的操作。在RHEL 8版本中，它已经被firewalld正式替代。换句话说，Linux系统中其实有两个层面的防火墙，第一种是前面讲到的基于TCP/IP协议的流量过滤工具，而TCP Wrapper服务则是能允许或禁止Linux系统提供服务的防火墙，从而在更高层面保护了Linux系统的安全运行。</p>
<p>TCP Wrapper服务的防火墙策略由两个控制列表文件所控制，用户可以编辑允许控制列表文件来放行对服务的请求流量，也可以编辑拒绝控制列表文件来阻止对服务的请求流量。控制列表文件修改后会立即生效，系统将会先检查允许控制列表文件（/etc/hosts.allow），如果匹配到相应的允许策略则放行流量；如果没有匹配，则会进一步匹配拒绝控制列表文件（/etc/hosts.deny），若找到匹配项则拒绝该流量。如果这两个文件都没有匹配到，则默认放行流量。</p>
<p>由于RHEL 8版本已经不再支持TCP Wrapper服务程序，因此我们接下来选择在一台老版本的服务器上进行实验。TCP Wrapper服务的控制列表文件配置起来并不复杂，常用的参数如表所示。</p>
<table>
<thead>
<tr>
<th>客户端类型</th>
<th>示例</th>
<th>满足示例的客户端列表</th>
</tr>
</thead>
<tbody>
<tr>
<td>单一主机</td>
<td>192.168.10.10</td>
<td>IP地址为192.168.10.10的主机</td>
</tr>
<tr>
<td>指定网段</td>
<td>192.168.10.</td>
<td>IP段为192.168.10.0/24的主机</td>
</tr>
<tr>
<td>指定网段</td>
<td>192.168.10.0/255.255.255.0</td>
<td>IP段为192.168.10.0/24的主机</td>
</tr>
<tr>
<td>指定DNS后缀</td>
<td>.linuxprobe.com</td>
<td>所有DNS后缀为.linuxprobe.com的主机</td>
</tr>
<tr>
<td>指定主机名称</td>
<td><a href="http://www.linuxprobe.com">www.linuxprobe.com</a></td>
<td>主机名称为www.linuxprobe.com的主机</td>
</tr>
<tr>
<td>指定所有客户端</td>
<td>ALL</td>
<td>所有主机全部包括在内</td>
</tr>
</tbody>
</table>
<p>在配置TCP Wrapper服务时需要遵循两个原则：</p>
<ul>
<li>编写拒绝策略规则时，填写的是服务名称，而非协议名称；</li>
<li>建议先编写拒绝策略规则，再编写允许策略规则，以便直观地看到相应的效果。</li>
</ul>
<p>下面编写拒绝策略规则文件，禁止访问本机sshd服务的所有流量（无须修改/etc/hosts.deny文件中原有的注释信息）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># vim /etc/hosts.deny</span>
<span style="color:#75715e">#</span>
<span style="color:#75715e"># hosts.deny This file contains access rules which are used to</span>
<span style="color:#75715e"># deny connections to network services that either use</span>
<span style="color:#75715e"># the tcp_wrappers library or that have been</span>
<span style="color:#75715e"># started through a tcp_wrappers-enabled xinetd.</span>
<span style="color:#75715e">#</span>
<span style="color:#75715e"># The rules in this file can also be set up in</span>
<span style="color:#75715e"># /etc/hosts.allow with a &#39;deny&#39; option instead.</span>
<span style="color:#75715e">#</span>
<span style="color:#75715e"># See &#39;man 5 hosts_options&#39; and &#39;man 5 hosts_access&#39;</span>
<span style="color:#75715e"># for information on rule syntax.</span>
<span style="color:#75715e"># See &#39;man tcpd&#39; for information on tcp_wrappers</span>
sshd:*
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># ssh 192.168.10.10</span>
ssh_exchange_identification: read: Connection reset by peer
</code></pre></div><p>接下来，在允许策略规则文件中添加一条规则，使其放行源自192.168.10.0/24网段，且访问本机sshd服务的所有流量。可以看到，服务器立刻就放行了访问sshd服务的流量，效果非常直观：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># vim /etc/hosts.allow</span>
<span style="color:#75715e">#</span>
<span style="color:#75715e"># hosts.allow This file contains access rules which are used to</span>
<span style="color:#75715e"># allow or deny connections to network services that</span>
<span style="color:#75715e"># either use the tcp_wrappers library or that have been</span>
<span style="color:#75715e"># started through a tcp_wrappers-enabled xinetd.</span>
<span style="color:#75715e">#</span>
<span style="color:#75715e"># See &#39;man 5 hosts_options&#39; and &#39;man 5 hosts_access&#39;</span>
<span style="color:#75715e"># for information on rule syntax.</span>
<span style="color:#75715e"># See &#39;man tcpd&#39; for information on tcp_wrappers</span>
sshd:192.168.10.

<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># ssh 192.168.10.10</span>
The authenticity of host <span style="color:#e6db74">&#39;192.168.10.10 (192.168.10.10)&#39;</span> can<span style="color:#e6db74">&#39;t be established.
</span><span style="color:#e6db74">ECDSA key fingerprint is 70:3b:5d:37:96:7b:2e:a5:28:0d:7e:dc:47:6a:fe:5c.
</span><span style="color:#e6db74">Are you sure you want to continue connecting (yes/no)? yes
</span><span style="color:#e6db74">Warning: Permanently added &#39;</span>192.168.10.10<span style="color:#e6db74">&#39; (ECDSA) to the list of known hosts.
</span><span style="color:#e6db74">root@192.168.10.10&#39;</span>s password: 
Last login: Wed May <span style="color:#ae81ff">4</span> 07:56:29 <span style="color:#ae81ff">2021</span>
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># </span>
</code></pre></div><h3 id="cockpit-驾驶舱管理工具">Cockpit 驾驶舱管理工具<a hidden class="anchor" aria-hidden="true" href="#cockpit-驾驶舱管理工具">#</a></h3>
<p>首先，Cockpit是一个英文单词，即“（飞机、船或赛车的）驾驶舱、驾驶座”，它用名字传达出了功能丰富的特性。其次，Cockpit是一个基于Web的图形化服务管理工具，对用户相当友好，即便是新手也可以轻松上手。而且它天然具备很好的跨平台性，因此被广泛应用于服务器、容器、虚拟机等多种管理场景。最后，红帽公司对Cockpit也十分看重，直接将它默认安装到了RHEL 8系统中，由此衍生的CentOS和Fedora也都标配有Cockpit。</p>
<p>Cockpit在默认情况下就已经被安装到系统中。下面执行dnf命令对此进行确认：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># dnf install cockpit</span>
Updating Subscription Management repositories.
Unable to read consumer identity
This system is not registered to Red Hat Subscription Management. You can use subscription-manager to register.
AppStream                                       3.1 MB/s | 3.2 kB     00:00    
BaseOS                                          2.7 MB/s | 2.7 kB     00:00    
Package cockpit-185-2.el8.x86_64 is already installed.
Dependencies resolved.
Nothing to <span style="color:#66d9ef">do</span>.
Complete!
</code></pre></div><p>但是，Cockpit服务程序在RHEL 8版本中没有自动运行，下面将它开启并加入到开机启动项中：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># systemctl start cockpit</span>
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># systemctl enable cockpit.socket</span>
Created symlink /etc/systemd/system/sockets.target.wants/cockpit.socket → /usr/lib/systemd/system/cockpit.socket.
</code></pre></div><p>在Cockpit服务启动后，打开系统自带的浏览器，在地址栏中输入“本机地址:9090”即可访问。由于访问Cockpit的流量会使用HTTPS进行加密，而证书又是在本地签发的，因此还需要进行添加并信任本地证书的操作。</p>
<p>添加额外允许的证书：</p>
<p><img loading="lazy" src="/Distributions/1-58.png" alt=""  />
</p>
<p>确认信任本地证书：</p>
<p><img loading="lazy" src="/Distributions/2-37.png" alt=""  />
</p>
<p>进入Cockpit的登录界面后，输入root管理员的账号与系统密码，单击Log In按钮后即可进入：</p>
<p><img loading="lazy" src="/Distributions/3-14.png" alt=""  />
</p>
<p>进入Cockpit的Web界面，发现里面可谓“别有洞天”。Cockpit总共分为13个功能模块：系统状态（System）、日志信息（Logs）、硬盘存储（Storage）、网卡网络（Networking）、账户安全（Accounts）、服务程序（Services）、软件仓库（Applications）、报告分析（Diagnostic Reports）、内核排错（Kernel Dump）、SElinux、更新软件（Software Updates）、订阅服务（Subscriptions）、终端界面（Terminal）。下面逐一进行讲解。</p>
<p><strong>1．System</strong></p>
<p>进入Cockpit界面后默认显示的便是System（系统）界面，在该界面中能够看到系统架构、版本、主机名与时间等信息，还能够动态地展现出CPU、硬盘、内存和网络的复杂情况，这有点类似于Web版的“Winodws系统任务管理器”，属实好用。</p>
<p>系统状态界面：</p>
<p><img loading="lazy" src="/Distributions/1-59.png" alt=""  />
</p>
<p><strong>2．Logs</strong></p>
<p>这个模块能够提供系统的全部日志，但是同学们可能会好奇，“为什么下图中的内容这么有限呢”？原因出在图中的两个选项中：时间和日志级别。通过这两个选项可以让用户更快地找到所需信息，而不是像/var/log/message文件那样一股脑儿地都抛给用户。</p>
<p>日志信息界面：</p>
<p><img loading="lazy" src="/Distributions/2-38.png" alt=""  />
</p>
<p><strong>3．Storage</strong></p>
<p>这个功能模块是同学们最喜欢的一个模块，原因不是这个模块显示了硬盘的I/O读写负载情况，而是可以让用户通过该界面，用鼠标创建出RAID、LVM、VDO和iSCSI等存储设备。是的，您没有看错，RAID和LVM都可以用鼠标进行创建了，是不是很开心呢？</p>
<p>硬盘存储界面：</p>
<p><img loading="lazy" src="/Distributions/3-15.png" alt=""  />
</p>
<p><strong>4．Networking</strong></p>
<p>既然名为Networking模块，那么动态看网卡的输出和接收值肯定是这个模块的标配功能了。我们不仅可以在这里进行网卡的绑定（Bonding）和聚合（Team），还可以创建桥接网卡及添加VLAN。最下方会单独列出与网卡相关的日志信息。</p>
<p>网卡网络界面：</p>
<p><img loading="lazy" src="/Distributions/4-9.png" alt=""  />
</p>
<p>**5．**Accounts</p>
<p>大家千万别小看Accounts模块，虽然它的账户安全界面有些简陋，只有一个用于创建账户的按钮，但只要点击进入某个用户的管理界面中，马上会发现“别有洞天”——账户管理界面，这个界面中的功能非常丰富，我们在这里可以对用户进行重命名，设置用户的权限，还可以锁定、修改密码以及创建SSH密钥信息。</p>
<p>账户安全界面：</p>
<p><img loading="lazy" src="/Distributions/5-9.png" alt=""  />
</p>
<p>账户管理界面：</p>
<p><img loading="lazy" src="/Distributions/5B.png" alt=""  />
</p>
<p><strong>6．Services</strong></p>
<p>在Services功能模块的界面中，可以查看系统中已有的服务列表和运行状态。单击某一服务，进入该服务的管理界面后，可以对具体的服务进行开启、关闭操作。在Services功能模块中设置了服务并将其加入到开机启动项后，在系统重启后也依然会为用户提供服务。</p>
<p>服务程序界面：</p>
<p><img loading="lazy" src="/Distributions/6-3.png" alt=""  />
</p>
<p>服务管理界面：</p>
<p><img loading="lazy" src="/Distributions/6B.png" alt=""  />
</p>
<p><strong>7．Applications</strong></p>
<p>后期采用Cockpit或红帽订阅服务安装的软件都会显示在这个功能模块中。</p>
<p>软件仓库界面：</p>
<p><img loading="lazy" src="/Distributions/7-3.png" alt=""  />
</p>
<p><strong>8．Diagnostic Report</strong></p>
<p>Diagnostic Report模块的功能是帮助用户收集及分析系统的信息，找到系统出现问题的原因。单击Create Report按钮后大约两分钟左右，会出现报告生成完毕的弹窗。好吧，摊牌了，这个功能其实很鸡肋，就是将sosreport命令做成了一个网页按钮。</p>
<p>报告分析界面：</p>
<p><img loading="lazy" src="/Distributions/8.png" alt=""  />
</p>
<p>报告生成完毕：</p>
<p><img loading="lazy" src="/Distributions/8B.png" alt=""  />
</p>
<p><strong>9．Kernel Dump</strong></p>
<p>Kernel Dump（Kdump）是一个在系统崩溃、死锁或死机时用来收集内核参数的一个服务。举例来说，如果有一天系统崩溃了，这时Kdump服务就会开始工作，将系统的运行状态和内核数据收集到一个名为dump core的文件中，以便后续让运维人员分析并找出问题所在。由于我们在安装系统时没有启动该服务，所以可以等到后续使用时再开启该功能界面。</p>
<p>内核排错界面：</p>
<p><img loading="lazy" src="/Distributions/9-2.png" alt=""  />
</p>
<p><strong>10．SElinux</strong></p>
<p>下图所示为SELinux服务的控制按钮和警告信息界面。</p>
<p>SElinux管理界面：</p>
<p><img loading="lazy" src="/Distributions/10.png" alt=""  />
</p>
<p><strong>11．Software Updates</strong></p>
<p>这里提到的Software Updates并不是我们用来更新其他常规软件的一个界面，而是用来对红帽客户订阅的服务进行更新的界面。用户只有在购买了红帽第三方服务后才能使用这里面的功能。在购买了红帽订阅服务后，用户便可以在这里下载到相应服务程序的最新版本和稳定版本。</p>
<p>更新软件界面：</p>
<p><img loading="lazy" src="/Distributions/11-5.png" alt=""  />
</p>
<p><strong>12．Subscriptions</strong></p>
<p>这里依然是一则红帽公司的“小广告”—如果想成为尊贵的红帽服务用户，要付费购买订阅服务。个人用户无须购买，而且这对我们的后续实验没有任何影响。</p>
<p>订阅服务界面：</p>
<p><img loading="lazy" src="/Distributions/12-3.png" alt=""  />
</p>
<p><strong>12．Terminal</strong></p>
<p>压轴的总是在最后。Cockpit服务提供了Shell终端的在线控制平台，可方便用户通过网页上的终端功能管理服务器。这个功能深受运维人员喜爱。</p>
<p>终端管理界面</p>
<p><img loading="lazy" src="/Distributions/13-2.png" alt=""  />
</p>
<p>至此，相信各位读者已经充分掌握了防火墙的管理能力。防火墙管理工具有很多种，我们任选其一即可。在配置后续的服务前，大家要记得检查网络和防火墙的状态，以避免出现服务明明配置正确，但无法从外部访问的情况，最终影响实验效果。</p>
<h3 id="在-ubuntu-上使用-ufwgufwhttpswwwmyfreaxcomhow-to-setup-a-firewall-with-ufw-on-ubuntu-20-04"><a href="https://www.myfreax.com/how-to-setup-a-firewall-with-ufw-on-ubuntu-20-04/">在 Ubuntu 上使用 UFW&amp;GUFW</a><a hidden class="anchor" aria-hidden="true" href="#在-ubuntu-上使用-ufwgufwhttpswwwmyfreaxcomhow-to-setup-a-firewall-with-ufw-on-ubuntu-20-04">#</a></h3>
<p>Ubuntu 20.04 随附了一个称为UFW（非复杂防火墙）的防火墙配置工具。 它是用于管理iptables防火墙规则的用户友好型前端。 它的主要目标是使防火墙的管理变得更容易，或者顾名思义，变得简单。而GUFW是UFW的图形介面。</p>
<h4 id="检查ufw状态">检查UFW状态<a hidden class="anchor" aria-hidden="true" href="#检查ufw状态">#</a></h4>
<p>UFW默认情况下处于禁用状态。 您可以使用以下命令检查UFW服务的状态：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw status verbose
</code></pre></div><p>输出将显示防火墙状态为非活动：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">Status: inactive
</code></pre></div><p>如果UFW已激活，则输出将类似于以下内容：</p>
<pre tabindex="0"><code>Status: active
</code></pre><h4 id="ufw默认策略">UFW默认策略<a hidden class="anchor" aria-hidden="true" href="#ufw默认策略">#</a></h4>
<p>UFW防火墙的默认行为是阻止所有传入和转发流量，并允许所有出站流量。 这意味着除非您专门打开端口，否则任何尝试访问您的服务器的人都将无法连接。 服务器上运行的应用程序和服务将可以访问外界。</p>
<p>默认策略在<code>/etc/default/ufw</code>文件中定义，可以通过手动修改文件或使用<code>sudo ufw default &lt;policy&gt; &lt;chain&gt;</code>命令来更改。</p>
<p>防火墙策略是建立更复杂和用户定义的规则的基础。 通常，最初的UFW默认策略是一个很好的起点。</p>
<h4 id="应用配置文件">应用配置文件<a hidden class="anchor" aria-hidden="true" href="#应用配置文件">#</a></h4>
<p>应用程序配置文件是INI格式的文本文件，描述了服务并包含该服务的防火墙规则。 在安装软件包期间，会在<code>/etc/ufw/applications.d</code>目录中创建应用程序配置文件。</p>
<p>您可以通过键入以下内容列出服务器上所有可用的应用程序配置文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw app list
Available applications:
  Nginx Full
  Nginx HTTP
  Nginx HTTPS
  OpenSSH
</code></pre></div><p>要查找有关特定配置文件和包含的规则的更多信息，请使用以下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw app info <span style="color:#e6db74">&#39;Nginx Full&#39;</span>
Profile: Nginx Full
Title: Web Server <span style="color:#f92672">(</span>Nginx, HTTP + HTTPS<span style="color:#f92672">)</span>
Description: Small, but very powerful and efficient web server

Ports:
  80,443/tcp
</code></pre></div><p>输出显示“ Nginx Full”配置文件打开了端口<code>80</code>和<code>443</code>。</p>
<p>您也可以为应用创建自定义配置文件。</p>
<h4 id="启用ufw">启用UFW<a hidden class="anchor" aria-hidden="true" href="#启用ufw">#</a></h4>
<p>如果要从远程位置连接到Ubuntu，则在启用UFW防火墙之前，必须明确允许传入的SSH连接。 否则，您将无法连接到计算机。</p>
<p>要将您的UFW防火墙配置为允许传入的SSH连接，请键入以下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw allow ssh
Rules updated
Rules updated <span style="color:#f92672">(</span>v6<span style="color:#f92672">)</span>
</code></pre></div><p>如果SSH在<a href="https://www.myfreax.com/how-to-change-ssh-port-in-linux/">非标准端口</a>上运行，则需要打开该端口。</p>
<p>例如，如果您的ssh守护程序侦听端口<code>7722</code>，请输入以下命令以允许该端口上的连接：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw allow 7722/tcp
</code></pre></div><p>现在已将防火墙配置为允许传入的SSH连接，您可以通过键入以下内容来启用它：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw enable
Command may disrupt existing ssh connections. Proceed with operation <span style="color:#f92672">(</span>y|n<span style="color:#f92672">)</span>? y
Firewall is active and enabled on system startup
</code></pre></div><p>将警告您启用防火墙可能会破坏现有的ssh连接，只需键入<code>y</code>并单击<code>Enter</code>。</p>
<h4 id="打开端口">打开端口<a hidden class="anchor" aria-hidden="true" href="#打开端口">#</a></h4>
<p>根据系统上运行的应用程序，您可能还需要打开其他端口。 打开端口的一般语法如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ufw allow port_number/protocol
</code></pre></div><p>以下是有关如何允许HTTP连接的几种方法。</p>
<p>第一种选择是使用服务名称。 UFW检查<code>/etc/services</code>文件中指定服务的端口和协议：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw allow http
</code></pre></div><p>您还可以指定端口号和协议：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw allow 80/tcp
</code></pre></div><p>如果未给出协议，则UFW会同时为<code>tcp</code>和<code>udp</code>创建规则。</p>
<p>另一个选择是使用应用程序配置文件； 在这种情况下，“ Nginx HTTP”：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw allow <span style="color:#e6db74">&#39;Nginx HTTP&#39;</span>
</code></pre></div><p>UFW还支持使用<code>proto</code>关键字指定协议的另一种语法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw allow proto tcp to any port <span style="color:#ae81ff">80</span>
</code></pre></div><p><strong>端口范围</strong></p>
<p>UFW还允许您打开端口范围。 起始端口和结束端口用冒号（<code>:</code>）分隔，并且您必须指定协议<code>tcp</code>或<code>udp</code>。</p>
<p>例如，如果要同时在<code>tcp</code>和<code>udp</code>上允许端口从<code>7100</code>到<code>7200</code>，则可以运行以下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw allow 7100:7200/tcp
</code></pre></div><p><strong>特定的IP地址和端口</strong></p>
<p>要允许来自给定源IP的所有端口上的连接，请使用<code>from</code>关键字，后跟源地址。</p>
<p>以下是将IP地址列入白名单的示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw allow from 64.63.62.61
</code></pre></div><p>如果要仅允许给定IP地址访问特定端口，请使用<code>to any port</code>关键字，后跟端口号。</p>
<p>例如，要允许IP地址为<code>64.63.62.61</code>的计算机访问端口<code>22</code>，请输入：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw allow from 64.63.62.61 to any port <span style="color:#ae81ff">22</span>
</code></pre></div><p><strong>子网</strong></p>
<p>允许连接到IP地址子网的语法与使用单个IP地址时的语法相同。 唯一的区别是您需要指定子网掩码。</p>
<p>下面是一个示例，显示了如何允许访问从<code>192.168.1.1</code>到<code>192.168.1.254</code>的IP地址到端口<code>3360</code>（<a href="https://www.myfreax.com/how-to-install-mysql-on-ubuntu-20-04/"> MySQL </a>）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw allow from 192.168.1.0/24 to any port <span style="color:#ae81ff">3306</span>
</code></pre></div><p><strong>特定网络接口</strong></p>
<p>要允许在特定的网络接口上进行连接，请使用<code>in on</code>关键字，后跟网络接口(网卡)的名称：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw allow in on eth2 to any port <span style="color:#ae81ff">3306</span>
</code></pre></div><h4 id="拒绝连接">拒绝连接<a hidden class="anchor" aria-hidden="true" href="#拒绝连接">#</a></h4>
<p>所有传入连接的默认策略均设置为<code>deny</code>，如果您未更改默认策略，除非您专门打开连接，否则UFW会阻止所有传入连接。</p>
<p>撰写拒绝规则与撰写允许规则相同； 您只需要使用<code>deny</code>关键字而不是<code>allow</code>。</p>
<p>假设您打开了端口<code>80</code>和<code>443</code>，并且服务器受到<code>23.24.25.0/24</code>网络的攻击。 要拒绝来自<code>23.24.25.0/24</code>的所有连接，您可以运行以下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw deny from 23.24.25.0/24
</code></pre></div><p>以下是拒绝访问<code>23.24.25.0/24</code>中的端口<code>80</code>和<code>443</code>的示例，您可以使用以下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw deny proto tcp from 23.24.25.0/24 to any port 80,443
</code></pre></div><h4 id="删除ufw规则">删除UFW规则<a hidden class="anchor" aria-hidden="true" href="#删除ufw规则">#</a></h4>
<p>有两种方法可以通过规则编号和指定实际规则来删除UFW规则。</p>
<p>按规则号删除规则比较容易，尤其是当您不熟悉UFW时。 要首先通过规则编号删除规则，您需要找到要删除的规则的编号。 要获取编号规则的列表，请使用<code>ufw status numbered</code>命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw status numbered
Status: active

     To                         Action      From
     --                         ------      ----
<span style="color:#f92672">[</span> 1<span style="color:#f92672">]</span> 22/tcp                     ALLOW IN    Anywhere
<span style="color:#f92672">[</span> 2<span style="color:#f92672">]</span> 80/tcp                     ALLOW IN    Anywhere
<span style="color:#f92672">[</span> 3<span style="color:#f92672">]</span> 8080/tcp                   ALLOW IN    Anywhere
</code></pre></div><p>要删除规则号<code>3</code>，该规则号允许连接到端口<code>8080</code>，请输入：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw delete <span style="color:#ae81ff">3</span>
</code></pre></div><p>第二种方法是通过指定实际规则来删除规则。 例如，如果您添加了打开端口<code>8069</code>的规则，则可以使用以下命令将其删除：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw delete allow <span style="color:#ae81ff">8069</span>
</code></pre></div><h4 id="禁用ufw">禁用UFW<a hidden class="anchor" aria-hidden="true" href="#禁用ufw">#</a></h4>
<p>如果出于任何原因要停止UFW并停用所有规则，则可以使用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw disable
</code></pre></div><p>以后，如果您想重新启用UTF并激活所有规则，只需键入：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw enable
</code></pre></div><h4 id="重设ufw">重设UFW<a hidden class="anchor" aria-hidden="true" href="#重设ufw">#</a></h4>
<p>重置UFW将禁用UFW，并删除所有活动规则。 如果您想还原所有更改并重新开始，这将很有帮助。</p>
<p>要重置UFW，请输入以下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw reset
</code></pre></div><h4 id="ip伪装">IP伪装<a hidden class="anchor" aria-hidden="true" href="#ip伪装">#</a></h4>
<p>IP伪装是Linux内核中NAT（网络地址转换）的一种变体，它通过重写源IP地址和目标IP地址和端口来转换网络流量。 借助IP伪装，您可以使用一台充当网关的Linux计算机，允许专用网络中的一台或多台计算机与Internet通信。</p>
<p>使用UFW配置IP伪装涉及几个步骤。</p>
<p>首先，您需要启用IP转发。 为此，请打开<code>/etc/ufw/sysctl.conf</code>文件，查找并取消注释以下行：<code>net.ipv4.ip_forward = 1</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo nano /etc/ufw/sysctl.conf
net/ipv4/ip_forward<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</code></pre></div><p>接下来，您需要配置UFW以允许转发数据包。 打开UFW配置文件，找到<code>DEFAULT_FORWARD_POLICY</code>键，然后将值从<code>DROP</code>更改为<code>ACCEPT</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo nano /etc/default/ufw
DEFAULT_FORWARD_POLICY<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;ACCEPT&#34;</span>
</code></pre></div><p>现在，您需要在<code>nat</code>表中设置<code>POSTROUTING</code>链的默认策略和伪装规则。 为此，请打开<code>/etc/ufw/before.rules</code>文件，附加以下几行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo nano /etc/ufw/before.rules
<span style="color:#75715e">#NAT table rules</span>
*nat
:POSTROUTING ACCEPT <span style="color:#f92672">[</span>0:0<span style="color:#f92672">]</span>

<span style="color:#75715e"># Forward traffic through eth0 - Change to public network interface</span>
-A POSTROUTING -s 10.8.0.0/16 -o eth0 -j MASQUERADE

<span style="color:#75715e"># don&#39;t delete the &#39;COMMIT&#39; line or these rules won&#39;t be processed</span>
COMMIT
</code></pre></div><p>别忘了在<code>-A POSTROUTING</code>行中替换<code>eth0</code>以匹配公共网络接口的名称：</p>
<p>完成后，保存并关闭文件。</p>
<p>最后，通过禁用和重新启用UFW重新加载UFW规则：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw disable
$ sudo ufw e
</code></pre></div><h2 id="udevhttpswwwjianshucompf9385d5703a7"><a href="https://www.jianshu.com/p/f9385d5703a7">udev</a><a hidden class="anchor" aria-hidden="true" href="#udevhttpswwwjianshucompf9385d5703a7">#</a></h2>
<p>如果你使用Linux比较长时间了，那你就知道，在对待设备文件这块，Linux改变了几次策略。在Linux早期，设备文件仅仅是是一些带有适当的属性集的普通文件，它由mknod命令创建，文件存放在/dev目录下。后来，采用了devfs, 一个基于内核的动态设备文件系统，他首次出现在2.3.46内核中。Mandrake，Gentoo等Linux分发版本采用了这种方式。devfs创建 的设备文件是动态的。但是devfs有一些严重的限制，从2.6.13版本后移走了。目前取代他的便是文本要提到的udev－－一个用户空间程序。</p>
<p>目前很多的Linux分发版本采纳了udev的方式，因为它在Linux设备访问，特别是那些对设备有极端需求的站点(比如需要控制上千个硬盘)和热插拔设备(比如USB摄像头和MP3播放器)上解决了几个问题。下面我我们来看看如何管理udev设备。</p>
<p>实际上，对于那些为磁盘，终端设备等准备的标准配置文件而言，你不需要修改什么。但是，你需要了解udev配置来使用新的或者外来设备，如果不修改配置， 这些设备可能无法访问，或者说Linux可能会采用不恰当的名字，属组或权限来创建这些设备文件。你可能也想知道如何修改RS－232串口，音频设备等文件的属组或者权限。这点在实际的Linux实施中是会遇到的。</p>
<h3 id="为什么使用udev">为什么使用udev<a hidden class="anchor" aria-hidden="true" href="#为什么使用udev">#</a></h3>
<p>在此之前的设备文件管理方法(静态文件和devfs)有几个缺点：</p>
<ol>
<li>不确定的设备映射。特别是那些动态设备，比如USB设备，设备文件到实际设备的映射并不可靠和确定。举一个例子：如果你有两个USB打印机。一个可能称 为/dev/usb/lp0,另外一个便是/dev/usb/lp1。但是到底哪个是哪个并不清楚，lp0,lp1和实际的设备没有一一对应的关系，因为 他可能因为发现设备的顺序，打印机本身关闭等原因而导致这种映射并不确定。理想的方式应该是：两个打印机应该采用基于他们的序列号或者其他标识信息的唯一 设备文件来映射。但是静态文件和devfs都无法做到这点。</li>
<li>没有足够的主/辅设备号。我们知道，每一个设备文件是有两个8位的数字：一个是主设备号 ，另外一个是辅设备号来分配的。这两个8位的数字加上设备类型(块设备或者字符设备)来唯一标识一个设备。不幸的是，关联这些身边的的数字并不足够。</li>
<li>/dev目录下文件太多。一个系统采用静态设备文件关联的方式，那么这个目录下的文件必然是足够多。而同时你又不知道在你的系统上到底有那些设备文件是激活的。</li>
<li>命名不够灵活。尽管devfs解决了以前的一些问题，但是它自身又带来了一些问题。其中一个就是命名不够灵活；你别想非常简单的就能修改设备文件的名字。缺省的devfs命令机制本身也很奇怪，他需要修改大量的配置文件和程序。</li>
<li>内核内存使用，devfs特有的另外一个问题是，作为内核驱动模块，devfs需要消耗大量的内存，特别当系统上有大量的设备时(比如上面我们提到的系统一个上有好几千磁盘时)</li>
</ol>
<p>udev的目标是想解决上面提到的这些问题，他通采用用户空间(user-space)工具来管理/dev/目录树，他和文件系统分开。知道如何改变缺省配置能让你之大如何定制自己的系统，比如创建设备字符连接，改变设备文件属组，权限等。</p>
<h3 id="udev配置文件">udev配置文件<a hidden class="anchor" aria-hidden="true" href="#udev配置文件">#</a></h3>
<p>主要的udev配置文件是/etc/udev/udev.conf。这个文件通常很短，他可能只是包含几行#开头的注释，然后有几行选项：</p>
<pre tabindex="0"><code>udev_root=“/dev/”
udev_rules=“/etc/udev/rules.d/”
udev_log=“err“
</code></pre><p>上面的第二行非常重要，因为他表示udev规则存储的目录，这个目录存储的是以.rules结束的文件。每一个文件处理一系列规则来帮助udev分配名字给设备文件以保证能被内核识别。</p>
<p>你的/etc/udev/rules.d下面可能有好几个udev规则文件，这些文件一部分是udev包安装的，另外一部分则是可能是别的硬件或者软件包 生成的。比如在Fedora Core 5系统上，sane-backends包就会安装60-libsane.rules文件，另外initscripts包会安装60-net.rules文 件。这些规则文件的文件名通常是两个数字开头，它表示系统应用该规则的顺序。</p>
<p>规则文件里的规则有一系列的键/值对组成，键/值对之间用逗号(,)分割。每一个键或者是用户匹配键，或者是一个赋值键。匹配键确定规则是否被应用，而赋 值键表示分配某值给该键。这些值将影响udev创建的设备文件。匹配键和赋值键操作符解释见下表：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>匹配或赋值</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>==</td>
<td>匹配</td>
<td>相等比较</td>
</tr>
<tr>
<td>!=</td>
<td>匹配</td>
<td>不等比较</td>
</tr>
<tr>
<td>=</td>
<td>赋值</td>
<td>分配一个特定的值给该键，他可以覆盖之前的赋值。</td>
</tr>
<tr>
<td>+=</td>
<td>赋值</td>
<td>追加特定的值给已经存在的键</td>
</tr>
<tr>
<td>:=</td>
<td>赋值</td>
<td>分配一个特定的值给该键，后面的规则不可能覆盖它。</td>
</tr>
</tbody>
</table>
<p>这有点类似我们常见的编程语言，比如C语言。只是这里的键一次可以处理多个值。有一些键在udev规则文件里经常出现，这些键的值可以使用通配符(*,?,甚至范围，比如[0-9])，这些常用键列举如下：</p>
<table>
<thead>
<tr>
<th>键</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ACTION</td>
<td>一个时间活动的名字，比如add，当设备增加的时候</td>
</tr>
<tr>
<td>KERNEL</td>
<td>在内核里看到的设备名字，比如sd*表示任意SCSI磁盘设备</td>
</tr>
<tr>
<td>DEVPATH</td>
<td>内核设备路径，比如/devices/*</td>
</tr>
<tr>
<td>SUBSYSTEM</td>
<td>子系统名字，比如sound,net</td>
</tr>
<tr>
<td>BUS</td>
<td>总线的名字，比如IDE,USB</td>
</tr>
<tr>
<td>DRIVER</td>
<td>设备驱动的名字，比如ide-cdromID                       独立于内核名字的设备名字</td>
</tr>
<tr>
<td>SYSFS{ value}</td>
<td>sysfs属性值，他可以表示任意</td>
</tr>
<tr>
<td>ENV{ key}</td>
<td>环境变量，可以表示任意</td>
</tr>
<tr>
<td>PROGRAM</td>
<td>可执行的外部程序，如果程序返回0值，该键则认为为真(true)</td>
</tr>
<tr>
<td>RESULT</td>
<td>上一个PROGRAM调用返回的标准输出。</td>
</tr>
<tr>
<td>NAME</td>
<td>根据这个规则创建的设备文件的文件名。注意：仅仅第一行的NAME描述是有效的，后面的均忽略。 如果你想使用使用两个以上的名字来访问一个设备的话，可以考虑SYMLINK键。</td>
</tr>
<tr>
<td>SYMLINK</td>
<td>根据规则创建的字符连接名</td>
</tr>
<tr>
<td>OWNER</td>
<td>设备文件的属组</td>
</tr>
<tr>
<td>GROUP</td>
<td>设备文件所在的组。</td>
</tr>
<tr>
<td>MODE</td>
<td>设备文件的权限，采用8进制</td>
</tr>
<tr>
<td>RUN</td>
<td>为设备而执行的程序列表</td>
</tr>
<tr>
<td>LABEL</td>
<td>在配置文件里为内部控制而采用的名字标签(下下面的GOTO服务)</td>
</tr>
<tr>
<td>GOTO</td>
<td>跳到匹配的规则（通过LABEL来标识），有点类似程序语言中的GOTO</td>
</tr>
<tr>
<td>IMPORT{ type}</td>
<td>导入一个文件或者一个程序执行后而生成的规则集到当前文件</td>
</tr>
<tr>
<td>WAIT_FOR_SYSFS</td>
<td>等待一个特定的设备文件的创建。主要是用作时序和依赖问题。</td>
</tr>
<tr>
<td>PTIONS</td>
<td>特定的选项： last_rule 对这类设备终端规则执行； ignore_device 忽略当前规则； ignore_remove 忽略接下来的并移走请求。all_partitions 为所有的磁盘分区创建设备文件。</td>
</tr>
</tbody>
</table>
<p>我们给出一个列子来解释如何使用这些键。下面的例子来自Fedora Core 5系统的标准配置文件。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">KERNEL<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;*&#34;</span>, OWNER<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;root&#34;</span> GROUP<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;root&#34;</span>, MODE<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;0600&#34;</span> 
KERNEL<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;tty&#34;</span>, NAME<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;%k&#34;</span>, GROUP<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;tty&#34;</span>, MODE<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;0666&#34;</span>, OPTIONS<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;last_rule&#34;</span>
KERNEL<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;scd[0-9]*&#34;</span>, SYMLINK<span style="color:#f92672">+=</span><span style="color:#e6db74">&#34;cdrom cdrom-%k&#34;</span>
KERNEL<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;hd[a-z]&#34;</span>, BUS<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;ide&#34;</span>, SYSFS<span style="color:#f92672">{</span>removable<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;1&#34;</span>, SYSFS<span style="color:#f92672">{</span>device/media<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;cdrom&#34;</span>, SYMLINK<span style="color:#f92672">+=</span><span style="color:#e6db74">&#34;cdrom cdrom-%k&#34;</span> 
ACTION<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;add&#34;</span>, SUBSYSTEM<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;scsi_device&#34;</span>, RUN<span style="color:#f92672">+=</span><span style="color:#e6db74">&#34;/sbin/modprobe sg&#34;</span>
</code></pre></div><p>上面的例子给出了5个规则，每一个都是KERNEL或者ACTION键开头：</p>
<ul>
<li>第一个规则是缺省的，他匹配任意被内核识别到的设备，然后设定这些设备的属组是root，组是root，访问权限模式是0600(-rw——-)。这也是一个安全的缺省设置保证所有的设备在默认情况下只有root可以读写</li>
<li>第二个规则也是比较典型的规则了。它匹配终端设备(tty)，然后设置新的权限为0600，所在的组是tty。它也设置了一个特别的设备文件名:%K。在这里例子里，%k代表设备的内核名字。那也就意味着内核识别出这些设备是什么名字，就创建什么样的设备文件名。</li>
<li>第三行开始的KERNEL==”scd[0-9]*”,表示 SCSI CD-ROM 驱动. 它创建一对设备符号连接：cdrom和cdrom-%k。</li>
<li>第四行，开始的 KERNEL==”hd[a-z]“, 表示ATA CDROM驱动器。这个规则创建和上面的规则相同的符号连接。ATA CDROM驱动器需要sysfs值以来区别别的ATA设备，因为SCSI CDROM可以被内核唯一识别。.</li>
<li>第五行以 ACTION==”add”开始，它告诉udev增加 /sbin/modprobe sg 到命令列表，当任意SCSI设备增加到系统后，这些命令将执行。其效果就是计算机应该会增加sg内核模块来侦测新的SCSI设备。</li>
</ul>
<p>当然，上面仅仅是一小部分例子，如果你的系统采用了udev方式，那你应该可以看到更多的规则。如果你想修改设备的权限或者创建信的符号连接，那么你需要熟读这些规则，特别是要仔细注意你修改的那些与之相关的设备。</p>
<h3 id="修改你的udev配置">修改你的udev配置<a hidden class="anchor" aria-hidden="true" href="#修改你的udev配置">#</a></h3>
<p>在修改udev配置之前，我们一定要仔细，通常的考虑是：你最好不要修改系统预置的那些规则，特别不要指定影响非常广泛的配置，比如上面例子中的第一行。不正确的配置可能会导致严重的系统问题或者系统根本就无法这个正确的访问设备。</p>
<p>而我们正确的做法应该是在/etc/udev/rules.d/下创建一个新的规则文件。确定你给出的文件的后缀是rules文件名给出的数字序列应该比标准配置文件高。比如，你可以创建一个名为99-my-udev.rules的规则文件。在你的规则文件中，你可以指定任何你想修改的配置，比如，假设你 修改修改floppy设备的所在组，还准备创建一个新的符号连接/dev/floppy，那你可以这么写：</p>
<pre tabindex="0"><code class="language-undefined" data-lang="undefined">KERNEL==”fd[0-9]*“, GROUP=“users“, SYMLINK+=“floppy“
</code></pre><p>有些发行版本，比如Fedora，采用了外部脚本来修改某些特定设备的属组，组关系和权限。因此上面的改动可能并不见得生效。如果你遇到了这个问题，你就需要跟踪和修改这个脚本来达到你的目的。或者你可以修改PROGRAM或RUN键的值来做到这点。</p>
<p>某些规则的修改可能需要更深的挖掘。比如，你可能想在一个设备上使用sysfs信息来唯一标识一个设备。这些信息最好通过udevinfo命令来获取。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ruby" data-lang="ruby"><span style="color:#960050;background-color:#1e0010">$</span> udevinfo <span style="color:#960050;background-color:#1e0010">–</span>a <span style="color:#960050;background-color:#1e0010">–</span>p <span style="color:#960050;background-color:#1e0010">$</span>(udevinfo <span style="color:#960050;background-color:#1e0010">–</span>q path <span style="color:#960050;background-color:#1e0010">–</span>n <span style="color:#e6db74">/dev/</span>hda)
</code></pre></div><p>上面的命令两次使用udevinfo：一次是返回sysfs设备路径(他通常和我们看到的Linux设备文件名所在路径－－/dev/hda－－不同)；第 二次才是查询这个设备路径，结果将是非常常的syfs信息汇总。你可以找到最够的信息来唯一标志你的设备，你可以采用适当的替换udev配置文件中的 SYSFS选项。下面的结果就是上面的命令输出</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@localhost rules.d<span style="color:#f92672">]</span><span style="color:#75715e"># udevinfo -a -p $(udevinfo -q path        -n      /dev/hda1)</span>
Udevinfo starts with the device specified by the devpath and <span style="color:#66d9ef">then</span> walks up the chain of
parent devices. It prints <span style="color:#66d9ef">for</span> every device found,all possible attributes in the udev rules
key format. A rule to match, can be composed by the attributes of the device and the
attributes from one single parent device.

looking at device <span style="color:#e6db74">&#39;/block/hda/hda1&#39;</span>:     
KERNEL<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;hda1&#34;</span>     SUBSYSTEM<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;block&#34;</span>     DRIVER<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;&#34;</span>        
ATTR<span style="color:#f92672">{</span>stat<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;        1133         2268            2            4&#34;</span>         ATTR<span style="color:#f92672">{</span>size<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;208782&#34;</span>
ATTR<span style="color:#f92672">{</span>start<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;63&#34;</span>         ATTR<span style="color:#f92672">{</span>dev<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;3:1&#34;</span>        looking at parent device <span style="color:#e6db74">&#39;/block/hda&#39;</span>:  

KERNELS<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;hda&#34;</span>     SUBSYSTEMS<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;block&#34;</span>     DRIVERS<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;&#34;</span>        
ATTRS<span style="color:#f92672">{</span>stat<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;28905 18814 1234781 302540 34087 133247 849708 981336 0 218340 1283968&#34;</span>
ATTRS<span style="color:#f92672">{</span>size<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;117210240&#34;</span>         ATTRS<span style="color:#f92672">{</span>removable<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;0&#34;</span>        
ATTRS<span style="color:#f92672">{</span>range<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;64&#34;</span>         ATTRS<span style="color:#f92672">{</span>dev<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;3:0&#34;</span>

looking at parent device <span style="color:#e6db74">&#39;/devices/pci0000:00/0000:00:1f.1/ide0/0.0&#39;</span>:    

KERNELS<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;0.0&#34;</span>     SUBSYSTEMS<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;ide&#34;</span>     DRIVERS<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;ide-disk&#34;</span>        
ATTRS<span style="color:#f92672">{</span>modalias<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;ide:m-disk&#34;</span>         ATTRS<span style="color:#f92672">{</span>drivename<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;hda&#34;</span>       
ATTRS<span style="color:#f92672">{</span>media<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;disk&#34;</span>       
looking at parent device <span style="color:#e6db74">&#39;/devices/pci0000:00/0000:00:1f.1/ide0&#39;</span>:    

KERNELS<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;ide0&#34;</span>     SUBSYSTEMS<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;&#34;</span>     DRIVERS<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;&#34;</span>       
looking at parent device <span style="color:#e6db74">&#39;/devices/pci0000:00/0000:00:1f.1&#39;</span>:     
KERNELS<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;0000:00:1f.1&#34;</span>     SUBSYSTEMS<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;pci&#34;</span>     DRIVERS<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;PIIX_IDE&#34;</span>        
ATTRS<span style="color:#f92672">{</span>broken_parity_status<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;0&#34;</span>         ATTRS<span style="color:#f92672">{</span>enable<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;1&#34;</span>        
ATTRS<span style="color:#f92672">{</span>modalias<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;pci:v00008086d000024CAsv0000144Dsd0000C009bc01sc01i8a&#34;</span>
ATTRS<span style="color:#f92672">{</span>local_cpus<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;1&#34;</span>         ATTRS<span style="color:#f92672">{</span>irq<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;11&#34;</span>         ATTRS<span style="color:#f92672">{</span>class<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;0x01018a&#34;</span>
ATTRS<span style="color:#f92672">{</span>subsystem_device<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;0xc009&#34;</span>         ATTRS<span style="color:#f92672">{</span>subsystem_vendor<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;0x144d&#34;</span>
ATTRS<span style="color:#f92672">{</span>device<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;0x24ca&#34;</span>         ATTRS<span style="color:#f92672">{</span>vendor<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;0x8086&#34;</span>       
looking at parent device <span style="color:#e6db74">&#39;/devices/pci0000:00&#39;</span>:    

KERNELS<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;pci0000:00&#34;</span>     SUBSYSTEMS<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;&#34;</span>     DRIVERS<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;&#34;</span> 
</code></pre></div><p>举一个例子：假设你想修改USB扫描仪的配置。通过一系列的尝试，你已经为这个扫描仪标识了Linux设备文件(每次打开扫描仪时，名字都会变)。你可以使 用上面的命令替换这个正确的Linux设备文件名，然后定位输出的采用SYSFS{idVendor}行和SYSFS{idProduct}行。最后你可 以使用这些信息来为这个扫描仪创建新的选项。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">SYSFS{idVendor}==<span style="color:#e6db74">&#34;0686&#34;</span>, SYSFS{idProduct}==<span style="color:#e6db74">&#34;400e&#34;</span>, SYMLINK+=<span style="color:#e6db74">&#34;scanner&#34;</span>, MODE=<span style="color:#e6db74">&#34;0664&#34;</span>, <span style="color:#66d9ef">group</span>=<span style="color:#e6db74">&#34;scanner&#34;</span>
</code></pre></div><p>上面的例子表示将扫描仪的组设置为scanner，访问权限设置为0664,同时创建一个/dev/scanner的符号连接。</p>
<h3 id="mounting-usb-automatically--having-usbs-label-as-mountpointhttpsunixstackexchangecomquestions119973mounting-usb-automatically-having-usbs-label-as-mountpoint"><a href="https://unix.stackexchange.com/questions/119973/mounting-usb-automatically-having-usbs-label-as-mountpoint">Mounting usb automatically &amp; having usb&rsquo;s label as mountpoint</a><a hidden class="anchor" aria-hidden="true" href="#mounting-usb-automatically--having-usbs-label-as-mountpointhttpsunixstackexchangecomquestions119973mounting-usb-automatically-having-usbs-label-as-mountpoint">#</a></h3>
<p><strong>Note for Ubuntu Server 11.10:</strong> This script fails on Ubuntu Server 11.10 due to the obsolete <code>vol_id</code> command. <code>vol_id</code> has been superseded by <code>blkid</code>. To fix the script, replace &ldquo;vol_id&rdquo; by &ldquo;blkid -o udev&rdquo; in the <code>udev-auto-mount.sh</code> script.</p>
<p>I&rsquo;ve been banging my head around this for a while now, and I think I&rsquo;ve found a working solution. This is developed and tested on a Debian-based system, so it should work on Ubuntu. I&rsquo;ll point out the assumptions it makes so it can be adapted to other systems as well.</p>
<ul>
<li>It will automatically mount USB drives on plugin, and shouldn&rsquo;t take much to adapt for Firewire.</li>
<li>It uses UDEV, so no monkeying with HAL/DeviceKit/GNOME-Anything.</li>
<li>It automagically creates a <code>/media/LABEL</code> directory to mount the device to.</li>
<li>However, it <strong>may</strong> interfere with other automounters; I can&rsquo;t test for that. I expect that, with Gnome-VFS active, both may try to do the mount &hellip; if Gnome-VFS fails the mount, it might not configure a desktop icon. Unmounting from Gnome should be possible, but might require <code>gksudo</code> or similar.</li>
</ul>
<p>I have not tested this on system boot, but the only reason I can see that it might not work is if it tries to mount the USB drive before the system is ready for mounts. If that&rsquo;s the case, you&rsquo;ll probably need one additional tweak to the mount script. (I&rsquo;m <a href="https://serverfault.com/questions/80912/understanding-the-linux-boot-process-subsystem-initialization-udev-rules">checking with ServerFault</a> to see if there&rsquo;s any advice, but not much interest in it over there.)</p>
<p>On to it, then.</p>
<h4 id="udev-references">UDEV references<a hidden class="anchor" aria-hidden="true" href="#udev-references">#</a></h4>
<ul>
<li><a href="http://www.reactivated.net/writing_udev_rules.html">Writing udev Rules</a> (<em>the</em> reference for udev rules)</li>
<li><a href="http://linux.die.net/man/8/udev">man udev</a> (see your system for the latest version)</li>
<li><a href="http://linux.die.net/man/8/udevadm">man udevadm</a> (udev admin tool; again see your system for latest)</li>
<li><a href="http://ninetynine.be/blog/2009/03/ubuntu-backup-to-usb-drive-on-mount/">Backup to USB drive on mount</a> (completely different problem, but helpful for understanding the solution)</li>
</ul>
<h4 id="background-udev-whuzzat">Background (UDEV? Whuzzat?)<a hidden class="anchor" aria-hidden="true" href="#background-udev-whuzzat">#</a></h4>
<p>UDEV is the kernel&rsquo;s hotplug system. It&rsquo;s what automagically configures the proper devices and device symlinks (eg <code>/dev/disk/by-label/&lt;LABEL&gt;</code>), both at boot time and for devices added while the system is running.</p>
<p>D-Bus and HAL are used for sending hardware events to listeners like Desktop Environments. So when you log into GNOME and insert a CD or plug in a USB drive, that event follows this chain:</p>
<pre tabindex="0"><code>kernel -&gt; udev -&gt; dbus -&gt; hal -&gt; gnome-vfs/nautilus (mount)
</code></pre><p>And presto, your drive gets mounted. But in a headless system, we don&rsquo;t want to have to log in to get the benefits of automounting.</p>
<h4 id="udev-rules">Udev Rules<a hidden class="anchor" aria-hidden="true" href="#udev-rules">#</a></h4>
<p>Since UDEV lets us write rules and run programs on device insertion, this is an ideal choice. We&rsquo;re going to take advantage of Debian/Ubuntu&rsquo;s existing rules, let them setup the <code>/dev/disk/by-label/&lt;LABEL&gt;</code> symlink for us, and add another rule that will mount the device for us.</p>
<p>UDEV&rsquo;s rules are kept in <code>/etc/udev/rules.d</code> (and <code>/lib/udev/rules.d</code> on Karmic), and are processed in numerical order. Any file not starting with a number gets processed after the numbered files. On my system, HAL rules are in a file called <code>90-hal.rules</code>, so I put my rules in <code>89-local.rules</code> so they get processed before they get to HAL. Primarily, you need to make sure these rules happen after the <code>60-persistent-storage.rules</code>. <code>local.rules</code> may be good enough.</p>
<p><strong>Put this in your new rules file:</strong></p>
<pre tabindex="0"><code># /etc/udev/rules.d/local.rules 
# /etc/udev/rules.d/89-local.rules
# ADD rule: if we have a valid ID_FS_LABEL_ENC, and it's USB, mkdir and mount
ENV{ID_FS_LABEL_ENC}==&quot;?*&quot;,   ACTION==&quot;add&quot;,      SUBSYSTEMS==&quot;usb&quot;, \
         RUN+=&quot;/usr/local/sbin/udev-automounter.sh %k&quot;
</code></pre><ul>
<li>Make sure there&rsquo;s no spaces after the <code>\</code>, just a <code>newline</code> (<code>\n</code>).</li>
<li>Change <code>SUBSYSTEMS==&quot;usb&quot;</code> to <code>SUBSYSTEMS==&quot;usb|ieee1394&quot;</code> for Firewire support.</li>
<li>If you want the device to always be owned by a particular user, add an <code>OWNER=&quot;username&quot;</code> clause. If you just need the files owned by a particular user, tweak the mount script instead.</li>
</ul>
<p><strong>Reading the Rule</strong></p>
<p>This adds a program to run to the device&rsquo;s list of programs to run. It identifies USB partition devices by <code>&lt;LABEL&gt;</code>, then passes this information to a script that performs the mount. Specifically, this rule is matching:</p>
<ol>
<li>
<p><strong><code>ENV{ID_FS_LABEL_ENC}==&quot;?\*&quot;</code></strong> &ndash; an environment variable set by an earlier system rule. Doesn&rsquo;t exist for non-filesystems, so that&rsquo;s why we check for it. We actually want to use <code>ID_FS_LABEL</code> for the mount point, but I haven&rsquo;t convinced UDEV to escape it for me, so we&rsquo;ll let the mount script handle that.</p>
<p>This and other environment variables are obtained by udev using the <code>vol_id</code> command (<a href="https://administratosphere.wordpress.com/tag/vol_id/">deprecated</a>). It&rsquo;s a handy tool to see nice quick details on a partition:</p>
<pre tabindex="0"><code>$ sudo vol_id /dev/sdc1
ID_FS_TYPE=ext2
ID_FS_UUID=a40d282a-4a24-4593-a0ab-6f2600f920dd
ID_FS_LABEL=Travel Dawgs
ID_FS_LABEL_ENC=Travel\x20Dawgs
ID_FS_LABEL_SAFE=Travel_Dawgs
</code></pre></li>
<li>
<p><strong><code>ACTION==&quot;add&quot;</code></strong> &ndash; only match <code>add</code> events&hellip;</p>
</li>
<li>
<p><strong><code>SUBSYSTEMS==&quot;usb&quot;</code></strong> &ndash; only match devices that are on the USB bus. We use <code>SUBSYSTEMS</code> here because this matches against our device&rsquo;s parents; the device we&rsquo;re interested in will actually be SUBSYSTEM==&ldquo;scsi&rdquo;. Matching against a parent USB device avoids adding our program to the internal drives.</p>
</li>
<li>
<p><strong><code>RUN+=&quot;...&quot;</code></strong> &ndash; not a match, but an action: add this program to the list of programs to run. In the program&rsquo;s arguments, <code>%k</code> gets expanded to the device name (eg <code>sdc1</code>, not <code>/dev/sdc1</code>) and <code>$env{FOO}</code> gets the contents of environment variable FOO.</p>
</li>
</ol>
<p><strong>Testing the Rule</strong></p>
<p>The first reference link (above) is an excellent UDEV tutorial, but it&rsquo;s slightly out of date. The programs it runs for testing your rules (<code>udevtest</code> in particular) have been replaced by the catch-all <code>udevadm</code> utility.</p>
<p>After you&rsquo;ve added the rule, plug in your device. Give it a few seconds, then check to see what device it&rsquo;s been assigned to with:</p>
<pre tabindex="0"><code>$ ls -l /dev/disk/by-label/*
lrwxrwxrwx 1 root root 10 2009-10-25 07:27 label_Foo -&gt; ../../sda1
lrwxrwxrwx 1 root root 10 2009-10-25 07:27 label_Bar -&gt; ../../sdb1
lrwxrwxrwx 1 root root 10 2009-10-25 07:27 label_Baz -&gt; ../../sdc1
</code></pre><p>If your removeable drive contains <code>label_Baz</code>, it&rsquo;s on device <code>sdc1</code>. Run this and look at the output towards the end:</p>
<pre tabindex="0"><code>$ sudo udevadm test /sys/block/sdc/sdc1
parse_file: reading (...)                           (many lines about files it reads)
import_uevent_var: import into environment: (...)   (many lines about env variables)
(...)                                               (many lines tracing rule matches &amp; programs run)
update_link: found 1 devices with name 'disk/by-label/LABEL_BAZ'
update_link: found '/block/sdc/sdc1' for 'disk/by-label/LABEL_BAZ'
update_link: compare (our own) priority of '/block/sdc/sdc1' 0 &gt;= 0
update_link: 'disk/by-label/LABEL_BAZ' with target 'sdc1' has the highest priority 0, create it
udevtest: run: '/usr/local/sbin/udev-automounter.sh sdc1 LABEL_BAZ'
udevtest: run: 'socket:/org/freedesktop/hal/udev_event'
udevtest: run: 'socket:@/org/kernel/udev/monitor'
</code></pre><p>Look for the script name from our <strong><code>RUN+=</code></strong> rule in the last few lines (3rd from the bottom in this example). You can see the arguments that would be used for this device. You can run that command now to check that the arguments are sound; if it works on your commandline, it should work automatically when a device is inserted.</p>
<p>You can also monitor UDEV events in realtime: run <code>sudo udevadm monitor</code> (see <code>man udevadm</code> for details on the switches). Then just plug in a new device and watch events scroll by. (Probably overkill unless you&rsquo;re into really low-level details&hellip;)</p>
<p><strong>Reloading the Rules</strong></p>
<p>Once you&rsquo;ve verified the rule is getting read properly, you need to tell UDEV to reload its rules so the new one takes effect. Use any of these methods (if the first doesn&rsquo;t work, the second should&hellip; but try the first first):</p>
<ul>
<li>run <code>sudo udevadm control --reload-rules</code></li>
<li>run <code>sudo /etc/init.d/udev reload</code></li>
<li>reboot</li>
</ul>
<h4 id="script-actually-2-scripts">Script! Actually, 2 Scripts&hellip;<a hidden class="anchor" aria-hidden="true" href="#script-actually-2-scripts">#</a></h4>
<p><strong>Here&rsquo;s the first script.</strong> Since the program we run needs to complete quickly, this just spins the second script off in the background. Put this in <code>/usr/local/sbin/udev-automounter.sh</code>:</p>
<pre tabindex="0"><code>#!/bin/sh
#
# USAGE: usb-automounter.sh DEVICE 
#   DEVICE   is the actual device node at /dev/DEVICE

/usr/local/sbin/udev-auto-mount.sh ${1} &amp;
</code></pre><p><strong>Here&rsquo;s the second script.</strong> This does a bit more input checking. Put this in <code>/usr/local/sbin/udev-auto-mount.sh</code>. You may want to tweak the mount options below. This script now handles finding the partition LABEL on its own; UDEV only sends the DEVICE name.</p>
<p><strong>If there&rsquo;s a problem mounting drives at boot-time</strong>, you can put a nice long <code>sleep 60</code> in this script, to give the system time to come all the way up before the script attempts to mount the drive.</p>
<p>I&rsquo;ve given a suggestion in the comments for how to check (run <code>ps</code> to see if a webserver is running), but you&rsquo;ll want to tweak that for your system. I think most any network servers you might be using would suffice for this purpose &ndash; nfsd, smbd, apache, etc. The risk, of course, is that the mount script will fail if the service isn&rsquo;t running, so maybe testing a particular file&rsquo;s existence would be a better solution.</p>
<pre tabindex="0"><code>#!/bin/sh
#
# USAGE: udev-auto-mount.sh DEVICE
#   DEVICE   is the actual device node at /dev/DEVICE
# 
# This script takes a device name, looks up the partition label and
# type, creates /media/LABEL and mounts the partition.  Mount options
# are hard-coded below.

DEVICE=$1

# check input
if [ -z &quot;$DEVICE&quot; ]; then
   exit 1
fi

# test that this device isn't already mounted
device_is_mounted=`grep ${DEVICE} /etc/mtab`
if [ -n &quot;$device_is_mounted&quot; ]; then
   echo &quot;error: seems /dev/${DEVICE} is already mounted&quot;
   exit 1
fi

# If there's a problem at boot-time, this is where we'd put
# some test to check that we're booting, and then run
#     sleep 60
# so the system is ready for the mount below.
#
# An example to experiment with:
# Assume the system is &quot;booted enough&quot; if the HTTPD server is running.
# If it isn't, sleep for half a minute before checking again.
#
# The risk: if the server fails for some reason, this mount script
# will just keep waiting for it to show up.  A better solution would
# be to check for some file that exists after the boot process is complete.
#
# HTTPD_UP=`ps -ax | grep httpd | grep -v grep`
# while [ -z &quot;$HTTPD_UP&quot; ]; do
#    sleep 30
#    HTTPD_UP=`ps -ax | grep httpd | grep -v grep`
# done


# pull in useful variables from vol_id, quote everything Just In Case
eval `/sbin/vol_id /dev/${DEVICE} | sed 's/^/export /; s/=/=&quot;/; s/$/&quot;/'`

if [ -z &quot;$ID_FS_LABEL&quot; ] || [ -z &quot;$ID_FS_TYPE&quot; ]; then
   echo &quot;error: ID_FS_LABEL is empty! did vol_id break? tried /dev/${DEVICE}&quot;
   exit 1
fi


# test mountpoint - it shouldn't exist
if [ ! -e &quot;/media/${ID_FS_LABEL}&quot; ]; then

   # make the mountpoint
   mkdir &quot;/media/${ID_FS_LABEL}&quot;

   # mount the device
   # 
   # If expecting thumbdrives, you probably want 
   #      mount -t auto -o sync,noatime [...]
   # 
   # If drive is VFAT/NFTS, this mounts the filesystem such that all files
   # are owned by a std user instead of by root.  Change to your user's UID
   # (listed in /etc/passwd).  You may also want &quot;gid=1000&quot; and/or &quot;umask=022&quot;, eg:
   #      mount -t auto -o uid=1000,gid=1000 [...]
   # 
   # 
   case &quot;$ID_FS_TYPE&quot; in

       vfat)  mount -t vfat -o sync,noatime,uid=1000 /dev/${DEVICE} &quot;/media/${ID_FS_LABEL}&quot;
              ;;

              # I like the locale setting for ntfs
       ntfs)  mount -t auto -o sync,noatime,uid=1000,locale=en_US.UTF-8 /dev/${DEVICE} &quot;/media/${ID_FS_LABEL}&quot;
              ;;

              # ext2/3/4 don't like uid option
       ext*)  mount -t auto -o sync,noatime /dev/${DEVICE} &quot;/media/${ID_FS_LABEL}&quot;
              ;;
   esac

   # all done here, return successful
   exit 0
fi

exit 1
</code></pre><h4 id="super-bonus-cleanup-script">Super Bonus Cleanup Script!<a hidden class="anchor" aria-hidden="true" href="#super-bonus-cleanup-script">#</a></h4>
<p>One more script. All this does is unmount the device and remove the mountpoint directories. It assumes it has privs to do this, so you&rsquo;ll need to run it with <code>sudo</code>. This script now takes the full mountpoint on the commandline, eg:</p>
<pre tabindex="0"><code>$ /usr/local/sbin/udev-unmounter.sh &quot;/media/My Random Disk&quot;
</code></pre><p>Put this in <code>/usr/local/sbin/udev-unmounter.sh</code>:</p>
<pre tabindex="0"><code>#!/bin/sh
#
# USAGE: udev-unmounter.sh MOUNTPT
#   MOUNTPT is a mountpoint we want to unmount and delete.
MOUNTPT=&quot;$1&quot;

if [ -z &quot;$MOUNTPT&quot; ]; then
   exit 1
fi


# test mountpoint - it should exist
if [ -e &quot;${MOUNTPT}&quot; ]; then

   # very naive; just run and pray
   umount -l &quot;${MOUNTPT}&quot; &amp;&amp; rmdir &quot;${MOUNTPT}&quot; &amp;&amp; exit 0

   echo &quot;error: ${MOUNTPT} failed to unmount.&quot;
   exit 1
fi

echo &quot;error: ${MOUNTPT} does not exist&quot;
exit 1
</code></pre><h2 id="gpghttpsruanyifengcomblog201307gpghtml"><a href="https://ruanyifeng.com/blog/2013/07/gpg.html">GPG</a><a hidden class="anchor" aria-hidden="true" href="#gpghttpsruanyifengcomblog201307gpghtml">#</a></h2>
<p>前两篇文章，我介绍了<a href="https://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">RSA算法</a>。</p>
<p>今天，就接着来看，现实中怎么使用这个算法，对信息加密和解密。这要用到<a href="https://www.gnupg.org/">GnuPG</a>软件（简称GPG），它是目前最流行、最好用的加密工具之一。</p>
<h3 id="什么是gpg">什么是GPG<a hidden class="anchor" aria-hidden="true" href="#什么是gpg">#</a></h3>
<p>要了解什么是GPG，就要先了解<a href="https://en.wikipedia.org/wiki/Pretty_Good_Privacy">PGP</a>。</p>
<p>1991年，程序员<a href="https://en.wikipedia.org/wiki/Phil_Zimmermann">Phil Zimmermann</a>为了避开政府监视，开发了加密软件PGP。这个软件非常好用，迅速流传开来，成了许多程序员的必备工具。但是，它是商业软件，不能自由使用。所以，自由软件基金会决定，开发一个PGP的替代品，取名为GnuPG。这就是GPG的由来。</p>
<p>GnuPG 是完整实现了 <a href="https://tools.ietf.org/html/rfc4880">RFC4880</a> （即PGP） 所定义的 <a href="https://openpgp.org/about/">OpenPGP</a> 标准的自由软件。</p>
<p>GnuPG 可以加密和签名你的数据和通讯信息，包含一个通用的密钥管理系统以及用于各种公钥目录的访问模块。</p>
<p>GnuPG 是一个易于与其它程序整合的命令行工具，拥有很多前端程序和函数库。</p>
<p>GnuPG 还支持 S/MIME 和 Secure Shell (ssh)。</p>
<p>GPG有许多用途，本文主要介绍文件加密。至于邮件的加密，不同的邮件客户端有不同的设置，请参考Ubuntu网站的<a href="https://help.ubuntu.com/community/GnuPrivacyGuardHowto#Reading_OpenPGP_E-mail">介绍</a>。</p>
<p>本文的使用环境为Linux命令行。如果掌握了命令行，<a href="https://gpg4win.org/">Windows</a> 或 <a href="https://gpgtools.org/">Mac OS</a> 客户端，就非常容易掌握。GPG并不难学，学会了它，从此就能轻松传递加密信息。建议读者一步步跟着教程做，对每条命令都自行测试。</p>
<h3 id="安装-5">安装<a hidden class="anchor" aria-hidden="true" href="#安装-5">#</a></h3>
<p>GPG有两种安装方式。可以<a href="https://www.gnupg.org/download/index.en.html">下载源码</a>，自己编译安装。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ./configure
$ make
$ make install
</code></pre></div><p>也可以安装编译好的二进制包。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt-get install gnupg
</code></pre></div><p>安装完成后，键入下面的命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ gpg --help
</code></pre></div><p>如果屏幕显示GPG的帮助，就表示安装成功。</p>
<h3 id="配置-4">配置<a hidden class="anchor" aria-hidden="true" href="#配置-4">#</a></h3>
<h4 id="目录位置">目录位置<a hidden class="anchor" aria-hidden="true" href="#目录位置">#</a></h4>
<p>GnuPG 用环境变量 <code>$GNUPGHOME</code> 定位配置文件的位置，默认情况下此变量并未被设置，会直接使用 <code>$HOME</code>，所以默认的配置目录是 <code>~/.gnupg</code>。</p>
<p>要改变默认位置，执行 <code>$ gpg --homedir path/to/file</code> 或在 <a href="https://wiki.archlinux.org/title/Startup_file">startup files</a> 中设置 <code>GNUPGHOME</code>。</p>
<h4 id="配置文件">配置文件<a hidden class="anchor" aria-hidden="true" href="#配置文件">#</a></h4>
<p>默认的配置文件是 <code>~/.gnupg/gpg.conf</code> 和 <code>~/.gnupg/dirmngr.conf</code>.</p>
<p>gnupg 目录的默认 <a href="https://wiki.archlinux.org/title/Permissions">权限</a> 是 <code>700</code>，其中文件的权限是 <code>600</code>. 仅目录的所有者有权读写，访问这些文件。这是基于安全考虑，请不要变更。如果不使用这样的安全权限设置，会收到不安全文件的警告。</p>
<p>在文件中附加需要的文件：<code>/usr/share/gnupg</code> 包含基本架构文件. gpg，第一次运行时，如果配置文件不存在，会自动复制文件到 <code>~/.gnupg</code>。</p>
<h4 id="新用户的默认选项">新用户的默认选项<a hidden class="anchor" aria-hidden="true" href="#新用户的默认选项">#</a></h4>
<p>要给新建用户设定一些默认选项，把配置文件放到 <code>/etc/skel/.gnupg/</code>。系统创建新用户时，就会把文件复制到 GnuPG 目录。还有一个 <em>addgnupghome</em> 命令可以为已有用户创建新 GnuPG 主目录：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># addgnupghome user1 user2</span>
</code></pre></div><p>此命令会将对检查 <code>/home/user1/.gnupg</code> 和 <code>/home/user2/.gnupg</code>，如果用户的 GnuPG 主目录不存在，就会从 skeleton 目录复制文件过去。</p>
<h3 id="生成密钥">生成密钥<a hidden class="anchor" aria-hidden="true" href="#生成密钥">#</a></h3>
<p>安装成功后，使用 <code>--full-generate-key</code> 参数生成自己的密钥。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ gpg --full-generate-key
</code></pre></div><p>或用 <code>gpg --gen-key</code> 快速生成。以下使用 <code>gpg2 --full-generate-key</code> 演示。</p>
<p>回车以后，会跳出一大段文字：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">gpg <span style="color:#f92672">(</span>GnuPG<span style="color:#f92672">)</span> 2.2.19; Copyright <span style="color:#f92672">(</span>C<span style="color:#f92672">)</span> <span style="color:#ae81ff">2019</span> Free Software Foundation, Inc.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Please <span style="color:#66d9ef">select</span> what kind of key you want:
   <span style="color:#f92672">(</span>1<span style="color:#f92672">)</span> RSA and RSA <span style="color:#f92672">(</span>default<span style="color:#f92672">)</span>
   <span style="color:#f92672">(</span>2<span style="color:#f92672">)</span> DSA and Elgamal
   <span style="color:#f92672">(</span>3<span style="color:#f92672">)</span> DSA <span style="color:#f92672">(</span>sign only<span style="color:#f92672">)</span>
   <span style="color:#f92672">(</span>4<span style="color:#f92672">)</span> RSA <span style="color:#f92672">(</span>sign only<span style="color:#f92672">)</span>
  <span style="color:#f92672">(</span>14<span style="color:#f92672">)</span> Existing key from card
Your selection? 
</code></pre></div><p>第一段是版权声明，然后让用户自己选择加密算法。默认选择第一个选项，表示加密和签名都使用RSA算法。</p>
<p>然后，系统就会问你密钥的长度。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">RSA keys may be between <span style="color:#ae81ff">1024</span> and <span style="color:#ae81ff">4096</span> bits long.
What keysize <span style="color:#66d9ef">do</span> you want? <span style="color:#f92672">(</span>3072<span style="color:#f92672">)</span> 
</code></pre></div><p>密钥越长越安全。</p>
<p>接着，设定密钥的有效期。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">Please specify how long the key should be valid.
         0 <span style="color:#f92672">=</span> key does not expire
      &lt;n&gt;  <span style="color:#f92672">=</span> key expires in n days
      &lt;n&gt;w <span style="color:#f92672">=</span> key expires in n weeks
      &lt;n&gt;m <span style="color:#f92672">=</span> key expires in n months
      &lt;n&gt;y <span style="color:#f92672">=</span> key expires in n years
Key is valid <span style="color:#66d9ef">for</span>? <span style="color:#f92672">(</span>0<span style="color:#f92672">)</span> 
</code></pre></div><p>如果密钥只是个人使用，并且你很确定可以有效保管私钥，建议选择第一个选项，即永不过期。回答完上面三个问题以后，系统让你确认。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">Is this correct? <span style="color:#f92672">(</span>y/N<span style="color:#f92672">)</span>
</code></pre></div><p>输入y，系统就要求你提供个人信息。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">GnuPG needs to construct a user ID to identify your key.

Real name: 
Email address
Comment: 
</code></pre></div><p>&ldquo;真实姓名&quot;填入你姓名的英文写法，&ldquo;电子邮件地址&quot;填入你的邮件地址，&ldquo;注释&quot;这一栏可以空着。</p>
<p>然后，你的&quot;用户ID&quot;生成了。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">You selected this USER-ID:
    <span style="color:#e6db74">&#34;Vane Hsiung &lt;1664548605@qq.com&gt;&#34;</span>
</code></pre></div><p>系统会让你最后确认一次。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">Change <span style="color:#f92672">(</span>N<span style="color:#f92672">)</span>ame, <span style="color:#f92672">(</span>C<span style="color:#f92672">)</span>omment, <span style="color:#f92672">(</span>E<span style="color:#f92672">)</span>mail or <span style="color:#f92672">(</span>O<span style="color:#f92672">)</span>kay/<span style="color:#f92672">(</span>Q<span style="color:#f92672">)</span>uit? 
</code></pre></div><p>输入O表示&quot;确定&rdquo;。</p>
<p>接着，系统会要求你做一些随机的举动，以生成一个随机数。同时系统会让你设定一个私钥的密码。这是为了防止误操作，或者系统被侵入时有人擅自动用私钥。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">We need to generate a lot of random bytes. It is a good idea to performsome other action <span style="color:#f92672">(</span>type on the keyboard, move the mouse, utilize thedisks<span style="color:#f92672">)</span> during the prime generation; this gives the random numbergenerator a better chance to gain enough entropy.
</code></pre></div><p>然后，系统就开始生成密钥了，</p>
<p>几分钟以后，系统提示密钥已经生成了。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">gpg: key B893B73ABC92D2CA marked as ultimately trusted
gpg: revocation certificate stored as <span style="color:#e6db74">&#39;&#39;</span>public and secret key created and signed.
</code></pre></div><p>请注意上面的字符串&quot;B893B73ABC92D2CA&rdquo;，这是&quot;用户ID&quot;的Hash字符串，可以用来替代&quot;用户ID&rdquo;。</p>
<p>这时，最好再生成一张&quot;撤销证书&rdquo;，以备以后密钥作废时，可以请求外部的公钥服务器撤销你的公钥。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ gpg --gen-revoke <span style="color:#f92672">[</span>用户ID<span style="color:#f92672">]</span>
</code></pre></div><p>上面的&quot;用户ID&quot;部分，可以填入你的邮件地址或者Hash字符串（以下同）。</p>
<h3 id="密钥管理">密钥管理<a hidden class="anchor" aria-hidden="true" href="#密钥管理">#</a></h3>
<p><strong>列出密钥</strong></p>
<p>list-keys参数列出系统中已有的密钥．</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ gpg --list-keys
</code></pre></div><p>显示结果如下：</p>
<pre tabindex="0"><code>gpg: checking the trustdb
gpg: marginals needed: 3  completes needed: 1  trust model: pgp
gpg: depth: 0  valid:   1  signed:   0  trust: 0-, 0q, 0n, 0m, 0f, 1u
/home/vane/.gnupg/pubring.kbx
-----------------------------
pub   rsa3072 2021-10-17 [SC]
      BC158F7500033355B5324CF14C701F8BF2E03463
uid           [ultimate] Vane Hsiung &lt;1664548605@qq.com&gt;
sub   rsa3072 2021-10-17 [E]
</code></pre><p>第一行显示公钥文件名（pubring.gpg），第二行显示公钥特征（4096位，Hash字符串和生成时间），第三行显示&quot;用户ID&quot;，第四行显示私钥特征。</p>
<p>如果你要从密钥列表中删除某个密钥，可以使用如下参数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ gpg --delete-secret-keys <span style="color:#f92672">[</span>用户ID<span style="color:#f92672">]</span>
$ gpg --delete-key <span style="color:#f92672">[</span>用户ID<span style="color:#f92672">]</span>
</code></pre></div><p><strong>输出密钥</strong></p>
<p>公钥文件（.gnupg/pubring.gpg）以二进制形式储存，armor参数可以将其转换为ASCII码显示。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ gpg --armor --output public-key.txt --export <span style="color:#f92672">[</span>用户ID<span style="color:#f92672">]</span>
</code></pre></div><p>&ldquo;用户ID&quot;指定哪个用户的公钥，output参数指定输出文件名（public-key.txt）。</p>
<p>类似地，export-secret-keys参数可以转换私钥。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ gpg --armor --output private-key.txt --export-secret-keys
</code></pre></div><p><strong>上传公钥</strong></p>
<p>公钥服务器是网络上专门储存用户公钥的服务器。send-keys参数可以将公钥上传到服务器。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ gpg --send-keys <span style="color:#f92672">[</span>用户ID<span style="color:#f92672">]</span> --keyserver hkp://subkeys.pgp.net
</code></pre></div><p>使用上面的命令，你的公钥就被传到了服务器subkeys.pgp.net，然后通过交换机制，所有的公钥服务器最终都会包含你的公钥。</p>
<p>由于公钥服务器没有检查机制，任何人都可以用你的名义上传公钥，所以没有办法保证服务器上的公钥的可靠性。通常，你可以在网站上公布一个公钥指纹，让其他人核对下载到的公钥是否为真。fingerprint参数生成公钥指纹。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ gpg --fingerprint <span style="color:#f92672">[</span>用户ID<span style="color:#f92672">]</span>
</code></pre></div><p><strong>输入密钥</strong></p>
<p>除了生成自己的密钥，还需要将他人的公钥或者你的其他密钥输入系统。这时可以使用import参数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ gpg --import <span style="color:#f92672">[</span>密钥文件<span style="color:#f92672">]</span>
</code></pre></div><p>为了获得他人的公钥，可以让对方直接发给你，或者到公钥服务器上寻找。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ gpg --keyserver hkp://subkeys.pgp.net --search-keys <span style="color:#f92672">[</span>用户ID<span style="color:#f92672">]</span>
</code></pre></div><p>正如前面提到的，我们无法保证服务器上的公钥是否可靠，下载后还需要用其他机制验证．</p>
<h3 id="加密和解密">加密和解密<a hidden class="anchor" aria-hidden="true" href="#加密和解密">#</a></h3>
<p><strong>加密</strong></p>
<p>假定有一个文本文件demo.txt，怎样对它加密呢？</p>
<p>encrypt参数用于加密。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ gpg --recipient <span style="color:#f92672">[</span>用户ID<span style="color:#f92672">]</span> --output demo.en.txt --encrypt demo.txt
</code></pre></div><p>recipient参数指定接收者的公钥，output参数指定加密后的文件名，encrypt参数指定源文件。运行上面的命令后，demo.en.txt就是已加密的文件，可以把它发给对方。</p>
<p><strong>解密</strong></p>
<p>对方收到加密文件以后，就用自己的私钥解密。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ gpg --output demo.de.txt --decrypt demo.en.txt
</code></pre></div><p>output 指定解密后生成的文件，decrypt参数指定需要解密的文件。运行上面的命令，demo.de.txt就是解密后的文件。</p>
<p>GPG允许省略decrypt参数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ gpg demo.en.txt
</code></pre></div><h3 id="签名">签名<a hidden class="anchor" aria-hidden="true" href="#签名">#</a></h3>
<p><strong>对文件签名</strong></p>
<p>有时，我们不需要加密文件，只需要对文件签名，表示这个文件确实是我本人发出的。sign参数用来签名。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ gpg --sign demo.txt
</code></pre></div><p>运行上面的命令后，当前目录下生成demo.txt.gpg文件，这就是签名后的文件。这个文件默认采用二进制储存，如果想生成ASCII码的签名文件，可以使用clearsign参数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ gpg --clearsign demo.txt
</code></pre></div><p>运行上面的命令后 ，当前目录下生成demo.txt.asc文件，后缀名asc表示该文件是ASCII码形式的。</p>
<p>如果想生成单独的签名文件，与文件内容分开存放，可以使用detach-sign参数。　　</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ gpg --detach-sign demo.txt
</code></pre></div><p>运行上面的命令后，当前目录下生成一个单独的签名文件demo.txt.sig。该文件是二进制形式的，如果想采用ASCII码形式，要加上armor参数。　　</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ gpg --armor --detach-sign demo.txt
</code></pre></div><p><strong>签名+加密</strong></p>
<p>上一节的参数，都是只签名不加密。如果想同时签名和加密，可以使用下面的命令。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ gpg --local-user <span style="color:#f92672">[</span>发信者ID<span style="color:#f92672">]</span> --recipient <span style="color:#f92672">[</span>接收者ID<span style="color:#f92672">]</span> --armor --sign --encrypt demo.txt
</code></pre></div><p>local-user参数指定用发信者的私钥签名，recipient参数指定用接收者的公钥加密，armor参数表示采用ASCII码形式显示，sign参数表示需要签名，encrypt参数表示指定源文件。</p>
<p><strong>验证签名</strong></p>
<p>我们收到别人签名后的文件，需要用对方的公钥验证签名是否为真。verify参数用来验证。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ gpg --verify demo.txt.asc demo.txt
</code></pre></div><p>举例来说，<a href="https://openvpn.net/index.php/open-source/downloads.html">openvpn</a>网站就提供每一个下载包的gpg签名文件。你可以根据它的<a href="https://openvpn.net/index.php/open-source/documentation/sig.html">说明</a>，验证这些下载包是否为真。</p>
<h2 id="linux-kernel">Linux Kernel<a hidden class="anchor" aria-hidden="true" href="#linux-kernel">#</a></h2>
<p>来自 <a href="https://en.wikipedia.org/wiki/Kernel_(computing)">Wikipedia</a>:</p>
<blockquote>
<p><em>内核是计算机操作系统的核心组件，对系统有完全的控制。开机时最先启动，然后负责后续的启动工作。它负责处理其它软件的请求，将这些请求转化为中央处理器的数据处理请求。内核还负责管理内存，管理系统和其它打印机、扬声器等外围设备的通讯，是操作系统最基础的部分。</em></p>
</blockquote>
<p>内核包安装在<code>/boot/</code>下的文件系统上。为了能够引导到内核，必须适当配置<a href="https://wiki.archlinux.org/title/%E5%90%AF%E5%8A%A8%E5%8A%A0%E8%BD%BD%E5%99%A8">启动加载器</a>。</p>
<h3 id="kernel-modulehttpswikiarchlinuxorgtitlekernel_module_e7ae80e4bd93e4b8ade69687"><a href="https://wiki.archlinux.org/title/Kernel_module_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Kernel module</a><a hidden class="anchor" aria-hidden="true" href="#kernel-modulehttpswikiarchlinuxorgtitlekernel_module_e7ae80e4bd93e4b8ade69687">#</a></h3>
<p><a href="https://en.wikipedia.org/wiki/Loadable_kernel_module">内核模块</a>是可以按需加载或卸载的内核代码，可以不重启系统就扩充内核的功能。</p>
<p>要创建内核模块，请阅读<a href="https://tldp.org/LDP/lkmpg/2.6/html/index.html">此指南</a>。模块可以设置成内置或者动态加载，要编译成可动态加载，需要在内核配置时将模块配置为 <code>M</code> (模块)。</p>
<h4 id="获取信息">获取信息<a hidden class="anchor" aria-hidden="true" href="#获取信息">#</a></h4>
<p>模块保存在 <code>/lib/modules/kernel_release</code> (使用 <code>uname -r</code> 命令显示当前内核版本)。</p>
<p><strong>注意：</strong> 模块名通常使用 (<code>_</code>) 或 <code>-</code> 连接，但是这些符号在 <code>modprobe</code> 命令和 <code>/etc/modprobe.d/</code> 配置文件中都是可以相互替换的。</p>
<p>显示当前装入的内核模块：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ lsmod
</code></pre></div><p>在上面的输出中：</p>
<ul>
<li><code>Module</code> 显示每个模块的名称</li>
<li><code>Size</code> 显示每个模块的大小（并不是它们占的内存大小）</li>
<li><code>Used by</code> 显示每个模块被使用的次数和使用它们的模块</li>
</ul>
<p>显然，这里有很多模块。加载的模块数量取决于你的系统和版本以及正在运行的内容。我们可以这样计数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ lsmod | wc -l
<span style="color:#ae81ff">67</span>
</code></pre></div><p><code>modules.builtin</code> 文件中列出了所有构建在内核中的模块</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ more /lib/modules/<span style="color:#66d9ef">$(</span>uname -r<span style="color:#66d9ef">)</span>/modules.builtin | head -10
kernel/arch/x86/crypto/crc32c-intel.ko
kernel/arch/x86/events/intel/intel-uncore.ko
kernel/arch/x86/platform/intel/iosf_mbi.ko
kernel/mm/zpool.ko
kernel/mm/zbud.ko
kernel/mm/zsmalloc.ko
kernel/fs/binfmt_script.ko
kernel/fs/mbcache.ko
kernel/fs/configfs/configfs.ko
kernel/fs/crypto/fscrypto.ko
</code></pre></div><p>显示模块信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ modinfo module_name
</code></pre></div><p>显示所有模块的配置信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ modprobe -c | less
</code></pre></div><p>显示某个模块的配置信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ modprobe -c | grep module_name
</code></pre></div><p>显示一个装入模块使用的选项：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ systool -v -m module_name
</code></pre></div><p>显示模块的依赖关系：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ modprobe --show-depends module_name
</code></pre></div><h4 id="使用systemd自动加载模块">使用systemd自动加载模块<a hidden class="anchor" aria-hidden="true" href="#使用systemd自动加载模块">#</a></h4>
<p>目前，所有必要模块的加载均由 <a href="https://wiki.archlinux.org/title/Udev">udev</a> 自动完成。所以，如果不需要使用任何额外的模块，就没有必要在任何配置文件中添加启动时加载的模块。但是，有些情况下可能需要在系统启动时加载某个额外的模块，或者将某个模块列入黑名单以便使系统正常运行。</p>
<p>内核模块可以在<code>/etc/modules-load.d/</code> 下的文件中明确列出，以便systemd在引导过程中加载它们。 每个配置文件都以 <code>/etc/modules-load.d/&lt;program&gt;.conf</code>的样式命名。 配置文件仅包含要加载的内核模块名称列表，以换行符分隔。 空行和第一个非空白字符为<code>#</code>或<code>;</code>的行被忽略。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat /etc/modules-load.d/virtio-net.conf
<span style="color:#75715e"># Load virtio_net.ko at boot</span>
virtio_net
</code></pre></div><p>另见<a href="https://man.archlinux.org/man/modules-load.d.5">modules-load.d(5)</a>。</p>
<h4 id="手动加载卸载">手动加载卸载<a hidden class="anchor" aria-hidden="true" href="#手动加载卸载">#</a></h4>
<p>控制内核模块载入/移除的命令是kmod 软件包提供的, 要手动装入模块的话，执行:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># modprobe module_name</span>
</code></pre></div><p>按文件名加载模块:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># insmod filename [args]</span>
</code></pre></div><p><strong>注意：</strong> 如果升级了内核但是没有重启，路径 <code>/usr/lib/modules/$(uname -r)/</code> 已经不存在。<em>modprobe</em> 会返回错误 1，没有额外的错误信息。如果出现 modprobe 加载失败，请检查模块路径以确认是否是这个问题导致。</p>
<p>如果要移除一个模块：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># modprobe -r module_name</span>
</code></pre></div><p>或者:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># rmmod module_name</span>
</code></pre></div><h4 id="配置模块参数">配置模块参数<a hidden class="anchor" aria-hidden="true" href="#配置模块参数">#</a></h4>
<h5 id="手动加载时设置">手动加载时设置<a hidden class="anchor" aria-hidden="true" href="#手动加载时设置">#</a></h5>
<p>传递参数的基本方式是使用 modprobe 选项，格式是 <code>key=value</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># modprobe module_name parameter_name=parameter_value</span>
</code></pre></div><h5 id="使用-etcmodprobed中的文件">使用 /etc/modprobe.d/中的文件<a hidden class="anchor" aria-hidden="true" href="#使用-etcmodprobed中的文件">#</a></h5>
<p>要通过配置文件传递参数，在 <code>/etc/modprobe.d/</code> 中放入任意名称 <code>.conf</code> 文件，加入:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo gedit /etc/modprobe.d/myfilename.conf
options modname parametername<span style="color:#f92672">=</span>parametercontents
</code></pre></div><p>例如</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo gedit /etc/modprobe.d/thinkfan.conf
<span style="color:#75715e"># On thinkpads, this lets the thinkfan daemon control fan speed</span>
options thinkpad_acpi fan_control<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</code></pre></div><p><strong>注意：</strong> 如果要在启动时就修改内核参数(从 init ramdisk 开始)，需要将相应的<code>.conf</code>-文件加入 <a href="https://wiki.archlinux.org/title/Mkinitcpio.conf">mkinitcpio.conf</a> 的 FILES 参数中。</p>
<h5 id="使用内核命令行">使用内核命令行<a hidden class="anchor" aria-hidden="true" href="#使用内核命令行">#</a></h5>
<p>如果模块直接编译进内核，也可以通过启动管理器(<a href="https://wiki.archlinux.org/title/GRUB">GRUB</a>, <a href="https://wiki.archlinux.org/title/LILO">LILO</a> 或 <a href="https://wiki.archlinux.org/title/Syslinux">Syslinux</a>)的内核行加入参数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">modname.parametername<span style="color:#f92672">=</span>parametercontents
</code></pre></div><p>例如:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">thinkpad_acpi.fan_control<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</code></pre></div><h4 id="别名">别名<a hidden class="anchor" aria-hidden="true" href="#别名">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat /etc/modprobe.d/myalias.conf
<span style="color:#75715e"># Lets you use &#39;mymod&#39; in MODULES, instead of &#39;really_long_module_name&#39;</span>
alias mymod really_long_module_name
</code></pre></div><p>有些模块具有别名，以方便其它程序自动装入模块。禁用这些别名可以阻止自动装入，但是仍然可以手动装入。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat /etc/modprobe.d/modprobe.conf
<span style="color:#75715e"># Prevent autoload of bluetooth</span>
alias net-pf-31 off

<span style="color:#75715e"># Prevent autoload of ipv6</span>
alias net-pf-10 off
</code></pre></div><h4 id="黑名单">黑名单<a hidden class="anchor" aria-hidden="true" href="#黑名单">#</a></h4>
<h5 id="禁用内核模块">禁用内核模块<a hidden class="anchor" aria-hidden="true" href="#禁用内核模块">#</a></h5>
<p>对内核模块来说，黑名单是指禁止某个模块装入的机制。当对应的硬件不存在或者装入某个模块会导致问题时很有用。</p>
<p>有些模块作为 <a href="https://wiki.archlinux.org/title/Initramfs">initramfs</a> 的一部分装入。</p>
<p><code>mkinitcpio -M</code> 会显示所有自动检测到到模块：要阻止 initramfs 装入某些模块，可以在 <code>/etc/modprobe.d</code>中将它们加入黑名单。并应在映像生成过程中通过<code>modconf</code>挂钩将其添加。</p>
<p>运行 <code>mkinitcpio -v</code> 会显示各种钩子(例如 filesystem 钩子, SCSI 钩子等)装入的模块。如果您的<code>HOOKS</code> 数组中没有 <code>modconf</code> 钩子（例如，和默认配置不同）则请将该&rdquo;.conf&quot;文件添加到<code>/etc/mkinitcpio.conf</code>中的FILES数组中。一旦您将其列入黑名单，请重新生成 <a href="https://wiki.archlinux.org/title/Initramfs">initramfs</a>，然后重新启动。</p>
<h5 id="使用-etcmodprobed-中的文件">使用 /etc/modprobe.d/ 中的文件<a hidden class="anchor" aria-hidden="true" href="#使用-etcmodprobed-中的文件">#</a></h5>
<p>在 <code>/etc/modprobe.d/</code> 中创建 <code>.conf</code> 文件，使用 <code>blacklist</code> 关键字屏蔽不需要的模块，例如如果不想装入 <code>pcspkr</code> 模块：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo gedit /etc/modprobe.d/nobeep.conf
<span style="color:#75715e"># Do not load the pcspkr module on boot</span>
blacklist pcspkr
</code></pre></div><p><strong>注意：</strong> <code>blacklist</code> 命令将屏蔽一个模板，所以不会自动装入，但是如果其它非屏蔽模块需要这个模块，系统依然会装入它。</p>
<p>要避免这个行为，可以让 modprobe 使用自定义的 <code>install</code> 命令，而不是像往常一样将模块插入内核，因此您可以通过以下方式强制模块始终无法加载：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo gedit /etc/modprobe.d/blacklist.conf
...
install MODULE /bin/true
...
</code></pre></div><p>这样就可以 &ldquo;屏蔽&rdquo; 模块及所有依赖它的模块。</p>
<h5 id="使用内核命令行-1">使用内核命令行<a hidden class="anchor" aria-hidden="true" href="#使用内核命令行-1">#</a></h5>
<p><strong>提示：</strong> 如果模块损坏导致无法引导系统，这将非常有用。</p>
<p>您也可以从引导加载程序中将模块列入黑名单。</p>
<p>如<a href="https://wiki.archlinux.org/title/Kernel_parameters_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Kernel参数</a>.中所述，只需将<code>module_blacklist=modname1,modname2,modname3</code> 添加到引导加载程序的内核行中即可。</p>
<p><strong>注意：</strong> 将多个模块列入黑名单时，请注意，它们之间仅用逗号分隔。 空格或其他内容可能会破坏语法。</p>
<h3 id="kernel-parameters">Kernel parameters<a hidden class="anchor" aria-hidden="true" href="#kernel-parameters">#</a></h3>
<p>一共有三种办法，可以给内核传递参数，用于控制其行为方式：</p>
<ol>
<li>在编译内核时（这个最根本，会决定后面两种方法）</li>
<li>内核启动时(通常是在一个启动管理器里设置).</li>
<li>在运行时 (通过修改在 <code>/proc</code> 和 <code>/sys</code>中的文件).</li>
</ol>
<p>本页面主要是讲第二种方法。</p>
<h4 id="配置-5">配置<a hidden class="anchor" aria-hidden="true" href="#配置-5">#</a></h4>
<p>内核参数可以在启动时临时修改，也可以永久性写到启动管理器的配置文件中，永远起作用。</p>
<p>下面示例把参数<code>quiet</code> 和 <code>splash</code> 加到启动管理器。</p>
<h5 id="systemd-boot">systemd-boot<a hidden class="anchor" aria-hidden="true" href="#systemd-boot">#</a></h5>
<ul>
<li>
<p>当启动菜单出现时 按 <code>e</code>进入编辑界面:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">initrd<span style="color:#f92672">=</span><span style="color:#ae81ff">\i</span>nitramfs-linux.img root<span style="color:#f92672">=</span>/dev/sda2 quiet splash
</code></pre></div></li>
<li>
<p>如果想永久加入参数，编辑 <code>/boot/loader/entries/arch.conf</code> (假设你已经设置好了 <a href="https://wiki.archlinux.org/title/EFI_system_partition_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">EFI system partition</a>) 的<code>options</code> 行:</p>
</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>如果没有设置显示启动菜单, 你需要按住<code>Space</code>启动电脑来进入启动菜单 。</li>
<li>如果不能够从启动菜单上进行编辑，修改 <code>/boot/loader/loader.conf</code> 加入 <code>editor 1</code> 来开启编辑功能。</li>
</ul>
<p>更多信息请参见 <a href="https://wiki.archlinux.org/title/Systemd-boot">systemd-boot</a> .</p>
<h5 id="grub">GRUB<a hidden class="anchor" aria-hidden="true" href="#grub">#</a></h5>
<ul>
<li>
<p>在菜单出现后按 <code>e</code> 然后将它们添加至 <code>linux</code> 行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">linux /boot/vmlinuz-linux root<span style="color:#f92672">=</span>UUID<span style="color:#f92672">=</span>978e3e81-8048-4ae1-8a06-aa727458e8ff ro quiet splash
</code></pre></div><p>按 b 以便用这些参数启动。</p>
</li>
<li>
<p>要使改变在重启后仍生效，您<em>可以</em>手动编辑 <code>/boot/grub/grub.cfg</code> 中的如上内容。对于初学者，建议编辑 <code>/etc/default/grub</code> 并将您的内核选项添加至 <code>GRUB_CMDLINE_LINUX_DEFAULT</code> 行：</p>
<pre tabindex="0"><code>GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash&quot;
</code></pre><p>然后重新生成 <code>grub.cfg</code> 文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># grub-mkconfig -o /boot/grub/grub.cfg</span>
</code></pre></div></li>
</ul>
<p>有关配置GRUB的更多信息，请参阅 <a href="https://wiki.archlinux.org/title/GRUB">GRUB</a> 。</p>
<h3 id="发布时间表httpslinuxcnarticle-13963-1html"><a href="https://linux.cn/article-13963-1.html">发布时间表</a><a hidden class="anchor" aria-hidden="true" href="#发布时间表httpslinuxcnarticle-13963-1html">#</a></h3>
<h4 id="内核发布时间表有吗">内核发布时间表：有吗？<a hidden class="anchor" aria-hidden="true" href="#内核发布时间表有吗">#</a></h4>
<p>短的回答是，每两到三个月就有一个新的内核版本发布。长的回答是，这不是一个硬性规定。</p>
<p>这个意思是，你经常会看到每两到三个月就有一个新的内核版本发布。这是内核维护者团队的目标，但并没有规定新版本必须在前一个版本的 8 周后准时发布的期限。</p>
<p>新的内核版本（通常）是由 Linus Torvalds 在它准备好的时候发布的。通常是每 2 到 3 个月发布一次。该版本被宣布为“稳定”，一般以 X.Y 的格式编号。</p>
<p>但这并不是 X.Y 开发的结束。稳定版会有更多的小版本以进行错误的修复。这些小版本在稳定版的内核上又增加了一个点，就像是 X.Y.Z。</p>
<p>虽然 X.Y（通常）是由 Linux 创造者 Linus Torvalds 发布的，但是维护稳定的 X.Y 内核、合并错误修复和发布 X.Y.Z 版本的责任是由另外的内核开发者负责的。</p>
<h4 id="一个内核版本支持多长时间">一个内核版本支持多长时间？<a hidden class="anchor" aria-hidden="true" href="#一个内核版本支持多长时间">#</a></h4>
<p>和发布一样，一个内核版本支持多长时间也没有固定的日期和时间表。</p>
<p>一个普通的稳定内核版本通常会被支持两个半月到三个月，这取决于下一个稳定内核版本的发布时间。</p>
<p>例如，稳定版内核 5.14 会在稳定版内核 5.15 发布后的几周内达到生命末期。结束支持是由该稳定内核版本的维护者在 Linux 内核邮件列表中宣布的。用户和贡献者会被要求切换到新发布的稳定版本。</p>
<p>但这只适用于正常的稳定内核版本，还有 LTS（长期支持）内核版本，它们的支持期要比 3 个月长得多。</p>
<h4 id="lts-内核它支持多长时间">LTS 内核：它支持多长时间？<a hidden class="anchor" aria-hidden="true" href="#lts-内核它支持多长时间">#</a></h4>
<p>LTS 内核也没有固定的发布时间表。通常，每年都有一个 LTS 内核版本，一般是当年的最后一个版本，它至少会被支持两年。但同样，这里也没有固定的规则。</p>
<p>LTS 内核的维护者可以同意某个 LTS 内核的维护时间超过通常的两年。这个协议是根据必要性和参与的人员来达成的。</p>
<p>这种情况经常发生在 Android 项目中。由于两年的时间不足以让制造商结束对他们的硬件和软件功能的支持，你经常会发现一些 LTS 内核会被支持六年之久。</p>
<p><img loading="lazy" src="/Distributions/104702q7swhiybninishib.png" alt=""  />
</p>
<p>你可以 <a href="https://www.kernel.org/category/releases.html">在 Linux 内核网站上</a> 找到这个信息。</p>
<h4 id="你的发行版可能没有跟随通常的-linux-内核版本">你的发行版可能没有跟随通常的 Linux 内核版本<a hidden class="anchor" aria-hidden="true" href="#你的发行版可能没有跟随通常的-linux-内核版本">#</a></h4>
<p>如果你检查你的 Linux 内核版本，你可能会发现 <a href="https://itsfoss.com/why-distros-use-old-kernel/">你的发行版使用了一个旧的内核</a>。也有可能该发行版提供的内核已经在内核网站上被标记为到达了生命末期。</p>
<p>不要惊慌。你的发行版会负责修补内核的错误和漏洞。除非你真的在使用一个不知名的 Linux 发行版，否则你可以相信你的发行版会保持它的安全和健全。</p>
<p>如果你有足够的理由，比如为了支持更新的硬件，你可以自由地在你使用的任何发行版或 <a href="https://itsfoss.com/upgrade-linux-kernel-ubuntu/">Ubuntu 中安装最新的 Linux 内核</a> 。</p>
<p>如果你想了解更多细节，我已经 <a href="https://itsfoss.com/why-distros-use-old-kernel/">在这里解释了为什么你的发行版使用过时的 Linux 内核</a>。</p>
<h3 id="安装内核httpslinuxcnarticle-12125-1html"><a href="https://linux.cn/article-12125-1.html">安装内核</a><a hidden class="anchor" aria-hidden="true" href="#安装内核httpslinuxcnarticle-12125-1html">#</a></h3>
<p><strong>dpkg</strong></p>
<p>从 <a href="http://kernel.ubuntu.com/~kernel-ppa/mainline/">kernel.ubuntu.com</a> 网站手动下载可用的最新 Linux 内核：</p>
<ul>
<li>linux-image-X.Y.Z-generic-.deb</li>
<li>linux-modules-X.Y.Z-generic-.deb</li>
</ul>
<p>手动安装内核：</p>
<pre tabindex="0"><code>$ sudo dpkg --install *.deb
</code></pre><p>重启系统，使用新内核：</p>
<pre tabindex="0"><code>$ sudo reboot
</code></pre><p>检查是否如你所愿：</p>
<pre tabindex="0"><code>$ uname -r
</code></pre><p><strong>apt-get</strong></p>
<p>不同于上一个方法，这种方法会从 Ubuntu 官方仓库下载、安装内核版本：</p>
<p>运行：</p>
<pre tabindex="0"><code>$ sudo apt-get upgrade linux-image-generic
</code></pre><h4 id="xanmod-kernelhttpsplumzmearchives12014"><a href="https://plumz.me/archives/12014/">XanMod Kernel</a><a hidden class="anchor" aria-hidden="true" href="#xanmod-kernelhttpsplumzmearchives12014">#</a></h4>
<p>最新内核集成的一些新特性的确是可以提升性能的。xanmod 内核的安装可以去它们的<a href="https://xanmod.org/">官方网站</a>来查询，xanmod 内核的特性很多地方都有，官方也写的有很多，不过大多数还是以下几点：</p>
<ul>
<li>改善了 CPU 调度能力</li>
<li>改善了 I/O 的调度能力</li>
<li>增加了一些和性能有关的第三方补丁</li>
<li>使用了最新的 GCC 进行编译</li>
<li>使用了最新的 MicroCode</li>
</ul>
<p>安装的方式也比较简单，添加源并且更新安装就行了：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ echo <span style="color:#e6db74">&#39;deb http://deb.xanmod.org releases main&#39;</span> | sudo tee /etc/apt/sources.list.d/xanmod-kernel.list <span style="color:#f92672">&amp;&amp;</span> wget -qO - https://dl.xanmod.org/gpg.key | sudo apt-key add -
</code></pre></div><p>然后安装，我个人安装的是最新的 5.8.1 的 edge：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt update <span style="color:#f92672">&amp;&amp;</span> sudo apt install linux-xanmod-edge
</code></pre></div><p>安装完毕后还可以安装最新的微码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt update <span style="color:#f92672">&amp;&amp;</span> sudo apt install linux-xanmod
</code></pre></div><p>重启以应用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo reboot
</code></pre></div><h4 id="zenhttpswikiubuntucomzenkernelliquorix-kernelhttpsliquorixnet"><a href="https://wiki.ubuntu.com/ZenKernel">Zen</a>/<a href="https://liquorix.net/">Liquorix Kernel</a><a hidden class="anchor" aria-hidden="true" href="#zenhttpswikiubuntucomzenkernelliquorix-kernelhttpsliquorixnet">#</a></h4>
<ul>
<li>一些内核黑客合作的结果，是适合日常使用的优秀内核</li>
<li>以吞吐量和功耗为代价来换取性能</li>
<li>相对 linux 内核加入了 Fsync 功能。Fsync 是维尔福公司发布的一个可以帮助提升大量多线程应用运行帧率的特殊内核补丁，这对改善游戏性能有很大帮助。在一些采用 .Net 的 wine 游戏中会有 <a href="https://github.com/ValveSoftware/Proton/issues/3706#issuecomment-611595369">明显的性能提升</a></li>
<li>如果你使用英伟达显卡，记得更换驱动为相应的 dkms 版本。一般来说较新的显卡安装 nvidia-dkms 即可。DKMS，即 <strong>D</strong>ynamic <strong>K</strong>ernel <strong>M</strong>odule <strong>S</strong>ystem。可以使内核变更（如升级）后自动编译模块，适配新内核。</li>
</ul>
<p><a href="https://www.reddit.com/r/linuxquestions/comments/j7krma/questions_about_zen_kernel/">Questions about</a>: I&rsquo;m not a kernel expert, but my understanding is that there are different ways for the kernel to prioritize tasks to be processed by the CPU. Priority on a server or workstation is different from a gaming PC. The Zen (and Liquorix) kernel alters the way this is done to optimise for gaming and multimedia. From what I can tell, the difference between the Zen and Liquorix kernels is the scheduler used, but are otherwise the same. There&rsquo;s more info <a href="https://liquorix.net/">here</a>.</p>
<p><strong>Ubuntu Prerequisites:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo add-apt-repository ppa:damentz/liquorix <span style="color:#f92672">&amp;&amp;</span> sudo apt-get update
</code></pre></div><p>The Liquorix kernel can be installed by way of meta-packages. This will guarantee that the latest kernel is installed on every upgrade.</p>
<p><strong>64-bit:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt-get install linux-image-liquorix-amd64 linux-headers-liquorix-amd64
</code></pre></div><h4 id="可选内核httpswikiarchlinuxorgtitlekernel"><a href="https://wiki.archlinux.org/title/kernel">可选内核</a><a hidden class="anchor" aria-hidden="true" href="#可选内核httpswikiarchlinuxorgtitlekernel">#</a></h4>
<h3 id="切換内核httpsmeetrixioblogawschanging-default-ubuntu-kernelhtml"><a href="https://meetrix.io/blog/aws/changing-default-ubuntu-kernel.html">切換内核</a><a hidden class="anchor" aria-hidden="true" href="#切換内核httpsmeetrixioblogawschanging-default-ubuntu-kernelhtml">#</a></h3>
<p>可以通过修改 <code>/etc/default/grub</code> 中的 <code>GRUB_DEFAULT</code> 值来改变默认启动项。</p>
<p>查看 grub menu 目前的選項 ：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ grep -A100 submenu  /boot/grub/grub.cfg |grep menuentry
submenu <span style="color:#e6db74">&#39;Advanced options for Ubuntu&#39;</span> $menuentry_id_option <span style="color:#e6db74">&#39;gnulinux-advanced-4a67ec61-9cd5-4a26-b00f-9391a34c8a29&#39;</span> <span style="color:#f92672">{</span>
    menuentry <span style="color:#e6db74">&#39;Ubuntu, with Linux 4.4.0-1062-aws&#39;</span> --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option <span style="color:#e6db74">&#39;gnulinux-4.4.0-1062-aws-advanced-4a67ec61-9cd5-4a26-b00f-9391a34c8a29&#39;</span> <span style="color:#f92672">{</span>
    menuentry <span style="color:#e6db74">&#39;Ubuntu, with Linux 4.4.0-1062-aws (recovery mode)&#39;</span> --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option <span style="color:#e6db74">&#39;gnulinux-4.4.0-1062-aws-recovery-4a67ec61-9cd5-4a26-b00f-9391a34c8a29&#39;</span> <span style="color:#f92672">{</span>
    menuentry <span style="color:#e6db74">&#39;Ubuntu, with Linux 4.4.0-1061-aws&#39;</span> --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option <span style="color:#e6db74">&#39;gnulinux-4.4.0-1061-aws-advanced-4a67ec61-9cd5-4a26-b00f-9391a34c8a29&#39;</span> <span style="color:#f92672">{</span>
    menuentry <span style="color:#e6db74">&#39;Ubuntu, with Linux 4.4.0-1061-aws (recovery mode)&#39;</span> --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option <span style="color:#e6db74">&#39;gnulinux-4.4.0-1061-aws-recovery-4a67ec61-9cd5-4a26-b00f-9391a34c8a29&#39;</span> <span style="color:#f92672">{</span>
</code></pre></div><p>接下來修改 grub config 檔案：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo nano /etc/default/grup 
</code></pre></div><p>找到 GRUB_DEFAULT=0 ，將數字 0 改成想用來開機的 kernel，以這個例子來說：</p>
<ul>
<li>0 = &lsquo;Ubuntu, with Linux 4.4.0-1062-aws&rsquo; = &lsquo;gnulinux-4.4.0-1062-aws-advanced-4a67ec61-9cd5-4a26-b00f-9391a34c8a29&rsquo;</li>
<li>1 = &lsquo;Ubuntu, with Linux 4.4.0-1062-aws (recovery mode)&rsquo; = &lsquo;gnulinux-4.4.0-1062-aws-recovery-4a67ec61-9cd5-4a26-b00f-9391a34c8a29&rsquo;</li>
<li>2 = &lsquo;Ubuntu, with Linux 4.4.0-1061-aws&rsquo; = &lsquo;gnulinux-4.4.0-1061-aws-advanced-4a67ec61-9cd5-4a26-b00f-9391a34c8a29&rsquo;</li>
<li>3 = &lsquo;Ubuntu, with Linux 4.4.0-1061-aws (recovery mode)&rsquo; = &lsquo;gnulinux-4.4.0-1061-aws-recovery-4a67ec61-9cd5-4a26-b00f-9391a34c8a29&rsquo;</li>
</ul>
<p>GRUB 启动项序号从 <code>0</code> 开始计数，<code>0</code> 代表第一个启动项，也是上述选项的默认值，<code>1</code> 表示第二个启动项，以此类推。主菜单和子菜单项之间用 <code>&gt;</code> 隔开。</p>
<p>下面的例子启动的是主菜单项 &lsquo;Advanced options for Arch Linux&rsquo; 下子菜单的第三项：</p>
<ul>
<li>
<p>使用数字编号：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">GRUB_DEFAULT<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>
<span style="color:#75715e"># or</span>
GRUB_DEFAULT<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;1&gt;2&#34;</span>
</code></pre></div></li>
<li>
<p>使用<a href="https://wiki.archlinux.org/title/GRUB_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)/Tips_and_tricks_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E8%8F%9C%E5%8D%95%E6%9D%A1%E7%9B%AE">菜单标题</a>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">GRUB_DEFAULT<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Advanced options for Ubuntu&gt;Ubuntu, with Linux 4.4.0-1061-aws&#34;</span>
</code></pre></div></li>
<li>
<p>还可以这样：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-basic" data-lang="basic">GRUB_DEFAULT<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;gnulinux-advanced-4a67ec61-9cd5-4a26-b00f-9391a34c8a29&gt;gnulinux-4.4.0-1061-aws-advanced-4a67ec61-9cd5-4a26-b00f-9391a34c8a29&#34;</span>
</code></pre></div></li>
<li>
<p>更新 grup 設定：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo update-grub
$ sudo reboot
</code></pre></div></li>
</ul>
<h3 id="删除旧内核httpslinuxcnarticle-6245-1html"><a href="https://linux.cn/article-6245-1.html">删除旧内核</a><a hidden class="anchor" aria-hidden="true" href="#删除旧内核httpslinuxcnarticle-6245-1html">#</a></h3>
<p>随着时间的流逝，持续的内核更新会在系统中积聚大量的不再使用的内核，浪费你的磁盘空间。每个内核镜像和其相关联的模块/头文件会占用200-400MB的磁盘空间，因此由不再使用的内核而浪费的磁盘空间会快速地增加。</p>
<p>GRUB管理器为每个旧内核都维护了一个GRUB入口，以备你想要使用它们。</p>
<p>作为磁盘清理的一部分，如果你不再使用这些，你可以考虑清理掉这些镜像。</p>
<p>在删除旧内核之前，记住最好留有2个最近的内核（最新的和上一个版本），以防主要的版本出错。</p>
<p>在Ubuntu内核镜像包含了以下的包。</p>
<ul>
<li><strong>linux-image-</strong>: 内核镜像</li>
<li><strong>linux-image-extra-</strong>: 额外的内核模块</li>
<li><strong>linux-headers-</strong>: 内核头文件</li>
</ul>
<p>首先检查系统中安装的内核镜像。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ dpkg --list | grep linux-image
$ dpkg --list | grep linux-headers
</code></pre></div><p>在列出的内核镜像中，你可以移除一个特定的版本。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt-get purge linux-image-3.19.0-15
$ sudo apt-get purge linux-headers-3.19.0-15
</code></pre></div><p>上面的命令会删除内核镜像和它相关联的内核模块和头文件。</p>
<p>注意如果你还没有升级内核那么删除旧内核会自动触发安装新内核。这样在删除旧内核之后，GRUB配置会自动升级来移除GRUB菜单中相关GRUB入口。</p>
<p>如果你有很多没用的内核，你可以用shell表达式来一次性地删除多个内核。注意这个括号表达式只在bash或者兼容的shell中才有效。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt-get purge linux-image-3.19.0-<span style="color:#f92672">{</span>18,20,21,25<span style="color:#f92672">}</span>
$ sudo apt-get purge linux-headers-3.19.0-<span style="color:#f92672">{</span>18,20,21,25<span style="color:#f92672">}</span>
</code></pre></div><p>上面的命令会删除4个内核镜像：3.19.0-18、3.19.0-20、3.19.0-21 和 3.19.0-25。</p>
<p>如果GRUB配置由于任何原因在删除旧内核后没有正确升级，你可以尝试手动用update-grub2命令来更新配置。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo update-grub2
</code></pre></div><p>现在就重启来验证GRUB菜单是否已经正确清理了。</p>
<h3 id="编写第一个内核模块httpslinuxcnarticle-3251-1html"><a href="https://linux.cn/article-3251-1.html">编写第一个内核模块</a><a hidden class="anchor" aria-hidden="true" href="#编写第一个内核模块httpslinuxcnarticle-3251-1html">#</a></h3>
<h2 id="容器">容器<a hidden class="anchor" aria-hidden="true" href="#容器">#</a></h2>
<h3 id="namespacehttpswwwcnblogscomsparkdevp9365405html"><a href="https://www.cnblogs.com/sparkdev/p/9365405.html">Namespace</a><a hidden class="anchor" aria-hidden="true" href="#namespacehttpswwwcnblogscomsparkdevp9365405html">#</a></h3>
<h4 id="概念">概念<a hidden class="anchor" aria-hidden="true" href="#概念">#</a></h4>
<p>**namespace 是 Linux 内核用来隔离内核资源的方式。**通过 namespace 可以让一些进程只能看到与自己相关的一部分资源，而另外一些进程也只能看到与它们自己相关的资源，这两拨进程根本就感觉不到对方的存在。具体的实现方式是把一个或多个进程的相关资源指定在同一个 namespace 中。</p>
<p>Linux namespaces 是对全局系统资源的一种封装隔离，使得处于不同 namespace 的进程拥有独立的全局系统资源，改变一个 namespace 中的系统资源只会影响当前 namespace 里的进程，对其他 namespace 中的进程没有影响。</p>
<h4 id="用途">用途<a hidden class="anchor" aria-hidden="true" href="#用途">#</a></h4>
<p>实际上，Linux 内核实现 namespace 的一个主要目的就是实现轻量级虚拟化(容器)服务。在同一个 namespace 下的进程可以感知彼此的变化，而对外界的进程一无所知。这样就可以让容器中的进程产生错觉，认为自己置身于一个独立的系统中，从而达到隔离的目的。也就是说 linux 内核提供的 namespace 技术为 docker 等容器技术的出现和发展提供了基础条件。</p>
<p>我们可以从 docker 实现者的角度考虑该如何实现一个资源隔离的容器。比如是不是可以通过 chroot 命令切换根目录的挂载点，从而隔离文件系统。为了在分布式的环境下进行通信和定位，容器必须要有独立的 IP、端口和路由等，这就需要对网络进行隔离。同时容器还需要一个独立的主机名以便在网络中标识自己。接下来还需要进程间的通信、用户权限等的隔离。最后，运行在容器中的应用需要有进程号(PID)，自然也需要与宿主机中的 PID 进行隔离。也就是说这六种隔离能力是实现一个容器的基础，让我们看看 linux 内核的 namespace 特性为我们提供了什么样的隔离能力：</p>
<p><img loading="lazy" src="/Distributions/952033-20180725130447798-998138444.png" alt=""  />
</p>
<p>上表中的前六种 namespace 正是实现容器必须的隔离技术，至于新近提供的 Cgroup namespace 目前还没有被 docker 采用。相信在不久的将来各种容器也会添加对 Cgroup namespace 的支持。</p>
<h4 id="发展历史">发展历史<a hidden class="anchor" aria-hidden="true" href="#发展历史">#</a></h4>
<p>Linux 在很早的版本中就实现了部分的 namespace，比如内核 2.4 就实现了 mount namespace。大多数的 namespace 支持是在内核 2.6 中完成的，比如 IPC、Network、PID、和 UTS。还有个别的 namespace 比较特殊，比如 User，从内核 2.6 就开始实现了，但在内核 3.8 中才宣布完成。同时，随着 Linux 自身的发展以及容器技术持续发展带来的需求，也会有新的 namespace 被支持，比如在内核 4.6 中就添加了 Cgroup namespace。</p>
<p>Linux 提供了多个 API 用来操作 namespace，它们是 clone()、setns() 和 unshare() 函数，为了确定隔离的到底是哪项 namespace，在使用这些 API 时，通常需要指定一些调用参数：CLONE_NEWIPC、CLONE_NEWNET、CLONE_NEWNS、CLONE_NEWPID、CLONE_NEWUSER、CLONE_NEWUTS 和 CLONE_NEWCGROUP。如果要同时隔离多个 namespace，可以使用 | (按位或)组合这些参数。同时我们还可以通过 /proc 下面的一些文件来操作 namespace。</p>
<p><strong>查看进程所属的 namespace</strong></p>
<p>从版本号为 3.8 的内核开始，<code>/proc/[pid]/ns</code> 目录下会包含进程所属的 namespace 信息，使用下面的命令可以查看当前进程所属的 namespace 信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ll /proc/$$/ns
total <span style="color:#ae81ff">0</span>
lrwxrwxrwx <span style="color:#ae81ff">1</span> kurome kurome <span style="color:#ae81ff">0</span> Mar  <span style="color:#ae81ff">3</span> 11:33 cgroup -&gt; <span style="color:#e6db74">&#39;cgroup:[4026531835]&#39;</span>
lrwxrwxrwx <span style="color:#ae81ff">1</span> kurome kurome <span style="color:#ae81ff">0</span> Mar  <span style="color:#ae81ff">3</span> 11:33 ipc -&gt; <span style="color:#e6db74">&#39;ipc:[4026531839]&#39;</span>
lrwxrwxrwx <span style="color:#ae81ff">1</span> kurome kurome <span style="color:#ae81ff">0</span> Mar  <span style="color:#ae81ff">3</span> 11:33 mnt -&gt; <span style="color:#e6db74">&#39;mnt:[4026531840]&#39;</span>
lrwxrwxrwx <span style="color:#ae81ff">1</span> kurome kurome <span style="color:#ae81ff">0</span> Mar  <span style="color:#ae81ff">3</span> 11:33 net -&gt; <span style="color:#e6db74">&#39;net:[4026532008]&#39;</span>
lrwxrwxrwx <span style="color:#ae81ff">1</span> kurome kurome <span style="color:#ae81ff">0</span> Mar  <span style="color:#ae81ff">3</span> 11:33 pid -&gt; <span style="color:#e6db74">&#39;pid:[4026531836]&#39;</span>
lrwxrwxrwx <span style="color:#ae81ff">1</span> kurome kurome <span style="color:#ae81ff">0</span> Mar  <span style="color:#ae81ff">3</span> 11:33 pid_for_children -&gt; <span style="color:#e6db74">&#39;pid:[4026531836]&#39;</span>
lrwxrwxrwx <span style="color:#ae81ff">1</span> kurome kurome <span style="color:#ae81ff">0</span> Mar  <span style="color:#ae81ff">3</span> 11:33 time -&gt; <span style="color:#e6db74">&#39;time:[4026531834]&#39;</span>
lrwxrwxrwx <span style="color:#ae81ff">1</span> kurome kurome <span style="color:#ae81ff">0</span> Mar  <span style="color:#ae81ff">3</span> 11:33 time_for_children -&gt; <span style="color:#e6db74">&#39;time:[4026531834]&#39;</span>
lrwxrwxrwx <span style="color:#ae81ff">1</span> kurome kurome <span style="color:#ae81ff">0</span> Mar  <span style="color:#ae81ff">3</span> 11:33 user -&gt; <span style="color:#e6db74">&#39;user:[4026531837]&#39;</span>
lrwxrwxrwx <span style="color:#ae81ff">1</span> kurome kurome <span style="color:#ae81ff">0</span> Mar  <span style="color:#ae81ff">3</span> 11:33 uts -&gt; <span style="color:#e6db74">&#39;uts:[4026531838]&#39;</span>
</code></pre></div><p>首先，这些 namespace 文件都是链接文件。链接文件的内容的格式为 xxx:[inode number]。其中的 xxx 为 namespace 的类型，inode number 则用来标识一个 namespace，我们也可以把它理解为 namespace 的 ID。如果两个进程的某个 namespace 文件指向同一个链接文件，说明其相关资源在同一个 namespace 中。</p>
<p>其次，在 <code>/proc/[pid]/ns</code> 里放置这些链接文件的另外一个作用是，一旦这些链接文件被打开，只要打开的文件描述符(fd)存在，那么就算该 namespace 下的所有进程都已结束，这个 namespace 也会一直存在，后续的进程还可以再加入进来。</p>
<p>除了打开文件的方式，我们还可以通过文件挂载的方式阻止 namespace 被删除。比如我们可以把当前进程中的 uts 挂载到 <code>~/uts</code> 文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ touch ~/uts
$ sudo mount --bind /proc/$$/ns/uts ~/uts
</code></pre></div><p>使用 stat 命令检查下结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ stat ~/uts
</code></pre></div><p>很神奇吧，~/uts 的 inode 和链接文件中的 inode number 是一样的，它们是同一个文件。</p>
<h4 id="clone-函数">clone() 函数<a hidden class="anchor" aria-hidden="true" href="#clone-函数">#</a></h4>
<p>我们可以通过 clone() 在创建新进程的同时创建 namespace。clone() 在 C 语言库中的声明如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/* Prototype for the glibc wrapper function */</span>
<span style="color:#75715e">#define _GNU_SOURCE
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sched.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">clone</span>(<span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>fn)(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>), <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>child_stack, <span style="color:#66d9ef">int</span> flags, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg);
</code></pre></div><p>实际上，clone() 是在 C 语言库中定义的一个封装(wrapper)函数，它负责建立新进程的堆栈并且调用对编程者隐藏的 clone() 系统调用。Clone() 其实是 linux 系统调用 fork() 的一种更通用的实现方式，它可以通过 flags 来控制使用多少功能。一共有 20 多种 CLONE_ 开头的 falg(标志位) 参数用来控制 clone 进程的方方面面(比如是否与父进程共享虚拟内存等)，下面我们只介绍与 namespace 相关的 4 个参数：</p>
<ul>
<li>fn：指定一个由新进程执行的函数。当这个函数返回时，子进程终止。该函数返回一个整数，表示子进程的退出代码。</li>
<li>child_stack：传入子进程使用的栈空间，也就是把用户态堆栈指针赋给子进程的 esp 寄存器。调用进程(指调用 clone() 的进程)应该总是为子进程分配新的堆栈。</li>
<li>flags：表示使用哪些 CLONE_ 开头的标志位，与 namespace 相关的有CLONE_NEWIPC、CLONE_NEWNET、CLONE_NEWNS、CLONE_NEWPID、CLONE_NEWUSER、CLONE_NEWUTS 和 CLONE_NEWCGROUP。</li>
<li>arg：指向传递给 fn() 函数的参数。</li>
</ul>
<h4 id="setns-函数">setns() 函数<a hidden class="anchor" aria-hidden="true" href="#setns-函数">#</a></h4>
<p>通过 setns() 函数可以将当前进程加入到已有的 namespace 中。setns() 在 C 语言库中的声明如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#define _GNU_SOURCE
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sched.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">setns</span>(<span style="color:#66d9ef">int</span> fd, <span style="color:#66d9ef">int</span> nstype);
</code></pre></div><p>和 clone() 函数一样，C 语言库中的 setns() 函数也是对 setns() 系统调用的封装：</p>
<ul>
<li>fd：表示要加入 namespace 的文件描述符。它是一个指向 /proc/[pid]/ns 目录中文件的文件描述符，可以通过直接打开该目录下的链接文件或者打开一个挂载了该目录下链接文件的文件得到。</li>
<li>nstype：参数 nstype 让调用者可以检查 fd 指向的 namespace 类型是否符合实际要求。若把该参数设置为 0 表示不检查。</li>
</ul>
<p>前面我们提到：可以通过挂载的方式把 namespace 保留下来。保留 namespace 的目的是为以后把进程加入这个 namespace 做准备。在 docker 中，使用 docker exec 命令在已经运行着的容器中执行新的命令就需要用到 setns() 函数。为了把新加入的 namespace 利用起来，还需要引入 <a href="http://www.cnblogs.com/sparkdev/p/8214455.html">execve() 系列的函数</a>，该函数可以执行用户的命令，比较常见的用法是调用 /bin/bash 并接受参数运行起一个 shell。</p>
<h4 id="unshare-函数">unshare() 函数<a hidden class="anchor" aria-hidden="true" href="#unshare-函数">#</a></h4>
<p>通过 unshare 函数可以在原进程上进行 namespace 隔离。也就是创建并加入新的 namespace 。unshare() 在 C 语言库中的声明如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#define _GNU_SOURCE
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sched.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">unshare</span>(<span style="color:#66d9ef">int</span> flags);
</code></pre></div><p>和前面两个函数一样，C 语言库中的 unshare() 函数也是对 unshare() 系统调用的封装。调用 unshare() 的主要作用就是：不启动新的进程就可以起到资源隔离的效果，相当于跳出原先的 namespace 进行操作。</p>
<p>系统还默认提供了一个叫 unshare 的命令，其实就是在调用 unshare() 系统调用。下面的 demo 使用 unshare 命令把当前进程的 user namespace 设置成了 root：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ whoami
nick
$ unshare --map-root-user --user sh -c whoami
root
</code></pre></div><h3 id="控制组httpdockoneioarticle8433"><a href="http://dockone.io/article/8433">控制组</a><a hidden class="anchor" aria-hidden="true" href="#控制组httpdockoneioarticle8433">#</a></h3>
<h4 id="简介-6">简介<a hidden class="anchor" aria-hidden="true" href="#简介-6">#</a></h4>
<p>说实话，一些未知的软件应用可能需要被控制或限制——至少是为了稳定性或者某种程度上的安全性。很多时候，一个bug或者仅仅只是烂代码就有可能破坏掉整个机器甚至可能削弱整个生态。幸运的是，有一种方式可以控制应用程序，Linux控制组（cgroups）是一个内核功能，用于限制、记录和隔离一个或多个进程对CPU、内存、磁盘I/O 以及网络的访问及使用。</p>
<p>即，cgroups(Control Groups) 是 linux 内核提供的一种机制，<strong>这种机制可以根据需求把一系列系统任务及其子任务整合(或分隔)到按资源划分等级的不同组内，从而为系统资源管理提供一个统一的框架</strong>。简单说，cgroups 可以限制、记录任务组所使用的物理资源。本质上来说，cgroups 是内核附加在程序上的一系列钩子(hook)，通过程序运行时对资源的调度触发相应的钩子以达到资源追踪和限制的目的。</p>
<p>控制组技术最初是由谷歌开发的，最终在2.6.24版本（2008年1月）中并入Linux内核主线。这项技术被部分重新设计，添加了kernfs（用于分割一些sysfs逻辑），这些改变被合并到3.15和3.16版本的内核中。</p>
<p>实现 cgroups 的主要目的是为不同用户层面的资源管理提供一个统一化的接口。从单个任务的资源控制到操作系统层面的虚拟化（Linux 容器或者LXC），cgroups 提供了四大功能：</p>
<ul>
<li><strong>资源限制</strong>：一个控制组可以配置成不能超过指定的内存限制或是不能使用超过一定数量的处理器或限制使用特定的外围设备。</li>
<li><strong>优先级</strong>：一个或者多个控制组可以配置成使用更少或者更多的CPU 时间片数量或者磁盘 IO 带宽，实际上就等同于控制了任务运行的优先级。</li>
<li><strong>记录</strong>：一个控制组的资源使用情况会被监督以及测量。</li>
<li><strong>控制</strong>：进程组可以被冻结，暂停或者重启。</li>
</ul>
<h4 id="概念httpswwwcnblogscomsparkdevp8296063html"><a href="https://www.cnblogs.com/sparkdev/p/8296063.html">概念</a><a hidden class="anchor" aria-hidden="true" href="#概念httpswwwcnblogscomsparkdevp8296063html">#</a></h4>
<p><strong>Task(任务)</strong> 在 linux 系统中，内核本身的调度和管理并不对进程和线程进行区分，只是根据 clone 时传入的参数的不同来从概念上区分进程和线程。这里使用 task 来表示系统的一个进程或线程。</p>
<p><strong>Cgroup(控制组)</strong> cgroups 中的资源控制以 cgroup 为单位实现。Cgroup 表示按某种资源控制标准划分而成的任务组，包含一个或多个子系统。一个任务可以加入某个 cgroup，也可以从某个 cgroup 迁移到另一个 cgroup。</p>
<p><strong>Subsystem(子系统)</strong> cgroups 中的子系统就是一个资源调度控制器(又叫 controllers)。比如 CPU 子系统可以控制 CPU 的时间分配，内存子系统可以限制内存的使用量。内核版本 4.10.0，支持的 subsystem 如下( <code>cat /proc/cgroups)</code>：</p>
<ul>
<li><strong>blkio</strong>     对块设备的 IO 进行限制。</li>
<li><strong>cpu</strong>      限制 CPU 时间片的分配，与 cpuacct 挂载在同一目录。</li>
<li><strong>cpuacct</strong>   生成 cgroup 中的任务占用 CPU 资源的报告，与 cpu 挂载在同一目录。</li>
<li><strong>cpuset</strong>    给 cgroup 中的任务分配独立的 CPU(多处理器系统) 和内存节点。</li>
<li><strong>devices</strong>   允许或禁止 cgroup 中的任务访问设备。</li>
<li><strong>freezer</strong>   暂停/恢复 cgroup 中的任务。</li>
<li><strong>hugetlb</strong>   限制使用的内存页数量。</li>
<li><strong>memory</strong>  对 cgroup 中的任务的可用内存进行限制，并自动生成资源占用报告。</li>
<li><strong>net_cls</strong>   使用等级识别符（classid）标记网络数据包，这让 Linux 流量控制器（tc 指令）可以识别来自特定 cgroup 任务的数据包，并进行网络限制。</li>
<li><strong>net_prio</strong>  允许基于 cgroup 设置网络流量(netowork traffic)的优先级。</li>
<li><strong>perf_event</strong> 允许使用 perf 工具来监控 cgroup。</li>
<li><strong>pids</strong>     限制任务的数量。</li>
</ul>
<p><strong>Hierarchy(层级)</strong> 层级有一系列 cgroup 以一个树状结构排列而成，每个层级通过绑定对应的子系统进行资源控制。层级中的 cgroup 节点可以包含零个或多个子节点，子节点继承父节点挂载的子系统。一个操作系统中可以有多个层级。</p>
<h4 id="接口">接口<a hidden class="anchor" aria-hidden="true" href="#接口">#</a></h4>
<p>（以下为 Ubuntu 20.04，内核 5.13.0-30-generic）</p>
<p>cgroups 以文件的方式提供应用接口，我们可以通过 mount 命令来查看 cgroups 默认的挂载点：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ mount | grep cgroup
tmpfs on /sys/fs/cgroup type tmpfs <span style="color:#f92672">(</span>ro,nosuid,nodev,noexec,mode<span style="color:#f92672">=</span>755,inode64<span style="color:#f92672">)</span>
cgroup on /sys/fs/cgroup/systemd type cgroup <span style="color:#f92672">(</span>rw,nosuid,nodev,noexec,relatime,xattr,name<span style="color:#f92672">=</span>systemd<span style="color:#f92672">)</span>
...
cgroup on /sys/fs/cgroup/cpuset type cgroup <span style="color:#f92672">(</span>rw,nosuid,nodev,noexec,relatime,cpuset<span style="color:#f92672">)</span>
</code></pre></div><p>第一行的 tmpfs 说明 <code>/sys/fs/cgroup</code> 目录下的文件都是存在于内存中的临时文件。</p>
<p>第二行的挂载点 <code>/sys/fs/cgroup/systemd</code> 用于 systemd 系统对 cgroups 的支持。</p>
<p>其余的挂载点则是内核支持的各个子系统的根级层级结构。</p>
<p>需要注意的是，在使用 systemd 系统的操作系统中，<code>/sys/fs/cgroup</code> 目录都是由 systemd 在系统启动的过程中挂载的，并且挂载为只读的类型。换句话说，系统是不建议我们在 <code>/sys/fs/cgroup</code> 目录下创建新的目录并挂载其它子系统的。这一点与之前的操作系统不太一样。</p>
<p>下面让我们来探索一下 <code>/sys/fs/cgroup</code> 目录及其子目录下都是些什么：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ls /sys/fs/cgroup 
blkio    cpu,cpuacct  freezer  misc              net_prio    rdma
cpu      cpuset       hugetlb  net_cls           perf_event  systemd
cpuacct  devices      memory   net_cls,net_prio  pids        unified
</code></pre></div><p><code>/sys/fs/cgroup</code> 目录下是各个子系统的根目录。我们以 memory 子系统为例，看看 memory 目录下都有什么？</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ls /sys/fs/cgroup/memory
cgroup.clone_children               memory.memsw.limit_in_bytes
cgroup.event_control                memory.memsw.max_usage_in_bytes
cgroup.procs                        memory.memsw.usage_in_bytes
cgroup.sane_behavior                memory.move_charge_at_immigrate
memory.failcnt                      memory.numa_stat
memory.force_empty                  memory.oom_control
memory.kmem.failcnt                 memory.pressure_level
memory.kmem.limit_in_bytes          memory.soft_limit_in_bytes
memory.kmem.max_usage_in_bytes      memory.stat
memory.kmem.slabinfo                memory.swappiness
memory.kmem.tcp.failcnt             memory.usage_in_bytes
memory.kmem.tcp.limit_in_bytes      memory.use_hierarchy
memory.kmem.tcp.max_usage_in_bytes  notify_on_release
memory.kmem.tcp.usage_in_bytes      release_agent
memory.kmem.usage_in_bytes          system.slice
memory.limit_in_bytes               tasks
memory.max_usage_in_bytes           user.slice
memory.memsw.failcnt
</code></pre></div><p>这些文件就是 cgroups 的 memory 子系统中的根级设置。比如 memory.limit_in_bytes 中的数字用来限制进程的最大可用内存，memory.swappiness 中保存着使用 swap 的权重等等。</p>
<h4 id="手动方法">手动方法<a hidden class="anchor" aria-hidden="true" href="#手动方法">#</a></h4>
<p>你可以直接或者间接（通过LXC、libvirt或者Docker）访问及管理控制组，这里我首先介绍使用sysfs以及<code>libgroups</code>库。接下来的示例需要你预先安装一个必须的包。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt-get install libcgroup1 cgroup-tools
</code></pre></div><p>我将使用一个简单的shell脚本文件test.sh作为示例应用程序，它将会在无限<code>while</code>循环中运行以下两个命令。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat test.sh
!/bin/shwhile <span style="color:#f92672">[</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">do</span>
    echo <span style="color:#e6db74">&#34;hello world&#34;</span>
    sleep <span style="color:#ae81ff">60</span>
<span style="color:#66d9ef">done</span>
</code></pre></div><p>安装必要的包后，你可以直接通过sysfs的目录结构来配置你的控制组，例如，要在内存子系统中创建一个叫做<code>foo</code>的控制组，只需要在<code>/sys/fs/cgroup/memory</code>底下新建一个叫做<code>foo</code>的目录：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo mkdir /sys/fs/cgroup/memory/foo
</code></pre></div><p>在我们使用 cgroups 时，最好不要直接在各个子系统的根目录下直接修改其配置文件。推荐的方式是为不同的需求在子系统树中定义不同的节点。</p>
<p>cgroups 的文件系统会在创建文件目录的时候自动创建配置文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ls /sys/fs/cgroup/memory/foo 
cgroup.clone_children               memory.memsw.failcnt
cgroup.event_control                memory.memsw.limit_in_bytes
cgroup.procs                        memory.memsw.max_usage_in_bytes
memory.failcnt                      memory.memsw.usage_in_bytes
memory.force_empty                  memory.move_charge_at_immigrate
memory.kmem.failcnt                 memory.numa_stat
memory.kmem.limit_in_bytes          memory.oom_control
memory.kmem.max_usage_in_bytes      memory.pressure_level
memory.kmem.slabinfo                memory.soft_limit_in_bytes
memory.kmem.tcp.failcnt             memory.stat
memory.kmem.tcp.limit_in_bytes      memory.swappiness
memory.kmem.tcp.max_usage_in_bytes  memory.usage_in_bytes
memory.kmem.tcp.usage_in_bytes      memory.use_hierarchy
memory.kmem.usage_in_bytes          notify_on_release
memory.limit_in_bytes               tasks
memory.max_usage_in_bytes
</code></pre></div><p>默认情况下，每个新建的控制组将会继承对系统整个内存池的访问权限。但对于某些应用程序，这些程序拒绝释放已分配的内存并继续分配更多内存，这种默认继承方式显然不是个好主意。要使程序的内存限制变得更为合理，你需要更新文件<code>memory.limit_in_bytes</code>。</p>
<p>限制控制组<code>foo</code>下运行的任何应用的内存上限为50MB：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ echo <span style="color:#ae81ff">50000000</span> | sudo tee /sys/fs/cgroup/memory/foo/memory.limit_in_bytes
</code></pre></div><p>验证设置：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo cat memory.limit_in_bytes
<span style="color:#ae81ff">49999872</span>
</code></pre></div><p>请注意，回读的值始终是内核页面大小的倍数（即4096字节或4KB）。这个值是<strong>内存的最小可分配大小</strong>。</p>
<p>启动应用程序test.sh：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sh ~/test.sh 
</code></pre></div><p>使用进程ID（PID），将应用程序移动到<code>内存</code>控制器底下的控制组<code>foo</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ echo <span style="color:#ae81ff">2152</span> | sudo tee /sys/fs/cgroup/memory/foo/cgroup.procs
</code></pre></div><p>使用相同的PID，列出正在运行的进程并验证它是否在正确的控制组下运行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ps -o cgroup <span style="color:#ae81ff">2152</span>
CGROUP
5:devices:/user.slice,4:pids:/user.slice/user-1000.slice/user@1000.service,3:m...
</code></pre></div><p>或者通过 <code>/proc/[pid]/cgroup</code> 来查看指定进程属于哪些 cgroup：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat /proc/2152/cgroup
13:cpuset:/
12:blkio:/
11:misc:/
10:rdma:/
9:freezer:/
8:cpu,cpuacct:/
7:perf_event:/
6:hugetlb:/
5:devices:/user.slice
4:pids:/user.slice/user-1000.slice/user@1000.service
3:memory:/foo <span style="color:#75715e">#here</span>
2:net_cls,net_prio:/
1:name<span style="color:#f92672">=</span>systemd:/user.slice/user-1000.slice/user@1000.service/gnome<span style="color:#ae81ff">\x</span>2dsession<span style="color:#ae81ff">\x</span>2dmanager.slice/gnome-session-manager@ubuntu.service
0::/user.slice/user-1000.slice/user@1000.service/gnome<span style="color:#ae81ff">\x</span>2dsession<span style="color:#ae81ff">\x</span>2dmanager.slice/gnome-session-manager@ubuntu.service
</code></pre></div><p>每一行包含用冒号隔开的三列，他们的含义分别是：</p>
<ul>
<li>cgroup 树的 ID， 和 /proc/cgroups 文件中的 ID 一一对应。</li>
<li>和 cgroup 树绑定的所有 subsystem，多个 subsystem 之间用逗号隔开。这里 name=systemd 表示没有和任何 subsystem 绑定，只是给他起了个名字叫 systemd。</li>
<li>进程在 cgroup 树中的路径，即进程所属的 cgroup，这个路径是相对于挂载点的相对路径。</li>
</ul>
<p>你还可以通过读取文件来监控控制组正在使用的资源。在这种情况下，你可以查看你的进程（以及生成的子进程）被分配的内存大小。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat /sys/fs/cgroup/memory/foo/memory.usage_in_bytes
<span style="color:#ae81ff">188416</span>
</code></pre></div><h4 id="当进程迷路时">当进程“迷路”时<a hidden class="anchor" aria-hidden="true" href="#当进程迷路时">#</a></h4>
<p>现在让我们重新创建相同的场景，但这次我们将控制组<code>foo</code>的内存限制从50MB改为500 bytes：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ echo <span style="color:#ae81ff">500</span> | sudo tee /sys/fs/cgroup/memory/foo/memory.limit_in_bytes
</code></pre></div><p><em>注意：如果任务超出其定义的限制，内核将进行干预，并在某些情况下终止该任务</em>。</p>
<p>同样，当您重新读取值时，它将始终是内核页面大小的倍数。因此，虽然您将其设置为500字节，但它实际上被设置为4 KB：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat /sys/fs/cgroup/memory/foo/memory.limit_in_bytes
<span style="color:#ae81ff">4096</span>
</code></pre></div><p>启动应用程序test.sh，将其移动到控制组下并监视系统日志：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo tail -f /var/log/messages
...
</code></pre></div><p>请注意，内核的Out-Of-Mempry Killer（也叫做oom-killer 内存不足杀手）在应用程序达到4KB限制时就会介入。它会杀死应用程序，应用程序将不再运行，你可以通过输入以下命令进行验证：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ps -o cgroup <span style="color:#ae81ff">2152</span>
</code></pre></div><h4 id="使用libcgroup">使用libcgroup<a hidden class="anchor" aria-hidden="true" href="#使用libcgroup">#</a></h4>
<p>之前描述的许多早期步骤都可以通过<code>libcgroup</code>包中提供的管理工具进行简化。例如，使用<code>cgcreate</code>二进制文件的单个命令即可创建sysfs条目和文件。</p>
<p>输入以下命令即可在<code>内存</code>子系统下创建一个叫做<code>foo</code>的控制组：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo cgcreate -g memory:foo
</code></pre></div><p><em>注意：libcgroup提供了一种管理控制组中任务的机制。</em></p>
<p>使用与之前相同的方法，你就可以开始设置内存阈值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ echo <span style="color:#ae81ff">50000000</span> | sudo tee /sys/fs/cgroup/memory/foo/memory.limit_in_bytes
</code></pre></div><p>验证新配置的设置：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo cat memory.limit_in_bytes
<span style="color:#ae81ff">50003968</span>
</code></pre></div><p>使用<code>cgexec</code>二进制文件在控制组<code>foo</code>中运行应用程序：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo cgexec -g memory:foo ~/test.sh
</code></pre></div><p>使用它的进程ID - PID来验证应用程序是否在控制组和子系统（<code>内存</code>）下运行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$  ps -o cgroup <span style="color:#ae81ff">2945</span>
CGROUP
6:memory:/foo,1:name<span style="color:#f92672">=</span>systemd:/user.slice/user-0.slice/session-1.scope
</code></pre></div><p>如果您的应用程序不再运行，并且您想要清理并删除控制组，则可以使用二进制文件<code>cgdelete</code>来执行此操作。要从<code>内存</code>控制器下删除控制组<code>foo</code>，请输入：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo cgdelete memory:foo
</code></pre></div><h4 id="持久组">持久组<a hidden class="anchor" aria-hidden="true" href="#持久组">#</a></h4>
<p>您也可以通过一个简单的配置文件和服务的启动来完成上述所有操作。您可以在<code>/etc/cgconfig.conf</code>文件中定义所有控制组名称和属性。以下为<code>foo</code>组添加了一些属性：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat /etc/cgconfig.conf
group foo <span style="color:#f92672">{</span>
    cpu <span style="color:#f92672">{</span>
        cpu.shares <span style="color:#f92672">=</span> 100;
    <span style="color:#f92672">}</span>
    memory <span style="color:#f92672">{</span>
        memory.limit_in_bytes <span style="color:#f92672">=</span> 5000000;
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span> 
</code></pre></div><p><code>cpu.shares</code>选项定义了该组的CPU优先级。默认情况下，所有组都继承1024 shares（CPU share指的是控制组中的任务被分配到的CPU的 time的优先级，即值越大，分配到的CPU time越多，这个值需大于等于2），即100%的CPU time（CPU time是CPU用于处理一个程序所花费的时间）。通过将<code>cpu.shares</code>的值降低到更保守的值（如100），这个组将会被限制只能使用大概10%的CPU time。</p>
<p>就如之前讨论的，在控制组中运行的进程也可以被限制它能访问的CPUs（内核）的数量。将以下部分添加到同一个配置文件<code>cgconfig.conf</code>中组名底下。</p>
<pre tabindex="0"><code>cpuset {
    cpuset.cpus=&quot;0-5&quot;;
} 
</code></pre><p>有了这个限制，这个控制组会将应用程序绑定到到0核到5核——也就是说，它只能访问系统上的前6个CPU核。</p>
<p>接下来，您需要使用<code>cgconfig</code>服务加载此配置。首先，启用cgconfig以在系统启动时能够加载上述配置：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo systemctl enable cgconfig
Create symlink from /etc/systemd/system/sysinit.target.wants/cgconfig.service
to /usr/lib/systemd/system/cgconfig.service.
</code></pre></div><p>现在，启动<code>cgconfig</code>服务并手动加载相同的配置文件（或者您可以跳过此步骤直接重启系统）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo systemctl start cgconfig
</code></pre></div><p>在控制组<code>foo</code>下启动该应用程序并将其绑定到您设置的内存和CPU限制：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo cgexec -g memory,cpu,cpuset:foo ~/test.sh &amp;
</code></pre></div><p>除了将应用程序启动到预定义的控制组之外，其余所有内容都将在系统重新启动后持续存在。但是，您可以通过定义依赖于<code>cgconfig</code>服务的启动初始脚本来启动该应用程序，自动执行该过程。</p>
<h4 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h4>
<p>通常来说，限制一个机器上一个或者多个任务的权限是必要的。控制组提供了这项功能，通过使用它，您可以对一些特别重要或无法控制的应用程序实施严格的硬件和软件限制。如果一个应用程序没有设置上限阈值或限制它可以在系统上消耗的内存量，cgroups可以解决这个问题。如果另一个应用程序没有CPU上的限制，那么cgroups可以再一次解决您的问题。您可以通过cgroup完成这么多工作，只需花一点时间，您就可以使用你的操作系统环境恢复稳定性，安全性和健全性。</p>
<h4 id="使用-systemdhttpswwwcnblogscomsparkdevp9523194html"><a href="https://www.cnblogs.com/sparkdev/p/9523194.html">使用 Systemd</a><a hidden class="anchor" aria-hidden="true" href="#使用-systemdhttpswwwcnblogscomsparkdevp9523194html">#</a></h4>
<p>当 Linux 的 init 系统发展到 systemd 之后，systemd 与 cgroups 发生了融合(或者说 systemd 提供了 cgroups 的使用和管理接口)。</p>
<p><strong>Systemd 依赖 cgroups</strong></p>
<p>要理解 systemd 与 cgroups 的关系，我们需要先区分 cgroups 的两个方面：<em>层级结构(A)和资源控制(B)</em>。首先 cgroups 是以层级结构组织并标识进程的一种方式，同时它也是在该层级结构上执行资源限制的一种方式。我们简单的把 cgroups 的层级结构称为 A，把 cgrpups 的资源控制能力称为 B。</p>
<p>对于 systemd 来说，A 是必须的，如果没有 A，systemd 将不能很好的工作。而 B 则是可选的，如果你不需要对资源进行控制，那么在编译 Linux 内核时完全可以去掉 B 相关的编译选项。</p>
<p><strong>Systemd 默认挂载的 cgroups 系统</strong></p>
<p>在系统的开机阶段，systemd 会把支持的 controllers (subsystem 子系统)挂载到默认的 <code>/sys/fs/cgroup/</code> 目录下面，除了 systemd 目录外，其它目录都是对应的 subsystem。</p>
<p><code>/sys/fs/cgroup/systemd</code> 目录是 systemd 维护的自己使用的非 subsystem 的 cgroups 层级结构。换句话说就是，并不允许其它的程序动这个目录下的内容。其实 <code>/sys/fs/cgroup/systemd</code> 目录对应的 cgroups 层级结构就是 systemd 用来使用 cgoups 中 feature A 的。</p>
<p><strong>Cgroup 的默认层级</strong></p>
<p><em>过将 cgroup 层级系统与 systemd unit 树绑定，systemd 可以把资源管理的设置从进程级别移至应用程序级别。因此，我们可以使用 systemctl 指令，或者通过修改 systemd unit 的配置文件来管理 unit 相关的资源。</em></p>
<p>默认情况下，systemd 会自动创建 <strong>slice、scope 和 service</strong> unit 的层级来为 cgroup 树提供统一的层级结构。</p>
<p>系统中运行的所有进程，都是 systemd init 进程的子进程。在资源管控方面，systemd 提供了三种 unit 类型：</p>
<ul>
<li><strong>service</strong>： 一个或一组进程，由 systemd 依据 unit 配置文件启动。service 对指定进程进行封装，这样进程可以作为一个整体被启动或终止。</li>
<li><strong>scope</strong>：一组外部创建的进程。由进程通过 fork() 函数启动和终止、之后被 systemd 在运行时注册的进程，scope 会将其封装。例如：用户会话、 容器和虚拟机被认为是 scope。</li>
<li><strong>slice</strong>： 一组按层级排列的 unit。slice 并不包含进程，但会组建一个层级，并将 scope 和 service 都放置其中。真正的进程包含在 scope 或 service 中。在这一被划分层级的树中，每一个 slice 单位的名字对应通向层级中一个位置的路径。</li>
</ul>
<p>以通过 systemd-cgls 命令来查看 cgroups 的层级结构</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">Control group /:
-.slice
├─419 bpfilter_umh
├─user.slice 
│ ├─user-125.slice 
│ │ ├─session-c1.scope 
│ │ │ ├─1101 gdm-session-worker <span style="color:#f92672">[</span>pam/gdm-launch-environment<span style="color:#f92672">]</span>
│ │ │ ├─1158 /usr/lib/gdm3/gdm-x-session dbus-run-session -- gnome-session -&gt;
│ │ │ ├─1160 /usr/lib/xorg/Xorg vt1 -displayfd <span style="color:#ae81ff">3</span> -auth /run/user/125/gdm/Xau&gt;
│ │ │ ├─1347 dbus-run-session -- gnome-session --autostart /usr/share/gdm/gr&gt;
│ │ │ ├─1348 dbus-daemon --nofork --print-address <span style="color:#ae81ff">4</span> --session
│ │ │ ├─1349 /usr/libexec/gnome-session-binary --systemd --autostart /usr/sh&gt;
│ │ │ ├─1352 /usr/libexec/at-spi-bus-launcher
│ │ │ ├─1357 /usr/bin/dbus-daemon --config-file<span style="color:#f92672">=</span>/usr/share/defaults/at-spi2/&gt;
│ │ │ ├─1378 /usr/bin/gnome-shell
│ │ │ ├─1432 ibus-daemon --panel disable --xim
│ │ │ ├─1435 /usr/libexec/ibus-dconf
│ │ │ ├─1438 /usr/libexec/ibus-x11 --kill-daemon
│ │ │ ├─1440 /usr/libexec/ibus-portal
│ │ │ ├─1451 /usr/libexec/at-spi2-registryd --use-gnome-session
</code></pre></div><p>service、scope 和 slice unit 被直接映射到 cgroup 树中的对象。当这些 unit 被激活时，它们会直接一一映射到由 unit 名建立的 cgroup 路径中。例如，cron.service 属于 system.slice，会直接映射到 cgroup system.slice/cron.service/ 中。
注意，所有的用户会话、虚拟机和容器进程会被自动放置在一个单独的 scope 单元中。</p>
<p>默认情况下，系统会创建四种 slice：</p>
<ul>
<li><strong>-.slice</strong>：根 slice</li>
<li><strong>system.slice</strong>：所有系统 service 的默认位置</li>
<li><strong>user.slice</strong>：所有用户会话的默认位置</li>
<li><strong>machine.slice</strong>：所有虚拟机和 Linux 容器的默认位置</li>
</ul>
<p><strong>创建临时的 cgroup</strong></p>
<p>对资源管理的设置可以是 transient(临时的)，也可以是 persistent (永久的)。我们先来介绍如何创建临时的 cgroup。</p>
<p>需要使用 <strong>systemd-run</strong> 命令创建临时的 cgroup，它可以创建并启动临时的 service 或 scope unit，并在此 unit 中运行程序。systemd-run 命令默认创建 service 类型的 unit，比如我们创建名称为 toptest 的 service 运行 top 命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo systemd-run --unit<span style="color:#f92672">=</span>toptest --slice<span style="color:#f92672">=</span>test top -b
</code></pre></div><p>然后查看一下 test.slice 的状态：</p>
<pre tabindex="0"><code>$ sudo systemctl status test.slice
</code></pre><p>创建了一个 test.slice/toptest.service cgroup 层级关系。再看看 toptest.service 的状态：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo systemctl status toptest.service
</code></pre></div><p>top 命令被包装成一个 service 运行在后台了！</p>
<p>接下来我们就可以通过 systemctl 命令来限制 toptest.service 的资源了。在限制前让我们先来看一看 top 进程的 cgroup 信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat /proc/2850/cgroup
</code></pre></div><p>比如我们限制 toptest.service 的 CPUShares 为 600，可用内存的上限为 550M：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo systemctl set-property toptest.service CPUShares<span style="color:#f92672">=</span><span style="color:#ae81ff">600</span> MemoryLimit<span style="color:#f92672">=</span>500M
</code></pre></div><p>再次检查 top 进程的 cgroup 信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat /proc/2850/cgroup
</code></pre></div><p>在 CPU 和 memory 子系统中都出现了 toptest.service 的名字。同时去查看 <code>/sys/fs/cgroup/memory/test.slice</code> 和 <code>/sys/fs/cgroup/cpu/test.slice</code> 目录，这两个目录下都多出了一个 toptest.service 目录。我们设置的 CPUShares=600 MemoryLimit=500M 被分别写入了这些目录下的对应文件中。</p>
<p><em>临时 cgroup 的特征是，所包含的进程一旦结束，临时 cgroup 就会被自动释放</em>。比如我们 kill 掉 top 进程，然后再查看 /sys/fs/cgroup/memory/test.slice 和 /sys/fs/cgroup/cpu/test.slice 目录，刚才的 toptest.service 目录已经不见了。</p>
<p><strong>通过配置文件修改 cgroup</strong></p>
<p>所有被 systemd 监管的 persistent cgroup(持久的 cgroup)都在 <code>/usr/lib/systemd/system/</code> 目录中有一个 unit 配置文件。比如我们常见的 service 类型 unit 的配置文件。我们可以通过设置 unit 配置文件来控制应用程序的资源，persistent cgroup 的特点是即便系统重启，相关配置也会被保留。需要注意的是，scope unit 不能以此方式创建。下面让我们为 cron.service 添加 CPU 和内存相关的一些限制，编辑 <code>/lib/systemd/system/cron.service</code> 文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo vim /lib/systemd/system/cron.service
<span style="color:#f92672">[</span>Service<span style="color:#f92672">]</span>
CPUShares<span style="color:#f92672">=</span><span style="color:#ae81ff">600</span>
MemoryLimit<span style="color:#f92672">=</span>500M
EnviromentFile<span style="color:#f92672">=</span>-/etc/default/cron
ExecStart<span style="color:#f92672">=</span>/usr/sbin/cron -f $EXTRA_OPTS
IgnoreSIGPIPE<span style="color:#f92672">=</span>false
KillMode<span style="color:#f92672">=</span>process
</code></pre></div><p>然后重新加载配置文件并重启 cron.service：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo systemctl daemon-reload
$ sudo systemctl restart cron.service
</code></pre></div><p>现在去查看 <code>/sys/fs/cgroup/memory/system.slice/cron.service/memory.limit_in_bytes</code> 和 <code>/sys/fs/cgroup/cpu/system.slice/cron.service/cpu.shares</code> 文件，是不是已经包含我们配置的内容了！</p>
<p><strong>通过 systemctl 命令修改 cgroup</strong></p>
<p>除了编辑 unit 的配置文件，还可以通过 systemctl set-property 命令来修改 cgroup，这种方式修该的配置也会在重启系统时保存下来。现在我们把 cron.service 的 CPUShares 改为 700：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo systemctl set-property cron.service CPUShares<span style="color:#f92672">=</span><span style="color:#ae81ff">700</span>
</code></pre></div><p>查看 <code>/sys/fs/cgroup/cpu/system.slice/cron.service/cpu.shares</code> 文件的内容应该是 700，重启系统后该文件的内容还是 700。</p>
<p><strong>Systemd-cgtop 命令</strong></p>
<p>类似于 top 命令，systemd-cgtop 命令显示 cgoups 的实时资源消耗情况。</p>
<p>通过它我们就可以分析应用使用资源的情况。</p>
<h3 id="lxchttpdockoneioarticle8631"><a href="http://dockone.io/article/8631">LXC</a><a hidden class="anchor" aria-hidden="true" href="#lxchttpdockoneioarticle8631">#</a></h3>
<p>LXC（Linux容器，Linux Container）相当于你运行了一个接近于裸机的虚拟机。这项技术始于2008年，LXC的大部分功能来自于Solaris容器（又叫做Solaries Zones）以及之前的FreeBSD jails技术。 LXC并不是创建一个成熟的虚拟机，而是创建了一个拥有自己进程程和网络空间的虚拟环境，使用命名空间来强制进程隔离并利用内核的控制组（cgroups）功能，该功能可以限制，计算和隔离一个或多个进程的CPU，内存，磁盘I / O和网络使用情况。 您可以将这种用户空间框架想像成是<code>chroot</code>的高级形式。</p>
<blockquote>
<p><code>chroot</code> 是一个改变当前运行进程以及其子进程的根目录的操作。一个运行在这种环境的程序无法访问根目录外的文件和命令。</p>
</blockquote>
<p>注意：LXC使用命名空间来强制进程隔离，同时利用内核的控制组来计算以及限制一个或多个进程的CPU，内存，磁盘I / O和网络使用。</p>
<p>但容器究竟是什么？简短的答案是容器将软件应用程序与操作系统分离，为用户提供干净且最小的Linux环境，与此同时在一个或多个隔离的“容器”中运行其他所有内容。容器的目的是启动一组有限数量的应用程序或服务（通常称为微服务），并使它们在独立的沙盒环境中运行。</p>
<p><img loading="lazy" src="../../../Distributions/4db26d0e1162aa7a8f61fd387d465f26.png" alt=""  />
</p>
<p>这种隔离可防止在给定容器内运行的进程监视或影响在另一个容器中运行的进程。此外，这些集装箱化服务不会影响或干扰主机。能够将分散在多个物理服务器上的许多服务合并为一个的想法是数据中心选择采用该技术的众多原因之一。</p>
<p>容器有以下几个特点：</p>
<ul>
<li>安全性：容器里可以运行网络服务，这可以限制安全漏洞或违规行为造成的损害。那些成功利用那个容器的一个或多个应用的安全漏洞的入侵者将会被限制在只能在那个容器中做一些操作。</li>
<li>隔离性：容器允许在同一物理机器上部署一个或多个应用程序，即使这些应用程序必须在不同的域下运行，每个域都需要独占访问其各自的资源。例如，通过将每个容器关联的不同IP地址，在不同容器中运行的多个应用程序可以绑定到同一物理网络接口。</li>
<li>虚拟化和透明性：容器为系统提供虚拟化环境，这个环境可以隐藏或限制系统底层的物理设备或系统配置的可见性。容器背后的一般原则是避免更改运行应用程序的环境，但解决安全性或隔离问题除外。</li>
</ul>
<h4 id="使用lxc的工具">使用LXC的工具<a hidden class="anchor" aria-hidden="true" href="#使用lxc的工具">#</a></h4>
<p>对于大多数现代Linux发行版，内核都启用了控制组，但您很可能仍需要安装LXC工具。</p>
<p>对于Ubuntu或Debian，只需键入：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt-get install lxc
</code></pre></div><p>现在，在开始使用这些工具之前，您需要配置您的环境。在此之前，您需要验证当前用户是否同时在<code>/etc/subuid</code>和<code>/etc/subgid</code>中定义了uid和gid：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat /etc/subuid
petros:100000:65536
$ cat /etc/subgid
petros:100000:65536
</code></pre></div><p>如果<code>~/.config/lxc</code>不存在，则创建该目录，并且把配置文件<code>/etc/lxc/default.conf</code>复制到<code>~/.config/lxc/default.conf.</code>，将以下两行添加到文件末尾：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">lxc.id_map <span style="color:#f92672">=</span> u <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">100000</span> <span style="color:#ae81ff">65536</span>
lxc.id_map <span style="color:#f92672">=</span> g <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">100000</span> <span style="color:#ae81ff">65536</span>
</code></pre></div><p>结果如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat ~/.config/lxc/default.conf
lxc.network.type <span style="color:#f92672">=</span> veth
lxc.network.link <span style="color:#f92672">=</span> lxcbr0
lxc.network.flags <span style="color:#f92672">=</span> up
lxc.network.hwaddr <span style="color:#f92672">=</span> 00:16:3e:xx:xx:xx
lxc.id_map <span style="color:#f92672">=</span> u <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">100000</span> <span style="color:#ae81ff">65536</span>
lxc.id_map <span style="color:#f92672">=</span> g <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">100000</span> <span style="color:#ae81ff">65536</span>
</code></pre></div><p>将以下命令添加到<code>/etc/lxc/lxc-usernet</code>文件末尾（把第一列换成你的username）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">petros veth lxcbr0 <span style="color:#ae81ff">10</span>
</code></pre></div><p>最快使这些配置生效的方法是重启或者将用户登出再登入。</p>
<p>重新登录后，请验证当前是否已加载veth网络驱动程序：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ lsmod | grep veth
veth                   <span style="color:#ae81ff">16384</span>  <span style="color:#ae81ff">0</span>
</code></pre></div><p>如果没有，请输入：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo modprobe veth
</code></pre></div><p>现在您可以使用LXC工具集来下载，运行，管理Linux容器。</p>
<p>接下来，下载容器镜像并将其命名为“example-container”。当您键入以下命令时，您将看到一长串许多Linux发行版和版本支持的容器：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo lxc-create -t download -n example-container
</code></pre></div><p>将会有三个弹出框让您分别选择发行版名称（distribution），版本号（release）以及架构（architecture）。请选择以下三个选项：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">Distribution: ubuntu
Release: xenial
Architecture: amd64
</code></pre></div><p>选择后点击<code>Enter</code>，rootfs将在本地下载并配置。出于安全原因，每个容器不附带OpenSSH服务器或用户帐户。同时也不会提供默认的root密码。要更改root密码并登录，必须在容器目录路径中运行lxc-attach或chroot（在启动之后）。</p>
<p>启动容器：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo lxc-start -n example-container -d
</code></pre></div><p><code>-d</code>选项表示隐藏容器，它会在后台运行。如果您想要观察boot的过程，只需要将<code>-d</code>换成<code>-F</code>。那么它将在前台运行，登录框出现时结束。</p>
<p>你可能会遇到如下错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo lxc-start -n example-container -d
lxc-start: tools/lxc_start.c: main: <span style="color:#ae81ff">366</span> The container
failed to start.
lxc-start: tools/lxc_start.c: main: <span style="color:#ae81ff">368</span> To get more details,
run the container in foreground mode.
lxc-start: tools/lxc_start.c: main: <span style="color:#ae81ff">370</span> Additional information
can be obtained by setting the --logfile and --logpriority
options.
</code></pre></div><p>如果你遇到了，您需要通过在前台运行lxc-start服务来调试它：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo lxc-start -n example-container -F
lxc-start: conf.c: instantiate_veth: <span style="color:#ae81ff">2685</span> failed to create veth
pair <span style="color:#f92672">(</span>vethQ4NS0B and vethJMHON2<span style="color:#f92672">)</span>: Operation not supported
lxc-start: conf.c: lxc_create_network: <span style="color:#ae81ff">3029</span> failed to
create netdev
lxc-start: start.c: lxc_spawn: <span style="color:#ae81ff">1103</span> Failed to create
the network.
lxc-start: start.c: __lxc_start: <span style="color:#ae81ff">1358</span> Failed to spawn
container <span style="color:#e6db74">&#34;example-container&#34;</span>.
lxc-start: tools/lxc_start.c: main: <span style="color:#ae81ff">366</span> The container failed
to start.
lxc-start: tools/lxc_start.c: main: <span style="color:#ae81ff">370</span> Additional information
can be obtained by setting the --logfile and --logpriority
options.
</code></pre></div><p>从以上示例，你可以看到模块<code>veth</code>没有被引入，在引入之后，将会解决这个问题。</p>
<p>之后，打开第二个terminal窗口，验证容器的状态。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo lxc-info -n example-container
Name:           example-container
State:          RUNNING
PID:            <span style="color:#ae81ff">1356</span>
IP:             10.0.3.28
CPU use:        0.29 seconds
BlkIO use:      16.80 MiB
Memory use:     29.02 MiB
KMem use:       <span style="color:#ae81ff">0</span> bytes
Link:           vethPRK7YU
TX bytes:      1.34 KiB
RX bytes:      2.09 KiB
Total bytes:   3.43 KiB
</code></pre></div><p>也可以通过另一种方式来查看所有安装的容器，运行命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo lxc-ls -f
NAME         STATE   AUTOSTART GROUPS IPV4      IPV6
example-container RUNNING <span style="color:#ae81ff">0</span>         -      10.0.3.28 -
</code></pre></div><p>但是问题是你仍然不能登录进去，你只需要直接attach到正在运行的容器，创建你的用户，使用<code>passwd</code>命令改变相关的密码。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo lxc-attach -n example-container
root@example-container:/#
root@example-container:/# useradd petros
root@example-container:/# passwd petros
Enter new UNIX password:
Retype new UNIX password:
passwd: password updated successfully
</code></pre></div><p>更改密码后，您将能够从控制台直接登录到容器，而无需使用<code>lxc-attach</code>命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo lxc-console -n example-container
</code></pre></div><p>如果要通过网络连接到此运行容器，请安装OpenSSH服务器：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># apt-get install openssh-server</span>
</code></pre></div><p>抓取容器的本地IP地址：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># ip addr show eth0|grep inet</span>
inet 10.0.3.25/24 brd 10.0.3.255 scope global eth0
inet6 fe80::216:3eff:fed8:53b4/64 scope link
</code></pre></div><p>然后在主机的新的控制台窗口中键入：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ssh 10.0.3.25
</code></pre></div><p>瞧！您现在可以SSH到正在运行的容器并键入您的用户名和密码。</p>
<p>在主机系统上，而不是在容器内，可以观察在启动容器后启动和运行的LXC进程：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ps aux | grep lxc | grep -v grep
...
</code></pre></div><p>要停止容器，请键入（在主机）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo lxc-stop -n example-container
</code></pre></div><p>停止后，验证容器的状态：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo lxc-ls -f
NAME         STATE   AUTOSTART GROUPS IPV4 IPV6
example-container STOPPED <span style="color:#ae81ff">0</span>         -      -    -

$ sudo lxc-info -n example-container
Name:           example-container
State:          STOPPED
</code></pre></div><p>要彻底销毁容器 - 即从主机system—type清除它：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo lxc-destroy -n example-container
Destroyed container example-container
</code></pre></div><p>销毁后，可以验证是否已将其删除：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo lxc-info -n example-container
example-container doesn<span style="color:#960050;background-color:#1e0010">&#39;</span>t exist
$ sudo lxc-ls -f
</code></pre></div><p>注意：如果您尝试销毁正在运行的容器，该命令将失败并告知您容器仍在运行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo lxc-destroy -n example-container
example-container is running
</code></pre></div><p>在销毁容器前必须先停止它。</p>
<h4 id="高级配置">高级配置<a hidden class="anchor" aria-hidden="true" href="#高级配置">#</a></h4>
<p>有时，可能需要配置一个或多个容器来完成一个或多个任务。 LXC通过让管理员修改位于<code>/var/lib/lxc</code>中的容器配置文件来简化这一过程：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo su
<span style="color:#75715e"># cd /var/lib/lxc</span>
<span style="color:#75715e"># ls</span>
example-container
</code></pre></div><p>容器的父目录将包含至少两个文件：1）容器配置文件和 2）容器的整个rootfs：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># cd example-container/</span>
<span style="color:#75715e"># ls</span>
config  rootfs
</code></pre></div><p>假设您想要在主机系统启动时自动启动名称为<code>example-container</code>的容器。那么您需要将以下行添加到容器的配置文件<code>/var/lib/lxc/example-container/config</code>的尾部：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># Enable autostart</span>
lxc.start.auto <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</code></pre></div><p>重新启动容器或重新启动主机系统后，您应该看到如下内容：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo lxc-ls -f
NAME              STATE   AUTOSTART GROUPS IPV4      IPV6
example-container RUNNING <span style="color:#ae81ff">1</span>         -      10.0.3.25 -
</code></pre></div><p>注意 <code>AUTOSTART</code> 字段现在被设置为“1”。</p>
<p>如果在容器启动时，您希望容器绑定装载主机上的目录路径，请将以下行添加到同一文件的尾部：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 将挂载系统路径绑定到本地路径</span>
lxc.mount.entry <span style="color:#f92672">=</span> /mnt mnt none bind <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span>
</code></pre></div><p>通过上面的示例，当容器重新启动时，您将看到容器本地的 / mnt目录可访问的主机/ mnt目录的内容。</p>
<h4 id="特权与非特权容器">特权与非特权容器<a hidden class="anchor" aria-hidden="true" href="#特权与非特权容器">#</a></h4>
<p>您经常会发现在与LXC相关的内容中讨论特权容器和非特权容器的概念。但它们究竟是什么呢？这个概念非常简单，并且LXC容器可以在任一配置下运行。</p>
<p>根据设计，无特权容器被认为比特权容器更安全，更保密。无特权容器运行时，容器的root UID映射到主机系统上的非root UID。这使得攻击者即使破解了容器，也难以获得对底层主机的root权限。简而言之，如果攻击者设法通过已知的软件漏洞破坏了您的容器，他们会立即发现自己无法获取任何主机权限。</p>
<p>特权容器可能使系统暴露于此类攻击。这就是为什么我们最好在特权模式下运行尽量少的容器。确定需要特权访问的容器，并确保付出额外的努力来定期更新并以其他方式锁定它们。</p>
<h4 id="然而docker又是什么呢">然而，Docker又是什么呢？<a hidden class="anchor" aria-hidden="true" href="#然而docker又是什么呢">#</a></h4>
<p>我花了相当多的时间谈论Linux容器，但是Docker呢？它是生产中部署最多的容器解决方案。自首次推出以来，Docker已经风靡Linux计算世界。 Docker是一种Apache许可的开源容器化技术，旨在自动化在容器内创建和部署微服务这类重复性任务。 Docker将容器视为非常轻量级和模块化的虚拟机。最初，Docker是在LXC之上构建的，但它已经远离了这种依赖，从而带来了更好的开发人员和用户体验。与LXC非常相似，Docker继续使用内核<code>cgroup</code>子系统。该技术不仅仅是运行容器，还简化了创建容器，构建映像，共享构建的映像以及对其进行版本控制的过程。</p>
<p>Docker主要关注于：</p>
<ul>
<li>可移植性：Docker提供基于镜像的部署模型。这种类型的可移植性允许更简单的方式在多个环境中共享应用程序或服务集合（以及它们的所有依赖）。</li>
<li>版本控制：单个Docker镜像由一系列组合层组成。每当镜像被更改时，都会创建一个新层。例如，每次用户指定命令（例如运行或复制）时，都会创建一个新层。 Docker将重用这些层用于新的容器构建。分层到Docker是它自己的版本控制方法。</li>
<li>回滚：再次，每个Docker镜像都有很多层。如果您不想使用当前运行的层，则可以回滚到以前的版本。这种敏捷性使软件开发人员可以更轻松地持续集成和部署他们的软件技术。</li>
<li>快速部署：配置新硬件通常需要数天时间。并且，安装和配置它的工作量和开销是非常繁重的。使用Docker，您可以在几秒钟将镜像启动并运行，相比于之前，节省了大量的时间。当你使用完一个容器时，你可以轻松地销毁它。</li>
</ul>
<p>从本质上说，Docker和LXC都非常相似。它们都是用户空间和轻量级虚拟化平台，它们利用cgroup和命名空间来管理资源隔离。但是，两者之间也存在许多明显的差异。</p>
<h5 id="进程管理">进程管理<a hidden class="anchor" aria-hidden="true" href="#进程管理">#</a></h5>
<p>Docker将容器限制为单个进程运行。如果您的应用程序包含X个并发进程，Docker将要求您运行X个容器，每个容器都有自己单独的进程。 LXC不是这样，LXC运行具有传统init进程的容器，反过来，可以在同一容器内托管多个进程。例如，如果要托管LAMP（Linux + Apache + MySQL + PHP）服务器，每个应用程序的每个进程都需要跨越多个Docker容器。</p>
<h5 id="状态管理">状态管理<a hidden class="anchor" aria-hidden="true" href="#状态管理">#</a></h5>
<p>Docker被设计为无状态，意味着它不支持持久存储。有很多方法可以解决这个问题，但同样，只有在进程需要时才需要它。创建Docker镜像时，它将包含只读层。这不会改变。在运行时，如果容器的进程对其内部状态进行任何更改，则将保持内部状态和镜像的当前状态之间的差异，直到对Docker镜像进行提交（创建新层）或直到容器被删除，差异也会消失。</p>
<h5 id="可移植性">可移植性<a hidden class="anchor" aria-hidden="true" href="#可移植性">#</a></h5>
<p>在讨论Docker时，这个词往往被过度使用——因为它是Docker相对于LXC的最重要的优势。 Docker从应用程序中抽象出网络，存储和操作系统细节方面做得更好。这样就形成了一个真正独立于配置的应用程序，保证应用程序的环境始终保持不变，无论启用它的机器配置环境如何。</p>
<p>Docker旨在使开发人员和系统管理员都受益。它已成为许多DevOps（开发人员+维护人员）工具链中不可或缺的一部分。开发人员可以专注于编写代码，而无需担心最终托管它的系统是什么。使用Docker，无需安装和配置复杂数据库，也无需担心在不兼容的语言工具链版本之间切换。 Docker为维护人员提供了更多的灵活性，通常可以减少托管一些较小和更基本的应用程序所需的物理系统数量。 Docker简化了软件交付。新功能和错误/安全修复程序可以快速到达客户，无需任何麻烦，意外或停机。</p>
<h4 id="总结-1">总结<a hidden class="anchor" aria-hidden="true" href="#总结-1">#</a></h4>
<p>为了基础设施安全性和系统稳定性而隔离进程并不像听起来那么痛苦。 Linux内核提供了所有必要的工具，使简单易用的用户空间应用程序【如LXC（甚至Docker）】能够在隔离的沙盒环境中管理操作系统的微实例及其本地服务。</p>
<h3 id="沙箱httpshyperjnet20162016-11-23-linux-sandbox"><a href="https://hyperj.net/2016/2016-11-23-linux-sandbox/">沙箱</a><a hidden class="anchor" aria-hidden="true" href="#沙箱httpshyperjnet20162016-11-23-linux-sandbox">#</a></h3>
<p>在计算机安全领域，沙箱(Sandbox)是一种程序的隔离运行机制，其目的是限制不可信进程的权限。沙箱技术经常被用于执行未经测试的或不可信的客户程序。为了避免不可信程序可能破坏其它程序的运行，沙箱技术通过为不可信客户程序提供虚拟化的磁盘、内存以及网络资源，而这种虚拟化手段对客户程序来说是透明的。由于沙箱里的资源被虚拟化（或被间接化），所以沙箱里的不可信程序的恶意行为往往会被限制在沙箱中。</p>
<p>沙箱技术一直是系统安全领域的挑战，不存在说哪一种方案是足够安全的。沙箱技术方案通常是需要结合多种系统安全技术来实现，采用防御纵深(Defence in Depth)的设计原则，筑建多道防御屏障，尽可能地将安全风险将为最低。下面我们主要讨论如何利用Linux kernel所提供的安全功能来建立有效的沙箱技术。</p>
<p>在讨论之前，我们简单回顾一下Linux安全模型相关的内容（假设读者已经非常熟悉）：</p>
<p>(1) 每个进程都有自己的地址空间；</p>
<p>(2) MMU硬件机制来保证地址空间的隔离；</p>
<p>(3) Kernel是系统的TCB(Trusted Computing Base)，是安全策略的制定者和执行者；</p>
<p>(4) 进程是最小的权限边界；</p>
<p>(5) root具有最高权限，它能控制一切；</p>
<p>(6) 其它用户受DAC(Discretionary Access Control)限制，如文件系统的UGO权限控制。</p>
<p>进程是最小的权限边界，其根本原因是MMU能保证进程地址空间的隔离。</p>
<p>Linux Kernel还提供了与进程降权(drop privilege)相关的一些功能：</p>
<ol>
<li>setuid</li>
<li>POSIX.1e capability</li>
<li>chroot jail</li>
<li>Quota control (eg, cgroup, namespace)</li>
<li>Linux Container</li>
<li>Linux Security Module (LSM)</li>
</ol>
<p>下面我们会介绍如何在实践中利用这些诀窍来构建一个有效的sandbox.</p>
<h2 id="权限">权限<a hidden class="anchor" aria-hidden="true" href="#权限">#</a></h2>
<h3 id="ugohttpswwwcnblogscomsparkdevp9573355html"><a href="https://www.cnblogs.com/sparkdev/p/9573355.html">ugo</a><a hidden class="anchor" aria-hidden="true" href="#ugohttpswwwcnblogscomsparkdevp9573355html">#</a></h3>
<p>Linux 系统中文件的 ugo 权限是 Linux 进行权限管理的基本方式。</p>
<h4 id="所有者和组">所有者和组<a hidden class="anchor" aria-hidden="true" href="#所有者和组">#</a></h4>
<p>Linux 文件的 ugo 权限把对文件的访问者划分为三个类别：文件的所有者、组和其他人。所谓的 ugo 就是指 user(也称为 owner)、group 和 other 三个单词的首字母组合。</p>
<p>用户和组的信息分别记录在 <code>/etc/passwd</code>、<code>/etc/group</code> 文件中，这两个文件的内容是任何人都有权查看的，可以直接以读取文本文件的方式查看其内容，其中的每一行代表一个用户。</p>
<p><strong>文件的所有者</strong></p>
<p>文件的所有者一般是创建该文件的用户，对该文件具有完全的权限。在一台允许多个用户访问的 Linux 主机上，可以通过文件的所有者来区分一个文件属于某个用户。当然，一个用户也无权查看或更改其它用户的文件。</p>
<p><strong>文件所属的组</strong></p>
<p>假如有几个用户合作开发同一个项目，如果每个用户只能查看和修改自己创建的文件就太不方便了，也就谈不上什么合作了。所以需要一个机制允许一个用户查看和修改其它用户的文件，此时就用到组的概念的。我们可以创建一个组，然后把需要合作的用户都添加都这个组中。在设置文件的访问权限时，允许这个组中的用户对该文件进行读取和修改。</p>
<p><strong>其他人</strong></p>
<p>如果我想把一个文件共享给系统中的所有用户该怎么办？通过组的方式显然是不合适的，因为需要把系统中的所有用户都添加到一个组中。并且系统中添加了新用户该怎么办，每添加一个新用户就把他添加到这个组中吗？这个问题可以通过其他人的概念解决。在设置文件的访问权限时，允许其他人户对该文件进行读取和修改。</p>
<h4 id="文件属性">文件属性<a hidden class="anchor" aria-hidden="true" href="#文件属性">#</a></h4>
<p>使用 ll 命令可以查看文件的属性信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ll Desktop
drwxr-xr-x <span style="color:#ae81ff">2</span> nick nick 4.0K Mar  <span style="color:#ae81ff">2</span> 15:06 Desktop
</code></pre></div><ul>
<li>drwxr-xr-x 指明文件的类型和 ugo 权限信息。</li>
<li>2 是对文件的引用计数。</li>
<li>nick 是文件的所有者，文件的所有者一般是创建该文件的用户，对该文件具有完全的权限。</li>
<li>nick 是文件所属的组，我们通过 adduser 命令创建用户时一般会创建一个同名的组，该用户就属于与他同名的组(比如笔者机器上的用户 nick 就属于 nick 组)。当我们创建文件和目录时，其默认所属的组就是所有者所在的组。</li>
</ul>
<p>其它的信息我们暂时忽略。</p>
<p><strong>文件类型</strong></p>
<p>drwxr-xr-x 的第一个字符描述文件的类型，常见的类型有如下几种：</p>
<ul>
<li>d 表示目录</li>
<li>- 表示普通文件</li>
<li>l 表示链接文件</li>
<li>b 表示块设备文件</li>
<li>c 表示字符设备文件</li>
<li>s 表示 socket 文件</li>
</ul>
<p><strong>ugo 权限信息</strong></p>
<p>10 个字符，除去第一个表示文件类型的字符，其它 9 个字符表示文件的 ugo 权限信息</p>
<p><img loading="lazy" src="/Distributions/952033-20180902120612711-514991426.png" alt=""  />
</p>
<p>这 9 个字符以三个为一组，都是 rwx 或 - 的组合。其中，<em>r 代表可读(read)、 w 代表可写(write)、 x 代表可执行(execute)</em>。 这三个权限的位置不会改变，如果没有对应的权限，就会以 -(减号)代替。</p>
<p>*第一组为文件所有者的权限，第二组为文件所属组的权限，第三组为其他人的权限。*其表示的具体含义为：文件所有者具有对文件的读写权限，文件所属组的用户具有对文件读写的权限，而其他人只有读取文件的权限。</p>
<p>下面详细的解释一下文件读写执行的权限：</p>
<ul>
<li>r (read)：可以读取文件的实际内容，比如读取文本文件内的文字等。</li>
<li>w (write)：可以编辑、增加、删除文件的内容(但不含删除该文件)。</li>
<li>x (execute)：该文件具有可以被系统执行的权限。</li>
</ul>
<p>可以看出，对于文件来说，rwx 主要针对的是文件的内容。</p>
<p>对目录而言，目录中存储的主要是目录下文件名称的列表，这与普通文件是有些不同的：</p>
<ul>
<li>r (read contents in directory) 表示具有读取目录下文件名称的权限，也就是说你可以通过 ls 命令把目录下的文件列表查询出来。</li>
<li>w (modify contents of directory) 具有 w 权限表明你可以在该目录下执行如下的操作：
<ul>
<li>创建新的文件和目录</li>
<li>删除已经存在的文件与目录(不论该文件的权限为何!)</li>
<li>重命名已存在的文件或目录</li>
<li>移动该目录内文件、目录的位置</li>
</ul>
</li>
<li>x (access directory) 目录虽然不能被执行，但是却具有可以执行的权限。目录的 x 权限表示用户是否可以<em>进入该目标并成为当前的工作目录</em>。注意，如果用户对目录没有 x 权限，则无<em>法查看该目录下的文件的内容(注意与 r 权限的区别)</em>。</li>
</ul>
<p>综上，<em>如果要允许目录被其他人浏览时，至少要给予 r 和 x 的权限</em>。</p>
<h4 id="改变权限">改变权限<a hidden class="anchor" aria-hidden="true" href="#改变权限">#</a></h4>
<p>在新建文件时会根据创建者的身份和其它的一些设置为文件生成默认的权限。</p>
<p>接下来我们介绍如何通过命令修改文件权限相关的信息。</p>
<p><strong>改变文件所有者</strong></p>
<p>通过 chown 命令可以改变文件的所有者：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo chown tester testfile
</code></pre></div><p><strong>改变文件所属的组</strong></p>
<p>通过 chgrp 命令可以改变文件所属的组：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo chgrp tester testfile
</code></pre></div><p><strong>改变文件的权限</strong></p>
<p>通过 chmod 命令可以改变文件的权限。对于文件的 rwx 权限，有两种表示方法，数字表示法和字符表示法。</p>
<p>以数字表示权限的方式如下：</p>
<ul>
<li>r: 4</li>
<li>w: 2</li>
<li>x: 1</li>
</ul>
<p>如果是 rwx 权限就是 4 + 2 + 1 = 7 ，r-x 就是 4 + 1 = 5 ，&mdash; 则为 0。所以 rw-rw-r&ndash; 就可以用 664 来表示。如果我们想把文件的权限修改为 rwxrwxrwx，可以使用下面的命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ chmod <span style="color:#ae81ff">777</span> testfile
</code></pre></div><p>以字符表示权限的方式如下：用字符 u, g, o 分别代表文件所有者(user)、文件所属的组(group)和其他人(other)，这就是 ugo 权限叫法的由来。只不过还有一个 a 可以表示全部的身份(all)。具体更改权限的语法如下：</p>
<pre tabindex="0"><code>chmod [ugoa][+-=][rwx] 文件/目录
</code></pre><p>比如我们可以通过下面的命令把 testfile 的权限设为 rw-rw-r&ndash;：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ chmod ug<span style="color:#f92672">=</span>rw,o<span style="color:#f92672">=</span>r testfile
</code></pre></div><p>如果想去掉组的 w 权限并给其他人添加 x 权限可以执行下面的命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ chmod g-w,o+x testfile
</code></pre></div><p>我们还可通过 a 为全部身份设置权限，比如 rwx：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ chmod a<span style="color:#f92672">=</span>rwx testfile
</code></pre></div><h3 id="特殊权限suidsgidsbit"><a href="SUID/SGID/SBIT">特殊权限</a><a hidden class="anchor" aria-hidden="true" href="#特殊权限suidsgidsbit">#</a></h3>
<p>setuid 和 setgid 分别是 set uid ID upon execution 和 set group ID upon execution 的缩写。我们一般会再次把它们缩写为 suid 和 sgid。它们是控制文件访问的权限标志(flag)，它们分别允许用户以可执行文件的 owner 或 owner group 的权限运行可执行文件。</p>
<h4 id="suid">SUID<a hidden class="anchor" aria-hidden="true" href="#suid">#</a></h4>
<p>在 Linux 中，所有账号的密码记录在 <code>/etc/shadow</code> 这个文件中，并且只有 root 可以读写入这个文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ll /etc/shadow
-rw-r----- <span style="color:#ae81ff">1</span> root shadow 1.5K Feb <span style="color:#ae81ff">25</span> 12:46 /etc/shadow
</code></pre></div><p>如果另一个普通账号 tester 需要修改自己的密码，就要访问 <code>/etc/shadow</code> 这个文件。但是明明只有 root 才能访问 <code>/etc/shadow</code> 这个文件，这究竟是如何做到的呢？事实上，tester 用户是可以修改 <code>/etc/shadow</code> 这个文件内的密码的，就是通过 SUID 的功能。让我们看看 passwd 程序文件的权限信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ll /usr/bin/passwd 
-rwsr-xr-x <span style="color:#ae81ff">1</span> root root 67K Jul <span style="color:#ae81ff">15</span>  <span style="color:#ae81ff">2021</span> /usr/bin/passwd
</code></pre></div><p>上图红框中的权限信息有些奇怪，owner 的信息为 rws 而不是 rwx。当 s 出现在文件拥有者的 x 权限上时，就被称为 SETUID BITS 或 SETUID ，其特点如下：</p>
<ul>
<li>SUID 权限仅对二进制可执行文件有效</li>
<li>如果执行者对于该二进制可执行文件具有 x 的权限，执行者将具有该文件的所有者的权限</li>
<li>本权限仅在执行该二进制可执行文件的过程中有效</li>
</ul>
<p>下面我们来看 tester 用户是如何利用 SUID 权限完成密码修改的：</p>
<ol>
<li>tester 用户对于 /usr/bin/passwd 这个程序具有执行权限，因此可以执行 passwd 程序</li>
<li>passwd 程序的所有者为 root</li>
<li>tester 用户执行 passwd 程序的过程中会暂时获得 root 权限</li>
<li>因此 tester 用户在执行 passwd 程序的过程中可以修改 /etc/shadow 文件</li>
</ol>
<p>但是如果由 tester 用户执行 cat 命令去读取 <code>/etc/shadow</code> 文件确是不行的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ll /bin/cat
-rwxr-xr-x <span style="color:#ae81ff">1</span> root root 43K Sep  <span style="color:#ae81ff">5</span>  <span style="color:#ae81ff">2019</span> /bin/cat
</code></pre></div><p>原因很清楚，tester 用户没有读 /etc/shadow 文件的权限，同时 cat 程序也没有被设置 SUID。我们可以通过下图来理解这两种情况：</p>
<p><img loading="lazy" src="/Distributions/952033-20180915174007691-528388363.png" alt=""  />
</p>
<h4 id="sgid">SGID<a hidden class="anchor" aria-hidden="true" href="#sgid">#</a></h4>
<p>当 s 标志出现在用户组的 x 权限时称为 SGID。SGID 的特点与 SUID 相同，我们通过 <code>/usr/bin/mlocate</code> 程序来演示其用法。mlocate 程序通过查询数据库文件 <code>/var/lib/mlocate/mlocate.db</code> 实现快速的文件查找。 mlocate 程序的权限如下图所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ll /usr/bin/mlocate
-rwxr-sr-x <span style="color:#ae81ff">1</span> root mlocate <span style="color:#ae81ff">39520</span> Nov <span style="color:#ae81ff">18</span> <span style="color:#ae81ff">2014</span> /usr/bin/mlocate*
</code></pre></div><p>很明显，它被设置了 SGID 权限。下面是数据库文件 <code>/var/lib/mlocate/mlocate.db</code> 的权限信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ll /var/lib/mlocate/mlocate.db
-rw-r----- <span style="color:#ae81ff">1</span> root mlocate <span style="color:#ae81ff">12101109</span> Aug <span style="color:#ae81ff">13</span> 07:35 /var/lib/mlocate/mlocate.db
</code></pre></div><p>普通用户 tester 执行 mlocate 命令时，tester 就会获得用户组 mlocate 的执行权限，又由于用户组 mlocate 对 mlocate.db 具有读权限，所以 tester 就可以读取 mlocate.db 了。程序的执行过程如下图所示：</p>
<p><img loading="lazy" src="/Distributions/952033-20180915174309311-990901650.png" alt=""  />
</p>
<p>除二进制程序外，SGID 也可以用在目录上。当一个目录设置了 SGID 权限后，它具有如下功能：</p>
<ol>
<li>用户若对此目录具有 r 和 x 权限，该用户能够进入该目录</li>
<li>用户在此目录下的有效用户组将变成该目录的用户组</li>
<li>若用户在此目录下拥有 w 权限，则用户所创建的新文件的用户组与该目录的用户组相同</li>
</ol>
<h4 id="sbit">SBIT<a hidden class="anchor" aria-hidden="true" href="#sbit">#</a></h4>
<p>其实 SBIT 与 SUID 和 SGID 的关系并不大。SBIT 是 the restricted deletion flag or sticky bit 的简称。</p>
<p>SBIT 目前只对目录有效，用来阻止非文件的所有者删除文件。比较常见的例子就是 <code>/tmp</code> 目录：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ls -ld /tmp 
drwxrwxrwt <span style="color:#ae81ff">22</span> root root <span style="color:#ae81ff">4096</span> Mar  <span style="color:#ae81ff">2</span> 20:57 /tmp
</code></pre></div><p>权限信息中最后一位 t 表明该目录被设置了 SBIT 权限。SBIT 对目录的作用是：当用户在该目录下创建新文件或目录时，仅有自己和 root 才有权力删除。</p>
<h4 id="设置权限">设置权限<a hidden class="anchor" aria-hidden="true" href="#设置权限">#</a></h4>
<p><strong>以数字的方式设置权限</strong></p>
<p>SUID、SGID、SBIT 权限对应的数字如下：</p>
<pre tabindex="0"><code>SUID-&gt;4
SGID-&gt;2
SBIT-&gt;1
</code></pre><p>所以如果要为一个文件权限为 &ldquo;-rwxr-xr-x&rdquo; 的文件设置 SUID 权限，需要在原先的 755 前面加上 4，也就是 4755：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ chmod <span style="color:#ae81ff">4755</span> filename
</code></pre></div><p>同样，可以用 2 和 1 来设置 SGID 和 SBIT 权限。设置完成后分别会用 s, s, t 代替文件权限中的 x。</p>
<p>其实，还可能出现 S 和 T 的情况。s 和 t 是替代 x 这个权限的，但是，如果它本身没有 x 这个权限，添加 SUID、SGID、SBIT 权限后就会显示为大写 S 或大写 T。比如我们为一个权限为 666 的文件添加 SUID、SGID、SBIT 权限：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ chmod <span style="color:#ae81ff">666</span> nickfile
$ ll nickfile 
-rw-rw-rw- <span style="color:#ae81ff">1</span> nick nick <span style="color:#ae81ff">0</span> Mar  <span style="color:#ae81ff">2</span> 21:03 nickfile
$ chmod <span style="color:#ae81ff">7666</span> nickfile
$ ll nickfile 
-rwSrwSrwT <span style="color:#ae81ff">1</span> nick nick <span style="color:#ae81ff">0</span> Mar  <span style="color:#ae81ff">2</span> 21:03 nickfile
</code></pre></div><p><strong>通过符号类型改变权限</strong></p>
<p>除了使用数字来修改权限，还可以使用符号：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ chmod u+s testfile <span style="color:#75715e"># 为 testfile 文件加上 SUID 权限。</span>
$ chmod g+s testdir  <span style="color:#75715e"># 为 testdir 目录加上 SGID 权限。</span>
$ chmod o+t testdir  <span style="color:#75715e"># 为 testdir 目录加上 SBIT 权限。</span>
</code></pre></div><h3 id="umaskhttpswwwcnblogscomsparkdevp9651890html"><a href="https://www.cnblogs.com/sparkdev/p/9651890.html">umask</a><a hidden class="anchor" aria-hidden="true" href="#umaskhttpswwwcnblogscomsparkdevp9651890html">#</a></h3>
<h4 id="默认权限">默认权限<a hidden class="anchor" aria-hidden="true" href="#默认权限">#</a></h4>
<p>为了查看用户创建的文件和目录的默认权限，我们用一个普通的用户创建文件 myfile 和目录 mydir 并查看它们的默认权限：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ touch myfile
$ mkdir mydir
$ ll
total 4.0K
drwxrwxr-x <span style="color:#ae81ff">2</span> nick nick 4.0K Mar  <span style="color:#ae81ff">2</span> 21:09 mydir
-rw-rw-r-- <span style="color:#ae81ff">1</span> nick nick    <span style="color:#ae81ff">0</span> Mar  <span style="color:#ae81ff">2</span> 21:09 myfile
</code></pre></div><p>目录的权限为 775，文件的权限为 664。默认情况下对于目录来说最大的权限是 777，对于文件来说最大的权限一般为 666(只有可以执行的文件才添加可执行权限)。所以我们创建的文件和目录的共同特点是从最大权限中减其他用户的写权限。而这个被减去的值就是我们常说的 umask。umask 还是 bash 的一个内置命令，默认输出当前用户的 umask 值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ umask
<span style="color:#ae81ff">002</span>
</code></pre></div><p>注意，umask 显示的值为从默认的最大权限中减去的值。</p>
<h4 id="默认策略">默认策略<a hidden class="anchor" aria-hidden="true" href="#默认策略">#</a></h4>
<p>系统在用户登录时通过 login 程序调用 pam_umask 模块设置用户默认的 umask。从 login 程序的配置文件 <code>/etc/login.defs</code> 中我们可以找到 umask 相关的配置：</p>
<pre tabindex="0"><code>...
UMASK          022
...
USERGROUPS_ENAB yes
...
</code></pre><p>用户的默认 umask 应该是 022，但当 USERGROUPS_ENAB 被设置为 yes 时(默认值)，对于 uid 和 gid 相同且用户名和主组名相同的用户，系统会把其 umask 改为 002。</p>
<p>于 root 用户的特殊性，它默认的 umask 与其它用户是不同的，其值为 022：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># umask</span>
<span style="color:#ae81ff">0022</span>
</code></pre></div><p>第一个 0 表示 8 进制，这里我们可以暂时忽略它。</p>
<h4 id="命令">命令<a hidden class="anchor" aria-hidden="true" href="#命令">#</a></h4>
<p>umask 是 bash 的一个内置命令，用来显示或设置新建文件/目录的权限掩码(umask)。前面我们以数字的方式输出了用户默认的 umask 值，这次我们以符号的方式进行输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ umask -S
u<span style="color:#f92672">=</span>rwx,g<span style="color:#f92672">=</span>rwx,o<span style="color:#f92672">=</span>rx
</code></pre></div><p>以符号输出的就是用户创建目录时的默认权限，也就是 775。</p>
<p>为了改变用户创建的文件/目录的默认值，我们可以改变 umask 的默认值。</p>
<p><strong>设置 umask 值</strong></p>
<p>最简单的方式就是为 umask 命令指定一个数字：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ umask <span style="color:#ae81ff">026</span>
</code></pre></div><p>026 的含义为：去掉 group 中的写权限，去掉 other 中的读写权限。</p>
<p>这时创建的文件权限为 640，目录权限为 751。注意，修改 umask 后只有新建的文件和目录受影响，已经存在的文件和目录的权限不会被影响。</p>
<p><strong>以符号的方式设置 umask 值</strong></p>
<p>比如下面的命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ umask u<span style="color:#f92672">=</span>,g<span style="color:#f92672">=</span>w,o<span style="color:#f92672">=</span>rwx
</code></pre></div><p>上面的命令表示从 group 中去掉写权限，从 other 中去掉读写执行的权限。</p>
<p>注意：&quot;=&quot; 号在 umask 命令和 chmod 命令中的作用恰恰相反。在 chmod 命令中，利用它来设置指定的权限，而其余权限则被删除。但是在 umask 命令中，将在原有权限的基础上删除指定的权限。</p>
<p><strong>在 ~/.bashrc 文件中为用户设置默认的 umask</strong></p>
<p>如果让用户每次登陆后都执行 umask 命令修改默认的 umask 值是不科学的，我们可以在用户的 ~/.bashrc 文件中执行 umask 命令，这样用户登录后 umask 的值自动就变成了设置的值。把下面的命令添加到 ~/.bashrc 文件的最后一行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">umask <span style="color:#ae81ff">026</span>
</code></pre></div><h4 id="与-acl">与 ACL<a hidden class="anchor" aria-hidden="true" href="#与-acl">#</a></h4>
<p>如果一个目录没有被设置 default ACL，那么将由 umask 决定新文件的 ACL 权限。这种情况其实就是我们常见的没有 ACL 权限时的情况。比如我们设置 umask 为 026，那么创建的文件和目录的权限就是由它决定的。</p>
<p>如果一个目录被设置了 default ACL，那么将会由文件创建函数的 mode 参数和目录的 default ACL 共通决定新文件的 ACL 权限，此时 umask 被忽略。还以 umask 026 为例，我们创建一个目录 dir2 并设置 default ACL 权限：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ setfacl -m d:u:tester:rwx dir2
$ getfacl dir2 
<span style="color:#75715e"># file: dir2</span>
<span style="color:#75715e"># owner: nick</span>
<span style="color:#75715e"># group: nick</span>
user::rwx
group::r-x
other::--x
default:user::rwx
default:user:tester:rwx
default:group::rwx
default😷:rwx
default:other::r-x
</code></pre></div><p>然后在 dir2 目录中创建文件 testfile：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ dir2 touch testfile
$ dir2 ll testfile 
-rw-rw-r--+ <span style="color:#ae81ff">1</span> nick nick <span style="color:#ae81ff">0</span> Mar  <span style="color:#ae81ff">2</span> 21:26 testfile
</code></pre></div><p>这次 testfile 的权限已经不受 umask 的影响了！</p>
<h3 id="aclhttpswwwcnblogscomsparkdevp5536868html"><a href="https://www.cnblogs.com/sparkdev/p/5536868.html">ACL</a><a hidden class="anchor" aria-hidden="true" href="#aclhttpswwwcnblogscomsparkdevp5536868html">#</a></h3>
<p>ACL的全称是 Access Control List (访问控制列表) ，一个针对文件/目录的访问控制列表。它在UGO权限管理的基础上为文件系统提供一个额外的、更灵活的权限管理机制。它被设计为UNIX文件权限管理的一个补充。<strong>ACL允许你给任何特定的用户或用户组设置任何文件/目录的访问权限</strong>。</p>
<p>ACL需要Linux内核和文件系统的配合才能工作，大多数Linux发行版本默认都是支持的。但最好还是能够先检查一下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo tune2fs -l /dev/sda1 | grep <span style="color:#e6db74">&#34;Default mount options:&#34;</span>
Default mount options:    user_xattr acl
</code></pre></div><h4 id="设置权限-1">设置权限<a hidden class="anchor" aria-hidden="true" href="#设置权限-1">#</a></h4>
<p>可以使用setfacl和getfacl命令来设置或观察文件/目录的acl权限。</p>
<p>当前用户是 nick，再创建两个用户 tester 和 tester1 用来进行测试：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo adduser tester
</code></pre></div><p>创建文件 aclfile，检查其默认的权限信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ touch aclfile
$ ll aclfile 
-rw-rw-r-- <span style="color:#ae81ff">1</span> nick nick <span style="color:#ae81ff">0</span> Mar  <span style="color:#ae81ff">2</span> 21:40 aclfile
$ getfacl aclfile
<span style="color:#75715e"># file: aclfile</span>
<span style="color:#75715e"># owner: nick</span>
<span style="color:#75715e"># group: nick</span>
user::rw-
group::rw-
other::r--
</code></pre></div><p>把用户切换为 tester，发现没有写文件的权限：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ echo <span style="color:#e6db74">&#34;hello&#34;</span> &gt;&gt; aclfile
bash: aclfile: Permission denied
</code></pre></div><p>这是因为 other 没有写 aclfile 文件的权限。</p>
<p>下面我们为 tester 用户赋予读写 aclfile 文件的权限：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ setfacl -m u:tester:rw aclfile
</code></pre></div><p>修改成功后再次以 tester 用户的身份向 aclfile 文件写入数据，这次已经可以正常写入了。查看 aclfile 文件的权限：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ getfacl aclfile
<span style="color:#75715e"># file: aclfile</span>
<span style="color:#75715e"># owner: nick</span>
<span style="color:#75715e"># group: nick</span>
user::rw-
user:tester:rw-
group::rw-
mask::rw-
other::r--
</code></pre></div><p>多出了一些信息，其中比较重要的是 user:tester:rw-，就是它让用户 tester 具有了读写 aclfile 的权限。</p>
<p>针对用户组来设置权限和针对用户的设置几乎一样，只是把小写的 u 换成小写的 g 就行了。</p>
<h4 id="继承权限">继承权限<a hidden class="anchor" aria-hidden="true" href="#继承权限">#</a></h4>
<p>acl 能让创建的子文件或者子文件夹继承父文件夹的权限设置！</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ mkdir mydir
$ ll -d mydir
drwxrwxr-x <span style="color:#ae81ff">2</span> nick nick 4.0K Mar  <span style="color:#ae81ff">2</span> 21:09 mydir
$ setfacl -m d:u:tester:rwx mydir
$ getfacl mydir
<span style="color:#75715e"># file: mydir</span>
<span style="color:#75715e"># owner: nick</span>
<span style="color:#75715e"># group: nick</span>
user::rwx
group::rwx
other::r-x
default:user::rwx
default:user:tester:rwx
default:group::rwx
default😷:rwx
default:other::r-x
</code></pre></div><p>这次多出了一些以 default 开头的行，这些 default 权限信息只能在目录上设置，然后会被目录中创建的文件和目录继承。下面分别在 mydir 目录下创建文件 testfile 和目录 testdir，并查看它们的 acl 权限：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ touch testfile
$ mkdir testdir
$ getfacl testfile
<span style="color:#75715e"># file: testfile</span>
<span style="color:#75715e"># owner: nick</span>
<span style="color:#75715e"># group: nick</span>
user::rw-
user:tester:rwx
group::rwx
mask::rw-
other::r--
</code></pre></div><p>从上面可以看到文件 testfile 继承了父目录的 acl 权限，因此用户 tester 对它有读写权限。下面再看看 testdir 目录：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ getfacl testdir
<span style="color:#75715e"># file: testdir</span>
<span style="color:#75715e"># owner: nick</span>
<span style="color:#75715e"># group: nick</span>
user::rwx
user:nick:rwx
group::rwx
mask::rwx
other::r-x
default:user::rwx
default:user:tester:rwx
default:group::rwx
default😷:rwx
default:other::r-x
</code></pre></div><p>从图中可以看出，testdir 目录不仅继承了 tester 的访问权限，还继承了父目录上的 default 权限。也就是说我们通过这种方式设置在目录上的权限可以被子目录递归的继承下去。</p>
<h4 id="操作权限">操作权限<a hidden class="anchor" aria-hidden="true" href="#操作权限">#</a></h4>
<h5 id="更改">更改<a hidden class="anchor" aria-hidden="true" href="#更改">#</a></h5>
<p><strong>-m 选项其实是在更改文件和目录的 ACL 权限</strong></p>
<ul>
<li>当一个用户或组的 ACL 权限不存在时，-m 选项执行的是添加操作，</li>
<li>如果一个用户或组的 ACL 权限已经存在时，-m 选项执行的是更新操作。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ setfacl -m u:tester:rwx aclfile
$ setfacl -m u:tester:rw aclfile
</code></pre></div><p><strong>-set 选项会先清除掉原有的 ACL 权限，然后添加新的权限</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ setfacl --set u::rw,u:tester:rwx,g::r,o::- aclfile
$ getfacl aclfile
<span style="color:#75715e"># file: aclfile</span>
<span style="color:#75715e"># owner: nick</span>
<span style="color:#75715e"># group: nick</span>
user::rw-
user:tester:rwx
group::r--
mask::rwx
other::---
</code></pre></div><p>需要注意的是一定要包含 UGO 权限的设置，不能象 -m 一样只包含 ACL 权限。o::- 是另一个需要注意的地方，其完整的写法是 other::-，就像 u::rw 的完整写法是 user::rw- 一样。通常我们可以把 &ldquo;-&rdquo; 省略，但是当权限位只包含 &ldquo;-&rdquo; 时，就至少要保留一个。如果写成了o::，就会报错。</p>
<h5 id="删除">删除<a hidden class="anchor" aria-hidden="true" href="#删除">#</a></h5>
<p>通过 setfacl 命令的 -x 选项来删除指定用户或组的 ACL 权限，还可以通过 -b 选项来清除文件和目录上所有的 ACL 权限。</p>
<p>下面通过 -x 选项删除 user tester 的 ACL 权限，注意命令中只指定了用户的名称而没有指定权限信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ getfacl aclfile 
<span style="color:#75715e"># file: aclfile</span>
<span style="color:#75715e"># owner: nick</span>
<span style="color:#75715e"># group: nick</span>
user::rw-
user:tester:rwx
group::rw-
mask::rwx
other::r--
$ setfacl -x u:tester aclfile
$ getfacl aclfile            
<span style="color:#75715e"># file: aclfile</span>
<span style="color:#75715e"># owner: nick</span>
<span style="color:#75715e"># group: nick</span>
user::rw-
group::rw-
mask::rw-
other::r--
</code></pre></div><p>下面通过 -b 选项一次性删除 aclfile 上所有的 ACL 权限：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ setfacl -b aclfile
getfacl aclfile   
<span style="color:#75715e"># file: aclfile</span>
<span style="color:#75715e"># owner: nick</span>
<span style="color:#75715e"># group: nick</span>
user::rw-
group::rw-
other::r--
</code></pre></div><h5 id="备份和恢复">备份和恢复<a hidden class="anchor" aria-hidden="true" href="#备份和恢复">#</a></h5>
<p>常见的文件操作命令 cp 和 mv 等都支持 ACL 权限，只是 cp 命令需要加上 -p 参数。但是 tar 等常见的备份工具不会保留目录和文件的 ACL 权限信息。如果希望备份和恢复带有 ACL 权限的文件和目录，可以先把 ACL 权限信息备份到一个文件里，然后再用 -restore 选项来恢复这些信息。</p>
<p>使用下面的命令导出 acldir 目录的 ACL 权限信息并保存到文件 acldir.acl 文件中：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ getfacl -R acldir &gt; acldir.acl
</code></pre></div><p>通过下面的命令把它们的 ACL 权限都恢复回来：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ setfacl --restore acldir.acl
</code></pre></div><h4 id="实现原理httpswwwcnblogscomsparkdevp9694015html"><a href="https://www.cnblogs.com/sparkdev/p/9694015.html">实现原理</a><a hidden class="anchor" aria-hidden="true" href="#实现原理httpswwwcnblogscomsparkdevp9694015html">#</a></h4>
<p><strong>ACL 条目</strong></p>
<p><img loading="lazy" src="/Disributions/952033-20180923221833345-608906567.png" alt=""  />
</p>
<h3 id="进程权限httpswwwcnblogscomsparkdevp9694103html"><a href="https://www.cnblogs.com/sparkdev/p/9694103.html">进程权限</a><a hidden class="anchor" aria-hidden="true" href="#进程权限httpswwwcnblogscomsparkdevp9694103html">#</a></h3>
<p>ugo 权限信息是文件的属性，它指明了用户与文件之间的关系。但是真正操作文件的却是进程，也就是说用户所拥有的文件访问权限是通过进程来体现的。</p>
<p>概念：</p>
<ul>
<li>
<p><strong>用户</strong> 对于支持多任务的 Linux 系统来说，用户就是获取资源的凭证。</p>
</li>
<li>
<p><strong>权限</strong> 权限用来控制用户对计算机资源(CPU、内存、文件等)的访问，一般会分为认证和授权两步。比如用户先经过认证机制(authentication)登录系统，然后由授权系统(authorization)对用户的操作进行授权。</p>
</li>
<li>
<p><strong>进程</strong> 进程是任何支持多道程序设计的操作系统中的基本概念。通常把进程定义为<code>程序执行时的一个实例</code>。因此，如果有 10 个用户同时运行 vi，就会有 10 个独立的进程(尽管它们共享同一份可执行代码)。</p>
<p>实际上，是进程在帮助我们完成各种任务。进程就是用户访问计算机资源的代理，用户执行的操作其实是带有用户身份信息的进程执行的操作。</p>
</li>
<li>
<p><strong>进程权限</strong> 既然是进程在为用户执行具体的操作，那么当用户要访问系统的资源时就必须给进程赋予权限。也就是说<em>进程必须携带发起这个进程的用户的身份信息才能够进行合法的操作。</em></p>
</li>
</ul>
<h4 id="登陆过程">登陆过程<a hidden class="anchor" aria-hidden="true" href="#登陆过程">#</a></h4>
<p>在 Linux 系统启动后，init 系统会 fork 出子进程执行 <code>/sbin/getty</code> 程序等待用户登录。当用户进行登录操作时，该子进程通过 exec 函数开始执行 <code>/bin/login</code> 程序(此时该进程已经变成了 login 进程)。由 login 进程验证我们的用户名和密码并查询 <code>/etc/passwd</code> 和 <code>/etc/shadow</code> 确定其合法性。如果是合法的用户，该进程再次通过 exec 函数执行用户的默认 shell 程序，此时的 login 进程就变成了 shell 进程(笔者机器上是 bash 进程)。并且**该 shell 进程的有效身份被设置成为该用户的身份，之后 fork 此 shell 进程的子进程都会继承该有效身份。**我们可以通过下图来理解用户从 tty 登录系统的过程：</p>
<p><img loading="lazy" src="/Distributions/952033-20180923224826617-131415814.png" alt=""  />
</p>
<p>简单点说就是：<strong>用户登录后， shell 进程的有效用户就是该用户。</strong></p>
<h4 id="user-id">user id<a hidden class="anchor" aria-hidden="true" href="#user-id">#</a></h4>
<p>通过 <code>cat /proc/&lt;PID&gt;/status</code> 命令，我们可以查看到进程所属的用户和组相关的信息：</p>
<pre tabindex="0"><code>Uid:	1000	1000	1000	1000
Gid:	1000	1000	1000	1000
</code></pre><p>通过 man proc 可以查询到第一行的四个数字分别是 real user id, effective user id, saved set user id 和 filesystem UID，第二行则是对应的组 ID。</p>
<p><strong>real user id</strong></p>
<p>real user id 是执行进程者的 user id，一般情况下就是用户登录时的 user id。子进程的 real user id 从父进继承。通常这个是不更改的，也不需要更改。比如我以用户 nick 登录 Linux 系统，我接下来运行的所有命令的进程的 real user id 都是 nick 的 user id。</p>
<p><strong>effective user id</strong></p>
<p><em>如果要判断一个进程是否对某个文件有操作权限，验证的是进程的 effective user id，而不是 real user id。</em></p>
<p>通常不建议直接使用 root 用户进行操作的，但是在很多情况下，程序可能需要特殊的权限。比如 passwd 程序需要 root 权限才能够为普通用户修改密码，一些 services 程序的操作也经常需要特殊的权限。为此，Linux 中设计了一些特殊的权限（SUID/SGID/SBIT）。这里我们以 passwd 程序为例，为二进制可执行文件 <code>/usr/bin/passwd</code> <em>设置 set-user-id bit=ON，这个可执行文件被用 exec 启动之后的进程的 effective user id 就是这个可执行文件的 owner id，而并非父进程的 real user id</em>。如果 set-user-id bit=OFF 的时候，这个被 exec 起来的进程的 effective user id 应该是等于进程的 user id 的。</p>
<p>其实我们通过 ps aux 查看的结果中，第一列显示的就是进程的 effective user。</p>
<p><strong>saved set user id</strong></p>
<p>saved set user id 相当于是一个 buffer，在 exec 函数启动之后，它会拷贝 effective user id 位的信息覆盖自己。</p>
<p>对于非 root 用户来说，可以在未来使用 setuid() 函数将 effective user id 设置成为 real user id 或 saved set user id 中的任何一个。但是不允许非 root 用户用 setuid() 函数把 effective user id 设置成为任何第三个 user id。</p>
<p>对于 root 用户来说，调用 setuid() 的时候，将会设置所有的这三个 user id。</p>
<h4 id="外部命令">外部命令<a hidden class="anchor" aria-hidden="true" href="#外部命令">#</a></h4>
<p>在 shell 中执行的命令分为内部命令和外部命令两种。</p>
<ul>
<li>内部命令：内建的，相当于 shell 的子函数</li>
<li>外部命令：在文件系统的某个路径下的一个可执行文件</li>
</ul>
<p>外部命令的执行过程如下：</p>
<ol>
<li>Shell 通过 fork() 函数建立一个新的子进程，新的子进程为当前 shell 进程的一个副本。</li>
<li>在新的进程里，从 PATH 变量所列出的目录中寻找指定的命令程序。当命令名称包含有斜杠(/)符号时，将略过路径查找步骤。</li>
<li>在新的进程里，通过 exec 系列函数，以所找到的新程序替换 shell 程序并执行。</li>
<li>子进程退出后，最初的 shell 会接着从终端读取并执行下一条命令。</li>
</ol>
<p>我们通过下面的例子来理解在 shell 中执行外部命令的过程，例子很简单就是通过 cat 命令查看一个文本文件 test.log：</p>
<pre tabindex="0"><code>$ cat test.log
</code></pre><p>我们先来检查一下当前用户以及相关文件的权限：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ uid<span style="color:#f92672">=</span>1000<span style="color:#f92672">(</span>nick<span style="color:#f92672">)</span> gid<span style="color:#f92672">=</span>1000<span style="color:#f92672">(</span>nick<span style="color:#f92672">)</span> groups<span style="color:#f92672">=</span>1000<span style="color:#f92672">(</span>nick<span style="color:#f92672">)</span>,4<span style="color:#f92672">(</span>adm<span style="color:#f92672">)</span>,24<span style="color:#f92672">(</span>cdrom<span style="color:#f92672">)</span>,27<span style="color:#f92672">(</span>sudo<span style="color:#f92672">)</span>,30<span style="color:#f92672">(</span>dip<span style="color:#f92672">)</span>,46<span style="color:#f92672">(</span>plugdev<span style="color:#f92672">)</span>,120<span style="color:#f92672">(</span>lpadmin<span style="color:#f92672">)</span>,132<span style="color:#f92672">(</span>lxd<span style="color:#f92672">)</span>,133<span style="color:#f92672">(</span>sambashare<span style="color:#f92672">)</span>
$ ll /bin/cat
-rwxr-xr-x <span style="color:#ae81ff">1</span> root root 43K Sep  <span style="color:#ae81ff">5</span>  <span style="color:#ae81ff">2019</span> /bin/cat
$ ll test.log 
-rw-rw-r-- <span style="color:#ae81ff">1</span> nick nick <span style="color:#ae81ff">0</span> Mar  <span style="color:#ae81ff">2</span> 23:25 test.log
</code></pre></div><p>当前用户 nick 的 real user id 为 1000，<code>/bin/cat</code> 文件的所有者为 root，但是所有人都有执行权限，test.log 文件的所有者为 nick。我们结合下图来介绍 cat test.log 命令的执行过程：</p>
<p><img loading="lazy" src="/Distributions/952033-20180923225453228-1326852315.png" alt=""  />
</p>
<p>当我们在 shell 中执行一个外部程序的时候，默认情况下进程的 effective user ID 等于 real user ID，进程的 effective group ID 等于 real group ID(接下来的介绍中省略 group ID)。当我们以用户 nick 登录系统，并在 bash 中键入 cat test.log 命令并回车后。Bash 先通过 fork() 建立一个新的子进程，这个新的子进程是当前 bash 进程的一个副本。新的进程在 PATH 变量指定的路径中搜索 cat 程序，找到 /bin/cat 程序后检查其权限。/bin/cat 程序的所有者为 root，但是其他人具有读和执行的权限，所以新进程可以通过 exec 函数用 cat 程序的代码段替换当前进程中的代码段(把 /bin/cat 程序加载到了内存中，此时的进程已经变成了 cat 进程，cat 进程会从 _start 函数开始执行)。由于 cat 进程是由用户 nick 启动的，所以 cat 进程的 effective user ID 是 1000(nick)。同时 cat 进程的 effective user ID 和 test.log 文件的 owner ID 相同(都是 1000)，所以 cat 进程拥有对此文件的 rw- 权限，那么顺理成章地就可以读写 test.log 文件的内容了。</p>
<h4 id="脚本">脚本<a hidden class="anchor" aria-hidden="true" href="#脚本">#</a></h4>
<p>在 shell 中执行脚本的方式和执行外部命令的方式差不多，比如我们要执行下面的脚本：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ /bin/bash ./test.sh
</code></pre></div><p>这时同样会 fork 出一个子进程。只不过脚本与程序相比没有代码段，也没有 _start 函数，此时 exec 函数就会执行另外一套机制。比如我们在 test.sh 文件的第一行通过 #!/bin/bash 指定了一个解释器，那么解释器程序的代码段会用来替换当前进程的代码段，并且从解释器的 _start 函数开始执行，而这个文本文件被当作命令行参数传给解释器。所以上面的命令执行过程为：Bash 进程 fork/exec 一个子 bash 进程用于执行脚本，子 bash 进程继承父进程的环境变量、用户信息等内容，父进程等待子 bash 进程终止。</p>
<ul>
<li>权限</li>
<li>cgroub</li>
<li>sudo</li>
<li>fdisk</li>
<li>自动更新</li>
<li>LVM</li>
<li>进程</li>
</ul>
<h3 id="capabilitieshttpswwwcnblogscomsparkdevp11417781html"><a href="https://www.cnblogs.com/sparkdev/p/11417781.html">Capabilities</a><a hidden class="anchor" aria-hidden="true" href="#capabilitieshttpswwwcnblogscomsparkdevp11417781html">#</a></h3>
<p>为了执行权限检查，Linux 区分两类进程：特权进程(其有效用户标识为 0，也就是超级用户 root)和非特权进程(其有效用户标识为非零)。 特权进程绕过所有内核权限检查，而非特权进程则根据进程凭证(通常为有效 UID，有效 GID 和补充组列表)进行完全权限检查。</p>
<p>以常用的 passwd 命令为例，修改用户密码需要具有 root 权限，而普通用户是没有这个权限的。但是实际上普通用户又可以修改自己的密码，这是怎么回事？在 Linux 的权限控制机制中，有一类比较特殊的权限设置，比如 SUID(Set User ID on execution)。因为程序文件 /bin/passwd 被设置了 SUID 标识，所以普通用户在执行 passwd 命令时，进程是以 passwd 的所有者，也就是 root 用户的身份运行，从而修改密码。</p>
<p>SUID 虽然可以解决问题，却带来了安全隐患。当运行设置了 SUID 的命令时，通常只是需要很小一部分的特权，但是 SUID 给了它 root 具有的全部权限。因此一旦 被设置了 SUID 的命令出现漏洞，就很容易被利用。也就是说 SUID 机制在增大了系统的安全攻击面。</p>
<p>Linux 引入了 capabilities 机制对 root 权限进行细粒度的控制，实现按需授权，从而减小系统的安全攻击面。</p>
<h4 id="简介-7">简介<a hidden class="anchor" aria-hidden="true" href="#简介-7">#</a></h4>
<p>从内核 2.2 开始，Linux 将传统上与超级用户 root 关联的特权划分为不同的单元，称为 capabilites。Capabilites 作为线程(Linux 并不真正区分进程和线程)的属性存在，每个单元可以独立启用和禁用。如此一来，权限检查的过程就变成了：在执行特权操作时，如果进程的有效身份不是 root，就去检查是否具有该特权操作所对应的 capabilites，并以此决定是否可以进行该特权操作。比如要向进程发送信号(kill())，就得具有 capability <strong>CAP_KILL</strong>；如果设置系统时间，就得具有 capability <strong>CAP_SYS_TIME</strong>。</p>
<p>下面是从 <a href="http://man7.org/linux/man-pages/man7/capabilities.7.html">capabilities man page</a> 中摘取的 capabilites 列表：</p>
<table>
<thead>
<tr>
<th>capability 名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CAP_AUDIT_CONTROL</td>
<td>启用和禁用内核审计；改变审计过滤规则；检索审计状态和过滤规则</td>
</tr>
<tr>
<td>CAP_AUDIT_READ</td>
<td>允许通过 multicast netlink 套接字读取审计日志</td>
</tr>
<tr>
<td>CAP_AUDIT_WRITE</td>
<td>将记录写入内核审计日志</td>
</tr>
<tr>
<td>CAP_BLOCK_SUSPEND</td>
<td>使用可以阻止系统挂起的特性</td>
</tr>
<tr>
<td>CAP_CHOWN</td>
<td>修改文件所有者的权限</td>
</tr>
<tr>
<td>CAP_DAC_OVERRIDE</td>
<td>忽略文件的 DAC 访问限制</td>
</tr>
<tr>
<td>CAP_DAC_READ_SEARCH</td>
<td>忽略文件读及目录搜索的 DAC 访问限制</td>
</tr>
<tr>
<td>CAP_FOWNER</td>
<td>忽略文件属主 ID 必须和进程用户 ID 相匹配的限制</td>
</tr>
<tr>
<td>CAP_FSETID</td>
<td>允许设置文件的 setuid 位</td>
</tr>
<tr>
<td>CAP_IPC_LOCK</td>
<td>允许锁定共享内存片段</td>
</tr>
<tr>
<td>CAP_IPC_OWNER</td>
<td>忽略 IPC 所有权检查</td>
</tr>
<tr>
<td>CAP_KILL</td>
<td>允许对不属于自己的进程发送信号</td>
</tr>
<tr>
<td>CAP_LEASE</td>
<td>允许修改文件锁的 FL_LEASE 标志</td>
</tr>
<tr>
<td>CAP_LINUX_IMMUTABLE</td>
<td>允许修改文件的 IMMUTABLE 和 APPEND 属性标志</td>
</tr>
<tr>
<td>CAP_MAC_ADMIN</td>
<td>允许 MAC 配置或状态更改</td>
</tr>
<tr>
<td>CAP_MAC_OVERRIDE</td>
<td>覆盖 MAC(Mandatory Access Control)</td>
</tr>
<tr>
<td>CAP_MKNOD</td>
<td>允许使用 mknod() 系统调用</td>
</tr>
<tr>
<td>CAP_NET_ADMIN</td>
<td>允许执行网络管理任务</td>
</tr>
<tr>
<td>CAP_NET_BIND_SERVICE</td>
<td>允许绑定到小于 1024 的端口</td>
</tr>
<tr>
<td>CAP_NET_BROADCAST</td>
<td>允许网络广播和多播访问</td>
</tr>
<tr>
<td>CAP_NET_RAW</td>
<td>允许使用原始套接字</td>
</tr>
<tr>
<td>CAP_SETGID</td>
<td>允许改变进程的 GID</td>
</tr>
<tr>
<td>CAP_SETFCAP</td>
<td>允许为文件设置任意的 capabilities</td>
</tr>
<tr>
<td>CAP_SETPCAP</td>
<td>参考 <a href="http://man7.org/linux/man-pages/man7/capabilities.7.html">capabilities man page</a></td>
</tr>
<tr>
<td>CAP_SETUID</td>
<td>允许改变进程的 UID</td>
</tr>
<tr>
<td>CAP_SYS_ADMIN</td>
<td>允许执行系统管理任务，如加载或卸载文件系统、设置磁盘配额等</td>
</tr>
<tr>
<td>CAP_SYS_BOOT</td>
<td>允许重新启动系统</td>
</tr>
<tr>
<td>CAP_SYS_CHROOT</td>
<td>允许使用 chroot() 系统调用</td>
</tr>
<tr>
<td>CAP_SYS_MODULE</td>
<td>允许插入和删除内核模块</td>
</tr>
<tr>
<td>CAP_SYS_NICE</td>
<td>允许提升优先级及设置其他进程的优先级</td>
</tr>
<tr>
<td>CAP_SYS_PACCT</td>
<td>允许执行进程的 BSD 式审计</td>
</tr>
<tr>
<td>CAP_SYS_PTRACE</td>
<td>允许跟踪任何进程</td>
</tr>
<tr>
<td>CAP_SYS_RAWIO</td>
<td>允许直接访问 /devport、/dev/mem、/dev/kmem 及原始块设备</td>
</tr>
<tr>
<td>CAP_SYS_RESOURCE</td>
<td>忽略资源限制</td>
</tr>
<tr>
<td>CAP_SYS_TIME</td>
<td>允许改变系统时钟</td>
</tr>
<tr>
<td>CAP_SYS_TTY_CONFIG</td>
<td>允许配置 TTY 设备</td>
</tr>
<tr>
<td>CAP_SYSLOG</td>
<td>允许使用 syslog() 系统调用</td>
</tr>
<tr>
<td>CAP_WAKE_ALARM</td>
<td>允许触发一些能唤醒系统的东西(比如 CLOCK_BOOTTIME_ALARM 计时器)</td>
</tr>
</tbody>
</table>
<p><strong>程序文件的 capabilities</strong></p>
<p>在可执行文件的属性中有三个集合来保存三类 capabilities，它们分别是：</p>
<ul>
<li>Permitted</li>
<li>Inheritable</li>
<li>Effective</li>
</ul>
<p>在进程执行时，Permitted 集合中的 capabilites 自动被加入到进程的 Permitted 集合中。</p>
<p>Inheritable 集合中的 capabilites 会与进程的 Inheritable 集合执行逻辑与操作，以确定进程在执行 execve 函数后哪些 capabilites 被继承。</p>
<p>Effective 只是一个 bit。如果设置为开启，那么在执行 execve 函数后，Permitted 集合中新增的 capabilities 会自动出现在进程的 Effective 集合中。</p>
<p><strong>进程的 capabilities</strong></p>
<p>进程中有五种 capabilities 集合类型，分别是：</p>
<ul>
<li>Permitted</li>
<li>Inheritable</li>
<li>Effective</li>
<li>Bounding</li>
<li>Ambient</li>
</ul>
<p>相比文件的 capabilites，进程的 capabilities 多了两个集合，分别是 Bounding 和 Ambient。</p>
<p><code>/proc/[pid]/status</code> 文件中包含了进程的五个 capabilities 集合的信息，我们可以通过下面的命名查看当前进程的 capabilities 信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat /proc/$$/status | grep <span style="color:#e6db74">&#39;Cap&#39;</span>
CapInh:	<span style="color:#ae81ff">0000000000000000</span>
CapPrm:	<span style="color:#ae81ff">0000000000000000</span>
CapEff:	<span style="color:#ae81ff">0000000000000000</span>
CapBnd:	000003ffffffffff
CapAmb:	<span style="color:#ae81ff">0000000000000000</span>
</code></pre></div><p>但是这中方式获得的信息无法阅读，我们需要使用 capsh 命令把它们转义为可读的格式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ capsh --decode<span style="color:#f92672">=</span>0000003fffffffff
</code></pre></div><h4 id="使用">使用<a hidden class="anchor" aria-hidden="true" href="#使用">#</a></h4>
<p><strong>getcap</strong> 命令和 <strong>setcap</strong> 命令分别用来查看和设置程序文件的 capabilities 属性。下面我们演示如何使用 capabilities 代替 ping 命令的 SUID。</p>
<p>因为 ping 命令在执行时需要访问网络，这就需要获得 root 权限，常规的做法是通过 SUID 实现的(和 passwd 命令相同)：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ll /bin/ping
-rwsr-xr-x <span style="color:#ae81ff">1</span> root root 72K Jan <span style="color:#ae81ff">31</span>  <span style="color:#ae81ff">2020</span> /bin/ping
$ ll /usr/bin/passwd 
-rwsr-xr-x <span style="color:#ae81ff">1</span> root root 67K Jul <span style="color:#ae81ff">15</span>  <span style="color:#ae81ff">2021</span> /usr/bin/passwd
</code></pre></div><p>红框中的 s 说明应用程序文件被设置了 SUID，这样普通用户就可以执行这些命令了。</p>
<p>移除 ping 命令文件上的 SUID 权限：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo chmod <span style="color:#ae81ff">755</span> /bin/ping
$ ping baidu.com
ping: socket: Operation not permitted
</code></pre></div><p>在移除 SUID 权限后，普通用户在执行 ping 命令时碰到了 &ldquo;ping: socket: Operation not permitted&rdquo; 错误。</p>
<p><strong>为 ping 命令文件添加 capabilities</strong></p>
<p>执行 ping 命令所需的 capabilities 为 cap_net_admin 和 cap_net_raw，通过 setcap 命令可以添加它们：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo setcap cap_net_admin,cap_net_raw+ep /bin/ping
$ getcap /bin/ping 
/bin/ping <span style="color:#f92672">=</span> cap_net_admin,cap_net_raw+ep
$ ping baidu.com
PING baidu.com <span style="color:#f92672">(</span>220.181.38.148<span style="color:#f92672">)</span> 56<span style="color:#f92672">(</span>84<span style="color:#f92672">)</span> bytes of data.
<span style="color:#ae81ff">64</span> bytes from 220.181.38.148 <span style="color:#f92672">(</span>220.181.38.148<span style="color:#f92672">)</span>: icmp_seq<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> ttl<span style="color:#f92672">=</span><span style="color:#ae81ff">46</span> time<span style="color:#f92672">=</span>33.3 ms
<span style="color:#ae81ff">64</span> bytes from 220.181.38.148 <span style="color:#f92672">(</span>220.181.38.148<span style="color:#f92672">)</span>: icmp_seq<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span> ttl<span style="color:#f92672">=</span><span style="color:#ae81ff">46</span> time<span style="color:#f92672">=</span>40.9 ms
</code></pre></div><p>被赋予合适的 capabilities 后，ping 命令又可以正常工作了，相比 SUID 它只具有必要的特权，在最大程度上减小了系统的安全攻击面。</p>
<p>如果要移除刚才添加的 capabilities，执行下面的命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo setcap cap_net_admin,cap_net_raw-ep /bin/ping
$ getcap /bin/ping 
/bin/ping <span style="color:#f92672">=</span>
</code></pre></div><p>命令中的 ep 分别表示 Effective 和 Permitted 集合，+ 号表示把指定的 capabilities 添加到这些集合中，- 号表示从集合中移除(对于 Effective 来说是设置或者清除位)。</p>
<h2 id="进程">进程<a hidden class="anchor" aria-hidden="true" href="#进程">#</a></h2>
<h3 id="job-controlhttpswwwcnblogscomsparkdevp11980732html"><a href="https://www.cnblogs.com/sparkdev/p/11980732.html">job control</a><a hidden class="anchor" aria-hidden="true" href="#job-controlhttpswwwcnblogscomsparkdevp11980732html">#</a></h3>
<h4 id="进程组">进程组<a hidden class="anchor" aria-hidden="true" href="#进程组">#</a></h4>
<p>执行一个命令会创建一个或多个进程，这些进程被称为一个进程组(process group)。进程组中包含一个或多个进程，每个进程都会属于一个进程组，进程组也叫 job。</p>
<p>每个进程组都有一个领头进程(process group leader)，领头进程的 PID 就是进程组的 ID(process group ID，PGID)，我们可以通过 ps 命令查看进程的 PGID：</p>
<pre tabindex="0"><code>$ ps -o pid,ppid,pgid,comm | cat
    PID    PPID    PGID COMMAND
   2646    2638    2646 zsh
   16823    2646    16823 ps
   16824    2646    16823 cat
</code></pre><p>16823  16824 两个进程属于同一进程组(通过管道符连接的进程属于相同的进程组)。这个进程组中的领头进程为 16823，因此它的 PID 成了进程组的 PGID。</p>
<p><img loading="lazy" src="/Distributions/952033-20191204084743627-202298079.png" alt=""  />
</p>
<p>领头进程可以先退出，这时进程组依然存在并且 PGID 也不会发生变化。在进程组中的所有进程都退出后，进程组的生命周期结束。</p>
<p>将进程划分到进程组中的主要原因是可以对它们进行统一的管理，说白了就是同时发信号给组内的所有进程，这就是我们接下来要介绍的 job 管理。</p>
<h4 id="管理-2">管理<a hidden class="anchor" aria-hidden="true" href="#管理-2">#</a></h4>
<p><strong>jobs 命令</strong></p>
<p>使用 vim 打开文件 test.txt，然后按下 ctrl + z，此时 vim 进入了后台：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ vim test.txt

<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span>+ Stopped  vim test.txt
</code></pre></div><p>输出的第一列方括号中的数字表示 jobID，第二列 Stopped 表示 job 当前的状态，第三列则表示该 job 执行的命令。
使用 jobs 命令可以查看当前会话中的的所有 jobs，此时执行 jobs 命令，输出的结果和上面一样：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ jobs
<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span>+ Stopped  vim test.txt
</code></pre></div><p><strong>&amp; 符</strong></p>
<p>在命令的后面加上 &amp; 符号，可以直接让 job 运行在后台：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sleep <span style="color:#ae81ff">1000</span> &amp;
<span style="color:#f92672">[</span>2<span style="color:#f92672">]</span> <span style="color:#ae81ff">26524</span>
$ jobs
<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span>+ Stopped vim test.txt
<span style="color:#f92672">[</span>2<span style="color:#f92672">]</span>- Running sleep <span style="color:#ae81ff">1000</span> &amp;
</code></pre></div><p>sleep 命令的 jobID 为 2，状态为 Running。</p>
<p><strong>fg 命令</strong></p>
<p>fg 命令是 foreground 的缩写。命令格式为 fg %n，它把当前或指定 ID 的 job 放到前台。下面我们操作一次 job 2：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ fg %2
sleep <span style="color:#ae81ff">1000</span>

</code></pre></div><p>此时 sleep 命令运行在前台，通过 ctrl + z 我们可以再次把它送回后台：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ fg %2
sleep <span style="color:#ae81ff">1000</span>
^Z
<span style="color:#f92672">[</span>2<span style="color:#f92672">]</span>+ Stopped  sleep <span style="color:#ae81ff">1000</span>
</code></pre></div><p>请注意此时 sleep 命令的状态已经变成了 Stopped。</p>
<p><strong>ctrl + z</strong></p>
<p>严格来说 ctrl + z 并不是一个 job 管理命令，它只是向当前进程发送一个 SIGSTOP 信号，该信号使进程进入暂停(stopped)状态，也就是挂起进程，此状态下，进程状态会被系统保存，此进程会被放置到作业队列中去，从而让出终端。使用 ctrl + z 我们可以暂停正在占用终端的进程而不结束它，然后我们可以使用终端命令来操作此进程。</p>
<p><strong>bg 命令</strong></p>
<p>bg 命令是 background 的缩写，命令格式为 bg %n，bg 命令和 ctrl + z 配合可以把前台命令切换到后台去执行。比如刚才我们通过 ctrl + z 把 sleep 命令切到了后台，但变成了 Stopped 状态，此时执行 bg %2 命令可以让 sleep 命令继续在后台执行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ bg %2
<span style="color:#f92672">[</span>2<span style="color:#f92672">]</span>+ sleep <span style="color:#ae81ff">1000</span> &amp;
$ jobs
<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span>+ Stopped vim test.txt
<span style="color:#f92672">[</span>2<span style="color:#f92672">]</span>- Running sleep <span style="color:#ae81ff">1000</span> &amp;
</code></pre></div><p><strong>kill 命令</strong></p>
<p>kill 命令负责向进程发送信号，当然它也可以向 job 发送信号，在 jobID 前面添加 % 就可以了。比如 SIGCONT 是唤醒一个挂起的进程，所以我们也可以使用下面的命令把处于 Stooped 状态的 sleep 命令唤醒：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ jobs
<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span>+ Stopped  sleep <span style="color:#ae81ff">1000</span>
$ kill -SIGCONT %1
$ jobs
<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span>+ Running  sleep <span style="color:#ae81ff">1000</span> &amp;
</code></pre></div><p><strong>杀死进程</strong></p>
<p>有时候使用 ctrl + c 无法杀死一个正在运行的前台进程，这是因为 ctrl + c 的本质是向进程发送 SIGINT 信号。SIGINT 是用来终止进程的，但是这是一个可以被忽略的信号，如果程序忽略了它，我们就无法通过 ctrl + c 来终止该进程。</p>
<p>此时我们可以先使用 ctrl + z 把进程切换到后台，然后使用 kill %n(n 为进程的 jobID)来终止进程。kill 命令默认向进程发送 SIGTERM 信号，程序一般会在 SIGTERM 信号的处理函数中正常地终止程序并执行资源清理工作。既然 SIGTERM 信号能够被程序处理，那么它也能够被忽略，所以也无法通过这种方式结束那些顽固的进程。</p>
<p>杀死进程的终极手段是 kill -SIGKILL PID(kill -9 PID)。SIGKILL 信号是不能被忽略的，所以这一招肯定管用。但是由于它过于强硬，使用这种方式杀死进程后往往会有后遗症，比如进程使用的资源没有在退出前清理干净，常见的例子是用这种方法杀死 vim 进程后会遗留下 .swp 文件。</p>
<p><strong>暂停 tail 命令的输出</strong></p>
<p>我们一般会使用 tail -f 命令查看实时的日志，但很多程序产生日志的速度非常快以至于我们跟不上节奏。此时使用 ctrl + s 命令可以暂停日志输出到终端，这样我们就可以仔细的分析当前终端中显示的日志。如果要接着输出日志，可以使用 ctrl + q 命令恢复日志的输出。</p>
<p>这两个命令的原理是：ctrl + s 会告诉终端暂停，阻塞所有读写操作，即不转发任何数据，只有按了 ctrl + q 后，才会继续。这个功能应该是历史遗留的产物，以前终端和服务器之间没有流量控制功能，所以有可能服务器发送数据过快，导致终端处理不过来，于是需要这样一个命令告诉服务器不要再发了，等终端处理完了后再通知服务器继续。</p>
<h3 id="sessionhttpswwwcnblogscomsparkdevp12146305html"><a href="https://www.cnblogs.com/sparkdev/p/12146305.html">session</a><a hidden class="anchor" aria-hidden="true" href="#sessionhttpswwwcnblogscomsparkdevp12146305html">#</a></h3>
<p>Linux session 一般是指 shell session。Shell session 是终端中当前的状态，在终端中只能有一个 session。当我们打开一个新的终端时，总会创建一个新的 shell session。</p>
<p>就进程间的关系来说，session 由一个或多个进程组组成。一般情况下，来自单个登录的所有进程都属于同一个 session。我们可以通过下图来理解进程、进程组和 session 之间的关系：</p>
<p><img loading="lazy" src="/Distributions/952033-20200103182042686-2100862807.png" alt=""  />
</p>
<p>会话是由会话中的第一个进程创建的，一般情况下是打开终端时创建的 shell 进程。该进程也叫 session 的领头进程。Session 中领头进程的 PID 也就是 session 的 SID。我们可以通过下面的命令查看 SID：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ps -o pid,ppid,pgid,sid,tty,comm
    PID    PPID    PGID     SID TT       COMMAND
  <span style="color:#ae81ff">14244</span>   <span style="color:#ae81ff">29789</span>   <span style="color:#ae81ff">14244</span>   <span style="color:#ae81ff">29789</span> pts/2    ps
</code></pre></div><p>Session 中的每个进程组被称为一个 job，有一个 job 会成为 session 的前台 job(foreground)，其它的 job 则是后台 job(background)。每个 session 连接一个控制终端(control terminal)，控制终端中的输入被发送给前台 job，从前台 job 产生的输出也被发送到控制终端上。同时由控制终端产生的信号，比如 ctrl + z 等都会传递给前台 job。</p>
<p>一般情况下 session 和终端是一对一的关系，当我们打开多个终端窗口时，实际上就创建了多个 session。</p>
<p>Session 的意义在于多个工作(job)在一个终端中运行，其中的一个为前台 job，它直接接收该终端的输入并把结果输出到该终端。其它的 job 则在后台运行。</p>
<h4 id="诞生与消亡">诞生与消亡<a hidden class="anchor" aria-hidden="true" href="#诞生与消亡">#</a></h4>
<p>通常，新的 session 由系统登录程序创建，session 中的领头进程是运行用户登录 shell 的进程。新创建的每个进程都会属于一个进程组，当创建一个进程时，它和父进程在同一个进程组、session 中。</p>
<p>将进程放入不同 session 的惟一方法是使用 setsid 函数使其成为新 session 的领头进程。这还会将 session 领头进程放入一个新的进程组中。</p>
<p>当 session 中的所有进程都结束时 session 也就消亡了。实际使用中比如网络断开了，session 肯定是要消亡的。另外就是正常的消亡，比如让 session 的领头进程退出。一般情况下 session 的领头进程是 shell 进程，如果它处于前台，我们可以使用 exit 命令或者是 ctrl + d 让它退出。或者我们可以直接通过 kill 命令杀死 session 的领头进程。这里面的原理是：当系统检测到挂断(hangup)条件时，内核中的驱动会将 SIGHUP 信号发送到整个 session。通常情况下，这会杀死 session 中的所有进程。</p>
<p><strong>session 与终端的关系</strong></p>
<p>如果 session 关联的是伪终端，这个伪终端本身就是随着 session 的建立而创建的，session 结束，那么这个伪终端也会被销毁。</p>
<p>如果 session 关联的是 tty1-6，tty 则不会被销毁。因为该终端设备是在系统初始化的时候创建的，并不是依赖该会话建立的，所以当 session 退出，tty 仍然存在。只是 init 系统在 session 结束后，会重启 getty 来监听这个 tty。</p>
<h4 id="nohup">nohup<a hidden class="anchor" aria-hidden="true" href="#nohup">#</a></h4>
<p>如果我们在 session 中执行了 nohup 等类似的命令，当 session 消亡时，相关的进程并不会随着 session 结束，原因是这些进程不再受 SIGHUP 信号的影响。比如我们执行下面的命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ nohup sleep <span style="color:#ae81ff">1000</span> &gt;/dev/null 2&gt;&amp;<span style="color:#ae81ff">1</span> &amp; 
$ ps -o pid,ppid,pgid,sid,tty,comm
    PID    PPID    PGID     SID TT       COMMAND
   <span style="color:#ae81ff">7837</span>    <span style="color:#ae81ff">7836</span>    <span style="color:#ae81ff">7837</span>    <span style="color:#ae81ff">7837</span> pts/0    zsh
   <span style="color:#ae81ff">7848</span>    <span style="color:#ae81ff">7837</span>    <span style="color:#ae81ff">7848</span>    <span style="color:#ae81ff">7837</span> pts/0    sleep
   <span style="color:#ae81ff">7858</span>    <span style="color:#ae81ff">7837</span>    <span style="color:#ae81ff">7858</span>    <span style="color:#ae81ff">7837</span> pts/0    ps
</code></pre></div><p>此时 sleep 进程的 sid 和其它进程是相同的，还可以通过 pstree 命令看到进程间的父子关系。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ pstree
</code></pre></div><p>如果我们退出当前 session 的领头进程(bash)，sleep 进程并不会退出，这样我们就可以放心的等待该进程运行结果了。</p>
<p>nohup 并不改变进程的 sid，同时也说明在这种情况中，虽然 session 的领头进程退出了，但是 session 依然没有被销毁(至少 sid 还在被引用)。重新建立连接，通过下面的命令查看 sleep 进程的信息，发现进程的 sid 依然是 7837：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ps -o pid,ppid,pgid,sid,tty,comm
    PID    PPID    PGID     SID TT       COMMAND
   <span style="color:#ae81ff">7848</span>       <span style="color:#ae81ff">1</span>    <span style="color:#ae81ff">7848</span>    <span style="color:#ae81ff">7837</span> ?        sleep
</code></pre></div><p>但是此时的 sleep 已经被系统的 1 号进程 systemd 收养了。</p>
<h4 id="setsid">setsid<a hidden class="anchor" aria-hidden="true" href="#setsid">#</a></h4>
<p>setsid 会创建一个新的 session，它的目的是让进程在后台执行命令，实现方式就是让命令进程运行在一个新的与终端脱离的 session 中。看下面的示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ setsid sleep <span style="color:#ae81ff">1000</span>
</code></pre></div><p>查找之下居然没有发现 sleep 进程的踪迹：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ps -o pid,ppid,pgid,sid,tty,comm
    PID    PPID    PGID     SID TT       COMMAND
  <span style="color:#ae81ff">11162</span>   <span style="color:#ae81ff">11161</span>   <span style="color:#ae81ff">11162</span>   <span style="color:#ae81ff">11162</span> pts/1    bash
  <span style="color:#ae81ff">11451</span>   <span style="color:#ae81ff">11162</span>   <span style="color:#ae81ff">11451</span>   <span style="color:#ae81ff">11162</span> pts/1    ps
</code></pre></div><p>通过 grep 查询 sleep 进程的 PID：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ps aux | grep sleep
nick     <span style="color:#ae81ff">11384</span>  0.0  0.0  <span style="color:#ae81ff">6176</span>   <span style="color:#ae81ff">840</span> ?        Ss   09:00   0:00 sleep <span style="color:#ae81ff">1000</span>
</code></pre></div><p>去查看 sleep 进程所在的 sid，发现是一个新的 session ID，并且没有关联终端：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ps -o pid,ppid,pgid,sid,tty,comm -p <span style="color:#ae81ff">11384</span>
    PID    PPID    PGID     SID TT       COMMAND
  <span style="color:#ae81ff">11384</span>       <span style="color:#ae81ff">1</span>   <span style="color:#ae81ff">11384</span>   <span style="color:#ae81ff">11384</span> ?        sleep
</code></pre></div><p>当一个进程通过调用 setsid 成为一个新的 session 领头进程时，它会与控制终端断开连接。</p>
<p>此时通过 pstree 查看进程间的关系，发现 sleep 进程直接被系统的 1 号进程 systemd 收养了。</p>
<h4 id="控制终端">控制终端<a hidden class="anchor" aria-hidden="true" href="#控制终端">#</a></h4>
<p>**控制终端是进程的一个属性。**通过 fork 系统调用创建的子进程会从父进程那里继承控制终端。这样，session 中的所有进程都从 session 领头进程那里继承控制终端。Session 的领头进程称为终端的控制进程(controlling process)。简单点说就是：**一个 session 只能与一个终端关联，这个终端被称为 session 的控制终端(controlling terminal)。**同时只能由 session 的领头进程来建立或者改变终端与 session 的联系。我们可以通过 ps 命令查看进程的控制终端( pts/0 )：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ps -o pid,ppid,pgid,sid,tty,comm
    PID    PPID    PGID     SID TT       COMMAND
  <span style="color:#ae81ff">17540</span>   <span style="color:#ae81ff">17539</span>   <span style="color:#ae81ff">17540</span>   <span style="color:#ae81ff">17540</span> pts/0    bash
  <span style="color:#ae81ff">17550</span>   <span style="color:#ae81ff">17540</span>   <span style="color:#ae81ff">17540</span>   <span style="color:#ae81ff">17540</span> pts/0    ps
</code></pre></div><p>支持 job control 的 <strong>shell</strong> 必须能够控制在某一时刻由哪个 job 使用终端。否则，可能会有多个 job 试图同时从终端读取数据，这会导致进程在接收用户输入时的混乱。为了防止这种情况发生，shell 必须按照预定的协议与终端驱动程序协作。</p>
<p>shell 一次只允许一个 job(进程组)访问控制终端。来自控制终端的某些输入会导致信号被发送到与控制终端关联的 job(进程组)中的所有进程。该 job 被称为控制终端上的前台 job。由 shell 管理的其他 job 在不访问终端的情况下，被称为后台 job。</p>
<p>Shell 的职责是通知 job 何时停止何时启动，还要把 job 的信息通知给用户，并提供机制允许用户继续暂停的 job、在前台和后台之间切换 job。比如前台 job 可以无限制的自由使用控制终端，而后台 job 则不可以。当后台 job 中的进程试图从其控制终端读取数据时，通常会向进程组发送 SIGTTIN 信号。这通常会导致该组中的所有进程停止(变成 stopped 状态)。类似地，当后台 job 中的进程试图写入其控制终端时，默认行为是向进程组发送 SIGTTOU 信号，但是否允许写入的控制会更加的复杂。</p>
<h2 id="tips-1">TIPS<a hidden class="anchor" aria-hidden="true" href="#tips-1">#</a></h2>
<h3 id="backupyoursystemhttpshelpubuntucomcommunitybackupyoursystem"><a href="https://help.ubuntu.com/community/BackupYourSystem">BackupYourSystem</a><a hidden class="anchor" aria-hidden="true" href="#backupyoursystemhttpshelpubuntucomcommunitybackupyoursystem">#</a></h3>
<h4 id="rsync">Rsync<a hidden class="anchor" aria-hidden="true" href="#rsync">#</a></h4>
<p>目的在于恢复系统出现的错误，类似于虚拟机的快照。</p>
<p><strong>备份</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">#!/bin/bash
</span><span style="color:#75715e"></span>
set -o errexit
set -o nounset
set -o pipefail

readonly SOURCE_DIR<span style="color:#f92672">=</span>/
readonly BACKUP_DIR<span style="color:#f92672">=</span>/home/kurome/DataBackup
readonly DATETIME<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span><span style="color:#66d9ef">$(</span>date <span style="color:#e6db74">&#39;+%Y-%m-%d_%H:%M:%S&#39;</span><span style="color:#66d9ef">)</span><span style="color:#e6db74">&#34;</span>
readonly BACKUP_PATH<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>BACKUP_DIR<span style="color:#e6db74">}</span><span style="color:#e6db74">/</span><span style="color:#e6db74">${</span>DATETIME<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>
readonly LATEST_LINK<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>BACKUP_DIR<span style="color:#e6db74">}</span><span style="color:#e6db74">/latest&#34;</span>

rsync -av <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>	--delete <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>SOURCE_DIR<span style="color:#e6db74">}</span><span style="color:#e6db74">/&#34;</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>	--link-dest <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>LATEST_LINK<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>	--exclude<span style="color:#f92672">={</span><span style="color:#e6db74">&#34;dev&#34;</span>,<span style="color:#e6db74">&#34;proc&#34;</span>,<span style="color:#e6db74">&#34;sys&#34;</span>,<span style="color:#e6db74">&#34;tmp&#34;</span>,<span style="color:#e6db74">&#34;run&#34;</span>,<span style="color:#e6db74">&#34;mnt&#34;</span>,<span style="color:#e6db74">&#34;media&#34;</span>,<span style="color:#e6db74">&#34;lost+found&#34;</span>,<span style="color:#e6db74">&#34;Trash&#34;</span>,<span style="color:#e6db74">&#34;Downloads/*&#34;</span>,<span style="color:#e6db74">&#34;DataBackup/*&#34;</span>,<span style="color:#e6db74">&#34;DataPool/*&#34;</span><span style="color:#f92672">}</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>	<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>BACKUP_PATH<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>
rm -rf <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>LATEST_LINK<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>
ln -s <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>BACKUP_PATH<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>LATEST_LINK<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>
</code></pre></div><p>注意：</p>
<ul>
<li><code>${SOURCE_DIR}/</code>必须带反斜杠，否则会备份<code>SOURCE_DIR</code>这个目录，而不是这个目录里的内容。</li>
<li><code>--exclude=&quot;Trash&quot;</code>，Trash被认为为目录，而非文件或文件和目录，并且，它不支持路径<code>~/.local/share/Trash</code></li>
</ul>
<p>查看备份大小</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo du -hs /backup/
16G	/backup/
</code></pre></div><p>整个备份为16GB，所花时间 12m。</p>
<p>通过 crontab 使之每周一12点自动备份：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo crontab -e
<span style="color:#ae81ff">0</span> <span style="color:#ae81ff">12</span> * * <span style="color:#ae81ff">1</span> /path/.backup.sh
</code></pre></div><p><strong>还原</strong></p>
<p>还原的时候，如果带 <code>--delete</code>，那么就会删除备份时 <code>--exclude=</code> 不包含的内容。还原的时候，同名文件内容会恢复到备份时候的状态。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ rsync -av 备份目录 源目录
$ rsync -av /backup/latest/ /
</code></pre></div><h4 id="tarhttpshelpubuntucomcommunitybackupyoursystemtar"><a href="https://help.ubuntu.com/community/BackupYourSystem/TAR">TAR</a><a hidden class="anchor" aria-hidden="true" href="#tarhttpshelpubuntucomcommunitybackupyoursystemtar">#</a></h4>
<p>目的在于迁移系统到新硬盘。</p>
<p><strong>Backup</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cd / <span style="color:#75715e"># THIS CD IS IMPORTANT THE FOLLOWING LONG COMMAND IS RUN FROM /</span>
$ tar -cvpzf backup.tar.gz <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>--exclude<span style="color:#f92672">=</span>/backup.tar.gz <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>--exclude<span style="color:#f92672">=</span>/proc <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>--exclude<span style="color:#f92672">=</span>/tmp <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>--exclude<span style="color:#f92672">=</span>/mnt <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>--exclude<span style="color:#f92672">=</span>/dev <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>--exclude<span style="color:#f92672">=</span>/sys <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>--exclude<span style="color:#f92672">=</span>/run <span style="color:#ae81ff">\ </span>
--exclude<span style="color:#f92672">=</span>/media <span style="color:#ae81ff">\ </span>
--exclude<span style="color:#f92672">=</span>/var/log <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>--exclude<span style="color:#f92672">=</span>/var/cache/apt/archives <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>--exclude<span style="color:#f92672">=</span>/usr/src/linux-headers* <span style="color:#ae81ff">\ </span>
--exclude<span style="color:#f92672">=</span>/home/*/.gvfs <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>--exclude<span style="color:#f92672">=</span>/home/*/.cache <span style="color:#ae81ff">\ </span>
--exclude<span style="color:#f92672">=</span>/home/*/.local/share/Trash /
</code></pre></div><p><strong>Restoring</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo tar -xvpzf /path/to/backup.tar.gz -C /media/whatever --numeric-owner
$ cd /media/whatever
$ mkdir /proc /sys /mnt /media 
</code></pre></div><p>For the system to boot, you will need to restore grub. To do this, you will need to reconfigure it in a chroot:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo -s
<span style="color:#66d9ef">for</span> f in dev dev/pts proc ; <span style="color:#66d9ef">do</span> mount --bind /$f /media/whatever/$f ; <span style="color:#66d9ef">done</span>
$ chroot /media/whatever
$ dpkg-reconfigure grub-pc
</code></pre></div><p>You will get a menu asking you what drive(s) grub should be installed on. Choose whatever drive(s) the computer will be booting from.</p>
<p>For more information on repairing grub, see [GrubHowto](<a href="https://help.ubuntu.com/community/GrubHowto#Backup">https://help.ubuntu.com/community/GrubHowto#Backup</a>, Repairing and Reinstalling GRUB)</p>
<h4 id="others-3">Others<a hidden class="anchor" aria-hidden="true" href="#others-3">#</a></h4>
<p><a href="https://askubuntu.com/questions/618244/does-the-uefi-partition-either-must-or-should-be-first-for-some-reason-if-s"><strong>Does the UEFI partition either &ldquo;MUST&rdquo; or &ldquo;SHOULD&rdquo; be first for some reason? If so why?</strong></a></p>
<p>The key words &ldquo;SHOULD&rdquo;, &ldquo;MUST&rdquo; and &ldquo;MAY&rdquo; (capitalised) in this answer are to be interpreted as described in <a href="https://www.ietf.org/rfc/rfc2119.txt">RFC 2119</a>.</p>
<p>An (U)EFI System Partition (ESP from now on):</p>
<ul>
<li>MAY reside at the beginning of the disk
<strong>and</strong></li>
<li>SHOULD be FAT32 because of <a href="http://www.rodsbooks.com/efi-bootloaders/principles.html">Windows compatibility</a>.</li>
</ul>
<p>The only <a href="http://www.uefi.org/sites/default/files/resources/UEFI_Drive_Partition_Limits_Fact_Sheet.pdf">official limit</a> is:</p>
<ul>
<li>the ESP MUST reside in the first 2.2 Terabytes of the disk.</li>
</ul>
<p>So, the ESP MUST reside anywhere in those first 2.2 TB of the disk, but <em>there is absolutely no need for the ESP to be the first partition</em> or reside on the beginning of the disk whatsoever.
(It&rsquo;s just that some large company in Redmond, WA <a href="https://i-technet.sec.s-msft.com/dynimg/IC514408.png">advises system integrators differently</a>)&hellip;</p>
<p>I would put it as the last partition on the disk (if &lt; 2.2TB) as it&rsquo;s only used to load other OSes, but that&rsquo;s just a personal, totally subjective opinion!</p>
<p><strong>ubuntu 20.04 默认 fstab</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># / was on /dev/sda2 during installation</span>
UUID<span style="color:#f92672">=</span>4b66082e-7982-4056-91c2-39cf9177b20f /               ext4    errors<span style="color:#f92672">=</span>remount-ro <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">1</span>
<span style="color:#75715e"># /boot/efi was on /dev/sda1 during installation</span>
UUID<span style="color:#f92672">=</span>ACEE-47E4  /boot/efi       vfat    umask<span style="color:#f92672">=</span><span style="color:#ae81ff">0077</span>      <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">1</span>
/swapfile                                 none            swap    sw              <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>
</code></pre></div><p>/boot/efi 是独立分区，而不是 /boot/，如果是 /boot/ 作为独立分区，还原的时候会报错 cannot create symbolic link &lsquo;./initrd.img&rsquo;: Operation not permitted</p>
<p><a href="https://askubuntu.com/questions/1103170/accidently-deleted-boot-option-on-dell-laptop"><strong>Add Boot Option Manually</strong></a></p>
<p>In <em>Boot Option Name</em>, type <em>Ubuntu</em>, and in <em>File Name</em> select the file <em>grubx64.efi</em> and then Click on &lsquo;OK&rsquo;.</p>
<p><a href="https://linux.cn/article-10655-1.html"><strong>13 个开源备份解决方案</strong></a></p>
<ul>
<li>
<p>Cronopete</p>
</li>
<li>
<p>Deja Dup</p>
</li>
<li>
<p>Rclone</p>
</li>
<li>
<p>Rdiff-backup</p>
</li>
<li>
<p>Restic</p>
</li>
<li>
<p>Rsync</p>
</li>
<li>
<p><a href="https://www.borgbackup.org/">BorgBackup</a>：带有压缩和加密特性以用具有数据去重功能的备份解决方案。它基于 BSD 许可证，支持 Linux、MacOS 和 BSD。</p>
</li>
<li>
<p><a href="https://www.urbackup.org/">UrBackup</a>：它可以做镜像和文件的完整和增量备份；你可以保存整个分区或单个目录。它有 Windows、Linux、和 MacOS 客户端，并且采用 GNU Affero 公共许可证。</p>
</li>
<li>
<p><a href="http://luckybackup.sourceforge.net/">LuckyBackup</a>：根据其网站介绍，“它是一个易于使用、快速（只传输变化部分，而不是全部数据）、安全（在做任何数据操作之前，先检查所有需要备份的目录，以确保数据安全）、可靠和完全可定制的备份解决方案。它在 GPL 许可证下发行。</p>
</li>
<li>
<p><a href="http://0pointer.net/blog/casync-a-tool-for-distributing-file-system-images.html">Casync</a> ：一个可寻址内容的同步解决方案 —— 它设计用于备份、同步、存储和检索大文件系统的多个相关版本。它使用 GNU Lesser 公共许可证。</p>
</li>
<li>
<p><a href="https://syncthing.net/">Syncthing</a>：用于在两台计算机之间同步文件。它基于 Mozilla 公共许可证使用，根据其网站介绍，它是安全和私密的。它可以工作于 MacOS、Windows、Linux、FreeBSD、Solaris 和 OpenBSD。</p>
</li>
<li>
<p><a href="https://www.duplicati.com/">Duplicati</a>：一个可工作于 Windows、MacOS 和 Linux 上的、并且支持多种标准协议（比如 FTP、SSH、WebDAV 和云服务）、免费的备份解决方案。它的特性是强大的加密功能，并且它使用 GPL 许可证。</p>
</li>
<li>
<p><a href="http://dirvish.org/">Dirvish</a> ：一个基于磁盘的虚拟镜像备份系统，它使用 OSL-3.0 许可证。它要求必须安装有 Rsync、Perl5、SSH。</p>
</li>
<li>
<p><a href="https://www.bacula.org/">Bacula</a>：允许系统管理员去管理备份、恢复、和跨网络的不同种类计算机上的多种数据的一套计算机程序，它支持在 Linux、FreeBSD、Windows、MacOS、OpenBSD 和 Solaris 上运行，并且它的大部分源代码都是基于 AGPLv3 许可证的。</p>
</li>
<li>
<p><a href="https://backuppc.github.io/backuppc/">BackupPC</a>：一个高性能的、企业级的、可以备份 Linux、Windows 和 MacOS 系统的 PC 和笔记本电脑上的数据到服务器磁盘上的备份解决方案。它是基于 GPLv3 许可证的。</p>
</li>
<li>
<p><a href="http://www.amanda.org/">Amanda</a> ：一个使用 C 和 Perl 写的备份系统，它允许系统管理员去备份整个网络中的客户端到一台服务器上的磁带、磁盘或基于云的系统。它是由马里兰大学于 1991 年开发并拥有版权，并且它有一个 BSD 式的许可证。</p>
</li>
<li>
<p><a href="https://github.com/bit-team/backintime">Back in Time</a> ：一个为 Linux 设计的简单的备份实用程序。它提供了命令行和图形用户界面，它们都是用 Python 写的。去执行一个备份，只需要指定存储快照的位置、需要备份的文件夹，和备份频率即可。它使用的是 GPLv2 许可证。</p>
</li>
<li>
<p><a href="https://github.com/teejee2008/timeshift">Timeshift</a> ：一个 Linux 上的备份实用程序，它类似于 Windows 上的系统恢复和 MacOS 上的时间胶囊。它的 GitHub 仓库上介绍说：“Timeshift 通过定期递增的文件系统快照来保护你的系统。这些快照可以在日后用于数据恢复，以撤销某些对文件系统的修改。”</p>
</li>
<li>
<p><a href="https://github.com/spersson/Kup">Kup</a> ：一个能够帮助用户备份它们的文件到 USB 驱动器上的备份解决方案，但它也可以用于执行网络备份。它的 GitHub 仓库上介绍说：”当插入你的外部硬盘时，Kup 将自动启动并复制你的最新的修改。“</p>
</li>
</ul>
<p><a href="https://askubuntu.com/questions/19901/how-to-make-a-disk-image-and-restore-from-it-later"><strong>How to make a disk image and restore from it later?</strong></a>/<a href="https://askubuntu.com/questions/741723/moving-entire-linux-installation-to-another-drive"><strong>Moving entire Linux installation to another drive</strong></a></p>
<p>It&rsquo;s Clonezilla Live: <a href="http://clonezilla.org/">http://clonezilla.org/</a></p>
<p>The tutorial for Clonezilla can be found <a href="http://www.dedoimedo.com/computers/free_imaging_software.html">here.</a></p>
<p><a href="https://askubuntu.com/questions/13278/easy-backup-restore-of-installed-system"><strong>Easy backup/restore of installed system?</strong></a></p>
<p>Yes you can use remastersys for that.You can see a complete tutorial <a href="http://www.ubuntugeek.com/creating-custom-ubuntu-live-cd-with-remastersys.html">here</a></p>
<h3 id="清理系统">清理系统<a hidden class="anchor" aria-hidden="true" href="#清理系统">#</a></h3>
<h4 id="删除不再需要的包">删除不再需要的包<a hidden class="anchor" aria-hidden="true" href="#删除不再需要的包">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt autoremove
</code></pre></div><h4 id="apt-cache">APT cache<a hidden class="anchor" aria-hidden="true" href="#apt-cache">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># see the size of this cache</span>
$ sudo du -sh /var/cache/apt 
<span style="color:#75715e"># remove only the outdated packages</span>
$ sudo apt-get autoclean
<span style="color:#75715e"># delete apt cache in its entirety</span>
$ sudo apt-get clean 
</code></pre></div><p>apt-get 和软件中心下载的软件包一般放在 <code>/var/cache/apt/archives/</code> 目录，一般都安装在 <code>/usr/</code></p>
<h4 id="journal-logs">Journal logs<a hidden class="anchor" aria-hidden="true" href="#journal-logs">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># check the log size</span>
$ journalctl --disk-usage
<span style="color:#75715e"># clear the logs that are older than a certain days</span>
$ journalctl --vacuum-time<span style="color:#f92672">=</span>3d
</code></pre></div><h4 id="thumbnails-cache">Thumbnails cache<a hidden class="anchor" aria-hidden="true" href="#thumbnails-cache">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># check the size of thumbnail cache</span>
$ du -sh ~/.cache/thumbnails
$ rm -rf ~/.cache/thumbnails/*
</code></pre></div><h4 id="duplicate-files">Duplicate files<a hidden class="anchor" aria-hidden="true" href="#duplicate-files">#</a></h4>
<p>Find and remove duplicate files：You can use a GUI tool like <a href="https://www.pixelbeat.org/fslint/">FSlint</a> or a command line tool like <a href="https://github.com/adrianlopezroche/fdupes">FDUPES</a> for this task</p>
<h4 id="old-linux-kernels">Old Linux kernels<a hidden class="anchor" aria-hidden="true" href="#old-linux-kernels">#</a></h4>
<p>Remove old Linux kernels</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># List all installed Linux kernels</span>
$ sudo dpkg --list <span style="color:#e6db74">&#39;linux-image*&#39;</span>
$ apt-get remove linux-image-VERSION
</code></pre></div><h4 id="清理-snaphttpslinuxcnarticle-14302-1html"><a href="https://linux.cn/article-14302-1.html">清理 Snap</a><a hidden class="anchor" aria-hidden="true" href="#清理-snaphttpslinuxcnarticle-14302-1html">#</a></h4>
<p>与 snap 有关的系统文件都存放在 <code>/var/lib/snapd</code> 目录下。根据你所安装的 Snap 包的数量，这个目录的大小可能在几 GB。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo du -sh /var/lib/snapd
</code></pre></div><p>根据设计，Snap 至少会在你的系统上保留一个你所安装的软件包的旧版本。你可以通过使用 Snap 命令看到这种行为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ snap list --all
</code></pre></div><p>你应该看到同一个软件包被列了两次，而且版本和修订号都不同。</p>
<p>为了释放磁盘空间，你可以删除额外的软件包版本。你怎么知道要删除哪一个呢？你可以看到，这些较旧的软件包被标记为“禁用”。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">#!/bin/bash
</span><span style="color:#75715e"></span><span style="color:#75715e"># Removes old revisions of snaps</span>
<span style="color:#75715e"># CLOSE ALL SNAPS BEFORE RUNNING THIS</span>
set -eu
snap list --all | awk <span style="color:#e6db74">&#39;/disabled/{print $1, $3}&#39;</span> |
    <span style="color:#66d9ef">while</span> read snapname revision; <span style="color:#66d9ef">do</span>
        snap remove <span style="color:#e6db74">&#34;</span>$snapname<span style="color:#e6db74">&#34;</span> --revision<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$revision<span style="color:#e6db74">&#34;</span>
    <span style="color:#66d9ef">done</span>
</code></pre></div><h3 id="命令行技巧">命令行技巧<a hidden class="anchor" aria-hidden="true" href="#命令行技巧">#</a></h3>
<h4 id="bash-快捷键">Bash 快捷键<a hidden class="anchor" aria-hidden="true" href="#bash-快捷键">#</a></h4>
<p><strong>编辑命令</strong></p>
<ul>
<li><code>Ctrl + a</code> ：移到命令行首</li>
<li><code>Ctrl + e</code> ：移到命令行尾</li>
<li><code>Ctrl + f</code> ：按字符前移（右向）</li>
<li><code>Ctrl + b</code> ：按字符后移（左向）</li>
<li><code>Alt + f</code> ：按单词前移（右向）</li>
<li><code>Alt + b</code> ：按单词后移（左向）</li>
<li><code>Ctrl + xx</code>：在命令行首和光标之间移动</li>
<li><code>Ctrl + u</code> ：从光标处删除至命令行首</li>
<li><code>Ctrl + k</code> ：从光标处删除至命令行尾</li>
<li><code>Ctrl + w</code> ：从光标处删除至字首</li>
<li><code>Alt + d</code> ：从光标处删除至字尾</li>
<li><code>Ctrl + d</code> ：删除光标处的字符</li>
<li><code>Ctrl + h</code> ：删除光标前的字符</li>
<li><code>Ctrl + y</code> ：粘贴至光标后</li>
<li><code>Alt + c</code> ：从光标处更改为首字母大写的单词</li>
<li><code>Alt + u</code> ：从光标处更改为全部大写的单词</li>
<li><code>Alt + l</code> ：从光标处更改为全部小写的单词</li>
<li><code>Ctrl + t</code> ：交换光标处和之前的字符</li>
<li><code>Alt + t</code> ：交换光标处和之前的单词</li>
<li><code>Alt + Backspace</code>：与 Ctrl + w 类似，分隔符有些差别</li>
</ul>
<p><strong>重新执行命令</strong></p>
<ul>
<li><code>Ctrl + r</code>：逆向搜索命令历史</li>
<li><code>Ctrl + g</code>：从历史搜索模式退出</li>
<li><code>Ctrl + p</code>：历史中的上一条命令</li>
<li><code>Ctrl + n</code>：历史中的下一条命令</li>
<li><code>Alt + .</code>：使用上一条命令的最后一个参数</li>
</ul>
<p><strong>控制命令</strong></p>
<ul>
<li><code>Ctrl + l</code>：清屏</li>
<li><code>Ctrl + o</code>：执行当前命令，并选择上一条命令</li>
<li><code>Ctrl + s</code>：阻止屏幕输出</li>
<li><code>Ctrl + q</code>：允许屏幕输出</li>
<li><code>Ctrl + c</code>：终止命令</li>
<li><code>Ctrl + z</code>：挂起命令</li>
</ul>
<p><strong>Bang (!) 命令</strong></p>
<ul>
<li><code>!!</code>：执行上一条命令</li>
<li><code>!blah</code>：执行最近的以 blah 开头的命令，如 <code>!ls</code></li>
<li><code>!blah:p</code>：仅打印输出，而不执行</li>
<li><code>!$</code>：上一条命令的最后一个参数，与 <code>Alt + .</code> 相同</li>
<li><code>!$:p</code>：打印输出 <code>!$</code> 的内容</li>
<li><code>!*</code>：上一条命令的所有参数</li>
<li><code>!*:p</code>：打印输出 <code>!*</code> 的内容</li>
<li><code>^blah</code>：删除上一条命令中的 blah</li>
<li><code>^blah^foo</code>：将上一条命令中的 blah 替换为 foo</li>
<li><code>^blah^foo^</code>：将上一条命令中所有的 blah 都替换为 foo</li>
</ul>
<h4 id="你可能不知道的shellhttpscoolshellcnarticles8619html"><a href="https://coolshell.cn/articles/8619.html">你可能不知道的SHELL</a><a hidden class="anchor" aria-hidden="true" href="#你可能不知道的shellhttpscoolshellcnarticles8619html">#</a></h4>
<p>Shell也叫做命令行界面，它是*nix操作系统下用户和计算机的交互界面。Shell这个词是指操作系统中提供访问内核服务的程序。</p>
<p>这篇文章向大家介绍Shell一些非广为人知、但却实用有趣的知识，权当品尝shell主食后的甜点吧。</p>
<p><strong>科普</strong></p>
<p>先科普几个你可能不知道的事实：</p>
<ul>
<li>
<p>Shell几乎是和Unix操作系统一起诞生，第一个Unix Shell是肯·汤普逊（Ken Thompson）以Multics上的Shell为模范在1971年改写而成，并命名Thompson sh。即便是后来流行的bash（shell的一种变体），它的年龄实际上比当前流行的所有的Linux kernel都大，可谓在Linux系统上是先有Shell再有Kernel。</p>
</li>
<li>
<p>当前绝大部分*nix和MacOS操作系统里的默认的Shell都是bash，bash由Brian Fox在1987年创造，全称Bourne Again shell ( bash)。</p>
</li>
<li>
<p>你或许听说除了bash之外，还有Bourne shell ( sh)，Korn shell ( ksh)，C shell （包括 csh and tcsh），但是你知道这个星球上一共存在着大约50多种不同的shell么？想了解他们，请参考 <a href="https://www.freebsd.org/ports/shells.html">http://www.freebsd.org/ports/shells.html</a>。</p>
</li>
</ul>
<p><strong>一些强大的命令</strong></p>
<ul>
<li>
<p>在命令行前加空格，该命令不会进入history里。</p>
</li>
<li>
<p><code>ctrl-x e</code></p>
<p>快速启动你的默认编辑器（由变量$EDITOR设置）。</p>
</li>
</ul>
<h4 id="为什么说-zsh-是-shell-中的极品httpswwwzhihucomquestion21418449"><a href="https://www.zhihu.com/question/21418449">为什么说 zsh 是 shell 中的极品？</a><a hidden class="anchor" aria-hidden="true" href="#为什么说-zsh-是-shell-中的极品httpswwwzhihucomquestion21418449">#</a></h4>
<p><strong>色彩高亮</strong></p>
<p>并不是传统基于正则表达式的色彩高亮，而是真的会判断你输入的是啥的色彩高亮。</p>
<p>比如一个主题白色代表普通命令或者程序，红色代表错误命令，青色的代表内建命令或者 alias （echo 和 ls ），这些都不是正则判断出来的，是真的去检查的。非零的错误码（上一条命令错误），也可以高亮显示。</p>
<p><strong>命令提示</strong></p>
<p>注意，命令提示和补全是两个完全不同的系统，很多时候提示比补全更有用。你输入命令，后面就用灰色给你提示命令的参数，而且是随着你动态输入完每一个字母不断修正变化。</p>
<p>这个命令提示是基于你的历史命令数据库进行分析的，随着你输入的命令越来越多，提示将会越来越准确和顺手。</p>
<p>如果你觉得它提示的正确，你可以 CTRL+F 表示采纳，后面就会自动帮你一次性全部输入完了。</p>
<p><strong>智能补全</strong></p>
<p>缩写路径补全：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cd /v/w/h
</code></pre></div><p>敲一个TAB</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cd /var/www/html/
</code></pre></div><p>补全目录、命令参数补全连敲两次TAB进入<strong>选择模式</strong>，除了 tab/shift+tab 可以前后切换外，你还可以使用光标键上下左右移动。回车表示确认选择，用 CTRL+G 表示退出。</p>
<p><strong>快速跳转</strong></p>
<p>输入 cd 后面加一个减号后，按一次 tab 马上就列出本次登陆后去过的最近几次路径，接着根据下面的提示输入数字按回车就过去了，比如输入：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cd -5 &lt;回车&gt;
</code></pre></div><p>当然你还可以不输入数字，而是再按一次 tab 进入选择模式，上下键或者 ctrl+n/p 来选择，回车确认，ctrl+g 返回。</p>
<p><strong>自动跳转</strong></p>
<p>敲入 z 命令，列出了自从我开始用zsh进入过的目录和他们的权重，进入次数越多，权重越大。z 后面加一个关键词就能跳转到所有匹配的历史路径中权重最高的那个了。空格分隔多个关键字，z会先匹配出第一个来，然后再匹配第二个&hellip;</p>
<p>使用：“z -l foo&quot; 可以列出包含 foo 的所有历史路径。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 按下ALT+O 就执行 cd .. 命令</span>
bindkey -s <span style="color:#e6db74">&#39;\eo&#39;</span>   <span style="color:#e6db74">&#39;cd ..\n&#39;</span>   
<span style="color:#75715e"># 按下 ALT+; 就执行 ls -l 命令</span>
bindkey -s <span style="color:#e6db74">&#39;\e;&#39;</span>   <span style="color:#e6db74">&#39;ls -l\n&#39;</span>    
</code></pre></div><p><strong>热键绑定</strong></p>
<p>zsh 里面使用 bindkey 命令可以设置一系列热键，用来运行某一个 zsh 内部命令或者某个 shell 命令。</p>
<h4 id="应该知道的linux技巧httpscoolshellcnarticles8883html"><a href="https://coolshell.cn/articles/8883.html">应该知道的LINUX技巧</a><a hidden class="anchor" aria-hidden="true" href="#应该知道的linux技巧httpscoolshellcnarticles8883html">#</a></h4>
<p>首先，我想告诉大家，<strong>在Unix/Linux下，最有效率技巧的不是操作图形界面，而是命令行操作，因为命令行意味着自动化</strong>。</p>
<p><strong>日常</strong></p>
<ul>
<li>
<p>请man bash后查找Readline Key Bindings一节来看看bash的默认热键，比如：<code>Alt-.</code> 把上一次命令的最后一个参数打出来，而<code>Alt-*</code> 则列出你可以输入的命令。</p>
</li>
<li>
<p>回到上一次的工作目录： cd –  （回到home是 cd ~）</p>
</li>
<li>
<p>pstree -p 可以帮你显示进程树。</p>
</li>
<li>
<p>使用 pgrep 和 pkill 来找到或是kill 某个名字的进程。 (-f 选项很有用).</p>
</li>
<li>
<p>通过 &lt;(some command) 可以把某命令当成一个文件。示例：比较一个本地文件和远程文件 /etc/hosts： diff /etc/hosts &lt;(ssh somehost cat /etc/hosts)</p>
</li>
<li>
<p>在 bash中，使用重定向到标准输出和标准错误。如： some-command &gt;logfile 2&gt;&amp;1。</p>
</li>
<li>
<p>使用 man ascii 来查看 ASCII 表。</p>
</li>
</ul>
<p><strong>系统调试</strong></p>
<ul>
<li>
<p>如果你想知道磁盘、CPU、或网络状态，你可以使用 iostat, netstat, top (或更好的 htop), 还有 dstat 命令。你可以很快地知道你的系统发生了什么事。关于这方面的命令，还有iftop, iotop等。</p>
</li>
<li>
<p>要了解内存的状态，你可以使用free和vmstat命令。具体来说，你需要注意 “cached” 的值，这个值是Linux内核占用的内存。还有free的值。</p>
</li>
<li>
<p>如果你要找到哪个socket或进程在使用网络带宽，你可以使用 iftop 或 nethogs。</p>
</li>
<li>
<p>如果你要抓网络包的话，试试 wireshark 或 tshark。</p>
</li>
<li>
<p>了解 strace 和 ltrace。这两个命令可以让你查看进程的系统调用，这有助于你分析进程的hang在哪了，怎么crash和failed的。你还可以用其来做性能profile，使用 -c 选项，你可以使用-p选项来attach上任意一个进程。</p>
</li>
<li>
<p>了解用ldd命令来检查相关的动态链接库。注意：<a href="https://coolshell.cn/articles/1626.html">ldd的安全问题</a></p>
</li>
<li>
<p>使用gdb来调试一个正在运行的进程或分析core dump文件。参看我写的《<a href="https://coolshell.cn/articles/3643.html">GDB中应该知道的几个调试方法</a>》</p>
</li>
<li>
<p>学会到 /proc 目录中查看信息。这是一个Linux内核运行时记录的整个操作系统的运行统计和信息，比如： /proc/cpuinfo, /proc/xxx/cwd, /proc/xxx/exe, /proc/xxx/fd/, /proc/xxx/smaps.</p>
</li>
<li>
<p>如果你调试某个东西为什么出错时，sar命令会有用。它可以让你看看 CPU, 内存, 网络, 等的统计信息。</p>
</li>
<li>
<p>使用 dmesg 来查看一些硬件或驱动程序的信息或问题。</p>
</li>
</ul>
<h4 id="powerline-shellhttpsgithubcomb-ryanpowerline-shell"><a href="https://github.com/b-ryan/powerline-shell">powerline-shell</a><a hidden class="anchor" aria-hidden="true" href="#powerline-shellhttpsgithubcomb-ryanpowerline-shell">#</a></h4>
<p>不想每次都安装 zsh 与 ohmyzsh？</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ pip install powerline-shell
</code></pre></div><p>Add the following to your <code>.bashrc</code> file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#66d9ef">function</span> _update_ps1<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    PS1<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>powerline-shell $?<span style="color:#66d9ef">)</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">if</span> <span style="color:#f92672">[[</span> $TERM !<span style="color:#f92672">=</span> linux <span style="color:#f92672">&amp;&amp;</span> ! $PROMPT_COMMAND <span style="color:#f92672">=</span>~ _update_ps1 <span style="color:#f92672">]]</span>; <span style="color:#66d9ef">then</span>
    PROMPT_COMMAND<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;_update_ps1; </span>$PROMPT_COMMAND<span style="color:#e6db74">&#34;</span>
<span style="color:#66d9ef">fi</span>
</code></pre></div><p>默认的话，路径会完整显示，会很长</p>
<p>generate the default config at this location using:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ mkdir -p ~/.config/powerline-shell <span style="color:#f92672">&amp;&amp;</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>powerline-shell --generate-config &gt; ~/.config/powerline-shell/config.json
</code></pre></div><p>Segment Configuration</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">{ 
    &#34;segments&#34;: 
    [  
        &#34;virtual_env&#34;,  
        &#34;username&#34;,  
        &#34;hostname&#34;,  
        &#34;ssh&#34;,   
        &#34;cwd&#34;,   
        &#34;git&#34;, 
        &#34;hg&#34;,    
        &#34;jobs&#34;,  
        &#34;root&#34; 
    ],
<span style="color:#a6e22e">+  &#34;cwd&#34;: 
</span><span style="color:#a6e22e">+    {
</span><span style="color:#a6e22e">+    &#34;max_depth&#34;: 1
</span><span style="color:#a6e22e">+	}
</span><span style="color:#a6e22e"></span>}
</code></pre></div><h3 id="检测硬盘坏道和坏块httpsblog51ctocompengjc2417004"><a href="https://blog.51cto.com/pengjc/2417004">检测硬盘坏道和坏块</a><a hidden class="anchor" aria-hidden="true" href="#检测硬盘坏道和坏块httpsblog51ctocompengjc2417004">#</a></h3>
<p>硬盘坏道分为物理坏道和逻辑坏道。</p>
<ul>
<li>物理坏道：就是硬盘实体有坏的地方，物理坏道推荐换硬盘，当然也有办法重新分区来隔离坏道，不过可能也用不久，所以不推荐。</li>
<li>逻辑坏道：是磁盘磁道上面的校验信息（ECC）跟磁道的数据对不上号所致。出现这一故障的原因，通常都是因为一些程序的错误操作或是该处扇区的磁介质开始出现不稳定的先兆。物理坏道也是逻辑坏道产生的一种原因。</li>
</ul>
<h4 id="发现">发现<a hidden class="anchor" aria-hidden="true" href="#发现">#</a></h4>
<p>dmesg：当有硬盘坏道时，通常在dmesg输出的信息中会有 Buffer I/O Error，所以经常检查dmesg的输出可以及时发现是否存在硬盘问题。</p>
<h4 id="检测">检测<a hidden class="anchor" aria-hidden="true" href="#检测">#</a></h4>
<p>通过fdisk 查看显示所有磁盘或闪存的信息</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo fdisk -l /dev/sd*
</code></pre></div><p>使用 badlocks检查 linux 硬盘上的坏道/坏块</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo badblocks -s -v /dev/sdb  &gt; badsectors.txt
</code></pre></div><h4 id="修复">修复<a hidden class="anchor" aria-hidden="true" href="#修复">#</a></h4>
<p>查看上述分区检查出来的坏道信息</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ tail -f badsectors.txt
</code></pre></div><p>先备份数据再修复磁盘。硬盘在使用时不能修复，否则可能存在写并发的问题，所以修复前需要umount对应分区,或使用 Live CD</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo umount MountPoint
</code></pre></div><p>umount 分区成功后，修复命令如下，其中<code>-w</code>表示写入修复的，后面是结束（END）和开始（START）块号，注意END在前，START在后。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo badblocks -s -w /dev/sdb <span style="color:#ae81ff">205971590</span> <span style="color:#ae81ff">205971595</span>
</code></pre></div><p>修复后再次检查</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo badblocks -s -v /dev/sdb <span style="color:#ae81ff">205971590</span> <span style="color:#ae81ff">205971595</span>
</code></pre></div><h4 id="屏蔽">屏蔽<a hidden class="anchor" aria-hidden="true" href="#屏蔽">#</a></h4>
<p>执行e2fsck（针对 ext2/ext3/ext4 文件系统）或fsck命令，命令中还需要用到 badsectors.txt 文件和设备文件。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># for ext2/ext3/ext4</span>
$ sudo e2fsck -l badsectors.txt /dev/sdb
<span style="color:#75715e"># others</span>
$ sudo fsck -l badsectors.txt /dev/sdb
</code></pre></div><h3 id="如何探索httpssamwhelpgithubiobook-ubuntu-qnareadhowtoexplore"><a href="https://samwhelp.github.io/book-ubuntu-qna/read/howto/explore/">如何探索</a><a hidden class="anchor" aria-hidden="true" href="#如何探索httpssamwhelpgithubiobook-ubuntu-qnareadhowtoexplore">#</a></h3>
<p><strong>從「指令」找到「使用說明」</strong></p>
<p>找使用說明</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ man -f ls
</code></pre></div><p>閱讀使用說明</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ man ls
$ man <span style="color:#ae81ff">1</span> ls

<span style="color:#75715e"># 若是「bash」內建的指令，則是可以使用「help」</span>
$ help <span style="color:#66d9ef">if</span>
</code></pre></div><p>上面的「man 1 ls」，「1」指的是「Manpage Sections」。</p>
<p>執行下面指令可以看到各個「Section」的簡介。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ whatis intro
</code></pre></div><p>然後分別執行下面的指令，可以閱讀更詳細的說明</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ man <span style="color:#ae81ff">1</span> intro
$ man <span style="color:#ae81ff">2</span> intro
$ man <span style="color:#ae81ff">3</span> intro
$ man <span style="color:#ae81ff">4</span> intro
$ man <span style="color:#ae81ff">5</span> intro
$ man <span style="color:#ae81ff">6</span> intro
$ man <span style="color:#ae81ff">7</span> intro
$ man <span style="color:#ae81ff">8</span> intro
</code></pre></div><p><strong>從「指令」找到「所屬套件」</strong></p>
<p>先透過「whereis」來找到「ls」所在的確切路徑。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ whereis ls
ls: /bin/ls
</code></pre></div><p>然後根據這個結果，再執行下面的指令</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ rpm -qf /bin/ls
$ dpkg -S /bin/ls
coreutils-8.32-1.2.x86_64
</code></pre></div><p><strong>找「已安裝套件」的「檔案列表」</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ rpm -ql coreutils
$ dpkg -L coreutils
</code></pre></div><h3 id="transfer-files-between-linux-and-androidhttpsmashtipscomtransfer-images-android-linuxtext120connect20your20android20smartphone20and20your20linuxselectede2809d20or20e2809cimport20alle2809d20if20you20want20"><a href="https://mashtips.com/transfer-images-android-linux/#:~:text=1%20Connect%20your%20Android%20smartphone%20and%20your%20Linux,Selected%E2%80%9D%20or%20%E2%80%9CImport%20All%E2%80%9D%20if%20you%20want%20">Transfer files between Linux and Android</a><a hidden class="anchor" aria-hidden="true" href="#transfer-files-between-linux-and-androidhttpsmashtipscomtransfer-images-android-linuxtext120connect20your20android20smartphone20and20your20linuxselectede2809d20or20e2809cimport20alle2809d20if20you20want20">#</a></h3>
<ul>
<li>Connect Using USB Cable</li>
<li>Apps
<ul>
<li><a href="https://www.howtogeek.com/423442/how-to-wirelessly-transfer-android-files-to-a-linux-desktop/">KDE Connect/GSConnect</a></li>
<li><a href="https://www.omgubuntu.co.uk/2017/11/android-file-transfer-app-linux">Android File Transfer</a></li>
<li><a href="https://help.airdroid.com/hc/en-us/articles/360035143073-How-to-transfer-files-between-Linux-and-Android-">AirDroid</a></li>
</ul>
</li>
<li>Bluetooth</li>
</ul>
<h3 id="xorg-vs-wayland">Xorg vs Wayland<a hidden class="anchor" aria-hidden="true" href="#xorg-vs-wayland">#</a></h3>
<p>X即X11、X Window System，是用于在类UNIX的操作系统上的位图显示的窗口系统，提供了GUI环境的基本框架。X由X.Org Foundation维护，遵守MIT协议，当前参考实现为X.Org Server。在架构方面，X使用了C/S模型，客户端和服务器可以在同一个机器上，也可以在不同的机器上，X作为Server为应用程序这个Client提供显示和I/O服务。</p>
<p><img loading="lazy" src="/Distributions/XServer.png" alt=""  />
</p>
<p>Wayland是一个显示服务协议，服务端为Wayland Compositor，把X的X Server和Compositor合二为一，旨在替换X，作为类Unix操作系统上更现代、简介的窗口系统，遵守MIT协议，提供了Wayland Compositor的参考C语言实现Weston。</p>
<p><img loading="lazy" src="/Distributions/Wayland.png" alt=""  />
</p>
<p>时至今日，原本在X Server中做的事很多已被移到kernel或者单独的库中，因此X Server就显得比较累赘了。Wayland在架构上去掉了这个中间层，将compositor作为display server，使client与compositor直接通信，从而在灵活性和性能等方面上能够比前辈更加出色。</p>
<p>查看是否使用 wayland</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ echo $XDG_SESSION_TYPE
</code></pre></div><p><strong>Fedora、openSUSE 群讨论</strong></p>
<p>AppImage的制造者就是其中一个。主要反对的是Wayland声称自己取代X11，但在功能集合上二者完全不在一个层面，后者比前者强太多了。</p>
<p>而他反对红帽的东西主要是因为红帽一直就是Linux桌面领域比较强权的那个企业，比如早期PulseAudio，比如SystemD，早期多灾多难制造了很多麻烦。</p>
<p>推出一个新技术，在其不完善的前提下就想着取代旧技术，对于旧技术存在的但新技术不存在的功能却完全不考虑过渡方案，导致技术迭代的过程中用户就一次又一次地被抛弃。尤其和微软对比起来，微软在砍掉很重要的旧功能的时候会有完备的过渡方案，并且对于旧技术依然保持极长的支持周期。不过毕竟Windows 8那时候用户啥反应大家也不是不知道。</p>
<p>能理解，并且我有时候也会有同样的抱怨，刚学会一个新软件，结果过半年这个软件就被下一次更新抛弃了。AppImage的制造者可能是希望Linux桌面能学习一下微软的一些策略。</p>
<p>至于为什么反对Flatpak，因为Flatpak是红帽随同Wayland、Gnome一起强推的技术。</p>
<p>X11 为什么强?</p>
<p>远程应用，只把远程系统的一个应用程序在本机打开。X下面非常轻松，这就是X功能的一部分。微软的RDP也有同样的功能。并且渲染工作是在发起远程连接的那一段完成的。Wayland下面，没有，完全依赖窗口管理器自己提供的功能，而目前能做到的极限就是个VNC。</p>
<p>统一的图形库，Xlib，Windows下与之对应的是Win32的UI部分。所有X11的窗口管理器都提供稳定且统一的图形库。在Wayland下面，没有，只能给你push一堆像素点，这就意味着Wayland的应用程序的向下兼容性会比原先X的程序更差。</p>
<p>统一的窗口管理方式，也是X服务器的标准功能之一，在Windows下面我也不知道对标啥，但只要一个桌面环境用了X，那么应用程序就能确保自己使用一个标准的方法就能管理程序窗口，在Windows下也有同样的保障。Wayland下面，没有，完全依赖窗口管理器暴露的API或者无障碍API。</p>
<p>接上述，统一的自动化工具实现方式。Windows下面的AutoHotkey不知道多少人用过，在X11下面对应的软件是xdotool。在Wayland下面，没有。ydotool先不说它已经被半弃坑了，最主要的是ydotool调用uinput，只能输入不能获得窗口状态。</p>
<p>程序的可靠性。在X下面，桌面环境或者渲染器崩溃，应用程序依然健在。并且Windows也是如此的。Wayland下面就不是这么一回事了，至少对于Gnome来讲，shell崩溃就会连着所有程序全部崩溃。KDE的Kwin实现了自己的程序留活机制，但这样便从“所有X11桌面都支持”变成了“只有KDE支持”。</p>
<p>Wayland没有上述所有功能的原因很简单，Wayland不是软件、不是具体实现，它只是个标准，用来显示画面的标准。</p>
<p>是的，没错，这些本来确实应该交给窗口管理器和渲染器完成。但是，Wayland在不支持这些功能的前提下却表示自己是X11的替代品/延续发展，这就非常地有问题，因为Wayland并没有做到功能上的延续。</p>
<p>而且，Linux桌面下面的向下兼容性问题极度严重，我不想在这再重复一遍。桌面在用X11的时候，至少还能确保X的功能是一致的，无论跑在什么桌面组合上都不用担心兼容性问题，Wayland的出现，只会让原本离散的桌面更加离散。</p>
<p>wlroots被称作有希望统一Wayland渲染器的实现方式，可惜在此之前Gnome和KDE已经开始做自己的Wayland实现了，这就意味着从X11转向Wayland，至少分裂成了Gnome、KDE和wlroots，其它桌面会不会突然想不开自己做Wayland实现我们也不知道。而且，三家的分裂，难道还不够折磨吗？</p>
<p>看看Flameshot的Wayland支持，因为发现Gnome和KDE的运行表现不同，于是放弃了Portals API打算等待wlroots的标准，然而wlroots的标准和Gnome的不互通，于是它的支持计划被延期，无ETA。</p>
<p>再看看Barrier的Wayland支持，它fork的项目是symless的synergy，这是个商业开源软件。Ubuntu 17.04的时候曾经短暂切换到Wayland，那时候symless就计划开始适配Wayland，之后Ubuntu换回X11，于是Wayland适配计划就被放弃。当一部分软件只跟着一部分发行版走、而不考虑整个Linux桌面生态的时候，Linux桌面便从事实上消失了。接下来便只剩Ubuntu桌面、openSUSE桌面、Fedora桌面了，至少对于ISV来讲是这样的，因为不然的话指数级别的适配难度会把开发者累死。</p>
<p>我并不是在吹X11诋毁Wayland。只是指出现状。我知道这不是Wayland该做的事情，只是问题是：有谁能来做？</p>
<p>用户关心的是能不能用上对应的功能，Wayland之后功能少了，那用户就会把锅甩给Wayland。</p>
<p>这也是AppImage创造者一直反感Wayland的原因之一。</p>
<h3 id="为什么执行自己的程序要在前面加httpszhuanlanzhihucomp85833766"><a href="https://zhuanlan.zhihu.com/p/85833766">为什么执行自己的程序要在前面加./</a><a hidden class="anchor" aria-hidden="true" href="#为什么执行自己的程序要在前面加httpszhuanlanzhihucomp85833766">#</a></h3>
<p>shell是如何运行程序的：如果不给出相对路径，或者绝对路径，那么它会经历下面的查找过程。</p>
<ul>
<li>alias中查找</li>
<li>内置命令中查找</li>
<li>PATH中查找</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cd /temp
$ ./ls_bak
</code></pre></div><p>等同于</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ /temp/ls_bak
</code></pre></div><p>shell通常可以执行两种程序，一种是二进制程序，一种是脚本程序。如果是文本程序，且开头没有指定解释程序，则按照shell脚本处理，如果指定了解释程序，则使用解释程序来解释运行；对于二进制程序，则直接创建新的进程即可。</p>
<h3 id="ltshttpsaskubuntucomquestions16366whats-the-difference-between-a-long-term-support-release-and-a-normal-release"><a href="https://askubuntu.com/questions/16366/whats-the-difference-between-a-long-term-support-release-and-a-normal-release">LTS</a><a hidden class="anchor" aria-hidden="true" href="#ltshttpsaskubuntucomquestions16366whats-the-difference-between-a-long-term-support-release-and-a-normal-release">#</a></h3>
<p>There is a new release every 6 months (in April and October), with the version number being <em>year.month</em> (e.g.: 16.04 was released in April 2016). Every two years, the April release is a Long Term Support version.</p>
<p><strong>LTS releases</strong> are the ‘enterprise grade’ releases of Ubuntu and are used the most. An estimated <strong>95%</strong> of all Ubuntu installations are LTS releases.</p>
<p><strong>Interim releases</strong> (normal releases) will introduce new capabilities from Canonical and upstream open source projects, they serve as a proving ground for these new capabilities.</p>
<ul>
<li>All Interim releases (13.04 and later) are only supported for <strong>9 months</strong>.</li>
<li>All LTS releases (12.04 and later) are supported for five years (now is <strong>ten years</strong>) on both the desktop and the server.</li>
</ul>
<p>Now, support means:</p>
<ul>
<li>Updates for potential security problems and bugs (not new versions of software)</li>
<li>Availability of Commercial support contracts from Canonical</li>
<li>Support by Landscape, Canonical&rsquo;s enterprise oriented server management tool set</li>
</ul>
<p>Ubuntu releases additional versions of the last LTS between releases—such as <strong>14.04.1</strong>, that incorporate all of the updates up to this point. This is called a Point-Release (or sometimes <em>snapshot</em>). Those are released every quarter to half year, as needed.</p>
<p>The most important thing (for most people) is how long you get to use an install without having to do a release upgrade. A non-LTS version of Ubuntu only gets updates for 9 months from its release so to stay up-to-date —which is critically important— you need to upgrade twice a year; you need to upgrade through every Ubuntu version…</p>
<p>Conversely an Ubuntu LTS release is supported for 5 years and you can upgrade directly from LTS to LTS. This gives you long-lived, solid base to target and test on that makes it super-easy to release-upgrade when you decide to. It&rsquo;s therefore ideal for mass deployment, high-availability systems, and just people who don&rsquo;t like doing release-upgrades.</p>
<h3 id="设计shell脚本选项-getopthttpswwwcnblogscomf-ck-need-up9758075html"><a href="https://www.cnblogs.com/f-ck-need-u/p/9758075.html">设计shell脚本选项 getopt</a><a hidden class="anchor" aria-hidden="true" href="#设计shell脚本选项-getopthttpswwwcnblogscomf-ck-need-up9758075html">#</a></h3>
<p>写shell脚本的时候，通过while、case、shift来设计脚本的命令行选项是一件比较麻烦的事，因为Unix命令行的选项和参数自由度很高，支持短选项和长选项，参数可能是可选的，选项顺序可能是无所谓的，等等。</p>
<p>bash下的getopt命令可以解析命令行的选项和参数，<strong>将散乱、自由的命令行选项和参数进行改造，得到一个完整的、规范化的参数列表，这样再使用while、case和shift进行处理就简单的太多了</strong>。</p>
<p>getopt有不同的版本，本文介绍的是它的增强版(enhanced)，相比传统的getopt(也称为兼容版本的getopt)，它提供了引号保护的能力。另外，除了不同版本的getopt，bash还有一个内置命令getopts(注意，有个尾随的字符s)，也用来解析命令行选项，但只能解析短选项。</p>
<p>要验证安装的getopt是增强版的还是传统版的，使用<code>getopt -T</code>判断即可。如果它什么都不输出，则是增强版，此时它的退出状态码为4。如果输出&quot;&ndash;&quot;，则是传统版的getopt，此时它的退出状态码为0。如果想在脚本中进行版本检查，可以参考如下代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ getopt -T &amp;&gt;/dev/null;<span style="color:#f92672">[</span> $? -ne <span style="color:#ae81ff">4</span> <span style="color:#f92672">]</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">{</span> echo <span style="color:#e6db74">&#34;not enhanced version&#34;</span>;exit 1; <span style="color:#f92672">}</span>
</code></pre></div><p>&hellip;</p>
<h3 id="在中文介面下如何只用英文目錄名稱httpsaskfedoraprojectorgttopic11528"><a href="https://ask.fedoraproject.org/t/topic/11528">在中文介面下，如何只用英文目錄名稱？</a><a hidden class="anchor" aria-hidden="true" href="#在中文介面下如何只用英文目錄名稱httpsaskfedoraprojectorgttopic11528">#</a></h3>
<ul>
<li>先切到英文介面再重新開機，此時 Fedora 會問你要不要將子目錄換為英文名稱（選 Yes），再切回中文介面重新開機，Fedora 會再問你一次要不要更改子目錄為中文名稱（選 No），收工！</li>
<li>LANG=C xdg-user-dirs-gtk-update # 同意更新
xdg-user-dirs-gtk-update # 保留且不再問</li>
<li>手動修正配置文件~/.config/user-dirs.dirs ,然後在主目錄下創建對應目錄,重啟即可解決.</li>
</ul>
<h3 id="dd-制作u盘启动盘">dd 制作U盘启动盘<a hidden class="anchor" aria-hidden="true" href="#dd-制作u盘启动盘">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ dd bs<span style="color:#f92672">=</span>4M <span style="color:#66d9ef">if</span><span style="color:#f92672">=</span>fileName.iso of<span style="color:#f92672">=</span>/dev/sdx status<span style="color:#f92672">=</span>progress <span style="color:#f92672">&amp;&amp;</span> sync
</code></pre></div><p>Windows 下用 Rufus 且 dd 写入模式</p>
<h3 id="为什么-linux-要用-targz很少用-7z-或-ziphttpswwwzhihucomquestion335911358answer755424668"><a href="https://www.zhihu.com/question/335911358/answer/755424668">为什么 Linux 要用 tar.gz，很少用 7Z 或 ZIP？</a><a hidden class="anchor" aria-hidden="true" href="#为什么-linux-要用-targz很少用-7z-或-ziphttpswwwzhihucomquestion335911358answer755424668">#</a></h3>
<p>因为 7z 和 zip 压缩格式都不能保留 unix 风格的文件权限，比如解压出个可执行文件要重新 chmod chown 才能恢复正常。而 tar 格式可以。而 tar 本身不提供压缩，无非就是把包括所有文件的內容和权限拼成一个文件而己，所以用另外如 gzip 格式压缩。为什么是 gzip，因为几乎所有 linux 都支持而已。</p>
<h3 id="置默认编辑器httpswwwcnblogscomwswindp10164052html"><a href="https://www.cnblogs.com/wswind/p/10164052.html">置默认编辑器</a><a hidden class="anchor" aria-hidden="true" href="#置默认编辑器httpswwwcnblogscomwswindp10164052html">#</a></h3>
<p>visudo 等操作会打开默认编辑器，在linux中默认编辑器读取EDITOR环境变量，可通过一下命令设置</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">export EDITOR<span style="color:#f92672">=</span>nano
</code></pre></div><p>可将其加入~/.bashrc文件，使得每次登录都可使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ nano ~/.bashrc
export EDITOR<span style="color:#f92672">=</span>nano
$ . ~/.bashrc
</code></pre></div><p>debian系统提供了一个管理工具来设置默认编辑器</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo update-alternatives --config editor 
</code></pre></div><p>有两个相似选项</p>
<ul>
<li>/usr/bin/vim.basic</li>
<li>/usr/bin/vim.tiny</li>
</ul>
<p>它们的<a href="https://askubuntu.com/questions/483308/what-are-the-differences-between-vim-basic-and-vim-tiny">区别</a>：</p>
<p><strong>im.basic</strong> is just plain vanilla Vim (as you can check with <code>apt-file vim.basic</code> or <code>dpkg -S /usr/bin/vim.basic</code>).</p>
<p>While <strong>vim.tiny</strong>, as the name implies, is a <em>trimmed-down</em> version of Vim (<a href="https://askubuntu.com/q/104138/153234">this question</a> explains it further).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ vim.tiny --version
</code></pre></div><h3 id="通过linux系统进入-bios">通过Linux系统进入 BIOS<a hidden class="anchor" aria-hidden="true" href="#通过linux系统进入-bios">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo systemctl reboot --firmware-setup
</code></pre></div><h3 id="5-ways-to-check-cpu-info-in-linuxhttpslinuxhandbookcomcheck-cpu-info-linux"><a href="https://linuxhandbook.com/check-cpu-info-linux/">5 Ways to Check CPU Info in Linux</a><a hidden class="anchor" aria-hidden="true" href="#5-ways-to-check-cpu-info-in-linuxhttpslinuxhandbookcomcheck-cpu-info-linux">#</a></h3>
<ul>
<li>lscpu</li>
<li>/proc/cpuinfo</li>
<li>lshw</li>
<li>hwinfo</li>
<li>dmidecodes</li>
<li>hardinfo: gui</li>
</ul>
<h3 id="exfathttpwwwruanyifengcomblog201810exfathtmlhmsrtoutiaoioutm_mediumtoutiaoioutm_sourcetoutiaoio"><a href="http://www.ruanyifeng.com/blog/2018/10/exfat.html?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io">exFAT</a><a hidden class="anchor" aria-hidden="true" href="#exfathttpwwwruanyifengcomblog201810exfathtmlhmsrtoutiaoioutm_mediumtoutiaoioutm_sourcetoutiaoio">#</a></h3>
<p><strong>文件系统</strong></p>
<p>所谓文件系统，就是文件的储存方式。通过文件系统可以准确找到存储在硬盘中的数据。储存设备都需要指定文件系统，计算机才能读写。</p>
<p><strong>Windows 的文件系统</strong></p>
<ul>
<li>
<p>FAT32：是最老的文件系统，所有操作系统都支持，兼容性最好。但是，它是为 32 位计算机设计的，文件不能超过 2<sup>32</sup> - 1 个字节，也就是不能超过 4GB，分区不能超过 8TB。</p>
</li>
<li>
<p>NTFS：是 Windows 的默认文件系统，用来替换 FAT32。Linux 下有如下方法<a href="https://askubuntu.com/questions/934560/format-usb-drive-to-ntfs-so-it-is-usable-under-windows">创建 NTFS 文件系统</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># gparted</span>
$ sudo apt-get install gparted

<span style="color:#75715e"># mkntfs</span>
$ sudo apt-get install ntfs-3g
$ sudo mkntfs --fast --label myUsbDrive /dev/sdb1

<span style="color:#75715e"># mkfs</span>
$ mkfs.ntfs -f -L DiskLabel /dev/sdb1
</code></pre></div></li>
<li>
<p>exFAT：是 FAT32 的 64位升级版，ex 就是 extended 的缩写（表示&quot;扩展的 FAT32&quot;），功能不如 NTFS，但是解决了文件和分区的大小问题，两者最大都可以到 128PB。</p>
</li>
</ul>
<p><strong>Linux 的 exFAT 格式化</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo mkfs.exfat /dev/sdX1
</code></pre></div><p><strong>分区表</strong></p>
<p>所谓硬盘分区，就是指一块硬盘上面，同时存在多个文件系统。每个文件系统管理的区域，就称为一个分区（partition）。</p>
<p>分区大小、起始位置、结束位置、文件系统等信息，都储存在分区表里面。</p>
<p>分区表也分成两种格式：MBR 和 GPT。前者是传统格式，兼容性好；后者更现代，功能更强大。</p>
<h3 id="logging-in-as-root-in-ubuntu-with-live-cd">Logging in as Root in Ubuntu with Live CD<a hidden class="anchor" aria-hidden="true" href="#logging-in-as-root-in-ubuntu-with-live-cd">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo passwd root
</code></pre></div><h3 id="how-to-download-a-large-file-faster-from-google-drivehttpsyantraascomdownload-large-file-faster-from-google-drive"><a href="https://yantraas.com/download-large-file-faster-from-google-drive/">How To Download A Large File Faster From Google Drive?</a><a hidden class="anchor" aria-hidden="true" href="#how-to-download-a-large-file-faster-from-google-drivehttpsyantraascomdownload-large-file-faster-from-google-drive">#</a></h3>
<p><strong>Step 1: Fetching Your File ID</strong></p>
<ul>
<li>Open your browser and <a href="https://drive.google.com/">go to your google drive</a>, open login with the account that has the file you wish to download.</li>
<li>Locate the file that you wish to download and select it.</li>
<li>Right click the file and click on “get shareable link”</li>
<li>You don’t need to copy the entire link here; you only need the file ID that we will be using later.</li>
</ul>
<p>The link will look like this: <strong><a href="https://drive.google.com/file/d/XXXXX/view?usp=sharing">https://drive.google.com/file/d/XXXXX/view?usp=sharing</a></strong></p>
<p>In this link, you only need to pay attention to the <strong>alphanumeric file ID</strong>, displayed by XXXXX here.</p>
<p><strong>Step 2: Getting an OAuth Code</strong></p>
<ol>
<li>Visit <a href="https://developers.google.com/oauthplayground/">OAuth 2.0 Playground by clicking here</a>.</li>
<li>On the developer’s webpage, in the “<strong>Select &amp; authorize APIs</strong>” click on the “<strong>Drive API v3</strong>” option, and select the: <strong><a href="https://www.googleapis.com/auth/drive.readonly">https://www.googleapis.com/auth/drive.readonly</a></strong> option from the available options.</li>
<li>Once selected click <strong>Authorize APIs</strong> button on the bottom right corner of the tab.</li>
<li>After you click on the Authorize APIs button you will be transferred to the google account login screen.</li>
<li>Select the same google account in which you have your file stored.</li>
<li>Allow Google OAuth 2.0 to access your drive if asked.</li>
<li>When you get redirected back to the OAuth 2.0 playground screen click on the “<strong>Exchange Authorization Code for Tokens</strong>” button as shown.</li>
<li>Copy the newly generated <strong>Access Token</strong> and save it on your notepad. You will be needing this in the next step.</li>
</ol>
<p><strong>Step 3: Downloading The File Using A Command Line Script</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl -H <span style="color:#e6db74">&#34;Authorization: Bearer YYYYY&#34;</span> https://www.googleapis.com/drive/v3/files/XXXXX?alt<span style="color:#f92672">=</span>media -o ZZZZZ 
</code></pre></div><p>In your command, replace “XXXXX” with the file ID from above, “YYYYY” with the access token from above, and “ZZZZZ” with the file name that will be saved (for example, “myFile.mp4” if you’re downloading an mp4 file).</p>
<p>Press Enter and let the download begin.</p>
<h3 id="usb插槽鬆動怎麼辦httpswwwyoutubecomwatchvwud4i6gzcpk"><a href="https://www.youtube.com/watch?v=WUd4I6GZcpk">USB插槽鬆動怎麼辦</a><a hidden class="anchor" aria-hidden="true" href="#usb插槽鬆動怎麼辦httpswwwyoutubecomwatchvwud4i6gzcpk">#</a></h3>
<ol>
<li>手机</li>
</ol>
<p><img loading="lazy" src="Distributions/image-20211031094951544.png" alt="image-20211031094951544"  />
</p>
<ol start="2">
<li>充电宝</li>
</ol>
<p><img loading="lazy" src="Distributions/image-20211031095019000.png" alt="image-20211031095019000"  />
</p>
<ol start="3">
<li>笔记本</li>
</ol>
<p><img loading="lazy" src="Distributions/image-20211031095137351.png" alt="image-20211031095137351"  />
</p>
<ol start="4">
<li>笔记本</li>
</ol>
<p><img loading="lazy" src="Distributions/image-20211031095211881.png" alt="image-20211031095211881"  />
</p>
<h3 id="nmcheckgnomeorghttpsaskubuntucomquestions1070823some-suspicious-software-making-request-to-nmcheck-gnome-org"><a href="https://askubuntu.com/questions/1070823/some-suspicious-software-making-request-to-nmcheck-gnome-org">nmcheck.gnome.org</a><a hidden class="anchor" aria-hidden="true" href="#nmcheckgnomeorghttpsaskubuntucomquestions1070823some-suspicious-software-making-request-to-nmcheck-gnome-org">#</a></h3>
<p><a href="http://nmcheck.gnome.org/">nmcheck.gnome.org</a> is not malware. It is the gnome network manager connectivity check (for captive portals/hotspots). Click the link and you will see a single text file with a text in it. It should be &ldquo;NetworkManager is online&rdquo;.</p>
<p>Check <code>/etc/NetworkManager/NetworkManager.conf</code>. There probably is a section with this in it:</p>
<pre tabindex="0"><code>[Connectivity] 
uri=http://nmcheck.gnome.org/check_network_status.txt
</code></pre><p>on Ubuntu 20.04 no <code>[Connectivity] </code> line like accepted answer in <code>/etc/NetworkManager/NetworkManager.conf</code>.</p>
<p>But you can disable the auto connectivity check by:</p>
<ol>
<li>Go to <code>Settings</code> app</li>
<li>Go to <code>Privacy</code> menu</li>
<li>On <code>Connectivity</code> tab, uncheck <code>Connectivity Checking</code></li>
</ol>
<h3 id="xdg_templates_dirhttpsaskubuntucomquestions94734what-is-the-templates-folder-in-the-home-directory-for"><a href="https://askubuntu.com/questions/94734/what-is-the-templates-folder-in-the-home-directory-for">XDG_TEMPLATES_DIR</a><a hidden class="anchor" aria-hidden="true" href="#xdg_templates_dirhttpsaskubuntucomquestions94734what-is-the-templates-folder-in-the-home-directory-for">#</a></h3>
<p>If you drop any files in &ldquo;Templates&rdquo; folder. Then when you right-click and create a new document, you can select any of these files as a basis for the new file.</p>
<p>If you have deleted the folder and need to restore this functionality:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ gedit ~/.config/user-dirs.dirs
</code></pre></div><p>Check that there is a line containing the following - if not, add this line.</p>
<pre tabindex="0"><code>XDG_TEMPLATES_DIR=&quot;$HOME/Templates&quot;
</code></pre><h3 id="软件的稳定性httpswwwzhihucomquestion301581684answer547761587"><a href="https://www.zhihu.com/question/301581684/answer/547761587">软件的稳定性</a><a hidden class="anchor" aria-hidden="true" href="#软件的稳定性httpswwwzhihucomquestion301581684answer547761587">#</a></h3>
<p>软件的稳定性其实往往来源于：足够多的使用者与足够多的反馈跟改进。</p>
<p>Linux系统，在服务器端的大多数常用软件都有足够多的使用者，所以就足够稳定，由于它在服务器端市场占有率远高于微软，所以服务器端就是比微软稳定，很正常的事。</p>
<p>在桌面端，市场占用率远低于微软，不稳定也是自然的。</p>
<p>为什么Linux下命令行程序往往又好用又稳定？是因为用户喜欢装逼吗？不是，因为命令行程序是服务器端跟桌面端通用的，而服务器端程序经过了足够多用户的使用，经过了足够的反馈开发迭代，所以稳定。而图形界面只有桌面用户用，桌面占有率那么低，这些程序往往缺乏足够的测试人力也缺乏足够的开发维护人力，所以并不会非常稳定。</p>
<p>那么，你要想体验Linux稳定，怎么办？答案就是只使用市场占有率高，用户量大，因而获得了充分测试的软件，这就稳定了。比方说只使用服务器端。或者桌面端只使用最常用的那些，例如终端仿真器，浏览器，输入法，gcc编译器之类，肯定是稳定的。</p>
<p>你看我就用浏览器，输入法，xterm，screen，编程ide，vim，以及一堆命令行的东西，稳定得很啊，六个月才重启一次电脑，重启的那一次还是因为ubuntu升级。</p>
<h3 id="如何将google搜索限制为特定语言的结果httpsqastackcnwebapps16047how-to-restrict-a-google-search-to-results-of-a-specific-language"><a href="https://qastack.cn/webapps/16047/how-to-restrict-a-google-search-to-results-of-a-specific-language">如何将Google搜索限制为特定语言的结果</a><a hidden class="anchor" aria-hidden="true" href="#如何将google搜索限制为特定语言的结果httpsqastackcnwebapps16047how-to-restrict-a-google-search-to-results-of-a-specific-language">#</a></h3>
<p>只是想在Google搜索中添加有关语言参数的更全面的答案。</p>
<p>有4种与语言相关的选项。</p>
<p><strong>Web界面语言： <code>hl=</code></strong></p>
<p>例： <code>www.google.com/search?q=vilnius&amp;hl=lt</code></p>
<pre tabindex="0"><code>Web Interface Language Codes

hl=zh-CN       Chinese (Simplified)
hl=zh-TW       Chinese (Traditional)
hl=en          English
hl=ja          Japanese
</code></pre><p><strong>指定语言的页面： <code>lr=lang_</code></strong></p>
<p>例： <code>www.google.com/search?q=vilnius&amp;lr=lang_lt</code></p>
<pre tabindex="0"><code>Search Language Codes

lr=lang_zh-CN Chinese (Simplified)
lr=lang_zh-TW Chinese (Traditional)
lr=lang_en    English
lr=lang_ja    Japanese
</code></pre><p><strong>来自指定国家/地区的页面： <code>cr=country</code></strong></p>
<p>示例：<code>www.google.com/search?q=vilnius&amp;cr=countryLT</code>
<strong>请注意</strong>，两个国家/地区代码字符必须大写！否则，Google会忽略该参数（自2017年1月3日起）（即使小写字母对于<code>hl=</code>和都适用<code>lr=lang_</code>）。</p>
<p>还有另一个参数&ndash; <code>gl=</code>用于搜索结果，因为它们将显示在指定的国家/地区。我尝试对其进行测试，但对我而言，不同参数值的结果没有不同。浏览器或我的Google帐户的某些其他参数/设置可能已过时或覆盖了该设置。</p>
<h3 id="two-options-to-recover-your-pc-with-androidhttpswwwmakeuseofcomtagrecover-pc-using-android"><a href="https://www.makeuseof.com/tag/recover-pc-using-android/">Two Options to Recover Your PC With Android</a><a hidden class="anchor" aria-hidden="true" href="#two-options-to-recover-your-pc-with-androidhttpswwwmakeuseofcomtagrecover-pc-using-android">#</a></h3>
<p>If your PC is out of action, you can install a new operating system or run a recovery environment thanks to Android. Two solid options are available:</p>
<ul>
<li><a href="https://play.google.com/store/apps/details?id=com.mixapplications.iso2usb&amp;hl=zh&amp;gl=US">ISO 2 USB</a>: Lets you burn an ISO file directly to a USB flash drive over USB-OTG.</li>
<li><a href="https://play.google.com/store/apps/details?id=com.softwarebakery.drivedroid&amp;hl=zh&amp;gl=US">DriveDroid</a>: Enables you to store bootable ISO files on Android. With the paid version, support for Windows 10 installation images is added.</li>
</ul>
<h3 id="good-practice-to-avoid-using-sudo-suhttpsaskubuntucomquestions962021is-it-considered-good-practice-to-avoid-using-sudo-su"><a href="https://askubuntu.com/questions/962021/is-it-considered-good-practice-to-avoid-using-sudo-su">good practice to avoid using <code>sudo su</code></a><a hidden class="anchor" aria-hidden="true" href="#good-practice-to-avoid-using-sudo-suhttpsaskubuntucomquestions962021is-it-considered-good-practice-to-avoid-using-sudo-su">#</a></h3>
<p><strong>It is <a href="https://en.wikipedia.org/wiki/Principle_of_least_privilege">good practice</a> to avoid performing more actions as root than you need to.</strong> <code>sudo</code> facilitates this by allowing you to run individual commands as root <a href="https://askubuntu.com/a/617767/22949">without having to log in as root</a> and without <em>needing</em> an interactive root shell for tasks you would otherwise not run a shell to do. But <code>sudo su</code> is not a &ldquo;<a href="https://en.wikipedia.org/wiki/Backdoor_(computing)">backdoor</a>,&rdquo; it is simply a somewhat less elegant way to do what <code>sudo</code> is designed to allow you to do with <code>sudo -s</code>. <a href="https://www.sudo.ws/pipermail/sudo-users/2012-April/004960.html">Similarly</a>, <code>sudo -i</code> is the more elegant way to achieve what <code>sudo su -</code> would get you: a simulated <em>initial login shell</em> whose environment is like what you would get if you could log in as root on the command line. See <a href="http://manpages.ubuntu.com/manpages/xenial/en/man8/sudo.8.html"><code>man sudo</code></a>.</p>
<h3 id="sshfs-how-to-mount-remote-file-systems-over-sshhttpsphoenixnapcomkbsshfs"><a href="https://phoenixnap.com/kb/sshfs">SSHFS: How to Mount Remote File Systems Over SSH</a><a hidden class="anchor" aria-hidden="true" href="#sshfs-how-to-mount-remote-file-systems-over-sshhttpsphoenixnapcomkbsshfs">#</a></h3>
<p><strong>SSHFS</strong> (SSH File System) is a client for mounting a file system located on a remote machine onto your local system through an <a href="https://phoenixnap.com/kb/how-does-ssh-work">SSH connection</a>. Using the SFTP (SSH file transfer protocol), the SSHFS command-line tool mounts a physical or virtual disk locally, allowing file transfer between a local and remote machine.</p>
<p><strong>This article demonstrates the installation and usage of SSHFS to mount a remote folder or file system over SSH.</strong></p>
<h4 id="install-sshfs">Install SSHFS<a hidden class="anchor" aria-hidden="true" href="#install-sshfs">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install sshfs
</code></pre></div><h4 id="mount-a-remote-file-system-on-linux">Mount a Remote File System on Linux<a hidden class="anchor" aria-hidden="true" href="#mount-a-remote-file-system-on-linux">#</a></h4>
<p><strong>Step 1: Create Mount Point</strong></p>
<p>Create a mount point directory in the <em>mnt</em> folder where the remote file system will be mounted:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo mkdir /mnt/&lt;folder name&gt;
</code></pre></div><p><strong>Step 2: Mount the Remote File System Using SSHFS</strong></p>
<p>Mount the remote file system to the created mount point using the SSHFS tool:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo sshfs <span style="color:#f92672">[</span>-o &lt;options&gt;<span style="color:#f92672">]</span> &lt;remote user&gt;@&lt;remote host&gt;:/&lt;path to remote directory&gt; /mnt/&lt;folder name&gt;/
</code></pre></div><p>Enter the login password when requested if using password authentication. If the remote server uses SSH key authorization, provide the path of the private key. For example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo sshfs -o allow_other,IdentityFile<span style="color:#f92672">=</span>/home/kb/.ssh/id_rsa ubuntu@131.153.142.254:/home/ubuntu/ /mnt/test/
</code></pre></div><p>The <strong><code>allow_other</code></strong> option allows access to users other than root.</p>
<p><strong>Step 3: Unmount a Remote File System on Linux</strong></p>
<p>Lastly, when finished with the mount point, unmount the remote file system with:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo umount /mnt/&lt;folder name&gt;
</code></pre></div><h3 id="img转化成isohttpsos51ctocomarticle290012html"><a href="https://os.51cto.com/article/290012.html">img转化成iso</a><a hidden class="anchor" aria-hidden="true" href="#img转化成isohttpsos51ctocomarticle290012html">#</a></h3>
<p><a href="https://zh.wikipedia.org/wiki/IMG%E6%A0%BC%E5%BC%8F">IMG</a>是一种文件归档格式（archive format），主要是为了创建磁盘的映像文件（disk image），它可以用来封装存储整个磁盘（通常指软磁盘，Floppy Disk或Diskette）或整片光盘的内容，使用&quot;.IMG&quot;这个扩展名的文件就是利用这种文件格式来创建的。</p>
<p>.IMG这个文件格式可视为.ISO格式的一种超集合。由于.ISO只能封存使用ISO9660和UDF这两种文件系统的存储介质，意即.ISO只能拿来封存CD或DVD，因此才发展出了.IMG，它是以.ISO格式为基础另外新增可封存使用其它文件系统的存储介质的能力，.IMG可向后兼容于.ISO，如果是拿来封存CD或DVD，则使用.IMG和.ISO这两种格式所产生出来的内容是一样的。</p>
<p>将img 转化成iso的有 nrg2iso 或 ccd2iso，分别下载如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt-get install nrg2iso
$ sudo apt-get install ccd2iso
</code></pre></div><p>使用如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ nrg2iso image.nrg image.iso  
$ ccd2iso &lt;.img filename&gt; &lt;.iso filename&gt; 
</code></pre></div><h3 id="hwehttpswikiubuntucomkernelltsenablementstack"><a href="https://wiki.ubuntu.com/Kernel/LTSEnablementStack">HWE</a><a hidden class="anchor" aria-hidden="true" href="#hwehttpswikiubuntucomkernelltsenablementstack">#</a></h3>
<p>The Ubuntu LTS enablement (also called HWE or Hardware Enablement) stacks provide newer kernel and X support for existing Ubuntu LTS releases.</p>
<p>The 20.04 LTS HWE Stacks continue to follow <a href="https://ubuntu.com/about/release-cycle#ubuntu-kernel-release-cycle">Rolling Update Model</a>, as has been in use since 16.04 LTS.</p>
<h3 id="microcodehttpsdecodezpgithubio20200712quickwords44-microcode"><a href="https://decodezp.github.io/2020/07/12/quickwords44-microcode/">Microcode</a><a hidden class="anchor" aria-hidden="true" href="#microcodehttpsdecodezpgithubio20200712quickwords44-microcode">#</a></h3>
<p><img loading="lazy" src="/Distributions/processor.png" alt=""  />
</p>
<p>每当听到有人说“这个问题更新一下微码就好了”，就觉得这个哥哥怎么这么迷人，好像在哪里见过。为了也让自己变成这种迷人的哥哥，我也研究了一下到底什么是微码。</p>
<p>这里说的是跑在CPU处理器上的微码，不是IBM那群人嘴里说的那个微码。如果你之前没和IBM打过交道那就当这段话不存在。</p>
<p>计算机体系结构是一层又一层的抽象，典型的比如操作系统对底层硬件的抽象。但鲜有人知的是，操作系统和底层硬件，尤其是CPU之间还存在着几层抽象。什么叫抽象，当然有很多种学术流的解释，但我土气一点的解释就是“不关心”，就是“Don’t care”，就是爱咋地咋地。</p>
<p>用这个模式套用一下我们熟悉的抽象：操作系统要将数据写入磁盘，它不关心怎么操作磁盘；应用要给某个服务器发个数据包，它也不关心怎么操作网卡。</p>
<p>回到我们的微码上来。我们现在常见的操作系统都是用C语言编写，它相对于汇编语言来说，也算是一种“高级语言”。编译器会将这种高级语言编译成汇编语言。只要C语言编写时“不关心”汇编指令是啥，那么就是相对汇编语言做了一次抽象。</p>
<p>马上就到微码了。我们知道汇编指令是执行在CPU上的，那么汇编指令会关心在某个具体型号的CPU上是怎么执行的吗？肯定不会的。汇编的一条ADD指令在80286上可以执行，在最新的Icelake上也能执行，但这两个CPU内部早已发生了天翻地覆的变化，执行ADD的操作已经完全不同了。</p>
<p>换句话说，就是汇编指令并“不关心”是如何在CPU上执行的。</p>
<p>操作系统不关心如何操作磁盘和网卡，是因为这些都有对应的设备驱动操心。汇编指令不关心具体如何在CPU中执行，这个就是由微码来操心了。所以用类比的方式，可以把微码类比成汇编指令针对某一型号CPU的驱动。</p>
<p>同样的汇编指令，会由该型号CPU的微码转成可以跑在该CPU上的微操作（Micro-ops/uops）。这些微操作指导CPU的电路完成汇编指令要求的意图。</p>
<p>在大家还在编写汇编语言代码的时代，微码为汇编语言的编写提供了方便：</p>
<ul>
<li>只关心汇编逻辑，而不用关心CPU内部电路设计和具体的执行方式</li>
<li>方便设计出新的汇编指令，由微码翻译成具体的执行逻辑，比如循环中“变量自减若大于零则转跳”，可以用一条汇编指令代替，脏活累活都交给微码去干</li>
<li>修复或绕过一些很难修复的处理器数字电路中的Bug</li>
</ul>
<p>上述第二点也为CISC指令集的实现提供了技术基础。因为不可能所有复杂的指令都是由专门的执行复杂指令的硬件来完成的，也是由简单的数字逻辑模块组合而成的。</p>
<p>在现代CPU里，是存在专门的将汇编指令翻译成微操作的硬件解码器的。但微码依旧存在（就是CPU微架构图中前端那个Microcode sequencer），它作为一个Lookup Table保存在一块ROM中，用来解码复杂的指令，比如浮点运算的指令等。一般是硬件解码器解码得比较快，而用微码解码会比较慢。</p>
<p>理论上，如果你能更改某一个处理器的微码，那么经它翻译的指令可以变成任意其他的指令。因为它关心指令如何在CPU电路中执行。所以现在升级微码主要是用来解决处理器的稳定和安全性的问题。</p>
<p>当然你也可以用它模拟自己没有的汇编指令，比如AVX系列，我只要在看到AVX512的汇编之后，把它翻译成两个“SIMD256”或者四个“SIMD128”指令就好了。</p>
<p>看到这里，你给自己就又加了一层微码的buff。最后贴心地推荐一篇详细说明Microcode怎么执行的文章：<a href="https://www.informatimago.com/articles/microcode/microcode.html">Microprocessor Microcode Simple Example</a></p>
<h4 id="安装更新微码httpslinuxcnarticle-9411-1html"><a href="https://linux.cn/article-9411-1.html">安装/更新微码</a><a hidden class="anchor" aria-hidden="true" href="#安装更新微码httpslinuxcnarticle-9411-1html">#</a></h4>
<p>微码就是由 Intel/AMD 提供的 CPU 固件。Linux  的内核可以在引导时更新 CPU 固件，而无需 BIOS 更新。处理器的微码保存在内存中，在每次启动系统时，内核可以更新这个微码。这些来自  Intel/AMD 的微码的更新可以去修复 bug 或者使用补丁来防范 bug。</p>
<p>查看当前的微码状态：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo dmesg | grep microcode
</code></pre></div><p><strong>使用包管理器</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install intel-microcode
</code></pre></div><p>必须重启以激活微码更新：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo reboot
</code></pre></div><p><strong>手动</strong></p>
<p>只有在你的 CPU 制造商建议这么做的时候，才可以使用下列的方法去更新/安装微码，除此之外，都应该使用上面的方法去更新。大多数 Linux 发行版都可以通过包管理器来维护、更新微码。使用包管理器的方法是经过测试的，对大多数用户来说是最安全的方式。</p>
<h3 id="automatic-light--dark-modehttpsaskubuntucomquestions1234742automatic-light-dark-mode"><a href="https://askubuntu.com/questions/1234742/automatic-light-dark-mode">Automatic Light / Dark Mode</a><a hidden class="anchor" aria-hidden="true" href="#automatic-light--dark-modehttpsaskubuntucomquestions1234742automatic-light-dark-mode">#</a></h3>
<p>for GNOME, this shell extension exists: <a href="https://extensions.gnome.org/extension/2236/night-theme-switcher/">Night Theme Switcher</a></p>
<h3 id="将du的输出按文件大小排序httpsbloglilydjwgmeposts18368html"><a href="https://blog.lilydjwg.me/posts/18368.html">将du的输出按文件大小排序</a><a hidden class="anchor" aria-hidden="true" href="#将du的输出按文件大小排序httpsbloglilydjwgmeposts18368html">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">sdu <span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
  du -sk $@ | sort -n | awk <span style="color:#e6db74">&#39;
</span><span style="color:#e6db74">BEGIN {
</span><span style="color:#e6db74">  split(&#34;K,M,G,T&#34;, Units, &#34;,&#34;);
</span><span style="color:#e6db74">  FS=&#34;\t&#34;;
</span><span style="color:#e6db74">  OFS=&#34;\t&#34;;
</span><span style="color:#e6db74">}
</span><span style="color:#e6db74">{
</span><span style="color:#e6db74">  u = 1;
</span><span style="color:#e6db74">  while ($1 &gt;= 1024) {
</span><span style="color:#e6db74">    $1 = $1 / 1024;
</span><span style="color:#e6db74">    u += 1
</span><span style="color:#e6db74">  }
</span><span style="color:#e6db74">  $1 = sprintf(&#34;%.1f%s&#34;, $1, Units[u]);
</span><span style="color:#e6db74">  sub(/\.0/, &#34;&#34;, $1);
</span><span style="color:#e6db74">  print $0;
</span><span style="color:#e6db74">}&#39;</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="改善触摸板体验httpsplumzmearchives12343"><a href="https://plumz.me/archives/12343/">改善触摸板体验</a><a hidden class="anchor" aria-hidden="true" href="#改善触摸板体验httpsplumzmearchives12343">#</a></h3>
<p>众所周知，Macbook 的触摸板是体验最好的，很多果粉都吹 Macbook 的触摸板用了之后“就不再想要去用鼠标”。</p>
<p>有一群人搞了一个项目：「Linux Touchpad like Macbook Update」。顾名思义，就是“把 Linux 的触摸板搞的像 Macbook 一样”。</p>
<p>这个项目的主要作用就是针对现在 Linux 下对于触摸板管理的相关驱动进行一些修改和优化，以提升触摸的使用体验，尤其是包括“多点触摸”等等等。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo add-apt-repository ppa:p12/xorg-gestures
$ sudo apt-get update
</code></pre></div><p>当然，尽管如此，我们也只是在驱动层面改善了触摸，在应用层面还需要另一个工具的帮忙：<a href="https://github.com/JoseExposito/touchegg">touchegg</a></p>
<p>安装完毕之后你的三指上滑和三指下滑都可以正常使用了，譬如三指上滑是窗口最大化，三指下滑是窗口最小化。</p>
<h3 id="reset-lost-root-passwordhttpswikiarchlinuxorgtitlereset_lost_root_password_e7ae80e4bd93e4b8ade69687"><a href="https://wiki.archlinux.org/title/Reset_lost_root_password_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Reset lost root password</a><a hidden class="anchor" aria-hidden="true" href="#reset-lost-root-passwordhttpswikiarchlinuxorgtitlereset_lost_root_password_e7ae80e4bd93e4b8ade69687">#</a></h3>
<p><strong>警告：</strong> 攻击者都可以使用上述方法修改系统，要保证系统安全，请限制物理上的访问，或者使用全<a href="https://wiki.archlinux.org/title/Data-at-rest_encryption">磁盘加密</a>。</p>
<h4 id="使用-livecd">使用 LiveCD<a hidden class="anchor" aria-hidden="true" href="#使用-livecd">#</a></h4>
<p>通过 LiveCD 可以使用好几种方法：chroot并且使用<code>passwd</code>命令或者擦除密码域条目。任何Linux的LiveCD都可以使用，chroot时它必须匹配已经安装的架构类型。这里仅介绍 chroot 方式，因为这个方法更不容易出错。</p>
<ol>
<li>
<p>启动LiveCD，挂载根文件系统.</p>
</li>
<li>
<p>然后通过下列命令重置密码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ passwd --root MOUNT_POINT USER_NAME
</code></pre></div></li>
<li>
<p>卸载根文件系统。</p>
</li>
<li>
<p>重启，记下你的密码。</p>
</li>
</ol>
<h4 id="用-bash-作为-init">用 Bash 作为 Init<a hidden class="anchor" aria-hidden="true" href="#用-bash-作为-init">#</a></h4>
<ol>
<li>
<p>将 <code>init=/bin/bash</code> <a href="https://wiki.archlinux.org/title/Kernel_parameter">内核参数</a>加入启动加载器的启动项.</p>
</li>
<li>
<p>启动后可以看到 Bash 提示符。</p>
</li>
<li>
<p>根文件系统应该是只读挂载，需要以可读写模式重新挂载：</p>
<pre tabindex="0"><code>mount -n -o remount,rw /
</code></pre></li>
<li>
<p>用 passwd 创建新的管理员密码。</p>
</li>
<li>
<p>通过 <code>reboot -f</code> 重启，不要再次忘记你的密码。</p>
</li>
</ol>
<p><strong>注意：</strong> 使用此法时有的键盘不能被初始系统正确加载，你可能不能在bash提示符后输入任何东西。如果出现这种情况，你不得不使用其他方法。</p>
<h3 id="how-to-block-internet-access-to-certain-programs-on-linuxhttpsserverfaultcomquestions550276how-to-block-internet-access-to-certain-programs-on-linux"><a href="https://serverfault.com/questions/550276/how-to-block-internet-access-to-certain-programs-on-linux">How to block internet access to certain programs on Linux</a><a hidden class="anchor" aria-hidden="true" href="#how-to-block-internet-access-to-certain-programs-on-linuxhttpsserverfaultcomquestions550276how-to-block-internet-access-to-certain-programs-on-linux">#</a></h3>
<p>The solution for me happened to be straight forward.</p>
<ol>
<li>
<p>Create, validate new group; add required users to this group:</p>
<ul>
<li>
<p>Create: <code>groupadd no-internet</code></p>
</li>
<li>
<p>Validate: <code>grep no-internet /etc/group</code></p>
</li>
<li>
<p>Add user: <code>useradd -g no-internet username</code></p>
<p><em>Note: If you&rsquo;re modifying already existing user you should run: <code>usermod -a -G no-internet userName</code> check with : <code>sudo groups userName</code></em></p>
</li>
</ul>
</li>
<li>
<p>Create a <em>script</em> in your path and make it executable:</p>
<ul>
<li>
<p>Create: <code>nano /home/username/.local/bin/no-internet</code></p>
</li>
<li>
<p>Executable: <code>chmod 755 /home/username/.local/bin/no-internet</code></p>
</li>
<li>
<p>Content:</p>
<pre tabindex="0"><code>#!/bin/bash
sg no-internet &quot;$@&quot;
</code></pre></li>
</ul>
</li>
<li>
<p>Add <em>iptables rule</em> for dropping network activity for group <em>no-internet</em>:</p>
<ul>
<li>
<p><code>iptables -I OUTPUT 1 -m owner --gid-owner no-internet -j DROP</code></p>
<p><em>Note: Don&rsquo;t forget to make the changes permanent, so it would be <a href="https://unix.stackexchange.com/questions/38019/execute-a-script-as-root-at-boot-on-fedora-15-16">applied automatically after reboot</a>. Doing it, depends on your Linux distribution.</em></p>
</li>
</ul>
</li>
<li>
<p>Check it, for example on Firefox by running: <code>no-internet &quot;firefox&quot;</code></p>
</li>
</ol>
<p>In case you would want to make an exception and allow a program to access <em>local network</em>:</p>
<ul>
<li><code>iptables -A OUTPUT -m owner --gid-owner no-internet -d 192.168.1.0/24 -j ACCEPT</code></li>
<li><code>iptables -A OUTPUT -m owner --gid-owner no-internet -d 127.0.0.0/8 -j ACCEPT</code></li>
<li><code>iptables -A OUTPUT -m owner --gid-owner no-internet -j DROP</code></li>
</ul>
<p><em>NOTE:</em> In case of spawning the rules will be maintained. For example, if you run a program with <em>no-internet</em> rule and that program will open browser window, still the rules will be applied.</p>
<h3 id="how-does-ubuntu-make-moneyhttpsaskubuntucomquestions21730how-does-ubuntu-make-money"><a href="https://askubuntu.com/questions/21730/how-does-ubuntu-make-money">How does Ubuntu make money?</a><a hidden class="anchor" aria-hidden="true" href="#how-does-ubuntu-make-moneyhttpsaskubuntucomquestions21730how-does-ubuntu-make-money">#</a></h3>
<p>Firstly a lot of people work on Ubuntu in their free time (many of them programming, but also those of here for instance answering people&rsquo;s questions). Also some people <a href="http://www.ubuntu.com/community/get-involved/donate">donate to Ubuntu</a>.</p>
<p>However there is more to the story. <a href="http://en.wikipedia.org/wiki/Canonical_Ltd">Canonical Ltd</a>. is a private company that created and continues to pay for Ubuntu. We know Canonical hadn&rsquo;t been making a profit, but Canonical was initially founded by multi-millionaire <a href="http://en.wikipedia.org/wiki/Mark_Shuttleworth">Mark Shuttleworth</a> which meant it didn&rsquo;t have to focus on making money right away.</p>
<p>However Canonical is now looking towards to making Ubuntu profitable. (After all, they have 600+ employees to pay every month!) There are <a href="http://www.nytimes.com/2009/01/11/business/11ubuntu.html?pagewanted=3&amp;_r=2">some indications</a> this has been successful. Their key revenue streams offer services around Ubuntu:</p>
<ul>
<li>Support services (mostly to business) alongside which they sell <a href="https://landscape.canonical.com/">Landscape</a></li>
<li>Contracting services to businesses (for instance working with OEMs such as Dell, or <a href="http://blog.canonical.com/?p=294">helping Google with Chrome OS</a>). As Ubuntu makes its way onto mobile phones and TVs then this will grow.</li>
<li>Ubuntu Software Centre&rsquo;s paid section (Canonical takes a cut of purchases)</li>
<li>The <a href="http://shop.canonical.com/">Canonical Store</a> (selling physical Ubuntu branded items) - discontinued</li>
<li>Closed-source projects wishing to use Launchpad.net <a href="https://answers.edge.launchpad.net/launchpad/+faq/208">can purchase a license</a></li>
<li><a href="https://one.ubuntu.com/">Ubuntu One</a> (online file storage and synchronization service) and Music Store (selling music from within Ubuntu) - discontinued.</li>
<li>Amazon referrals. When you search the Ubuntu Dash, you may see Amazon products (unless you have turned it off). Ubuntu takes a cut of these.[<a href="https://arstechnica.com/information-technology/2012/09/ubuntu-bakes-amazon-search-results-into-os-to-raise-cash/">ref]</a></li>
</ul>
<p>All of these are areas that Canonical hopes will grow.</p>
<h3 id="启用-trimhttpslinuxcnarticle-8177-1html"><a href="https://linux.cn/article-8177-1.html">启用 TRIM</a><a hidden class="anchor" aria-hidden="true" href="#启用-trimhttpslinuxcnarticle-8177-1html">#</a></h3>
<p>当我在运行 Linux 的计算机上安装我的第一块固态驱动器（SSD）后，我开始探索如何用好它们。SSD 在操作方式上与传统磁性驱动器不同，并且它们需要在软件上另行处理以达到功能优化。</p>
<p>在传统磁盘驱动器上，删除时所删除的文件不会从磁盘中完全删除。这就是为什么你可以恢复已删除的文件的原因。基本上，文件系统仅引用磁盘上文件的位置，并且当文件被删除时，该引用被擦除，以允许你在这些空间中写入新数据覆盖原来的数据。然而，对于 SSD，新数据只能写在驱动器上完全新的或已擦除的单元上。因为必须在写入之前清除空间，如果在写入文件时尚未有足够的可用空间，则必须首先擦除该空间。这可能会对性能产生负面影响。</p>
<p>如果操作系统在写入新数据之前就擦除了未使用的空间，而不是在写入时同时进行擦除，则可以提高文件保存性能。这种做法就是 <a href="https://en.wikipedia.org/wiki/Trim_(computing)">TRIM</a>。 TRIM 命令本质上允许你的操作系统告诉驱动器哪些区域的数据不再使用，以便擦除它们，加快驱动器将来的写入，可以 SSD 的用户提供更佳的体验。</p>
<p>在 Linux 中，<code>fstrim</code> 提供此功能，它可以为写入新数据而准备驱动器，并延长驱动器的使用寿命。由于在我使用的 Linux 发行版上 SSD 的 trim 不是自动的，所以必须去调度该操作，否则 SSD 的性能会随着时间的推移而降低。</p>
<p>为了在驱动器上运行 <code>fstrim</code>，驱动器本身以及其上的文件系统必须支持 TRIM。TRIM SSD 可以在命令行或 cron 任务中手动完成。作为超级用户（使用 <code>su</code> 或 <code>sudo</code>），运行 <code>fstrim / -v</code> 以完成手动 trim，或者设置 cron 任务以在计算机未使用时定期为你运行此命令。对于 <code>fstrim</code> 的完整选项列表请参考它的 <a href="http://man7.org/linux/man-pages/man8/fstrim.8.html">man 手册</a>。</p>
<p>注：可以定期执行fstrim命令，但是不建议在mount / fstab 中使用discard 选项。因为这个选项要求SSD每次删除文件都进行trim操作，比较耗资源，尤其是在文件操作很频繁的时候。所以可以考虑用cron来定期trim。</p>
<p>硬件支持根据使用的驱动器接口类型如 PCI、<a href="https://en.wikipedia.org/wiki/Trim_(computing)#ATA">ATA</a>、<a href="https://en.wikipedia.org/wiki/Trim_(computing)#SCSI">SCSI</a> 还是 <a href="https://en.wikipedia.org/wiki/Trim_(computing)#SD.2FMMC">SD/MMC</a> 而有所不同。你需要咨询你的 Linux 供应商以了解你的特定发行版是如何支持 TRIM 的。</p>
<p>例如，红帽提供以下 <a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Storage_Administration_Guide/ch-ssd.html">SSD 磁盘指南</a>。“性能随着所使用的块数接近磁盘容量而降低，性能影响程度因供应商而异，但是所有设备都会遇到一些性能降低。为了解决性能降低问题，主机系统（例如 Linux 内核）使用丢弃请求以通知存储器给定范围的块不再使用。”</p>
<p><a href="https://wiki.debian.org/SSDOptimization">Debian wiki</a> 提供了 SSD 使用的一些基本注意事项：使用 Linux 3.2 或更高版本内核，使用 SSD 的最新固件，使用 EXT4 文件系统，并且“在正常工作负载下有足够的 DRAM 用来操作而不用使用交换空间“。</p>
<h3 id="reserve-5-of-the-spacehttpsaskubuntucomquestions249387df-h-used-space-avail-free-space-is-less-than-the-total-size-of-home"><a href="https://askubuntu.com/questions/249387/df-h-used-space-avail-free-space-is-less-than-the-total-size-of-home">reserve 5% of the space</a><a hidden class="anchor" aria-hidden="true" href="#reserve-5-of-the-spacehttpsaskubuntucomquestions249387df-h-used-space-avail-free-space-is-less-than-the-total-size-of-home">#</a></h3>
<p>By default, <code>ext2/3/4</code> filesystems reserve 5% of the space to be useable only by <code>root</code>. This is to avoid a normal user completely filling the disk which would then cause system components to fail whenever they next needed to write to the disk.</p>
<p>You can see the number of reserved blocks (and lots of other information about the filesystem) by doing:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo tune2fs -l /dev/sda8
</code></pre></div><p>For a <code>/home</code> partition, it is probably safe to set the reserved fraction to zero:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo tune2fs -m <span style="color:#ae81ff">0</span> /dev/sda8
</code></pre></div><p>Which should make an additional ~5GB available.</p>
<h3 id="change-partition-labelhttpswwwtecmintcomchange-modify-linux-disk-partition-label-names"><a href="https://www.tecmint.com/change-modify-linux-disk-partition-label-names/">Change Partition Label</a><a hidden class="anchor" aria-hidden="true" href="#change-partition-labelhttpswwwtecmintcomchange-modify-linux-disk-partition-label-names">#</a></h3>
<h4 id="e2label-or-tune2fs">e2label or tune2fs<a hidden class="anchor" aria-hidden="true" href="#e2label-or-tune2fs">#</a></h4>
<p>The commands <strong>e2label</strong> or <strong>tune2fs</strong> used for changing label of ext2, ext3 and ext4 type partitions.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># e2label /dev/sda1 ROOT</span>
OR
<span style="color:#75715e"># tune2fs –L ROOT_PART /dev/sda1</span>
</code></pre></div><p>Here, <code>ROOT</code> and <code>ROOT_PART</code> are the labels to be added to <code>/dev/sda1</code> which is ext4 formatted partition.</p>
<h4 id="ntfslabel">ntfslabel<a hidden class="anchor" aria-hidden="true" href="#ntfslabel">#</a></h4>
<p>The <strong>ntfslabel</strong> command used for changing label of NTFS partitions.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># ntfslabel /dev/sda5 NTFS_DIR</span>
</code></pre></div><h4 id="mkswap">mkswap<a hidden class="anchor" aria-hidden="true" href="#mkswap">#</a></h4>
<p>The <strong>mkswap</strong> command used for changing label of SWAP partition.</p>
<p>After unmounting the filesystem, following command needs to be executed to change the label of swap partition.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># mkswap -L SWAP_PART /dev/sda5</span>
</code></pre></div><p>Where, <code>/dev/sda5</code> is the SWAP formatted partition.</p>
<h4 id="exfatlabel">exfatlabel<a hidden class="anchor" aria-hidden="true" href="#exfatlabel">#</a></h4>
<p>The <strong>exfatlabel</strong> command used for changing the label of exFAT formatted partition.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># exfatlabel /dev/sda3 EX_PART</span>
</code></pre></div><h3 id="disable-usb-automounthttpsaskubuntucomquestions89244how-to-disable-automount-in-nautiluss-preferences"><a href="https://askubuntu.com/questions/89244/how-to-disable-automount-in-nautiluss-preferences">Disable usb automount</a><a hidden class="anchor" aria-hidden="true" href="#disable-usb-automounthttpsaskubuntucomquestions89244how-to-disable-automount-in-nautiluss-preferences">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ gsettings get org.gnome.desktop.media-handling automount
$ gsettings set org.gnome.desktop.media-handling automount false
</code></pre></div><p>or use <a href="https://linuxconfig.org/how-to-disable-gui-desktop-usb-automount-on-linux-system">dconf-editor</a></p>
<h3 id="create-an-iso-filehttpsvituxcomhow-to-create-an-iso-file-in-ubuntu"><a href="https://vitux.com/how-to-create-an-iso-file-in-ubuntu/">Create an ISO File</a><a hidden class="anchor" aria-hidden="true" href="#create-an-iso-filehttpsvituxcomhow-to-create-an-iso-file-in-ubuntu">#</a></h3>
<ul>
<li>
<p>Mkisofs</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ mkisofs -o <span style="color:#f92672">[</span>filename.iso<span style="color:#f92672">]</span> <span style="color:#f92672">[</span> directory_path<span style="color:#f92672">]</span>
$ mkisofs –o backup.iso /home/tin/Documents/backup
</code></pre></div></li>
<li>
<p>dd</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ dd <span style="color:#66d9ef">if</span><span style="color:#f92672">=[</span>source<span style="color:#f92672">]</span> of<span style="color:#f92672">=[</span>target.iso<span style="color:#f92672">]</span>
$ sudo dd <span style="color:#66d9ef">if</span><span style="color:#f92672">=</span> /dev/sdb of<span style="color:#f92672">=</span> diskimage.iso
</code></pre></div></li>
<li>
<p>Brasero</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt-get install brasero
</code></pre></div></li>
</ul>
<h3 id="keychainhttpswwwcybercitibizfaqubuntu-debian-linux-server-install-keychain-apt-get-command"><a href="https://www.cyberciti.biz/faq/ubuntu-debian-linux-server-install-keychain-apt-get-command/">keychain</a><a hidden class="anchor" aria-hidden="true" href="#keychainhttpswwwcybercitibizfaqubuntu-debian-linux-server-install-keychain-apt-get-command">#</a></h3>
<p><a href="https://wiki.gentoo.org/wiki/Keychain#Squeezing_the_last_drop_of_convenience_out_of_ssh-agent">Squeezing the last drop of convenience out of ssh-agent</a>: Keychain will allow to reuse an <strong>ssh-agent</strong> between logins, and optionally prompt for passphrases each time the user logs in.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install keychain
$ vi ~/.bashrc
. ~/.keychain/<span style="color:#e6db74">${</span>HOSTNAME<span style="color:#e6db74">}</span>-sh
$ keychain ~/.ssh/id_rsa
</code></pre></div><h3 id="default-bashrchttpsgistgithubcommariobonales1637696"><a href="https://gist.github.com/marioBonales/1637696">Default .bashrc</a><a hidden class="anchor" aria-hidden="true" href="#default-bashrchttpsgistgithubcommariobonales1637696">#</a></h3>
<p>You don&rsquo;t need to trust this random gist on Github. Heck, it&rsquo;s ~10 years old. Don&rsquo;t you want the latest default - or the default that&rsquo;s specific to your version of Ubuntu?</p>
<p>You can find the &ldquo;skeleton&rdquo; file used to initialize new users in <code>ls -a /etc/skel</code>.</p>
<p>To copy someone else&rsquo;s comment: just run <code>cp /etc/skel/.bashrc ~/</code> to copy from that &ldquo;skeleton&rdquo; to your current bashrc.</p>
<h3 id="use-cp-to-exclude-a-specific-directoryhttpsstackoverflowcomquestions4585929how-to-use-cp-command-to-exclude-a-specific-directory1478940014789400"><a href="https://stackoverflow.com/questions/4585929/how-to-use-cp-command-to-exclude-a-specific-directory/14789400#14789400">use &lsquo;cp&rsquo; to exclude a specific directory</a><a hidden class="anchor" aria-hidden="true" href="#use-cp-to-exclude-a-specific-directoryhttpsstackoverflowcomquestions4585929how-to-use-cp-command-to-exclude-a-specific-directory1478940014789400">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ shopt -s extglob
$ echo images/*
images/004.bmp images/033.jpg images/1276338351183.jpg images/2252.png
$ echo images/!<span style="color:#f92672">(</span>*.jpg<span style="color:#f92672">)</span>
images/004.bmp images/2252.png
</code></pre></div><h3 id="regenerate-initramfshttpsaskubuntucomquestions1351911what-does-regenerate-your-initramfs-mean"><a href="https://askubuntu.com/questions/1351911/what-does-regenerate-your-initramfs-mean">regenerate initramfs</a><a hidden class="anchor" aria-hidden="true" href="#regenerate-initramfshttpsaskubuntucomquestions1351911what-does-regenerate-your-initramfs-mean">#</a></h3>
<p>To create/recreate/update the initramfs file means to update the <code>initrd.img-*</code> ramdisk files in <code>/boot</code>.</p>
<p><strong>Note</strong>: I prefer to create a totally fresh version by using the <code>-c</code> option, instead of just updating the existing file by using the <code>-u</code> option.</p>
<p>The proper command would be:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo update-initramfs -c -k <span style="color:#66d9ef">$(</span>uname -r<span style="color:#66d9ef">)</span>
</code></pre></div><p>This will create a fresh initrd.img-* file for your currently booted version of Ubuntu.</p>
<p>However, if you can&rsquo;t boot to the current version of Ubuntu, you may have to modify this command, and by booting to an older version of Ubuntu, you can do it this way:</p>
<p><code>sudo update-initramfs -c -k 5.11.0-22-generic</code> where the 5.11.0-22-generic part should be replaced with the version of the desired boot kernel.</p>
<p>To get more detailed information, type:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ man update-initramfs
</code></pre></div><h3 id="extract-a-specific-file-from-a-tar-archivehttpsaskubuntucomquestions168795how-do-i-extract-a-specific-file-from-a-tar-archive"><a href="https://askubuntu.com/questions/168795/how-do-i-extract-a-specific-file-from-a-tar-archive">extract a specific file from a tar archive</a><a hidden class="anchor" aria-hidden="true" href="#extract-a-specific-file-from-a-tar-archivehttpsaskubuntucomquestions168795how-do-i-extract-a-specific-file-from-a-tar-archive">#</a></h3>
<p>Yes, just give the full stored path of the file after the tarball name.</p>
<p>Example: suppose you want file <code>etc/apt/sources.list</code> from <code>etc.tar</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ tar -xf etc.tar etc/apt/sources.list
</code></pre></div><h3 id="repair-grubhttpsaskubuntucomquestions88384how-can-i-repair-grub-how-to-get-ubuntu-back-after-installing-windows"><a href="https://askubuntu.com/questions/88384/how-can-i-repair-grub-how-to-get-ubuntu-back-after-installing-windows">repair grub</a><a hidden class="anchor" aria-hidden="true" href="#repair-grubhttpsaskubuntucomquestions88384how-can-i-repair-grub-how-to-get-ubuntu-back-after-installing-windows">#</a></h3>
<p>When you install Windows, Windows assumes it is the only operating system (OS) on the machine, or at least it does not account for Linux. So it replaces GRUB with its own boot loader. What you have to do is replace the Windows boot loader with GRUB. I&rsquo;ve seen various instructions for replacing GRUB by mucking around with GRUB commands or some such, but to me the easiest way is to simply <code>chroot</code> into your install and run <code>update-grub</code>. <code>chroot</code> is great because it allows you to work on your actual install, instead of trying to redirect things here and there. It is really clean.</p>
<h3 id="dns缓存httpsblogcsdnnetcunchi4221articledetails107470928"><a href="https://blog.csdn.net/cunchi4221/article/details/107470928">DNS缓存</a><a hidden class="anchor" aria-hidden="true" href="#dns缓存httpsblogcsdnnetcunchi4221articledetails107470928">#</a></h3>
<p>使用以下命令来检查其状态。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo systemctl status systemd-resolved
</code></pre></div><p>运行以下命令来检查DNS缓存统计信息。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo systemd-resolve --statistics
</code></pre></div><p>运行以下命令来清除Ubuntu上的DNS缓存。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo systemd-resolve --flush-caches
</code></pre></div><p>DNS刷新命令不会清除缓存命中和未命中统计信息。 如果要清除所有缓存统计信息，则必须重新启动systemd解析的服务。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo systemctl restart systemd-resolved
</code></pre></div><h3 id="change-my-usernamehttpsaskubuntucomquestions34074how-do-i-change-my-username"><a href="https://askubuntu.com/questions/34074/how-do-i-change-my-username">change my username</a><a hidden class="anchor" aria-hidden="true" href="#change-my-usernamehttpsaskubuntucomquestions34074how-do-i-change-my-username">#</a></h3>
<p>Unix-like operating systems decouple the user name from the user identity, so you may safely change the name without affecting the ID. All permissions, files, etc are tied to your identity (uid), not your username.</p>
<p>To manage every aspect of the user database, you use the <code>usermod</code> tool.</p>
<p>To change username (it is probably best to do this without being logged in):</p>
<pre tabindex="0"><code>sudo usermod -l newUsername oldUsername
</code></pre><p>This however, doesn&rsquo;t rename the home folder.</p>
<p>To change home-folder, use</p>
<pre tabindex="0"><code>sudo usermod -d /home/newHomeDir -m newUsername
</code></pre><p>after you changed the username.</p>
<p>For instance, you could logout, drop to a console (Ctrl+Alt+F1), and <code>sudo su -</code> to become true root (as opposed to <code>sudo -s</code>, where $HOME is still /home/yourname.) Maybe you also have to kill some still running processes from this user first. To do so, enter <code>ps -u username</code>, look for the matching PID and kill them by <code>kill PID-number</code>.</p>
<p>Update: as arrange mentioned, some files may reference your old home directory. You can either keep a symlink for backward compatibility, e g <code>ln -s /home/newname /home/oldname</code> or you can change the file contents with <code>sed -i.bak 's/*oldname*/*newname*/g' *list of files*</code> It creates a backup for each file with a .bak extension.</p>
<p>Some additional information for not so experienced users like me:
As I only have ONE user account (administrator), it would not let me change the username (&ldquo;you are already logged in&rdquo; was the response in TTY1 (Ctrl+Alt+F1). To get around this:</p>
<ol>
<li>
<p>Login with your old credentials and add a new user, e.g. &ldquo;temporary&rdquo; in TTY1:</p>
<pre tabindex="0"><code>sudo adduser temporary
</code></pre><p>set the password.</p>
</li>
<li>
<p>Allow the temporary user to run sudo by adding the user to sudo group:</p>
<pre tabindex="0"><code>sudo adduser temporary sudo
</code></pre></li>
<li>
<p>Log out with the command <code>exit</code>.</p>
</li>
<li>
<p>Return to tty1: Login with the &lsquo;temporary&rsquo; user account and password. Change your username and folder as mentioned above. <code>exit</code> (until you get the login prompt)</p>
</li>
<li>
<p>Go back to TTY7 (Ctrl+Alt+F7) to login on the GUI/normal desktop screen and see if this works.</p>
</li>
<li>
<p>Delete temporary user and folder:</p>
<pre tabindex="0"><code>sudo deluser temporary
sudo rm -r /home/temporary
</code></pre></li>
</ol>
<h3 id="test-network-speedhttpsphoenixnapcomkblinux-network-speed-test"><a href="https://phoenixnap.com/kb/linux-network-speed-test">Test Network Speed</a><a hidden class="anchor" aria-hidden="true" href="#test-network-speedhttpsphoenixnapcomkblinux-network-speed-test">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install speedtest-cli
$ speedtest
</code></pre></div><h3 id="蓝牙与wifi信号干扰httpswwwbilibilicomreadcv218058"><a href="https://www.bilibili.com/read/cv218058">蓝牙与WiFi信号干扰</a><a hidden class="anchor" aria-hidden="true" href="#蓝牙与wifi信号干扰httpswwwbilibilicomreadcv218058">#</a></h3>
<p><del>蓝牙和WIFI干扰？把蓝牙掐死就行了</del></p>
<p>蓝牙和Wi-Fi信号干扰问题可能你也遇到过，两者主要都是使用2.4GHz频段，导致同时开启时，蓝牙的数据吞吐量会急剧下降，配对设备困难，Wi-Fi间歇性中断，网络受到限制。目前基本没什么办法可以根治这个问题，但你可以下面的方案临时帮你解决一些问题。本文提供了4种方法，可以参考下。</p>
<p><strong>方法1：连接至5GHz无线网络</strong></p>
<p>既然知道了问题出在频段冲突上，那么可以考虑购买一个双频（2.4GHz + 5GHz）路由器，并连接至5GHz的Wi-Fi网络。该方法可以彻底解决干扰问题，但银子也是必不可少的。</p>
<p><strong>方法2：更换Wi-Fi信道</strong></p>
<p>以TP-Link路由器为例，登录路由器Web管理页，在无线设置-&gt;基本设置中找到信道选项，将其改为1、6、11中的任何一个。这些为2.4GHz的不重叠传输信道，相较于其他信道更稳定一些。</p>
<p><strong>方法3：<a href="https://askubuntu.com/questions/1200778/wifi-and-bluetooth-headset-issues">开启网卡蓝牙共存功能</a></strong></p>
<p>在近几年生产的无线网卡中，都支持蓝牙共存功能，方法是在网络适配器属性的高级选项卡中，找到Bluetooth Collaboration或Bluetooth Coexistence Mode（名称可能有所不同），将其设为启用（Enable）。Windows会自动重新连接Wi-Fi，干扰蓝牙的情况也会有所缓解。</p>
<p>对于 Linux</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ lspci -knn | grep Net -A3; lsusb
...
Kernel driver in use: ath9k
Kernel modules: ath9k
...
$ sudo tee /etc/modprobe.d/ath9k.conf <span style="color:#f92672">&lt;&lt;&lt;</span> <span style="color:#e6db74">&#34;options ath9k btcoex_enable=1&#34;</span>
</code></pre></div><p><strong>方法4：远离干扰源</strong></p>
<p>将蓝牙终端与路由器、微波炉、无绳电话机等使用2.4GHz频段的设备隔开使用。</p>
<p>然而蓝牙与WIFI干扰确实是头疼的问题：蓝牙鼠标会受到WIFI干扰经常反应迟缓，而蓝牙音箱则会导致WIFI断网，经常上传失败的绝望。。。。</p>
<p>总之，无线信道的改进还在进行着。。。</p>
<h3 id="ram--vram">RAM &amp; VRAM<a hidden class="anchor" aria-hidden="true" href="#ram--vram">#</a></h3>
<h4 id="vram-as-ramhttpswikiarchlinuxorgtitleswap_on_video_ram"><a href="https://wiki.archlinux.org/title/Swap_on_video_RAM">VRAM as RAM</a><a hidden class="anchor" aria-hidden="true" href="#vram-as-ramhttpswikiarchlinuxorgtitleswap_on_video_ram">#</a></h4>
<ul>
<li><a href="http://www.linux-mtd.infradead.org/">MTD</a></li>
<li><a href="https://github.com/Overv/vramfs">vramfs</a></li>
</ul>
<h4 id="ram-as-vramhttpswwwredditcomrpcmasterracecomments4bj7f7is_there_any_way_to_use_ram_memory_as_vram"><a href="https://www.reddit.com/r/pcmasterrace/comments/4bj7f7/is_there_any_way_to_use_ram_memory_as_vram/">RAM as VRAM</a><a hidden class="anchor" aria-hidden="true" href="#ram-as-vramhttpswwwredditcomrpcmasterracecomments4bj7f7is_there_any_way_to_use_ram_memory_as_vram">#</a></h4>
<p>Basically the answer is the operating system threats the whole memory pool for the graphics card, and ram as a virtual memory.</p>
<p>Virtual memory is paged two ways through a partition like swap, or a image file like in windows.</p>
<p>The virtual memory then maps the references to memory when you call int* or &amp;memory. To a physical address on your ram or vram depending on where it&rsquo;s meant to go.</p>
<p>The game cannot force the kernel or operating system to allocate virtual memory to a certain place.</p>
<p>The kernel will dynamically decide where everything goes, and will write to your hard drive if you overflow the current physical limit.</p>
<p>There are tons of articles on virtual memory on windows, bsd and linux. Mac is technically a bsd fork and does use the same methods, and so does the ps4 os.</p>
<p>tl;dr Basically what you are saying doesn&rsquo;t make sense in terms of virtual memory and <strong>this is done automatically</strong>( Games automatically use RAM as VRAM when you run out of VRAM. That&rsquo;s why, when you go over your VRAM limit, your FPS drops like a rock ).</p>
<p>Also some people in this thread are confusing video memory and virtual memory.</p>
<h3 id="optimizing-for-gaminghttpssteamcommunitycomsharedfilesfiledetailsid1787799592"><a href="https://steamcommunity.com/sharedfiles/filedetails/?id=1787799592">Optimizing for Gaming</a><a hidden class="anchor" aria-hidden="true" href="#optimizing-for-gaminghttpssteamcommunitycomsharedfilesfiledetailsid1787799592">#</a></h3>
<p>This guide is only for Arch and Ubuntu. Any derivatives like Manjaro, Mint, PopOS, etc should also work.</p>
<h4 id="enable-multilib">Enable Multilib<a hidden class="anchor" aria-hidden="true" href="#enable-multilib">#</a></h4>
<p>Multilib is required by Steam, So if you are running Steam you can skip this step, If you can not find Steam in your repositories this is your issue.</p>
<p>Add the architecture.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo dpkg --add-architecture i386
</code></pre></div><p>Update the package manager</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt-get update
</code></pre></div><p>Upgrade to newer packages</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt-get dist-upgrade
</code></pre></div><h4 id="gpu-drivers">GPU Drivers<a hidden class="anchor" aria-hidden="true" href="#gpu-drivers">#</a></h4>
<p>Having the right GPU drivers is imporant, else games won&rsquo;t run properly.</p>
<p>Manually check which driver you need: <a href="https://www.nvidia.com/Download/index.aspx?lang=en-us">https://www.nvidia.com/Download/index.aspx?lang=en-us</a></p>
<p>For Nvidia you need to add a repository</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo add-apt-repository ppa:graphics-drivers/ppa <span style="color:#f92672">&amp;&amp;</span> sudo apt-get upgrade
</code></pre></div><p>For Nvidia 440 you need these packages so install them.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install nvidia-graphics-drivers-440 nvidia-settings vulkan vulkan-utils
</code></pre></div><p>Now reboot</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo reboot
</code></pre></div><p>If you use Gnome or GDM you might need to disable Wayland, This is not always the case, But I include it here just in case, If your System won&rsquo;t reboot you can try this</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo nano /etc/gdm/custom.conf
</code></pre></div><p>Remove the # in front of the #WaylandEnable=false line and it should force Xorg.</p>
<h4 id="linux-kernel-1">Linux kernel<a hidden class="anchor" aria-hidden="true" href="#linux-kernel-1">#</a></h4>
<p>Installing the newest kernel is generally the easiest kernel switch, There are other kernels available, I will include them later.</p>
<p>The easiest way is to use <a href="https://github.com/bkw777/mainline">ukuu</a>, First we need to install it.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo add-apt-repository ppa:cappelikan/ppa
$ sudo apt update
$ sudo apt install mainline
</code></pre></div><p>Now ukuu is installed, in this program you can select the newest stable kernel click install and when you reboot the new kernel is used. Do not remove your old kernel. If anything goes wrong you can select which kernel to boot in the grub screen at startup and remove the kernel that gives you trouble.</p>
<h4 id="feral-gamemodehttpslinuxhintcomgamemode-improve-gaming-performance-in-linux"><a href="https://linuxhint.com/gamemode-improve-gaming-performance-in-linux/">Feral Gamemode</a><a hidden class="anchor" aria-hidden="true" href="#feral-gamemodehttpslinuxhintcomgamemode-improve-gaming-performance-in-linux">#</a></h4>
<p><a href="https://github.com/FeralInteractive/gamemode">gamemode</a> 基本上是一组守护进程/库，它可以按需优化 Linux 系统的游戏性能。它实际上只是让 CPU 在用户玩游戏时自动运行在高性能模式下并帮助 Linux 用户从游戏中获得最佳性能。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install gamemode
</code></pre></div><p><strong>Manual</strong></p>
<p>Install the dependencies</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install meson libsystemd-dev pkg-config ninja-build git libdbus-1-dev libinih-dev
</code></pre></div><p>Clone the repository</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git clone https://github.com/FeralInteractive/gamemode.git
</code></pre></div><p>Change the directory into the just downloaded folder</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cd gamemode
</code></pre></div><p>Change the tree to the newest version</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git checkout 1.5.1
</code></pre></div><p>Run the install script</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ./bootstrap.sh
</code></pre></div><p><strong>Usage</strong></p>
<p>Now that it is installed we need to enable the service with this command</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ systemctl --user enable gamemoded <span style="color:#f92672">&amp;&amp;</span> systemctl --user start gamemoded
</code></pre></div><p>To use gamemode for supertuxkart for example, run this terminal</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ gamemoderun supertuxkart
</code></pre></div><p>To use it in Steam edit the launch option for the desired game to</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ gamemoderun %command%
</code></pre></div><p>If gamemode does not run try to make it executable:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo chmod +x /usr/bin/gamemoderun
</code></pre></div><p>If gamemoderun does not work for you try this as a launch command:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ LD_PRELOAD<span style="color:#f92672">=</span>$LD_PRELOAD:/usr/lib/x86_64-linux-gnu/libgamemodeauto.so.0 %command%
</code></pre></div><h4 id="nvidia-improvements">Nvidia Improvements<a hidden class="anchor" aria-hidden="true" href="#nvidia-improvements">#</a></h4>
<p>Nvidia users might want to enable all options listed here to improve performance in games</p>
<ul>
<li>Force Full Composition Pipeline avoids screen tearing by letting the GPU do all the scaling.</li>
<li>Triple Buffer avoids stuttering gameplay It allows for a stream of data instead of chunks of data.</li>
<li>IndirectGLXProtocol forces the game to directly communicate with the Nvidia drivers.</li>
<li>Coolbits enables your card to be overclocked which gamemode will make use of.</li>
</ul>
<p>Create a Xorg Config file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo nvidia-xconfig
</code></pre></div><p>Edit the file with the following command</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo nano /etc/X11/xorg.conf
</code></pre></div><p>Add in these lines under the &ldquo;Device&rdquo; section between the other options</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">Option         <span style="color:#e6db74">&#34;TripleBuffer&#34;</span> <span style="color:#e6db74">&#34;on&#34;</span> Option         <span style="color:#e6db74">&#34;Coolbits&#34;</span> <span style="color:#e6db74">&#34;28&#34;</span>
</code></pre></div><p>Add in these lines under the &ldquo;Screen&rdquo; section between the other options.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">Option         <span style="color:#e6db74">&#34;metamodes&#34;</span> <span style="color:#e6db74">&#34;nvidia-auto-select +0+0 {ForceCompositionPipeline=On, ForceFullCompositionPipeline=On}&#34;</span> Option         <span style="color:#e6db74">&#34;AllowIndirectGLXProtocol&#34;</span> <span style="color:#e6db74">&#34;off&#34;</span>
</code></pre></div><p>Try this one with risk, It will be sure to crash GNOME, I am not sure about other DEs</p>
<p>just add it to the end of the file</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">Section <span style="color:#e6db74">&#34;Extensions&#34;</span>   Option         <span style="color:#e6db74">&#34;Composite&#34;</span> <span style="color:#e6db74">&#34;Disable&#34;</span> EndSection
</code></pre></div><p>If you run into any problems, just hit CTRL ALT F3 to switch to a different tty login, run the command to edit the file again and put a # in front of the options that are giving you trouble, Most likely the last one</p>
<p>Alternatively you can just completely remove the file with the following command</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo rm /etc/X11/xorg.conf
</code></pre></div><h4 id="libstrangle">Libstrangle<a hidden class="anchor" aria-hidden="true" href="#libstrangle">#</a></h4>
<p><a href="https://gitlab.com/torkel104/libstrangle">Libstrangle</a> is a tool that helps you control framerates but also vsync settings. This is especially handy for games that do not support these features, You would like to half your framerate to make it run better save some power or just give your hardware a break.</p>
<p>Libstrangle can be used in multiple ways depending on what you want to achieve.</p>
<p>To use libstrangle you can simply type strangle and then the amount of frames you want to run. There are some examples below, But the features you will probably use are Vsync which you use by using the -v option, the rules for OpenGL and Vulkan are different, Here is what each number does for the different apis.</p>
<ul>
<li>OpenGL 0 Force off, 1 Force on, n - Sync to refresh rate</li>
<li>Vulkan 0 Force off, 1 Mailbox mode, 2 Traditional vsync, 3 Adaptive vsync</li>
</ul>
<p>You can also limit the game depending on the power state of your device, Set it to 60 while charging and on 30 while discharging for example. You do this by adding a second number right after a colon. in example, strangle 60:30. There are more features but they are not that commonly used, you can check the gitlab link above or simply type strangle -h for more information.</p>
<p>To limit the framerate of supertuxkart to 30 simply run</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ strangle <span style="color:#ae81ff">30</span> supertuxkart
</code></pre></div><p>To Force enable vsync on 60 fps for an OpenGL Steam game set the launch option to</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ strangle -v <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">60</span> %command%
</code></pre></div><p>To set the framerate of a vulkan game on Steam to 120 fps but 60 on battery power with adaptive vsync set this as your launch command</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ strangle -v <span style="color:#ae81ff">3</span> 120:60 %command%
</code></pre></div><h4 id="mangohud">Mangohud<a hidden class="anchor" aria-hidden="true" href="#mangohud">#</a></h4>
<p><a href="https://github.com/flightlessmango/MangoHud">Mangohud</a> is a monitoring tool for Vulkan and OpenGL applications. It can show CPU and GPU usage, temps, But also framerates, frametimes and a lot more.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo add-apt-repository ppa:flexiondotorg/mangohud
$ sudo apt update
$ sudo apt install mangohud
</code></pre></div><p>To configure it with a GUI you can check out GOverlay below. For a manual configuration you can edit</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ~/.config/MangoHud/MangoHud.conf
</code></pre></div><p>If you want exactly my configuration you can just copy this into it without the need for GOverlay.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">background_alpha<span style="color:#f92672">=</span>0.3
font_size<span style="color:#f92672">=</span><span style="color:#ae81ff">20</span>
background_color<span style="color:#f92672">=</span><span style="color:#ae81ff">020202</span>
text_color<span style="color:#f92672">=</span>ffffff
position<span style="color:#f92672">=</span>top-right
no_display
toggle_hud<span style="color:#f92672">=</span>F11
cpu_stats
cpu_temp
cpu_color<span style="color:#f92672">=</span>007AFA
gpu_stats
gpu_temp
gpu_color<span style="color:#f92672">=</span>00BD00
ram
ram_color<span style="color:#f92672">=</span>B3000A
vram
vram_color<span style="color:#f92672">=</span>00801B
io_read
io_write
io_color<span style="color:#f92672">=</span>B84700
arch
engine_color<span style="color:#f92672">=</span>B200B0
frame_timing<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
frametime_color<span style="color:#f92672">=</span>00ff00
<span style="color:#75715e">#output_file=/home/houtworm/mangohud_log_ </span>
<span style="color:#75715e">#fps_limit 120</span>
<span style="color:#75715e">#media_player</span>
<span style="color:#75715e">#toggle_logging=F10</span>
</code></pre></div><p>You can tweak all the little things you want here. You can also create different configurations per game by adding a MangoHud.conf file to the game directory.</p>
<p>To use it for any game change its launch option to</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ mangohud %command%
</code></pre></div><p>To use it with non Steam games use the following command</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ mangohud supertuxkart
</code></pre></div><p>Some games might need the 32 bit version, try this if the normal command fails.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ mangohud.x86 %command%
</code></pre></div><h4 id="vkbasalt">VKBasalt<a hidden class="anchor" aria-hidden="true" href="#vkbasalt">#</a></h4>
<p><a href="https://github.com/DadSchoorse/vkBasalt">VKBasalt</a> is a post processing layer for Vulkan which enables you to enhance graphics further. It only works with Vulkan, This includes all Proton games.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git clone https://github.com/DadSchoorse/vkBasalt.git <span style="color:#f92672">&amp;&amp;</span> cd vkBasalt <span style="color:#f92672">&amp;&amp;</span> meson --buildtype<span style="color:#f92672">=</span>release builddir <span style="color:#f92672">&amp;&amp;</span> ninja -C builddir install
</code></pre></div><p>To configure it first you need to create a config file, Run the following command to copy the example to a folder you can edit as the user.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ mkdir ~/.config/vkBasalt <span style="color:#f92672">&amp;&amp;</span> cp /usr/share/vkBasalt/vkBasalt.conf.example ~/.config/vkBasalt/vkBasalt.conf
</code></pre></div><p>You can tweak all the little things you want here. You can also create different configurations per game by adding a vkBasalt.conf file to the game directory.</p>
<p>To use VKBasalt for any particular game enter this as a launch option.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">ENABLE_VKBASALT<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> %command%
</code></pre></div><p>You can also start non Steam games this way by typing the following command</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">ENABLE_VKBASALT<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> supertuxkart
</code></pre></div><h4 id="goverlay">GOverlay<a hidden class="anchor" aria-hidden="true" href="#goverlay">#</a></h4>
<p><a href="https://github.com/benjamimgois/goverlay">GOverlay</a> is a Graphical User Interface for managing MangoHud and VKBasalt</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt-get install lazarus git
$ git clone https://github.com/benjamimgois/goverlay.git
$ cd goverlay
$ lazbuild -B goverlay.lpi
</code></pre></div><p>mesa-demos and vulkan-tools are optional, You need them if you want to show the previews. You can find them in your distros repository</p>
<h4 id="xbox-one-controller">Xbox One Controller<a hidden class="anchor" aria-hidden="true" href="#xbox-one-controller">#</a></h4>
<p>xpad works great, is the default on modern Linux distros and supports a wide range of controllers, But if you are like me and you only Xbox One controllers then using xpadneo is much better.</p>
<p>For Bluetooth to work with xpad and the Xbox One controllers you need to disable ertm (This is not needed for xpadneo)</p>
<p>create the config file</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo nano /etc/modprobe.d/xbox_bt.conf
</code></pre></div><p>Add the following line to the document and save and exit with CTRL + X.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">options bluetooth disable_ertm<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</code></pre></div><p><a href="https://github.com/atar-axis/xpadneo">xpadneo</a> supports Xbox One controllers wired and over bluetooth, It enables Force Feedback even the vibration inside the triggers, It supports battery level indication, It also fixes the mapping in many many games that where previously unplayable with a Xbox One controller on Linux.</p>
<p>Install the dependencies</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt-get install dkms linux-headers-<span style="color:#e6db74">`</span>uname -r<span style="color:#e6db74">`</span>
</code></pre></div><p>Install xpadneo from Github</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git clone https://github.com/atar-axis/xpadneo.git <span style="color:#f92672">&amp;&amp;</span> cd xpadneo <span style="color:#f92672">&amp;&amp;</span> sudo ./install.sh
</code></pre></div><p>Now you should be able to reboot and it should be all good, Having the controllers vibrate for a second when connected is a good indicator that it works.</p>
<h3 id="认证硬件httpswwwzhihucomquestion286150644"><a href="https://www.zhihu.com/question/286150644">认证硬件</a><a hidden class="anchor" aria-hidden="true" href="#认证硬件httpswwwzhihucomquestion286150644">#</a></h3>
<ul>
<li><a href="https://ubuntu.com/certified">Ubuntu certified hardware</a></li>
<li><a href="https://catalog.redhat.com/hardware">Red Hat certified hardware</a></li>
</ul>
<p>如果不怎么玩游戏的话，建议是直接考虑那些不带独立显卡的笔记本电脑。因为在Linux下双显卡装驱动问题很多。</p>
<p>说到牌子的话，建议是考虑戴尔笔记本。因为戴尔台式机和笔记本，都是尽可能地去兼容Ubuntu来设计的。这个不是说假话做广告。我也就这个问题，看过了几乎所有戴尔系列产品的技术文档了。基本上都是在支持的操作系统列表中，无一例外地包含了Ubuntu。如果是想买能完美使用Ubuntu的本子，戴尔是首选。戴尔绝大部分笔记本机型都能很好完美兼容Ubuntu。</p>
<p>还有一个重要原因就是，ubuntu的所属公司，与戴尔公司是有合作的。也正因为如此，Ubuntu默认就包含了dell的大部分硬件通用驱动，甚至硬件底层管理模块都囊括其中。</p>
<h3 id="功耗控制httpsarchicekylinonlineadvancedpower-ctlhtml"><a href="https://arch.icekylin.online/advanced/power-ctl.html">功耗控制</a><a hidden class="anchor" aria-hidden="true" href="#功耗控制httpsarchicekylinonlineadvancedpower-ctlhtml">#</a></h3>
<p>针对散热不好的设备或者续航能力不佳的笔记本，功耗控制显得非常必要</p>
<h4 id="使用-tlp-延长电池寿命及续航">使用 TLP 延长电池寿命及续航<a hidden class="anchor" aria-hidden="true" href="#使用-tlp-延长电池寿命及续航">#</a></h4>
<blockquote>
<p>如有需要可参阅 <a href="https://linrunner.de/tlp/settings/index.html">TLP 官方文档</a> 和 <a href="https://wiki.archlinux.org/title/TLP_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">archwiki TLP</a>。</p>
</blockquote>
<p>多年来，Linux 在电池优化方面取得了很大进步，但仍然有一些可选步骤改善笔记本电脑的电池寿命并且延长续航。</p>
<p>TLP 作为一款自由开源的高级电源管理工具提供开箱即用的默认配置。同时也可以高度定制化，以满足特定需求。</p>
<h4 id="电压下探">电压下探<a hidden class="anchor" aria-hidden="true" href="#电压下探">#</a></h4>
<blockquote>
<p>以下方法<strong>仅适用于 Intel 四代酷睿 ™ Haswell 及更新 CPU</strong>。有关 AMD CPU 和 Intel 四代酷睿 ™ Haswell 之前的 CPU 请参考 <a href="https://wiki.archlinux.org/index.php/Undervolting_CPU">archWiki Undervolting CPU</a>。</p>
</blockquote>
<p>对处理器的电压进行最大限度的下探，在挖掘 CPU 体质的极限的同时，起到既能降低发热，又能最大限度保持性能的效果。</p>
<p>如果正常操作，降低电压<strong>一般</strong>不会损害 CPU，一般建议从 50 毫伏进行尝试，每次降压尝试多增加 10 毫伏。只要确保在降低电压前，系统中任务均被正确保存即可。</p>
<h4 id="降低功率墙">降低功率墙<a hidden class="anchor" aria-hidden="true" href="#降低功率墙">#</a></h4>
<p>除了电压的下探，同时也可以尝试对处理器的功率墙（TDP）做出降低的限制。比如考虑这种情况 —— 在 CPU 满睿频时，其实不需要默认的那么多功耗来维持，也许在默认功耗的基础上减几瓦，也能维持满睿频，这样就又可以进一步降低温度。对功率墙进行限制不同于对电压进行下探，若限制功率墙的参数较低，这会不可避免的损失较多的性能，但是在散热过差的设备上这也是一个好办法。</p>
<p>对于功率墙的调整，有些主板在 BIOS 中提供了设置项可以直接调整。对于没有设置项的主板，有的主板是锁定了瞬时和长时功率墙，这种情况就无法调整功率墙了。有的主板 BIOS 随没有提供功率墙调整项，但依旧可以通过命令行设置。</p>
<p>通过以下的命令可以查看主板是否可以调整功率墙：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">grep . /sys/class/powercap/intel-rapl/intel-rapl:0/* 2&gt; /dev/null
</code></pre></div><p>如果在输出中看到了如下的 <code>enabled</code> 值为 <code>1</code>，即可以调整。第一行的数字代表现有的功率墙限制：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">/sys/class/powercap/intel-rapl/intel-rapl:0/constraint_0_power_limit_uw:100000000
/sys/class/powercap/intel-rapl/intel-rapl:0/enabled:1
</code></pre></div><p>具体的调整步骤参考 <a href="https://askubuntu.com/questions/1226254/set-max-tdp-of-intel-h-series-cpu">Set Max TDP of Intel H-series CPU</a>。</p>
<h3 id="交换文件httpsarchlinuxstudiogithubioarchlinuxtutorialrookiedeappid_5e8aebee7bdaee4baa4e68da2e69687e4bbb6-swape58fafe98089"><a href="https://archlinuxstudio.github.io/ArchLinuxTutorial/#/rookie/DE&amp;App?id=_5%e8%ae%be%e7%bd%ae%e4%ba%a4%e6%8d%a2%e6%96%87%e4%bb%b6-swap%e5%8f%af%e9%80%89">交换文件</a><a hidden class="anchor" aria-hidden="true" href="#交换文件httpsarchlinuxstudiogithubioarchlinuxtutorialrookiedeappid_5e8aebee7bdaee4baa4e68da2e69687e4bbb6-swape58fafe98089">#</a></h3>
<p>在桌面环境中，交换分区或文件用来实现休眠(hibernate)的功能，即将当前环境保存在磁盘的交换文件或分区部分。除此之外，某些特定软件需要 swap 才可以正确运行。交换文件与分区性能相同，且交换文件更为灵活，可随时变更大小，增加与删除。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ dd <span style="color:#66d9ef">if</span><span style="color:#f92672">=</span>/dev/zero of<span style="color:#f92672">=</span>/swapfile bs<span style="color:#f92672">=</span>1M count<span style="color:#f92672">=</span><span style="color:#ae81ff">4096</span> status<span style="color:#f92672">=</span>progress <span style="color:#75715e">#创建4G的交换空间 大小根据需要自定</span>
$ chmod <span style="color:#ae81ff">600</span> /swapfile <span style="color:#75715e">#设置正确的权限</span>
$ mkswap /swapfile <span style="color:#75715e">#格式化swap文件</span>
$ swapon /swapfile <span style="color:#75715e">#启用swap文件</span>
</code></pre></div><p>最后，向/etc/fstab 中<strong>追加</strong>如下内容：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">/swapfile none swap defaults <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span>
</code></pre></div><p>KDE 自身提供开箱即用的睡眠功能(suspend)，即将系统挂起到内存，消耗少量的电量。休眠(hibernate)会将系统挂起到交换分区或文件，几乎不消耗电量。</p>
<h2 id="questions-2">QUESTIONS<a hidden class="anchor" aria-hidden="true" href="#questions-2">#</a></h2>
<h3 id="ubuntu-无法关机">Ubuntu 无法关机<a hidden class="anchor" aria-hidden="true" href="#ubuntu-无法关机">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo vim /etc/systemd/system.conf
DefaultTimeoutStartSec<span style="color:#f92672">=</span>5s
DefaultTimeoutStopSec<span style="color:#f92672">=</span>5s
$ sudo systemctl reload
</code></pre></div><p><code>DefaultTimeoutStartSec=</code>, <code>DefaultTimeoutStopSec=</code> 设置启动/停止一个单元所允许的最大时长。若仅设置一个整数而没有单位，那么单位是秒。 也可以在整数后面加上时间单位后缀： &ldquo;ms&rdquo;(毫秒), &ldquo;s&rdquo;(秒), &ldquo;min&rdquo;(分钟), &ldquo;h&rdquo;(小时), &ldquo;d&rdquo;(天), &ldquo;w&rdquo;(周) 。 对于 <code>Type=oneshot</code> 类型的 service 单元， 这些选项没有意义(相当于全部被禁用)。 对于其他类型的 service 单元，可以在单元文件中设置 <code>TimeoutStartSec=</code>, <code>TimeoutStopSec=</code>, <code>RestartSec=</code> 以覆盖此处设置的默认值 (参见<a href="http://www.jinbuguo.com/systemd/systemd.service.html##">systemd.service(5)</a>)。 对于其他非 service 类型的单元， <code>DefaultTimeoutStartSec=</code> 是 <code>TimeoutSec=</code> 的默认值。</p>
<p>注1：尽量不要使用上面更改。应该在完全清楚自己的更改造成的影响、产生的作用的前提下，做出更改。</p>
<p>注2：作为桌面操作系统，如果有硬件驱动或其他各种莫名问题，可以尝试升级到最新版本来解决。</p>
<h3 id="acpi-error-ae_already_existshttpsaskubuntucomquestions1064528cant-install-ubuntu-from-an-usb-stick-ae-not-found-ae-already-exists"><a href="https://askubuntu.com/questions/1064528/cant-install-ubuntu-from-an-usb-stick-ae-not-found-ae-already-exists">ACPI ERROR: AE_ALREADY_EXISTS</a><a hidden class="anchor" aria-hidden="true" href="#acpi-error-ae_already_existshttpsaskubuntucomquestions1064528cant-install-ubuntu-from-an-usb-stick-ae-not-found-ae-already-exists">#</a></h3>
<p>These kinds of &ldquo;errors&rdquo; have been discussed ad nauseam, it&rsquo;s simply the kernel telling you that the ACPI information received from the system seems to be incomplete in some way, update your BIOS/UEFI in hopes for a proper fix or ignore the error if you don&rsquo;t notice anything off with your system.</p>
<p>(And please don&rsquo;t do something dumb like setting acpi=off just to get rid of these messages)</p>
<h3 id="解压zip乱码httpsforumubuntuorgcnviewtopicphpf122t175405p1343326"><a href="https://forum.ubuntu.org.cn/viewtopic.php?f=122&amp;t=175405&amp;p=1343326">解压zip乱码</a><a hidden class="anchor" aria-hidden="true" href="#解压zip乱码httpsforumubuntuorgcnviewtopicphpf122t175405p1343326">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ unzip -O CP936 xxx.zip
</code></pre></div><p>用GBK, GB18030也可以</p>
<h3 id="cant-run-csgo-at-fullscreenhttpsaskubuntucomquestions1114857cant-run-csgo-at-fullscreen-ubuntu-18-10"><a href="https://askubuntu.com/questions/1114857/cant-run-csgo-at-fullscreen-ubuntu-18-10">Can&rsquo;t run CS:GO at fullscreen</a><a hidden class="anchor" aria-hidden="true" href="#cant-run-csgo-at-fullscreenhttpsaskubuntucomquestions1114857cant-run-csgo-at-fullscreen-ubuntu-18-10">#</a></h3>
<ol>
<li>Open Steam</li>
<li>Go to the &ldquo;Library&rdquo;</li>
<li>Right-click the game which needs to be reconfigured</li>
<li>Select &ldquo;Properties&rdquo; from the menu</li>
<li>Click the &ldquo;Set launch options&hellip;&rdquo; button</li>
<li>type: -full and save</li>
</ol>
<h3 id="how-to-disable-lock-in--kubuntuhttpswwwubuntubuzzcom201604how-to-disable-suspend-lock-ubuntu-kubuntuhtmlm1textto20disable20kde20lock20behavior2c20in20the20sameactions20post20tags203a20kde2c20kubuntu2c20ubuntu2c20unity"><a href="https://www.ubuntubuzz.com/2016/04/how-to-disable-suspend-lock-ubuntu-kubuntu.html?m=1#:~:text=To%20disable%20KDE%20lock%20behavior%2C%20in%20the%20same,actions.%20Post%20Tags%20%3A%20KDE%2C%20Kubuntu%2C%20Ubuntu%2C%20unity">How To Disable Lock In  Kubuntu</a><a hidden class="anchor" aria-hidden="true" href="#how-to-disable-lock-in--kubuntuhttpswwwubuntubuzzcom201604how-to-disable-suspend-lock-ubuntu-kubuntuhtmlm1textto20disable20kde20lock20behavior2c20in20the20sameactions20post20tags203a20kde2c20kubuntu2c20ubuntu2c20unity">#</a></h3>
<p>open Workspace &gt; Desktop Behavior &gt; Screen Locking &gt; uncheck Lock screen option</p>
<h3 id="gnome-3-displays-two-icons-for-same-apphttpsaskubuntucomquestions898474why-do-some-applications-have-two-icons-in-usr-share-application"><a href="https://askubuntu.com/questions/898474/why-do-some-applications-have-two-icons-in-usr-share-application">Gnome 3 displays two icons for same app</a><a hidden class="anchor" aria-hidden="true" href="#gnome-3-displays-two-icons-for-same-apphttpsaskubuntucomquestions898474why-do-some-applications-have-two-icons-in-usr-share-application">#</a></h3>
<p>No, there&rsquo;s nothing wrong with your system.</p>
<p>The duplicated launcher icons explained:</p>
<p>The different icons are different commandline options. Some context applications with call the associated *.desktop icon. The exec option of the icon will depend on how the application is called.</p>
<p>Some of the Icons you show in your image may be obvious because of the difference in the way they are named. You can see the difference in the way the app is called by right clicking and clicking on properties to see other differences.</p>
<p>Some of the <code>*.desktop</code> files have a <code>%U</code> argument, used so the application will accept arguments.</p>
<p>Some of the Launchers are different commands that are called differently and are named differently often by a symbolic link.</p>
<p>Some exampes from the list in you image are:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">Name: Online Accounts
Command: unity-control-center credentials

Name: Online Accounts
Command: Online account credentials and settings

Name: Personal File Sharing
Command: gnome-file-share-properties

Name: Rhythmbox
Command: rhythmbox %U

Name: Rhythmbox
Command rhythmbox-client --select-source %U
</code></pre></div><h3 id="ssh_exchange_identification-connection-closed-by-remote-hosthttpswwwzhihucomquestion20023544"><a href="https://www.zhihu.com/question/20023544">ssh_exchange_identification: Connection closed by remote host</a><a hidden class="anchor" aria-hidden="true" href="#ssh_exchange_identification-connection-closed-by-remote-hosthttpswwwzhihucomquestion20023544">#</a></h3>
<p>原因是 Clash 开了 TUN 模式。关闭掉就好了。</p>
<h3 id="disk-show-129986-tb">Disk show 129986 TB<a hidden class="anchor" aria-hidden="true" href="#disk-show-129986-tb">#</a></h3>
<blockquote>
<p>(=ↀωↀ=)橘外猫, [2/7/22 11:16 AM]
<img loading="lazy" src="/Distributions/photo_2022-02-07_11-41-09.jpg" alt=""  />

这个是怎么回事啊</p>
<p>雪梨, [2/7/22 11:21 AM]
分区表坏了？</p>
<p>(=ↀωↀ=)橘外猫, [2/7/22 11:21 AM]
直接再分区吗？</p>
<p>雪梨, [2/7/22 11:21 AM]
请鸽鱼老师看看诶</p>
<p>雪梨, [2/7/22 11:22 AM]
还能挂载就先备份数据好了</p>
<p>(=ↀωↀ=)橘外猫, [2/7/22 11:22 AM]
好的</p>
<p>Pegion Fish, [2/7/22 11:25 AM]
JMS炸了？
建议备份数据重建分区表
先重新插一次USB和硬盘</p>
<p>(=ↀωↀ=)橘外猫, [2/7/22 11:27 AM]
重插了
用fdisk 重建吗？</p>
<p>Pegion Fish, [2/7/22 11:28 AM]
还是不正常？
硬盘也重新插一下</p>
<p>(=ↀωↀ=)橘外猫, [2/7/22 11:28 AM]
恩</p>
<p>雪梨, [2/7/22 11:28 AM]
重建分区表，不是删掉分区再新增分区</p>
<p>(=ↀωↀ=)橘外猫, [2/7/22 11:30 AM]
断电后自动好了
这是怎么回事啊</p>
<p>Thor Luo Bing-, [2/7/22 11:31 AM]
硬盘清空了</p>
<p>(=ↀωↀ=)橘外猫, [2/7/22 11:32 AM]
没有，东西还在</p>
<p>Pegion Fish, [2/7/22 11:32 AM]
啊
这不是争产的吗
1T啊
这就是JMS主控抽风</p>
</blockquote>
<h3 id="no-caching-mode-page-found">No Caching mode page found<a hidden class="anchor" aria-hidden="true" href="#no-caching-mode-page-found">#</a></h3>
<p>during early boot, I get following error message:</p>
<pre tabindex="0"><code>[sdb] No Caching mode page found
[sdb] Assuming drive cache: write through
</code></pre><p>If I understand correctly, this is actually just a harmless info message and not an actual error. <code>sdb</code> is my USB disk, and it does not use caching .</p>
<p>Hard disks have a small amount of RAM cache to speed up write operations. The system can write a chunk of data to the disk cache without actually waiting for it to be written to the disk. This is sometimes called &ldquo;write-back&rdquo; mode. If there is no cache on the disk, data is directly written to it in &ldquo;write-through&rdquo; mode. The Asking for cache data failed warning usually occurs with devices such as USB flash drives, USB card readers, etc. which present themselves as SCSI devices to the system (sdX), but have no cache. The system asks the device: &ldquo;Do you have a cache?&rdquo; and gets no response. So it assumes there is no cache and puts it in &ldquo;write-through&rdquo; mode.</p>
<h3 id="certificate-verification-failedhttpsblogcsdnnetchaowanqarticledetails121559709"><a href="https://blog.csdn.net/Chaowanq/article/details/121559709">Certificate verification failed</a><a hidden class="anchor" aria-hidden="true" href="#certificate-verification-failedhttpsblogcsdnnetchaowanqarticledetails121559709">#</a></h3>
<p>首先更改源文件，将所有的 https 改成 http ：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo vi /etc/apt/sources.list
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse
<span style="color:#ae81ff">1234</span>
</code></pre></div><p>然后安装/更新证书 ca-certificates：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt-get update
$ sudo apt-get install --reinstall ca-certificates
</code></pre></div><p>最后将镜像源文件改回 https：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo vi /etc/apt/sources.list
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse
$ sudo apt-get update
</code></pre></div><h3 id="move-and-overwrite-subdirectories-and-files-to-parent-directoryhttpsunixstackexchangecomquestions9899how-to-move-and-overwrite-subdirectories-and-files-to-parent-directory"><a href="https://unix.stackexchange.com/questions/9899/how-to-move-and-overwrite-subdirectories-and-files-to-parent-directory">Move and overwrite subdirectories (and files) to parent directory</a><a hidden class="anchor" aria-hidden="true" href="#move-and-overwrite-subdirectories-and-files-to-parent-directoryhttpsunixstackexchangecomquestions9899how-to-move-and-overwrite-subdirectories-and-files-to-parent-directory">#</a></h3>
<p>You will have to copy them to the destination and then delete the source, using the commands <code>cp -r * ..</code> followed by <code>rm -rf *</code>.</p>
<p>I don&rsquo;t think you can &ldquo;merge&rdquo; directories using <code>mv</code>.</p>
<h3 id="system-program-problem-detectedhttpswwwcnblogscomcrazyackingp5451861html"><a href="https://www.cnblogs.com/crazyacking/p/5451861.html">System program problem detected</a><a hidden class="anchor" aria-hidden="true" href="#system-program-problem-detectedhttpswwwcnblogscomcrazyackingp5451861html">#</a></h3>
<p>The error &ldquo;System program problem detected&rdquo; comes up when a certain  application crashes. Ubuntu has a program called Apport that is  responsible for detecting such crashes and upon user consent, report  these crashes to developers. This process intends to get the problem  fixed by the developers.</p>
<p>However it can be very annoying to common users, and there is no  point in showing errors to users when they cannot do anything about it  themselves. So you might want to disable them.</p>
<p><img loading="lazy" src="/Distributions/system-program-problem-detected.png" alt=""  />
</p>
<p><strong>Remove crash report files</strong></p>
<p>The apport system creates crash report files in the /var/crash  directory. These crash report files cause the error message to appear  everytime Ubuntu boots.</p>
<pre tabindex="0"><code>$ cd /var/crash
$ ls
_opt_google_chrome_chrome.1000.crash
_usr_lib_chromium-browser_chromium-browser.1000.crash
_usr_sbin_ulatencyd.0.crash
_usr_share_apport_apport-gtk.1000.crash
</code></pre><p>Just remove the crash report files</p>
<pre tabindex="0"><code>$ sudo rm /var/crash/*
</code></pre><p>After removing all the crash report files, the error message should  stop popping up. However if a new crash takes place then it would appear again in future.</p>
<p><strong>Turn off apport</strong></p>
<p>After removing the old crash reports, if you still get the same error message, then you can completely turn off apport to get rid. Edit the  configuration file at /etc/default/apport.</p>
<pre tabindex="0"><code>$ gksudo gedit /etc/default/apport
</code></pre><p>The file would contain something like this</p>
<pre tabindex="0"><code># set this to 0 to disable apport, or to 1 to enable it
# you can temporarily override this with
# sudo service apport start force_start=1
enabled=1
</code></pre><p>Just set the value of enabled to 0, and this will disable apport.</p>
<pre tabindex="0"><code>enabled=0
</code></pre><p>Save the file and close it. From the next boot onwards, there should  be no error messages ever. If you do not want to restart the system then restart apport from the command line.</p>
<pre tabindex="0"><code>$ sudo restart apport
</code></pre>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://sakamotokurome.github.io/tags/unix/">Unix</a></li>
      <li><a href="https://sakamotokurome.github.io/tags/linux/">Linux</a></li>
      <li><a href="https://sakamotokurome.github.io/tags/ubuntu/">Ubuntu</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://sakamotokurome.github.io/posts/links/">
    <span class="title">« Prev Page</span>
    <br>
    <span>Links</span>
  </a>
  <a class="next" href="https://sakamotokurome.github.io/posts/hexo/">
    <span class="title">Next Page »</span>
    <br>
    <span>Hexo</span>
  </a>
</nav>

  </footer>
</article>

<div class="disqus-container">
  <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    this.page.identifier = '710eb4';
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "sakamotokurome" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://sakamotokurome.github.io/">Sakamoto Kurome</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
</body>

</html>
