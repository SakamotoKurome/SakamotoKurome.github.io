<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Git | Sakamoto Kurome</title>
<meta name="keywords" content="Unix, Linux, Git, GitHub" />
<meta name="description" content="Workspace：工作区，Index / Stage：暂存区，Repository：仓库区（或本地仓库），Remote：远程仓库 远程仓库 安装，">
<meta name="author" content="Sakamoto Kurome">
<link rel="canonical" href="https://sakamotokurome.github.io/posts/git/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css" integrity="sha256-yIlj/i15RiAA/Q&#43;xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://sakamotokurome.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://sakamotokurome.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://sakamotokurome.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://sakamotokurome.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://sakamotokurome.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.90.0" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>

<link rel="stylesheet" href="https://sakamotokurome.github.io/custom.css">
<meta name="google-site-verification" content="i2r403EffR8m-KBf7EHi6AYg7tfnMshaXTAynoYPnpE" />
<script async src="https://www.googletagmanager.com/gtag/js?id=G-K2Y212LPQ2"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-K2Y212LPQ2', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="Git" />
<meta property="og:description" content="Workspace：工作区，Index / Stage：暂存区，Repository：仓库区（或本地仓库），Remote：远程仓库 远程仓库 安装，" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://sakamotokurome.github.io/posts/git/" />
<meta property="og:image" content="https://sakamotokurome.github.io/Git/github0.png" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-12-12T16:46:08&#43;08:00" />
<meta property="article:modified_time" content="2021-12-12T16:46:08&#43;08:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://sakamotokurome.github.io/Git/github0.png" />
<meta name="twitter:title" content="Git"/>
<meta name="twitter:description" content="Workspace：工作区，Index / Stage：暂存区，Repository：仓库区（或本地仓库），Remote：远程仓库 远程仓库 安装，"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://sakamotokurome.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Git",
      "item": "https://sakamotokurome.github.io/posts/git/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Git",
  "name": "Git",
  "description": "Workspace：工作区，Index / Stage：暂存区，Repository：仓库区（或本地仓库），Remote：远程仓库 远程仓库 安装，",
  "keywords": [
    "Unix", "Linux", "Git", "GitHub"
  ],
  "articleBody": "Workspace：工作区，Index / Stage：暂存区，Repository：仓库区（或本地仓库），Remote：远程仓库\n远程仓库 安装，windows需要处理换行符 sudo yum install git 设置姓名和邮箱地址 git config --global user.name \"Vane Hsiung\" git config --global user.email \"1664548605@qq.com\" 提高输出可读性 git config --global color.ui auto 设置文件   显示当前的 Git 配置\ngit config --list cat ~/.giconfig   编辑Git配置文件\ngit config -e [--global]   设置SSH，添加认证密码 ssh-keygen -t rsa -C \"1664548605@qq.com\" 添加公开密钥 将下面的密钥添加到 GitHub 设置中的 SSH key 中\ncat ~/.ssh/id_rsa.pub 查看是否认证和通信成功 ssh -T git@github.com 获取远程仓库 clone 后默认在 master 分支下自动将 origin 设置为远程仓库标识符\ngit clone SSH 提速：\ngit clone SSH --depth=1 加上 –depth 会只下载一个 commit，所以内容少了很多，速度也就上去了。\n而且下载下来的内容是可以继续提交新的 commit、创建新的分支的。不影响后续开发，只是不能切换到历史 commit 和历史分支。\n在一些场景下还是比较有用的：当需要切换到历史分支的时候也可以计算需要几个 commit，然后再指定 depth，这样也可以提高速度。\n获取远程非master分支 -b 后是新建分支名称\ngit checkout -b branchName origin/branchName 获取指定分支 使用git拉代码时可以使用 -b 指定分支，拉取 develop 分支代码：\ngit clone -b develop http://gitslab.yiqing.com/declare/about.git 查看当前项目拉的是哪个分支的代码详情：\ngit branch -v 查看分支上的递交情况:\ngit show-branch 获取最新的远程仓库分支 远程仓库拉取代码并合并到本地，可简写为 git pull 等同于 git fetch \u0026\u0026 git merge\ngit pull  : # 取回远程仓库的变化，并与本地分支合并 git pull origin branchName # 使用rebase的模式进行合并 git pull --rebase  : # 获取远程仓库特定分支的更新 git fetch   # 获取远程仓库所有分支的更新 git fetch --all 问题：For those who found this searching for an answer to fatal: 'origin/remote-branch-name' is not a commit and a branch 'local-branch-name' cannot be created from it, you may also want to try this first:\ngit fetch --all 与 git pull 不同的是 git fetch 操作仅仅只会拉取远程的更改，不会自动进行 merge 操作。对你当前的代码没有影响。\ngit rebase 让你的提交记录更加清晰可读\nrebase 翻译为变基，他的作用和 merge 很相似，用于把一个分支的修改合并到当前分支上。\n即逐个应用了 mater 分支的更改，然后以 master 分支最后的提交作为基点，再逐个应用 feature 的每个更改。\n大部分情况下，rebase 的过程中会产生冲突的，此时，就需要手动解决冲突，然后使用依次 git add  、git rebase --continue  的方式来处理冲突，完成 rebase 的过程，如果不想要某次 rebase 的结果，那么需要使用 git rebase --skip  来跳过这次 rebase 操作。\ngit merge 和 git rebase 的区别\n不同于 git rebase 的是，git merge 在不是 fast-forward（快速合并）的情况下，会产生一条额外的合并记录，类似 Merge branch 'xxx' into 'xxx' 的一条提交信息。\n另外，在解决冲突的时候，用 merge 只需要解决一次冲突即可，简单粗暴，而用 rebase 的时候 ，需要依次解决每次的冲突，才可以提交。\n同一台电脑配置多个 GItHub 账号 在日常使用 git 作为仓库使用的时候，有时可能会遇到这样的一些情况：\n 有两个 github 账号，一台电脑怎么同时连接这两个账号进行维护呢？ 自己用一个 github 账号，平时用来更新自己的一些资料；公司使用的 gitlab（也是 git 的衍生产品）  如下是解决方案：\n  创建默认 SSH Key\nssh-keygen -t rsa -C \"one@example.com\"   将公钥添加到 one@example.com 的 GitHub SSH key 中。\n  测试 ssh key 是否成功\nssh -T git@github.com   如果设置过全局，则清除 git 的全局设置\n# 查看当前配置 git config --list # 取消 global user.name user.email git config --global --unset user.name git config --global --unset user.email   生成另外一个账号新的SSH keys\nssh-keygen -t rsa -C \"two@example.com\" 私钥需重命名，如 id_rsa_two。然后将对应的公钥添加到two@example.com的 Github SSH key 中。\n  需添加新私钥到 SSH agent 中，因为默认只读取 id_rsa\n# Windows 在管理员下运行 Get-Service ssh-agent Set-Service ssh-agent -StartupType Manual Start-Service ssh-agent # Linux eval `ssh-agent -s` # 添加私钥 ssh-add ~/.ssh/id_rsa_new unable to start ssh-agent service\nCould not open a connection to your authentication agent\n  配置 ~/.ssh/config 文件，用于配置私钥对应的服务器\n# Default github user(one@example.com) Host git@github.com HostName github.com User \"Your GitHub Account Name\" IdentityFile ~/.ssh/id_rsa # another user(two@example.com) # 建一个别名，新建的帐号使用这个别名做克隆和更新 # \"Host\" 如果带了 \"git@\"，如 \"git@two.github.com\"，就会连接到 two.github.com # \"Host\" 没有带 \"git@\"，就会正确的连接到 github.com Host two.github.com HostName github.com User \"Your GitHub Account Name\" IdentityFile ~/.ssh/id_rsa_two 测试\n# default ssh -T git@github.com # another ssh -T git@two.github.com 可能需要重启系统\n$ sudo systemctl reboot   使用\n# default git remote add origin git@github.com:one/demo.git # another git remote add origin git@two.github.com:two/demo.git   设置每个项目的自己的 user.name 和 user.email\ngit config user.email \"two@example.com\" git config user.name \"two\"   Git 中 HTTPS 和 SSH 的 Clone 方式区别  HTTPS：不管是谁，拿到url随便clone，但是在push的时候需要验证用户名和密码； SSH：clone的项目你必须是拥有者或者管理员，而且需要在clone前添加SSH Key。SSH 在push的时候，是不需要输入用户名的，如果配置SSH key的时候设置了密码，则需要输入密码的。  本地仓库 初始化仓库 生成 .git 目录, 也就是当前目录的仓库，当前目录称为“附属于该仓库的工作树”\ngit init [project-name] 查看仓库的状态 git status # 显示有变更的文件 向暂存区添加文件   添加指定文件到暂存区\ngit add [file1] [file2] ...   添加指定目录到暂存区，包括子目录\ngit add [dir]   添加当前目录的所有文件到暂存区\ngit add .   删除工作区文件，并且将这次删除放入暂存区\ngit rm [file1] [file2] ...   改名文件，并且将这个改名放入暂存区\ngit mv [file-original] [file-renamed]   原理（git add 为如下两步简写）：\n  为 example.txt 创建一个副本。git hash-object 命令把 example.txt 的当前内容压缩成二进制文件，称为一个 Git 对象，保存在 .git/objects 目录。并计算当前内容的哈希值，前 2 个字符作为目录名，后 38 个字符作为该对象的文件名\ngit hash-object -w example.txt 二进制对象里面会保存一些元数据，如果想看该文件原始的文本内容，需用git cat-file命令\ngit cat-file -p e69de29bb2d1d6434b8b29ae775ad8c2e48c5391   所有变动的文件，Git 都记录在\"暂存区\"，git update-index 命令用于在暂存区记录一个发生变动的文件\ngit update-index --add --cacheinfo 100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 example.txt git ls-files 命令显示暂存区当前内容\ngit ls-files --stage   查看更改前后的差别 习惯：git commit 前先 git diff HEAD\ngit diff 默认查看工作树和暂存区的差别\nHEAD查看工作树与最新提交的差别，HEAD 为指向当前分支中最新一次提交的指针，HEAD^ 指向 HEAD 的前一个提交，HEAD~6 则是 HEAD 之前的第6个提交。每一个分支都是一个文本文件，保存在 .git/refs/heads/ 目录中，文件的内容是最新提交的哈希值\ngit diff [HEAD] 将暂存区中文件保存到仓库历史记录中 -m 用于记录一行信息；不加 -m 记录详细信息，会新开编辑器进行编辑\n  相当与 git add 与 git commit\ngit commit -am \"Message\"   提交暂存区的指定文件到仓库区\ngit commit [file1] [file2] ... -m \"Message\"   提交工作区自上次commit之后的变化，直接到仓库区\ngit commit -a   提交时显示所有diff信息\ngit commit -v   原理（git commit -m \"first commit\" 为如下两步简写）：\n  git write-tree 命令保存当前的目录结构，生成一个 Git 对象\ngit write-tree   git commit-tree 命令用目录结构 Git 对象生成一个 Git 对象，需添加提交说明，-p 参数用来指定父提交\necho \"first commit\" | git e5a60f66d9966270c835343d4facc1c4bf44ed7a -p c9053865e9dff393fd2f7a92a18f9bd7f2caa7fa   修改提交信息 产生一个新的提交对象，替换掉上一次提交产生的提交对象\ngit commit --amend -m \"Message\" 重做上一次 commit，并包括指定文件的新变化\ngit commit --amend [file1] [file2] ... 压缩历史 用于拼错单词等简单的错误，选定当前分支中包含 HEAD（最新提交）在内的 number 个最新历史记录为对象并在编辑器中打开，pick 为合并对象，fixup 为被合并对象，最后 pick 提交信息会保留\ngit rebase -i HEAD~[number] 查看提交日志   --pretty=short 用于只显示第一行简述信息\n  FileName 为文件名或目录名，只显示指定文件的日志\n  -p 用于显示文件的改动\n  --stat 显示 commit 历史，以及每次 commit 发生变更的文件\ngit log [--pretty=short][FileName][-p][--stat] # 显示当前分支的版本历史   查看文件每次提交的diff\ngit log -p FileName   搜索提交历史，根据关键词\ngit log -S [keyword]   显示某个 commit 之后的所有变动，每个commit占据一行\ngit log [tag] HEAD --pretty=format:%s   显示某个 commit 之后的所有变动，其\"提交说明\"必须符合搜索条件\ngit log [tag] HEAD --grep feature   显示某个文件的版本历史，包括文件改名\ngit log --follow [file] git whatchanged [file]   git log 的运行过程\n 查找 HEAD 指针对应的分支 找到分支的最新提交 找到父节点（前一个提交） 依此类推，显示当前分支的所有提交  查看当前仓库操作日志 git reflog 怎么查看当前的git分支是基于哪个分支创建的\ngit reflog --date=local | grep \n类似于如下\n6b3db1f HEAD@{Fri Jul 9 16:05:23 2021}: checkout: moving from development to feature/api_xiongwen_dump 可知 feature/api_xiongwen_dump 基于 development\n从暂存区撤销文件 停止追踪指定文件，但该文件会保留在工作区\ngit rm --cached [filename] 撤销提交 在当前提交后面，新增一次提交，抵消掉上一次提交导致的所有变化\ngit revert HEAD 想抵消多个提交，必须在命令行依次指定这些提交\ngit revert [倒数第一个提交] [倒数第二个提交] 回溯历史版本   重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变\ngit reset [file]   重置暂存区与工作区，与上一次 commit 保持一致\ngit reset --hard   让最新提交的指针回到以前某个时点，该时点之后的提交都从历史中消失\ngit reset 目标时间点哈希值 # 重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变   默认情况下，git reset不改变工作区的文件（但会改变暂存区），--hard参数可以让工作区里面的文件也回到以前的状态\ngit reset --hard 目标时间点哈希值 # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致   重置当前 HEAD 为指定 commit，但保持暂存区和工作区不变\ngit reset --keep [commit]   添加远程仓库 origin 为远程仓库的标识符\ngit remote add origin SSH # 增加一个新的远程仓库，并命名 git remote -v # 显示所有远程仓库 git remote show [remote] # 显示某个远程仓库的信息 推送至远程仓库  推送的是当前分支 -u 在推送的同时将远程仓库的（origin仓库）的 branch 分支设为本地仓库当前分支的 upstream（上游） 运行 git pull 从远程仓库获取内容时，就可以省略参数  git push [-u origin branchName] # 上传本地指定分支到远程仓库 git push --set-upstream origin [branchName] # To push the current branch and set the remote as upstream 如果每次 git push 都需要输入账号和密码\n  首先在 git 工作目录下：\ngit config [--global] credential.helper store   然后执行一次 git pull，这次输入账号和密码之后就不用再输入了。\n  Git push existing repo to a new and different remote repo server? 需求：从公司的账户 clone repo 到本地，添加注释，pull 到自己账户的私有 repo 中。\n Create a new repo at github. git remote rename origin upstream git remote add origin URL_TO_GITHUB_REPO git push origin master  Now you can work with it just like any other github repo. To pull in patches from upstream, simply run git pull upstream master \u0026\u0026 git push origin master.\n分支 创建并切换分支 # 切换分支，并更新工作区 git checkout branchName #切换至上一分支 git checkout - # 新建一个分支，并切换到该分支 git checkout -b branchName # 新建本地分支，但不切换 git branch  # 新建一个分支，指向指定commit git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 git branch --track [branch] [remote-branch] 以图表形式查看分支 git log --graph 显示分支 # 列出所有本地分支 git branch # 列出所有远程分支 git branch -r # 同时显示本地仓库和远程仓库的分支信息 git branch -a # 用于创建分支 git branch branchName # 本地分支对应哪个远程分支 git branch -vv 合并分支  --no-ff 用于记录本次分支合并 消除冲突：打开冲突的文件，在编辑器中改为想要的样子  git merge [--no-ff] branchName # 合并指定分支到当前分支 git cherry-pick [commit] # 选择一个 commit，合并进当前分支 删除分支   删除分支\n# 删除本地分支 git branch -d [branch-name]   删除远程分支\ngit push origin --delete [branch-name] git branch -dr [remote/branch]   撤销工作区的文件修改   先找暂存区，如果该文件有暂存的版本，则恢复该版本，否则恢复上一次提交的版本\ngit checkout -- [filename]   恢复某个 commit 的指定文件到暂存区和工作区\ngit checkout [commit] [file]   恢复暂存区的所有文件到工作区\ngit checkout .   分支重命名   重命名本地分支：\n  在当前分支时\ngit branch -m new_branch_name   当不在当前分支时\ngit branch -m old_branch_name new_branch_name     重命名远端分支：\n假设是在当前分支，并且远端分支与本地分支名是一致的重命名本地分支\ngit branch -m new_branch_name 删除远程分支\ngit push --delete origin old_branch_name 上传新命名的本地分支\ngit push origin new_branch_name 关联修改后的本地分支与远程分支\ngit branch --set-upstream-to origin/new_branch_name   标签   列出所有 tag\ngit tag   新建一个 tag 在当前commit\ngit tag [tag]   新建一个tag在指定commit\ngit tag [tag] [commit]   删除本地 tag\ngit tag -d [tag]   删除远程 tag\ngit push origin :refs/tags/[tagName]   查看 tag 信息\ngit show [tag]   提交指定 tag\ngit push [remote] [tag]   提交所有tag\ngit push [remote] --tags   新建一个分支，指向某个tag\ngit checkout -b [branch] [tag]   Git Ignore git 为我们提供了一个 .gitignore 文件，只要在这个文件中申明哪些文件你不希望添加到git中去，这样当你使用 git add . 的时候这些文件就会被自动忽略掉。\n经实验，可以为每一个平行非包含的目录设定一个 .gitignore。\nPull Request 当你想更正别人仓库里的错误时，要走一个流程：\n 先 fork 别人的仓库，相当于拷贝一份，相信我，不会有人直接让你改修原仓库的。 clone 到本地分支，做一些 bug fix。 发起 pull request 给原仓库，让他看到你修改的 bug。 原仓库 review 这个 bug，如果是正确的话，就会 merge 到他自己的项目中  至此，整个 pull request 的过程就结束了。\n拉取请求，就是请求对方拉取我本地仓库的 bug fix，合并到对方的 repo 中。以对方的视角来看，我的本地仓库就是一个远程仓库。因为我们是在请求对方做什么，所以要以对方视角来看，即 pull，因为对方可能同意，也可能不同意，所以是请求，即 pull request。\nGitHub Hosts GitHub520 本项目无需安装任何程序，通过修改本地 hosts 文件，试图解决：\n GitHub 访问速度慢的问题 GitHub 项目中的图片显示不出的问题  花 5 分钟时间，让你\"爱\"上 GitHub。\n# GitHub520 Host Start 140.82.112.26 alive.github.com 140.82.114.25 live.github.com 185.199.108.154 github.githubassets.com 140.82.113.22 central.github.com 185.199.108.133 desktop.githubusercontent.com 185.199.108.153 assets-cdn.github.com 185.199.108.133 camo.githubusercontent.com 185.199.108.133 github.map.fastly.net 199.232.69.194 github.global.ssl.fastly.net 140.82.113.4 gist.github.com 185.199.108.153 github.io 140.82.114.3 github.com 140.82.114.5 api.github.com 185.199.108.133 raw.githubusercontent.com 185.199.108.133 user-images.githubusercontent.com 185.199.108.133 favicons.githubusercontent.com 185.199.108.133 avatars5.githubusercontent.com 185.199.108.133 avatars4.githubusercontent.com 185.199.108.133 avatars3.githubusercontent.com 185.199.108.133 avatars2.githubusercontent.com 185.199.108.133 avatars1.githubusercontent.com 185.199.108.133 avatars0.githubusercontent.com 185.199.108.133 avatars.githubusercontent.com 140.82.112.10 codeload.github.com 52.216.170.203 github-cloud.s3.amazonaws.com 52.217.98.76 github-com.s3.amazonaws.com 52.216.164.3 github-production-release-asset-2e65be.s3.amazonaws.com 52.216.160.147 github-production-user-asset-6210df.s3.amazonaws.com 52.217.103.12 github-production-repository-file-5c1aeb.s3.amazonaws.com 185.199.108.153 githubstatus.com 64.71.168.201 github.community 185.199.108.133 media.githubusercontent.com # Update time: 2021-07-04T08:07:49+08:00 # Star me GitHub url: https://github.com/521xueweihan/GitHub520 # GitHub520 Host End GitHub Pages 使用 GitHub GitHub Pages 是一项静态站点托管服务，它直接从 GitHub 上的仓库获取 HTML、CSS 和 JavaScript 文件，（可选）通过构建过程运行文件，然后发布网站。\n有三种类型的 GitHub Pages 站点：项目、用户和组织。 项目站点连接到 GitHub 上托管的特定项目。 用户和组织站点连接到特定的 GitHub 帐户。\nTo publish a user site, you must create a repository owned by your user account that’s named . Repositories using the legacy  naming scheme will still be published, but visitors will be redirected from http(s):// to http(s)://. If both a  and  repository exist, only the  repository will be published.\nGitHub Pages sites are publicly available on the internet, even if the repository for the site is private or internal. 如果站点的仓库中有敏感数据，您可能想要在发布前删除它。\nGitHub Pages 站点的发布来源是存储站点源文件的分支和文件夹。用户和组织站点的默认发布源是仓库默认分支的根目录。 项目站点的默认发布来源是 gh-pages 分支的根目录。\n您可以创建自己的静态文件或使用静态站点生成器为您构建站点。默认情况下，GitHub Pages 将使用 Jekyll 来构建您的站点。\nGitHub Pages 站点受到以下使用限制的约束：\n GitHub Pages source repositories have a recommended limit of 1GB. 发布的 GitHub Pages 站点不得超过 1 GB。 GitHub Pages sites have a soft bandwidth limit of 100GB per month. GitHub Pages sites have a soft limit of 10 builds per hour.  可在 Repository 的 Settings 中配置 GitHub Pages 站点的发布源或取消发布 GitHub Pages 站点。\n使用 jekyll Github Docs 与 Jekyll 文档不一致，Windows 并未正式支持 Jekyll。\n使用 Hexo 我选择 Hexo，一个是安装简单；一个是文档好。\nGitHub Actions GitHub Actions 是什么 持续集成由很多操作组成，比如自动抓取代码、运行测试、登录远程服务器、发布到第三方服务等。GitHub 把这些操作就称为 actions。\n很多操作在不同项目里面是类似的，可以共享。GitHub 允许开发者把每个操作写成独立的脚本文件，存放到代码仓库，使得其他开发者可以引用。\n可在官方市场与 awesome actions 找 action。\nworkflow 文件 GitHub Actions 的配置文件叫做 workflow 文件，存放在代码仓库的 .github/workflows 目录。\nworkflow 文件采用 YAML 格式，一个库可以有多个 workflow 文件。GitHub 发现 .github/workflows 目录里有 .yml 文件，就会自动运行该文件。\n配置字段：\n  name：工作流程的名称。如果省略 name，GitHub 将其设置为相对于仓库根目录的工作流程文件路径\n  on：必要，触发工作流程的 GitHub 事件的名称\non: [push, pull_request]   on..：您可以将工作流配置为在特定分支或标记上运行\non: push: branches: - main - 'mona/octocat' - 'releases/**' tags: - v1 - v1.*    jobs：工作流程运行包括一项或多项作业。每项作业必须关联一个 ID\n  jobs..name：job_id 里面的 name 字段是任务的说明\njobs: my_first_job: name: My first job my_second_job: name: My second job   jobs..needs：作业默认是并行运行。needs字段指定当前任务的运行顺序\njobs: job1: job2: needs: job1 job3: needs: [job1, job2] 此例中作业执行顺序：job1、job2、job3\n  jobs..runs-on：必需，运行作业的机器类型\nruns-on: ubuntu-latest     jobs..steps：作业包含一系列任务，称为 steps\n  jobs..steps.name：步骤名称\n  jobs..steps.uses：引用的 Actions\nsteps: # Reference a specific commit - uses: actions/setup-node@74bc508 # Reference a minor version of a release - uses: actions/setup-node@v1.2 # Reference a branch - uses: actions/setup-node@main   jobs..steps.run：使用操作系统 shell 运行命令行程序\n- name: Clean install dependencies and build run: |npm ci npm run build     参考 GitHub Actions 入门教程\nGitHub Actions\n持续集成（Continuous integration，简称CI） 概念 持续集成指的是，频繁地（一天多次）将代码合并（集成）到主干源码仓库。在 CI 中可以通过自动化等手段高频率地去获取产品反馈并响应反馈的过程。\n流程  提交：开发者向代码仓库提交代码 测试（第一轮）：代码仓库对提交的代码跑自动化测试  单元测试：针对函数或模块的测试 集成测试：针对整体产品的某个功能的测试，又称功能测试 端对端测试：从用户界面直达数据库的全链路测试   构建：将源码转换为可以运行的实际代码，会安装依赖，配置各种资源等。常用的构建工具如下  Jenkins：开源 Travis Codeship Strider：开源   测试（第二轮）：第二轮是全面测试 部署：直接部署 回滚：当前版本发生问题，回滚到上一个版本的构建结果  Commit message 社区有多种 Commit Message Conventions。本文介绍 Angular 规范。\n格式化的 Commit message 好处   提供更多的历史信息，方便浏览\ngit log HEAD --pretty=format:%s   可以过滤某些 commit，便于查找信息\ngit log HEAD --grep feature   可以直接从 commit 生成 Change Log\n  Commit message 的格式 ():  // 空一行  // 空一行    Header 只有一行\n type 用于说明 commit 的类别  feat：新功能 fix：修补bug docs：文档 style： 格式 refactor：重构 test：增加测试 chore：构建过程或辅助工具的变动 Revert：当前 commit 用于撤销以前的 commit   scope 用于说明 commit 影响的范围 subject 是 commit 目的的简短描述  以动词开头，使用第一人称现在时 第一个字母小写 结尾不加句号      Body 部分是对本次 commit 的详细描述\n  Footer\n  不兼容变动：如果当前代码与上一个版本不兼容，则以 BREAKING CHANGE 开头，后面是对变动的描述、以及变动理由和迁移方法\n  关闭 Issue：如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue\nCloses #123, #245, #992     Commitizen Commitizen 是一个撰写 Commit message 的工具\n  Install the Commitizen cli tools\nnpm install commitizen -g   Initialize your project to use the cz-conventional-changelog adapter\ncommitizen init cz-conventional-changelog --save-dev --save-exact   以后，凡是用到 git commit 命令，一律改为使用 git cz。\n  参考 Commit message 和 Change log 编写指南\nYAML（YAML Ain’t a Markup Language） YAML 是专门用来写配置文件的语言\n简介 规则：\n 大小写敏感 使用缩进表示层级关系 缩进时不允许使用 Tab 键，只允许使用空格。 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 # 表示注释，从这个字符一直到行尾，都会被解析器忽略 对象和数组可以结合使用，形成复合结构  对象 一组键值对\nanimal: pets 行内表示法\nhash: { name: Steve, foo: bar }  数组 一组连词线开头的行\n- Cat - Dog - Goldfish 数据结构的子成员是一个数组，则可以在该项下面缩进一个空格\n- - Cat - Dog - Goldfish 行内表示法\nanimal: [Cat, Dog] 纯量   字符串：字符串默认不使用引号表示\nstr: 这是一行字符串 包含空格或特殊字符，需要放在引号之中，单引号和双引号都可以使用，双引号不会对特殊字符转义\nstr: '内容： 字符串' 单引号之中如果还有单引号，必须连续使用两个单引号转义\nstr: 'labor''s day' 字符串可以写成多行，从第二行开始，必须有一个单空格缩进。换行符会被转为空格\nstr: 这是一段 多行 字符串 多行字符串可以使用|保留换行符，也可以使用折叠换行\nthis: |Foo Bar that: Foo Bar +表示保留文字块末尾的换行，-表示删除字符串末尾的换行\ns1: | Foo s2: |+ Foo s3: |- Foo\n  字符串之中可以插入 HTML 标记 ```yaml message: | 段落 参考 YAML 语言教程\nThe Official YAML Web Site\n开源许可证 一般情况下，软件的源代码只由编写者拥有，而开源（即开放源代码，Open Source Code）是指一种更自由的软件发布模式。简单来说，开源软件的特点就是把软件程序和源代码文件一起打包提供给用户，让用户在不受限制地使用某个软件功能的基础上还可以对代码按需修改，让软件更贴合硬件环境，让功能更符合工作需求。用户还可以将其编制成衍生产品再发布出去。用户一般享有使用自由、复制自由、修改自由、创建衍生品自由，以及收费自由。是的，您没有看错，用户具备创建衍生品和收费的自由。这也就是说，可以对一个开源软件进行深度定制化加工。如果修改过的程序更加好用，或者颇具新的特色，只要符合原作者的许可要求，我们就完全可以合法地将软件进行商标注册，以商业版的形式再发布出去，只要有新用户使用您的软件并支付相应的费用，那就是您的收入。这也正好符合了黑客和极客对自由的追求，因此在合作与竞争中，国内外的开源社区慢慢生长出了强健的根基，人气也非常高。\n但是，如果开源软件只单纯追求“自由”而牺牲了程序员的利益，这肯定会影响程序员的创作热情。为了平衡两者的关系，截至目前，世界上已经有100多种被开源促进组织（OSI，Open Source Initiative）确认的开源许可证，用于保护开源工作者的权益。对于那些只知道一味抄袭、篡改、破解或者盗版他人作品的不法之徒，终归会在某一天收到法院的传票。\n考虑到大家没准儿以后会以开源工作者的身份编写出一款畅销软件，因此刘遄老师根据开源促进组织的推荐建议以及实际使用情况，为大家筛选出了程序员最喜欢的前6名的开源许可证，并教大家怎么从中进行选择。提前了解最热门的开源许可证，并在未来选择一个合适的可最大程度地保护自己软件权益的开源许可证，这对创业公司来讲能起到事半功倍的作用。\n开源许可证总览：https://opensource.org/licenses/alphabetical\nTips：上述提到的“开源许可证”与“开源许可协议”的含义完全相同，只不过是英文翻译后两种不同的叫法，这里不作区别。\nTips：自由软件基金会（Free Software Foundation，FSF）是一个非营利组织，其使命是在全球范围内促进计算机用户的自由，捍卫所有软件用户的权利。\n大家经常会在开源社区中看到Copyleft这个单词，这是一个由自由软件运动所发展出的概念，中文被翻译为“著佐权”或者“公共版权”。与Copyright截然相反，Copyleft不会限制使用者复制、修改或再发布软件。\n此外，大家应该经常会听到别人说开源软件是free的，没错，开源软件就是自由的。这里的free千万不要翻译成“免费”，这样就大错特错了，这与您去酒吧看到的“第一杯免费”的意思可相差甚远。\n下面我们来看一下程序员最喜欢的前6名的开源许可证，以及它们各自赋予用户的权利。\nGPL **GNU通用公共许可证（**General Public License，GPL）：目前广泛使用的开源软件许可协议之一，用户享有运行、学习、共享和修改软件的自由。GPL最初是自由软件基金会创始人Richard Stallman起草的，其版本目前已经发展到了第3版。GPL的目的是保证程序员在开源社区中所做的工作对整个世界是有益的，所开发的软件也是自由的，并极力避免开源软件被私有化以及被无良软件公司所剥削。\n现在，只要软件中包含了遵循GPL许可证的产品或代码，该软件就必须开源、免费，因此这个许可证并不适合商业收费软件。遵循该许可证的开源软件数量极其庞大，包括Linux内核在内的大多数的开源软件都是基于GPL许可证的。GPL赋予了用户著名的五大自由。\n **使用自由：**允许用户根据需要自由使用这个软件。\n**复制自由：**允许把软件复制到任何人的计算机中，并且不限制复制的数量。\n**修改自由：**允许开发人员增加或删除软件的功能，但软件修改后必须依然基于GPL许可证。\n**衍生自由：**允许用户深度定制化软件后，为软件注册自己的新商标，再发行衍生品的自由。\n**收费自由：**允许在各种媒介上出售该软件，但必须提前让买家知道这个软件是可以免费获得的。因此，一般来讲，开源软件都是通过为用户提供有偿服务的形式来营利的。\n LGPL 较宽松通用公共许可证（Lesser GPL, LGPL）：一个主要为保护类库权益而设计的GPL开源协议。与标准GPL许可证相比，LGPL允许商业软件以类库引用的方式使用开源代码，而不用将其产品整体开源，因此普遍被商业软件用来引用类库代码。简单来说，就是针对使用了基于LGPL许可证的开源代码，在涉及这部分代码，以及修改过或者衍生出来的代码时，都必须继续采用LGPL协议，除此以外的其他代码则不强制要求。\n如果您觉得LGPL许可证更多地是关注对类库文件的保护，而不是软件整体，那就对了。因为该许可证最早的名字是Library GPL，即GPL类库开源许可证，保护的对象有glibc、GTK widget toolkit等类库文件。\nBSD **伯克利软件发布版（**Berkeley Software Distribution, BSD）许可证：另一款被广泛使用的开源软件许可协议。相较于GPL许可证，BSD更加宽松，适合于商业用途。用户可以使用、修改和重新发布遵循该许可证的软件，并且可以将软件作为商业软件发布和销售，前提是需要满足下面3个条件。\n 如果再发布的软件中包含开源代码，则源代码必须继续遵循BSD许可证。\n如果再发布的软件中只有二进制程序，则需要在相关文档或版权文件中声明原始代码遵循了BSD许可证。\n不允许用原始软件的名字、作者名字或机构名称进行市场推广。\n Apache Apache许可证（Apache License）：顾名思义，是由Apache软件基金会负责发布和维护的开源许可协议。作为当今世界上最大的开源基金会，Apache不仅因此协议而出名，还因市场占有率第一的Web服务器软件而享誉行业。目前使用最广泛的Apache许可证是2004年发行的2.0版本，它在为开发人员提供版权及专利许可的同时，还允许用户拥有修改代码及再发布的自由。该许可证非常适合用于商业软件，现在热门的Hadoop、Apache HTTP Server、MongoDB等项目都是基于该许可证研发的。程序开发人员在开发遵循该许可证的软件时，要严格遵守下面4个条件。\n 该软件及其衍生品必须继续使用Apache许可证。\n如果修改了程序源代码，需要在文档中进行声明。\n若软件是基于他人的源代码编写而成的，则需要保留原始代码的许可证、商标、专利声明及原作者声明的其他内容信息。\n如果再发布的软件中有声明文件，则需在此文件中注明基于了Apache许可证及其他许可证。\n MIT MIT许可证（Massachusetts Institute of Technology License）：源于麻省理工学院，又称为X11协议。MIT许可证是目前限制最少的开源许可证之一，用户可以使用、复制、修改、再发布软件，而且只要在修改后的软件源代码中保留原作者的许可信息即可，因此普遍被商业软件（例如jQuery与Node.js）所使用。也就是说，MIT许可证宽松到一个新境界，即用户只要在代码中声明了MIT许可证和版权信息，就可以去做任何事情，而无须承担任何责任。\nMPL **Mozilla公共许可证（**Mozilla Public License，MPL）：于1998年初由Netscape公司的Mozilla小组设计，原因是它们认为GPL和BSD许可证不能很好地解决开发人员对源代码的需求和收益之间的平衡关系，因此便将这两个协议进行融合，形成了MPL。2012年年初，Mozilla基金会发布了MPL 2.0版本（目前为止也是最新的版本），后续被用在Firefox、Thunderbird等诸多产品上。最新版的MPL公共许可证有以下特点。\n 在使用基于MPL许可证的源代码时，后续只需要继续开源这部分特定代码即可，新研发的软件不用完全被该许可证控制。\n开发人员可以将基于MPL、GPL、BSD等多种许可证的代码一起混合使用。\n开发人员在发布新软件时，必须附带一个专门用于说明该程序的文件，内容要有原始代码的修改时间和修改方式。\n 总结 估计大家在看完上面琳琅满目的许可证后，会心生怨念：“这不都差不多吗？到底该选哪个呢？”写到这里时，刘遄老师也是一脸无助：“到底该怎么让大家进行选择呢？”搜肠刮肚之际突然眼前一亮，乌克兰程序员Paul Bagwell创作的一幅流程图正好对刚才讲过的这6款开源许可证进行了汇总归纳，具体如下图所示。\n开源许可证的选择流程图\n众所周知，绝大部分的开源软件在安装完毕之后即可使用，很难在软件界面中找到相关的收费信息。所以经常会有同学提问：“刘老师，开源社区的程序员总要吃饭的呀，他们是靠什么营利呢？”针对这个问题，网络上好像只有两种声音：\n **情怀——**开源社区的程序员觉悟好，本领强，写代码纯粹是为了兴趣以及造福社会；\n**服务——**先让用户把软件安装上，等用好、用习惯之后，再通过提供一些维护服务来营利。\n 这两种解释都各有道理，但是不够全面。读者也不要把开源软件和商业软件完全对立起来，因为好的项目也需要好的运营模式。就开源软件来讲，营利模式具体包括以下5种。\n 多条产品线：如MySQL数据库便有个人版和企业版两个版本，即个人版完全免费，起到了很好的推广作用；企业版则通过销售授权许可来营利。\n技术服务型：JBoss应用服务器便是典型代表，JBoss软件可自由免费使用，软件提供方通过技术文档、培训课程以及定制开发服务来盈利。\n软硬件结合：比如IBM公司在出售服务器时，一般会为用户捆绑销售AIX或Linux系统来确保硬件设施的营利。\n技术出版物：比如O’Reilly既是一家开源公司，也是一家出版商，诸多优秀图书都是由O’Reilly出版的。\n品牌和口碑：微软公司曾多次表示支持开源社区。大家对此可能会感到意外，但这是真的！Visual Studio Code、PowerShell、TypeScript等软件均已开源。大家是不是瞬间就对微软公司好感倍增了呢？买一份正版系统表示支持也就是人之常情了。\n SSH 原理与运用 数字签名与数字证书 鲍勃有两把钥匙，一把是公钥，另一把是私钥。\n鲍勃把公钥送给他的朋友们——帕蒂、道格、苏珊——每人一把。\n苏珊要给鲍勃写一封保密的信。她写完后用鲍勃的公钥加密，就可以达到保密的效果。\n鲍勃收信后，用私钥解密，就看到了信件内容。只要鲍勃的私钥不泄露，这封信就是安全的，即使落在别人手里，也无法解密。\n鲍勃给苏珊回信，决定采用\"数字签名\"。他写完后先用Hash函数，生成信件的摘要（digest）。\n然后，鲍勃使用私钥，对这个摘要加密，生成\"数字签名\"（signature）。\n鲍勃将这个签名，附在信件下面，一起发给苏珊。\n苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。\n苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。\n复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。此时，苏珊实际拥有的是道格的公钥，但是还以为这是鲍勃的公钥。因此，道格就可以冒充鲍勃，用自己的私钥做成\"数字签名\"，写信给苏珊，让苏珊用假的鲍勃公钥进行解密。\n后来，苏珊感觉不对劲，发现自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去找\"证书中心\"（certificate authority，简称CA），为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成\"数字证书\"（Digital Certificate）。\n鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。\n苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明\"数字签名\"是否真的是鲍勃签的。\n远程登录   1995年，芬兰学者 Tatu Ylonen 设计了 SSH 协议，用于计算机之间的加密登录。本文针对的实现是 OpenSSH。\n  基本用法：\n  假定你要以用户名 user，登录远程主机 host\nssh user@host   如果本地用户名与远程用户名一致，登录时可以省略用户名\nssh host   SSH 的默认端口是 22，使用 p 参数修这个端口\nssh -p 2222 user@host     中间人攻击（Man-in-the-middle attack）\n  SSH 加密登录过程\n 远程主机收到用户的登录请求，把自己的公钥发给用户。 用户使用这个公钥，将登录密码加密后，发送给远程主机。 远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。      中间人攻击：攻击者插在用户与远程主机之间，用伪造的公钥，获取用户的登录密码，再用这个密码登录远程主机。\n  口令登录：第一次登录远程主机时，会询问是否接受远程主机公钥（是否继续连接），并显示公钥指纹——公钥长度较长（这里采用RSA算法，长达 1024 位），很难比对，所以对其进行MD5计算，将它变成一个 128 位的指纹。用户通过比对远程网站上贴出的公钥指纹，决定是否接受这个远程主机的公钥。当远程主机的公钥被接受以后，它就会被保存在文件 $HOME/.ssh/known_hosts 之中。\n  公钥登录：省去口令登录每次都必须输入密码的步骤。用户将自己的公钥储存在远程主机上，登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来，远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。\n  ssh-keygen\n在 $HOME/.ssh/ 目录下生成两个文件：公钥 id_rsa.pub 和私钥 id_rsa。\n    远程操作与端口转发   SSH 可以在用户和远程主机之间，建立命令和数据的传输通道\n  绑定本地端口：让那些不加密的网络连接，全部改走 SSH 连接\nssh -D 8080 user@host 建立一个 socket，去监听本地的 8080 端口。一旦有数据传向那个端口，就自动把它转移到 SSH 连接上面，发往远程主机。\n  本地端口转发：假定 host1 是本地主机，host2 是远程主机。由于种种原因，这两台主机之间无法连通。但是，另外还有一台 host3，可以同时连通前面两台主机。因此，很自然的想法就是，通过 host3，将 host1 连上 host2。\nssh -L 2121:host2:21 host3 L 参数接受三个值——“本地端口:目标主机:目标主机端口”。SSH 绑定本地端口 2121，指定 host3 将所有的数据转发到目标主机 host2 的 21 端口。本地端口转发使得 host1 和 host3 之间仿佛形成一个数据传输的秘密隧道，因此又被称为\"SSH 隧道\"。\n  远程端口转发：host1 与 host2 之间无法连通，必须借助 host3 转发，而 host3 是一台内网机器，它可以连接外网的 host1，但是反过来就不行。解决办法是从 host3 上建立与 host1 的 SSH 连接，然后在 host1 上使用这条连接。在 host3 执行下面的命令\nssh -R 2121:host2:21 host1 R 参数也是接受三个值——“远程主机端口:目标主机:目标主机端口”。它让 host1 监听它自己的 2121 端口，然后将所有数据经由 host3，转发到 host2 的 21 端口。\n  GitHub Packages Learn to safely publish and consume packages, store your packages alongside your code, and share your packages privately with your team or publicly with the open source community. You can also automate your packages with GitHub Actions.\nTip \u0026 Questions Repository size limits for GitHub.com Hard limits:\n Individual files in a repository are strictly limited to a 100 MB maximum size limit. Repositories have a hard size limit of 100GB.  解决SSH自动断线问题 在连接远程SSH服务的时候，经常会发生长时间后的断线，或者无响应（无法再键盘输入）。 总体来说有两个方法：\n一、客户端定时发送心跳\nputty、SecureCRT、XShell都有这个功能，设置请自行搜索\n此外在Linux下：\n  修改本机/etc/ssh/ssh_config\n# vim /etc/ssh/ssh_config   添加\nServerAliveInterval 30 ServerAliveCountMax 100 即每隔30秒，向服务器发出一次心跳。若超过100次请求，都没有发送成功，则会主动断开与服务器端的连接。\n  二、服务器端定时向客户端发送心跳（一劳永逸）\n  修改服务器端 ssh配置 /etc/ssh/sshd_config\n# vim /etc/ssh/sshd_config   添加\nClientAliveInterval 30 ClientAliveCountMax 6 ClientAliveInterval表示每隔多少秒，服务器端向客户端发送心跳，是的，你没看错。\n下面的ClientAliveInterval表示上述多少次心跳无响应之后，会认为Client已经断开。\n所以，总共允许无响应的时间是60*3=180秒。\n  new mode 100755 出现\n$ git diff filename old mode 100644 new mode 100755 但是文件内容并没有发生改变\n产生这个问题的原因就是：filemode的变化，文件chmod后其文件某些位是改变了的，如果严格的比较原文件和chmod后的文件，两者是有区别的，但是源代码通常只关心文本内容，因此chmod产生的变化应该忽略，所以设置一下：\n$ git config --add core.filemode false Check if pull needed in Git First use git remote update, to bring your remote refs up to date. Then you can do one of several things, such as:\n git status -uno will tell you whether the branch you are tracking is ahead, behind or has diverged. If it says nothing, the local and remote are the same. git show-branch *master will show you the commits in all of the branches whose names end in ‘master’ (eg master and origin/master).  If you use -v with git remote update (git remote -v update) you can see which branches got updated, so you don’t really need any further commands.\nHowever, it looks like you want to do this in a script or program and end up with a true/false value. If so, there are ways to check the relationship between your current HEAD commit and the head of the branch you’re tracking, although since there are four possible outcomes you can’t reduce it to a yes/no answer. However, if you’re prepared to do a pull --rebase then you can treat “local is behind” and “local has diverged” as “need to pull”, and the other two (“local is ahead” and “same”) as “don’t need to pull”.\nYou can get the commit id of any ref using git rev-parse , so you can do this for master and origin/master and compare them. If they’re equal, the branches are the same. If they’re unequal, you want to know which is ahead of the other. Using git merge-base master origin/master will tell you the common ancestor of both branches, and if they haven’t diverged this will be the same as one or the other. If you get three different ids, the branches have diverged.\nTo do this properly, eg in a script, you need to be able to refer to the current branch, and the remote branch it’s tracking. The bash prompt-setting function in /etc/bash_completion.d has some useful code for getting branch names. However, you probably don’t actually need to get the names. Git has some neat shorthands for referring to branches and commits (as documented in git rev-parse --help). In particular, you can use @ for the current branch (assuming you’re not in a detached-head state) and @{u} for its upstream branch (eg origin/master). So git merge-base @ @{u} will return the (hash of the) commit at which the current branch and its upstream diverge and git rev-parse @ and git rev-parse @{u} will give you the hashes of the two tips. This can be summarized in the following script:\n#!/bin/sh  UPSTREAM=${1:-'@{u}'} LOCAL=$(git rev-parse @) REMOTE=$(git rev-parse \"$UPSTREAM\") BASE=$(git merge-base @ \"$UPSTREAM\") if [ $LOCAL = $REMOTE ]; then echo \"Up-to-date\" elif [ $LOCAL = $BASE ]; then echo \"Need to pull\" elif [ $REMOTE = $BASE ]; then echo \"Need to push\" else echo \"Diverged\" fi Note: older versions of git didn’t allow @ on its own, so you may have to use @{0} instead.\nThe line UPSTREAM=${1:-'@{u}'} allows you optionally to pass an upstream branch explicitly, in case you want to check against a different remote branch than the one configured for the current branch. This would typically be of the form remotename/branchname. If no parameter is given, the value defaults to @{u}.\nThe script assumes that you’ve done a git fetch or git remote update first, to bring the tracking branches up to date. I didn’t build this into the script because it’s more flexible to be able to do the fetching and the comparing as separate operations, for example if you want to compare without fetching because you already fetched recently.\nSetting the default editor for Git Pick one:\n  Set core.editor in your Git config:\ngit config --global core.editor \"vim\"   Set the GIT_EDITOR environment variable:\nexport GIT_EDITOR=vim   ",
  "wordCount" : "14764",
  "inLanguage": "en",
  "image":"https://sakamotokurome.github.io/Git/github0.png","datePublished": "2021-12-12T16:46:08+08:00",
  "dateModified": "2021-12-12T16:46:08+08:00",
  "author":{
    "@type": "Person",
    "name": "Sakamoto Kurome"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://sakamotokurome.github.io/posts/git/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Sakamoto Kurome",
    "logo": {
      "@type": "ImageObject",
      "url": "https://sakamotokurome.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://sakamotokurome.github.io/" accesskey="h" title="Sakamoto Kurome (Alt + H)">Sakamoto Kurome</a>
            <span class="logo-switches">
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://sakamotokurome.github.io/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://sakamotokurome.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://sakamotokurome.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Git
    </h1>
    <div class="post-meta"><span title='2021-12-12 16:46:08 +0800 CST'>December 12, 2021</span>&nbsp;·&nbsp;30 min&nbsp;·&nbsp;Sakamoto Kurome

</div>
  </header> 
<figure class="entry-cover"><img loading="lazy" src="https://sakamotokurome.github.io/Git/github0.png" alt="Git cover">
        <p>Git</p>
</figure><div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e8%bf%9c%e7%a8%8b%e4%bb%93%e5%ba%93" aria-label="远程仓库">远程仓库</a><ul>
                        
                <li>
                    <a href="#%e5%ae%89%e8%a3%85windows%e9%9c%80%e8%a6%81%e5%a4%84%e7%90%86%e6%8d%a2%e8%a1%8c%e7%ac%a6" aria-label="安装，windows需要处理换行符">安装，windows需要处理换行符</a></li>
                <li>
                    <a href="#%e8%ae%be%e7%bd%ae%e5%a7%93%e5%90%8d%e5%92%8c%e9%82%ae%e7%ae%b1%e5%9c%b0%e5%9d%80" aria-label="设置姓名和邮箱地址">设置姓名和邮箱地址</a></li>
                <li>
                    <a href="#%e6%8f%90%e9%ab%98%e8%be%93%e5%87%ba%e5%8f%af%e8%af%bb%e6%80%a7" aria-label="提高输出可读性">提高输出可读性</a></li>
                <li>
                    <a href="#%e8%ae%be%e7%bd%ae%e6%96%87%e4%bb%b6" aria-label="设置文件">设置文件</a></li>
                <li>
                    <a href="#%e8%ae%be%e7%bd%aessh%e6%b7%bb%e5%8a%a0%e8%ae%a4%e8%af%81%e5%af%86%e7%a0%81" aria-label="设置SSH，添加认证密码">设置SSH，添加认证密码</a></li>
                <li>
                    <a href="#%e6%b7%bb%e5%8a%a0%e5%85%ac%e5%bc%80%e5%af%86%e9%92%a5" aria-label="添加公开密钥">添加公开密钥</a></li>
                <li>
                    <a href="#%e6%9f%a5%e7%9c%8b%e6%98%af%e5%90%a6%e8%ae%a4%e8%af%81%e5%92%8c%e9%80%9a%e4%bf%a1%e6%88%90%e5%8a%9f" aria-label="查看是否认证和通信成功">查看是否认证和通信成功</a></li>
                <li>
                    <a href="#%e8%8e%b7%e5%8f%96%e8%bf%9c%e7%a8%8b%e4%bb%93%e5%ba%93" aria-label="获取远程仓库">获取远程仓库</a></li>
                <li>
                    <a href="#%e8%8e%b7%e5%8f%96%e8%bf%9c%e7%a8%8b%e9%9d%9emaster%e5%88%86%e6%94%af" aria-label="获取远程非master分支">获取远程非master分支</a></li>
                <li>
                    <a href="#%e8%8e%b7%e5%8f%96%e6%8c%87%e5%ae%9a%e5%88%86%e6%94%af" aria-label="获取指定分支">获取指定分支</a></li>
                <li>
                    <a href="#%e8%8e%b7%e5%8f%96%e6%9c%80%e6%96%b0%e7%9a%84%e8%bf%9c%e7%a8%8b%e4%bb%93%e5%ba%93%e5%88%86%e6%94%af" aria-label="获取最新的远程仓库分支">获取最新的远程仓库分支</a></li>
                <li>
                    <a href="#%e5%90%8c%e4%b8%80%e5%8f%b0%e7%94%b5%e8%84%91%e9%85%8d%e7%bd%ae%e5%a4%9a%e4%b8%aa-github-%e8%b4%a6%e5%8f%b7httpsgithubcomjawilnotesissues2" aria-label="同一台电脑配置多个 GItHub 账号"><a href="https://github.com/jawil/notes/issues/2">同一台电脑配置多个 GItHub 账号</a></a></li>
                <li>
                    <a href="#git-%e4%b8%ad-https-%e5%92%8c-ssh-%e7%9a%84-clone-%e6%96%b9%e5%bc%8f%e5%8c%ba%e5%88%abhttpswwwcnblogscomtomato0906articles8461325html" aria-label="Git 中 HTTPS 和 SSH 的 Clone 方式区别"><a href="https://www.cnblogs.com/tomato0906/articles/8461325.html">Git 中 HTTPS 和 SSH 的 Clone 方式区别</a></a></li></ul>
                </li>
                <li>
                    <a href="#%e6%9c%ac%e5%9c%b0%e4%bb%93%e5%ba%93" aria-label="本地仓库">本地仓库</a><ul>
                        
                <li>
                    <a href="#%e5%88%9d%e5%a7%8b%e5%8c%96%e4%bb%93%e5%ba%93" aria-label="初始化仓库">初始化仓库</a></li>
                <li>
                    <a href="#%e6%9f%a5%e7%9c%8b%e4%bb%93%e5%ba%93%e7%9a%84%e7%8a%b6%e6%80%81" aria-label="查看仓库的状态">查看仓库的状态</a></li>
                <li>
                    <a href="#%e5%90%91%e6%9a%82%e5%ad%98%e5%8c%ba%e6%b7%bb%e5%8a%a0%e6%96%87%e4%bb%b6" aria-label="向暂存区添加文件">向暂存区添加文件</a></li>
                <li>
                    <a href="#%e6%9f%a5%e7%9c%8b%e6%9b%b4%e6%94%b9%e5%89%8d%e5%90%8e%e7%9a%84%e5%b7%ae%e5%88%ab" aria-label="查看更改前后的差别">查看更改前后的差别</a></li>
                <li>
                    <a href="#%e5%b0%86%e6%9a%82%e5%ad%98%e5%8c%ba%e4%b8%ad%e6%96%87%e4%bb%b6%e4%bf%9d%e5%ad%98%e5%88%b0%e4%bb%93%e5%ba%93%e5%8e%86%e5%8f%b2%e8%ae%b0%e5%bd%95%e4%b8%ad" aria-label="将暂存区中文件保存到仓库历史记录中">将暂存区中文件保存到仓库历史记录中</a></li>
                <li>
                    <a href="#%e4%bf%ae%e6%94%b9%e6%8f%90%e4%ba%a4%e4%bf%a1%e6%81%af" aria-label="修改提交信息">修改提交信息</a></li>
                <li>
                    <a href="#%e5%8e%8b%e7%bc%a9%e5%8e%86%e5%8f%b2" aria-label="压缩历史">压缩历史</a></li>
                <li>
                    <a href="#%e6%9f%a5%e7%9c%8b%e6%8f%90%e4%ba%a4%e6%97%a5%e5%bf%97" aria-label="查看提交日志">查看提交日志</a></li>
                <li>
                    <a href="#%e6%9f%a5%e7%9c%8b%e5%bd%93%e5%89%8d%e4%bb%93%e5%ba%93%e6%93%8d%e4%bd%9c%e6%97%a5%e5%bf%97" aria-label="查看当前仓库操作日志">查看当前仓库操作日志</a></li>
                <li>
                    <a href="#%e4%bb%8e%e6%9a%82%e5%ad%98%e5%8c%ba%e6%92%a4%e9%94%80%e6%96%87%e4%bb%b6" aria-label="从暂存区撤销文件">从暂存区撤销文件</a></li>
                <li>
                    <a href="#%e6%92%a4%e9%94%80%e6%8f%90%e4%ba%a4httpwwwruanyifengcomblog201912git-undohtml" aria-label="撤销提交"><a href="http://www.ruanyifeng.com/blog/2019/12/git-undo.html">撤销提交</a></a></li>
                <li>
                    <a href="#%e5%9b%9e%e6%ba%af%e5%8e%86%e5%8f%b2%e7%89%88%e6%9c%ac" aria-label="回溯历史版本">回溯历史版本</a></li>
                <li>
                    <a href="#%e6%b7%bb%e5%8a%a0%e8%bf%9c%e7%a8%8b%e4%bb%93%e5%ba%93" aria-label="添加远程仓库">添加远程仓库</a></li>
                <li>
                    <a href="#%e6%8e%a8%e9%80%81%e8%87%b3%e8%bf%9c%e7%a8%8b%e4%bb%93%e5%ba%93" aria-label="推送至远程仓库">推送至远程仓库</a></li>
                <li>
                    <a href="#git-push-existing-repo-to-a-new-and-different-remote-repo-serverhttpsstackoverflowcomquestions5181845git-push-existing-repo-to-a-new-and-different-remote-repo-server" aria-label="Git push existing repo to a new and different remote repo server?"><a href="https://stackoverflow.com/questions/5181845/git-push-existing-repo-to-a-new-and-different-remote-repo-server">Git push existing repo to a new and different remote repo server?</a></a></li></ul>
                </li>
                <li>
                    <a href="#%e5%88%86%e6%94%af" aria-label="分支">分支</a><ul>
                        
                <li>
                    <a href="#%e5%88%9b%e5%bb%ba%e5%b9%b6%e5%88%87%e6%8d%a2%e5%88%86%e6%94%af" aria-label="创建并切换分支">创建并切换分支</a></li>
                <li>
                    <a href="#%e4%bb%a5%e5%9b%be%e8%a1%a8%e5%bd%a2%e5%bc%8f%e6%9f%a5%e7%9c%8b%e5%88%86%e6%94%af" aria-label="以图表形式查看分支">以图表形式查看分支</a></li>
                <li>
                    <a href="#%e6%98%be%e7%a4%ba%e5%88%86%e6%94%af" aria-label="显示分支">显示分支</a></li>
                <li>
                    <a href="#%e5%90%88%e5%b9%b6%e5%88%86%e6%94%af" aria-label="合并分支">合并分支</a></li>
                <li>
                    <a href="#%e5%88%a0%e9%99%a4%e5%88%86%e6%94%af" aria-label="删除分支">删除分支</a></li>
                <li>
                    <a href="#%e6%92%a4%e9%94%80%e5%b7%a5%e4%bd%9c%e5%8c%ba%e7%9a%84%e6%96%87%e4%bb%b6%e4%bf%ae%e6%94%b9" aria-label="撤销工作区的文件修改">撤销工作区的文件修改</a></li>
                <li>
                    <a href="#%e5%88%86%e6%94%af%e9%87%8d%e5%91%bd%e5%90%8dhttpsblogcsdnnetqq_37148270articledetails107106392" aria-label="分支重命名"><a href="https://blog.csdn.net/qq_37148270/article/details/107106392">分支重命名</a></a></li></ul>
                </li>
                <li>
                    <a href="#%e6%a0%87%e7%ad%be" aria-label="标签">标签</a></li>
                <li>
                    <a href="#git-ignorehttpsgithubcomgithubgitignore" aria-label="Git Ignore"><a href="https://github.com/github/gitignore">Git Ignore</a></a></li>
                <li>
                    <a href="#pull-requesthttpswwwzhihucomquestion21682976answer79489643" aria-label="Pull Request"><a href="https://www.zhihu.com/question/21682976/answer/79489643">Pull Request</a></a></li>
                <li>
                    <a href="#github-hosts" aria-label="GitHub Hosts">GitHub Hosts</a><ul>
                        
                <li>
                    <a href="#github520httpsgithubcom521xueweihangithub520" aria-label="GitHub520"><a href="https://github.com/521xueweihan/GitHub520">GitHub520</a></a></li></ul>
                </li>
                <li>
                    <a href="#github-pages" aria-label="GitHub Pages">GitHub Pages</a><ul>
                        
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8-githubhttpsdocsgithubcomcnfree-pro-teamlatestgithubworking-with-github-pagesgetting-started-with-github-pages" aria-label="使用 GitHub"><a href="https://docs.github.com/cn/free-pro-team@latest/github/working-with-github-pages/getting-started-with-github-pages">使用 GitHub</a></a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8-jekyllhttpsdocsgithubcomcnfree-pro-teamlatestgithubworking-with-github-pagessetting-up-a-github-pages-site-with-jekyll" aria-label="使用 jekyll"><a href="https://docs.github.com/cn/free-pro-team@latest/github/working-with-github-pages/setting-up-a-github-pages-site-with-jekyll">使用 jekyll</a></a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8-hexohttpshexoiozh-cndocs" aria-label="使用 Hexo"><a href="https://hexo.io/zh-cn/docs/">使用 Hexo</a></a></li></ul>
                </li>
                <li>
                    <a href="#github-actions" aria-label="GitHub Actions">GitHub Actions</a><ul>
                        
                <li>
                    <a href="#github-actions-%e6%98%af%e4%bb%80%e4%b9%88" aria-label="GitHub Actions 是什么">GitHub Actions 是什么</a></li>
                <li>
                    <a href="#workflow-%e6%96%87%e4%bb%b6" aria-label="workflow 文件">workflow 文件</a></li>
                <li>
                    <a href="#%e5%8f%82%e8%80%83" aria-label="参考">参考</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%8c%81%e7%bb%ad%e9%9b%86%e6%88%90continuous-integration%e7%ae%80%e7%a7%b0ci" aria-label="持续集成（Continuous integration，简称CI）">持续集成（Continuous integration，简称CI）</a><ul>
                        
                <li>
                    <a href="#%e6%a6%82%e5%bf%b5" aria-label="概念">概念</a></li>
                <li>
                    <a href="#%e6%b5%81%e7%a8%8b" aria-label="流程">流程</a></li></ul>
                </li>
                <li>
                    <a href="#commit-message" aria-label="Commit message">Commit message</a><ul>
                        
                <li>
                    <a href="#%e6%a0%bc%e5%bc%8f%e5%8c%96%e7%9a%84-commit-message-%e5%a5%bd%e5%a4%84" aria-label="格式化的 Commit message 好处">格式化的 Commit message 好处</a></li>
                <li>
                    <a href="#commit-message-%e7%9a%84%e6%a0%bc%e5%bc%8f" aria-label="Commit message 的格式">Commit message 的格式</a></li>
                <li>
                    <a href="#commitizen" aria-label="Commitizen">Commitizen</a></li>
                <li>
                    <a href="#%e5%8f%82%e8%80%83-1" aria-label="参考">参考</a></li></ul>
                </li>
                <li>
                    <a href="#yamlyaml-aint-a-markup-language" aria-label="YAML（YAML Ain&amp;rsquo;t a Markup Language）">YAML（YAML Ain&rsquo;t a Markup Language）</a><ul>
                        
                <li>
                    <a href="#%e7%ae%80%e4%bb%8b" aria-label="简介">简介</a></li>
                <li>
                    <a href="#%e5%af%b9%e8%b1%a1" aria-label="对象">对象</a></li>
                <li>
                    <a href="#%e6%95%b0%e7%bb%84" aria-label="数组">数组</a></li>
                <li>
                    <a href="#%e7%ba%af%e9%87%8f" aria-label="纯量">纯量</a></li>
                <li>
                    <a href="#%e5%8f%82%e8%80%83-2" aria-label="参考">参考</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%bc%80%e6%ba%90%e8%ae%b8%e5%8f%af%e8%af%81" aria-label="开源许可证">开源许可证</a><ul>
                        
                <li>
                    <a href="#gpl" aria-label="GPL">GPL</a></li>
                <li>
                    <a href="#lgpl" aria-label="LGPL">LGPL</a></li>
                <li>
                    <a href="#bsd" aria-label="BSD">BSD</a></li>
                <li>
                    <a href="#apache" aria-label="Apache">Apache</a></li>
                <li>
                    <a href="#mit" aria-label="MIT">MIT</a></li>
                <li>
                    <a href="#mpl" aria-label="MPL">MPL</a></li>
                <li>
                    <a href="#%e6%80%bb%e7%bb%93" aria-label="总结">总结</a></li></ul>
                </li>
                <li>
                    <a href="#ssh-%e5%8e%9f%e7%90%86%e4%b8%8e%e8%bf%90%e7%94%a8" aria-label="SSH 原理与运用">SSH 原理与运用</a><ul>
                        
                <li>
                    <a href="#%e6%95%b0%e5%ad%97%e7%ad%be%e5%90%8d%e4%b8%8e%e6%95%b0%e5%ad%97%e8%af%81%e4%b9%a6httpwwwruanyifengcomblog201108what_is_a_digital_signaturehtml" aria-label="数字签名与数字证书"><a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html">数字签名与数字证书</a></a></li>
                <li>
                    <a href="#%e8%bf%9c%e7%a8%8b%e7%99%bb%e5%bd%95httpwwwruanyifengcomblog201112ssh_remote_loginhtml" aria-label="远程登录"><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html">远程登录</a></a></li>
                <li>
                    <a href="#%e8%bf%9c%e7%a8%8b%e6%93%8d%e4%bd%9c%e4%b8%8e%e7%ab%af%e5%8f%a3%e8%bd%ac%e5%8f%91httpwwwruanyifengcomblog201112ssh_port_forwardinghtml" aria-label="远程操作与端口转发"><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html">远程操作与端口转发</a></a></li></ul>
                </li>
                <li>
                    <a href="#github-packageshttpsdocsgithubcomenpackages" aria-label="GitHub Packages"><a href="https://docs.github.com/en/packages">GitHub Packages</a></a></li>
                <li>
                    <a href="#tip--questions" aria-label="Tip &amp;amp; Questions">Tip &amp; Questions</a><ul>
                        
                <li>
                    <a href="#repository-size-limits-for-githubcomhttpsstackoverflowcomquestions38768454repository-size-limits-for-github-com" aria-label="Repository size limits for GitHub.com"><a href="https://stackoverflow.com/questions/38768454/repository-size-limits-for-github-com">Repository size limits for GitHub.com</a></a></li>
                <li>
                    <a href="#%e8%a7%a3%e5%86%b3ssh%e8%87%aa%e5%8a%a8%e6%96%ad%e7%ba%bf%e9%97%ae%e9%a2%98httpsmtjonetblogarticle30html" aria-label="解决SSH自动断线问题"><a href="https://mtjo.net/blog/article/30.html">解决SSH自动断线问题</a></a></li>
                <li>
                    <a href="#new-mode-100755httpsblogcsdnnetai2000aiarticledetails79628896" aria-label="new mode 100755"><a href="https://blog.csdn.net/ai2000ai/article/details/79628896">new mode 100755</a></a></li>
                <li>
                    <a href="#check-if-pull-needed-in-githttpsstackoverflowcoma3278427" aria-label="Check if pull needed in Git"><a href="https://stackoverflow.com/a/3278427">Check if pull needed in Git</a></a></li>
                <li>
                    <a href="#setting-the-default-editor-for-githttpsstackoverflowcoma2596835" aria-label="Setting the default editor for Git"><a href="https://stackoverflow.com/a/2596835">Setting the default editor for Git</a></a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>Workspace：工作区，Index / Stage：暂存区，Repository：仓库区（或本地仓库），Remote：远程仓库</p>
<h2 id="远程仓库">远程仓库<a hidden class="anchor" aria-hidden="true" href="#远程仓库">#</a></h2>
<h3 id="安装windows需要处理换行符">安装，windows需要处理换行符<a hidden class="anchor" aria-hidden="true" href="#安装windows需要处理换行符">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">sudo yum install git
</code></pre></div><h3 id="设置姓名和邮箱地址">设置姓名和邮箱地址<a hidden class="anchor" aria-hidden="true" href="#设置姓名和邮箱地址">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git config --global user.name <span style="color:#e6db74">&#34;Vane Hsiung&#34;</span>
git config --global user.email <span style="color:#e6db74">&#34;1664548605@qq.com&#34;</span>
</code></pre></div><h3 id="提高输出可读性">提高输出可读性<a hidden class="anchor" aria-hidden="true" href="#提高输出可读性">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git config --global color.ui auto
</code></pre></div><h3 id="设置文件">设置文件<a hidden class="anchor" aria-hidden="true" href="#设置文件">#</a></h3>
<ul>
<li>
<p>显示当前的 Git 配置</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git config --list
cat ~/.giconfig
</code></pre></div></li>
<li>
<p>编辑Git配置文件</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git config -e <span style="color:#f92672">[</span>--global<span style="color:#f92672">]</span>
</code></pre></div></li>
</ul>
<h3 id="设置ssh添加认证密码">设置SSH，添加认证密码<a hidden class="anchor" aria-hidden="true" href="#设置ssh添加认证密码">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">ssh-keygen -t rsa -C <span style="color:#e6db74">&#34;1664548605@qq.com&#34;</span>
</code></pre></div><h3 id="添加公开密钥">添加公开密钥<a hidden class="anchor" aria-hidden="true" href="#添加公开密钥">#</a></h3>
<p>将下面的密钥添加到 GitHub 设置中的 SSH key 中</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">cat ~/.ssh/id_rsa.pub
</code></pre></div><h3 id="查看是否认证和通信成功">查看是否认证和通信成功<a hidden class="anchor" aria-hidden="true" href="#查看是否认证和通信成功">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">ssh -T git@github.com
</code></pre></div><h3 id="获取远程仓库">获取远程仓库<a hidden class="anchor" aria-hidden="true" href="#获取远程仓库">#</a></h3>
<p>clone 后默认在 master 分支下自动将 origin 设置为远程仓库标识符</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git clone SSH
</code></pre></div><p><a href="https://juejin.cn/post/6969206858179411982">提速</a>：</p>
<pre tabindex="0"><code>git clone SSH --depth=1
</code></pre><p>加上 &ndash;depth 会只下载一个 commit，所以内容少了很多，速度也就上去了。</p>
<p>而且下载下来的内容是可以继续提交新的 commit、创建新的分支的。不影响后续开发，只是不能切换到历史 commit 和历史分支。</p>
<p>在一些场景下还是比较有用的：当需要切换到历史分支的时候也可以计算需要几个 commit，然后再指定 depth，这样也可以提高速度。</p>
<h3 id="获取远程非master分支">获取远程非master分支<a hidden class="anchor" aria-hidden="true" href="#获取远程非master分支">#</a></h3>
<p><code>-b</code> 后是新建分支名称</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git checkout -b branchName origin/branchName
</code></pre></div><h3 id="获取指定分支">获取指定分支<a hidden class="anchor" aria-hidden="true" href="#获取指定分支">#</a></h3>
<p>使用git拉代码时可以使用 -b 指定分支，拉取 develop 分支代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">git clone -b develop http://gitslab.yiqing.com/declare/about.git
</code></pre></div><p>查看当前项目拉的是哪个分支的代码详情：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">git branch -v
</code></pre></div><p>查看分支上的递交情况:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">git show-branch
</code></pre></div><h3 id="获取最新的远程仓库分支">获取最新的远程仓库分支<a hidden class="anchor" aria-hidden="true" href="#获取最新的远程仓库分支">#</a></h3>
<p>远程仓库拉取代码并合并到本地，可简写为 git pull 等同于 git fetch &amp;&amp; git merge</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;

<span style="color:#75715e"># 取回远程仓库的变化，并与本地分支合并</span>
git pull origin branchName

<span style="color:#75715e"># 使用rebase的模式进行合并</span>
git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;

<span style="color:#75715e"># 获取远程仓库特定分支的更新</span>
git fetch &lt;远程主机名&gt; &lt;分支名&gt;

<span style="color:#75715e"># 获取远程仓库所有分支的更新</span>
git fetch --all
</code></pre></div><p><a href="https://stackoverflow.com/questions/49297153/why-is-it-not-a-commit-and-a-branch-cannot-be-created-from-it">问题</a>：For those who found this searching for an answer to <code>fatal: 'origin/remote-branch-name' is not a commit and a branch 'local-branch-name' cannot be created from it</code>, you may also want to try this first:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">git fetch --all
</code></pre></div><p>与 <code>git pull</code> 不同的是 <code>git fetch</code> 操作仅仅只会拉取远程的更改，不会自动进行 merge 操作。对你当前的代码没有影响。</p>
<p><strong>git rebase 让你的提交记录更加清晰可读</strong></p>
<p>rebase 翻译为变基，他的作用和 merge 很相似，用于把一个分支的修改合并到当前分支上。</p>
<p><img loading="lazy" src="/Git/rebase.image" alt=""  />
</p>
<p>即逐个应用了 mater 分支的更改，然后以 master 分支最后的提交作为基点，再逐个应用 feature 的每个更改。</p>
<p>大部分情况下，rebase 的过程中会产生冲突的，此时，就需要手动解决冲突，然后使用依次 <code>git add </code> 、<code>git rebase --continue </code> 的方式来处理冲突，完成 rebase 的过程，如果不想要某次 rebase 的结果，那么需要使用 <code>git rebase --skip </code> 来跳过这次 rebase 操作。</p>
<p><strong>git merge 和 git rebase 的区别</strong></p>
<p>不同于 <code>git rebase</code> 的是，<code>git merge</code> 在不是 fast-forward（快速合并）的情况下，会产生一条额外的合并记录，类似 <code>Merge branch 'xxx' into 'xxx'</code> 的一条提交信息。</p>
<p><img loading="lazy" src="/Git/merge.image" alt=""  />
</p>
<p>另外，在解决冲突的时候，用 merge 只需要解决一次冲突即可，简单粗暴，而用 rebase 的时候 ，需要依次解决每次的冲突，才可以提交。</p>
<h3 id="同一台电脑配置多个-github-账号httpsgithubcomjawilnotesissues2"><a href="https://github.com/jawil/notes/issues/2">同一台电脑配置多个 GItHub 账号</a><a hidden class="anchor" aria-hidden="true" href="#同一台电脑配置多个-github-账号httpsgithubcomjawilnotesissues2">#</a></h3>
<p>在日常使用 <code>git</code> 作为仓库使用的时候，有时可能会遇到这样的一些情况：</p>
<ol>
<li>有两个 <code>github</code> 账号，一台电脑怎么同时连接这两个账号进行维护呢？</li>
<li>自己用一个 <code>github</code> 账号，平时用来更新自己的一些资料；公司使用的 <code>gitlab</code>（也是 <code>git</code> 的衍生产品）</li>
</ol>
<p>如下是解决方案：</p>
<ul>
<li>
<p>创建默认 <code>SSH Key</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">ssh-keygen -t rsa -C <span style="color:#e6db74">&#34;one@example.com&#34;</span>
</code></pre></div></li>
<li>
<p>将公钥添加到 <a href="mailto:one@example.com">one@example.com</a> 的 GitHub SSH key 中。</p>
</li>
<li>
<p>测试 <code>ssh key</code> 是否成功</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">ssh -T git@github.com
</code></pre></div></li>
<li>
<p>如果设置过全局，则清除 <code>git</code> 的全局设置</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 查看当前配置</span>
git config --list

<span style="color:#75715e"># 取消 global user.name user.email</span>
git config --global --unset user.name
git config --global --unset user.email
</code></pre></div></li>
<li>
<p>生成另外一个账号新的SSH keys</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">ssh-keygen -t rsa -C <span style="color:#e6db74">&#34;two@example.com&#34;</span>
</code></pre></div><p>私钥需重命名，如 <code>id_rsa_two</code>。然后将对应的公钥添加到two@example.com的 Github SSH key 中。</p>
</li>
<li>
<p>需添加新私钥到 <code>SSH agent</code> 中，因为默认只读取 <code>id_rsa</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># Windows 在管理员下运行</span>
Get-Service ssh-agent
Set-Service ssh-agent -StartupType Manual
Start-Service ssh-agent

<span style="color:#75715e"># Linux</span>
eval <span style="color:#e6db74">`</span>ssh-agent -s<span style="color:#e6db74">`</span>

<span style="color:#75715e"># 添加私钥</span>
ssh-add ~/.ssh/id_rsa_new
</code></pre></div><p><a href="https://stackoverflow.com/questions/52113738/starting-ssh-agent-on-windows-10-fails-unable-to-start-ssh-agent-service-erro">unable to start ssh-agent service</a></p>
<p><a href="https://stackoverflow.com/questions/17846529/could-not-open-a-connection-to-your-authentication-agent">Could not open a connection to your authentication agent</a></p>
</li>
<li>
<p>配置 <code>~/.ssh/config</code> 文件，用于配置私钥对应的服务器</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># Default github user(one@example.com)</span>
Host git@github.com
    HostName github.com
    User <span style="color:#e6db74">&#34;Your GitHub Account Name&#34;</span>
    IdentityFile ~/.ssh/id_rsa

<span style="color:#75715e"># another user(two@example.com)</span>
<span style="color:#75715e"># 建一个别名，新建的帐号使用这个别名做克隆和更新</span>
<span style="color:#75715e"># &#34;Host&#34; 如果带了 &#34;git@&#34;，如 &#34;git@two.github.com&#34;，就会连接到 two.github.com</span>
<span style="color:#75715e"># &#34;Host&#34; 没有带 &#34;git@&#34;，就会正确的连接到 github.com</span>
Host two.github.com
    HostName github.com
    User <span style="color:#e6db74">&#34;Your GitHub Account Name&#34;</span>
    IdentityFile ~/.ssh/id_rsa_two
</code></pre></div><p>测试</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># default</span>
ssh -T git@github.com

<span style="color:#75715e"># another</span>
ssh -T git@two.github.com
</code></pre></div><p>可能需要重启系统</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo systemctl reboot
</code></pre></div></li>
<li>
<p>使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># default</span>
git remote add origin git@github.com:one/demo.git

<span style="color:#75715e"># another</span>
git remote add origin git@two.github.com:two/demo.git 
</code></pre></div></li>
<li>
<p>设置每个项目的自己的 user.name 和 user.email</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">git config  user.email <span style="color:#e6db74">&#34;two@example.com&#34;</span>
git config  user.name <span style="color:#e6db74">&#34;two&#34;</span>
</code></pre></div></li>
</ul>
<h3 id="git-中-https-和-ssh-的-clone-方式区别httpswwwcnblogscomtomato0906articles8461325html"><a href="https://www.cnblogs.com/tomato0906/articles/8461325.html">Git 中 HTTPS 和 SSH 的 Clone 方式区别</a><a hidden class="anchor" aria-hidden="true" href="#git-中-https-和-ssh-的-clone-方式区别httpswwwcnblogscomtomato0906articles8461325html">#</a></h3>
<ul>
<li>HTTPS：不管是谁，拿到url随便clone，但是在push的时候需要验证用户名和密码；</li>
<li>SSH：clone的项目你必须是拥有者或者管理员，而且需要在clone前添加SSH Key。SSH 在push的时候，是不需要输入用户名的，如果配置SSH key的时候设置了密码，则需要输入密码的。</li>
</ul>
<h2 id="本地仓库">本地仓库<a hidden class="anchor" aria-hidden="true" href="#本地仓库">#</a></h2>
<h3 id="初始化仓库">初始化仓库<a hidden class="anchor" aria-hidden="true" href="#初始化仓库">#</a></h3>
<p>生成  <code>.git</code>  目录, 也就是当前目录的仓库，当前目录称为“附属于该仓库的工作树”</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git init <span style="color:#f92672">[</span>project-name<span style="color:#f92672">]</span>
</code></pre></div><h3 id="查看仓库的状态">查看仓库的状态<a hidden class="anchor" aria-hidden="true" href="#查看仓库的状态">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git status        <span style="color:#75715e"># 显示有变更的文件</span>
</code></pre></div><h3 id="向暂存区添加文件">向暂存区添加文件<a hidden class="anchor" aria-hidden="true" href="#向暂存区添加文件">#</a></h3>
<ul>
<li>
<p>添加指定文件到暂存区</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git add <span style="color:#f92672">[</span>file1<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>file2<span style="color:#f92672">]</span> ...
</code></pre></div></li>
<li>
<p>添加指定目录到暂存区，包括子目录</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git add <span style="color:#f92672">[</span>dir<span style="color:#f92672">]</span>
</code></pre></div></li>
<li>
<p>添加当前目录的所有文件到暂存区</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git add .
</code></pre></div></li>
<li>
<p>删除工作区文件，并且将这次删除放入暂存区</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git rm <span style="color:#f92672">[</span>file1<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>file2<span style="color:#f92672">]</span> ...
</code></pre></div></li>
<li>
<p>改名文件，并且将这个改名放入暂存区</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git mv <span style="color:#f92672">[</span>file-original<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>file-renamed<span style="color:#f92672">]</span>
</code></pre></div></li>
</ul>
<p>原理（<code>git add</code> 为如下两步简写）：</p>
<ul>
<li>
<p>为 example.txt 创建一个副本。<code>git hash-object</code> 命令把 example.txt 的当前内容压缩成二进制文件，称为一个 Git 对象，保存在 <code>.git/objects</code> 目录。并计算当前内容的哈希值，前 2 个字符作为目录名，后 38 个字符作为该对象的文件名</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git hash-object -w example.txt
</code></pre></div><p>二进制对象里面会保存一些元数据，如果想看该文件原始的文本内容，需用<code>git cat-file</code>命令</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git cat-file -p e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
</code></pre></div></li>
<li>
<p>所有变动的文件，Git 都记录在&quot;暂存区&quot;，<code>git update-index</code> 命令用于在暂存区记录一个发生变动的文件</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git update-index --add --cacheinfo <span style="color:#ae81ff">100644</span> e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 example.txt
</code></pre></div><p><code>git ls-files</code> 命令显示暂存区当前内容</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git ls-files --stage
</code></pre></div></li>
</ul>
<h3 id="查看更改前后的差别">查看更改前后的差别<a hidden class="anchor" aria-hidden="true" href="#查看更改前后的差别">#</a></h3>
<p>习惯：<code>git commit</code> 前先 <code>git diff HEAD</code></p>
<p><code>git diff</code> 默认查看工作树和暂存区的差别</p>
<p>HEAD查看工作树与最新提交的差别，HEAD 为指向当前分支中最新一次提交的指针，<code>HEAD^</code> 指向 <code>HEAD</code> 的前一个提交，<code>HEAD~6</code> 则是 <code>HEAD</code> 之前的第6个提交。每一个分支都是一个文本文件，保存在 <code>.git/refs/heads/</code> 目录中，文件的内容是最新提交的哈希值</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git diff <span style="color:#f92672">[</span>HEAD<span style="color:#f92672">]</span>
</code></pre></div><h3 id="将暂存区中文件保存到仓库历史记录中">将暂存区中文件保存到仓库历史记录中<a hidden class="anchor" aria-hidden="true" href="#将暂存区中文件保存到仓库历史记录中">#</a></h3>
<p><code>-m</code> 用于记录一行信息；不加 <code>-m</code> 记录详细信息，会新开编辑器进行编辑</p>
<ul>
<li>
<p>相当与 git add 与 git commit</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git commit -am <span style="color:#e6db74">&#34;Message&#34;</span>    
</code></pre></div></li>
<li>
<p>提交暂存区的指定文件到仓库区</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"> git commit <span style="color:#f92672">[</span>file1<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>file2<span style="color:#f92672">]</span> ... -m <span style="color:#e6db74">&#34;Message&#34;</span>
</code></pre></div></li>
<li>
<p>提交工作区自上次commit之后的变化，直接到仓库区</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git commit -a
</code></pre></div></li>
<li>
<p>提交时显示所有diff信息</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git commit -v
</code></pre></div></li>
</ul>
<p>原理（<code>git commit -m &quot;first commit&quot;</code> 为如下两步简写）：</p>
<ul>
<li>
<p><code>git write-tree</code> 命令保存当前的目录结构，生成一个 Git 对象</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git write-tree
</code></pre></div></li>
<li>
<p><code>git commit-tree</code>  命令用目录结构 Git 对象生成一个 Git 对象，需添加提交说明，<code>-p</code> 参数用来指定父提交</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">echo <span style="color:#e6db74">&#34;first commit&#34;</span> | git e5a60f66d9966270c835343d4facc1c4bf44ed7a -p c9053865e9dff393fd2f7a92a18f9bd7f2caa7fa
</code></pre></div></li>
</ul>
<h3 id="修改提交信息">修改提交信息<a hidden class="anchor" aria-hidden="true" href="#修改提交信息">#</a></h3>
<p>产生一个新的提交对象，替换掉上一次提交产生的提交对象</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git commit --amend -m <span style="color:#e6db74">&#34;Message&#34;</span>
</code></pre></div><p>重做上一次 commit，并包括指定文件的新变化</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git commit --amend <span style="color:#f92672">[</span>file1<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>file2<span style="color:#f92672">]</span> ...
</code></pre></div><h3 id="压缩历史">压缩历史<a hidden class="anchor" aria-hidden="true" href="#压缩历史">#</a></h3>
<p>用于拼错单词等简单的错误，选定当前分支中包含 HEAD（最新提交）在内的 number 个最新历史记录为对象并在编辑器中打开，pick 为合并对象，fixup 为被合并对象，最后 pick 提交信息会保留</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git rebase -i HEAD~<span style="color:#f92672">[</span>number<span style="color:#f92672">]</span> 
</code></pre></div><h3 id="查看提交日志">查看提交日志<a hidden class="anchor" aria-hidden="true" href="#查看提交日志">#</a></h3>
<ul>
<li>
<p><code>--pretty=short</code> 用于只显示第一行简述信息</p>
</li>
<li>
<p><code>FileName</code> 为文件名或目录名，只显示指定文件的日志</p>
</li>
<li>
<p><code>-p</code> 用于显示文件的改动</p>
</li>
<li>
<p><code>--stat</code> 显示 commit 历史，以及每次 commit 发生变更的文件</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git log <span style="color:#f92672">[</span>--pretty<span style="color:#f92672">=</span>short<span style="color:#f92672">][</span>FileName<span style="color:#f92672">][</span>-p<span style="color:#f92672">][</span>--stat<span style="color:#f92672">]</span>        <span style="color:#75715e"># 显示当前分支的版本历史</span>
</code></pre></div></li>
<li>
<p>查看文件每次提交的diff</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git log -p FileName
</code></pre></div></li>
<li>
<p>搜索提交历史，根据关键词</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git log -S <span style="color:#f92672">[</span>keyword<span style="color:#f92672">]</span>
</code></pre></div></li>
<li>
<p>显示某个 commit 之后的所有变动，每个commit占据一行</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git log <span style="color:#f92672">[</span>tag<span style="color:#f92672">]</span> HEAD --pretty<span style="color:#f92672">=</span>format:%s
</code></pre></div></li>
<li>
<p>显示某个 commit 之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git log <span style="color:#f92672">[</span>tag<span style="color:#f92672">]</span> HEAD --grep feature
</code></pre></div></li>
<li>
<p>显示某个文件的版本历史，包括文件改名</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git log --follow <span style="color:#f92672">[</span>file<span style="color:#f92672">]</span>
git whatchanged <span style="color:#f92672">[</span>file<span style="color:#f92672">]</span>
</code></pre></div></li>
</ul>
<p><code>git log</code> 的运行过程</p>
<ul>
<li>查找 HEAD 指针对应的分支</li>
<li>找到分支的最新提交</li>
<li>找到父节点（前一个提交）</li>
<li>依此类推，显示当前分支的所有提交</li>
</ul>
<h3 id="查看当前仓库操作日志">查看当前仓库操作日志<a hidden class="anchor" aria-hidden="true" href="#查看当前仓库操作日志">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git reflog
</code></pre></div><p><strong><a href="https://www.php.cn/wenda/103934.html#:~:text=%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E6%97%A5%E5%BF%97%E6%9D%A5%E6%89%BE%E5%88%B0%E6%89%80%E5%9F%BA%E4%BA%8E%E7%9A%84%E5%88%86%E6%94%AF%EF%BC%8C%E5%8D%B3%E9%80%9A%E8%BF%87%20git%20log%20%E5%91%BD%E4%BB%A4%EF%BC%8C%E4%B8%8D%E8%BF%87%E9%9C%80%E8%A6%81%E5%80%9F%E5%8A%A9%E4%B8%80%E4%BA%9B%E5%91%BD%E4%BB%A4%E9%80%89%E9%A1%B9%E3%80%82%20%E4%BD%A0%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%20--decorate,%E9%80%89%E9%A1%B9%E6%9D%A5%E5%9C%A8%E6%8F%90%E4%BA%A4%E6%97%A5%E5%BF%97%E4%B8%AD%E6%98%BE%E7%A4%BA%E5%88%86%E6%94%AF%E4%BF%A1%E6%81%AF%EF%BC%8C%E4%BB%A5%E5%8F%8A%20--graph%20%E9%80%89%E9%A1%B9%E4%BB%A5ASCII%E5%9B%BE%E5%BD%A2%E5%BD%A2%E5%BC%8F%E6%98%BE%E7%A4%BA%E5%88%86%E6%94%AF%E5%8E%86%E5%8F%B2%EF%BC%8C%E5%BD%93%E7%84%B6%E4%BD%A0%E8%BF%98%E9%9C%80%E8%A6%81%20--all%20%E9%80%89%E9%A1%B9%E6%9D%A5%E4%BF%9D%E8%AF%81%E6%89%80%E6%9C%89%E7%9A%84%E5%88%86%E6%94%AF%E4%BF%A1%E6%81%AF%E9%83%BD%E6%98%BE%E7%A4%BA%E5%87%BA%E6%9D%A5%EF%BC%9A%20%E7%84%B6%E5%90%8E%E4%BD%A0%E5%8F%AF%E4%BB%A5%E5%9C%A8%E7%BB%93%E6%9E%9C%E4%B8%AD%E6%89%BE%E5%88%B0%E5%BD%93%E5%89%8D%E5%88%86%E6%94%AF%EF%BC%8C%E5%B9%B6%E9%A1%BA%E7%9D%80%E8%AF%A5%E5%88%86%E6%94%AF%E7%9A%84%E7%BA%BF%E6%89%BE%E5%88%B0%E5%85%B6%E7%88%B6%E5%88%86%E6%94%AF%EF%BC%8C%E5%9B%A0%E4%B8%BA%E7%9B%B8%E9%82%BB%E5%88%86%E6%94%AF%E4%B9%8B%E9%97%B4%E7%9A%84%E9%A2%9C%E8%89%B2%E9%83%BD%E6%98%AF%E4%B8%8D%E5%90%8C%E7%9A%84%EF%BC%8C%E6%89%80%E4%BB%A5%E4%BB%94%E7%BB%86%E6%89%BE%E5%BA%94%E8%AF%A5%E5%8F%AF%E4%BB%A5%E6%89%BE%E5%87%BA%E6%9D%A5%E7%9A%84%E3%80%82">怎么查看当前的git分支是基于哪个分支创建的</a></strong></p>
<p><code>git reflog --date=local | grep &lt;branchname&gt;</code></p>
<p>类似于如下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">6b3db1f HEAD@<span style="color:#f92672">{</span>Fri Jul <span style="color:#ae81ff">9</span> 16:05:23 2021<span style="color:#f92672">}</span>: checkout: moving from development to feature/api_xiongwen_dump
</code></pre></div><p>可知 feature/api_xiongwen_dump 基于 development</p>
<h3 id="从暂存区撤销文件">从暂存区撤销文件<a hidden class="anchor" aria-hidden="true" href="#从暂存区撤销文件">#</a></h3>
<p>停止追踪指定文件，但该文件会保留在工作区</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git rm --cached <span style="color:#f92672">[</span>filename<span style="color:#f92672">]</span>
</code></pre></div><h3 id="撤销提交httpwwwruanyifengcomblog201912git-undohtml"><a href="http://www.ruanyifeng.com/blog/2019/12/git-undo.html">撤销提交</a><a hidden class="anchor" aria-hidden="true" href="#撤销提交httpwwwruanyifengcomblog201912git-undohtml">#</a></h3>
<p>在当前提交后面，新增一次提交，抵消掉上一次提交导致的所有变化</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git revert HEAD
</code></pre></div><p>想抵消多个提交，必须在命令行依次指定这些提交</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git revert <span style="color:#f92672">[</span>倒数第一个提交<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>倒数第二个提交<span style="color:#f92672">]</span>
</code></pre></div><h3 id="回溯历史版本">回溯历史版本<a hidden class="anchor" aria-hidden="true" href="#回溯历史版本">#</a></h3>
<ul>
<li>
<p>重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git reset <span style="color:#f92672">[</span>file<span style="color:#f92672">]</span>
</code></pre></div></li>
<li>
<p>重置暂存区与工作区，与上一次 commit 保持一致</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git reset --hard
</code></pre></div></li>
<li>
<p>让最新提交的指针回到以前某个时点，该时点之后的提交都从历史中消失</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git reset 目标时间点哈希值        <span style="color:#75715e"># 重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变</span>
</code></pre></div></li>
<li>
<p>默认情况下，<code>git reset</code>不改变工作区的文件（但会改变暂存区），<code>--hard</code>参数可以让工作区里面的文件也回到以前的状态</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git reset --hard 目标时间点哈希值        <span style="color:#75715e">#  重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span>
</code></pre></div></li>
<li>
<p>重置当前 HEAD 为指定 commit，但保持暂存区和工作区不变</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git reset --keep <span style="color:#f92672">[</span>commit<span style="color:#f92672">]</span>
</code></pre></div></li>
</ul>
<h3 id="添加远程仓库">添加远程仓库<a hidden class="anchor" aria-hidden="true" href="#添加远程仓库">#</a></h3>
<p><code>origin</code> 为远程仓库的标识符</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git remote add origin SSH        <span style="color:#75715e"># 增加一个新的远程仓库，并命名</span>
git remote -v        <span style="color:#75715e"># 显示所有远程仓库</span>
git remote show <span style="color:#f92672">[</span>remote<span style="color:#f92672">]</span>        <span style="color:#75715e"># 显示某个远程仓库的信息</span>
</code></pre></div><h3 id="推送至远程仓库">推送至远程仓库<a hidden class="anchor" aria-hidden="true" href="#推送至远程仓库">#</a></h3>
<ul>
<li>推送的是当前分支</li>
<li><code>-u</code> 在推送的同时将远程仓库的（origin仓库）的 branch 分支设为本地仓库当前分支的 upstream（上游）
运行 git pull 从远程仓库获取内容时，就可以省略参数</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git push <span style="color:#f92672">[</span>-u origin branchName<span style="color:#f92672">]</span>        <span style="color:#75715e"># 上传本地指定分支到远程仓库</span>

git push --set-upstream origin <span style="color:#f92672">[</span>branchName<span style="color:#f92672">]</span>        <span style="color:#75715e"># To push the current branch and set the remote as upstream</span>
</code></pre></div><p>如果每次 <code>git push</code> 都需要输入账号和密码</p>
<ul>
<li>
<p>首先在 git 工作目录下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">git config <span style="color:#f92672">[</span>--global<span style="color:#f92672">]</span> credential.helper store
</code></pre></div></li>
<li>
<p>然后执行一次 <code>git pull</code>，这次输入账号和密码之后就不用再输入了。</p>
</li>
</ul>
<h3 id="git-push-existing-repo-to-a-new-and-different-remote-repo-serverhttpsstackoverflowcomquestions5181845git-push-existing-repo-to-a-new-and-different-remote-repo-server"><a href="https://stackoverflow.com/questions/5181845/git-push-existing-repo-to-a-new-and-different-remote-repo-server">Git push existing repo to a new and different remote repo server?</a><a hidden class="anchor" aria-hidden="true" href="#git-push-existing-repo-to-a-new-and-different-remote-repo-serverhttpsstackoverflowcomquestions5181845git-push-existing-repo-to-a-new-and-different-remote-repo-server">#</a></h3>
<p>需求：从公司的账户 clone repo 到本地，添加注释，pull 到自己账户的私有 repo 中。</p>
<ol>
<li>Create a new repo at github.</li>
<li><code>git remote rename origin upstream</code></li>
<li><code>git remote add origin URL_TO_GITHUB_REPO</code></li>
<li><code>git push origin master</code></li>
</ol>
<p>Now you can work with it just like any other github repo. To pull in patches from upstream, simply run <code>git pull upstream master &amp;&amp; git push origin master</code>.</p>
<h2 id="分支">分支<a hidden class="anchor" aria-hidden="true" href="#分支">#</a></h2>
<h3 id="创建并切换分支">创建并切换分支<a hidden class="anchor" aria-hidden="true" href="#创建并切换分支">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#75715e"># 切换分支，并更新工作区</span>
git checkout branchName    

<span style="color:#75715e">#切换至上一分支</span>
git checkout -            

<span style="color:#75715e"># 新建一个分支，并切换到该分支</span>
git checkout -b branchName        

<span style="color:#75715e"># 新建本地分支，但不切换</span>
git branch &lt;branch-name&gt; 

<span style="color:#75715e"># 新建一个分支，指向指定commit</span>
git branch <span style="color:#f92672">[</span>branch<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>commit<span style="color:#f92672">]</span>        

<span style="color:#75715e"># 新建一个分支，与指定的远程分支建立追踪关系</span>
git branch --track <span style="color:#f92672">[</span>branch<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>remote-branch<span style="color:#f92672">]</span>        
</code></pre></div><h3 id="以图表形式查看分支">以图表形式查看分支<a hidden class="anchor" aria-hidden="true" href="#以图表形式查看分支">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git log --graph
</code></pre></div><h3 id="显示分支">显示分支<a hidden class="anchor" aria-hidden="true" href="#显示分支">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#75715e"># 列出所有本地分支</span>
git branch    

<span style="color:#75715e"># 列出所有远程分支</span>
git branch -r        

<span style="color:#75715e"># 同时显示本地仓库和远程仓库的分支信息</span>
git branch -a    

<span style="color:#75715e"># 用于创建分支</span>
git branch branchName    

<span style="color:#75715e"># 本地分支对应哪个远程分支</span>
git branch -vv
</code></pre></div><h3 id="合并分支">合并分支<a hidden class="anchor" aria-hidden="true" href="#合并分支">#</a></h3>
<ul>
<li><code>--no-ff</code> 用于记录本次分支合并</li>
<li>消除冲突：打开冲突的文件，在编辑器中改为想要的样子</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git merge <span style="color:#f92672">[</span>--no-ff<span style="color:#f92672">]</span>  branchName        <span style="color:#75715e"># 合并指定分支到当前分支</span>
git cherry-pick <span style="color:#f92672">[</span>commit<span style="color:#f92672">]</span>        <span style="color:#75715e"># 选择一个 commit，合并进当前分支</span>
</code></pre></div><h3 id="删除分支">删除分支<a hidden class="anchor" aria-hidden="true" href="#删除分支">#</a></h3>
<ul>
<li>
<p>删除分支</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#75715e"># 删除本地分支</span>
git branch -d <span style="color:#f92672">[</span>branch-name<span style="color:#f92672">]</span>
</code></pre></div></li>
<li>
<p>删除远程分支</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git push origin --delete <span style="color:#f92672">[</span>branch-name<span style="color:#f92672">]</span>
git branch -dr <span style="color:#f92672">[</span>remote/branch<span style="color:#f92672">]</span>
</code></pre></div></li>
</ul>
<h3 id="撤销工作区的文件修改">撤销工作区的文件修改<a hidden class="anchor" aria-hidden="true" href="#撤销工作区的文件修改">#</a></h3>
<ul>
<li>
<p>先找暂存区，如果该文件有暂存的版本，则恢复该版本，否则恢复上一次提交的版本</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git checkout -- <span style="color:#f92672">[</span>filename<span style="color:#f92672">]</span>
</code></pre></div></li>
<li>
<p>恢复某个 commit 的指定文件到暂存区和工作区</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git checkout <span style="color:#f92672">[</span>commit<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>file<span style="color:#f92672">]</span>
</code></pre></div></li>
<li>
<p>恢复暂存区的所有文件到工作区</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git checkout .
</code></pre></div></li>
</ul>
<h3 id="分支重命名httpsblogcsdnnetqq_37148270articledetails107106392"><a href="https://blog.csdn.net/qq_37148270/article/details/107106392">分支重命名</a><a hidden class="anchor" aria-hidden="true" href="#分支重命名httpsblogcsdnnetqq_37148270articledetails107106392">#</a></h3>
<ul>
<li>
<p>重命名本地分支：</p>
<ul>
<li>
<p>在当前分支时</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git branch -m new_branch_name
</code></pre></div></li>
<li>
<p>当不在当前分支时</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git branch -m old_branch_name new_branch_name
</code></pre></div></li>
</ul>
</li>
<li>
<p>重命名远端分支：</p>
<p>假设是在当前分支，并且远端分支与本地分支名是一致的重命名本地分支</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git branch -m new_branch_name
</code></pre></div><p>删除远程分支</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git push --delete origin old_branch_name
</code></pre></div><p>上传新命名的本地分支</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git push origin new_branch_name
</code></pre></div><p>关联修改后的本地分支与远程分支</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git branch --set-upstream-to origin/new_branch_name
</code></pre></div></li>
</ul>
<h2 id="标签">标签<a hidden class="anchor" aria-hidden="true" href="#标签">#</a></h2>
<ul>
<li>
<p>列出所有 tag</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git tag
</code></pre></div></li>
<li>
<p>新建一个 tag 在当前commit</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git tag <span style="color:#f92672">[</span>tag<span style="color:#f92672">]</span>
</code></pre></div></li>
<li>
<p>新建一个tag在指定commit</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git tag <span style="color:#f92672">[</span>tag<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>commit<span style="color:#f92672">]</span>
</code></pre></div></li>
<li>
<p>删除本地 tag</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git tag -d <span style="color:#f92672">[</span>tag<span style="color:#f92672">]</span>
</code></pre></div></li>
<li>
<p>删除远程 tag</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git push origin :refs/tags/<span style="color:#f92672">[</span>tagName<span style="color:#f92672">]</span>
</code></pre></div></li>
<li>
<p>查看 tag 信息</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git show <span style="color:#f92672">[</span>tag<span style="color:#f92672">]</span>
</code></pre></div></li>
<li>
<p>提交指定 tag</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git push <span style="color:#f92672">[</span>remote<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>tag<span style="color:#f92672">]</span>
</code></pre></div></li>
<li>
<p>提交所有tag</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git push <span style="color:#f92672">[</span>remote<span style="color:#f92672">]</span> --tags
</code></pre></div></li>
<li>
<p>新建一个分支，指向某个tag</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git checkout -b <span style="color:#f92672">[</span>branch<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>tag<span style="color:#f92672">]</span>
</code></pre></div></li>
</ul>
<h2 id="git-ignorehttpsgithubcomgithubgitignore"><a href="https://github.com/github/gitignore">Git Ignore</a><a hidden class="anchor" aria-hidden="true" href="#git-ignorehttpsgithubcomgithubgitignore">#</a></h2>
<p>git 为我们提供了一个 <code>.gitignore</code> 文件，只要在这个文件中申明哪些文件你不希望添加到git中去，这样当你使用 <code>git add .</code> 的时候这些文件就会被自动忽略掉。</p>
<p>经实验，可以为每一个平行非包含的目录设定一个 .gitignore。</p>
<h2 id="pull-requesthttpswwwzhihucomquestion21682976answer79489643"><a href="https://www.zhihu.com/question/21682976/answer/79489643">Pull Request</a><a hidden class="anchor" aria-hidden="true" href="#pull-requesthttpswwwzhihucomquestion21682976answer79489643">#</a></h2>
<p>当你想更正别人仓库里的错误时，要走一个流程：</p>
<ol>
<li>先 fork 别人的仓库，相当于拷贝一份，相信我，不会有人直接让你改修原仓库的。</li>
<li>clone 到本地分支，做一些 bug fix。</li>
<li>发起 <a href="https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/about-pull-requests">pull request</a> 给原仓库，让他看到你修改的 bug。</li>
<li>原仓库 review 这个 bug，如果是正确的话，就会 merge 到他自己的项目中</li>
</ol>
<p>至此，整个 pull request 的过程就结束了。</p>
<p>拉取请求，就是请求对方拉取我本地仓库的 bug fix，合并到对方的 repo 中。以对方的视角来看，我的本地仓库就是一个远程仓库。因为我们是在请求对方做什么，所以要以对方视角来看，即 pull，因为对方可能同意，也可能不同意，所以是请求，即 pull request。</p>
<h2 id="github-hosts">GitHub Hosts<a hidden class="anchor" aria-hidden="true" href="#github-hosts">#</a></h2>
<h3 id="github520httpsgithubcom521xueweihangithub520"><a href="https://github.com/521xueweihan/GitHub520">GitHub520</a><a hidden class="anchor" aria-hidden="true" href="#github520httpsgithubcom521xueweihangithub520">#</a></h3>
<p>本项目无需安装任何程序，通过修改本地 hosts 文件，试图解决：</p>
<ul>
<li>GitHub 访问速度慢的问题</li>
<li>GitHub 项目中的图片显示不出的问题</li>
</ul>
<p>花 5 分钟时间，让你&quot;爱&quot;上 GitHub。</p>
<pre tabindex="0"><code># GitHub520 Host Start
140.82.112.26                 alive.github.com
140.82.114.25                 live.github.com
185.199.108.154               github.githubassets.com
140.82.113.22                 central.github.com
185.199.108.133               desktop.githubusercontent.com
185.199.108.153               assets-cdn.github.com
185.199.108.133               camo.githubusercontent.com
185.199.108.133               github.map.fastly.net
199.232.69.194                github.global.ssl.fastly.net
140.82.113.4                  gist.github.com
185.199.108.153               github.io
140.82.114.3                  github.com
140.82.114.5                  api.github.com
185.199.108.133               raw.githubusercontent.com
185.199.108.133               user-images.githubusercontent.com
185.199.108.133               favicons.githubusercontent.com
185.199.108.133               avatars5.githubusercontent.com
185.199.108.133               avatars4.githubusercontent.com
185.199.108.133               avatars3.githubusercontent.com
185.199.108.133               avatars2.githubusercontent.com
185.199.108.133               avatars1.githubusercontent.com
185.199.108.133               avatars0.githubusercontent.com
185.199.108.133               avatars.githubusercontent.com
140.82.112.10                 codeload.github.com
52.216.170.203                github-cloud.s3.amazonaws.com
52.217.98.76                  github-com.s3.amazonaws.com
52.216.164.3                  github-production-release-asset-2e65be.s3.amazonaws.com
52.216.160.147                github-production-user-asset-6210df.s3.amazonaws.com
52.217.103.12                 github-production-repository-file-5c1aeb.s3.amazonaws.com
185.199.108.153               githubstatus.com
64.71.168.201                 github.community
185.199.108.133               media.githubusercontent.com


# Update time: 2021-07-04T08:07:49+08:00
# Star me GitHub url: https://github.com/521xueweihan/GitHub520
# GitHub520 Host End
</code></pre><h2 id="github-pages">GitHub Pages<a hidden class="anchor" aria-hidden="true" href="#github-pages">#</a></h2>
<h3 id="使用-githubhttpsdocsgithubcomcnfree-pro-teamlatestgithubworking-with-github-pagesgetting-started-with-github-pages"><a href="https://docs.github.com/cn/free-pro-team@latest/github/working-with-github-pages/getting-started-with-github-pages">使用 GitHub</a><a hidden class="anchor" aria-hidden="true" href="#使用-githubhttpsdocsgithubcomcnfree-pro-teamlatestgithubworking-with-github-pagesgetting-started-with-github-pages">#</a></h3>
<p>GitHub Pages 是一项静态站点托管服务，它直接从 GitHub 上的仓库获取 HTML、CSS 和 JavaScript 文件，（可选）通过构建过程运行文件，然后发布网站。</p>
<p>有三种类型的 GitHub Pages 站点：项目、用户和组织。 项目站点连接到 GitHub 上托管的特定项目。 用户和组织站点连接到特定的 GitHub 帐户。</p>
<p>To publish a user site, you must create a repository owned by your user account that&rsquo;s named <code>&lt;username.github.io&gt;</code>. Repositories using the legacy <code>&lt;username.github.com&gt;</code> naming scheme will still be published, but visitors will be redirected from <code>http(s)://&lt;username.github.com&gt;</code> to <code>http(s)://&lt;username.github.io</code>. If both a <code>&lt;username.github.com&gt;</code> and <code>&lt;username.github.io&gt;</code> repository exist, only the <code>&lt;username.github.io&gt;</code> repository will be published.</p>
<p>GitHub Pages sites are publicly available on the internet, even if the repository for the site is private or internal. 如果站点的仓库中有敏感数据，您可能想要在发布前删除它。</p>
<p>GitHub Pages 站点的发布来源是存储站点源文件的分支和文件夹。用户和组织站点的默认发布源是仓库默认分支的根目录。 项目站点的默认发布来源是 <code>gh-pages</code> 分支的根目录。</p>
<p>您可以创建自己的静态文件或使用静态站点生成器为您构建站点。默认情况下，GitHub Pages 将使用 Jekyll 来构建您的站点。</p>
<p>GitHub Pages 站点受到以下使用限制的约束：</p>
<ul>
<li>GitHub Pages source repositories have a recommended limit of 1GB.</li>
<li>发布的 GitHub Pages 站点不得超过 1 GB。</li>
<li>GitHub Pages sites have a soft bandwidth limit of 100GB per month.</li>
<li>GitHub Pages sites have a soft limit of 10 builds per hour.</li>
</ul>
<p>可在 Repository 的 Settings 中配置 GitHub Pages 站点的发布源或取消发布 GitHub Pages 站点。</p>
<h3 id="使用-jekyllhttpsdocsgithubcomcnfree-pro-teamlatestgithubworking-with-github-pagessetting-up-a-github-pages-site-with-jekyll"><a href="https://docs.github.com/cn/free-pro-team@latest/github/working-with-github-pages/setting-up-a-github-pages-site-with-jekyll">使用 jekyll</a><a hidden class="anchor" aria-hidden="true" href="#使用-jekyllhttpsdocsgithubcomcnfree-pro-teamlatestgithubworking-with-github-pagessetting-up-a-github-pages-site-with-jekyll">#</a></h3>
<p>Github Docs 与 Jekyll 文档不一致，Windows 并未正式支持 Jekyll。</p>
<h3 id="使用-hexohttpshexoiozh-cndocs"><a href="https://hexo.io/zh-cn/docs/">使用 Hexo</a><a hidden class="anchor" aria-hidden="true" href="#使用-hexohttpshexoiozh-cndocs">#</a></h3>
<p>我选择 Hexo，一个是安装简单；一个是文档好。</p>
<h2 id="github-actions">GitHub Actions<a hidden class="anchor" aria-hidden="true" href="#github-actions">#</a></h2>
<h3 id="github-actions-是什么">GitHub Actions 是什么<a hidden class="anchor" aria-hidden="true" href="#github-actions-是什么">#</a></h3>
<p>持续集成由很多操作组成，比如自动抓取代码、运行测试、登录远程服务器、发布到第三方服务等。GitHub 把这些操作就称为 actions。</p>
<p>很多操作在不同项目里面是类似的，可以共享。GitHub 允许开发者把每个操作写成独立的脚本文件，存放到代码仓库，使得其他开发者可以引用。</p>
<p>可在<a href="https://github.com/marketplace?type=actions">官方市场</a>与 <a href="https://github.com/sdras/awesome-actions">awesome actions</a> 找 action。</p>
<h3 id="workflow-文件">workflow 文件<a hidden class="anchor" aria-hidden="true" href="#workflow-文件">#</a></h3>
<p>GitHub Actions 的配置文件叫做 workflow 文件，存放在代码仓库的 <code>.github/workflows</code> 目录。</p>
<p>workflow 文件采用 YAML 格式，一个库可以有多个 workflow 文件。GitHub 发现 <code>.github/workflows</code> 目录里有 <code>.yml</code> 文件，就会自动运行该文件。</p>
<p>配置字段：</p>
<ul>
<li>
<p>name：工作流程的名称。如果省略 name，GitHub 将其设置为相对于仓库根目录的工作流程文件路径</p>
</li>
<li>
<p>on：必要，触发工作流程的 GitHub 事件的名称</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yml" data-lang="yml"><span style="color:#f92672">on</span>: [<span style="color:#ae81ff">push, pull_request]</span>
</code></pre></div></li>
<li>
<p>on.&lt;push|pull_request&gt;.&lt;branches|tags&gt;：您可以将工作流配置为在特定分支或标记上运行</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yml" data-lang="yml"><span style="color:#f92672">on</span>:
  <span style="color:#f92672">push</span>:
    <span style="color:#f92672">branches</span>:    
      - <span style="color:#ae81ff">main</span>
      - <span style="color:#e6db74">&#39;mona/octocat&#39;</span>
      - <span style="color:#e6db74">&#39;releases/**&#39;</span>
    <span style="color:#f92672">tags</span>:        
      - <span style="color:#ae81ff">v1</span>
      - <span style="color:#ae81ff">v1.* </span>
</code></pre></div></li>
<li>
<p>jobs：工作流程运行包括一项或多项作业。每项作业必须关联一个 ID</p>
<ul>
<li>
<p>jobs.&lt;job_id&gt;.name：job_id 里面的 name 字段是任务的说明</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yml" data-lang="yml"><span style="color:#f92672">jobs</span>:
  <span style="color:#f92672">my_first_job</span>:
    <span style="color:#f92672">name</span>: <span style="color:#ae81ff">My first job</span>
  <span style="color:#f92672">my_second_job</span>:
    <span style="color:#f92672">name</span>: <span style="color:#ae81ff">My second job</span>
</code></pre></div></li>
<li>
<p>jobs.&lt;job_id&gt;.needs：作业默认是并行运行。needs字段指定当前任务的运行顺序</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yml" data-lang="yml"><span style="color:#f92672">jobs</span>:
  <span style="color:#f92672">job1</span>:
  <span style="color:#f92672">job2</span>:
    <span style="color:#f92672">needs</span>: <span style="color:#ae81ff">job1</span>
  <span style="color:#f92672">job3</span>:
    <span style="color:#f92672">needs</span>: [<span style="color:#ae81ff">job1, job2]</span>
</code></pre></div><p>此例中作业执行顺序：job1、job2、job3</p>
</li>
<li>
<p>jobs.&lt;job_id&gt;.runs-on：必需，运行作业的机器类型</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yml" data-lang="yml"><span style="color:#f92672">runs-on</span>: <span style="color:#ae81ff">ubuntu-latest</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p>jobs.&lt;job_id&gt;.steps：作业包含一系列任务，称为 steps</p>
<ul>
<li>
<p>jobs.&lt;job_id&gt;.steps.name：步骤名称</p>
</li>
<li>
<p>jobs.&lt;job_id&gt;.steps.uses：引用的 Actions</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yml" data-lang="yml"><span style="color:#f92672">steps</span>:    
  <span style="color:#75715e"># Reference a specific commit</span>
  - <span style="color:#f92672">uses</span>: <span style="color:#ae81ff">actions/setup-node@74bc508</span>
  <span style="color:#75715e"># Reference a minor version of a release</span>
  - <span style="color:#f92672">uses</span>: <span style="color:#ae81ff">actions/setup-node@v1.2</span>
  <span style="color:#75715e"># Reference a branch</span>
  - <span style="color:#f92672">uses</span>: <span style="color:#ae81ff">actions/setup-node@main</span>
</code></pre></div></li>
<li>
<p>jobs.&lt;job_id&gt;.steps.run：使用操作系统 shell 运行命令行程序</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yml" data-lang="yml">- <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Clean install dependencies and build</span>
  <span style="color:#f92672">run</span>: |<span style="color:#e6db74">
</span><span style="color:#e6db74">    npm ci
</span><span style="color:#e6db74">    npm run build</span>    
</code></pre></div></li>
</ul>
</li>
</ul>
<h3 id="参考">参考<a hidden class="anchor" aria-hidden="true" href="#参考">#</a></h3>
<p><a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html">GitHub Actions 入门教程</a></p>
<p><a href="https://docs.github.com/cn/free-pro-team@latest/actions">GitHub Actions</a></p>
<h2 id="持续集成continuous-integration简称ci">持续集成（Continuous integration，简称CI）<a hidden class="anchor" aria-hidden="true" href="#持续集成continuous-integration简称ci">#</a></h2>
<h3 id="概念">概念<a hidden class="anchor" aria-hidden="true" href="#概念">#</a></h3>
<p>持续集成指的是，频繁地（一天多次）将代码合并（集成）到主干源码仓库。在 CI 中可以通过自动化等手段高频率地去获取产品反馈并响应反馈的过程。</p>
<h3 id="流程">流程<a hidden class="anchor" aria-hidden="true" href="#流程">#</a></h3>
<p><img loading="lazy" src="/Git/CI.png" alt=""  />
</p>
<ul>
<li>提交：开发者向代码仓库提交代码</li>
<li>测试（第一轮）：代码仓库对提交的代码跑自动化测试
<ul>
<li>单元测试：针对函数或模块的测试</li>
<li>集成测试：针对整体产品的某个功能的测试，又称功能测试</li>
<li>端对端测试：从用户界面直达数据库的全链路测试</li>
</ul>
</li>
<li>构建：将源码转换为可以运行的实际代码，会安装依赖，配置各种资源等。常用的构建工具如下
<ul>
<li><a href="http://jenkins-ci.org/">Jenkins</a>：开源</li>
<li><a href="https://travis-ci.com/">Travis</a></li>
<li><a href="https://www.codeship.io/">Codeship</a></li>
<li><a href="http://stridercd.com/">Strider</a>：开源</li>
</ul>
</li>
<li>测试（第二轮）：第二轮是全面测试</li>
<li>部署：直接部署</li>
<li>回滚：当前版本发生问题，回滚到上一个版本的构建结果</li>
</ul>
<h2 id="commit-message">Commit message<a hidden class="anchor" aria-hidden="true" href="#commit-message">#</a></h2>
<p>社区有多种 Commit Message Conventions。本文介绍 <a href="https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#heading=h.greljkmo14y0">Angular 规范</a>。</p>
<h3 id="格式化的-commit-message-好处">格式化的 Commit message 好处<a hidden class="anchor" aria-hidden="true" href="#格式化的-commit-message-好处">#</a></h3>
<ul>
<li>
<p>提供更多的历史信息，方便浏览</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git log HEAD --pretty<span style="color:#f92672">=</span>format:%s
</code></pre></div></li>
<li>
<p>可以过滤某些 commit，便于查找信息</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git log HEAD --grep feature
</code></pre></div></li>
<li>
<p>可以直接从 commit 生成 Change Log</p>
</li>
</ul>
<h3 id="commit-message-的格式">Commit message 的格式<a hidden class="anchor" aria-hidden="true" href="#commit-message-的格式">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"><span style="color:#f92672">&lt;type&gt;</span>(<span style="color:#f92672">&lt;scope&gt;</span>): <span style="color:#f92672">&lt;subject&gt;</span>
// 空一行
<span style="color:#f92672">&lt;body&gt;</span>
// 空一行
<span style="color:#f92672">&lt;footer&gt;</span>
</code></pre></div><ul>
<li>
<p>Header 只有一行</p>
<ul>
<li>type 用于说明 commit 的类别
<ul>
<li>feat：新功能</li>
<li>fix：修补bug</li>
<li>docs：文档</li>
<li>style： 格式</li>
<li>refactor：重构</li>
<li>test：增加测试</li>
<li>chore：构建过程或辅助工具的变动</li>
<li>Revert：当前 commit 用于撤销以前的 commit</li>
</ul>
</li>
<li>scope 用于说明 commit 影响的范围</li>
<li>subject 是 commit 目的的简短描述
<ul>
<li>以动词开头，使用第一人称现在时</li>
<li>第一个字母小写</li>
<li>结尾不加句号</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Body 部分是对本次 commit 的详细描述</p>
</li>
<li>
<p>Footer</p>
<ul>
<li>
<p>不兼容变动：如果当前代码与上一个版本不兼容，则以 <code>BREAKING CHANGE</code> 开头，后面是对变动的描述、以及变动理由和迁移方法</p>
</li>
<li>
<p>关闭 Issue：如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue</p>
<pre tabindex="0"><code>Closes #123, #245, #992
</code></pre></li>
</ul>
</li>
</ul>
<h3 id="commitizen">Commitizen<a hidden class="anchor" aria-hidden="true" href="#commitizen">#</a></h3>
<p><a href="https://github.com/commitizen/cz-cli">Commitizen</a> 是一个撰写 Commit message 的工具</p>
<ul>
<li>
<p>Install the Commitizen cli tools</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">npm install commitizen -g
</code></pre></div></li>
<li>
<p>Initialize your project to use the cz-conventional-changelog adapter</p>
<pre tabindex="0"><code>commitizen init cz-conventional-changelog --save-dev --save-exact
</code></pre></li>
<li>
<p>以后，凡是用到 <code>git commit</code> 命令，一律改为使用 <code>git cz</code>。</p>
</li>
</ul>
<h3 id="参考-1">参考<a hidden class="anchor" aria-hidden="true" href="#参考-1">#</a></h3>
<p><a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html">Commit message 和 Change log 编写指南</a></p>
<h2 id="yamlyaml-aint-a-markup-language">YAML（YAML Ain&rsquo;t a Markup Language）<a hidden class="anchor" aria-hidden="true" href="#yamlyaml-aint-a-markup-language">#</a></h2>
<p>YAML 是专门用来写配置文件的语言</p>
<h3 id="简介">简介<a hidden class="anchor" aria-hidden="true" href="#简介">#</a></h3>
<p>规则：</p>
<ul>
<li>大小写敏感</li>
<li>使用缩进表示层级关系</li>
<li>缩进时不允许使用 Tab 键，只允许使用空格。</li>
<li>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</li>
<li><code>#</code> 表示注释，从这个字符一直到行尾，都会被解析器忽略</li>
<li>对象和数组可以结合使用，形成复合结构</li>
</ul>
<h3 id="对象">对象<a hidden class="anchor" aria-hidden="true" href="#对象">#</a></h3>
<p>一组键值对</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">animal</span>: <span style="color:#ae81ff">pets</span>
</code></pre></div><p>行内表示法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">hash</span>: { <span style="color:#f92672">name: Steve, foo</span>: <span style="color:#ae81ff">bar } </span>
</code></pre></div><h3 id="数组">数组<a hidden class="anchor" aria-hidden="true" href="#数组">#</a></h3>
<p>一组连词线开头的行</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">- <span style="color:#ae81ff">Cat</span>
- <span style="color:#ae81ff">Dog</span>
- <span style="color:#ae81ff">Goldfish</span>
</code></pre></div><p>数据结构的子成员是一个数组，则可以在该项下面缩进一个空格</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">-
 - <span style="color:#ae81ff">Cat</span>
 - <span style="color:#ae81ff">Dog</span>
 - <span style="color:#ae81ff">Goldfish</span>
</code></pre></div><p>行内表示法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">animal</span>: [<span style="color:#ae81ff">Cat, Dog]</span>
</code></pre></div><h3 id="纯量">纯量<a hidden class="anchor" aria-hidden="true" href="#纯量">#</a></h3>
<ul>
<li>
<p>字符串：字符串默认不使用引号表示</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">str</span>: <span style="color:#ae81ff">这是一行字符串</span>
</code></pre></div><p>包含空格或特殊字符，需要放在引号之中，单引号和双引号都可以使用，双引号不会对特殊字符转义</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">str</span>: <span style="color:#e6db74">&#39;内容： 字符串&#39;</span>
</code></pre></div><p>单引号之中如果还有单引号，必须连续使用两个单引号转义</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">str</span>: <span style="color:#e6db74">&#39;labor&#39;&#39;s day&#39;</span> 
</code></pre></div><p>字符串可以写成多行，从第二行开始，必须有一个单空格缩进。换行符会被转为空格</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">str</span>: <span style="color:#ae81ff">这是一段</span>
  <span style="color:#ae81ff">多行</span>
  <span style="color:#ae81ff">字符串</span>
</code></pre></div><p>多行字符串可以使用<code>|</code>保留换行符，也可以使用<code>&gt;</code>折叠换行</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">this</span>: |<span style="color:#e6db74">
</span><span style="color:#e6db74">  Foo
</span><span style="color:#e6db74">  Bar</span>  
<span style="color:#f92672">that</span>: &gt;<span style="color:#e6db74">
</span><span style="color:#e6db74">  Foo
</span><span style="color:#e6db74">  Bar</span>  
</code></pre></div><p><code>+</code>表示保留文字块末尾的换行，<code>-</code>表示删除字符串末尾的换行</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">s1</span>: |<span style="color:#e6db74">
</span><span style="color:#e6db74">  </span>  <span style="color:#ae81ff">Foo</span>

<span style="color:#f92672">s2</span>: |+<span style="color:#e6db74">
</span><span style="color:#e6db74">  </span>  <span style="color:#ae81ff">Foo</span>
</code></pre></div><p>s3: |-
Foo</p>
</li>
</ul>
<pre tabindex="0"><code>字符串之中可以插入 HTML 标记

```yaml
message: |

  &lt;p style=&quot;color: red&quot;&gt;
    段落
  &lt;/p&gt;
</code></pre><h3 id="参考-2">参考<a hidden class="anchor" aria-hidden="true" href="#参考-2">#</a></h3>
<p><a href="http://www.ruanyifeng.com/blog/2016/07/yaml.html">YAML 语言教程</a></p>
<p><a href="https://yaml.org/">The Official YAML Web Site</a></p>
<h2 id="开源许可证">开源许可证<a hidden class="anchor" aria-hidden="true" href="#开源许可证">#</a></h2>
<p>一般情况下，软件的源代码只由编写者拥有，而开源（即开放源代码，Open Source Code）是指一种更自由的软件发布模式。简单来说，开源软件的特点就是把软件程序和源代码文件一起打包提供给用户，让用户在不受限制地使用某个软件功能的基础上还可以对代码按需修改，让软件更贴合硬件环境，让功能更符合工作需求。用户还可以将其编制成衍生产品再发布出去。用户一般享有使用自由、复制自由、修改自由、创建衍生品自由，以及收费自由。是的，您没有看错，用户具备创建衍生品和收费的自由。这也就是说，可以对一个开源软件进行深度定制化加工。如果修改过的程序更加好用，或者颇具新的特色，只要符合原作者的许可要求，我们就完全可以合法地将软件进行商标注册，以商业版的形式再发布出去，只要有新用户使用您的软件并支付相应的费用，那就是您的收入。这也正好符合了黑客和极客对自由的追求，因此在合作与竞争中，国内外的开源社区慢慢生长出了强健的根基，人气也非常高。</p>
<p>但是，如果开源软件只单纯追求“自由”而牺牲了程序员的利益，这肯定会影响程序员的创作热情。为了平衡两者的关系，截至目前，世界上已经有100多种被开源促进组织（OSI，Open Source Initiative）确认的开源许可证，用于保护开源工作者的权益。对于那些只知道一味抄袭、篡改、破解或者盗版他人作品的不法之徒，终归会在某一天收到法院的传票。</p>
<p>考虑到大家没准儿以后会以开源工作者的身份编写出一款畅销软件，因此刘遄老师根据开源促进组织的推荐建议以及实际使用情况，为大家筛选出了程序员最喜欢的前6名的开源许可证，并教大家怎么从中进行选择。提前了解最热门的开源许可证，并在未来选择一个合适的可最大程度地保护自己软件权益的开源许可证，这对创业公司来讲能起到事半功倍的作用。</p>
<p>开源许可证总览：https://opensource.org/licenses/alphabetical</p>
<p><strong>Tips</strong>：上述提到的“开源许可证”与“开源许可协议”的含义完全相同，只不过是英文翻译后两种不同的叫法，这里不作区别。</p>
<p><strong>Tips</strong>：自由软件基金会（Free Software Foundation，FSF）是一个非营利组织，其使命是在全球范围内促进计算机用户的自由，捍卫所有软件用户的权利。</p>
<p>大家经常会在开源社区中看到Copyleft这个单词，这是一个由自由软件运动所发展出的概念，中文被翻译为“著佐权”或者“公共版权”。与Copyright截然相反，Copyleft不会限制使用者复制、修改或再发布软件。</p>
<p>此外，大家应该经常会听到别人说开源软件是free的，没错，开源软件就是自由的。这里的free千万不要翻译成“免费”，这样就大错特错了，这与您去酒吧看到的“第一杯免费”的意思可相差甚远。</p>
<p>下面我们来看一下程序员最喜欢的前6名的开源许可证，以及它们各自赋予用户的权利。</p>
<h3 id="gpl">GPL<a hidden class="anchor" aria-hidden="true" href="#gpl">#</a></h3>
<p>**GNU通用公共许可证（**General Public License，<strong>GPL）</strong>：目前广泛使用的开源软件许可协议之一，用户享有运行、学习、共享和修改软件的自由。GPL最初是自由软件基金会创始人Richard Stallman起草的，其版本目前已经发展到了第3版。GPL的目的是保证程序员在开源社区中所做的工作对整个世界是有益的，所开发的软件也是自由的，并极力避免开源软件被私有化以及被无良软件公司所剥削。</p>
<p>现在，只要软件中包含了遵循GPL许可证的产品或代码，该软件就必须开源、免费，因此这个许可证并不适合商业收费软件。遵循该许可证的开源软件数量极其庞大，包括Linux内核在内的大多数的开源软件都是基于GPL许可证的。GPL赋予了用户著名的五大自由。</p>
<blockquote>
<p>**使用自由：**允许用户根据需要自由使用这个软件。</p>
<p>**复制自由：**允许把软件复制到任何人的计算机中，并且不限制复制的数量。</p>
<p>**修改自由：**允许开发人员增加或删除软件的功能，但软件修改后必须依然基于GPL许可证。</p>
<p>**衍生自由：**允许用户深度定制化软件后，为软件注册自己的新商标，再发行衍生品的自由。</p>
<p>**收费自由：**允许在各种媒介上出售该软件，但必须提前让买家知道这个软件是可以免费获得的。因此，一般来讲，开源软件都是通过为用户提供有偿服务的形式来营利的。</p>
</blockquote>
<h3 id="lgpl">LGPL<a hidden class="anchor" aria-hidden="true" href="#lgpl">#</a></h3>
<p><strong>较宽松通用公共许可证（Lesser GPL, LGPL）</strong>：一个主要为保护类库权益而设计的GPL开源协议。与标准GPL许可证相比，LGPL允许商业软件以类库引用的方式使用开源代码，而不用将其产品整体开源，因此普遍被商业软件用来引用类库代码。简单来说，就是针对使用了基于LGPL许可证的开源代码，在涉及这部分代码，以及修改过或者衍生出来的代码时，都必须继续采用LGPL协议，除此以外的其他代码则不强制要求。</p>
<p>如果您觉得LGPL许可证更多地是关注对类库文件的保护，而不是软件整体，那就对了。因为该许可证最早的名字是Library GPL，即GPL类库开源许可证，保护的对象有glibc、GTK widget toolkit等类库文件。</p>
<h3 id="bsd">BSD<a hidden class="anchor" aria-hidden="true" href="#bsd">#</a></h3>
<p>**伯克利软件发布版（**<strong>Berkeley Software Distribution, BSD）许可证</strong>：另一款被广泛使用的开源软件许可协议。相较于GPL许可证，BSD更加宽松，适合于商业用途。用户可以使用、修改和重新发布遵循该许可证的软件，并且可以将软件作为商业软件发布和销售，前提是需要满足下面3个条件。</p>
<blockquote>
<p>如果再发布的软件中包含开源代码，则源代码必须继续遵循BSD许可证。</p>
<p>如果再发布的软件中只有二进制程序，则需要在相关文档或版权文件中声明原始代码遵循了BSD许可证。</p>
<p>不允许用原始软件的名字、作者名字或机构名称进行市场推广。</p>
</blockquote>
<h3 id="apache">Apache<a hidden class="anchor" aria-hidden="true" href="#apache">#</a></h3>
<p><strong>Apache许可证（Apache License）</strong>：顾名思义，是由Apache软件基金会负责发布和维护的开源许可协议。作为当今世界上最大的开源基金会，Apache不仅因此协议而出名，还因市场占有率第一的Web服务器软件而享誉行业。目前使用最广泛的Apache许可证是2004年发行的2.0版本，它在为开发人员提供版权及专利许可的同时，还允许用户拥有修改代码及再发布的自由。该许可证非常适合用于商业软件，现在热门的Hadoop、Apache HTTP Server、MongoDB等项目都是基于该许可证研发的。程序开发人员在开发遵循该许可证的软件时，要严格遵守下面4个条件。</p>
<blockquote>
<p>该软件及其衍生品必须继续使用Apache许可证。</p>
<p>如果修改了程序源代码，需要在文档中进行声明。</p>
<p>若软件是基于他人的源代码编写而成的，则需要保留原始代码的许可证、商标、专利声明及原作者声明的其他内容信息。</p>
<p>如果再发布的软件中有声明文件，则需在此文件中注明基于了Apache许可证及其他许可证。</p>
</blockquote>
<h3 id="mit">MIT<a hidden class="anchor" aria-hidden="true" href="#mit">#</a></h3>
<p><strong>MIT许可证（Massachusetts Institute of Technology License）</strong>：源于麻省理工学院，又称为X11协议。MIT许可证是目前限制最少的开源许可证之一，用户可以使用、复制、修改、再发布软件，而且只要在修改后的软件源代码中保留原作者的许可信息即可，因此普遍被商业软件（例如jQuery与Node.js）所使用。也就是说，MIT许可证宽松到一个新境界，即用户只要在代码中声明了MIT许可证和版权信息，就可以去做任何事情，而无须承担任何责任。</p>
<h3 id="mpl">MPL<a hidden class="anchor" aria-hidden="true" href="#mpl">#</a></h3>
<p>**Mozilla公共许可证（**Mozilla Public License，<strong>MPL）</strong>：于1998年初由Netscape公司的Mozilla小组设计，原因是它们认为GPL和BSD许可证不能很好地解决开发人员对源代码的需求和收益之间的平衡关系，因此便将这两个协议进行融合，形成了MPL。2012年年初，Mozilla基金会发布了MPL 2.0版本（目前为止也是最新的版本），后续被用在Firefox、Thunderbird等诸多产品上。最新版的MPL公共许可证有以下特点。</p>
<blockquote>
<p>在使用基于MPL许可证的源代码时，后续只需要继续开源这部分特定代码即可，新研发的软件不用完全被该许可证控制。</p>
<p>开发人员可以将基于MPL、GPL、BSD等多种许可证的代码一起混合使用。</p>
<p>开发人员在发布新软件时，必须附带一个专门用于说明该程序的文件，内容要有原始代码的修改时间和修改方式。</p>
</blockquote>
<h3 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h3>
<p>估计大家在看完上面琳琅满目的许可证后，会心生怨念：“这不都差不多吗？到底该选哪个呢？”写到这里时，刘遄老师也是一脸无助：“到底该怎么让大家进行选择呢？”搜肠刮肚之际突然眼前一亮，乌克兰程序员Paul Bagwell创作的一幅流程图正好对刚才讲过的这6款开源许可证进行了汇总归纳，具体如下图所示。</p>
<p><img loading="lazy" src="Git/%e5%bc%80%e6%ba%90%e5%8d%8f%e8%ae%ae%e9%80%89%e6%8b%a9%e6%b5%81%e7%a8%8b%e5%9b%be-1.jpg" alt="第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统"  />
</p>
<p>开源许可证的选择流程图</p>
<p>众所周知，绝大部分的开源软件在安装完毕之后即可使用，很难在软件界面中找到相关的收费信息。所以经常会有同学提问：“刘老师，开源社区的程序员总要吃饭的呀，他们是靠什么营利呢？”针对这个问题，网络上好像只有两种声音：</p>
<blockquote>
<p>**情怀——**开源社区的程序员觉悟好，本领强，写代码纯粹是为了兴趣以及造福社会；</p>
<p>**服务——**先让用户把软件安装上，等用好、用习惯之后，再通过提供一些维护服务来营利。</p>
</blockquote>
<p>这两种解释都各有道理，但是不够全面。读者也不要把开源软件和商业软件完全对立起来，因为好的项目也需要好的运营模式。就开源软件来讲，营利模式具体包括以下5种。</p>
<blockquote>
<p><strong>多条产品线</strong>：如MySQL数据库便有个人版和企业版两个版本，即个人版完全免费，起到了很好的推广作用；企业版则通过销售授权许可来营利。</p>
<p><strong>技术服务型</strong>：JBoss应用服务器便是典型代表，JBoss软件可自由免费使用，软件提供方通过技术文档、培训课程以及定制开发服务来盈利。</p>
<p><strong>软硬件结合</strong>：比如IBM公司在出售服务器时，一般会为用户捆绑销售AIX或Linux系统来确保硬件设施的营利。</p>
<p><strong>技术出版物</strong>：比如O&rsquo;Reilly既是一家开源公司，也是一家出版商，诸多优秀图书都是由O&rsquo;Reilly出版的。</p>
<p><strong>品牌和口碑</strong>：微软公司曾多次表示支持开源社区。大家对此可能会感到意外，但这是真的！Visual Studio Code、PowerShell、TypeScript等软件均已开源。大家是不是瞬间就对微软公司好感倍增了呢？买一份正版系统表示支持也就是人之常情了。</p>
</blockquote>
<h2 id="ssh-原理与运用">SSH 原理与运用<a hidden class="anchor" aria-hidden="true" href="#ssh-原理与运用">#</a></h2>
<h3 id="数字签名与数字证书httpwwwruanyifengcomblog201108what_is_a_digital_signaturehtml"><a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html">数字签名与数字证书</a><a hidden class="anchor" aria-hidden="true" href="#数字签名与数字证书httpwwwruanyifengcomblog201108what_is_a_digital_signaturehtml">#</a></h3>
<p><img loading="lazy" src="/Git/signature0.png" alt=""  />
</p>
<p>鲍勃有两把钥匙，一把是公钥，另一把是私钥。</p>
<p><img loading="lazy" src="/Git/signature1.png" alt=""  />
</p>
<p>鲍勃把公钥送给他的朋友们——帕蒂、道格、苏珊——每人一把。</p>
<p><img loading="lazy" src="/Git/signature2.png" alt=""  />
</p>
<p>苏珊要给鲍勃写一封保密的信。她写完后用鲍勃的公钥加密，就可以达到保密的效果。</p>
<p><img loading="lazy" src="/Git/signature3.png" alt=""  />
</p>
<p>鲍勃收信后，用私钥解密，就看到了信件内容。只要鲍勃的私钥不泄露，这封信就是安全的，即使落在别人手里，也无法解密。</p>
<p><img loading="lazy" src="/Git/signature4.png" alt=""  />
</p>
<p>鲍勃给苏珊回信，决定采用&quot;数字签名&quot;。他写完后先用Hash函数，生成信件的摘要（digest）。</p>
<p><img loading="lazy" src="/Git/signature5.png" alt=""  />
</p>
<p>然后，鲍勃使用私钥，对这个摘要加密，生成&quot;数字签名&quot;（signature）。</p>
<p><img loading="lazy" src="/Git/signature6.png" alt=""  />
</p>
<p>鲍勃将这个签名，附在信件下面，一起发给苏珊。</p>
<p><img loading="lazy" src="/Git/signature7.png" alt=""  />
</p>
<p>苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。</p>
<p><img loading="lazy" src="/Git/signature8.png" alt=""  />
</p>
<p>苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。</p>
<p><img loading="lazy" src="/Git/signature9.png" alt=""  />
</p>
<p>复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。此时，苏珊实际拥有的是道格的公钥，但是还以为这是鲍勃的公钥。因此，道格就可以冒充鲍勃，用自己的私钥做成&quot;数字签名&quot;，写信给苏珊，让苏珊用假的鲍勃公钥进行解密。</p>
<p><img loading="lazy" src="/Git/signature10.png" alt=""  />
</p>
<p>后来，苏珊感觉不对劲，发现自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去找&quot;证书中心&quot;（certificate authority，简称CA），为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成&quot;数字证书&quot;（Digital Certificate）。</p>
<p><img loading="lazy" src="/Git/signature11.png" alt=""  />
</p>
<p>鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。</p>
<p><img loading="lazy" src="/Git/signature12.png" alt=""  />
</p>
<p>苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明&quot;数字签名&quot;是否真的是鲍勃签的。</p>
<h3 id="远程登录httpwwwruanyifengcomblog201112ssh_remote_loginhtml"><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html">远程登录</a><a hidden class="anchor" aria-hidden="true" href="#远程登录httpwwwruanyifengcomblog201112ssh_remote_loginhtml">#</a></h3>
<ul>
<li>
<p>1995年，芬兰学者 Tatu Ylonen 设计了 SSH 协议，用于计算机之间的加密登录。本文针对的实现是 <a href="http://www.openssh.com/">OpenSSH</a>。</p>
</li>
<li>
<p>基本用法：</p>
<ul>
<li>
<p>假定你要以用户名 user，登录远程主机 host</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">ssh user@host
</code></pre></div></li>
<li>
<p>如果本地用户名与远程用户名一致，登录时可以省略用户名</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">ssh host
</code></pre></div></li>
<li>
<p>SSH 的默认端口是 22，使用 p 参数修这个端口</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">ssh -p <span style="color:#ae81ff">2222</span> user@host
</code></pre></div></li>
</ul>
</li>
<li>
<p>中间人攻击（Man-in-the-middle attack）</p>
<ul>
<li>
<p>SSH 加密登录过程</p>
<ul>
<li>远程主机收到用户的登录请求，把自己的公钥发给用户。</li>
<li>用户使用这个公钥，将登录密码加密后，发送给远程主机。</li>
<li>远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>中间人攻击：攻击者插在用户与远程主机之间，用伪造的公钥，获取用户的登录密码，再用这个密码登录远程主机。</p>
</li>
<li>
<p>口令登录：第一次登录远程主机时，会询问是否接受远程主机公钥（是否继续连接），并显示公钥指纹——公钥长度较长（这里采用RSA算法，长达 1024 位），很难比对，所以对其进行MD5计算，将它变成一个 128 位的指纹。用户通过比对远程网站上贴出的公钥指纹，决定是否接受这个远程主机的公钥。当远程主机的公钥被接受以后，它就会被保存在文件 <code>$HOME/.ssh/known_hosts</code> 之中。</p>
</li>
<li>
<p>公钥登录：省去口令登录每次都必须输入密码的步骤。用户将自己的公钥储存在远程主机上，登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来，远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。</p>
<ul>
<li>
<p><code>ssh-keygen</code></p>
<p>在 <code>$HOME/.ssh/</code> 目录下生成两个文件：公钥 <code>id_rsa.pub</code> 和私钥 <code>id_rsa</code>。</p>
</li>
</ul>
</li>
</ul>
<h3 id="远程操作与端口转发httpwwwruanyifengcomblog201112ssh_port_forwardinghtml"><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html">远程操作与端口转发</a><a hidden class="anchor" aria-hidden="true" href="#远程操作与端口转发httpwwwruanyifengcomblog201112ssh_port_forwardinghtml">#</a></h3>
<ul>
<li>
<p>SSH 可以在用户和远程主机之间，建立命令和数据的传输通道</p>
</li>
<li>
<p>绑定本地端口：让那些不加密的网络连接，全部改走 SSH 连接</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">ssh -D <span style="color:#ae81ff">8080</span> user@host
</code></pre></div><p>建立一个 socket，去监听本地的 8080 端口。一旦有数据传向那个端口，就自动把它转移到 SSH 连接上面，发往远程主机。</p>
</li>
<li>
<p>本地端口转发：假定 host1 是本地主机，host2 是远程主机。由于种种原因，这两台主机之间无法连通。但是，另外还有一台 host3，可以同时连通前面两台主机。因此，很自然的想法就是，通过 host3，将 host1 连上 host2。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">ssh -L 2121:host2:21 host3
</code></pre></div><p>L 参数接受三个值——&ldquo;本地端口:目标主机:目标主机端口&rdquo;。SSH 绑定本地端口 2121，指定 host3 将所有的数据转发到目标主机 host2 的 21 端口。本地端口转发使得 host1 和 host3 之间仿佛形成一个数据传输的秘密隧道，因此又被称为&quot;SSH 隧道&quot;。</p>
</li>
<li>
<p>远程端口转发：host1 与 host2 之间无法连通，必须借助 host3 转发，而 host3 是一台内网机器，它可以连接外网的 host1，但是反过来就不行。解决办法是从 host3 上建立与 host1 的 SSH 连接，然后在 host1 上使用这条连接。在 host3 执行下面的命令</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">ssh -R 2121:host2:21 host1
</code></pre></div><p>R 参数也是接受三个值——&ldquo;远程主机端口:目标主机:目标主机端口&rdquo;。它让 host1 监听它自己的 2121 端口，然后将所有数据经由 host3，转发到 host2 的 21 端口。</p>
</li>
</ul>
<h2 id="github-packageshttpsdocsgithubcomenpackages"><a href="https://docs.github.com/en/packages">GitHub Packages</a><a hidden class="anchor" aria-hidden="true" href="#github-packageshttpsdocsgithubcomenpackages">#</a></h2>
<p>Learn to safely publish and consume packages, store your packages alongside your code, and share your packages privately with your team or publicly with the open source community. You can also automate your packages with GitHub Actions.</p>
<h2 id="tip--questions">Tip &amp; Questions<a hidden class="anchor" aria-hidden="true" href="#tip--questions">#</a></h2>
<h3 id="repository-size-limits-for-githubcomhttpsstackoverflowcomquestions38768454repository-size-limits-for-github-com"><a href="https://stackoverflow.com/questions/38768454/repository-size-limits-for-github-com">Repository size limits for GitHub.com</a><a hidden class="anchor" aria-hidden="true" href="#repository-size-limits-for-githubcomhttpsstackoverflowcomquestions38768454repository-size-limits-for-github-com">#</a></h3>
<p>Hard limits:</p>
<ul>
<li>Individual files in a repository are strictly limited to a 100 MB maximum size limit.</li>
<li>Repositories have a hard size limit of 100GB.</li>
</ul>
<h3 id="解决ssh自动断线问题httpsmtjonetblogarticle30html"><a href="https://mtjo.net/blog/article/30.html">解决SSH自动断线问题</a><a hidden class="anchor" aria-hidden="true" href="#解决ssh自动断线问题httpsmtjonetblogarticle30html">#</a></h3>
<p>在连接远程SSH服务的时候，经常会发生长时间后的断线，或者无响应（无法再键盘输入）。 总体来说有两个方法：</p>
<p><strong>一、客户端定时发送心跳</strong></p>
<p>putty、SecureCRT、XShell都有这个功能，设置请自行搜索</p>
<p>此外在Linux下：</p>
<ul>
<li>
<p>修改本机/etc/ssh/ssh_config</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># vim /etc/ssh/ssh_config</span>
</code></pre></div></li>
<li>
<p>添加</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">ServerAliveInterval <span style="color:#ae81ff">30</span>
ServerAliveCountMax <span style="color:#ae81ff">100</span>
</code></pre></div><p>即每隔30秒，向服务器发出一次心跳。若超过100次请求，都没有发送成功，则会主动断开与服务器端的连接。</p>
</li>
</ul>
<p><strong>二、服务器端定时向客户端发送心跳（一劳永逸）</strong></p>
<ul>
<li>
<p>修改服务器端 ssh配置 /etc/ssh/sshd_config</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># vim /etc/ssh/sshd_config</span>
</code></pre></div></li>
<li>
<p>添加</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">ClientAliveInterval <span style="color:#ae81ff">30</span>
ClientAliveCountMax <span style="color:#ae81ff">6</span>
</code></pre></div><p>ClientAliveInterval表示每隔多少秒，服务器端向客户端发送心跳，是的，你没看错。</p>
<p>下面的ClientAliveInterval表示上述多少次心跳无响应之后，会认为Client已经断开。</p>
<p>所以，总共允许无响应的时间是60*3=180秒。</p>
</li>
</ul>
<h3 id="new-mode-100755httpsblogcsdnnetai2000aiarticledetails79628896"><a href="https://blog.csdn.net/ai2000ai/article/details/79628896">new mode 100755</a><a hidden class="anchor" aria-hidden="true" href="#new-mode-100755httpsblogcsdnnetai2000aiarticledetails79628896">#</a></h3>
<p>出现</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git diff filename
old mode <span style="color:#ae81ff">100644</span>
new mode <span style="color:#ae81ff">100755</span> 
</code></pre></div><p>但是文件内容并没有发生改变</p>
<p>产生这个问题的原因就是：filemode的变化，文件chmod后其文件某些位是改变了的，如果严格的比较原文件和chmod后的文件，两者是有区别的，但是源代码通常只关心文本内容，因此chmod产生的变化应该忽略，所以设置一下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ git config --add core.filemode false
</code></pre></div><h3 id="check-if-pull-needed-in-githttpsstackoverflowcoma3278427"><a href="https://stackoverflow.com/a/3278427">Check if pull needed in Git</a><a hidden class="anchor" aria-hidden="true" href="#check-if-pull-needed-in-githttpsstackoverflowcoma3278427">#</a></h3>
<p>First use <a href="https://git-scm.com/docs/git-remote"><code>git remote update</code></a>, to bring your remote refs up to date. Then you can do one of several things, such as:</p>
<ol>
<li><code>git status -uno</code> will tell you whether the branch you are tracking is ahead, behind or has diverged. If it says nothing, the local and remote are the same.</li>
<li><code>git show-branch *master</code> will show you the commits in all of the branches whose names end in &lsquo;master&rsquo; (eg <em>master</em> and <em>origin/master</em>).</li>
</ol>
<p>If you use <code>-v</code> with <code>git remote update</code> (<code>git remote -v update</code>) you can see which branches got updated, so you don&rsquo;t really need any further commands.</p>
<p>However, it looks like you want to do this in a script or program and end up with a true/false value. If so, there are ways to check the relationship between your current <em>HEAD</em> commit and the head of the branch you&rsquo;re tracking, although since there are four possible outcomes you can&rsquo;t reduce it to a yes/no answer. However, if you&rsquo;re prepared to do a <code>pull --rebase</code> then you can treat &ldquo;local is behind&rdquo; and &ldquo;local has diverged&rdquo; as &ldquo;need to pull&rdquo;, and the other two (&ldquo;local is ahead&rdquo; and &ldquo;same&rdquo;) as &ldquo;don&rsquo;t need to pull&rdquo;.</p>
<p>You can get the commit id of any ref using <code>git rev-parse &lt;ref&gt;</code>, so you can do this for <em>master</em> and <em>origin/master</em> and compare them. If they&rsquo;re equal, the branches are the same. If they&rsquo;re unequal, you want to know which is ahead of the other. Using <code>git merge-base master origin/master</code> will tell you the common ancestor of both branches, and if they haven&rsquo;t diverged this will be the same as one or the other. If you get three different ids, the branches have diverged.</p>
<p>To do this properly, eg in a script, you need to be able to refer to the current branch, and the remote branch it&rsquo;s tracking. The bash prompt-setting function in <code>/etc/bash_completion.d</code> has some useful code for getting branch names. However, you probably don&rsquo;t actually need to get the names. Git has some neat shorthands for referring to branches and commits (as documented in <code>git rev-parse --help</code>). In particular, you can use <code>@</code> for the current branch (assuming you&rsquo;re not in a detached-head state) and <code>@{u}</code> for its upstream branch (eg <code>origin/master</code>). So <code>git merge-base @ @{u}</code> will return the (hash of the) commit at which the current branch and its upstream diverge and <code>git rev-parse @</code> and <code>git rev-parse @{u}</code> will give you the hashes of the two tips. This can be summarized in the following script:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">#!/bin/sh
</span><span style="color:#75715e"></span>
UPSTREAM<span style="color:#f92672">=</span><span style="color:#e6db74">${</span>1<span style="color:#66d9ef">:-</span><span style="color:#e6db74">&#39;@{u}&#39;</span><span style="color:#e6db74">}</span>
LOCAL<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>git rev-parse @<span style="color:#66d9ef">)</span>
REMOTE<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>git rev-parse <span style="color:#e6db74">&#34;</span>$UPSTREAM<span style="color:#e6db74">&#34;</span><span style="color:#66d9ef">)</span>
BASE<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>git merge-base @ <span style="color:#e6db74">&#34;</span>$UPSTREAM<span style="color:#e6db74">&#34;</span><span style="color:#66d9ef">)</span>

<span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> $LOCAL <span style="color:#f92672">=</span> $REMOTE <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
    echo <span style="color:#e6db74">&#34;Up-to-date&#34;</span>
<span style="color:#66d9ef">elif</span> <span style="color:#f92672">[</span> $LOCAL <span style="color:#f92672">=</span> $BASE <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
    echo <span style="color:#e6db74">&#34;Need to pull&#34;</span>
<span style="color:#66d9ef">elif</span> <span style="color:#f92672">[</span> $REMOTE <span style="color:#f92672">=</span> $BASE <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
    echo <span style="color:#e6db74">&#34;Need to push&#34;</span>
<span style="color:#66d9ef">else</span>
    echo <span style="color:#e6db74">&#34;Diverged&#34;</span>
<span style="color:#66d9ef">fi</span>
</code></pre></div><p><em>Note:</em> older versions of git didn&rsquo;t allow <code>@</code> on its own, so you may have to use <code>@{0}</code> instead.</p>
<p>The line <code>UPSTREAM=${1:-'@{u}'}</code> allows you optionally to pass an upstream branch explicitly, in case you want to check against a different remote branch than the one configured for the current branch. This would typically be of the form <em>remotename/branchname</em>. If no parameter is given, the value defaults to <code>@{u}</code>.</p>
<p>The script assumes that you&rsquo;ve done a <code>git fetch</code> or <code>git remote update</code> first, to bring the tracking branches up to date. I didn&rsquo;t build this into the script because it&rsquo;s more flexible to be able to do the fetching and the comparing as separate operations, for example if you want to compare without fetching because you already fetched recently.</p>
<h3 id="setting-the-default-editor-for-githttpsstackoverflowcoma2596835"><a href="https://stackoverflow.com/a/2596835">Setting the default editor for Git</a><a hidden class="anchor" aria-hidden="true" href="#setting-the-default-editor-for-githttpsstackoverflowcoma2596835">#</a></h3>
<p>Pick one:</p>
<ul>
<li>
<p>Set <a href="http://git-scm.com/book/en/Customizing-Git-Git-Configuration#Basic-Client-Configuration"><code>core.editor</code></a> in your Git config:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lisp" data-lang="lisp">git config --global core.editor <span style="color:#e6db74">&#34;vim&#34;</span>
</code></pre></div></li>
<li>
<p>Set the <a href="http://git-scm.com/docs/git-var#_variables"><code>GIT_EDITOR</code></a> environment variable:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lisp" data-lang="lisp"><span style="color:#a6e22e">export</span> GIT_EDITOR=vim
</code></pre></div></li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://sakamotokurome.github.io/tags/unix/">Unix</a></li>
      <li><a href="https://sakamotokurome.github.io/tags/linux/">Linux</a></li>
      <li><a href="https://sakamotokurome.github.io/tags/git/">Git</a></li>
      <li><a href="https://sakamotokurome.github.io/tags/github/">GitHub</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://sakamotokurome.github.io/posts/hexo/">
    <span class="title">« Prev Page</span>
    <br>
    <span>Hexo</span>
  </a>
  <a class="next" href="https://sakamotokurome.github.io/posts/freebsd/">
    <span class="title">Next Page »</span>
    <br>
    <span>FreeBSD</span>
  </a>
</nav>

  </footer>
</article>

<div class="disqus-container">
  <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    this.page.identifier = 'b949c9';
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "sakamotokurome" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://sakamotokurome.github.io/">Sakamoto Kurome</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
</body>

</html>
