<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>OpenSUSE | Sakamoto Kurome</title>
<meta name="keywords" content="Unix, Linux, openSUSE" />
<meta name="description" content="/ˌoʊpənˈsuːzə/ openSUSE Desktop DVD 方式安装 使用其他方式安装系统需要耗费比其他安装方式更多的时间和精力，除非必要，建议优先使用离线的 DVD 镜像进行">
<meta name="author" content="Sakamoto Kurome">
<link rel="canonical" href="https://sakamotokurome.github.io/posts/opensuse/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css" integrity="sha256-yIlj/i15RiAA/Q&#43;xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://sakamotokurome.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://sakamotokurome.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://sakamotokurome.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://sakamotokurome.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://sakamotokurome.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.90.0" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>

<link rel="stylesheet" href="https://sakamotokurome.github.io/custom.css">
<meta name="google-site-verification" content="i2r403EffR8m-KBf7EHi6AYg7tfnMshaXTAynoYPnpE" />
<script async src="https://www.googletagmanager.com/gtag/js?id=G-K2Y212LPQ2"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-K2Y212LPQ2', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="OpenSUSE" />
<meta property="og:description" content="/ˌoʊpənˈsuːzə/ openSUSE Desktop DVD 方式安装 使用其他方式安装系统需要耗费比其他安装方式更多的时间和精力，除非必要，建议优先使用离线的 DVD 镜像进行" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://sakamotokurome.github.io/posts/opensuse/" />
<meta property="og:image" content="https://sakamotokurome.github.io/Distributions/OpenSUSE_Logo.svg" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-09T11:42:26&#43;08:00" />
<meta property="article:modified_time" content="2022-03-09T11:42:26&#43;08:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://sakamotokurome.github.io/Distributions/OpenSUSE_Logo.svg" />
<meta name="twitter:title" content="OpenSUSE"/>
<meta name="twitter:description" content="/ˌoʊpənˈsuːzə/ openSUSE Desktop DVD 方式安装 使用其他方式安装系统需要耗费比其他安装方式更多的时间和精力，除非必要，建议优先使用离线的 DVD 镜像进行"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://sakamotokurome.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "OpenSUSE",
      "item": "https://sakamotokurome.github.io/posts/opensuse/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "OpenSUSE",
  "name": "OpenSUSE",
  "description": "/ˌoʊpənˈsuːzə/ openSUSE Desktop DVD 方式安装 使用其他方式安装系统需要耗费比其他安装方式更多的时间和精力，除非必要，建议优先使用离线的 DVD 镜像进行",
  "keywords": [
    "Unix", "Linux", "openSUSE"
  ],
  "articleBody": "/ˌoʊpənˈsuːzə/\nopenSUSE Desktop DVD 方式安装   使用其他方式安装系统需要耗费比其他安装方式更多的时间和精力，除非必要，建议优先使用离线的 DVD 镜像进行安装系统。\n  语言选择 English，因为 Linux 需要经常使用 Terminal，中文家目录并不方便。\n  分区 选择默认的 btrfs 文件系统，有需要选择 Guided setup 和 Expert Partitioner。\n  软件包：\n$ sudo zypper in android-tools aria2 qemu-kvm samba goldendict noto-sans-cjk-fonts noto-sans-mono-fonts translate-shell git unrar proxychains-ng   国内镜像源 解答 我们官方的态度是不鼓励直接使用镜像的。\n因为比起「其它」发行版，我们 openSUSE 的技术力量比较强，开发了两个东西。\n一个叫做 Metalink，意思是这个格式（BT、Megalink 磁力链一样的格式）可以自动从 BT/FTP/HTTP 同时下载。\n另一个叫做 MirrorBrain，意思是我把所有的镜像地址隐藏起来，只暴露出一个中央服务器，所有人只需使用这个中央服务器（download.opensuse.org ），它会根据你的 IP 地理位置为你分配一个离你最近的镜像，但是在你那边显示的依旧是来自 download.opensuse.org。而如何分配是根据镜像管理员和中央服务器管理员当初的协定来确定的，比如镜像每月能够承受的流量、所愿意扮演的角色（是区域中心、地标式的镜像比如北交大、中科大，还是小镜像）等。\n而根据 openSUSE 软件源的构造，所有的 RPM 包都是从镜像获得的，所有的 metadata（元数据）都是从主镜像（位于德国）获得的，所以你源刷新的慢，只能证明你被我们光荣伟大的放火长城拖住了，而不能证明 openSUSE 项目有错，也代表不了你下载 RPM 包时的速度。\n更换   禁用原有软件源\n$ sudo zypper mr -da   添加镜像源， 以清华 OpenTUNA 的 Tumbleweed mirror 为例（OpenTUNA 镜像站作为 TUNA 镜像的兄弟站，由清华 TUNA 协会运行维护，提供和 TUNA 镜像站基本一致的镜像内容）：\n$ sudo zypper ar -fcg 'https://opentuna.cn/opensuse/tumbleweed/repo/oss/' 'OPEN-TUNA:TW:OSS' $ sudo zypper ar -fcg 'https://opentuna.cn/opensuse/tumbleweed/repo/non-oss/' 'OPEN-TUNA:TW:NON-OSS' 命令中最后一个参数为每一个源指定了一个 alias（别称），可以根据个人喜好更改。\n  手动刷新软件源\n$ sudo zypper ref   更新 Tumbleweed 无论怎样，下面的内容将完成升级：\n 退出你的桌面环境，在登录管理器中按 CTRL + ALT + F1 进入内核终端界面。 以 root 的身份登录。 输入命令。sudo zypper dup。 处理好任何冲突，然后同意升级。 当升级完成后，输入命令。sudo reboot  Packman 什么是 Packman ？ openSUSE 的 Packman 是 Package man 的缩写。意即指一群打包狂组成的团体。他们在尊重并重视版权的基础上做一些规避专利的事。总之，他们想要自由打包从多媒体到大型软件到游戏到甚至是自己的回收站的所有内容。\nPackman 和 openSUSE 的关系 Packman 不隶属于任何 openSUSE 官方，是独立于 openSUSE 社区之外的社区，只是基于 openSUSE 打给 openSUSE 用的软件包。注意 openSUSE 社区也是官方，同样有在专利法最为严苛的美国和欧洲注册，这也是为什么 OBS 不能打包专利软件的原因，另一个原因是 OBS 的服务器坐落于德国诺伦堡。\nPackman 的资源来自于成员捐献，不能和 openSUSE 官方有任何的联系，也就是说即使是 SuSE 的捐献，也要放弃一切权利。不能像社区董事会那样，主席要由 SuSE 指定，一般是 SuSE 员工。\nPackman 欢迎大学和社区为它做镜像。\nPackman 收纳什么样的软件 ？ 由于英文的 free 很有迷惑性（大部分外国人喜欢用法语 Libre，也就是自由）：\n 这里的自由，仍然不包括商业和私有软件，版权产品应该尊重他们自有的分发渠道。也就是说，这里仍然不做盗版，也不做免费使用的商业软件。不规避版权，只规避专利。版权同样是保护 Linux 下的开源作品不被盗版的力量，而专利则是大公司用来牟利的工具。 这里只接纳由于或有专利纠纷而不能存在于官方构建服务中的软件。比如 FFMPEG，MPLAYER，MP3, AMULE。和依赖它们的软件。以及可以自由分发的软件，并且愿意允许从源代码编译。  也就是说，大部分时候这里的软件都是 FOSS/LOSS （自由和开源软件），而不是免费软件。而且是存在或有专利纠纷的软件，想想看什么软件最容易发生专利纠纷呢？ 多媒体。于是 Packman 里有那么多多媒体软件也就不奇怪了。\n另外 Packman 还允许两类软件：发行版中长期不更新的软件的最新版，和发行版中没有的软件。但这是 FTP 做源的时代延续下来的。目前这两类软件都建议走 OBS 流程来做，因为 OBS 的服务器比 Packman 的多快好省。\n启用 Packman 源 国内可用的 Packman 镜像列表：Packman/镜像列表，配置方法详见：添加镜像源。\nopenSUSE Tumbleweed 用户：\n$ sudo zypper ar -cfp 90 https://mirrors.ustc.edu.cn/packman/suse/openSUSE_Tumbleweed/ packman $ sudo zypper ref Install Multimedia Codecs openSUSE 默认是没有部分多媒体编解码器的，包括家喻户晓的 MP3、AVI 等。这是因为它们是受限媒体格式。具体解释见openSUSE 编解码器一键安装、常见编解码器对应软件包/源说明、及版权须知。\n$ sudo zypper in opi \u0026\u0026 opi codecs or, In order to install the H264/AVC support on your system, type in:\n$ sudo zypper install x264 libx265-130 libx264-148 或者通过 Packman 安装解码器\n$ sudo zypper refresh $ sudo zypper dist-upgrade --from packman --allow-vendor-change $ sudo zypper install --from packman ffmpeg gstreamer-plugins-{good,bad,ugly,libav} libavcodec-full vlc-codecs 注：如果不使用 VLC 可以省略 vlc-codecs。\n软件管理 更新/刷新进程被占用 在 System Tray Setting 里面关闭 Software Updates 的通知。\n如果你不需要自动更新，或者不需要 Packagekit 本身，你首先可以考虑:\n$ sudo systemctl mask packagekit.service #屏蔽 Packagekit 服务 或者卸载该软件：\n$ sudo zypper rm Packagekit 取消推荐的软件包 \u0026 删除模组 打开 YaST ，点击 软件管理 ，再点击左上角的 依赖项 ，取消勾选 安装被推荐的软件包 。这样你的电脑就不会在某次更新后出现一些不是你主动安装的软件包。\n在 软件管理 页面，点击 视图，选择 模组 ，然后你就能看到按模组分类的包。例如你可以在此页面直接用鼠标右键单击 游戏 ，选择 不安装 或 卸载，卸载全部的预装的 KDE/Gnome 游戏包。\nOBS Package Installer 如果你想在终端直接查找来自 OBS 的软件包，你可以先安装 opi\n$ sudo zypper in opi 然后输入你想要查找的软件包的名称，例如你要安装 qbittorrent enhanced edition ，你可以：\n$ opi qbittorrent 中文社区源 openSUSE 中文社区的开发者们为用户构建、打包和收录一些发起自中文 Linux 圈子的软件或中文 Linux 圈子常用的软件。详见：\n openSUSE for Chinese Users Project   输入法 在Yast中安装第二语言，就会自动安装fcitx并添加中文支持，但是这种方案安装的东西很多。\nibus $ sudo zypper in ibus ibus-rime $ vim .bashrc export GTK_IM_MODULE=ibus export XMODIFIERS=@im=ibus export QT_IM_MODULE=ibus $ ibus-daemon -x -d Fcitx5 $ sudo zypper in fcitx5 $ sudo vim /etc/environment GTK_IM_MODULE=fcitx QT_IM_MODULE=fcitx XMODIFIERS=@im=fcitx 设置主题：Setting - Location - input method - Configure addons - Classic user interface - Theme.\n词库 Fcitx 的 Libpinyin 可以直接在线导入搜狗细胞词库。不需要安装sougou输入法。\n需要安装 fcitx-pinyin-tools/fcitx-table-tools 这两个包，以添加处理词库的工具。\n$ sudo zypper in fcitx-pinyin-tools fcitx-table-tools 词库少了的话，也不好用，但是一次只能导入一个细胞词库。网上可以找到比较全的词库包。\n通过 7zr 解压过后将所有 txt 词库拷贝到 ~/.config/fcitx/libpinyin/importdict 即可。\n$ 7zr x txt.7z cloudpinyin 根据文档，可以使用 libpinyin + cloudpinyin，哪怕不用导入词典，依旧很好用。果然，还是云词库的力量强大。\n$ sudo zypper in fcitx-cloudpinyin 默认的云输入引擎是 Google ，国内直接访问很不流畅，你可以打开输入法的配置，点击 Addon Config，找到 Cloud Pinyin ，点击右侧的设置，在弹出的窗口中，将 Google 替换为 Baidu 。\n搜狗拼音 $ sudo opi sogou-pinyin 有点问题。\nNVIDIA 有两种为英伟达（NVIDIA）显卡提供的驱动：\n 为 NVIDIA 硬件提供的自由开源的驱动名叫 nouveau。 来自 NVIDIA 厂商自己的驱动名为 nvidia，但由于许可证问题，它不能直接被集成进入 openSUSE 。  如果你没有特别的需求，NVIDIA 的闭源驱动不是必须安装的。持有 NVIDIA 独立显卡之类厂商只提供闭源驱动的硬件的 Tumbleweed 用户请不要过于频繁地更新系统，闭源驱动可能会因为内核版本太新缺乏适配而崩溃。\n安装 添加 Nvdia 软件源\n$ sudo zypper addrepo --refresh 'https://download.nvidia.com/opensuse/leap/$releasever' NVIDIA 确定显卡型号\n$ sudo hwinfo --gfxcard | grep Model 安装驱动\n$ sudo zypper in x11-video-nvidiaG05 最后，重启电脑确认是否加载\n$ sudo lsmod | grep nvidia 画面撕裂 出现此种情况，你必须打开 “PRIME同步” 功能：\n 创建文件  $ sudo echo \"options nvidia_drm modeset=1 \"  /etc/modprobe.d/nvidia-drm-nomodeset.conf 执行代码：  $ sudo dracut -f 重启\n注意： 在某些情况下，修改此配置可能会导致图形界面无法进入，若出现此情况，请进入重启后进入恢复模式，执行 sudo rm /etc/modprobe.d/nvidia-drm-nomodeset.conf ，然后执行 dracut -f ，然后重启\nAudacious 一个设计简洁，功能强大，支持多种格式的无损播放器。\n$ sudo zypper in audacious OpenZFS openSUSE Tumbleweed\n$ sudo zypper ar https://download.opensuse.org/repositories/filesystems/openSUSE_Tumbleweed/filesystems.repo $ sudo zypper ref $ sudo zypper in zfs openSUSE System Btrfs 文件系统似乎是内核中比较稳定的部分，多年来，人们一直使用 ext2/3，ext 文件系统以其卓越的稳定性成为了事实上的 Linux 标准文件系统。近年来 ext2/3 暴露出了一些扩展性问题，于是便催生了 ext4 。在 2008 年发布的 Linux2.6.19 内核中集成了 ext4 的 dev 版本。 2.6.28 内核发布时，ext4 结束了开发版，开始接受用户的使用。似乎 ext 就将成为 Linux 文件系统的代名词。然而当您阅读很多有关 ext4 的文章时，会发现都不约而同地提到了 btrfs，并认为 ext4 将是一个过渡的文件系统。 ext4 的作者 Theodore Tso 也盛赞 btrfs 并认为 btrfs 将成为下一代 Linux 标准文件系统。 Oracle，IBM， Intel 等厂商也对 btrfs 表现出了极大的关注，投入了资金和人力。为什么 btrfs 如此受人瞩目呢。这便是本文首先想探讨的问题。\nKevin Bowling 有一篇介绍各种文件系统的文章，在他看来，ext2/3 等文件系统属于“古典时期”。文件系统的新时代是 2005 年由 Sun 公司的 ZFS 开创的。 ZFS 代表” last word in file system ”，意思是此后再也不需要开发其他的文件系统了。 ZFS 的确带来了很多崭新的观念，对文件系统来讲是一个划时代的作品。\n如果您比较 btrfs 的特性，将会发现 btrfs 和 ZFS 非常类似。也许我们可以认为 btrfs 就是 Linux 社区对 ZFS 所作出的回应。从此往后在 Linux 中也终于有了一个可以和 ZFS 相媲美的文件系统。\nBtrfs 的特性 您可以在 btrfs 的主页上看到 btrfs 的特性列表。我自作主张，将那张列表分成了四大部分。\n首先是扩展性 (scalability) 相关的特性，btrfs 最重要的设计目标是应对大型机器对文件系统的扩展性要求。 Extent，B-Tree 和动态 inode 创建等特性保证了 btrfs 在大型机器上仍有卓越的表现，其整体性能而不会随着系统容量的增加而降低。\n其次是数据一致性 (data integrity) 相关的特性。系统面临不可预料的硬件故障，Btrfs 采用 COW 事务技术来保证文件系统的一致性。 btrfs 还支持 checksum，避免了 silent corrupt 的出现。而传统文件系统则无法做到这一点。\n第三是和多设备管理相关的特性。 Btrfs 支持创建快照 (snapshot)，和克隆 (clone) 。 btrfs 还能够方便的管理多个物理设备，使得传统的卷管理软件变得多余。\n最后是其他难以归类的特性。这些特性都是比较先进的技术，能够显著提高文件系统的时间 / 空间性能，包括延迟分配，小文件的存储优化，目录索引等。\n扩展性相关的特性 B-Tree\nbtrfs 文件系统中所有的 metadata 都由 BTree 管理。使用 BTree 的主要好处在于查找，插入和删除操作都很高效。可以说 BTree 是 btrfs 的核心。\n一味地夸耀 BTree 很好很高效也许并不能让人信服，但假如稍微花费一点儿时间看看 ext2/3 中元数据管理的实现方式，便可以反衬出 BTree 的优点。\n妨碍 ext2/3 扩展性的一个问题来自其目录的组织方式。目录是一种特殊的文件，在 ext2/3 中其内容是一张线性表格。\n图中展示了一个 ext2 目录文件的内容，该目录中包含四个文件。分别是 “home1”，“usr”，“oldfile” 和 “sbin” 。如果需要在该目录中查找目录 sbin，ext2 将遍历前三项，直至找到 sbin 这个字符串为止。\n这种结构在文件个数有限的情况下是比较直观的设计，但随着目录下文件数的增加，查找文件的时间将线性增长。 2003 年，ext3 设计者开发了目录索引技术，解决了这个问题。目录索引使用的数据结构就是 BTree 。如果同一目录下的文件数超过 2K，inode 中的 i_data 域指向一个特殊的 block 。在该 block 中存储着目录索引 BTree 。 BTree 的查找效率高于线性表，\n但为同一个元数据设计两种数据结构总是不太优雅。在文件系统中还有很多其他的元数据，用统一的 BTree 管理是非常简单而优美的设计。\nBtrfs 内部所有的元数据都采用 BTree 管理，拥有良好的可扩展性。 btrfs 内部不同的元数据由不同的 Tree 管理。在 superblock 中，有指针指向这些 BTree 的根。如图 2 所示：\nFS Tree 管理文件相关的元数据，如 inode，dir 等； Chunk tree 管理设备，每一个磁盘设备都在 Chunk Tree 中有一个 item ； Extent Tree 管理磁盘空间分配，btrfs 每分配一段磁盘空间，便将该磁盘空间的信息插入到 Extent tree 。查询 Extent Tree 将得到空闲的磁盘空间信息； Tree of tree root 保存很多 BTree 的根节点。比如用户每建立一个快照，btrfs 便会创建一个 FS Tree 。为了管理所有的树，btrfs 采用 Tree of tree root 来保存所有树的根节点； checksum Tree 保存数据块的校验和。\n基于 Extent 的文件存储\n现代很多文件系统都采用了 extent 替代 block 来管理磁盘。 Extent 就是一些连续的 block，一个 extent 由起始的 block 加上长度进行定义。\nExtent 能有效地减少元数据开销。为了进一步理解这个问题，我们还是看看 ext2 中的反面例子。\next2/3 以 block 为基本单位，将磁盘划分为多个 block 。为了管理磁盘空间，文件系统需要知道哪些 block 是空闲的。 Ext 使用 bitmap 来达到这个目的。 Bitmap 中的每一个 bit 对应磁盘上的一个 block，当相应 block 被分配后，bitmap 中的相应 bit 被设置为 1 。这是很经典也很清晰的一个设计，但不幸的是当磁盘容量变大时，bitmap 自身所占用的空间也将变大。这就导致了扩展性问题，随着存储设备容量的增加，bitmap 这个元数据所占用的空间也随之增加。而人们希望无论磁盘容量如何增加，元数据不应该随之线形增加，这样的设计才具有可扩展性。\n下图比较了 block 和 extent 的区别：\n在 ext2/3 中，10 个 block 需要 10 个 bit 来表示；在 btrfs 中则只需要一个元数据。对于大文件，extent 表现出了更加优异的管理性能。\nExtent 是 btrfs 管理磁盘空间的最小单位，由 extent tree 管理。 Btrfs 分配 data 或 metadata 都需要查询 extent tree 以便获得空闲空间的信息。\n动态 inode 分配\n为了理解动态 inode 分配，还是需要借助 ext2/3 。下表列举了 ext2 文件系统的限制：\n限制最大文件数量文件系统空间大小 V / 8192\n比如 100G 大小的文件系统中，能创建的文件个数最大为 131072\n下图显示了 ext2 的磁盘布局：\n在 ext2 中 inode 区是被预先固定分配的，且大小固定，比如一个 100G 的分区中，inode table 区中只能存放 131072 个 inode，这就意味着不可能创建超过 131072 个文件，因为每一个文件都必须有一个唯一的 inode 。\n为了解决这个问题，必须动态分配 inode 。每一个 inode 只是 BTree 中的一个节点，用户可以无限制地任意插入新的 inode，其物理存储位置是动态分配的。所以 btrfs 没有对文件个数的限制。\n针对 SSD 的优化支持\nSSD 是固态存储 Solid State Disk 的简称。在过去的几十年中，CPU/RAM 等器件的发展始终遵循着摩尔定律，但硬盘 HDD 的读写速率却始终没有飞跃式的发展。磁盘 IO 始终是系统性能的瓶颈。\nSSD 采用 flash memory 技术，内部没有磁盘磁头等机械装置，读写速率大幅度提升。 flash memory 有一些不同于 HDD 的特性。 flash 在写数据之前必须先执行擦除操作；其次，flash 对擦除操作的次数有一定的限制，在目前的技术水平下，对同一个数据单元最多能进行约 100 万次擦除操作，因此，为了延长 flash 的寿命，应该将写操作平均到整个 flash 上。\nSSD 在硬件内部的微代码中实现了 wear leveling 等分布写操作的技术，因此系统无须再使用特殊的 MTD 驱动和 FTL 层。虽然 SSD 在硬件层面做了很多努力，但毕竟还是有限。文件系统针对 SSD 的特性做优化不仅能提高 SSD 的使用寿命，而且能提高读写性能。 Btrfs 是少数专门对 SSD 进行优化的文件系统。 btrfs 用户可以使用 mount 参数打开对 SSD 的特殊优化处理。\nBtrfs 的 COW 技术从根本上避免了对同一个物理单元的反复写操作。如果用户打开了 SSD 优化选项，btrfs 将在底层的块空间分配策略上进行优化：将多次磁盘空间分配请求聚合成一个大小为 2M 的连续的块。大块连续地址的 IO 能够让固化在 SSD 内部的微代码更好的进行读写优化，从而提高 IO 性能。\n数据一致性相关的特性 COW 事务\n理解 COW 事务，必须首先理解 COW 和事务这两个术语。\n所谓 COW，即每次写磁盘数据时，先将更新数据写入一个新的 block，当新数据写入成功之后，再更新相关的数据结构指向新 block 。\nCOW 只能保证单一数据更新的原子性。但文件系统中很多操作需要更新多个不同的元数据，比如创建文件需要修改以下这些元数据：\n 修改 extent tree，分配一段磁盘空间 创建一个新的 inode，并插入 FS Tree 中 增加一个目录项，插入到 FS Tree 中  任何一个步骤出错，文件便不能创建成功，因此可以定义为一个事务。\n下面将演示一个 COW 事务。\nA 是 FS Tree 的根节点，新的 inode 的信息将被插入节点 C 。首先，btrfs 将 inode 插入一个新分配的 block C ’中，并修改上层节点 B，使其指向新的 block C ’；修改 B 也将引发 COW，以此类推，引发一个连锁反应，直到最顶层的 Root A 。当整个过程结束后，新节点 A ’变成了 FS Tree 的根。但此时事务并未结束，superblock 依然指向 A 。\n接下来，修改目录项（E 节点），同样引发这一过程，从而生成新的根节点 A ’’。\n此时，inode 和目录项都已经写入磁盘，可以认为事务已经结束。 btrfs 修改 superblock，使其指向 A ’’，如下图所示：\nCOW 事务能够保证文件系统的一致性，并且系统 Reboot 之后不需要执行 fsck 。因为 superblock 要么指向新的 A ’’，要么指向 A，无论哪个都是一致的数据。\nChecksum\nChecksum 技术保证了数据的可靠性，避免 silent corruption 现象。由于硬件原因，从磁盘上读出的数据会出错。比如 block A 中存放的数据为 0x55，但读取出来的数据变是 0x54，因为读取操作并未报错，所以这种错误不能被上层软件所察觉。\n解决这个问题的方法是保存数据的校验和，在读取数据后检查校验和。如果不符合，便知道数据出现了错误。\next2/3 没有校验和，对磁盘完全信任。而不幸的是，磁盘的错误始终存在，不仅发生在廉价的 IDE 硬盘上，昂贵的 RAID 也存在 silent corruption 问题。而且随着存储网络的发展，即使数据从磁盘读出正确，也很难确保能够安全地穿越网络设备。\nbtrfs 在读取数据的同时会读取其相应的 checksum 。如果最终从磁盘读取出来的数据和 checksum 不相同，btrfs 会首先尝试读取数据的镜像备份，如果数据没有镜像备份，btrfs 将返回错误。写入磁盘数据之前，btrfs 计算数据的 checksum 。然后将 checksum 和数据同时写入磁盘。\nBtrfs 采用单独的 checksum Tree 来管理数据块的校验和，把 checksum 和 checksum 所保护的数据块分离开，从而提供了更严格的保护。假如在每个数据 block 的 header 中加入一个域保存 checksum，那么这个数据 block 就成为一个自己保护自己的结构。这种结构下有一种错误无法检测出来，比如本来文件系统打算从磁盘上读 block A，但返回了 block B，由于 checksum 在 block 内部，因此 checksum 依旧是正确的。 btrfs 采用 checksum tree 来保存数据块的 checksum，避免了上述问题。\nBtrfs 采用 crc32 算法计算 checksum，在将来的开发中会支持其他类型的校验算法。为了提高效率，btrfs 将写数据和 checksum 的工作分别用不同的内核线程并行执行。\n多设备管理相关的特性 每个 Unix 管理员都曾面临为用户和各种应用分配磁盘空间的任务。多数情况下，人们无法事先准确地估计一个用户或者应用在未来究竟需要多少磁盘空间。磁盘空间被用尽的情况经常发生，此时人们不得不试图增加文件系统空间。传统的 ext2/3 无法应付这种需求。\n很多卷管理软件被设计出来满足用户对多设备管理的需求，比如 LVM 。 Btrfs 集成了卷管理软件的功能，一方面简化了用户命令；另一方面提高了效率。\n多设备管理\nBtrfs 支持动态添加设备。用户在系统中增加新的磁盘之后，可以使用 btrfs 的命令将该设备添加到文件系统中。\n为了灵活利用设备空间，Btrfs 将磁盘空间划分为多个 chunk 。每个 chunk 可以使用不同的磁盘空间分配策略。比如某些 chunk 只存放 metadata，某些 chunk 只存放数据。一些 chunk 可以配置为 mirror，而另一些 chunk 则可以配置为 stripe 。这为用户提供了非常灵活的配置可能性。\nSubvolume\nSubvolume 是很优雅的一个概念。即把文件系统的一部分配置为一个完整的子文件系统，称之为 subvolume 。\n采用 subvolume，一个大的文件系统可以被划分为多个子文件系统，这些子文件系统共享底层的设备空间，在需要磁盘空间时便从底层设备中分配，类似应用程序调用 malloc() 分配内存一样。可以称之为存储池。这种模型有很多优点，比如可以充分利用 disk 的带宽，可以简化磁盘空间的管理等。\n所谓充分利用 disk 的带宽，指文件系统可以并行读写底层的多个 disk，这是因为每个文件系统都可以访问所有的 disk 。传统的文件系统不能共享底层的 disk 设备，无论是物理的还是逻辑的，因此无法做到并行读写。\n所谓简化管理，是相对于 LVM 等卷管理软件而言。采用存储池模型，每个文件系统的大小都可以自动调节。而使用 LVM，如果一个文件系统的空间不够了，该文件系统并不能自动使用其他磁盘设备上的空闲空间，而必须使用 LVM 的管理命令手动调节。\nSubvolume 可以作为根目录挂载到任意 mount 点。 subvolume 是非常有趣的一个特性，有很多应用。\n假如管理员只希望某些用户访问文件系统的一部分，比如希望用户只能访问 /var/test/ 下面的所有内容，而不能访问 /var/ 下面其他的内容。那么便可以将 /var/test 做成一个 subvolume 。 /var/test 这个 subvolume 便是一个完整的文件系统，可以用 mount 命令挂载。比如挂载到 /test 目录下，给用户访问 /test 的权限，那么用户便只能访问 /var/test 下面的内容了。\n快照和克隆\n快照是对文件系统某一时刻的完全备份。建立快照之后，对文件系统的修改不会影响快照中的内容。这是非常有用的一种技术。\n比如数据库备份。假如在时间点 T1，管理员决定对数据库进行备份，那么他必须先停止数据库。备份文件是非常耗时的操作，假如在备份过程中某个应用程序修改了数据库的内容，那么将无法得到一个一致性的备份。因此在备份过程中数据库服务必须停止，对于某些关键应用这是不能允许的。\n利用快照，管理员可以在时间点 T1 将数据库停止，对系统建立一个快照。这个过程一般只需要几秒钟，然后就可以立即重新恢复数据库服务。此后在任何时候，管理员都可以对快照的内容进行备份操作，而此时用户对数据库的修改不会影响快照中的内容。当备份完成，管理员便可以删除快照，释放磁盘空间。\n快照一般是只读的，当系统支持可写快照，那么这种可写快照便被称为克隆。克隆技术也有很多应用。比如在一个系统中安装好基本的软件，然后为不同的用户做不同的克隆，每个用户使用自己的克隆而不会影响其他用户的磁盘空间。非常类似于虚拟机。\nBtrfs 支持 snapshot 和 clone 。这个特性极大地增加了 btrfs 的使用范围，用户不需要购买和安装昂贵并且使用复杂的卷管理软件。下面简要介绍一下 btrfs 实现快照的基本原理。\n如前所述 Btrfs 采用 COW 事务技术，从图 COW transaction 3 可以看到，COW 事务结束后，如果不删除原来的节点 A,C,E，那么 A,C,E,D,F 依然完整的表示着事务开始之前的文件系统。这就是 snapshot 实现的基本原理。\nBtrfs 采用引用计数决定是否在事务 commit 之后删除原有节点。对每一个节点，btrfs 维护一个引用计数。当该节点被别的节点引用时，该计数加一，当该节点不再被别的节点引用时，该计数减一。当引用计数归零时，该节点被删除。对于普通的 Tree Root, 引用计数在创建时被加一，因为 Superblock 会引用这个 Root block 。很明显，初始情况下这棵树中的所有其他节点的引用计数都为一。当 COW 事务 commit 时，superblock 被修改指向新的 Root A ’’，原来 Root block A 的引用计数被减一，变为零，因此 A 节点被删除。 A 节点的删除会引发其子孙节点的引用计数也减一，图 COW transaction 3 中的 B，C 节点的引用计数因此也变成了 0，从而被删除。 D,E 节点在 COW 时，因为被 A ’’所引用，计数器加一，因此计数器这时并未归零，从而没有被删除。\n创建 Snapshot 时，btrfs 将的 Root A 节点复制到 sA，并将 sA 的引用计数设置为 2 。在事务 commit 的时候，sA 节点的引用计数不会归零，从而不会被删除，因此用户可以继续通过 Root sA 访问 snapshot 中的文件。\n软件 RAID\nRAID 技术有很多非常吸引人的特性，比如用户可以将多个廉价的 IDE 磁盘组合为 RAID0 阵列，从而变成了一个大容量的磁盘； RAID1 和更高级的 RAID 配置还提供了数据冗余保护，从而使得存储在磁盘中的数据更加安全。\nBtrfs 很好的支持了软件 RAID，RAID 种类包括 RAID0,RAID1 和 RAID10.\nBtrfs 缺省情况下对 metadata 进行 RAID1 保护。前面已经提及 btrfs 将设备空间划分为 chunk，一些 chunk 被配置为 metadata，即只存储 metadata 。对于这类 chunk，btrfs 将 chunk 分成两个条带，写 metadata 的时候，会同时写入两个条带内，从而实现对 metadata 的保护。\n其他特性 Btrfs 主页上罗列的其他特性不容易分类，这些特性都是现代文件系统中比较先进的技术，能够提高文件系统的时间或空间效率。\nDelay allocation\n延迟分配技术能够减少磁盘碎片。在 Linux 内核中，为了提高效率，很多操作都会延迟。\n在文件系统中，小块空间频繁的分配和释放会造成碎片。延迟分配是这样一种技术，当用户需要磁盘空间时，先将数据保存在内存中。并将磁盘分配需求发送给磁盘空间分配器，磁盘空间分配器并不立即分配真正的磁盘空间。只是记录下这个请求便返回。\n磁盘空间分配请求可能很频繁，所以在延迟分配的一段时间内，磁盘分配器可以收到很多的分配请求，一些请求也许可以合并，一些请求在这段延迟期间甚至可能被取消。通过这样的“等待”，往往能够减少不必要的分配，也有可能将多个小的分配请求合并为一个大的请求，从而提高 IO 效率。\nInline file\n系统中往往存在大量的小文件，比如几百个字节或者更小。如果为其分配单独的数据 block，便会引起内部碎片，浪费磁盘空间。 btrfs 将小文件的内容保存在元数据中，不再额外分配存放文件数据的磁盘块。改善了内部碎片问题，也增加了文件的访问效率。\n上图显示了一个 BTree 的叶子节点。叶子中有两个 extent data item 元数据，分别用来表示文件 file1 和 file2 所使用的磁盘空间。\n假设 file1 的大小仅为 15 个字节； file2 的大小为 1M 。如图所示，file2 采用普通的 extent 表示方法：extent2 元数据指向一段 extent，大小为 1M，其内容便是 file2 文件的内容。\n而对于 file1， btrfs 会把其文件内容内嵌到元数据 extent1 中。如果不采用 inline file 技术。如虚线所示，extent1 指向一个最小的 extent，即一个 block，但 file1 有 15 个字节，其余的空间便成为了碎片空间。\n采用 inline 技术，读取 file1 时只需要读取元数据 block，而无需先读取 extent1 这个元数据，再读取真正存放文件内容的 block，从而减少了磁盘 IO 。\n得益于 inline file 技术，btrfs 处理小文件的效率非常高，也避免了磁盘碎片问题。\nDirectory index\n当一个目录下的文件数目巨大时，目录索引可以显著提高文件搜索时间。 Btrfs 本身采用 BTree 存储目录项，所以在给定目录下搜索文件的效率是非常高的。\n然而，btrfs 使用 BTree 管理目录项的方式无法同时满足 readdir 的需求。 readdir 是 POSIX 标准 API，它要求返回指定目录下的所有文件，并且特别的，这些文件要按照 inode number 排序。而 btrfs 目录项插入 BTree 时的 Key 并不是 Inode number，而是根据文件名计算的一个 hash 值。这种方式在查找一个特定文件时非常高效，但却不适于 readdir 。为此，btrfs 在每次创建新的文件时，除了插入以 hash 值为 Key 的目录项外，还同时插入另外一种目录项索引，该目录项索引的 KEY 以 sequence number 作为 BTree 的键值。这个 sequence number 在每次创建新文件时线性增加。因为 Inode number 也是每次创建新文件时增加的，所以 sequence number 和 inode number 的顺序相同。以这种 sequence number 作为 KEY 在 BTree 中查找便可以方便的得到一个以 inode number 排序的文件列表。\n另外以 sequence number 排序的文件往往在磁盘上的位置也是相邻的，所以以 sequence number 为序访问大量文件会获得更好的 IO 效率。\n压缩\n大家都曾使用过 zip，winrar 等压缩软件，将一个大文件进行压缩可以有效节约磁盘空间。 Btrfs 内置了压缩功能。\n通常人们认为将数据写入磁盘之前进行压缩会占用很多的 CPU 计算时间，必然降低文件系统的读写效率。但随着硬件技术的发展，CPU 处理时间和磁盘 IO 时间的差距不断加大。在某些情况下，花费一定的 CPU 时间和一些内存，但却能大大节约磁盘 IO 的数量，这反而能够增加整体的效率。\n比如一个文件不经过压缩的情况下需要 100 次磁盘 IO 。但花费少量 CPU 时间进行压缩后，只需要 10 次磁盘 IO 就可以将压缩后的文件写入磁盘。在这种情况下，IO 效率反而提高了。当然，这取决于压缩率。目前 btrfs 采用 zlib 提供的 DEFALTE/INFLATE 算法进行压缩和解压。在将来，btrfs 应该可以支持更多的压缩算法，满足不同用户的不同需求。\n目前 btrfs 的压缩特性还存在一些不足，当压缩使能后，整个文件系统下的所有文件都将被压缩，但用户可能需要更细粒度的控制，比如针对不同的目录采用不同的压缩算法，或者禁止压缩。我相信，btrfs 开发团队将在今后的版本中解决这个问题。\n对于某些类型的文件，比如 jpeg 文件，已经无法再进行压缩。尝试对其压缩将纯粹浪费 CPU 。为此，当对某文件的若干个 block 压缩后发现压缩率不佳，btrfs 将不会再对文件的其余部分进行压缩操作。这个特性在某种程度上提高了文件系统的 IO 效率。\n预分配\n很多应用程序有预先分配磁盘空间的需要。他们可以通过 posix_fallocate 接口告诉文件系统在磁盘上预留一部分空间，但暂时并不写入数据。如果底层文件系统不支持 fallocate，那么应用程序只有使用 write 预先写一些无用信息以便为自己预留足够的磁盘空间。\n由文件系统来支持预留空间更加有效，而且能够减少磁盘碎片，因为所有的空间都是一次分配，因而更有可能使用连续的空间。 Btrfs 支持 posix_fallocate 。\n总结 至此，我们对 btrfs 的很多特性进行了较为详细的探讨，但 btrfs 能提供的特性却并不止这些。 btrfs 正处于试验开发阶段，还将有更多的特性。\nBtrfs 也有一个重要的缺点，当 BTree 中某个节点出现错误时，文件系统将失去该节点之下的所有的文件信息。而 ext2/3 却避免了这种被称为”错误扩散”的问题。\n但无论怎样，希望您和我一样，开始认同 btrfs 将是 Linux 未来最有希望的文件系统。\nBtrfs 使用 了解了 btrfs 的特性，想必您一定想亲身体验一下 btrfs 的使用。本章将简要介绍如何使用 btrfs 。\n要使用一些用户空间工具的话，需要 安装 基础操作必须的 btrfs-progs 软件包。\n创建文件系统 单一设备上的文件系统\n要在分区 /dev/partition 上创建一个 Btrfs 文件系统，执行：\n# mkfs.btrfs -L mylabel /dev/partition Btrfs 用于元数据的默认节点大小 (nodesize) 为 16KB，而用于数据的默认扇区大小 (sectorsize) 等于页面大小 (page size) 并会自动检测。 要对元数据使用较大的节点大小 (必须为扇区大小的倍数，最大允许 64KB)，请通过 -n 开关为 nodesize 指定一个值。如下例所示，使用 32KB 块大小：\n# mkfs.btrfs -L mylabel -n 32k /dev/partition 注意： 根据 mkfs.btrfs(8) § OPTIONS 手册页内容：“较小的节点大小会增加碎片，但也会让 B-trees 更高，进而使得锁定争用（locking contention）更少。较高的节点大小则能有更好的打包（packing）和更少的碎片，但代价是，更新元数据块时会使用更多的内存”。\n多设备文件系统 RAID\n多个设备可以用来创建一组 RAID。支持的 RAID 级别有 RAID 0、RAID 1、RAID 10、RAID 5 和 RAID 6。从 5.5 版本内核开始，新增对 RAID1c3 和 RAID1c4 的支持，分别是 3 份冗余和 4 份冗余的 RAID 1。可以使用 -d 和 -m 参数分别为数据和元数据配置 RAID 等级。默认情况下，数据有一份副本（single），元数据则被镜像（RAID1）。\n# mkfs.btrfs -d single -m raid1 /dev/part1 /dev/part2 ... subvolume 创建子卷\n要创建一个子卷:\n# btrfs subvolume create /path/to/subvolume 列出子卷列表\n要列出当前路径 (path) 下的子卷和它们的 ID:\n# btrfs subvolume list -p path 删除子卷\n要删除一个子卷:\n# btrfs subvolume delete /path/to/subvolume 自 Linux 4.18 起, 用户可以像移除常规目录一样删除一个子卷 (用 rm -r, rmdir 命令)。\n挂载子卷\n可以使用 subvol=*/path/to/subvolume* 或 subvolid=*objectid* 挂载标志来安装子卷，就像文件系统分区一样。\n$ sudo mount /dev/sdb1 -o subvol=projects /tmp/projects$ sudo mount /dev/sdb1 -o subvolid=261 /tmp/projects 使用 Btrfs 快照进行增量备份 *快照(snapshot)*是 Btrfs 的一个有趣的功能。快照是一个子卷的副本。生成快照是立即的。然而，生成快照与执行 rsync 或 cp 不同，快照并不是一创建就会占用空间。\n 编者注：来自 BTRFS Wiki：快照简单的来说就是一个子卷，它使用 Btrfs 的 COW 功能与其他子卷共享其数据（和元数据）。\n 占用的空间将随着原始子卷或快照本身（如果它是可写的）的数据变化而增加。子卷中已添加/修改的文件和已删除的文件仍然存在于快照中。这是一种方便的备份方式。\n使用快照进行备份\n快照驻留在子卷所在的同一磁盘上。你可以像浏览普通目录一样浏览它，并按照生成快照时的状态恢复文件的副本。顺便说一下，在快照子卷的同一磁盘上生成快照并不是一个理想的备份策略：如果硬盘坏了，快照也会丢失。快照的一个有趣的功能是可以将快照发送到另一个位置。快照可以被发送到外部硬盘或通过 SSH 发送到远程系统（目标文件系统也需要格式化为 Btrfs）。要实现这个，需要使用命令 btrfs send 和 btrfs receive。\n生成快照\n要使用 btrfs send 和 btrfs receive 命令，重要的是要将快照创建为只读，而快照默认是可写的。\n要创建一个快照:\n# btrfs subvolume snapshot source [dest/]name source为要创建快照的对象，[dest/]name为快照安放路径。\n下面的命令将对 /home 子卷进行快照。请注意 -r 标志代表只读。\nsudo btrfs subvolume snapshot -r /home /.snapshots/home-day1 快照的名称可以是当前日期，而不是 day1，比如 home-$(date +%Y%m%d)。快照看起来像普通的子目录。你可以把它们放在任何你喜欢的地方。目录 /.snapshots 可能是一个不错的选择，以保持它们的整洁和避免混淆。\n 编者注：快照不会对自己进行递归快照。如果你创建了一个子卷的快照，子卷所包含的每一个子卷或快照都会被映射到快照里面的一个同名的空目录。\n 使用 btrfs send 进行备份\n在本例中，U 盘中的目标 Btrfs 卷被挂载为 /run/media/user/mydisk/bk。发送快照到目标卷的命令是：\nsudo btrfs send /.snapshots/home-day1 | sudo btrfs receive /run/media/user/mydisk/bk 这被称为初始启动，它相当于一个完整的备份。这个任务需要一些时间，取决于 /home 目录的大小。显然，后续的增量发送只需要更短的时间。\n增量备份\n快照的另一个有用的功能是能够以增量的方式执行发送任务。让我们再来生成一个快照。\nsudo btrfs subvolume snapshot -r /home /.snapshots/home-day2 为了执行增量发送任务，需要指定上一个快照作为基础，并且这个快照必须存在于源文件和目标文件中。请注意 -p 选项。\nsudo btrfs send -p /.snapshot/home-day1 /.snapshot/home-day2 | sudo btrfs receive /run/media/user/mydisk/bk 再来一次（一天之后）：\nsudo btrfs subvolume snapshot -r /home /.snapshots/home-day3sudo btrfs send -p /.snapshot/home-day2 /.snapshot/home-day3 | sudo btrfs receive /run/media/user/mydisk/bk 清理\n操作完成后，你可以保留快照。但如果你每天都执行这些操作，你可能最终会有很多快照。这可能会导致混乱，并可能会在你的磁盘上使用大量的空间。因此，如果你认为你不再需要一些快照，删除它们是一个很好的建议。\n请记住，为了执行增量发送，你至少需要最后一个快照。这个快照必须存在于源文件和目标文件中。\nsudo btrfs subvolume delete /.snapshot/home-day1sudo btrfs subvolume delete /.snapshot/home-day2sudo btrfs subvolume delete /run/media/user/mydisk/bk/home-day1sudo btrfs subvolume delete /run/media/user/mydisk/bk/home-day2 注意：第 3 天的快照被保存在源文件和目标文件中。这样，明天（第 4 天），你就可以执行新的增量 btrfs send。\n最后的建议是，如果 U 盘的空间很大，可以考虑在目标盘中保留多个快照，而在源盘中只保留最后一个快照。\n压缩 给现存文件启用压缩，可使用 btrfs filesystem defragment -c alg 命令，alg 处可选填为 zlib，lzo 或 zstd。举例来说，要用 zstd 方式给整个文件系统重新压缩，执行下列命令：\n# btrfs filesystem defragment -r -v -c zstd / 要在新的 Btrfs 分区上安装 Arch Linux 时就启用压缩功能 (充分利用压缩特性)，请在 挂载 文件系统时使用 compress 选项：mount -o compress=zstd /dev/sd*xY* /mnt/。在配置过程中，请在 fstab 中把 compress=zstd 添加到根目录文件系统的挂载选项里。\nBtrfs 和 LVM-ext4 两者的共性 尽管两个文件系统之间存在核心差异，但 Btrfs 和 LVM-ext4 实际上有很多共同之处。两者都是成熟且经过充分测试的存储技术。从 Fedora Core 的早期开始，就一直在使用 LVM，而 ext4 在 2009 年成为 Fedora 11 的默认设置。Btrfs 在 2009 年并入 Linux 主线内核，并且 Facebook 广泛使用了该文件系统。SUSE Linux Enterprise 12 在 2014 年使其成为默认文件系统。因此，它在生产环境中也有着长久的运行时间。\n这两个系统都能很好地防止因意外停电而导致的文件系统损坏，尽管它们的实现方式不同。它们支持的配置包括使用单盘设置和跨越多个设备，并且这两种配置都能够创建近乎即时的快照。有各种工具可以帮助管理这两种系统，包括命令行和图形界面。这两种解决方案在家用台式机和高端服务器上都同样有效。\nLVM-ext4 的优势 ext4 文件系统 专注于高性能和可伸缩性，没有太多额外的花哨之处。它能有效地防止长时间后的碎片化，并当碎片化出现后提供了 很好的工具。ext4 之所以坚如磐石，是因为它构建在前代的 ext3 文件系统之上，带来了多年的系统内测试和错误修复。\nLVM-ext4 环境中的大多数高级功能都来自 LVM 本身。LVM 位于文件系统的“下方”，这意味着它支持任何文件系统。逻辑卷Logical volume（LV）是通用的块设备，因此 虚拟机可以直接使用它们。这种灵活性使得每个逻辑卷都可以使用合适的文件系统，用合适的选项应对各种情况。这种分层方法还遵循了“小工具协同工作”的 Unix 哲学。\n从硬件抽象出来的卷组volume group（VG）允许 LVM 创建灵活的逻辑卷。每个逻辑卷都提取自同一个存储池，但具有自己的设置。调整卷的大小比调整物理分区的大小容易得多，因为没有数据有序放置的限制。LVM 物理卷physical volume（PV）可以是任意数量的分区，甚至可以在系统运行时在设备之间移动。\nLVM 支持只读和读写的 快照，这使得从活动系统创建一致的备份变得很容易。每个快照都有一个定义的大小，更改源卷或快照卷将占用其中的空间。又或者，逻辑卷也可以是稀疏配置池thinly provisioned pool的一部分。这允许快照自动使用池中的数据，而不是使用在创建卷时定义的固定大小的块。\n有多个磁盘驱动器的 LVM\n当有多个设备时，LVM 才真正大放异彩。它原生支持大多数 RAID 级别，每个逻辑卷可以具有不同的 RAID 级别。LVM 将自动为 RAID 配置选择适当的物理设备，或者用户可以直接指定它。基本的 RAID 支持包括用于性能的数据条带化（RAID0）和用于冗余的镜像（RAID1）。逻辑卷也可以使用 RAID5、RAID6 和 RAID10 等高级设置。LVM RAID 支持已经成熟，因为 LVM 在底层使用的 设备映射器（dm） 和 多设备（md） 内核支持， 与 mdadm 使用的一样。\n对于具有快速和慢速驱动器的系统，逻辑卷也可以是 缓存卷。经典示例是 SSD 和传统磁盘驱动器的组合。缓存卷使用较快的驱动器来存储更频繁访问的数据（或用作写缓存），而慢速的驱动器则用于处理大量数据。\nLVM 中大量稳定的功能以及 ext4 的可靠性在既往的使用中早已被证明了。当然，功能越多就越复杂。在配置 LVM 时，要找到合适的功能选项是很有挑战性的。对于单驱动器的台式机系统，LVM 的功能（例如 RAID 和缓存卷）不适用。但是，逻辑卷比物理分区更灵活，快照也很有用。对于正常的桌面使用，LVM 的复杂性会成为典型的用户可能遇到的问题恢复的障碍。\nBtrfs 的优势 从前几代文件系统中学到的经验指导了构建到 Btrfs 的功能设计。与 ext4 不同，它可以直接跨越多个设备，因此它具有通常仅在卷管理器中才能找到的功能。它还具有 Linux 文件系统空间中独有的功能（ZFS 具有相似的功能集，但不要指望它在 Linux 内核中出现）。\nBtrfs 的主要功能\n也许最重要的功能是对所有数据进行校验和checksumming。校验和与写时复制copy-on-write（COW）一起，提供了在意外断电后确保文件系统完整性的 关键方法。更独特的是，校验和可以检测数据本身中的错误。悄然的数据损坏（有时也称为 bitrot）比大多数人意识到的更常见。如果没有主动验证，损坏最终可能会传播到所有可用的备份中。这使得用户没有有效的副本。通过透明地校验所有数据，Btrfs 能够立即检测到任何此类损坏。启用正确的 dup 或 raid 选项，文件系统也可以透明地修复损坏。\n写时复制也是 Btrfs 的基本功能，因为它在提供文件系统完整性和即时子卷快照方面至关重要。从公共子卷创建快照后，快照会自动共享底层数据。另外，事后的重复数据删除deduplication 使用相同的技术来消除相同的数据块。单个文件可以通过使用 cp 的 reflink 选项 来使用 COW 功能。reflink 副本对于复制大型文件（例如虚拟机镜像）特别有用，这些文件往往随着时间的推移具有大部分相同的数据。\nBtrfs 支持跨越多个设备，而无需卷管理器。多设备支持可提供数据镜像功能以实现冗余和条带化以提高性能。此外，还实验性地支持更高级的 RAID 级别，例如 RAID 5 和 RAID 6。与标准 RAID 设置不同，Btrfs 的 RAID1 实际上允许奇数个设备。例如，它可以使用 3 个设备，即使它们的大小不同。\n所有 RAID 和 dup 选项都是在文件系统级别指定的。因此，各个子卷不能使用不同的选项。请注意，使用多设备的 RAID1 选项意味着即使一个设备发生故障，卷中的所有数据都是可用的，并且校验功能可以保持数据本身的完整性。这超出了当前典型的 RAID 设置所能提供的范围。\n附加功能\nBtrfs 还支持快速简便的远程备份。子卷快照可以 发送到远程系统 进行存储。通过利用文件系统中固有的 COW 元数据，这些传输通过仅发送先前发送的快照中的增量更改而非常有效。诸如 snapper 之类的用户应用程序使管理这些快照变得容易。\n另外，Btrfs 卷可以具有 透明压缩 功能，并且 chattr +c 可以标记进行压缩的单个文件或目录。压缩不仅可以减少数据消耗的空间，还可以通过减少写入操作量来帮助延长 SSD 的寿命。压缩当然会带来额外的 CPU 开销，但是有很多选项就可以权衡取舍。\nBtrfs 集成了文件系统和卷管理器功能，这意味着总体维护比 LVM-ext4 更简单。当然，这种集成的灵活性较低，但是对于大多数台式机甚至服务器而言，设置已足够。\nLVM 上使用 Btrfs Btrfs 可以 就地转换 ext3/ext4 文件系统。就地转换意味着无需将数据复制出来然后再复制回去。数据块本身甚至都不需要修改。因此，对于现有的 LVM-ext4 系统，一种选择是将 LVM 保留在原处，然后简单地将 ext4 转换为 Btrfs。虽然可行且受支持，但有一些原因使它不是最佳选择。\nBtrfs 的吸引力之一是与卷管理器集成的文件系统所带来的更轻松的管理。要是在 LVM 之上运行，对于系统维护，仍然要对额外的卷管理器进行一些设置。同样，LVM 设置通常具有多个固定大小的逻辑卷，并具有独立文件系统。虽然 Btrfs 支持给定的计算机上的多个卷，但是许多不错的功能都需要单一卷具有多个子卷。如果每个 LVM 卷都有一个独立的 Btrfs 卷，则用户仍然需要手动管理固定大小的 LVM 卷。虽然能够收缩挂载的 Btrfs 文件系统的能力确实使处理固定大小的卷的工作变得更轻松。通过在线收缩功能，就无需启动 实时镜像 了。\n在使用 Btrfs 的多设备支持时，必须仔细考虑逻辑卷的物理位置。对于 Btrfs 而言，每个逻辑卷都是一个单独的物理设备，如果实际情况并非如此，则某些数据可用性功能可能会做出错误的决定。例如，如果单个驱动器发生故障，对数据使用 RAID1 通常可以提供保护。如果实际逻辑卷在同一物理设备上，则没有冗余。\n如果强烈需要某些特定的 LVM 功能，例如原始块设备或高速缓存的逻辑卷，则在 LVM 之上运行 Btrfs 是有意义的。在这种配置下，Btrfs 仍然提供其大多数优点，例如校验和和易于发送的增量快照。尽管使用 LVM 会产生一些操作开销，但 Btrfs 的这种开销并不比任何其他文件系统大。\n总结 当尝试在 Btrfs 和 LVM-ext4 之间进行选择时，没有一个正确的答案。每个用户都有独特的要求，并且同一用户可能拥有具有不同需求的不同系统。看一下每个配置的功能集，并确定是否有令人心动的功能。如果没有，坚持默认值没有错。选择这两种设置都有很好的理由。\nSnapper Snapper 是 openSUSE 下用于创建和管理文件系统快照（以下简称快照）的工具。快照保存了文件系统在某个时间点的状态，从而可以轻松实现系统回滚或数据备份。\nSnapper 可以在 Btrfs 文件系统（推荐）及采用 XFS 或 Ext4 文件系统的 LVM 精简配置卷上使用，本文主要介绍在 Btrfs 文件系统上使用 Snapper 的方法。\n快照类型 Snapper 快照可分为两大类型：\n 快照对：由一对快照组成，在进行某项操作前拍摄一个“前快照”（pre），操作后再拍摄一个“后快照”（post），从而可以比较两个快照对差异而撤销该操作。快照对是一一对应的，如果删除了某一快照，则对应的快照也会被删除。 单一快照（single）：由一个单独的快照组成，与其他快照没有特殊联系。可用于备份或回滚整个系统等操作。  快照对和单一快照既可以手动创建，也可以根据配置自动创建。自动创建的快照又可分为三种类型：\n 时间线快照：每小时自动创建的单一快照。 安装快照：在安装软件包前后自动创建的一对快照对。可用于撤销软件包更改。 管理快照：在使用 YaST 管理系统前后自动创建的一堆快照对。可用于撤销配置更改。  这三种自动创建的快照均可单独启用和配置，从而提供了极大的灵活性。\n默认配置 要在分区或 Btrfs 子卷启用快照，需要创建配置文件。Snapper 的配置文件存储在 /etc/snapper/configs 中。\n如果你的根分区大于 16 GB，并且在安装 openSUSE 时使用默认分区配置，则根分区的配置文件应已被自动创建。默认配置启用了安装快照和管理快照，并排除了部分目录，可以满足大多数需求。以下列表显示了排除的所有目录：\n  /boot/grub2/i386-pc、/boot/grub2/x86_64-efi、/boot/grub2/powerpc-ieee1275、/boot/grub2/s390x-emu\n不能回滚引导加载程序配置。上面列出的目录是架构专属目录。前两个目录位于 AMD64/Intel 64 计算机上，后两个目录分别位于 IBM POWER 和 IBM Z 上。\n  /home\n如果独立的分区中没有 /home，便会将该目录排除以免在回滚时发生数据丢失。\n  /opt、/var/opt\n第三方产品通常安装到 /opt 下。排除此目录是为了防止在回滚时卸装这些应用程序。\n  /srv\n包含 Web 和 FTP 服务器的数据。排除此目录是为了防止在回滚时发生数据丢失。\n  /tmp、/var/tmp、/var/cache、/var/crash\n包含临时文件和超速缓存的所有目录都会排除在快照范围之外。\n  /usr/local\n在手动安装软件时会用到此目录。系统会将该目录排除以免在回滚时卸载这些安装的软件。\n  /var/lib/libvirt/images\n使用 libvirt 管理的虚拟机映像的默认位置。为确保回滚期间虚拟机映像不会替换为旧版本而被排除。默认情况下，此子卷是使用写入时不复制选项创建的。\n  /var/lib/mailman、/var/spool\n包含邮件或邮件队列的目录会排除，以免在回滚后造成邮件丢失。\n  /var/lib/bind\n包含 DNS 服务器的区域数据。排除该目录是为了确保回滚后名称服务器仍能运作。\n  /var/lib/mariadb、/var/lib/mysql、/var/lib/pgqsl\n这些目录包含数据库数据。默认情况下，这些子卷是使用写入时不复制选项创建的。\n  /var/log\n日志文件所在的位置。排除该目录是为了在对受损的系统进行回滚后能够对日志文件进行分析。\n  如果你希望使用 openSUSE 的默认配置，但在安装 openSUSE 时未开启快照功能，可以使用以下命令创建根分区的默认配置文件：\n注意： 要使用该默认配置文件，请确保根分区大小至少为 16 GB，并使用 openSUSE 安装程序建议的包含子卷的 Btrfs 根文件系统（安装程序默认分区设置）\nsnapper -c root create-config / 确保 snapper-zypp-plugin 软件包已安装以启用安装快照：\nzypper install snapper-zypp-plugin 手动配置 创建和装入新子卷 系统支持在 / 层次下创建新的子卷，并永久性装入该卷。此类子卷将从快照中排除。切勿在现有快照中创建此类子卷，因为在回滚之后，您将无法再删除快照。\nSUSE Linux Enterprise Server 上配置了 /@/ 子卷，该子卷充当永久性子卷（例如 /opt、/srv、/home 等）的独立根目录。您创建和永久装入的任何新子卷都需要在这个初始根文件系统中创建。\n为此，请运行以下命令。在此示例中，从 /dev/sda2 创建了一个新子卷 /usr/important。\nsudo mount /dev/sda2 -o subvol=@ /mntsudo btrfs subvolume create /mnt/usr/importantsudo umount /mnt /etc/fstab 中的相应项需类似于：\n/dev/sda2 /usr/important btrfs subvol=@/usr/important 0 0 提示：子卷可能包含经常更改的文件，例如虚拟化的磁盘映像、数据库文件或日志文件。如果是这样，可考虑对此卷禁用写入时复制功能，以免复制磁盘块。可在 /etc/fstab 中使用 nodatacow 装入选项来实现此目的：\n/dev/sda2 /usr/important btrfs nodatacow,subvol=@/usr/important 0 0 或者，要为单个文件或目录禁用写入时复制功能，请使用命令 chattr +C 路径。\n创建配置文件 希望在特定分区或子卷启用快照，可以以下命令创建相应的配置文件：\nsnapper -c 配置文件名 create-config 分区或子卷的挂载点 这将根据 /etc/snapper/config-templates/default 提供的默认值创建配置文件。\n注意： 在创建配置文件前请确保目标分区或子卷已被创建。不能为同一分区或子卷创建多个配置文件。\n例如，为防止回滚时数据丢失，默认的根分区配置排除了 /home 目录，可以使用上述命令为 /home 创建配置文件：\nsnapper -c home create-config /home 该命令会使用 /etc/snapper/config-templates/default 提供的默认值创建 /etc/snapper/configs/home 文件。\n可以使用\nsnapper list-configs 查看现有配置文件。\n启用/禁用自动快照 你可以选择性地启用/禁用自动创建的快照类型：\n启用时间线快照\nsnapper -c 配置文件名 set-config \"TIMELINE_CREATE=yes\" 禁用时间线快照\nsnapper -c 配置文件名 set-config \"TIMELINE_CREATE=no\" 时间线快照默认会启用，但根分区除外。\n注意： 以下两种快照包含的内容由安装的软件包或修改的配置而定，与特定分区或子卷无关。默认为启用状态。\n启用安装快照\nzypper install snapper-zypp-plugin 禁用安装快照\nzypper remove snapper-zypp-plugin 使用 YaST 或 Zypper 安装包时所创建的快照会由 snapper-zypp-plugin 进行处理。何时创建快照由 XML 配置文件 /etc/snapper/zypp-plugin.conf 定义。\n启用管理快照\n在 /etc/sysconfig/yast2 中将 USE_SNAPPER 设置为 yes 禁用管理快照\n在 /etc/sysconfig/yast2 中将 USE_SNAPPER 设置为 no 配置文件参数 Snapper 的行为由配置文件参数定义，除了直接使用文本编辑器编辑配置文件外，还可以使用\nsnapper -c 配置文件名称 set-config \"参数名称=参数\" 修改配置文件参数。\n以下对几个常用配置案例进行说明，完整的参数说明可参阅 snapper-configs(5) ：\nman snapper-configs 允许普通用户管理快照\n默认情况下仅 root 用户可以管理快照，要允许普通用户或组管理快照，可运行：\nsnapper -c 配置文件名称 set-config \"ALLOW_USERS=用户名\" \"ALLOW_GROUPS=组名\" \"SYNC_ACL=yes\" 必须配置“SYNC_ACL=yes”以允许普通用户访问快照所在目录。\n自动清理旧快照\n为防止快照占据全部磁盘空间，Snapper 提供了几种自动清理旧快照的机制，可通过一系列参数配置自动清理过程：\n   清理机制 说明 启用选项 配置参数 含义 备注     编号 根据快照编号进行清理 NUMBER_CLEANUP=yes NUMBER_LIMIT=数字或范围 定义要保留的快照数量。 如果启用了定额支持，应使用范围。如果未启用定额支持，应使用单个数字。   NUMBER_LIMIT_IMPORTANT=数字或范围 定义要保留的含 important 标签的快照数量，内核更新等的安装快照自带该标签。       NUMBER_MIN_AGE=秒 定义满足上述条件的快照被清理前最少应保留的时间。0 表示无限制。       时间线 根据快照创建时间进行清理 TIMELINE_CLEANUP=yes TIMELINE_LIMIT_HOURLY=数字或范围 定义要保留的每小时首张快照的数量。 如果启用了定额支持，应使用范围。如果未启用定额支持，应使用单个数字。   TIMELINE_LIMIT_DAILY=数字或范围 定义要保留的每日首张快照的数量。       TIMELINE_LIMIT_WEEKLY=数字或范围 定义要保留的每周首张快照的数量，此处的周由星期一开始。       TIMELINE_LIMIT_MONTHLY=数字或范围 定义要保留的每月首张快照的数量。       TIMELINE_LIMIT_YEARLY=数字或范围 定义要保留的每年首张快照的数量。       TIMELINE_MIN_AGE=秒 定义满足上述条件的快照被清理前最少应保留的时间。0 表示无限制。       无差异快照对 清理没有差异的快照对。如运行 Yast2 后未作任何修改，则自动清理创建的管理快照。 EMPTY_PRE_POST_CLEANUP=yes EMPTY_PRE_POST_CLEANUP=秒 定义无差异快照对被清理前最少应保留的时间。0 表示无限制。    磁盘定额 定义快照可占用空间的百分比 运行snapper setup-quota SPACE_LIMIT=表示百分比的小数 定义快照可占用空间的百分比 仅支持 Btrfs 文件系统需至少启用编号或时间线清理算法中的一个启用定额支持后，编号和时间线清理算法的部分参数应当使用范围值。清理算法会清理快照至上限值，如果未满足定额配置则在下限值范围内尽量清理快照以满足定额。    管理配置文件 可以使用 snapper 命令快速管理配置文件：\n列出配置文件\nsnapper list-configs 显示特定的配置文件\nsnapper -c 配置文件名称 get-config 删除配置文件\nsnapper -c 配置文件名称 delete-config 快照管理 可以使用 snapper 工具或 Yast2 模块进行查看、创建、比较快照等操作。\nsnapper 工具提供了一系列子命令，可以在文本界面进行快照管理。本节介绍了一些常用命令和参数，更多信息可参阅 snapper(8)：\nman snapper 注意： 管理快照时可使用 “-c 配置文件名” 指定配置文件，如未指定则默认使用 root 配置文件，下述示例均未指定配置文件。\n查看快照\nsnapper list 将列出 root 配置的所有快照。\n可以使用 “-t” 参数列出特定类型的快照。\n例如，列出 root 配置下的所有快照对：\nsnapper list -t pre-post 列出 home 配置下的所有单一快照：\nsnapper -c home list -t single 你还可以使用\nsnapper list -a 列出所有配置下的快照。\n创建快照\nsnapper create 将使用 root 配置文件创建一个单一快照。\n可以使用“-t”参数指定快照类型（默认值为 single），使用“-d”参数添加描述。手动创建的快照默认不会自动被清理，使用“–cleanup-algorithm”参数指定自动清理算法。还可以使用“–userdata”参数定义自定义数据（如 important 标记）。\n例如，创建当前系统的单一快照，标记为重要，并指定时间线清理算法：\nsnapper create -t single --description \"系统快照\" --userdata \"important=yes\" --cleanup-algorithm timeline 要创建一个快照对，首先创建一个前快照，使用“–print-number”选项以列出快照编号：\nsnapper create -t pre --print-number --description \"Before\" 假设列出的快照编号为 30，将其作为“–pre-number”参数的值创建后快照：\nsnapper create -t post --pre-number 30 --description \"After\" 你也可以使用\nsnapper create --command \"要运行的命令\" 以自动创建运行命令前后的快照对。\n比较快照\n有两种比较方法：\nsnapper status .. //第一个快照的创建时间要早于第二个 将显示您在两个快照时间内修改的全部文件的路径和文件名。\n例如，下述命令可以比较当前系统状态与 161 号快照的差异：\nsnapper status 161..0 //0 表示当前系统，它不是快照，但你可以认为是比所有快照都新的一个快照。 第二种：\nsnapper diff .. 文件名 将以 diff 的格式显示指定文件的差异，如果未指定文件名，将显示所有文件的差异。\n撤销修改\nsnapper undochange ..  比如你误删除了某个文件，可以使用：\nsnapper undochange ..0 文件名 //0 表示当前系统，它不是快照，但你可以认为是比所有快照都新的一个快照。 来撤销。\n删除快照\nsnapper delete 快照编号或范围 例如，要删除 16 号快照：\nsnapper delete 16 要删除 10 号到 15 号快照：\nsnapper delete 10-15 可以结合“-s”参数以在删除快照后立刻释放可用空间而不必等待 Btrfs 进程回收。\n回滚整个系统\nSUSE Linux Enterprise Server 上包含的 GRUB 2 版本可以从 Btrfs 快照进行引导。与 Snapper 的回滚功能相结合，就能恢复配置错误的系统。只有针对默认 Snapper 配置（根）创建的快照才可引导。\n注意： 要回滚整个系统，请确保根文件系统为 openSUSE 安装程序默认的带子卷的 Btrfs 文件系统。从 SUSE Linux Enterprise Server 15 开始，只有在根分区的默认子卷配置未更改过的情况下，才支持系统回滚。\n如果因为更新或病毒等原因导致系统出现重大错误，并保留了错误前的快照，则可以回滚整个系统到错误前的状态。\nsnapper rollback 要回滚的快照编号 该命令将创建当前系统状态的只读快照 A 及指定编号快照的可读写快照 B，并使用快照 B 替换根分区的默认子卷，重新启动系统后即可实现回滚。\n你还可以在引导系统时选择Start bootloader from a read-only snapshot，以引导想要回滚的快照，在检查无误后在引导的快照中执行：\nsnapper rollback 不指定快照编号时，将创建根分区默认子卷（即原系统）的只读快照 A 和当前系统（即目前引导的快照）的可读写快照 B，并使用快照 B 替换根分区的默认子卷，重新启动系统后选择默认引导项即可实现回滚。\nsudo 许多命令和系统实用程序都需要以 root 身份运行才能执行。为了确保安全和避免发生意外运行危险命令，通常建议不要直接以 root 身份登录。建议的做法是以非特权的普通用户身份工作，并使用 sudo 命令来运行需要较高特权的命令。\n在 SUSE Linux Enterprise Server 上，sudo 默认配置与 su 的工作方式类似。但是，sudo 可让用户以高度可配置的方式使用任何其他用户的特权来运行命令。这样，便可为某些用户和组指派具有特定特权的角色。举例来说，可以允许组 users 的成员使用 wilber 的特权运行命令。通过禁止指定任何命令选项，可以进一步限制对命令的权限。虽然 su 始终需要 root 口令才能使用 PAM 进行身份验证，但是您可以将 sudo 配置为使用您自己的身份凭证进行身份验证。这样就不需要共享 root 口令，从而提高了安全性。\nsudo 基本用法 虽然 sudo 简单易用，功能却十分强大。\n运行单个命令 以普通用户身份登录后，您可以在命令前加上 sudo 以 root 身份运行任何命令。按照提示输入口令后，如果身份验证成功，您便能以 root 身份运行命令：\n# id -un 命令会打印当前用户的登录名 $ id -un tux # 在输入过程中不会显示口令，无论是明文还是密文均不显示。  $ sudo id -un root's password: root # 只有以 sudo 开头的命令才会使用较高的特权运行。如果是不带 sudo 前缀的相同命令，仍会使用当前用户的特权运行。  $ id -un tux # 在限定时间内，您无需再次输入 root 口令。  $ sudo id -un root I/O 重定向的工作方式与您预期的可能不同：\n$ sudo echo s  /proc/sysrq-trigger bash: /proc/sysrq-trigger: Permission denied $ sudo cat 只有 echo/cat 二进制会使用较高特权运行，重定向则由用户外壳使用用户特权执行。您可以按启动外壳中所述启动外壳，也可以使用 dd 实用程序来启动：\n$ echo s | sudo dd of=/proc/sysrq-trigger $ sudo dd if=/proc/1/maps | cat 启动外壳 必须在每条命令前加上 sudo 可能很繁琐。虽然可以将外壳指定为命令 sudo bash，但还是建议您使用以下其中一种内置机制来启动外壳：\n  sudo -s ()\n启动 SHELL 环境变量所指定的外壳或目标用户的默认外壳。如果给定了命令，则会将该命令传递给外壳（使用 -c 选项），否则外壳会以交互模式运行。\n$ sudo -s root's password: $ exit   sudo -i ()\n  与 -s 类似，但是会将外壳启动为登录外壳。也就是说，系统会对外壳的启动文件（.profile 等）进行处理，并会将当前的工作目录设置为目标用户的主目录。\n$ sudo -i root's password: $ exit   环境变量 默认情况下，sudo 不会传播环境变量：\n$ ENVVAR=test env | grep ENVVAR ENVVAR=test $ ENVVAR=test sudo env | grep ENVVAR root's password: $ 输出为空即表明在使用 sudo 运行的命令的环境中不存在环境变量 ENVVAR。\n此行为可通过 env_reset 选项进行更改，请参见下文有用的标志和选项。\n配置 sudo sudo 是一个非常灵活的工具，提供各种配置选项。\n注意：如果您不小心将自己锁定在 sudo 之外，则可以使用 su - 及 root 口令来获取 root 外壳。要修复该错误，请运行 visudo。\n编辑配置文件 sudo 的主要策略配置文件为 /etc/sudoers。如果此文件中存在错误，您可能便会无法进入系统，因此强烈建议您使用 visudo 来编辑配置文件。此举可防止同时更改打开的文件，并会在保存修改之前检查语法错误。\n您还可以通过设置 EDITOR 环境变量来使用除 vi 以外的编辑器（不论名字如何），例如：\n$ sudo EDITOR=/usr/bin/nano visudo 不过，/etc/sudoers 文件本身是由系统包提供的，更新时这些修改可能会取消。因此，建议您将自定义配置放到 /etc/sudoers.d/ 目录下的文件中。该目录下的任何文件都会自动纳入系统中。要在该子目录下创建或编辑文件，请运行：\nsudo visudo -f /etc/sudoers.d/NAME 或者，使用其他编辑器（例如 nano）：\nsudo EDITOR=/usr/bin/nano visudo -f /etc/sudoers.d/NAME 注意：/etc/sudoers 中的 #includedir 命令（用于 /etc/sudoers.d）会忽略以 ~（波浪号）结尾或包含 .（点）的文件。\n关于 visudo 命令的详细信息，请运行 man 8 visudo。\nsudoers 基本配置语法 在 sudoers 配置文件中，有两种类型的选项：字符串和标志。字符串可以包含任何值，而标志则只能在“ON”或“OFF”之间切换。sudoers 配置文件最重要的语法构造为：\n# Everything on a line after a # gets ignored, Defaults !insults # Disable the insults flag Defaults env_keep += \"DISPLAY HOME\" # Add DISPLAY and HOME to env_keep tux ALL = NOPASSWD: /usr/bin/frobnicate, PASSWD: /usr/bin/journalctl  #include 和 #includedir 这两个普通命令例外。其后跟数字，用于指定 UID。 去除 ! 可将指定的标志设置为“ON”。  有用的标志和选项\n   选项名称 说明 示例     targetpw 此标志控制调用用户是需要输入目标用户（例如 root）的口令 (ON) 还是需要输入调用用户的口令 (OFF)。 Defaults targetpw # Turn targetpw flag ON   rootpw 如果设置了该选项，sudo 会提示输入 root 口令，而非目标用户或调用者的口令。默认值为“OFF”。 Defaults !rootpw # Turn rootpw flag OFF   env_reset 如果设置了该选项，sudo 会构造一个仅包含 TERM、PATH、HOME、MAIL、SHELL、LOGNAME、USER、USERNAME 和 SUDO_* 集的最小环境。此外，会从调用环境导入 env_keep 中列出的变量。默认值为“ON”。 Defaults env_reset # Turn env_reset flag ON   env_keep env_reset 标志设为“ON”时要保留的环境变量列表。 # Set env_keep to contain EDITOR and PROMPT Defaults env_keep = \"EDITOR PROMPT\" Defaults env_keep += \"JRE_HOME\" # Add JRE_HOME Defaults env_keep -= \"JRE_HOME\" # Remove JRE_HOME   env_delete env_reset 标志设为“OFF”时要去除的环境变量列表。 # Set env_delete to contain EDITOR and PROMPT Defaults env_delete = \"EDITOR PROMPT\" Defaults env_delete += \"JRE_HOME\" # Add JRE_HOME Defaults env_delete -= \"JRE_HOME\" # Remove JRE_HOME    还可以使用 Defaults 令牌为用户、主机和命令集合创建别名。并且，可以仅将选项应用到特定用户集。\n关于 /etc/sudoers 配置文件的详细信息，请参见 man 5 sudoers。\nsudoers 中的规则 sudoers 配置中的规则可能会非常复杂，因此本节仅涉及基本内容。每个规则都遵循基本模式（[] 标记的是可选部分）：\n#Who Where As whom Tag What User_List Host_List = [(User_List)] [NOPASSWD:|PASSWD:] Cmnd_List   User_List\n一个或多个（用 , 分隔）标识符：用户名、格式为 %GROUPNAME 的组或格式为 #UID 的用户 ID。可以使用 ! 前缀来取反。\n  Host_List\n一个或多个（用 , 分隔）标识符：（完全限定的）主机名或 IP 地址。可以使用 ! 前缀来取反。Host_List 的惯常选项为 ALL。\n  NOPASSWD:|PASSWD:\n如果用户在 NOPASSWD: 后面运行的命令与 CMDSPEC 匹配，系统不会提示用户输入口令。\nPASSWD 为默认选项，仅当两个选项位于同一行时才需要指定它：\ntux ALL = PASSWD: /usr/bin/foo, NOPASSWD: /usr/bin/bar   Cmnd_List\n一个或多个（用 , 分隔）区分符：可执行文件的路径，后跟允许使用的自变量或什么也不跟。\n/usr/bin/foo # Anything allowed /usr/bin/foo bar # Only \"/usr/bin/foo bar\" allowed /usr/bin/foo \"\" # No arguments allowed   ALL 可以用作 User_List、Host_List 和 Cmnd_List。\n允许 tux 在无需输入口令的情况下以 root 身份运行所有命令的规则：\ntux ALL = NOPASSWD: ALL 允许 tux 运行 systemctl restart apache2 的规则：\ntux ALL = /usr/bin/systemctl restart apache2 允许 tux 在不带自变量的情况下以 admin 身份运行 wall 的规则：\ntux ALL = (admin) /usr/bin/wall \"\" 警告：以下类型的构造\nALL ALL = ALL 在没有 Defaults targetpw 的情况下切勿使用，否则任何人都能以 root 身份运行命令。\n常见使用情况 尽管默认配置对于简单的设置和桌面环境通常已经够用，但是自定义配置非常有用。\n在无需 root 口令的情况下使用 sudo 在具有特殊限制（“用户 X 只能以 root” 身份运行命令 Y）的情况下，无法实现此目的。在其他情况下，还是建议进行某种分隔。按照惯例，组 wheel 的成员能以 root 身份运行所有带有 sudo 的命令。\n  将自己添加到 wheel 组\n如果您自己的用户帐户尚不是 wheel 组的成员，请添加该帐户，具体做法是运行 sudo usermod -a -G wheel 用户名然后注销并再次登录。运行 groups 用户名以确认更改是否成功。\n  将使用调用用户的口令进行身份验证的选项设为默认设置。\n使用 visudo 创建文件 /etc/sudoers.d/userpw并添加：\nDefaults !targetpw   选择新默认规则。\n根据是否想要用户重新输入口令，取消对 /etc/sudoers 中特定行的注释，并将默认规则注释掉。\n## Uncomment to allow members of group wheel to execute any command # %wheel ALL=(ALL) ALL ## Same thing without a password # %wheel ALL=(ALL) NOPASSWD: ALL   提高默认规则的限制性\n将 /etc/sudoers 中允许一切操作的规则注释掉或去除：\nALL ALL=(ALL) ALL # WARNING! Only use this together with 'Defaults targetpw'!   警告：切勿漏掉这一步，否则任何用户都能以 root 身份执行任何命令。\n  测试配置\n尝试以 wheel 的成员和非成员身份运行 sudo。\n# user tux $ groups users wheel $ sudo id -un tux's password: root # use wilber $ groups users $ sudo id -un wilber is not in the sudoers file. This incident will be reported.   对 X.Org 应用程序使用 sudo 在使用 sudo 启动图形应用程序时，可能会出现以下错误：\n$ sudo xterm xterm: Xt error: Can't open display: %s xterm: DISPLAY is not set YaST 会选择 ncurses 界面而非图形界面。\n要在通过 sudo 启动的应用程序中使用 X.Org，需要传播环境变量 DISPLAY 和 XAUTHORITY。要进行此项配置，请创建文件 /etc/sudoers.d/xorg并添加下面一行：\nDefaults env_keep += \"DISPLAY XAUTHORITY\" 如尚未设置 XAUTHORITY 变量，请按如下方式设置：\nexport XAUTHORITY=~/.Xauthority 现在，X.Org 应用程序便可正常运行：\n$ sudo yast2 Zypper Zypper 是用于安装、更新和去除包的命令行包管理器。它还可管理储存库。这一点对于完成远程软件管理任务或从外壳脚本管理软件尤其有用。\n一般使用 Zypper 的常用语法为：\nzypper [--global-options] COMMAND [--command-options] [arguments] 有关常规选项和所有命令的列表，请参见 zypper help。要获取有关特定命令的帮助，请键入 zypper help 命令。\n  Zypper 命令\n执行 Zypper 最简单的方式是，键入其名称后跟一个命令。例如，要将所有需要的增补程序应用于系统，请使用：\n$ sudo zypper patch   全局选项\n此外，您还可以选择使用一个或多个全局选项，只需在命令前面键入它们即可：\n$ sudo zypper --non-interactive patch 在上面的示例中，选项 --non-interactive 表示在不询问任何问题的情况下运行命令（自动应用默认回答）。\n  命令特定的选项\n要使用特定于某个命令的选项，请紧接在该命令后面键入这些选项：\n$ sudo zypper patch --auto-agree-with-licenses 在上面的示例中，--auto-agree-with-licenses 用于将所有需要的增补程序应用于系统，不要求您确认任何许可条款，而是自动接受许可条款。\n  自变量\n某些命令需要一个或多个自变量。例如，使用 install 命令时，需要指定您要安装的一个或多个包：\n$ sudo zypper install mplayer 某些选项还需要单个自变量。用以下命令可列出所有已知模式：\n$ zypper search -t pattern   您可以组合上述所有模式。例如，下面的命令在冗长模式下运行时将安装 mc and vim 包（来自 factory 储存库）：\n$ sudo zypper -v install --from factory mc vim --from 选项确保了在从指定储存库请求包时保留所有储存库的启用状态（用于解析任何依赖项）。\n多数 Zypper 命令都有 dry-run 选项，它模拟给定的命令。它可用于测试。\n$ sudo zypper remove --dry-run MozillaFirefox Zypper 支持 --userdata 字符串全局选项。您可以使用此选项指定一个将会写入 Zypper 的日志文件和插件（例如 Btrfs 插件）的字符串。它可以用于标记和标识日志文件中的事务。\n$ sudo zypper --userdata STRING patch 使用 Zypper 安装和删除软件 要安装或去除包，请使用以下命令：\n$ sudo zypper install PACKAGE_NAME$ sudo zypper remove PACKAGE_NAME 警告：不要去除必需的系统包，例如 glibc 、zypper、kernel。如果去除这些包，系统可能会变得不稳定，或完全停止工作。\n选择要安装或去除的包 可以使用 zypper install 和 zypper remove 命令通过多种方法来找到包。\n  按确切的包名称\n$ sudo zypper install MozillaFirefox   按确切的包名称和版本号\n$ sudo zypper install MozillaFirefox-52.2   按储存库别名和包名称\n$ sudo zypper install mozilla:MozillaFirefox 其中 mozilla 是用于安装的储存库别名。\n  使用通配符按包名称\n您可以选择名称以特定字符串开头或结尾的所有包。使用通配符要小心，特别是去除包的时候。以下命令将安装名称以“Moz”开头的所有包：\n$ sudo zypper install 'Moz*' 提示：在调试问题时，您有时需要临时安装大量的 -debuginfo 包，以获取有关正在运行的进程的详细信息。在调试会话完成后，如果您需要清理环境，请运行以下命令：\n$ sudo zypper remove '*-debuginfo'   按功能\n例如，要安装不知道名称的包，这些功能就很有用。下面的命令将安装包 MozillaFirefox：\n$ sudo zypper install firefox   按功能、硬件体系结构或版本\n  所需硬件体系结构的名称需要追加在功能的后面，两者以句点分隔。例如，要指定 AMD64/Intel 64 体系结构（在 Zypper 中命名为 x86_64），请使用：\n$ sudo zypper install 'firefox.x86_64'   版本必须追加到字符串的末尾，并且前面必须带有一个运算符：（小于）、（小于等于）、=（等于）、=（大于等于）或 （大于）。\n$ sudo zypper install 'firefox=52.2'   还可以指定硬件体系结构与版本组合要求：\n$ sudo zypper install 'firefox.x86_64=52.2'     按 RPM 文件的路径\n您还可以指定包的本地或远程路径：\n$ sudo zypper install /tmp/install/MozillaFirefox.rpm$ sudo zypper install http://download.example.com/MozillaFirefox.rpm   同时安装和去除包 要同时安装和去除包，请使用 +/- 修饰符。要安装 emacs 并同时去除 vim ，请使用：\n$ sudo zypper install emacs -vim 要去除 emacs 并同时安装 vim ，请使用：\n$ sudo zypper remove emacs +vim 为避免 - 开头的包名称被解释为命令行选项，要始终把它用作第二个自变量。如果做不到这点，在它之前加上 --：\n$ sudo zypper install -emacs +vim # Wrong$ sudo zypper install vim -emacs # Correct$ sudo zypper install -- -emacs +vim # Correct$ sudo zypper remove emacs +vim # Correct 清理已去除包的依赖项 如果您想将在指定的包去除后不再需要的所有包（随指定的包）自动去除，请使用 --clean-deps 选项：\n$ sudo zypper rm PACKAGE_NAME --clean-deps 在脚本中使用 Zypper 默认情况下，在安装或删除选定包之前发生问题时，Zypper 会要求确认。您可以使用 --non-interactive 选项覆盖此行为。必须在实际命令（install、remove 和 patch）的前面指定此选项，如下所示：\n$ sudo zypper --non-interactive install PACKAGE_NAME 该选项允许在脚本和 cron 任务中使用 Zypper。\n安装或下载源包 要安装某个包的对应源代码包，请使用：\n$ zypper source-install PACKAGE_NAME 以 root 身份执行时，源包的默认安装位置为 /usr/src/packages/；以用户身份运行时，则为 ~/rpmbuild。可以在本地 rpm 配置中更改这些值。\n使用此命令还会安装指定包的版本依赖项。如果不想执行此操作，请添加开关 -D：\n$ sudo zypper source-install -D PACKAGE_NAME 要只安装版本依赖项，请使用 -d。\n$ sudo zypper source-install -d PACKAGE_NAME 当然，只有当储存库列表中启用了含有源包的储存库时，才能这样做（默认添加但不启用它）。\n可使用以下方法来获取储存库中所有源包的列表：\n$ zypper search -t srcpackage 您也可以将所有已安装软件包的源包下载到本地目录。要下载源包，请使用：\n$ zypper source-download 默认的下载目录是 /var/cache/zypper/source-download。您可以使用 --directory 选项更改下载目录。若只想显示缺失或多余的包而不进行下载或删除任何内容，请使用 --status 选项。要删除多余的源包，请使用 --delete 选项。要禁用删除，请使用 --no-delete 选项。\n从禁用的储存库安装包 通常，您只能安装或刷新来自启用的储存库的包。--plus-content 标记选项可帮助您指定要刷新的、要在当前 Zypper 会话期间暂时启用的，以及要在会话完成后禁用的储存库。\n例如，要启用可以提供其他 -debuginfo 或 -debugsource 包的储存库，请使用 --plus-content debug。可以多次指定此选项。\n要暂时启用此类“调试”储存库以安装特定的 -debuginfo 包，请按如下所示使用该选项：\n$ sudo zypper --plus-content debug \\ install \"debuginfo(build-id)=eb844a5c20c70a59fc693cd1061f851fb7d046f4\" 对于缺少的 debuginfo 包，gdb 将会报告 build-id 字符串。\n实用程序 要校验所有依赖项是否仍然满足，并修复缺少的依赖项，请使用：\n$ zypper verify 除了依赖项必须满足外，某些包还“推荐”其他包。只有在实际可用并可安装时才会安装这些推荐包。如果推荐的包在推荐它们的包已安装（通过添加其他包或硬件）之后才可用，请使用以下命令：\n$ sudo zypper install-new-recommends 此命令在插入网络摄像头或 Wi-Fi 设备后非常有用。如果可用，它将安装设备驱动程序和相关软件。只有在满足特定硬件依赖项后，才可安装驱动程序和相关软件。\n使用 Zypper 更新软件 用 Zypper 更新软件有三种方式：安装包、安装包的新版本或更新整个分发包。最后一种方式可通过 zypper dist-upgrade 来实现。\n安装全部所需的增补程序 要安装所有适用于您系统的正式发布的增补程序，请运行：\n$ sudo zypper patch 系统将会检查您计算机上配置的储存库中提供的所有增补程序是否与您的安装相关。如果相关（未分为可选或功能类别），则会立即安装这些增补程序。\n如果即将安装的增补程序所包含的更改要求重引导系统，您会在重引导前收到警告。\n单纯使用 zypper patch 命令不会应用来自第三方储存库的包。要同时更新第三方储存库，请使用 with-update 命令选项，如下所示：\n$ sudo zypper patch --with update 要额外安装可选增补程序，请使用：\n$ sudo zypper patch --with-optional 要安装与特定 Bugzilla 问题相关的所有增补程序，请使用：\n$ sudo zypper patch --bugzilla=NUMBER 要安装与特定 CVE 数据库项相关的所有增补程序，请使用：\n$ sudo zypper patch --cve=NUMBER 例如，要安装 CVE 编号为 CVE-2010-2713 的安全增补程序，请执行：\n$ sudo zypper patch --cve=CVE-2010-2713 如果只想安装影响 Zypper 和包管理本身的增补程序，请使用：\n$ sudo zypper patch --updatestack-only 请记住，如果您使用了 updatestack-only 命令选项，将会丢弃原本还会更新其他储存库的其他命令选项。\n列出增补程序 为了让您确定增补程序是否可用，Zypper 允许您查看以下信息：\n  所需增补程序的数目\n要列出所需增补程序（适用于您的系统但尚未安装的增补程序）的数目，请使用 patch-check：\n$ zypper patch-checkLoading repository data...Reading installed packages...5 patches needed (1 security patch) 可以结合 --updatestack-only 选项使用此命令，以便仅列出影响 Zypper 和包管理本身的增补程序。\n  所需增补程序的列表\n要列出全部所需的增补程序（适用于您的系统但尚未安装的增补程序），请使用 list-patches：\n$ zypper list-patchesLoading repository data...Reading installed packages...Repository | Name | Version | Category | Status | Summary---------------+-------------+---------+----------+---------+---------SLES12-Updates | SUSE-2014-8 | 1 | security | needed | openssl: Update for OpenSSL   所有增补程序的列表\n要列出可用的所有增补程序，而不管它们是否已安装或适用于您的安装，请使用 zypper patches。\n还可以列出并安装与特定问题相关的增补程序。要列出特定的增补程序，请使用带以下选项的 zypper list-patches 命令：\n  按 Bugzilla 问题\n要列出与 Bugzilla 问题相关的全部所需增补程序，请使用 --bugzilla 选项。\n要列出针对特定 Bug 的增补程序，您也可以指定 Bug 编号：--bugzilla=编号。要搜索与多个 Bugzilla 问题相关的增补程序，请在 bug 编号之间添加逗号，例如：\n$ zypper list-patches --bugzilla=972197,956917   按 CVE 编号\n要列出与 CVE（公共漏洞和披露）数据库中某个项相关的全部所需增补程序，请使用 --cve 选项。\n要列出针对特定 CVE 数据库项的增补程序，您也可以指定 CVE 编号：--cve=*编号*。要搜索与多个 CVE 数据库项相关的增补程序，请在 CVE 编号之间添加逗号，例如：\n$ zypper list-patches --bugzilla=CVE-2016-2315,CVE-2016-2324     要列出所有增补程序而不管是否需要安装它们，请另外使用 --all 选项。例如，要列出指派有 CVE 编号的所有增补程序，请使用：\n$ zypper list-patches --all --cveIssue | No. | Patch | Category | Severity | Status------+---------------+-------------------+-------------+-----------+----------cve | CVE-2015-0287 | SUSE-SLE-Module.. | recommended | moderate | neededcve | CVE-2014-3566 | SUSE-SLE-SERVER.. | recommended | moderate | not needed[...] 安装新的包版本 如果某个安装源只包含新包，但未提供增补程序，则 zypper patch 不会产生任何作用。要使用可用的较新版本更新所有已安装的包（同时还要保持系统完整性），请使用︰\n$ sudo zypper update 要更新个别包，请用更新或安装命令指定包：\n$ sudo zypper update PACKAGE_NAME$ sudo zypper install PACKAGE_NAME 可使用此命令来获取所有新的可安装包的列表：\n$ zypper list-updates 请注意，此命令只会列出符合以下准则的包︰\n 与已安装的包拥有相同的供应商， 由至少与已安装包拥有相同优先级的储存库提供， 可安装（满足所有依赖项）。  所有新的可用包（无论是否可安装）的列表可通过以下方式获取：\n$ sudo zypper list-updates --all 要找出新包无法安装的原因，请使用上面所述的 zypper install 或 zypper update 命令。\n识别孤立的包 每当您从 Zypper 中去除某个储存库或者升级系统时，某些包可能会进入“孤立”状态。这些孤立的包不再属于任何活动储存库。以下命令可以列出这些包：\n$ sudo zypper packages --orphaned 借助此列表，您可以确定是否仍然需要某个包，或者是否可以安全去除某个包。\n识别使用已删除文件的进程和服务 在增补、更新或去除包时，系统上可能有一些正在运行的进程会继续使用更新或去除后已被删除的文件。运行 zypper ps 可以列出使用已删除文件的进程。如果此类进程属于某个已知的服务，则会列出服务名称，方便您重启动该服务。默认情况下，zypper ps 会显示一个表：\nPID | PPID | UID | User | Command | Service | Files------+------+-----+-------+--------------+--------------+-------------------814 | 1 | 481 | avahi | avahi-daemon | avahi-daemon | /lib64/ld-2.19.s- | | | | | | /lib64/libdl-2.1- | | | | | | /lib64/libpthrea- | | | | | | /lib64/libc-2.19-[...]  PID：进程的 ID PPID：父进程的 ID UID：运行进程的用户的 ID User：运行进程的用户的登录名 Command：用于执行进程的命令 Service：服务名称（仅当命令与系统服务关联时才显示） Files：已删除文件的列表  通过如下方式可控制 zypper ps 的输出格式：\n  zypper ps -s\n创建一份简短表格，其中不会显示已删除的文件。\nPID | PPID | UID | User | Command | Service------+------+------+---------+--------------+--------------814 | 1 | 481 | avahi | avahi-daemon | avahi-daemon817 | 1 | 0 | root | irqbalance | irqbalance1567 | 1 | 0 | root | sshd | sshd1761 | 1 | 0 | root | master | postfix1764 | 1761 | 51 | postfix | pickup | postfix1765 | 1761 | 51 | postfix | qmgr | postfix2031 | 2027 | 1000 | tux | bash |   zypper ps -ss\n仅显示与系统服务关联的进程。\nPID | PPID | UID | User | Command | Service------+------+------+---------+--------------+--------------814 | 1 | 481 | avahi | avahi-daemon | avahi-daemon817 | 1 | 0 | root | irqbalance | irqbalance1567 | 1 | 0 | root | sshd | sshd1761 | 1 | 0 | root | master | postfix1764 | 1761 | 51 | postfix | pickup | postfix1765 | 1761 | 51 | postfix | qmgr | postfix   zypper ps -sss\n仅显示使用已删除文件的系统服务。\navahi-daemonirqbalancepostfixsshd   zypper ps --print \"systemctl status %s\"\n显示用于检索可能需要重启动的服务状态信息的命令。\nsystemctl status avahi-daemonsystemctl status irqbalancesystemctl status postfixsystemctl status sshd   用 Zypper 管理安装源 Zypper 的所有安装或增补程序命令均基于已知安装源列表。要列出系统已知的所有储存库，请使用命令：\n$ zypper repos 结果将类似于与以下输出：\n# | Alias | Name | Enabled | Refresh--+--------------+---------------+---------+--------1 | SLEHA-12-GEO | SLEHA-12-GEO | Yes | No2 | SLEHA-12 | SLEHA-12 | Yes | No3 | SLES12 | SLES12 | Yes | No 当在各个命令中指定储存库时，可以使用别名、URI 或 zypper repos 命令输出中的储存库编号。储存库别名是用于储存库处理命令中的储存库名称的简短版本。请注意，在修改储存库列表后，储存库编号可能会更改。别名本身不会更改。\n默认情况下不显示储存库的 URI 或优先级之类的细节。用以下命令可以列出所有细节：\n$ zypper repos -d 添加安装源 要添加安装源，请运行\n$ sudo zypper addrepo URI ALIAS URI 可以是因特网储存库、网络资源、目录、CD 或 DVD。ALIAS 是储存库的唯一简写标识符。您可以随意选择别名，前提是它必须唯一。如果指定的别名已在使用，Zypper 将发出警告。\n刷新储存库 zypper 可让您从配置的储存库中提取包的更改。要提取更改，请运行：\n$ sudo zypper refresh 注意：有些命令默认会自动执行 refresh，因此您不需要明确运行该命令。\n使用 refresh 命令时搭配 --plus-content 选项还可查看已禁用储存库中的更改：\n$ sudo zypper --plus-content refresh 该选项虽然会提取储存库中的更改，但会使禁用储存库的状态保持不变，即仍为禁用。\n删除储存库 要从列表中去除某个储存库，请将命令 zypper removerepo 与要删除的储存库的别名或编号结合使用。例如\n$ sudo zypper removerepo 1$ sudo zypper removerepo \"SLEHA-12-GEO\" 修改储存库 用 zypper modifyrepo 启用或禁用储存库。您还可以用该命令更改储存库的属性（例如刷新行为、名称或优先级）。以下命令将会启用名为 updates 的储存库、打开自动刷新并将其优先级设置为 20：\n$ sudo zypper modifyrepo -er -p 20 'updates' 修改储存库并不局限于单个储存库 —— 您也可以对组执行该操作︰\n -a：所有储存库 -l：本地储存库 -t：远程储存库 -m 类型：特定类型的储存库（其中类型可以是以下之一：http、https、ftp、cd、dvd、dir、file、cifs、smb、nfs、hd 和 iso）  要重命名安装源别名，请使用 renamerepo 命令。以下示例将别名从 Mozilla Firefox 更改为 firefox：\n$ sudo zypper renamerepo 'Mozilla Firefox' firefox 用 Zypper 查询储存库和包 Zypper 提供各种查询储存库或包的方式。要获取所有可用的产品、模式、包或增补程序的列表，请使用以下命令：\n$ zypper products$ zypper patterns$ zypper packages$ zypper patches 要查询特定包的所有储存库，请使用 search。要获得有关特定包的信息，请使用 info 命令。\n搜索软件 zypper search 命令可对包名或（视情况）对包摘要和说明执行搜索。括在 / 中的字符串会解译为正则表达式。默认情况下搜索不区分大小写。\n  执行简单搜索来查找包含 fire 的包名称\n$ zypper search \"fire\"   执行简单搜索来查找确切的包 MozillaFirefox\n$ zypper search --match-exact \"MozillaFirefox\"   同时在包描述和摘要中搜索\n$ zypper search -d fire   仅显示尚未安装的包\n$ zypper search -u fire   显示包含字符串 fir 且该字符串后面不是 e 的包\n$ zypper se \"/fir[^e]/\"   搜索特定功能 要搜索提供特殊功能的包，请使用命令 what-provides。例如，如果您想知道哪个包提供 Perl 模块 SVN::Core，请使用以下命令：\n$ zypper what-provides 'perl(SVN::Core)' what-provides 包名 与 rpm -q --whatprovides 包名 类似，不过 RPM 只能查询 RPM 数据库（即所有已安装的包的数据库）。另一方面，Zypper 将告诉您任意储存库的功能的提供商，而非仅已安装的储存库功能的提供商。\n显示包信息 要查询个别包，请使用 info 命令，并用完整包名称作为自变量。这会显示有关某个包的详细信息。如果包名与储存库中的所有包名都不匹配，该命令会输出非包匹配项的详细信息。如果您请求特定类型（通过使用 -t 选项），但该类型不存在，该命令会输出其他可用的匹配项，但不提供详细信息。\n如果您指定源包，该命令会显示基于该源包构建的二进制包。如果您指定二进制包，该命令会输出用来构建该二进制包的源包。\n如果还要显示该包必需/推荐的包，则使用选项 --requires 和 --recommends：\nzypper info --requires MozillaFirefox 显示生命周期信息 要检查您的产品和所支持包的生命周期，请如下所示使用 zypper lifecycle 命令：\n$ zypper lifecycleProduct end of supportCodestream: SUSE Linux Enterprise Server 15 2028-04-23 SUSE Linux Enterprise Server 15 n/a*Module end of supportBasesystem Module 2021-07-31No packages with end of support different from product.*) See https://www.suse.com/lifecycle for latest information 配置 Zypper Zypper 现在随附配置文件，允许您永久更改 Zypper 的行为（系统范围或用户特定）。要进行系统范围更改，请编辑 /etc/zypp/zypper.conf。要进行用户特定的更改，请编辑 ~/.zypper.conf。如果 ~/.zypper.conf 尚不存在，您可以使用 /etc/zypp/zypper.conf 作为模板：将其复制到 ~/.zypper.conf 并根据您的喜好进行调整。请参见文件中的注释，获取有关可用选项的帮助。\n查错 如果您在访问配置的储存库中的包时遇到问题（例如，尽管您知道某个包在某个储存库中，但 Zypper 找不到该包），刷新储存库或许可以解决问题：\nsudo zypper refresh 如果不起作用，则尝试\nsudo zypper refresh -fdb 这会强制完全刷新和重构建数据库，包括强制下载原始元数据。\nBtrfs 文件系统上的 Zypper 回滚功能 如果根分区上使用的是 Btrfs 文件系统，且系统中安装了 snapper，当 Zypper 提交对文件系统所做的更改以创建相应的文件系统快照时，会自动调用 snapper。这些快照可用于还原 Zypper 进行的任何更改。\nRPM RPM（RPM 程序包管理器）用于管理软件包。其主要程命令为 rpm 和 rpmbuild。用户、系统管理员和包构建人员可以查询强大的 RPM 数据库以获得有关已安装软件的详细信息。\nrpm 有五种模式：安装、卸装（或更新）软件包、重构建 RPM 数据库、查询 RPM 库或独立 RPM 存档、对包执行完整性检查以及对包签名。rpmbuild 可用于从原始源构建可安装的包。\n用特殊的二进制格式对可安装 RPM 存档进行打包。这些存档由要安装的程序文件和某些元信息组成，这些元信息供 rpm 在安装过程中配置软件包使用或者储存在 RPM 数据库中进行存档。RPM 存档通常具有扩展名 .rpm。\n对于一些包，软件开发所需的组件（库、报头、包含文件等）已纳入独立的包中。只有当您要自己编译软件时才需要这些开发包（例如最新的 GNOME 包）。可以通过扩展名 -devel 确定这些开发包，例如包 alsa-devel 和 gimp-devel。\n校验包真实性 RPM 包具有 GPG 签名。要校验 RPM 包的签名，请使用 rpm --checksig PACKAGE-1.2.3.rpm 命令确定该包是来自 SUSE 还是另一个可信机构。特别建议对来自因特网的更新包使用此命令。\n修复操作系统中的问题时，您可能需要将问题临时修复 (PTF) 安装到生产系统中。SUSE 提供的包已使用特殊的 PTF 密钥签名。要手动导入该密钥，请使用以下命令：\nsudo rpm --import \\/usr/share/doc/packages/suse-build-key/suse_ptf_key.asc 导入该密钥后，您可以在系统上安装 PTF 包。\n管理包：安装、更新和卸装 安装 RPM 存档的步骤通常十分简单，执行运行：rpm -i PACKAGE.rpm。使用此命令可以安装包，但前提是满足其依赖关系并且不与其他包冲突。如果出现错误消息，rpm 将请求那些需要安装的包以满足依赖关系要求。在后台，RPM 数据库确保不出现冲突 － 一个特定文件只能属于一个包。通过选择不同的选项，您可以强制 rpm 忽略这些默认设置，但这只供专家用户使用。否则，将影响系统的完整性并可能使系统无法更新。\n选项 -U 或 --upgrade 以及 -F 或 --freshen 可用于更新包（例如，rpm -F PACKAGE.rpm）。此命令将删除旧版本的文件并立即安装新文件。两个版本之间的差别是：-U 安装系统中以前不存在的包，而 -F 只更新以前安装的包。更新时，rpm 使用以下策略小心更新配置文件：\n 如果配置文件未被系统管理员更改，则 rpm 将安装适当文件的新版本。系统管理员无需执行任何操作。 如果配置文件在更新前曾被系统管理员更改，则 rpm 会以扩展名 .rpmorig 或 .rpmsave（备份文件）保存更改的文件，并安装新包中的版本。仅当原先安装的文件和较新的版本不同时，才执行此操作。如果是这种情况，则将备份文件（.rpmorig 或 .rpmsave）与新安装的文件进行比较，并在新文件中再次进行更改。之后，请删除所有 .rpmorig 和 .rpmsave 文件，以免以后的更新出现问题。 如果配置文件已存在并且 .spec 文件中指定了 noreplace 标签，则出现 .rpmnew 文件。  更新后，在使用 .rpmsave 和 .rpmnew 文件进行比较后应将它们删除，从而防止它们阻碍以后的更新。如果 RPM 数据库以前未能识别文件，则将为其指派扩展名 .rpmorig。 否则，将使用 .rpmsave。换句话说，.rpmorig 是从异系统格式更新为 RPM 的结果。而 .rpmsave 是从较早的 RPM 更新为较新的 RPM 的结果。.rpmnew 不提供任何有关系统管理员是否对配置文件进行过任何更改的信息。/var/adm/rpmconfigcheck 中提供这些文件的列表。不覆盖某些配置文件（如 /etc/httpd/httpd.conf）以允许继续进行操作。\n-U 开关的作用并不完全等同于使用 -e 选项进行卸载以及使用 -i 选项进行安装，它还有其他作用。只要可能，就可以使用 -U。\n要去除包，请输入 rpm -e PACKAGE。仅当不存在未解决的依赖项问题时，此命令才会删除包。例如，只要有其他程序需要 Tcl/Tk，理论上就不能删除它。即使是在这种情况下，RPM 也会向数据库寻求帮助。如果出于任何原因无法进行此删除操作（即使不存在其他依赖项），则最好使用选项 --rebuilddb 重构建 RPM 数据库。\n增量 RPM 包 增量 RPM 包包含旧版本和新版本的 RPM 包之间的差别。在旧 RPM 上应用增量 RPM 将得到全新的 RPM。不需要旧 RPM 的副本，因为增量 RPM 也可以与已安装的 RPM 一起工作。增量 RPM 包的大小甚至比增补程序 RPM 小，这有利于通过因特网传送更新包。缺点是，涉及增量 RPM 的更新操作与使用纯粹 RPM 或增补程序 RPM 进行更新的情况相比，占用的 CPU 周期要长得多。\nmakedeltarpm 和 applydelta 二进制文件是增量 RPM 套件（包 deltarpm）的一部分，可帮助您创建和应用增量 RPM 包。使用以下命令可以创建名为 new.delta.rpm 的增量 RPM。以下命令假设 old.rpm 和 new.rpm 是存在的：\nsudo makedeltarpm old.rpm new.rpm new.delta.rpm 如果旧包已经安装，则使用 applydeltarpm 可以从文件系统重新构建新的 RPM：\nsudo applydeltarpm new.delta.rpm new.rpm 如果不访问文件系统而从旧 RPM 得到它，请使用 -r 选项：\nsudo applydeltarpm -r old.rpm new.delta.rpm new.rpm RPM 查询 带 -q 选项的 rpm 将启动查询，如此用户便可查看 RPM 存档（通过添加选项 -p）并查询已安装包的 RPM 数据库。可以使用多个开关指定所需信息的类型。\n   选项 含义     -i 包信息   -l 文件列表   -f FILE 查询包含文件 FILE 的包（必须使用 FILE 指定完整路径）   -s 带有状态信息的文件列表（间接指定 -l）   -d 仅列出文档文件（间接指定 -l）   -c 仅列出配置文件（间接指定 -l）   --dump 带有完整详细信息的文件列表（将用于 -l、-c 或 -d）   --provides 列出包中可被另一个包通过 --requires 请求的功能   --requires, -R 包需要的功能   --scripts 安装脚本（预安装、后安装、卸载）    例如，命令 rpm -q -i wget 显示\nName : wgetVersion : 1.14Release : 17.1Architecture: x86_64Install Date: Mon 30 Jan 2017 14:01:29 CETGroup : Productivity/Networking/Web/UtilitiesSize : 2046483License : GPL-3.0+Signature : RSA/SHA256, Thu 08 Dec 2016 07:48:44 CET, Key ID 70af9e8139db7c82Source RPM : wget-1.14-17.1.src.rpmBuild Date : Thu 08 Dec 2016 07:48:34 CETBuild Host : sheep09Relocations : (not relocatable)Packager : https://www.suse.com/Vendor : SUSE LLC URL : http://www.gnu.org/software/wget/Summary : A Tool for Mirroring FTP and HTTP ServersDescription :Wget enables you to retrieve WWW documents or FTP files from a server.This can be done in script files or via the command line.Distribution: SUSE Linux Enterprise 12 只有当您指定带有完整路径的完整文件名时，选项 -f 才起作用。根据需要提供任意多个文件名。例如：\nrpm -q -f /bin/rpm /usr/bin/wgetrpm-4.11.2-15.1.x86_64wget-1.14-17.1.x86_64 如果只知道部分文件名，则可以使用外壳脚本。当运行所显示的脚本时，将部分文件名以参数的形式传递给脚本。\n#! /bin/shfor i in $(rpm -q -a -l | grep $1); do echo \"\\\"$i\\\" is in package:\" rpm -q -f $i echo \"\"done rpm -q --changelog PACKAGE 命令会按日期排序显示有关特定包的详细更改信息列表。\n借助已安装的 RPM 数据库，可以进行校验检查。使用 -V 或 --verify 启动这些检查。使用此选项，rpm 显示安装后已被更改的包中的所有文件。rpm 使用 8 个字符符号给出有关以下更改的一些提示：\n   符号 含义     5 MD5 校验和   S 文件大小   L 符号链接   T 修改时间   D 主要和次要设备编号   U 拥有者   G 组   M 方式（权限和文件类型）    对于配置文件，将输出字母 c。例如，对于 /etc/wgetrc（wget 包）的更改：\nrpm -V wgetS.5....T c /etc/wgetrc RPM 数据库的文件被放置在 /var/lib/rpm 中。如果分区 /usr 的大小为 1 GB，则此数据库可能会占用将近 30 MB，特别是在完全更新之后。如果数据库比预期大得多，则最好使用选项 --rebuilddb 重构建数据库。在执行此操作之前，制作旧数据库的备份。cron 脚本 cron.daily 每天制作数据库的副本（用 gzip 打包）并将这些副本储存在 /var/adm/backup/rpmdb 中。副本的数目是由 /etc/sysconfig/backup 中的变量 MAX_RPMDB_BACKUPS（默认值为 5）控制的。对于 1 GB 的 /usr，单个备份的大小大约为 1 MB。\n安装和编译源包 所有源包都带有 .src.rpm 扩展名（源 RPM）。\n源包可以从安装媒体复制到硬盘并使用 YaST 解压缩。但是，在包管理器中它们不会被标记为已安装 ([i])。这是因为源包不是在 RPM 数据库中输入的。只有已安装的操作系统软件列在 RPM 数据库中。安装源包时，只将源代码添加到系统中。\n以下目录必须可用于 /usr/src/packages 中的 rpm 和 rpmbuild（除非在诸如 /etc/rpmrc 这样的文件中指定自定义设置）：\n  SOURCES\n代表原始源（.tar.bz2 或 .tar.gz 文件等）和特定于发布版本的调整（多为 .diff 或 .patch 文件）\n  SPECS\n代表 .spec 文件，类似于元 Makefile，该文件控制构建进程\n  BUILD\n在此目录中解压缩、增补和编译所有源\n  RPMS\n储存完整的二进制包的位置\n  SRPMS\n这里是源 RPM\n  使用 YaST 安装源包时，将在 /usr/src/packages 中安装所有需要的组件：源和调整在 SOURCES 中，相关的 .spec 文件在 SPECS 中。\n警告：不要对系统组件（glibc、rpm 等）进行试验，因为这样做会影响系统的稳定性。\n下面的示例使用 wget.src.rpm 包。安装源包后，应具有类似以下列表中的文件：\n/usr/src/packages/SOURCES/wget-1.11.4.tar.bz2/usr/src/packages/SOURCES/wgetrc.patch/usr/src/packages/SPECS/wget.spec rpmbuild -bX /usr/src/packages/SPECS/wget.spec 会启动编译。X 是通配符，代表构建进程的不同阶段。以下简要描述：\n  -bp\n在 /usr/src/packages/BUILD 中准备源：解压和打增补程序。\n  -bc\n执行与 -bp 相同的操作，但还进行编译。\n  -bi\n执行与 -bp 相同的操作，但还安装生成的软件。注意：如果包不支持 BuildRoot 功能，则可能会重写配置文件。\n  -bb\n执行与 -bi 相同的操作，但还创建二进制包。如果编译成功，二进制包应该在 /usr/src/packages/RPMS 中。\n  -ba\n执行与 -bb 相同的操作，但还创建源 RPM。如果编译成功，二进制包应该在 /usr/src/packages/SRPMS 中。\n  --short-circuit\n跳过某些步骤。\n  现在可以使用 rpm -i 或最好使用 rpm -U 来安装创建的二进制 RPM。使用 rpm 进行安装使它显示在 RPM 数据库中。\n使用 build 编译 RPM 包 许多包存在的风险是构建进程中会将许多不需要的文件添加到正在运行的系统中。为防止发生这种情况，请使用 build，它将创建构建包的已定义环境。要建立这一 chroot 环境，build 脚本必须和完整的包树结构一起提供。可以通过 NFS 或从 DVD 使用硬盘上的此树。使用 build --rpms DIRECTORY 设置位置。与 rpm 不同，build 命令在源目录中查找 .spec 文件。要用系统中 /media/dvd 下装入的 DVD 构建 wget（如上例所示），请以 root 用户身份使用以下命令：\ncd /usr/src/packages/SOURCES/mv ../SPECS/wget.spec .build --rpms /media/dvd/suse/ wget.spec 随后，将在 /var/tmp/build-root 建立一个最小的环境。在此环境中构建包。完成后，生成的包位于 /var/tmp/build-root/usr/src/packages/RPMS 中。\nbuild 脚本提供多个其他选项。例如，使脚本优先选择您自己的 RPM、忽略构建环境的初始化或者将 rpm 命令限制在上述阶段之一。\n用于 RPM 存档和 RPM 数据库的工具 Midnight Commander (mc) 可以显示 RPM 存档的内容并复制部分内容。它将存档表示为虚拟文件系统，提供 Midnight Commander 所有常用的菜单选项。使用 F3 键显示 HEADER。使用光标键和 Enter 键查看存档结构。使用 F5 键复制部分存档。\n拥有全部功能的包管理器将作为 YaST 模块提供。\nFirewall-cmd Firewall-cmd 是 Firewalld 的命令行工具。\nfirewall-cmd(firewalld command line client) 是 firewalld 的主要命令行工具。它可以用来获取 firewalld 的状态信息，获取运行时和永久环境的防火墙配置，也可以用来修改这些配置。根据所选择的策略，你需要通过 Root 认证才能访问或更改 firewalld 的配置。它只有在 firewalld 运行的情况下才能使用。firewall-cmd 充当 nftables/iptables 的前端。\n该文主要描述 firewall-cmd 的简易使用方法，更多内容详见：Firewalld Documentation\n准备工作 openSUSE 已经默认安装并激活了 firewalld ，但你可以使用下列方法安装 firewalld ：\n$ sudo zypper ref $ sudo zypper update $ sudo zypper install firewalld Firewalld 的基本概念 区域（zone） firewalld 将所有的网络数据流量划分为多个区域，再根据数据包的源IP地址或传入网络接口等条件，将数据流量转入相应区域的防火墙规则中。\n你可以通过运行以下 ls 命令查看所有的区域：\n$ ls -l /usr/lib/firewalld/zones/ 使用 cat 指令查阅某个区域的详细内容\n$ cat /usr/lib/firewalld/zones/*.xml * 的可以替换成：\n block：拒绝所有传入的网络连接。只有从系统内部发起的网络连接才可能有效； dmz：隔离区域也称为非军事化区域 (Demilitarized zone) ，为您的局域网提供有限的访问权限，并且只允许选定的传入端口； drop：终止所有传入链接，只允许传出的链接； external：对路由器类型的连接很有用。你需要局域网和广域网的接口来进行伪装（NAT）才能正常工作。 home：适用于家庭电脑，如局域网内的笔记本电脑和台式机，您可以信任其他电脑。只允许选定的 TCP/IP 端口； internal：用于内部网络，当你几乎信任局域网内的其他服务器或计算机时； public（系统默认值）：适用于始终处于公共区域的云服务器或托管在您处的服务器。您不信任网络上的任何其他计算机和服务器。您只允许使用所需的端口和服务； trusted：允许任何的网络链接； work：适用于您信任您的同事和其他服务器的工作场所。  查看所有区域：\n$ sudo firewall-cmd --get-zones 查看默认区域：\n$ sudo firewall-cmd --get-default-zone #### OR $ sudo grep -i DefaultZone /etc/firewalld/firewalld.conf openSUSE 默认的区域是 public ，默认启用的服务是 ssh 和 dhcpv6-client 。 查看网络接口名称：\n$ ip link show 当 NetworkManager 添加新的接口连接（如 eth0 或 ens3）时，它们将被连接到默认的区域。通过运行以下命令进行验证：\n$ firewall-cmd --get-active-zones 服务（services） 服务是一个包含了本地端口、协议、源端口、目的地和防火墙帮助模块 (firewall helper modules) 的列表。\n查询与 public 相关的防火墙规则或服务：\n$ sudo firewall-cmd --list-all --zone=public public (active) target: default icmp-block-inversion: no interfaces: wlan0 sources: services: dhcpv6-client ports: protocols: masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: 在该查询结果中，默认区域是 public ，允许的服务是 dhcpv6-client 。假设你需要删除 dhcpv6-client ，那么你应该运行如下指令：\n$ sudo firewall-cmd --remove-service=dhcpv6-client --permanent --zone=public $ sudo firewall-cmd --reload #### 重载防火墙 $ sudo firewall-cmd --list-services #### 列出所有服务 运行下列指令查询特定区域允许的服务列表：\n$ sudo firewall-cmd --list-services #### 查询当前区域允许的服务 $ sudo firewall-cmd --list-services --zone=* #### 将 * 替换成你所需要查询服务的区域 $ sudo firewall-cmd --list-all-zones #### 查询全部区域的服务或防火墙规则 启动、检查和关闭 firewalld 服务 启动（Start）并激活（Enable）防火墙：\n$ sudo systemctl start firewalld $ sudo systemctl enable firewalld 检查防火墙服务状态：\n$ sudo systemctl status firewalld 检查防火墙状态：\n$ sudo firewall-cmd --state 检查 firewalld 是否开机启动：\n$ sudo systemctl is-enabled firewalld 更改规则后，重启防火墙让规则生效：\n$ sudo firewall-cmd --reload 暂停（Stop）和关闭（Disable）防火墙：\n$ sudo systemctl stop firewalld $ sudo systemctl disable firewalld 运行时和永久规则 运行时的 firewalld 配置更改是临时性的，当你重新启动 openSUSE 或 firewalld 时，它们就会消失。永久规则则不受影响。 例如\n$ sudo firewall-cmd --zone=public --add-service=kdeconnect #### 运行时规则 $ sudo firewall-cmd --zone=public --add-service=kdeconnect --permanent #### 永久规则 添加永久性规则\n$ sudo firewall-cmd --zone=* --add-service=** --permanent #### 将 * 替换成区域，将 ** 替换成服务名称，如 https. $ sudo firewall-cmd --reload #### 重启防火墙让规则生效。 确认规则是否生效：\n$ sudo firewall-cmd --list-services $ sudo firewall-cmd --list-services --permanent 查询 firewalld 支持的服务列表\n$ sudo firewall-cmd --get-services $ sudo firewall-cmd --get-services | grep kdeconnect $ ls -l /usr/lib/firewalld/services/ $ cat /usr/lib/firewalld/services/kdeconnect.xml Firewall-cmd 规则集样例 添加 DNS 服务（TCP/UDP 端口：53，区域为 public，永久性规则）：\n$ sudo firewall-cmd --zone=public --add-service=dns --permanent 删除某个服务（例如 VNC 服务器服务，TCP 端口：5900-5903，区域为 public，永久性规则）：\n$ sudo firewall-cmd --zone=public --remove-service=vnc-server --permanent 开放特定的端口（TCP/UDP），例如开放 TCP/UDP 端口：55527：\n$ sudo firewall-cmd --zone=public --add-port=55527/tcp --permanent $ sudo firewall-cmd --zone=public --add-port=55527/udp --permanent 查看已开放的端口：\n$ sudo firewall-cmd --zone=public --list-ports $ sudo firewall-cmd --zone=public --list-ports --permanent 拒绝/禁用特定端口：\n$ sudo firewall-cmd --zone=public --remove-port=23/tcp --permanent 注意，当 firewalld 的区域是 public 的时候，绝大多数端口是默认禁用的。\n编写端口转发 Firewalld 规则 将同一服务器上的 TCP 端口 443 转发到 8080：\n$ sudo firewall-cmd --zone=public --add-forward-port=port=80:proto=tcp:toport=8080 --permanent 要删除上述端口转发，请运行下列指令：\n$ sudo firewall-cmd --zone=public --remove-forward-port=port=80:proto=tcp:toport=8080 如果您需要将流量 (端口 443) 转发到 192.168.2.42 端口 443 的 lxd 服务器/容器，请开启伪装功能：\n$ sudo firewall-cmd --zone=public --add-masquerade $ sudo firewall-cmd --zone=public --add-forward-port=port=443:proto=tcp:toport=443:toaddr=192.168.2.42 --permanent 要删除上述伪装规则，请运行下列指令：\n$ sudo firewall-cmd --zone=public --remove-masquerade $ sudo firewall-cmd --zone=public --remove-forward-port=port=443:proto=tcp:toport=443:toaddr=192.168.2.42 --permanent 列出规则：\n$ sudo firewall-cmd --zone=public --list-all --permanent Rich rule 示例 假设你想只允许从 192.168.0.0 子网的 IP 地址访问 KDE Connect 的端口，运行下列指令：\n$ sudo firewall-cmd --permanent --zone=public --add-rich-rule='rule family=\"ipv4\" source address=\"192.168.0.0/24\" port protocol=\"tcp\" port=\"1714-1764\" accept' $ sudo firewall-cmd --permanent --zone=public --add-rich-rule='rule family=\"ipv4\" source address=\"192.168.0.0/24\" port protocol=\"udp\" port=\"1714-1764\" accept' 要验证新规则，请运行下列指令：\n$ sudo firewall-cmd --list-rich-rules --permanent 您可以通过以下方式删除富规则：\n$ sudo firewall-cmd --permanent --zone=public --remove-rich-rule 'rule family=\"ipv4\" source address=\"192.168.0.0/24\" port protocol=\"udp\" port=\"1714-1764\" accept' 其他 如果你更青睐于GUI，那么你可以考虑使用Yast自带的防火墙，或者使用 firewall-config:\n$ sudo zypper install firewall-config openSUSE Tips 为什么选择 openSUSE Free and Open Source 确定你心目中的贡献者们是什么样的，从而聚拢到这样的人。\n狭义的自由开源概念 狭义的自由开源概念是：自由地开放源代码。即：软件作者把源代码公开发布，给予你修改并二次发布的权利。就这样，没别的了。\n测试、调试、故障受理与修复、接受新功能请求、接受代码合并请求、接受别人的帮助、用户社区建立、互动、整个自由开源生态的维护，统统都是完全没有，谁愿意干谁干，跟我没有关系。或者这么说：“写完拉倒”，哪怕洪水滔天。这从 GPL 许可证的“无保声明”中可以看出端倪。\n广义的自由开源概念 实际上如果你看过操作系统革命你就会明白：开放源代码其实并不是这一运动想要实现的全部，它的最终目的是普及自由精神，建立自由社区。\n目前这一精神在自由开源软件上的表现有：\n 源代码开源。 来自软件所有者的开发门槛为零。 不重新发明轮子。如果有已有实现并可以扩展，那么扩展它。 文档开源。使用维基等。 组织并形成用户互助社区。积极帮助用户（在不影响开发的前提下）。同时在开发上尽量面向用户，把用户的反应纳入到重大修改的考量因素当中去，积极采纳合理意见。 积极回应故障汇报并提供修复。 积极回应新功能请求。能做的做，不能做的解释原因寻求理解。 形成良性的贡献者添加内容和用户反馈渠道。 重视并维护由类似软件共同组成的生态的和谐稳定。（简单说就是：我开发 KDE 是因为 GNOME 满足不了我的需求，而不是为了搞死 GNOME。）  现在您可以拿来同狭义的自由开源概念做比较，发现如果说狭义的自由开源概念只是指某种行为，那么广义的自由开源概念已经是指一种氛围了。\nopenSUSE 秉持的自由开源概念 openSUSE 项目是完全做到“广义的自由开源概念”的社区。\n同时我们一直持有的相关理念还有：\n 积极的与上游合作。不“内化”补丁或修改，除非上游出于种种原因不收。 积极的为整个生态着想。 不搞歧视或二等公民。 尊重许可证、版权甚至是专利  如果你认同这些，那么您适合这个社区。\n用户字体 Dolphin 下单击安装字体目录为\n/home/用户名/.fonts 如果下载好的字体文件无法直接点开安装（例如 *.ttc），或者字体太多，不想一个一个地安装，可以将字体文件全部放到字体文件夹中。然后运行：\nfc-cache -fv 装入 NTFS 分区   安装 ntfs-3g。\nsudo zypper in ntfs-3g   创建一个要充当安装点的目录，如 ~/mounts/windows。\nmkdir ~/mounts/windows   确定所需的 Windows 分区。\nsudo fdisk -l   以读写模式装入分区。使用相应的 Windows 分区替换占位符 DEVICE：\nntfs-3g /dev/DEVICE MOUNT POINT 要在只读模式下使用 Windows 分区，请追加 -o ro\nntfs-3g /dev/DEVICE MOUNT POINT -o ro ntfs-3g 命令使用当前用户 (UID) 和组 (GID) 装入给定设备。如果要为其他用户设置写权限，请使用命令 id  USER 获取 UID 和 GID 值的输出。设置方式：\nid usernamentfs-3g /dev/DEVICE MOUNT POINT -o uid=1000,gid=100   要卸载资源，请运行 fusermount -u 安装点。\n  任务栏透明化 Go to System Settings | Window Management | Window Rules. Press New… button. Give some description to the new rule, Dock Transparency, for example. Then select only Dock (panel) in “Window type” field.\n之后在 Appearance \u0026 Fixes 中调整 opacity。\n使用 24 小时制 点击桌面右侧的时间 = 点击弹出面板的左上角 Config Digital Clock = Appearance 的 Time display 设置为 24 小时（但是窗口管理器还是12小时制）。\n主题 不是我喜欢黑暗主题，而是热门的好看的主题都是黑暗主题。所以尝试如下：\n 全局黑暗主题为 Sweet chrome 黑暗主题  系统设置 Theme 使用 GTK+，可以使标题栏，设置菜单栏为黑暗，但是网页、设置页为白色。 Chrome 黑暗模式：在网址栏输入 chrome://flags/#enable-force-dark，启用。可以使设置页面黑暗，网页黑暗，但是进入 segmentfault，你会发现 segment 不见了（即表现不好）。 安装 dark reader 插件。可以使网页黑暗，比 chrome 自带表现要好。但是打开新页面时，还是有短暂的白色。   Firefox 黑暗主题  设置页的颜色会与系统一致，也就是与 chrome 相反。 firefox theme 会改变标题栏、设置菜单栏颜色。    实际上你会发现，无法达到一致的黑暗，反而使得眼睛不舒服，所以我放弃了黑暗主题。\n亮色混合主题：\n Global Theme 为 openSUSE Plasma 为 Edna-light Window Decorations 为 Edna-light Font 为 Source Hans Sans CN 和 Jet Brains Moon Icon 为 Papirus SSDM Theme 为 chili for plasma kconsole 主题为 sweet 开始改为 application dashboard  实际你会发现，混合主题没有一个单独主题搭配的那么协调。\n窗体内容亮色，其他部分为黑暗，即标准主题:\n 全局主题 Sweet Colors 为 Breeze，使得 window 内容为亮色 Window Decorations 为 sweet-dark-transparent，设置标题栏 Icon 为 Papirus SSDM Theme 为 sweet fcitx 为 dartmouth。  感觉可以。\nDesktop Effects：\n Magic Lamp 400ms Wobbly Windows  不如不要。\n常用软件 Remove a file using inode number 用 7zip 解压出一个乱码文件，删除不了，因此考虑用 inode 删除。\n  Use -i flag to get the inode number of any file (First column is your inode)\n$ ls -li   In find command, use -inum flag with inode number and ls at the end to list a file\n$ find . -inum -ls   In find command, use -inum flag with inode number and pass the rm using exec arugment to delete a file\n$ find . -inum -exec rm {} \\;   unzip openSUSE 中文论坛讨论：大家都用什么 gui 压缩软件？\n问题描述 ZIP文件在不同平台压缩时，对于文件名会有不同的编码，主要分为下面两类：\n Windows平台，默认的中文编码为GBK，因此压缩后的文件名编码格式为GBK。 Linux/MacOS平台，默认的中文编码为UTF8，因此压缩后的文件名编码格式为UTF8。  这样就存在一个问题，在Windows上压缩的文件放到MacOS上解压，或者将Windows上压缩的文件上传到服务器上解压后处理，里面的文件名都会出现乱码情况。出现这个问题，主要是因为ZIP标准公布于1989年1月，那时还没有Unicode标准。在当前ZIP标准中，Info-ZIP Unicode Path Extra Field(0x7075)会记录UTF8的编码名。\n但是，这个字段不是强制字段，允许为空，Linux/Mac OS在压缩时都不会记录这个标识，因此，无法识别出zip包采用的编码方式，导致解压时会出现乱码。\n解决 系统还未编译安装Unzip 更改源码解决乱码\n调试发现问题出现在 MultiByteToWideChar 方法里，如 MultiByteToWideChar(CP_ACP,0,fn,-1,tfn,MAX_PATH); 到这里时 fn 中的 name 属性值还是正常的，在这个方法内部执行完 tfn 就乱了。\n解决方法：\n打开 unzip.cpp 源文件，找到函数\nZRESULT TUnzip::Get(int index,ZIPENTRY *ze) { // ......  // ...... } 这个函数里有\n#ifdef UNICODE  MultiByteToWideChar(CP_UTF8,0,fn,-1,tfn,MAX_PATH); #else  strcpy(tfn,fn); #endif 把 CP_UTF8 改为 CP_ACP（CP_ACP 指示要使用当前设置的 API 默认 Windows ANSI 代码页）\n重新编译后\n这样就解决了解压中文文件名称乱码的问题\n编译时解决源码问题（无需更改源码）\n上面的情况，我们我观察到unzip源代码这段开始的地方有判断\n#ifndef Ext_ASCII_TO_Native 这样问题似乎更简单了，不用改源代码，只需在 make 时定义 Ext_ASCII_TO_Native 即可，这样 Ext_ASCII_TO_Native 实际为一个空的宏，不进行任何转换操作。\n比如，使用下面的方法编译\n$ make -DExt_ASCII_TO_Native 或者在 bash 执行下面两行\n$ export LOCAL_UNZIP=-DExt_ASCII_TO_Native $ make unzip 解压缩含中文文件名 zip 包是出现乱码的问题解决！\n如果您的系统已经安装了 unzip unzip 行命令解压，指定字符集\n通过 unzip 行命令解压，指定字符集\n$ unzip -O CP936 xxx.zip # 用GBK, GB18030 也可以 有的发行版并没有如 Ubuntu 那样安装了 unzip-iconv 补丁，因此需要安装该补丁以启用“指定字符集”功能。\n注意：unzip-natspec 是较新的方案，gbkunzip 是依云的一个Python脚本解决方案。\n在环境变量中，指定 unzip 参数\n在环境变量中，指定 unzip 参数，总是以指定的字符集显示和解压文件 /etc/environment 中加入 2 行\nUNZIP=\"-O CP936\" ZIPINFO=\"-O CP936\" 利用 python 来处理\n复制以下内容（Python）保存为 myuzip.py 文件脚本，并修改运行权限为可运行（chmod +x uzip）\n#!/usr/bin/env python # -*- coding: utf-8 -*- # uzip.py import os import sys import zipfile print \"Processing File \" + sys.argv[1] file=zipfile.ZipFile(sys.argv[1],\"r\"); for name in file.namelist(): utf8name=name.decode('gbk') print \"Extracting \" + utf8name pathname = os.path.dirname(utf8name) if not os.path.exists(pathname) and pathname!= \"\": os.makedirs(pathname) data = file.read(name) if not os.path.exists(utf8name): fo = open(utf8name, \"w\") fo.write(data) fo.close file.close() 这样以后我们解压缩时只需要运行此文件即可\n$ ./myuzip.py xxxx.zip 乱码问题 Unicode 中文乱码速查表\n   xxxxxx 示例 特点 产生原因     古文码 鐢辨湀瑕佸ソ濂藉涔犲ぉ澶╁悜涓? 大都为不认识的古文，并加杂日韩文 以 GBK 方式读取 UTF-8 编码的中文   口字码 ����Ҫ�¨2�ѧϰ������ 大部分字符为小方块 以 UTF-8 的方式读取 GBK 编码的中文   符号码 ç”±æœˆè|�å￥½å￥½å-|ä1 å¤©å¤©å�‘ä¸Š 大部分字符为各种符号 以 ISO8859-1 方式读取 UTF-8 编码的中文   拼音码 óéÔÂòaoÃoÃÑ§Ï°ììììÏòéÏ 大部分字符为头顶带有各种类似声调符号的字母 以 ISO8859-1 方式读取 GBK 编码的中文   问句码 由月要好好学习天天向?? 字符串长度为偶数时正确，长度为奇数时最后的字符变为问号 以 GBK 方式读取 UTF-8 编码的中文，然后又用 UTF-8 的格式再次读取   锟拷码 锟斤拷锟斤拷要锟矫猴拷学习锟斤拷锟斤拷锟斤拷 全中文字符，且大部分字符为“锟斤拷”这几个字符 以 UTF-8 方式读取 GBK 编码的中文，然后又用 GBK 的格式再次读取   烫烫烫 烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫 字符显示为“烫烫烫”这几个字符 VC Debug 模式下，栈内存未初始化   屯屯屯 屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯 字符显示为“屯屯屯”这几个字符 VC Debug 模式下，堆内存未初始化    避免乱码基本原则：使用 utf-8 代替 gbk/gb2312。\n文件名乱码 安装 convmv，使用 convmv 命令转换编码格式。示例：\n$ convmv -f GBK -t UTF-8 --notest --nosmart file -f 指定原始编码，-t 指定输出编码。使用 convmv --list 可查询所有支持的编码。 --notest 表示非测试而是要进行转码（如果不使用该参数只会打印出转换结果而不会实际转码），--smart 表示如果已经是 UTF-8 则忽略。\n文件内容乱码 使用 iconv 命令转换格式。示例：\n$ iconv -f GBK -t UTF-8 -o new-file origin-file -f 指定原始编码，-t 指定输出编码。使用 iconv -l 可查询所有支持的编码。-o 指定输出文件。\nzip 压缩包乱码 避免方法：非 utf8 编码环境下（一般 windows 下的中文环境即是）不使用 zip 进行压缩（建议使用 7z)。 解决方案：安装使用 unzip-iconv [package not found] 或者 unzip-natspec 取代原版的 unzip 来解压缩，示例：\n$ unzip -O gbk file.zip file.zip 是压缩文件，gbk 是该文件的编码格式，以 -O 指定（原版 unzip 无 -O 选项）。\nzypper autoremove zypper 提供了 subcommand 子命令的功能，可以将自定义脚本当作 zypper 命令来执行。所以可以编写这样一个脚本：\n$ sudo cp zypper-autoremove.sh /usr/lib/zypper/commands/zypper-autoremove $ sudo chmod u+x /usr/lib/zypper/commands/zypper-autoremove $ sudo zypper autoremove #!/bin/sh packages=$(zypper -tqn --no-refresh pa --unneeded |grep '^i |' |awk -F \"|\" '{print $3}') if [ \"$packages\" ]; then sudo zypper rm -u $packages else echo No unneeded package found. fi 命名为 zypper-autoremove，放在你的 $PATH 下或者 /usr/lib/zypper/commands 里面，就可以通过\n$ zypper autoremove 命令来实现清理无用包的功能了。\nntfs-3g 与 ntfs3 驱动 Linux Kernel 5.15 合并了 Paragon 提供的 NTFS3 内核驱动， 拥有更高的性能和更多的特性\n总结：内核驱动开销变低, 读取性能有所提升，写入性能大幅提升，不考虑硬盘速度的话，写入速度接近10x\nKDE Tips trash-cli rm -rf 文件会彻底消失掉。为了避免误操作,有人写了一个替代品 trash-cli ，从命令行里面删除的时候移动到回收站，也就是 trash:/\n不过 trash-cli 有点臃肿和重复，kde 的 kioclient5 可以做一样的事情\nkioclient5 move  trash:/ # 这里可以用文件通配符: 删除所有 .jpg 文件 kioclient5 move *.jpg trash:/ 可以在 .bashrc 里面加入这个命令来放心地删除文件\nfunction krm(){ kioclient5 move \"$@\" trash:/ } liberate Super Key 为了避免快捷键冲突，我给所有软件 (比如 Emacs) 添加自定义快捷键都会用 SuperKey（Microsoft 叫 WinKey，Appple 叫 CommandKey）来弄。这时候就需要禁用 SuperKey 启动开始菜单来防止误操作。\nkwriteconfig5 --file kwinrc --group ModifierOnlyShortcuts --key Meta \"\" # 重载配置 qdbus org.kde.KWin /KWin reconfigure kwriteconfig5 那条命令的实际作用是在~/.config/kwinrc 里面修改了这部分\n[ModifierOnlyShortcuts] Meta= 如果你想迁移你的 KDE 设置，可以把所用自定义的设置都用脚本来表示，比如说禁用键盘上的锁屏键\n# 修改 ~/.config/kglobalshortcutsrc 里面 [ksmserver] 中 Lock Session= 的值为 \",,Lock Session\" kwriteconfig5 --file kglobalshortcutsrc --group ksmserver --key \"Lock Session\" \",,Lock Session\" Custom Context Menu KDE 可以添加自定义的右键菜单，比如说我自用的通过 Inkscape 把 .svg 转换成 .eps（ LaTeX 插入 .eps 方便一些）\n把如下的内容丢进 ~/.local/share/kservices5/ServiceMenus/svg2eps.desktop 即可。\n[Desktop Entry] Type=Service ServiceTypes=KonqPopupMenu/Plugin MimeType=image/svg+xml Actions=svg2eps Icon=view-refresh [Desktop Action svg2eps] Name=convert svg to eps Icon=view-refresh Exec=inkscape -D \"%f\" --export-type=eps 唯一重点的一行是 Exec=。\n原始的命令是 inkscape -D  --export-type=eps，然后把 换成 %f, Dolphin 就会在从右键使用的时候自动传入目标文件。(大写的版本%F会传入一组文件)。\n具体的写法在 Freedesktop Desktop Entry Specification- The Exec key 里面。\nMimeType= 是匹配文件格式，可以用 file --mime-type -b  来获取，或者从 freedesktop/xdg-shared-mime-info 里面查\n你可能注意到，右键菜单里面的格式，用的和 launcher(开始菜单）用的是用样的格式 .desktop\n如果仔细考虑一下，他们本质上是没有区别的，只不过一个从 launcher 里面打开，另一个从右键呼出。不过通过右键打开的，可以获取一些文件和目录的信息。\n详细的教程 https://develop.kde.org/docs/extend/dolphin/service-menus/\n长命令通知 如果一个命令需要运行的特别特别久，可以在命令后面加上 \u0026\u0026 notify-send \"\n比如 ls \u0026\u0026 notify-send \"finished at $(date +%c)\"\n不过这个通知一会就会消失，可以在设置里面，把 low priority 的通知设置成 show in history\n这个同时还可以插入图片，想知道可以搜以下 KNotify/Knotifications 的 API…\nCommand Palette 自从某一个版本以后，用 KDE 框架写的软件都” 自动 “地获得了一个命令面板功能 Ctrl+Alt+i，正式的名称应该是 KCommandBar。\n这里有两个好玩的：\n  okular ” 自动 “地获得搜索最近打开文件的能力\n  Kate 可以更加方便地调用外部程序（类似于 Kakoune 那种几乎完全借助外部程序处理文档编辑的操作）。\n需要做的就是从菜单栏的 Tools - External Tools - Configure 里面添加新的外部程序，比如 google 搜索选定的文本。\n也可以这样操作来安装这个 google 搜索：\necho \"[General] actionName=externaltool_GoogleSearch arguments=https://www.google.com/search?q=%{Document:Selection:Text} executable=/usr/bin/xdg-open icon=plasma-search name=GoogleSearch output=Ignore reload=false save=None\"  ~/.config/kate/externaltools/googlesearch 然后这样搜索一段选定的文本了\n  openQA 大致的原理就是开一个虚拟机，然后模拟用户活动：https://openqa.opensuse.org\n而且测试的项目也很多，除了安装，重启，安装桌面环境之类常规的测试。还有一些很特别的，比如说从 GNOME 桌面启动 Firefox，然后在关于界面一定会在某个坐标出现 Firefox 的 logo。打开 Dophin 然后右键菜单，新建文件的地方一定可以有那个文本文件。\n另外还有两个项目也在使用来自 SUSE 的 openQA:\n Debian: https://openqa.debian.net https://wiki.debian.org/Outreachy/Round15/Projects/TestingDebianWithOpenQA Fedora https://openqa.stg.fedoraproject.org https://fedoraproject.org/wiki/OpenQA  SDB 支持资料库。\n Support Database (SDB) articles are written as solutions for technical problems with openSUSE.\n 给 pdf 电子书加目录 对许多人来说 pdf 格式的电子书最头疼的两件事：\n 每页都是没经过 OCR 处理过的图片 没有目录(ABBYY)  以下这个批量加目录的方法我用好久了，见过我这么操作过的都想学一下，这里详细地记录以下，也方便以后有人再问的时候 :)\n用到的软件是 pdftk pdftk-java / pdftk-java · GitLab 。linux 发行版一般都有这个这个软件可以直接安装。\npdftk 的用法就是：输出 (dump_data) pdf 的元信息 (data.txt)，编辑以后，重新倒入 (update_info) 到 pdf 文件里面\n主要是这两条命令:\npdftk [my.pdf] dump_data  [data.txt] pdftk [my.pdf] update_info [data.txt] output my2.pdf 在第一条命令输出的 data.txt 里面加入如下的内容，然后通过第二条命令就可以创建新的目录条目\nBookmarkBegin BookmarkTitle: name BookmarkLevel: level BookmarkPageNumber: page number 另外电子书的第一页通常是封面，紧接着的是其它的东西。但是书里面标注的页码的第一页往往后面的某页。\nPDF 支持把页码标注成其它的格式 (page_labels)，第一页标注成 cover，第二到第十页标注成罗马数字，然后从第十一页标注成 1,2,3,4,5,6…\n# 把第一页标注成名字为 cover 的非数字 (NoNumber) PageLabelBegin PageLabelNewIndex: 1 PageLabelStart: 1 PageLabelPrefix: cover PageLabelNumStyle: NoNumber # 从第二页 (PageLabelNewIndex) 开始标注成小写罗马数字 (LowercaseRomanNumerals) PageLabelBegin PageLabelNewIndex: 2 PageLabelStart: 1 # 从数字 1 开始数，如果这里变成 3 = 起始的罗马数字会是 iii PageLabelNumStyle: LowercaseRomanNumerals # 从 {true start page} 开始用普通的数字标注 PageLabelBegin PageLabelNewIndex: {true start page} PageLabelStart: 1 PageLabelNumStyle: DecimalArabicNumerals 对于一本书，这种手动添加的方法会很慢，下面是一个小脚本来半自动化。\n由于电子书 100% 可以搜索到这种格式的目录 编号 标题 页码。如果搜索不到，也可以直接从书里面复制。\n复制粘贴一下，调整成这种格式\n14 I: Reduction Semantics\t1 1 Semantics via Syntax\t5 2 Analyzing Syntactic Semantics\t13 3 The λ-Calculus\t23 4 ISWIM\t45 II: PLT Redex\t201 11 The Basics\t205 12 Variables and Meta-functions\t217 13 Layered Development\t227 14 Testing\t237 ...... 第一行是对于人类，而非 pdf 格式来说真正的第一页\n后面根据行首 tab 的数量来决定目录的层级\n每行后面的数字是页码\n然后用这个小脚本 toc-gen.py\n#!/usr/bin/env python3 # # Usage # toc-gen.py # def make_offset(off: int): if off  1: print(\"\"\"PageLabelBegin PageLabelNewIndex: 1 PageLabelStart: 1 PageLabelPrefix: cover PageLabelNumStyle: NoNumber\"\"\") if off  2: print(\"\"\"PageLabelBegin PageLabelNewIndex: 2 PageLabelStart: 1 PageLabelNumStyle: LowercaseRomanNumerals\"\"\") print(f\"\"\"PageLabelBegin PageLabelNewIndex: {off}PageLabelStart: 1 PageLabelNumStyle: DecimalArabicNumerals\"\"\") def make_bookmark(t: str, l: int, p: int): print(f\"\"\"BookmarkBegin BookmarkTitle: {t}BookmarkLevel: {l}BookmarkPageNumber: {p}\"\"\") if __name__ == '__main__': offset = int(input()) make_offset(offset) while True: try: line = input() if not line.strip(): break except EOFError: break title = \" \".join(line.split()[0:-1]) n_of_tabs = len(line) - len(line.lstrip()) page = int(line.split()[-1]) make_bookmark(t=title, l=n_of_tabs + 1, p=page + offset) 来获取这些内容，把这些内容粘贴到 [data.txt] 后面，然后再用 pdftk 的第二条命令\nPageLabelBegin PageLabelNewIndex: 1 PageLabelStart: 1 PageLabelPrefix: cover PageLabelNumStyle: NoNumber PageLabelBegin PageLabelNewIndex: 2 PageLabelStart: 1 PageLabelNumStyle: LowercaseRomanNumerals PageLabelBegin PageLabelNewIndex: 14 PageLabelStart: 1 PageLabelNumStyle: DecimalArabicNumerals BookmarkBegin BookmarkTitle: Reduction Semantics BookmarkLevel: 1 BookmarkPageNumber: 15 BookmarkBegin BookmarkTitle: Semantics via Syntax BookmarkLevel: 2 BookmarkPageNumber: 19 BookmarkBegin BookmarkTitle: Analyzing Syntactic Semantics BookmarkLevel: 2 BookmarkPageNumber: 27 BookmarkBegin BookmarkTitle: The λ-Calculus BookmarkLevel: 2 BookmarkPageNumber: 37 BookmarkBegin BookmarkTitle: ISWIM BookmarkLevel: 2 BookmarkPageNumber: 59 BookmarkBegin BookmarkTitle: An Abstract Syntax Machine BookmarkLevel: 2 BookmarkPageNumber: 79 BookmarkBegin BookmarkTitle: Abstract Register Machines BookmarkLevel: 2 BookmarkPageNumber: 103 BookmarkBegin BookmarkTitle: Tail Calls and More Space Savings BookmarkLevel: 2 BookmarkPageNumber: 121 BookmarkBegin BookmarkTitle: Control: Errors, Exceptions, and Continuations BookmarkLevel: 2 BookmarkPageNumber: 129 BookmarkBegin BookmarkTitle: State: Imperative Assignment .............. Bingo! 这下舒服了 :)\nKDE PIM 使用指北 openSUSE Questions 解决KDE下KDE Wallet重装系统后每次登陆需要输入密码 在每次重装或者配置桌面后kdewallet总是在登陆系统之后提示输入密码，虽然在输入密码后能够继续正常使用，但是每次登陆系统都需要输入一次密码还是很烦人的。\n出现的原因：\n在重新配置桌面或者重装系统之后KDE Wallet所需要的一些必备需要依赖组件未能找到，所以导致不能正确运行KDE Wallet，所以只要安装其所需的组件即可。而其所需的但是未能自动安装的依赖组件正是 pam_kwallet，kwallet-pam 与 GnuPG keys 不兼容，所以 KDE Wallet 必须使用 blowfish 加密方式。\n解决方案 ：\n安装缺失的组件\nsudo zypper in pam_kwallet 为了保险起见，查看个人目录下是否存在~/.kde4/share/apps/kwallet文件夹，如果存在则将其删除或者重命名以避免出现冲突，并且还需要确定使用的钱包名为kdewallet并且密码为当前用户的密码。\n如此便可完全正常使用KDE Wallet\n解决方案参考arch wiki的KDE Wallet小节中。\nCould not open a connection to your authentication agent 执行ssh-add时出现\nssh-agent bash 无法读取 exfat 、 .7z 和 .rar $ sudo zypper in fuse-exfat exfat-utils $ sudo zypper in p7zip-full $ sudo zypper in unrar vscode keychain issues for KDE $ sudo zypper in gnome-keyring 提示添加密码的时候为空就行了，否则每次启动 vscode 都需要输入一次密码。\nTypora 字体问题 如果 Typora 字体如上面那样，每个字大小不一样：   整个应用的语言设置为英语\n  在 conf.user.json 指定字体\n{ \"defaultFontFamily\": { \"standard\": \"Source Han Sans CN\", //String - Defaults to \"Times New Roman\".  \"serif\": \"Source Han Sans CN\", // String - Defaults to \"Times New Roman\".  \"sansSerif\": \"Source Han Sans CN\", // String - Defaults to \"Arial\".  \"monospace\": \"JetBrains Mono\" // String - Defaults to \"Courier New\".  } }   flatpak run: Invalid MIT-MAGIC-COOKIE-1 key rm .Xauthority nothing provides ‘libuuid’ needed by the to be installed xmind BearChild, [7/21/22 10:14 PM] 强行装即可 libuuid 的依赖对于大多数 opensuse 安装来讲，都可以忽略，打包的问题\nHigh cpu usage of Goldendict full-text search 在 openSUSE 中是默认开启的，Disable full-text search: Preferences = Full-text search\nDisabling mouse scroll-wheel switching between virtual desktops Right-click the desktop - Configure Desktop and Wallpaper… - Mouse actions - “vertical scrollwheel: Standard Menu”\n",
  "wordCount" : "42912",
  "inLanguage": "en",
  "image":"https://sakamotokurome.github.io/Distributions/OpenSUSE_Logo.svg","datePublished": "2022-03-09T11:42:26+08:00",
  "dateModified": "2022-03-09T11:42:26+08:00",
  "author":{
    "@type": "Person",
    "name": "Sakamoto Kurome"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://sakamotokurome.github.io/posts/opensuse/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Sakamoto Kurome",
    "logo": {
      "@type": "ImageObject",
      "url": "https://sakamotokurome.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://sakamotokurome.github.io/" accesskey="h" title="Sakamoto Kurome (Alt + H)">Sakamoto Kurome</a>
            <span class="logo-switches">
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://sakamotokurome.github.io/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://sakamotokurome.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://sakamotokurome.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      OpenSUSE
    </h1>
    <div class="post-meta"><span title='2022-03-09 11:42:26 +0800 CST'>March 9, 2022</span>&nbsp;·&nbsp;86 min&nbsp;·&nbsp;Sakamoto Kurome

</div>
  </header> 
<figure class="entry-cover"><img loading="lazy" src="https://sakamotokurome.github.io/Distributions/OpenSUSE_Logo.svg" alt="openSUSE Logo">
        <p>openSUSE</p>
</figure><div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#opensuse-desktop" aria-label="openSUSE Desktop">openSUSE Desktop</a><ul>
                        
                <li>
                    <a href="#dvd-%e6%96%b9%e5%bc%8f%e5%ae%89%e8%a3%85httpszhopensuseorgsdbdvd_e5ae89e8a385e696b9e5bc8f" aria-label="DVD 方式安装"><a href="https://zh.opensuse.org/SDB:DVD_%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F">DVD 方式安装</a></a></li>
                <li>
                    <a href="#%e5%9b%bd%e5%86%85%e9%95%9c%e5%83%8f%e6%ba%90httpsforumsuseorgcntopensuse1759" aria-label="国内镜像源"><a href="https://forum.suse.org.cn/t/opensuse/1759">国内镜像源</a></a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e7%ad%94" aria-label="解答">解答</a></li>
                <li>
                    <a href="#%e6%9b%b4%e6%8d%a2httpszhopensuseorgsdbe5bfabe9809fe9858de7bdaee68c87e58d97e69bb4e68da2e887b3e59bbde58685e9959ce5838fe6ba90" aria-label="更换"><a href="https://zh.opensuse.org/SDB:%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97#.E6.9B.B4.E6.8D.A2.E8.87.B3.E5.9B.BD.E5.86.85.E9.95.9C.E5.83.8F.E6.BA.90">更换</a></a></li></ul>
                </li>
                <li>
                    <a href="#%e6%9b%b4%e6%96%b0-tumbleweedhttpszhopensuseorgsdbe69bb4e696b0_tumbleweed" aria-label="更新 Tumbleweed"><a href="https://zh.opensuse.org/SDB:%E6%9B%B4%E6%96%B0_Tumbleweed">更新 Tumbleweed</a></a></li>
                <li>
                    <a href="#packmanhttpszhopensuseorgpackman" aria-label="Packman"><a href="https://zh.opensuse.org/Packman">Packman</a></a><ul>
                        
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af-packman-" aria-label="什么是 Packman ？">什么是 Packman ？</a></li>
                <li>
                    <a href="#packman-%e5%92%8c-opensuse-%e7%9a%84%e5%85%b3%e7%b3%bb" aria-label="Packman 和 openSUSE 的关系">Packman 和 openSUSE 的关系</a></li>
                <li>
                    <a href="#packman-%e6%94%b6%e7%ba%b3%e4%bb%80%e4%b9%88%e6%a0%b7%e7%9a%84%e8%bd%af%e4%bb%b6-" aria-label="Packman 收纳什么样的软件 ？">Packman 收纳什么样的软件 ？</a></li>
                <li>
                    <a href="#%e5%90%af%e7%94%a8-packman-%e6%ba%90httpszhopensuseorgsdbe5bfabe9809fe9858de7bdaee68c87e58d97e590afe794a8_packman_e6ba90" aria-label="启用 Packman 源"><a href="https://zh.opensuse.org/SDB:%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97#.E5.90.AF.E7.94.A8_Packman_.E6.BA.90">启用 Packman 源</a></a></li>
                <li>
                    <a href="#install-multimedia-codecshttpsfosspostorgthings-to-do-after-installing-opensuserun_a_system_update" aria-label="Install Multimedia Codecs"><a href="https://fosspost.org/things-to-do-after-installing-opensuse/#Run_a_System_Update">Install Multimedia Codecs</a></a></li></ul>
                </li>
                <li>
                    <a href="#%e8%bd%af%e4%bb%b6%e7%ae%a1%e7%90%86" aria-label="软件管理">软件管理</a><ul>
                        
                <li>
                    <a href="#%e6%9b%b4%e6%96%b0%e5%88%b7%e6%96%b0%e8%bf%9b%e7%a8%8b%e8%a2%ab%e5%8d%a0%e7%94%a8httpszhopensuseorgsdbe5bfabe9809fe9858de7bdaee68c87e58d97e69bb4e696b02fe588b7e696b0e8bf9be7a88be8a2abe58da0e794a8" aria-label="更新/刷新进程被占用"><a href="https://zh.opensuse.org/SDB:%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97#.E6.9B.B4.E6.96.B0.2F.E5.88.B7.E6.96.B0.E8.BF.9B.E7.A8.8B.E8.A2.AB.E5.8D.A0.E7.94.A8">更新/刷新进程被占用</a></a></li>
                <li>
                    <a href="#%e5%8f%96%e6%b6%88%e6%8e%a8%e8%8d%90%e7%9a%84%e8%bd%af%e4%bb%b6%e5%8c%85--%e5%88%a0%e9%99%a4%e6%a8%a1%e7%bb%84httpszhopensuseorgsdbe5bfabe9809fe9858de7bdaee68c87e58d97e58f96e6b688e68ea8e88d90e79a84e8bdafe4bbb6e58c85_26_e588a0e999a4e6a8a1e7bb84" aria-label="取消推荐的软件包 &amp;amp; 删除模组"><a href="https://zh.opensuse.org/SDB:%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97#.E5.8F.96.E6.B6.88.E6.8E.A8.E8.8D.90.E7.9A.84.E8.BD.AF.E4.BB.B6.E5.8C.85_.26_.E5.88.A0.E9.99.A4.E6.A8.A1.E7.BB.84">取消推荐的软件包 &amp; 删除模组</a></a></li>
                <li>
                    <a href="#obs-package-installer" aria-label="OBS Package Installer">OBS Package Installer</a></li>
                <li>
                    <a href="#%e4%b8%ad%e6%96%87%e7%a4%be%e5%8c%ba%e6%ba%90httpszhopensuseorgsdbe5bfabe9809fe9858de7bdaee68c87e58d97e4b8ade69687e7a4bee58cbae6ba90" aria-label="中文社区源"><a href="https://zh.opensuse.org/SDB:%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97#.E4.B8.AD.E6.96.87.E7.A4.BE.E5.8C.BA.E6.BA.90">中文社区源</a></a></li></ul>
                </li>
                <li>
                    <a href="#%e8%be%93%e5%85%a5%e6%b3%95" aria-label="输入法">输入法</a><ul>
                        
                <li>
                    <a href="#ibushttpszhopensuseorgibuse7ae80e4bb8b" aria-label="ibus"><a href="https://zh.opensuse.org/Ibus#.E7.AE.80.E4.BB.8B">ibus</a></a></li>
                <li>
                    <a href="#fcitx5httpswikiarchlinuxorgtitlefcitx5_e7ae80e4bd93e4b8ade69687e9858de7bdae" aria-label="Fcitx5"><a href="https://wiki.archlinux.org/title/Fcitx5_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E9%85%8D%E7%BD%AE">Fcitx5</a></a><ul>
                        
                <li>
                    <a href="#%e8%af%8d%e5%ba%93" aria-label="词库">词库</a></li>
                <li>
                    <a href="#cloudpinyin" aria-label="cloudpinyin">cloudpinyin</a></li>
                <li>
                    <a href="#%e6%90%9c%e7%8b%97%e6%8b%bc%e9%9f%b3" aria-label="搜狗拼音">搜狗拼音</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#nvidiahttpszhopensuseorgsdbnvidia" aria-label="NVIDIA"><a href="https://zh.opensuse.org/SDB:NVIDIA">NVIDIA</a></a><ul>
                        
                <li>
                    <a href="#%e5%ae%89%e8%a3%85" aria-label="安装">安装</a></li>
                <li>
                    <a href="#%e7%94%bb%e9%9d%a2%e6%92%95%e8%a3%82" aria-label="画面撕裂">画面撕裂</a></li></ul>
                </li>
                <li>
                    <a href="#audacioushttpsaudacious-media-playerorg" aria-label="Audacious"><a href="https://audacious-media-player.org/">Audacious</a></a></li>
                <li>
                    <a href="#openzfshttpsenopensuseorgopenzfszfs_openzfs_and_zfs_on_linux" aria-label="OpenZFS"><a href="https://en.opensuse.org/OpenZFS#ZFS,_OpenZFS_and_ZFS_on_Linux">OpenZFS</a></a></li></ul>
                </li>
                <li>
                    <a href="#opensuse-system" aria-label="openSUSE System">openSUSE System</a><ul>
                        
                <li>
                    <a href="#btrfshttpszhuanlanzhihucomp61407714" aria-label="Btrfs"><a href="https://zhuanlan.zhihu.com/p/61407714">Btrfs</a></a><ul>
                        
                <li>
                    <a href="#btrfs-%e7%9a%84%e7%89%b9%e6%80%a7" aria-label="Btrfs 的特性">Btrfs 的特性</a><ul>
                        
                <li>
                    <a href="#%e6%89%a9%e5%b1%95%e6%80%a7%e7%9b%b8%e5%85%b3%e7%9a%84%e7%89%b9%e6%80%a7" aria-label="扩展性相关的特性">扩展性相关的特性</a></li>
                <li>
                    <a href="#%e6%95%b0%e6%8d%ae%e4%b8%80%e8%87%b4%e6%80%a7%e7%9b%b8%e5%85%b3%e7%9a%84%e7%89%b9%e6%80%a7" aria-label="数据一致性相关的特性">数据一致性相关的特性</a></li>
                <li>
                    <a href="#%e5%a4%9a%e8%ae%be%e5%a4%87%e7%ae%a1%e7%90%86%e7%9b%b8%e5%85%b3%e7%9a%84%e7%89%b9%e6%80%a7" aria-label="多设备管理相关的特性">多设备管理相关的特性</a></li>
                <li>
                    <a href="#%e5%85%b6%e4%bb%96%e7%89%b9%e6%80%a7" aria-label="其他特性">其他特性</a></li>
                <li>
                    <a href="#%e6%80%bb%e7%bb%93" aria-label="总结">总结</a></li></ul>
                </li>
                <li>
                    <a href="#btrfs-%e4%bd%bf%e7%94%a8httpswikiarchlinuxorgtitlebtrfs_e7ae80e4bd93e4b8ade69687" aria-label="Btrfs 使用"><a href="https://wiki.archlinux.org/title/Btrfs_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Btrfs 使用</a></a><ul>
                        
                <li>
                    <a href="#%e5%88%9b%e5%bb%ba%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f" aria-label="创建文件系统">创建文件系统</a></li>
                <li>
                    <a href="#subvolume" aria-label="subvolume">subvolume</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8-btrfs-%e5%bf%ab%e7%85%a7%e8%bf%9b%e8%a1%8c%e5%a2%9e%e9%87%8f%e5%a4%87%e4%bb%bdhttpszhuanlanzhihucomp259534619" aria-label="使用 Btrfs 快照进行增量备份"><a href="https://zhuanlan.zhihu.com/p/259534619">使用 Btrfs 快照进行增量备份</a></a></li>
                <li>
                    <a href="#%e5%8e%8b%e7%bc%a9" aria-label="压缩">压缩</a></li></ul>
                </li>
                <li>
                    <a href="#btrfs-%e5%92%8c-lvm-ext4httpslinuxcnarticle-13043-1html" aria-label="Btrfs 和 LVM-ext4"><a href="https://linux.cn/article-13043-1.html">Btrfs 和 LVM-ext4</a></a><ul>
                        
                <li>
                    <a href="#%e4%b8%a4%e8%80%85%e7%9a%84%e5%85%b1%e6%80%a7" aria-label="两者的共性">两者的共性</a></li>
                <li>
                    <a href="#lvm-ext4-%e7%9a%84%e4%bc%98%e5%8a%bf" aria-label="LVM-ext4 的优势">LVM-ext4 的优势</a></li>
                <li>
                    <a href="#btrfs-%e7%9a%84%e4%bc%98%e5%8a%bf" aria-label="Btrfs 的优势">Btrfs 的优势</a></li>
                <li>
                    <a href="#lvm-%e4%b8%8a%e4%bd%bf%e7%94%a8-btrfs" aria-label="LVM 上使用 Btrfs">LVM 上使用 Btrfs</a></li>
                <li>
                    <a href="#%e6%80%bb%e7%bb%93-1" aria-label="总结">总结</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#snapperhttpszhopensuseorgsdbsnapper_tutorial" aria-label="Snapper"><a href="https://zh.opensuse.org/SDB:Snapper_Tutorial">Snapper</a></a><ul>
                        
                <li>
                    <a href="#%e5%bf%ab%e7%85%a7%e7%b1%bb%e5%9e%8b" aria-label="快照类型">快照类型</a></li>
                <li>
                    <a href="#%e9%bb%98%e8%ae%a4%e9%85%8d%e7%bd%ae" aria-label="默认配置">默认配置</a></li>
                <li>
                    <a href="#%e6%89%8b%e5%8a%a8%e9%85%8d%e7%bd%ae" aria-label="手动配置">手动配置</a><ul>
                        
                <li>
                    <a href="#%e5%88%9b%e5%bb%ba%e5%92%8c%e8%a3%85%e5%85%a5%e6%96%b0%e5%ad%90%e5%8d%b7" aria-label="创建和装入新子卷">创建和装入新子卷</a></li>
                <li>
                    <a href="#%e5%88%9b%e5%bb%ba%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6" aria-label="创建配置文件">创建配置文件</a></li>
                <li>
                    <a href="#%e5%90%af%e7%94%a8%e7%a6%81%e7%94%a8%e8%87%aa%e5%8a%a8%e5%bf%ab%e7%85%a7" aria-label="启用/禁用自动快照">启用/禁用自动快照</a></li>
                <li>
                    <a href="#%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6%e5%8f%82%e6%95%b0" aria-label="配置文件参数">配置文件参数</a></li>
                <li>
                    <a href="#%e7%ae%a1%e7%90%86%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6" aria-label="管理配置文件">管理配置文件</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%bf%ab%e7%85%a7%e7%ae%a1%e7%90%86" aria-label="快照管理">快照管理</a></li></ul>
                </li>
                <li>
                    <a href="#sudohttpsdocumentationsusecomzh-cnsles15-gahtmlsles-allcha-adm-sudohtml" aria-label="sudo"><a href="https://documentation.suse.com/zh-cn/sles/15-GA/html/SLES-all/cha-adm-sudo.html">sudo</a></a><ul>
                        
                <li>
                    <a href="#sudo-%e5%9f%ba%e6%9c%ac%e7%94%a8%e6%b3%95" aria-label="sudo 基本用法"><code>sudo</code> 基本用法</a><ul>
                        
                <li>
                    <a href="#%e8%bf%90%e8%a1%8c%e5%8d%95%e4%b8%aa%e5%91%bd%e4%bb%a4" aria-label="运行单个命令">运行单个命令</a></li>
                <li>
                    <a href="#%e5%90%af%e5%8a%a8%e5%a4%96%e5%a3%b3" aria-label="启动外壳">启动外壳</a></li>
                <li>
                    <a href="#%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f" aria-label="环境变量">环境变量</a></li></ul>
                </li>
                <li>
                    <a href="#%e9%85%8d%e7%bd%ae-sudo" aria-label="配置 sudo">配置 <code>sudo</code></a><ul>
                        
                <li>
                    <a href="#%e7%bc%96%e8%be%91%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6" aria-label="编辑配置文件">编辑配置文件</a></li>
                <li>
                    <a href="#sudoers-%e5%9f%ba%e6%9c%ac%e9%85%8d%e7%bd%ae%e8%af%ad%e6%b3%95" aria-label="sudoers 基本配置语法">sudoers 基本配置语法</a></li>
                <li>
                    <a href="#sudoers-%e4%b8%ad%e7%9a%84%e8%a7%84%e5%88%99" aria-label="sudoers 中的规则">sudoers 中的规则</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%b8%b8%e8%a7%81%e4%bd%bf%e7%94%a8%e6%83%85%e5%86%b5" aria-label="常见使用情况">常见使用情况</a><ul>
                        
                <li>
                    <a href="#%e5%9c%a8%e6%97%a0%e9%9c%80-root-%e5%8f%a3%e4%bb%a4%e7%9a%84%e6%83%85%e5%86%b5%e4%b8%8b%e4%bd%bf%e7%94%a8-sudo" aria-label="在无需 root 口令的情况下使用 sudo">在无需 <code>root</code> 口令的情况下使用 <code>sudo</code></a></li>
                <li>
                    <a href="#%e5%af%b9-xorg-%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f%e4%bd%bf%e7%94%a8-sudo" aria-label="对 X.Org 应用程序使用 sudo">对 X.Org 应用程序使用 <code>sudo</code></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#zypperhttpsdocumentationsusecomzh-cnsles15-gahtmlsles-allcha-sw-clhtmlsec-zypper" aria-label="Zypper"><a href="https://documentation.suse.com/zh-cn/sles/15-GA/html/SLES-all/cha-sw-cl.html#sec-zypper">Zypper</a></a><ul>
                        
                <li>
                    <a href="#%e4%b8%80%e8%88%ac%e4%bd%bf%e7%94%a8" aria-label="一般使用">一般使用</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8-zypper-%e5%ae%89%e8%a3%85%e5%92%8c%e5%88%a0%e9%99%a4%e8%bd%af%e4%bb%b6" aria-label="使用 Zypper 安装和删除软件">使用 Zypper 安装和删除软件</a><ul>
                        
                <li>
                    <a href="#%e9%80%89%e6%8b%a9%e8%a6%81%e5%ae%89%e8%a3%85%e6%88%96%e5%8e%bb%e9%99%a4%e7%9a%84%e5%8c%85" aria-label="选择要安装或去除的包">选择要安装或去除的包</a></li>
                <li>
                    <a href="#%e5%90%8c%e6%97%b6%e5%ae%89%e8%a3%85%e5%92%8c%e5%8e%bb%e9%99%a4%e5%8c%85" aria-label="同时安装和去除包">同时安装和去除包</a></li>
                <li>
                    <a href="#%e6%b8%85%e7%90%86%e5%b7%b2%e5%8e%bb%e9%99%a4%e5%8c%85%e7%9a%84%e4%be%9d%e8%b5%96%e9%a1%b9" aria-label="清理已去除包的依赖项">清理已去除包的依赖项</a></li>
                <li>
                    <a href="#%e5%9c%a8%e8%84%9a%e6%9c%ac%e4%b8%ad%e4%bd%bf%e7%94%a8-zypper" aria-label="在脚本中使用 Zypper">在脚本中使用 Zypper</a></li>
                <li>
                    <a href="#%e5%ae%89%e8%a3%85%e6%88%96%e4%b8%8b%e8%bd%bd%e6%ba%90%e5%8c%85" aria-label="安装或下载源包">安装或下载源包</a></li>
                <li>
                    <a href="#%e4%bb%8e%e7%a6%81%e7%94%a8%e7%9a%84%e5%82%a8%e5%ad%98%e5%ba%93%e5%ae%89%e8%a3%85%e5%8c%85" aria-label="从禁用的储存库安装包">从禁用的储存库安装包</a></li>
                <li>
                    <a href="#%e5%ae%9e%e7%94%a8%e7%a8%8b%e5%ba%8f" aria-label="实用程序">实用程序</a></li></ul>
                </li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8-zypper-%e6%9b%b4%e6%96%b0%e8%bd%af%e4%bb%b6" aria-label="使用 Zypper 更新软件">使用 Zypper 更新软件</a><ul>
                        
                <li>
                    <a href="#%e5%ae%89%e8%a3%85%e5%85%a8%e9%83%a8%e6%89%80%e9%9c%80%e7%9a%84%e5%a2%9e%e8%a1%a5%e7%a8%8b%e5%ba%8f" aria-label="安装全部所需的增补程序">安装全部所需的增补程序</a></li>
                <li>
                    <a href="#%e5%88%97%e5%87%ba%e5%a2%9e%e8%a1%a5%e7%a8%8b%e5%ba%8f" aria-label="列出增补程序">列出增补程序</a></li>
                <li>
                    <a href="#%e5%ae%89%e8%a3%85%e6%96%b0%e7%9a%84%e5%8c%85%e7%89%88%e6%9c%ac" aria-label="安装新的包版本">安装新的包版本</a></li>
                <li>
                    <a href="#%e8%af%86%e5%88%ab%e5%ad%a4%e7%ab%8b%e7%9a%84%e5%8c%85" aria-label="识别孤立的包">识别孤立的包</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%af%86%e5%88%ab%e4%bd%bf%e7%94%a8%e5%b7%b2%e5%88%a0%e9%99%a4%e6%96%87%e4%bb%b6%e7%9a%84%e8%bf%9b%e7%a8%8b%e5%92%8c%e6%9c%8d%e5%8a%a1" aria-label="识别使用已删除文件的进程和服务">识别使用已删除文件的进程和服务</a></li>
                <li>
                    <a href="#%e7%94%a8-zypper-%e7%ae%a1%e7%90%86%e5%ae%89%e8%a3%85%e6%ba%90" aria-label="用 Zypper 管理安装源">用 Zypper 管理安装源</a></li>
                <li>
                    <a href="#%e6%b7%bb%e5%8a%a0%e5%ae%89%e8%a3%85%e6%ba%90" aria-label="添加安装源">添加安装源</a></li>
                <li>
                    <a href="#%e5%88%b7%e6%96%b0%e5%82%a8%e5%ad%98%e5%ba%93" aria-label="刷新储存库">刷新储存库</a><ul>
                        
                <li>
                    <a href="#%e5%88%a0%e9%99%a4%e5%82%a8%e5%ad%98%e5%ba%93" aria-label="删除储存库">删除储存库</a></li>
                <li>
                    <a href="#%e4%bf%ae%e6%94%b9%e5%82%a8%e5%ad%98%e5%ba%93" aria-label="修改储存库">修改储存库</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%94%a8-zypper-%e6%9f%a5%e8%af%a2%e5%82%a8%e5%ad%98%e5%ba%93%e5%92%8c%e5%8c%85" aria-label="用 Zypper 查询储存库和包">用 Zypper 查询储存库和包</a><ul>
                        
                <li>
                    <a href="#%e6%90%9c%e7%b4%a2%e8%bd%af%e4%bb%b6" aria-label="搜索软件">搜索软件</a></li>
                <li>
                    <a href="#%e6%90%9c%e7%b4%a2%e7%89%b9%e5%ae%9a%e5%8a%9f%e8%83%bd" aria-label="搜索特定功能">搜索特定功能</a></li>
                <li>
                    <a href="#%e6%98%be%e7%a4%ba%e5%8c%85%e4%bf%a1%e6%81%af" aria-label="显示包信息">显示包信息</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%98%be%e7%a4%ba%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e4%bf%a1%e6%81%af" aria-label="显示生命周期信息">显示生命周期信息</a></li>
                <li>
                    <a href="#%e9%85%8d%e7%bd%ae-zypper" aria-label="配置 Zypper">配置 Zypper</a></li>
                <li>
                    <a href="#%e6%9f%a5%e9%94%99" aria-label="查错">查错</a></li>
                <li>
                    <a href="#btrfs-%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e4%b8%8a%e7%9a%84-zypper-%e5%9b%9e%e6%bb%9a%e5%8a%9f%e8%83%bd" aria-label="Btrfs 文件系统上的 Zypper 回滚功能">Btrfs 文件系统上的 Zypper 回滚功能</a></li></ul>
                </li>
                <li>
                    <a href="#rpmhttpsdocumentationsusecomzh-cnsles15-gahtmlsles-allcha-sw-clhtmlsec-rpm" aria-label="RPM"><a href="https://documentation.suse.com/zh-cn/sles/15-GA/html/SLES-all/cha-sw-cl.html#sec-rpm">RPM</a></a><ul>
                        
                <li>
                    <a href="#%e6%a0%a1%e9%aa%8c%e5%8c%85%e7%9c%9f%e5%ae%9e%e6%80%a7" aria-label="校验包真实性">校验包真实性</a></li>
                <li>
                    <a href="#%e7%ae%a1%e7%90%86%e5%8c%85%e5%ae%89%e8%a3%85%e6%9b%b4%e6%96%b0%e5%92%8c%e5%8d%b8%e8%a3%85" aria-label="管理包：安装、更新和卸装">管理包：安装、更新和卸装</a></li>
                <li>
                    <a href="#%e5%a2%9e%e9%87%8f-rpm-%e5%8c%85" aria-label="增量 RPM 包">增量 RPM 包</a></li>
                <li>
                    <a href="#rpm-%e6%9f%a5%e8%af%a2" aria-label="RPM 查询">RPM 查询</a></li>
                <li>
                    <a href="#%e5%ae%89%e8%a3%85%e5%92%8c%e7%bc%96%e8%af%91%e6%ba%90%e5%8c%85" aria-label="安装和编译源包">安装和编译源包</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8-build-%e7%bc%96%e8%af%91-rpm-%e5%8c%85" aria-label="使用 build 编译 RPM 包">使用 build 编译 RPM 包</a></li>
                <li>
                    <a href="#%e7%94%a8%e4%ba%8e-rpm-%e5%ad%98%e6%a1%a3%e5%92%8c-rpm-%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e5%b7%a5%e5%85%b7" aria-label="用于 RPM 存档和 RPM 数据库的工具">用于 RPM 存档和 RPM 数据库的工具</a></li></ul>
                </li>
                <li>
                    <a href="#firewall-cmdhttpszhopensuseorgsdbfirewall-cmd" aria-label="Firewall-cmd"><a href="https://zh.opensuse.org/SDB:Firewall-cmd">Firewall-cmd</a></a><ul>
                        
                <li>
                    <a href="#%e5%87%86%e5%a4%87%e5%b7%a5%e4%bd%9c" aria-label="准备工作">准备工作</a></li>
                <li>
                    <a href="#firewalld-%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5" aria-label="Firewalld 的基本概念">Firewalld 的基本概念</a><ul>
                        
                <li>
                    <a href="#%e5%8c%ba%e5%9f%9fzone" aria-label="区域（zone）">区域（zone）</a></li>
                <li>
                    <a href="#%e6%9c%8d%e5%8a%a1services" aria-label="服务（services）">服务（services）</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%90%af%e5%8a%a8%e6%a3%80%e6%9f%a5%e5%92%8c%e5%85%b3%e9%97%ad-firewalld-%e6%9c%8d%e5%8a%a1" aria-label="启动、检查和关闭 firewalld 服务">启动、检查和关闭 firewalld 服务</a></li>
                <li>
                    <a href="#%e8%bf%90%e8%a1%8c%e6%97%b6%e5%92%8c%e6%b0%b8%e4%b9%85%e8%a7%84%e5%88%99" aria-label="运行时和永久规则">运行时和永久规则</a></li>
                <li>
                    <a href="#firewall-cmd-%e8%a7%84%e5%88%99%e9%9b%86%e6%a0%b7%e4%be%8b" aria-label="Firewall-cmd 规则集样例">Firewall-cmd 规则集样例</a><ul>
                        
                <li>
                    <a href="#%e7%bc%96%e5%86%99%e7%ab%af%e5%8f%a3%e8%bd%ac%e5%8f%91-firewalld-%e8%a7%84%e5%88%99" aria-label="编写端口转发 Firewalld 规则">编写端口转发 Firewalld 规则</a></li></ul>
                </li>
                <li>
                    <a href="#rich-rule-%e7%a4%ba%e4%be%8bhttpsforumsuseorgcnttopic13503uhsiung" aria-label="Rich rule 示例"><a href="https://forum.suse.org.cn/t/topic/13503?u=hsiung">Rich rule 示例</a></a></li>
                <li>
                    <a href="#%e5%85%b6%e4%bb%96" aria-label="其他">其他</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#opensuse-tips" aria-label="openSUSE Tips">openSUSE Tips</a><ul>
                        
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%80%89%e6%8b%a9-opensusehttpszhopensuseorge4b8bae4bb80e4b988e98089e68ba9_opensuse" aria-label="为什么选择 openSUSE"><a href="https://zh.opensuse.org/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9_openSUSE">为什么选择 openSUSE</a></a></li>
                <li>
                    <a href="#free-and-open-sourcehttpszhopensuseorgfree_and_open_source" aria-label="Free and Open Source"><a href="https://zh.opensuse.org/Free_and_Open_Source">Free and Open Source</a></a><ul>
                        
                <li>
                    <a href="#%e7%8b%ad%e4%b9%89%e7%9a%84%e8%87%aa%e7%94%b1%e5%bc%80%e6%ba%90%e6%a6%82%e5%bf%b5" aria-label="狭义的自由开源概念">狭义的自由开源概念</a></li>
                <li>
                    <a href="#%e5%b9%bf%e4%b9%89%e7%9a%84%e8%87%aa%e7%94%b1%e5%bc%80%e6%ba%90%e6%a6%82%e5%bf%b5" aria-label="广义的自由开源概念">广义的自由开源概念</a></li>
                <li>
                    <a href="#opensuse-%e7%a7%89%e6%8c%81%e7%9a%84%e8%87%aa%e7%94%b1%e5%bc%80%e6%ba%90%e6%a6%82%e5%bf%b5" aria-label="openSUSE 秉持的自由开源概念">openSUSE 秉持的自由开源概念</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%94%a8%e6%88%b7%e5%ad%97%e4%bd%93" aria-label="用户字体">用户字体</a></li>
                <li>
                    <a href="#%e8%a3%85%e5%85%a5-ntfs-%e5%88%86%e5%8c%ba" aria-label="装入 NTFS 分区">装入 NTFS 分区</a></li>
                <li>
                    <a href="#%e4%bb%bb%e5%8a%a1%e6%a0%8f%e9%80%8f%e6%98%8e%e5%8c%96httpsaskubuntucomquestions1173618how-to-make-kde-plasma-taskbar-panel-transparent" aria-label="任务栏透明化"><a href="https://askubuntu.com/questions/1173618/how-to-make-kde-plasma-taskbar-panel-transparent">任务栏透明化</a></a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8-24-%e5%b0%8f%e6%97%b6%e5%88%b6" aria-label="使用 24 小时制">使用 24 小时制</a></li>
                <li>
                    <a href="#%e4%b8%bb%e9%a2%98" aria-label="主题">主题</a></li>
                <li>
                    <a href="#%e5%b8%b8%e7%94%a8%e8%bd%af%e4%bb%b6httpszhopensuseorge5b8b8e794a8e8bdafe4bbb6" aria-label="常用软件"><a href="https://zh.opensuse.org/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6">常用软件</a></a></li>
                <li>
                    <a href="#remove-a-file-using-inode-numberhttpssysadmineracom20170310unix-how-to-remove-a-file-using-inode-number" aria-label="Remove a file using inode number"><a href="https://sysadminera.com/2017/03/10/unix-how-to-remove-a-file-using-inode-number/">Remove a file using inode number</a></a></li>
                <li>
                    <a href="#unziphttpsforumsuseorgcntgui510" aria-label="unzip"><a href="https://forum.suse.org.cn/t/gui/510">unzip</a></a><ul>
                        
                <li>
                    <a href="#%e9%97%ae%e9%a2%98%e6%8f%8f%e8%bf%b0httpsjuejincnpost7033637038574436366heading-0" aria-label="问题描述"><a href="https://juejin.cn/post/7033637038574436366#heading-0">问题描述</a></a></li>
                <li>
                    <a href="#%e8%a7%a3%e5%86%b3httpswwwmarkjourcomarticle20190506-unzip-chinesehtml" aria-label="解决"><a href="https://www.markjour.com/article/20190506-unzip-chinese.html">解决</a></a><ul>
                        
                <li>
                    <a href="#%e7%b3%bb%e7%bb%9f%e8%bf%98%e6%9c%aa%e7%bc%96%e8%af%91%e5%ae%89%e8%a3%85unzip" aria-label="系统还未编译安装Unzip">系统还未编译安装Unzip</a></li>
                <li>
                    <a href="#%e5%a6%82%e6%9e%9c%e6%82%a8%e7%9a%84%e7%b3%bb%e7%bb%9f%e5%b7%b2%e7%bb%8f%e5%ae%89%e8%a3%85%e4%ba%86-unzip" aria-label="如果您的系统已经安装了 unzip">如果您的系统已经安装了 unzip</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e4%b9%b1%e7%a0%81%e9%97%ae%e9%a2%98httpswikiarchlinuxorgtitlelocalization_e7ae80e4bd93e4b8ade69687simplified_chinese_e7ae80e4bd93e4b8ade69687e4b9b1e7a081e997aee9a298" aria-label="乱码问题"><a href="https://wiki.archlinux.org/title/Localization_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)/Simplified_Chinese_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#.E4.B9.B1.E7.A0.81.E9.97.AE.E9.A2.98">乱码问题</a></a><ul>
                        
                <li>
                    <a href="#%e6%96%87%e4%bb%b6%e5%90%8d%e4%b9%b1%e7%a0%81" aria-label="文件名乱码">文件名乱码</a></li>
                <li>
                    <a href="#%e6%96%87%e4%bb%b6%e5%86%85%e5%ae%b9%e4%b9%b1%e7%a0%81" aria-label="文件内容乱码">文件内容乱码</a></li>
                <li>
                    <a href="#zip-%e5%8e%8b%e7%bc%a9%e5%8c%85%e4%b9%b1%e7%a0%81" aria-label="zip 压缩包乱码">zip 压缩包乱码</a></li></ul>
                </li>
                <li>
                    <a href="#zypper-autoremovehttpsforumsuseorgcnttopic1413713uhsiung" aria-label="zypper autoremove"><a href="https://forum.suse.org.cn/t/topic/14137/13?u=hsiung">zypper autoremove</a></a></li>
                <li>
                    <a href="#ntfs-3g-%e4%b8%8e-ntfs3-%e9%a9%b1%e5%8a%a8httpsbiluohcgithubiopostsntfs3gvsntfs3" aria-label="ntfs-3g 与 ntfs3 驱动"><a href="https://biluohc.github.io/posts/ntfs3gvsntfs3/">ntfs-3g 与 ntfs3 驱动</a></a></li>
                <li>
                    <a href="#kde-tipshttpsforumsuseorgcnttopic14131uhsiung" aria-label="KDE Tips"><a href="https://forum.suse.org.cn/t/topic/14131?u=hsiung">KDE Tips</a></a><ul>
                        
                <li>
                    <a href="#trash-cli" aria-label="trash-cli">trash-cli</a></li>
                <li>
                    <a href="#liberate-super-key" aria-label="liberate Super Key">liberate Super Key</a></li>
                <li>
                    <a href="#custom-context-menu" aria-label="Custom Context Menu">Custom Context Menu</a></li>
                <li>
                    <a href="#%e9%95%bf%e5%91%bd%e4%bb%a4%e9%80%9a%e7%9f%a5" aria-label="长命令通知">长命令通知</a></li>
                <li>
                    <a href="#command-palette" aria-label="Command Palette">Command Palette</a></li></ul>
                </li>
                <li>
                    <a href="#openqahttpsforumsuseorgcnttopic13525uhsiung" aria-label="openQA"><a href="https://forum.suse.org.cn/t/topic/13525?u=hsiung">openQA</a></a></li>
                <li>
                    <a href="#sdbhttpsforumsuseorgcnttopic135037uhsiung" aria-label="SDB"><a href="https://forum.suse.org.cn/t/topic/13503/7?u=hsiung">SDB</a></a></li>
                <li>
                    <a href="#%e7%bb%99-pdf-%e7%94%b5%e5%ad%90%e4%b9%a6%e5%8a%a0%e7%9b%ae%e5%bd%95httpsforumsuseorgcnttopic14862uhsiung" aria-label="给 pdf 电子书加目录"><a href="https://forum.suse.org.cn/t/topic/14862?u=hsiung">给 pdf 电子书加目录</a></a></li>
                <li>
                    <a href="#kde-pim-%e4%bd%bf%e7%94%a8%e6%8c%87%e5%8c%97httpsimbearchildcyouarchives202111kde-pim-guide" aria-label="KDE PIM 使用指北"><a href="https://imbearchild.cyou/archives/2021/11/kde-pim-guide/">KDE PIM 使用指北</a></a></li></ul>
                </li>
                <li>
                    <a href="#opensuse-questions" aria-label="openSUSE Questions">openSUSE Questions</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e5%86%b3kde%e4%b8%8bkde-wallet%e9%87%8d%e8%a3%85%e7%b3%bb%e7%bb%9f%e5%90%8e%e6%af%8f%e6%ac%a1%e7%99%bb%e9%99%86%e9%9c%80%e8%a6%81%e8%be%93%e5%85%a5%e5%af%86%e7%a0%81httpscloudtencentcomdeveloperarticle1688182" aria-label="解决KDE下KDE Wallet重装系统后每次登陆需要输入密码"><a href="https://cloud.tencent.com/developer/article/1688182">解决KDE下KDE Wallet重装系统后每次登陆需要输入密码</a></a></li>
                <li>
                    <a href="#could-not-open-a-connection-to-your-authentication-agent" aria-label="Could not open a connection to your authentication agent">Could not open a connection to your authentication agent</a></li>
                <li>
                    <a href="#%e6%97%a0%e6%b3%95%e8%af%bb%e5%8f%96-exfat--7z-%e5%92%8c-rar" aria-label="无法读取 exfat 、 .7z 和 .rar">无法读取 exfat 、 .7z 和 .rar</a></li>
                <li>
                    <a href="#vscode-keychain-issueshttpscodevisualstudiocomdocseditorsettings-sync_troubleshooting-keychain-issues-for-kdehttpsgithubcommicrosoftvscodeissues92972issuecomment-608572519" aria-label="vscode keychain issues for KDE">vscode <a href="https://code.visualstudio.com/docs/editor/settings-sync#_troubleshooting-keychain-issues">keychain issues</a> <a href="https://github.com/microsoft/vscode/issues/92972#issuecomment-608572519">for KDE</a></a></li>
                <li>
                    <a href="#typora-%e5%ad%97%e4%bd%93%e9%97%ae%e9%a2%98" aria-label="Typora 字体问题">Typora 字体问题</a></li>
                <li>
                    <a href="#%e5%a6%82%e6%9e%9c-typora-%e5%ad%97%e4%bd%93%e5%a6%82%e4%b8%8a%e9%9d%a2%e9%82%a3%e6%a0%b7%e6%af%8f%e4%b8%aa%e5%ad%97%e5%a4%a7%e5%b0%8f%e4%b8%8d%e4%b8%80%e6%a0%b7" aria-label="如果 Typora 字体如上面那样，每个字大小不一样：">如果 Typora 字体如上面那样，每个字大小不一样：</a></li>
                <li>
                    <a href="#flatpak-run-invalid-mit-magic-cookie-1-keyhttpsforumsopensuseorgshowthreadphp539546-cannot-run-flatpaks-anymore" aria-label="flatpak run: Invalid MIT-MAGIC-COOKIE-1 key"><a href="https://forums.opensuse.org/showthread.php/539546-Cannot-run-flatpaks-anymore">flatpak run: Invalid MIT-MAGIC-COOKIE-1 key</a></a></li>
                <li>
                    <a href="#nothing-provides-libuuid-needed-by-the-to-be-installed-xmind" aria-label="nothing provides &amp;lsquo;libuuid&amp;rsquo; needed by the to be installed xmind">nothing provides &lsquo;libuuid&rsquo; needed by the to be installed xmind</a></li>
                <li>
                    <a href="#high-cpu-usage-of-goldendict" aria-label="High cpu usage of Goldendict">High cpu usage of Goldendict</a></li>
                <li>
                    <a href="#disabling-mouse-scroll-wheel-switching-between-virtual-desktopshttpswwwredditcomrkdecomments6l9fvedisabling_mouse_scrollwheel_switching_between" aria-label="Disabling mouse scroll-wheel switching between virtual desktops"><a href="https://www.reddit.com/r/kde/comments/6l9fve/disabling_mouse_scrollwheel_switching_between/">Disabling mouse scroll-wheel switching between virtual desktops</a></a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p><code>/ˌoʊpənˈsuːzə/</code></p>
<h2 id="opensuse-desktop">openSUSE Desktop<a hidden class="anchor" aria-hidden="true" href="#opensuse-desktop">#</a></h2>
<h3 id="dvd-方式安装httpszhopensuseorgsdbdvd_e5ae89e8a385e696b9e5bc8f"><a href="https://zh.opensuse.org/SDB:DVD_%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F">DVD 方式安装</a><a hidden class="anchor" aria-hidden="true" href="#dvd-方式安装httpszhopensuseorgsdbdvd_e5ae89e8a385e696b9e5bc8f">#</a></h3>
<ul>
<li>
<p>使用其他方式安装系统需要耗费比其他安装方式更多的时间和精力，除非必要，建议优先使用离线的 DVD 镜像进行安装系统。</p>
</li>
<li>
<p>语言选择 English，因为 Linux 需要经常使用 Terminal，中文家目录并不方便。</p>
</li>
<li>
<p><a href="https://doc.opensuse.org/documentation/leap/startup/html/book-startup/cha-install.html#sec-yast-install-partitioning-suggested">分区</a> 选择默认的 btrfs 文件系统，有需要选择 Guided setup 和 Expert Partitioner。</p>
</li>
<li>
<p>软件包：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo zypper in android-tools aria2 qemu-kvm samba goldendict noto-sans-cjk-fonts noto-sans-mono-fonts translate-shell git unrar proxychains-ng
</code></pre></div></li>
</ul>
<h3 id="国内镜像源httpsforumsuseorgcntopensuse1759"><a href="https://forum.suse.org.cn/t/opensuse/1759">国内镜像源</a><a hidden class="anchor" aria-hidden="true" href="#国内镜像源httpsforumsuseorgcntopensuse1759">#</a></h3>
<h4 id="解答">解答<a hidden class="anchor" aria-hidden="true" href="#解答">#</a></h4>
<p>我们官方的态度是不鼓励直接使用镜像的。</p>
<p>因为比起「其它」发行版，我们 openSUSE 的技术力量比较强，开发了两个东西。</p>
<p>一个叫做 <a href="https://en.opensuse.org/SDB:Metalink">Metalink</a>，意思是这个格式（BT、Megalink 磁力链一样的格式）可以自动从 BT/FTP/HTTP 同时下载。</p>
<p>另一个叫做 <a href="https://zh.opensuse.org/MirrorBrain">MirrorBrain</a>，意思是我把所有的镜像地址隐藏起来，只暴露出一个中央服务器，所有人只需使用这个中央服务器（download.opensuse.org ），它会根据你的 IP 地理位置为你分配一个离你最近的镜像，但是在你那边显示的依旧是来自 download.opensuse.org。而如何分配是根据镜像管理员和中央服务器管理员当初的协定来确定的，比如镜像每月能够承受的流量、所愿意扮演的角色（是区域中心、地标式的镜像比如北交大、中科大，还是小镜像）等。</p>
<p>而根据 openSUSE 软件源的构造，所有的 RPM 包都是从镜像获得的，所有的 metadata（元数据）都是从主镜像（位于德国）获得的，所以你源刷新的慢，只能证明你被我们光荣伟大的放火长城拖住了，而不能证明 openSUSE 项目有错，也代表不了你下载 RPM 包时的速度。</p>
<h4 id="更换httpszhopensuseorgsdbe5bfabe9809fe9858de7bdaee68c87e58d97e69bb4e68da2e887b3e59bbde58685e9959ce5838fe6ba90"><a href="https://zh.opensuse.org/SDB:%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97#.E6.9B.B4.E6.8D.A2.E8.87.B3.E5.9B.BD.E5.86.85.E9.95.9C.E5.83.8F.E6.BA.90">更换</a><a hidden class="anchor" aria-hidden="true" href="#更换httpszhopensuseorgsdbe5bfabe9809fe9858de7bdaee68c87e58d97e69bb4e68da2e887b3e59bbde58685e9959ce5838fe6ba90">#</a></h4>
<ol>
<li>
<p>禁用原有软件源</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo zypper mr -da
</code></pre></div></li>
<li>
<p>添加镜像源， 以清华 <a href="https://mirrors.tuna.tsinghua.edu.cn/news/opentuna-mirror/">OpenTUNA</a> 的 Tumbleweed mirror 为例（OpenTUNA 镜像站作为 TUNA 镜像的兄弟站，由清华 TUNA 协会运行维护，提供和 TUNA 镜像站基本一致的镜像内容）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo zypper ar -fcg <span style="color:#e6db74">&#39;https://opentuna.cn/opensuse/tumbleweed/repo/oss/&#39;</span> <span style="color:#e6db74">&#39;OPEN-TUNA:TW:OSS&#39;</span>
$ sudo zypper ar -fcg <span style="color:#e6db74">&#39;https://opentuna.cn/opensuse/tumbleweed/repo/non-oss/&#39;</span> <span style="color:#e6db74">&#39;OPEN-TUNA:TW:NON-OSS&#39;</span>
</code></pre></div><p>命令中最后一个参数为每一个源指定了一个 alias（别称），可以根据个人喜好更改。</p>
</li>
<li>
<p>手动刷新软件源</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo zypper ref
</code></pre></div></li>
</ol>
<h3 id="更新-tumbleweedhttpszhopensuseorgsdbe69bb4e696b0_tumbleweed"><a href="https://zh.opensuse.org/SDB:%E6%9B%B4%E6%96%B0_Tumbleweed">更新 Tumbleweed</a><a hidden class="anchor" aria-hidden="true" href="#更新-tumbleweedhttpszhopensuseorgsdbe69bb4e696b0_tumbleweed">#</a></h3>
<p>无论怎样，下面的内容将完成升级：</p>
<ol>
<li>退出你的桌面环境，在登录管理器中按 CTRL + ALT + F1 进入内核终端界面。</li>
<li>以 root 的身份登录。</li>
<li>输入命令。<code>sudo zypper dup</code>。</li>
<li>处理好任何冲突，然后同意升级。</li>
<li>当升级完成后，输入命令。<code>sudo reboot</code></li>
</ol>
<h3 id="packmanhttpszhopensuseorgpackman"><a href="https://zh.opensuse.org/Packman">Packman</a><a hidden class="anchor" aria-hidden="true" href="#packmanhttpszhopensuseorgpackman">#</a></h3>
<h4 id="什么是-packman-">什么是 Packman ？<a hidden class="anchor" aria-hidden="true" href="#什么是-packman-">#</a></h4>
<p>openSUSE 的 Packman 是 Package man 的缩写。意即指一群打包狂组成的团体。他们在尊重并重视版权的基础上做一些规避专利的事。总之，他们想要自由打包从多媒体到大型软件到游戏到甚至是自己的回收站的所有内容。</p>
<h4 id="packman-和-opensuse-的关系">Packman 和 openSUSE 的关系<a hidden class="anchor" aria-hidden="true" href="#packman-和-opensuse-的关系">#</a></h4>
<p>Packman 不隶属于任何 openSUSE 官方，是独立于 openSUSE 社区之外的社区，只是基于 openSUSE 打给 openSUSE 用的软件包。注意 openSUSE 社区也是官方，同样有在专利法最为严苛的美国和欧洲注册，这也是为什么 OBS 不能打包专利软件的原因，另一个原因是 OBS 的服务器坐落于德国诺伦堡。</p>
<p>Packman 的资源来自于成员捐献，不能和 openSUSE 官方有任何的联系，也就是说即使是 SuSE 的捐献，也要放弃一切权利。不能像社区<a href="https://zh.opensuse.org/openSUSE:%E8%91%A3%E4%BA%8B%E4%BC%9A">董事会</a>那样，主席要由 SuSE 指定，一般是 SuSE 员工。</p>
<p>Packman 欢迎大学和社区为它做<a href="https://zh.opensuse.org/Packman/%E9%95%9C%E5%83%8F%E5%88%97%E8%A1%A8">镜像</a>。</p>
<h4 id="packman-收纳什么样的软件-">Packman 收纳什么样的软件 ？<a hidden class="anchor" aria-hidden="true" href="#packman-收纳什么样的软件-">#</a></h4>
<p>由于英文的 free 很有迷惑性（大部分外国人喜欢用法语 Libre，也就是自由）：</p>
<ul>
<li>这里的自由，仍然不包括商业和私有软件，版权产品应该尊重他们自有的分发渠道。也就是说，这里仍然不做盗版，也不做免费使用的商业软件。不规避版权，只规避专利。版权同样是保护 Linux 下的开源作品不被盗版的力量，而专利则是大公司用来牟利的工具。</li>
<li>这里只接纳由于或有专利纠纷而不能存在于官方构建服务中的软件。比如 FFMPEG，MPLAYER，MP3, AMULE。和依赖它们的软件。以及可以自由分发的软件，并且愿意允许从源代码编译。</li>
</ul>
<p>也就是说，大部分时候这里的软件都是 FOSS/LOSS （自由和开源软件），而不是免费软件。而且是存在或有专利纠纷的软件，想想看什么软件最容易发生专利纠纷呢？ 多媒体。于是 Packman 里有那么多多媒体软件也就不奇怪了。</p>
<p>另外 Packman 还允许两类软件：发行版中长期不更新的软件的最新版，和发行版中没有的软件。但这是 FTP 做源的时代延续下来的。目前这两类软件都建议走 OBS 流程来做，因为 OBS 的服务器比 Packman 的多快好省。</p>
<h4 id="启用-packman-源httpszhopensuseorgsdbe5bfabe9809fe9858de7bdaee68c87e58d97e590afe794a8_packman_e6ba90"><a href="https://zh.opensuse.org/SDB:%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97#.E5.90.AF.E7.94.A8_Packman_.E6.BA.90">启用 Packman 源</a><a hidden class="anchor" aria-hidden="true" href="#启用-packman-源httpszhopensuseorgsdbe5bfabe9809fe9858de7bdaee68c87e58d97e590afe794a8_packman_e6ba90">#</a></h4>
<p>国内可用的 Packman 镜像列表：<a href="https://zh.opensuse.org/Packman/%E9%95%9C%E5%83%8F%E5%88%97%E8%A1%A8">Packman/镜像列表</a>，配置方法详见：<a href="https://zh.opensuse.org/SDB:%E6%B7%BB%E5%8A%A0%E8%BD%AF%E4%BB%B6%E6%BA%90#.E6.B7.BB.E5.8A.A0.E9.95.9C.E5.83.8F.E6.BA.90">添加镜像源</a>。</p>
<p>openSUSE Tumbleweed 用户：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo zypper ar -cfp <span style="color:#ae81ff">90</span> https://mirrors.ustc.edu.cn/packman/suse/openSUSE_Tumbleweed/ packman
$ sudo zypper ref
</code></pre></div><h4 id="install-multimedia-codecshttpsfosspostorgthings-to-do-after-installing-opensuserun_a_system_update"><a href="https://fosspost.org/things-to-do-after-installing-opensuse/#Run_a_System_Update">Install Multimedia Codecs</a><a hidden class="anchor" aria-hidden="true" href="#install-multimedia-codecshttpsfosspostorgthings-to-do-after-installing-opensuserun_a_system_update">#</a></h4>
<p>openSUSE 默认是没有<strong>部分</strong>多媒体编解码器的，包括家喻户晓的 MP3、AVI 等。这是因为它们是<a href="https://zh.opensuse.org/%E5%8F%97%E9%99%90%E5%AA%92%E4%BD%93%E6%A0%BC%E5%BC%8F">受限媒体格式</a>。具体解释见<a href="https://forum.suse.org.cn/viewtopic.php?f=7&amp;t=425">openSUSE 编解码器一键安装、常见编解码器对应软件包/源说明、及版权须知</a>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo zypper in opi <span style="color:#f92672">&amp;&amp;</span> opi codecs
</code></pre></div><p>or, In order to install the H264/AVC support on your system, type in:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo zypper install x264 libx265-130 libx264-148
</code></pre></div><p>或者<a href="https://zh.opensuse.org/SDB:%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97#.E5.AE.89.E8.A3.85.E5.A4.9A.E5.AA.92.E4.BD.93.E8.A7.A3.E7.A0.81.E5.99.A8">通过 Packman 安装解码器</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo zypper refresh
$ sudo zypper dist-upgrade --from packman --allow-vendor-change
$ sudo zypper install --from packman ffmpeg gstreamer-plugins-<span style="color:#f92672">{</span>good,bad,ugly,libav<span style="color:#f92672">}</span> libavcodec-full vlc-codecs
</code></pre></div><p>注：如果不使用 VLC 可以省略 vlc-codecs。</p>
<h3 id="软件管理">软件管理<a hidden class="anchor" aria-hidden="true" href="#软件管理">#</a></h3>
<h4 id="更新刷新进程被占用httpszhopensuseorgsdbe5bfabe9809fe9858de7bdaee68c87e58d97e69bb4e696b02fe588b7e696b0e8bf9be7a88be8a2abe58da0e794a8"><a href="https://zh.opensuse.org/SDB:%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97#.E6.9B.B4.E6.96.B0.2F.E5.88.B7.E6.96.B0.E8.BF.9B.E7.A8.8B.E8.A2.AB.E5.8D.A0.E7.94.A8">更新/刷新进程被占用</a><a hidden class="anchor" aria-hidden="true" href="#更新刷新进程被占用httpszhopensuseorgsdbe5bfabe9809fe9858de7bdaee68c87e58d97e69bb4e696b02fe588b7e696b0e8bf9be7a88be8a2abe58da0e794a8">#</a></h4>
<p>在 System Tray Setting 里面关闭 Software Updates 的通知。</p>
<p>如果你不需要自动更新，或者不需要 Packagekit 本身，你首先可以考虑:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo systemctl mask packagekit.service <span style="color:#75715e">#屏蔽 Packagekit 服务</span>
</code></pre></div><p>或者卸载该软件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo zypper rm Packagekit
</code></pre></div><h4 id="取消推荐的软件包--删除模组httpszhopensuseorgsdbe5bfabe9809fe9858de7bdaee68c87e58d97e58f96e6b688e68ea8e88d90e79a84e8bdafe4bbb6e58c85_26_e588a0e999a4e6a8a1e7bb84"><a href="https://zh.opensuse.org/SDB:%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97#.E5.8F.96.E6.B6.88.E6.8E.A8.E8.8D.90.E7.9A.84.E8.BD.AF.E4.BB.B6.E5.8C.85_.26_.E5.88.A0.E9.99.A4.E6.A8.A1.E7.BB.84">取消推荐的软件包 &amp; 删除模组</a><a hidden class="anchor" aria-hidden="true" href="#取消推荐的软件包--删除模组httpszhopensuseorgsdbe5bfabe9809fe9858de7bdaee68c87e58d97e58f96e6b688e68ea8e88d90e79a84e8bdafe4bbb6e58c85_26_e588a0e999a4e6a8a1e7bb84">#</a></h4>
<p>打开 YaST ，点击 <strong>软件管理</strong> ，再点击左上角的 <strong>依赖项</strong> ，取消勾选 <strong>安装被推荐的软件包</strong> 。这样你的电脑就不会在某次更新后出现一些不是你主动安装的软件包。</p>
<p>在 <strong>软件管理</strong> 页面，点击 <strong>视图</strong>，选择 <strong>模组</strong> ，然后你就能看到按模组分类的包。例如你可以在此页面直接用鼠标右键单击 <strong>游戏</strong> ，选择 <strong>不安装</strong> 或 <strong>卸载</strong>，卸载全部的预装的 KDE/Gnome 游戏包。</p>
<h4 id="obs-package-installer">OBS Package Installer<a hidden class="anchor" aria-hidden="true" href="#obs-package-installer">#</a></h4>
<p>如果你想在终端直接查找来自 OBS 的软件包，你可以先安装 opi</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo zypper in opi
</code></pre></div><p>然后输入你想要查找的软件包的名称，例如你要安装 qbittorrent enhanced edition ，你可以：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ opi qbittorrent
</code></pre></div><h4 id="中文社区源httpszhopensuseorgsdbe5bfabe9809fe9858de7bdaee68c87e58d97e4b8ade69687e7a4bee58cbae6ba90"><a href="https://zh.opensuse.org/SDB:%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97#.E4.B8.AD.E6.96.87.E7.A4.BE.E5.8C.BA.E6.BA.90">中文社区源</a><a hidden class="anchor" aria-hidden="true" href="#中文社区源httpszhopensuseorgsdbe5bfabe9809fe9858de7bdaee68c87e58d97e4b8ade69687e7a4bee58cbae6ba90">#</a></h4>
<p>openSUSE 中文社区的开发者们为用户构建、打包和收录一些发起自中文 Linux 圈子的软件或中文 Linux 圈子常用的软件。详见：</p>
<ul>
<li><a href="https://build.opensuse.org/project/show/home:opensuse_zh">openSUSE for Chinese Users Project </a></li>
</ul>
<h3 id="输入法">输入法<a hidden class="anchor" aria-hidden="true" href="#输入法">#</a></h3>
<p>在Yast中安装第二语言，就会自动安装fcitx并添加中文支持，但是这种方案安装的东西很多。</p>
<h4 id="ibushttpszhopensuseorgibuse7ae80e4bb8b"><a href="https://zh.opensuse.org/Ibus#.E7.AE.80.E4.BB.8B">ibus</a><a hidden class="anchor" aria-hidden="true" href="#ibushttpszhopensuseorgibuse7ae80e4bb8b">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo zypper in ibus ibus-rime
$ vim .bashrc
export GTK_IM_MODULE<span style="color:#f92672">=</span>ibus
export XMODIFIERS<span style="color:#f92672">=</span>@im<span style="color:#f92672">=</span>ibus
export QT_IM_MODULE<span style="color:#f92672">=</span>ibus
$ ibus-daemon -x -d
</code></pre></div><h4 id="fcitx5httpswikiarchlinuxorgtitlefcitx5_e7ae80e4bd93e4b8ade69687e9858de7bdae"><a href="https://wiki.archlinux.org/title/Fcitx5_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E9%85%8D%E7%BD%AE">Fcitx5</a><a hidden class="anchor" aria-hidden="true" href="#fcitx5httpswikiarchlinuxorgtitlefcitx5_e7ae80e4bd93e4b8ade69687e9858de7bdae">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo zypper in fcitx5
$ sudo vim /etc/environment
GTK_IM_MODULE<span style="color:#f92672">=</span>fcitx
QT_IM_MODULE<span style="color:#f92672">=</span>fcitx
XMODIFIERS<span style="color:#f92672">=</span>@im<span style="color:#f92672">=</span>fcitx
</code></pre></div><p>设置主题：<em>Setting -&gt; Location -&gt; input method -&gt; Configure addons -&gt; Classic user interface -&gt; Theme</em>.</p>
<h5 id="词库">词库<a hidden class="anchor" aria-hidden="true" href="#词库">#</a></h5>
<p>Fcitx 的 Libpinyin 可以直接在线导入<a href="http://pinyin.sogou.com/dict/">搜狗细胞词库</a>。不需要安装sougou输入法。</p>
<p>需要安装 fcitx-pinyin-tools/fcitx-table-tools 这两个包，以<a href="https://forum.suse.org.cn/t/libpinyin/3814/2">添加处理词库的工具</a>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo zypper in fcitx-pinyin-tools fcitx-table-tools
</code></pre></div><p>词库少了的话，也不好用，但是一次只能导入一个细胞词库。网上可以找到比较全的词库包。</p>
<p>通过 7zr 解压过后将所有 txt 词库拷贝到 <code>~/.config/fcitx/libpinyin/importdict</code> 即可。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ 7zr x txt.7z
</code></pre></div><h5 id="cloudpinyin">cloudpinyin<a hidden class="anchor" aria-hidden="true" href="#cloudpinyin">#</a></h5>
<p>根据<a href="https://zh.opensuse.org/Fcitx">文档</a>，可以使用 libpinyin + cloudpinyin，哪怕不用导入词典，依旧很好用。果然，还是云词库的力量强大。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo zypper in fcitx-cloudpinyin
</code></pre></div><p>默认的云输入引擎是 Google ，国内直接访问很不流畅，你可以打开输入法的配置，点击 Addon Config，找到 Cloud Pinyin ，点击右侧的设置，在弹出的窗口中，将 Google 替换为 Baidu 。</p>
<h5 id="搜狗拼音">搜狗拼音<a hidden class="anchor" aria-hidden="true" href="#搜狗拼音">#</a></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo opi sogou-pinyin
</code></pre></div><p>有点问题。</p>
<h3 id="nvidiahttpszhopensuseorgsdbnvidia"><a href="https://zh.opensuse.org/SDB:NVIDIA">NVIDIA</a><a hidden class="anchor" aria-hidden="true" href="#nvidiahttpszhopensuseorgsdbnvidia">#</a></h3>
<p>有两种为英伟达（NVIDIA）显卡提供的驱动：</p>
<ul>
<li>为 NVIDIA 硬件提供的自由开源的驱动名叫 nouveau。</li>
<li>来自 NVIDIA 厂商自己的驱动名为 nvidia，但由于许可证问题，它不能直接被集成进入 openSUSE 。</li>
</ul>
<p>如果你没有特别的需求，NVIDIA 的闭源驱动不是必须安装的。持有 NVIDIA 独立显卡之类厂商只提供闭源驱动的硬件的 Tumbleweed 用户请不要过于频繁地更新系统，闭源驱动可能会因为内核版本太新缺乏适配而崩溃。</p>
<h4 id="安装">安装<a hidden class="anchor" aria-hidden="true" href="#安装">#</a></h4>
<p>添加 Nvdia 软件源</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo zypper addrepo --refresh <span style="color:#e6db74">&#39;https://download.nvidia.com/opensuse/leap/$releasever&#39;</span> NVIDIA
</code></pre></div><p>确定显卡型号</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo hwinfo --gfxcard | grep Model
</code></pre></div><p>安装驱动</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo zypper in x11-video-nvidiaG05
</code></pre></div><p>最后，重启电脑确认是否加载</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo lsmod | grep nvidia 
</code></pre></div><h4 id="画面撕裂">画面撕裂<a hidden class="anchor" aria-hidden="true" href="#画面撕裂">#</a></h4>
<p>出现此种情况，你必须打开 “PRIME同步” 功能：</p>
<ol>
<li>创建文件</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo echo <span style="color:#e6db74">&#34;options nvidia_drm modeset=1 &#34;</span> &gt; /etc/modprobe.d/nvidia-drm-nomodeset.conf 
</code></pre></div><ol start="2">
<li>执行代码：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo dracut -f
</code></pre></div><p>重启</p>
<p><strong>注意：</strong> 在某些情况下，修改此配置可能会导致图形界面无法进入，若出现此情况，请进入重启后进入恢复模式，执行 <code>sudo rm /etc/modprobe.d/nvidia-drm-nomodeset.conf</code> ，然后执行 <code>dracut -f</code> ，然后重启</p>
<h3 id="audacioushttpsaudacious-media-playerorg"><a href="https://audacious-media-player.org/">Audacious</a><a hidden class="anchor" aria-hidden="true" href="#audacioushttpsaudacious-media-playerorg">#</a></h3>
<p>一个设计简洁，功能强大，支持多种格式的无损播放器。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo zypper in audacious
</code></pre></div><h3 id="openzfshttpsenopensuseorgopenzfszfs_openzfs_and_zfs_on_linux"><a href="https://en.opensuse.org/OpenZFS#ZFS,_OpenZFS_and_ZFS_on_Linux">OpenZFS</a><a hidden class="anchor" aria-hidden="true" href="#openzfshttpsenopensuseorgopenzfszfs_openzfs_and_zfs_on_linux">#</a></h3>
<p>openSUSE Tumbleweed</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo zypper ar https://download.opensuse.org/repositories/filesystems/openSUSE_Tumbleweed/filesystems.repo
$ sudo zypper ref
$ sudo zypper in zfs
</code></pre></div><h2 id="opensuse-system">openSUSE System<a hidden class="anchor" aria-hidden="true" href="#opensuse-system">#</a></h2>
<h3 id="btrfshttpszhuanlanzhihucomp61407714"><a href="https://zhuanlan.zhihu.com/p/61407714">Btrfs</a><a hidden class="anchor" aria-hidden="true" href="#btrfshttpszhuanlanzhihucomp61407714">#</a></h3>
<p>文件系统似乎是内核中比较稳定的部分，多年来，人们一直使用 ext2/3，ext 文件系统以其卓越的稳定性成为了事实上的 Linux 标准文件系统。近年来 ext2/3 暴露出了一些扩展性问题，于是便催生了 ext4 。在 2008 年发布的 Linux2.6.19 内核中集成了 ext4 的 dev 版本。 2.6.28 内核发布时，ext4 结束了开发版，开始接受用户的使用。似乎 ext 就将成为 Linux 文件系统的代名词。然而当您阅读很多有关 ext4 的文章时，会发现都不约而同地提到了 btrfs，并认为 ext4 将是一个过渡的文件系统。 ext4 的作者 Theodore Tso 也盛赞 btrfs 并认为 btrfs 将成为下一代 Linux 标准文件系统。 Oracle，IBM， Intel 等厂商也对 btrfs 表现出了极大的关注，投入了资金和人力。为什么 btrfs 如此受人瞩目呢。这便是本文首先想探讨的问题。</p>
<p>Kevin Bowling 有一篇介绍各种文件系统的文章，在他看来，ext2/3 等文件系统属于“古典时期”。文件系统的新时代是 2005 年由 Sun 公司的 ZFS 开创的。 ZFS 代表” last word in file system ”，意思是此后再也不需要开发其他的文件系统了。 ZFS 的确带来了很多崭新的观念，对文件系统来讲是一个划时代的作品。</p>
<p>如果您比较 btrfs 的特性，将会发现 btrfs 和 ZFS 非常类似。也许我们可以认为 btrfs 就是 Linux 社区对 ZFS 所作出的回应。从此往后在 Linux 中也终于有了一个可以和 ZFS 相媲美的文件系统。</p>
<h4 id="btrfs-的特性">Btrfs 的特性<a hidden class="anchor" aria-hidden="true" href="#btrfs-的特性">#</a></h4>
<p>您可以在 <a href="https://btrfs.wiki.kernel.org/index.php/Main_Page">btrfs 的主页</a>上看到 btrfs 的特性列表。我自作主张，将那张列表分成了四大部分。</p>
<p>首先是扩展性 (scalability) 相关的特性，btrfs 最重要的设计目标是应对大型机器对文件系统的扩展性要求。 Extent，B-Tree 和动态 inode 创建等特性保证了 btrfs 在大型机器上仍有卓越的表现，其整体性能而不会随着系统容量的增加而降低。</p>
<p>其次是数据一致性 (data integrity) 相关的特性。系统面临不可预料的硬件故障，Btrfs 采用 COW 事务技术来保证文件系统的一致性。 btrfs 还支持 checksum，避免了 silent corrupt 的出现。而传统文件系统则无法做到这一点。</p>
<p>第三是和多设备管理相关的特性。 Btrfs 支持创建快照 (snapshot)，和克隆 (clone) 。 btrfs 还能够方便的管理多个物理设备，使得传统的卷管理软件变得多余。</p>
<p>最后是其他难以归类的特性。这些特性都是比较先进的技术，能够显著提高文件系统的时间 / 空间性能，包括延迟分配，小文件的存储优化，目录索引等。</p>
<h5 id="扩展性相关的特性">扩展性相关的特性<a hidden class="anchor" aria-hidden="true" href="#扩展性相关的特性">#</a></h5>
<p><strong>B-Tree</strong></p>
<p>btrfs 文件系统中所有的 metadata 都由 BTree 管理。使用 BTree 的主要好处在于查找，插入和删除操作都很高效。可以说 BTree 是 btrfs 的核心。</p>
<p>一味地夸耀 BTree 很好很高效也许并不能让人信服，但假如稍微花费一点儿时间看看 ext2/3 中元数据管理的实现方式，便可以反衬出 BTree 的优点。</p>
<p>妨碍 ext2/3 扩展性的一个问题来自其目录的组织方式。目录是一种特殊的文件，在 ext2/3 中其内容是一张线性表格。</p>
<p><img loading="lazy" src="/Distributions/ext2-directory.jpg" alt=""  />
</p>
<p>图中展示了一个 ext2 目录文件的内容，该目录中包含四个文件。分别是 &ldquo;home1&rdquo;，&ldquo;usr&rdquo;，&ldquo;oldfile&rdquo; 和 &ldquo;sbin&rdquo; 。如果需要在该目录中查找目录 sbin，ext2 将遍历前三项，直至找到 sbin 这个字符串为止。</p>
<p>这种结构在文件个数有限的情况下是比较直观的设计，但随着目录下文件数的增加，查找文件的时间将线性增长。 2003 年，ext3 设计者开发了目录索引技术，解决了这个问题。目录索引使用的数据结构就是 BTree 。如果同一目录下的文件数超过 2K，inode 中的 i_data 域指向一个特殊的 block 。在该 block 中存储着目录索引 BTree 。 BTree 的查找效率高于线性表，</p>
<p>但为同一个元数据设计两种数据结构总是不太优雅。在文件系统中还有很多其他的元数据，用统一的 BTree 管理是非常简单而优美的设计。</p>
<p>Btrfs 内部所有的元数据都采用 BTree 管理，拥有良好的可扩展性。 btrfs 内部不同的元数据由不同的 Tree 管理。在 superblock 中，有指针指向这些 BTree 的根。如图 2 所示：</p>
<p><img loading="lazy" src="/Distributions/btrfs-btree.jpg" alt=""  />
</p>
<p>FS Tree 管理文件相关的元数据，如 inode，dir 等； Chunk tree 管理设备，每一个磁盘设备都在 Chunk Tree 中有一个 item ； Extent Tree 管理磁盘空间分配，btrfs 每分配一段磁盘空间，便将该磁盘空间的信息插入到 Extent tree 。查询 Extent Tree 将得到空闲的磁盘空间信息； Tree of tree root 保存很多 BTree 的根节点。比如用户每建立一个快照，btrfs 便会创建一个 FS Tree 。为了管理所有的树，btrfs 采用 Tree of tree root 来保存所有树的根节点； checksum Tree 保存数据块的校验和。</p>
<p><strong>基于 Extent 的文件存储</strong></p>
<p>现代很多文件系统都采用了 extent 替代 block 来管理磁盘。 Extent 就是一些连续的 block，一个 extent 由起始的 block 加上长度进行定义。</p>
<p>Extent 能有效地减少元数据开销。为了进一步理解这个问题，我们还是看看 ext2 中的反面例子。</p>
<p>ext2/3 以 block 为基本单位，将磁盘划分为多个 block 。为了管理磁盘空间，文件系统需要知道哪些 block 是空闲的。 Ext 使用 bitmap 来达到这个目的。 Bitmap 中的每一个 bit 对应磁盘上的一个 block，当相应 block 被分配后，bitmap 中的相应 bit 被设置为 1 。这是很经典也很清晰的一个设计，但不幸的是当磁盘容量变大时，bitmap 自身所占用的空间也将变大。这就导致了扩展性问题，随着存储设备容量的增加，bitmap 这个元数据所占用的空间也随之增加。而人们希望无论磁盘容量如何增加，元数据不应该随之线形增加，这样的设计才具有可扩展性。</p>
<p>下图比较了 block 和 extent 的区别：</p>
<p><img loading="lazy" src="/Distributions/extent-vs-bitmap.jpg" alt=""  />
</p>
<p>在 ext2/3 中，10 个 block 需要 10 个 bit 来表示；在 btrfs 中则只需要一个元数据。对于大文件，extent 表现出了更加优异的管理性能。</p>
<p>Extent 是 btrfs 管理磁盘空间的最小单位，由 extent tree 管理。 Btrfs 分配 data 或 metadata 都需要查询 extent tree 以便获得空闲空间的信息。</p>
<p><strong>动态 inode 分配</strong></p>
<p>为了理解动态 inode 分配，还是需要借助 ext2/3 。下表列举了 ext2 文件系统的限制：</p>
<p>限制<strong>最大文件数量</strong>文件系统空间大小 V / 8192</p>
<p>比如 100G 大小的文件系统中，能创建的文件个数最大为 131072</p>
<p>下图显示了 ext2 的磁盘布局：</p>
<p><img loading="lazy" src="/Distributions/ext2-layout.jpg" alt=""  />
</p>
<p>在 ext2 中 inode 区是被预先固定分配的，且大小固定，比如一个 100G 的分区中，inode table 区中只能存放 131072 个 inode，这就意味着不可能创建超过 131072 个文件，因为每一个文件都必须有一个唯一的 inode 。</p>
<p>为了解决这个问题，必须动态分配 inode 。每一个 inode 只是 BTree 中的一个节点，用户可以无限制地任意插入新的 inode，其物理存储位置是动态分配的。所以 btrfs 没有对文件个数的限制。</p>
<p><strong>针对 SSD 的优化支持</strong></p>
<p>SSD 是固态存储 Solid State Disk 的简称。在过去的几十年中，CPU/RAM 等器件的发展始终遵循着摩尔定律，但硬盘 HDD 的读写速率却始终没有飞跃式的发展。磁盘 IO 始终是系统性能的瓶颈。</p>
<p>SSD 采用 flash memory 技术，内部没有磁盘磁头等机械装置，读写速率大幅度提升。 flash memory 有一些不同于 HDD 的特性。 flash 在写数据之前必须先执行擦除操作；其次，flash 对擦除操作的次数有一定的限制，在目前的技术水平下，对同一个数据单元最多能进行约 100 万次擦除操作，因此，为了延长 flash 的寿命，应该将写操作平均到整个 flash 上。</p>
<p>SSD 在硬件内部的微代码中实现了 wear leveling 等分布写操作的技术，因此系统无须再使用特殊的 MTD 驱动和 FTL 层。虽然 SSD 在硬件层面做了很多努力，但毕竟还是有限。文件系统针对 SSD 的特性做优化不仅能提高 SSD 的使用寿命，而且能提高读写性能。 Btrfs 是少数专门对 SSD 进行优化的文件系统。 btrfs 用户可以使用 mount 参数打开对 SSD 的特殊优化处理。</p>
<p>Btrfs 的 COW 技术从根本上避免了对同一个物理单元的反复写操作。如果用户打开了 SSD 优化选项，btrfs 将在底层的块空间分配策略上进行优化：将多次磁盘空间分配请求聚合成一个大小为 2M 的连续的块。大块连续地址的 IO 能够让固化在 SSD 内部的微代码更好的进行读写优化，从而提高 IO 性能。</p>
<h5 id="数据一致性相关的特性">数据一致性相关的特性<a hidden class="anchor" aria-hidden="true" href="#数据一致性相关的特性">#</a></h5>
<p><strong>COW 事务</strong></p>
<p>理解 COW 事务，必须首先理解 COW 和事务这两个术语。</p>
<p>所谓 COW，即每次写磁盘数据时，先将更新数据写入一个新的 block，当新数据写入成功之后，再更新相关的数据结构指向新 block 。</p>
<p>COW 只能保证单一数据更新的原子性。但文件系统中很多操作需要更新多个不同的元数据，比如创建文件需要修改以下这些元数据：</p>
<ol>
<li>修改 extent tree，分配一段磁盘空间</li>
<li>创建一个新的 inode，并插入 FS Tree 中</li>
<li>增加一个目录项，插入到 FS Tree 中</li>
</ol>
<p>任何一个步骤出错，文件便不能创建成功，因此可以定义为一个事务。</p>
<p>下面将演示一个 COW 事务。</p>
<p>A 是 FS Tree 的根节点，新的 inode 的信息将被插入节点 C 。首先，btrfs 将 inode 插入一个新分配的 block C ’中，并修改上层节点 B，使其指向新的 block C ’；修改 B 也将引发 COW，以此类推，引发一个连锁反应，直到最顶层的 Root A 。当整个过程结束后，新节点 A ’变成了 FS Tree 的根。但此时事务并未结束，superblock 依然指向 A 。</p>
<p><img loading="lazy" src="/Distributions/COWtransaction1.jpg" alt=""  />
</p>
<p>接下来，修改目录项（E 节点），同样引发这一过程，从而生成新的根节点 A ’’。</p>
<p><img loading="lazy" src="/Distributions/COWtransaction2.jpg" alt=""  />
</p>
<p>此时，inode 和目录项都已经写入磁盘，可以认为事务已经结束。 btrfs 修改 superblock，使其指向 A ’’，如下图所示：</p>
<p><img loading="lazy" src="/Distributions/COWtransaction3.jpg" alt=""  />
</p>
<p>COW 事务能够保证文件系统的一致性，并且系统 Reboot 之后不需要执行 fsck 。因为 superblock 要么指向新的 A ’’，要么指向 A，无论哪个都是一致的数据。</p>
<p><strong>Checksum</strong></p>
<p>Checksum 技术保证了数据的可靠性，避免 silent corruption 现象。由于硬件原因，从磁盘上读出的数据会出错。比如 block A 中存放的数据为 0x55，但读取出来的数据变是 0x54，因为读取操作并未报错，所以这种错误不能被上层软件所察觉。</p>
<p>解决这个问题的方法是保存数据的校验和，在读取数据后检查校验和。如果不符合，便知道数据出现了错误。</p>
<p>ext2/3 没有校验和，对磁盘完全信任。而不幸的是，磁盘的错误始终存在，不仅发生在廉价的 IDE 硬盘上，昂贵的 RAID 也存在 silent corruption 问题。而且随着存储网络的发展，即使数据从磁盘读出正确，也很难确保能够安全地穿越网络设备。</p>
<p>btrfs 在读取数据的同时会读取其相应的 checksum 。如果最终从磁盘读取出来的数据和 checksum 不相同，btrfs 会首先尝试读取数据的镜像备份，如果数据没有镜像备份，btrfs 将返回错误。写入磁盘数据之前，btrfs 计算数据的 checksum 。然后将 checksum 和数据同时写入磁盘。</p>
<p>Btrfs 采用单独的 checksum Tree 来管理数据块的校验和，把 checksum 和 checksum 所保护的数据块分离开，从而提供了更严格的保护。假如在每个数据 block 的 header 中加入一个域保存 checksum，那么这个数据 block 就成为一个自己保护自己的结构。这种结构下有一种错误无法检测出来，比如本来文件系统打算从磁盘上读 block A，但返回了 block B，由于 checksum 在 block 内部，因此 checksum 依旧是正确的。 btrfs 采用 checksum tree 来保存数据块的 checksum，避免了上述问题。</p>
<p>Btrfs 采用 crc32 算法计算 checksum，在将来的开发中会支持其他类型的校验算法。为了提高效率，btrfs 将写数据和 checksum 的工作分别用不同的内核线程并行执行。</p>
<h5 id="多设备管理相关的特性">多设备管理相关的特性<a hidden class="anchor" aria-hidden="true" href="#多设备管理相关的特性">#</a></h5>
<p>每个 Unix 管理员都曾面临为用户和各种应用分配磁盘空间的任务。多数情况下，人们无法事先准确地估计一个用户或者应用在未来究竟需要多少磁盘空间。磁盘空间被用尽的情况经常发生，此时人们不得不试图增加文件系统空间。传统的 ext2/3 无法应付这种需求。</p>
<p>很多卷管理软件被设计出来满足用户对多设备管理的需求，比如 LVM 。 Btrfs 集成了卷管理软件的功能，一方面简化了用户命令；另一方面提高了效率。</p>
<p><strong>多设备管理</strong></p>
<p>Btrfs 支持动态添加设备。用户在系统中增加新的磁盘之后，可以使用 btrfs 的命令将该设备添加到文件系统中。</p>
<p>为了灵活利用设备空间，Btrfs 将磁盘空间划分为多个 chunk 。每个 chunk 可以使用不同的磁盘空间分配策略。比如某些 chunk 只存放 metadata，某些 chunk 只存放数据。一些 chunk 可以配置为 mirror，而另一些 chunk 则可以配置为 stripe 。这为用户提供了非常灵活的配置可能性。</p>
<p><strong>Subvolume</strong></p>
<p>Subvolume 是很优雅的一个概念。即把文件系统的一部分配置为一个完整的子文件系统，称之为 subvolume 。</p>
<p>采用 subvolume，一个大的文件系统可以被划分为多个子文件系统，这些子文件系统共享底层的设备空间，在需要磁盘空间时便从底层设备中分配，类似应用程序调用 malloc() 分配内存一样。可以称之为存储池。这种模型有很多优点，比如可以充分利用 disk 的带宽，可以简化磁盘空间的管理等。</p>
<p>所谓充分利用 disk 的带宽，指文件系统可以并行读写底层的多个 disk，这是因为每个文件系统都可以访问所有的 disk 。传统的文件系统不能共享底层的 disk 设备，无论是物理的还是逻辑的，因此无法做到并行读写。</p>
<p>所谓简化管理，是相对于 LVM 等卷管理软件而言。采用存储池模型，每个文件系统的大小都可以自动调节。而使用 LVM，如果一个文件系统的空间不够了，该文件系统并不能自动使用其他磁盘设备上的空闲空间，而必须使用 LVM 的管理命令手动调节。</p>
<p>Subvolume 可以作为根目录挂载到任意 mount 点。 subvolume 是非常有趣的一个特性，有很多应用。</p>
<p>假如管理员只希望某些用户访问文件系统的一部分，比如希望用户只能访问 /var/test/ 下面的所有内容，而不能访问 /var/ 下面其他的内容。那么便可以将 /var/test 做成一个 subvolume 。 /var/test 这个 subvolume 便是一个完整的文件系统，可以用 mount 命令挂载。比如挂载到 /test 目录下，给用户访问 /test 的权限，那么用户便只能访问 /var/test 下面的内容了。</p>
<p><strong>快照和克隆</strong></p>
<p>快照是对文件系统某一时刻的完全备份。建立快照之后，对文件系统的修改不会影响快照中的内容。这是非常有用的一种技术。</p>
<p>比如数据库备份。假如在时间点 T1，管理员决定对数据库进行备份，那么他必须先停止数据库。备份文件是非常耗时的操作，假如在备份过程中某个应用程序修改了数据库的内容，那么将无法得到一个一致性的备份。因此在备份过程中数据库服务必须停止，对于某些关键应用这是不能允许的。</p>
<p>利用快照，管理员可以在时间点 T1 将数据库停止，对系统建立一个快照。这个过程一般只需要几秒钟，然后就可以立即重新恢复数据库服务。此后在任何时候，管理员都可以对快照的内容进行备份操作，而此时用户对数据库的修改不会影响快照中的内容。当备份完成，管理员便可以删除快照，释放磁盘空间。</p>
<p>快照一般是只读的，当系统支持可写快照，那么这种可写快照便被称为克隆。克隆技术也有很多应用。比如在一个系统中安装好基本的软件，然后为不同的用户做不同的克隆，每个用户使用自己的克隆而不会影响其他用户的磁盘空间。非常类似于虚拟机。</p>
<p>Btrfs 支持 snapshot 和 clone 。这个特性极大地增加了 btrfs 的使用范围，用户不需要购买和安装昂贵并且使用复杂的卷管理软件。下面简要介绍一下 btrfs 实现快照的基本原理。</p>
<p>如前所述 Btrfs 采用 COW 事务技术，从图 COW transaction 3 可以看到，COW 事务结束后，如果不删除原来的节点 A,C,E，那么 A,C,E,D,F 依然完整的表示着事务开始之前的文件系统。这就是 snapshot 实现的基本原理。</p>
<p>Btrfs 采用引用计数决定是否在事务 commit 之后删除原有节点。对每一个节点，btrfs 维护一个引用计数。当该节点被别的节点引用时，该计数加一，当该节点不再被别的节点引用时，该计数减一。当引用计数归零时，该节点被删除。对于普通的 Tree Root, 引用计数在创建时被加一，因为 Superblock 会引用这个 Root block 。很明显，初始情况下这棵树中的所有其他节点的引用计数都为一。当 COW 事务 commit 时，superblock 被修改指向新的 Root A ’’，原来 Root block A 的引用计数被减一，变为零，因此 A 节点被删除。 A 节点的删除会引发其子孙节点的引用计数也减一，图 COW transaction 3 中的 B，C 节点的引用计数因此也变成了 0，从而被删除。 D,E 节点在 COW 时，因为被 A ’’所引用，计数器加一，因此计数器这时并未归零，从而没有被删除。</p>
<p>创建 Snapshot 时，btrfs 将的 Root A 节点复制到 sA，并将 sA 的引用计数设置为 2 。在事务 commit 的时候，sA 节点的引用计数不会归零，从而不会被删除，因此用户可以继续通过 Root sA 访问 snapshot 中的文件。</p>
<p><img loading="lazy" src="/Distributions/Snapshot.jpg" alt=""  />
</p>
<p><strong>软件 RAID</strong></p>
<p>RAID 技术有很多非常吸引人的特性，比如用户可以将多个廉价的 IDE 磁盘组合为 RAID0 阵列，从而变成了一个大容量的磁盘； RAID1 和更高级的 RAID 配置还提供了数据冗余保护，从而使得存储在磁盘中的数据更加安全。</p>
<p>Btrfs 很好的支持了软件 RAID，RAID 种类包括 RAID0,RAID1 和 RAID10.</p>
<p>Btrfs 缺省情况下对 metadata 进行 RAID1 保护。前面已经提及 btrfs 将设备空间划分为 chunk，一些 chunk 被配置为 metadata，即只存储 metadata 。对于这类 chunk，btrfs 将 chunk 分成两个条带，写 metadata 的时候，会同时写入两个条带内，从而实现对 metadata 的保护。</p>
<h5 id="其他特性">其他特性<a hidden class="anchor" aria-hidden="true" href="#其他特性">#</a></h5>
<p>Btrfs 主页上罗列的其他特性不容易分类，这些特性都是现代文件系统中比较先进的技术，能够提高文件系统的时间或空间效率。</p>
<p><strong>Delay allocation</strong></p>
<p>延迟分配技术能够减少磁盘碎片。在 Linux 内核中，为了提高效率，很多操作都会延迟。</p>
<p>在文件系统中，小块空间频繁的分配和释放会造成碎片。延迟分配是这样一种技术，当用户需要磁盘空间时，先将数据保存在内存中。并将磁盘分配需求发送给磁盘空间分配器，磁盘空间分配器并不立即分配真正的磁盘空间。只是记录下这个请求便返回。</p>
<p>磁盘空间分配请求可能很频繁，所以在延迟分配的一段时间内，磁盘分配器可以收到很多的分配请求，一些请求也许可以合并，一些请求在这段延迟期间甚至可能被取消。通过这样的“等待”，往往能够减少不必要的分配，也有可能将多个小的分配请求合并为一个大的请求，从而提高 IO 效率。</p>
<p><strong>Inline file</strong></p>
<p>系统中往往存在大量的小文件，比如几百个字节或者更小。如果为其分配单独的数据 block，便会引起内部碎片，浪费磁盘空间。 btrfs 将小文件的内容保存在元数据中，不再额外分配存放文件数据的磁盘块。改善了内部碎片问题，也增加了文件的访问效率。</p>
<p><img loading="lazy" src="/Distributions/inline-file.jpg" alt=""  />
</p>
<p>上图显示了一个 BTree 的叶子节点。叶子中有两个 extent data item 元数据，分别用来表示文件 file1 和 file2 所使用的磁盘空间。</p>
<p>假设 file1 的大小仅为 15 个字节； file2 的大小为 1M 。如图所示，file2 采用普通的 extent 表示方法：extent2 元数据指向一段 extent，大小为 1M，其内容便是 file2 文件的内容。</p>
<p>而对于 file1， btrfs 会把其文件内容内嵌到元数据 extent1 中。如果不采用 inline file 技术。如虚线所示，extent1 指向一个最小的 extent，即一个 block，但 file1 有 15 个字节，其余的空间便成为了碎片空间。</p>
<p>采用 inline 技术，读取 file1 时只需要读取元数据 block，而无需先读取 extent1 这个元数据，再读取真正存放文件内容的 block，从而减少了磁盘 IO 。</p>
<p>得益于 inline file 技术，btrfs 处理小文件的效率非常高，也避免了磁盘碎片问题。</p>
<p><strong>Directory index</strong></p>
<p>当一个目录下的文件数目巨大时，目录索引可以显著提高文件搜索时间。 Btrfs 本身采用 BTree 存储目录项，所以在给定目录下搜索文件的效率是非常高的。</p>
<p>然而，btrfs 使用 BTree 管理目录项的方式无法同时满足 readdir 的需求。 readdir 是 POSIX 标准 API，它要求返回指定目录下的所有文件，并且特别的，这些文件要按照 inode number 排序。而 btrfs 目录项插入 BTree 时的 Key 并不是 Inode number，而是根据文件名计算的一个 hash 值。这种方式在查找一个特定文件时非常高效，但却不适于 readdir 。为此，btrfs 在每次创建新的文件时，除了插入以 hash 值为 Key 的目录项外，还同时插入另外一种目录项索引，该目录项索引的 KEY 以 sequence number 作为 BTree 的键值。这个 sequence number 在每次创建新文件时线性增加。因为 Inode number 也是每次创建新文件时增加的，所以 sequence number 和 inode number 的顺序相同。以这种 sequence number 作为 KEY 在 BTree 中查找便可以方便的得到一个以 inode number 排序的文件列表。</p>
<p>另外以 sequence number 排序的文件往往在磁盘上的位置也是相邻的，所以以 sequence number 为序访问大量文件会获得更好的 IO 效率。</p>
<p><strong>压缩</strong></p>
<p>大家都曾使用过 zip，winrar 等压缩软件，将一个大文件进行压缩可以有效节约磁盘空间。 Btrfs 内置了压缩功能。</p>
<p>通常人们认为将数据写入磁盘之前进行压缩会占用很多的 CPU 计算时间，必然降低文件系统的读写效率。但随着硬件技术的发展，CPU 处理时间和磁盘 IO 时间的差距不断加大。在某些情况下，花费一定的 CPU 时间和一些内存，但却能大大节约磁盘 IO 的数量，这反而能够增加整体的效率。</p>
<p>比如一个文件不经过压缩的情况下需要 100 次磁盘 IO 。但花费少量 CPU 时间进行压缩后，只需要 10 次磁盘 IO 就可以将压缩后的文件写入磁盘。在这种情况下，IO 效率反而提高了。当然，这取决于压缩率。目前 btrfs 采用 zlib 提供的 DEFALTE/INFLATE 算法进行压缩和解压。在将来，btrfs 应该可以支持更多的压缩算法，满足不同用户的不同需求。</p>
<p>目前 btrfs 的压缩特性还存在一些不足，当压缩使能后，整个文件系统下的所有文件都将被压缩，但用户可能需要更细粒度的控制，比如针对不同的目录采用不同的压缩算法，或者禁止压缩。我相信，btrfs 开发团队将在今后的版本中解决这个问题。</p>
<p>对于某些类型的文件，比如 jpeg 文件，已经无法再进行压缩。尝试对其压缩将纯粹浪费 CPU 。为此，当对某文件的若干个 block 压缩后发现压缩率不佳，btrfs 将不会再对文件的其余部分进行压缩操作。这个特性在某种程度上提高了文件系统的 IO 效率。</p>
<p><strong>预分配</strong></p>
<p>很多应用程序有预先分配磁盘空间的需要。他们可以通过 posix_fallocate 接口告诉文件系统在磁盘上预留一部分空间，但暂时并不写入数据。如果底层文件系统不支持 fallocate，那么应用程序只有使用 write 预先写一些无用信息以便为自己预留足够的磁盘空间。</p>
<p>由文件系统来支持预留空间更加有效，而且能够减少磁盘碎片，因为所有的空间都是一次分配，因而更有可能使用连续的空间。 Btrfs 支持 posix_fallocate 。</p>
<h5 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h5>
<p>至此，我们对 btrfs 的很多特性进行了较为详细的探讨，但 btrfs 能提供的特性却并不止这些。 btrfs 正处于试验开发阶段，还将有更多的特性。</p>
<p>Btrfs 也有一个重要的缺点，当 BTree 中某个节点出现错误时，文件系统将失去该节点之下的所有的文件信息。而 ext2/3 却避免了这种被称为”错误扩散”的问题。</p>
<p>但无论怎样，希望您和我一样，开始认同 btrfs 将是 Linux 未来最有希望的文件系统。</p>
<h4 id="btrfs-使用httpswikiarchlinuxorgtitlebtrfs_e7ae80e4bd93e4b8ade69687"><a href="https://wiki.archlinux.org/title/Btrfs_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Btrfs 使用</a><a hidden class="anchor" aria-hidden="true" href="#btrfs-使用httpswikiarchlinuxorgtitlebtrfs_e7ae80e4bd93e4b8ade69687">#</a></h4>
<p>了解了 btrfs 的特性，想必您一定想亲身体验一下 btrfs 的使用。本章将简要介绍如何使用 btrfs 。</p>
<p>要使用一些用户空间工具的话，需要 安装 基础操作必须的 btrfs-progs 软件包。</p>
<h5 id="创建文件系统">创建文件系统<a hidden class="anchor" aria-hidden="true" href="#创建文件系统">#</a></h5>
<p><strong>单一设备上的文件系统</strong></p>
<p>要在分区 <code>/dev/partition</code> 上创建一个 Btrfs 文件系统，执行：</p>
<pre tabindex="0"><code># mkfs.btrfs -L mylabel /dev/partition
</code></pre><p>Btrfs 用于元数据的默认节点大小 (nodesize) 为 16KB，而用于数据的默认扇区大小 (sectorsize) 等于页面大小 (page size) 并会自动检测。 要对元数据使用较大的节点大小 (必须为扇区大小的倍数，最大允许 64KB)，请通过 <code>-n</code> 开关为 <code>nodesize</code> 指定一个值。如下例所示，使用 32KB 块大小：</p>
<pre tabindex="0"><code># mkfs.btrfs -L mylabel -n 32k /dev/partition
</code></pre><p><strong>注意：</strong> 根据 <a href="https://man.archlinux.org/man/mkfs.btrfs.8#OPTIONS">mkfs.btrfs(8) § OPTIONS</a> 手册页内容：“较小的节点大小会增加碎片，但也会让 B-trees 更高，进而使得锁定争用（locking contention）更少。较高的节点大小则能有更好的打包（packing）和更少的碎片，但代价是，更新元数据块时会使用更多的内存”。</p>
<p><strong>多设备文件系统 RAID</strong></p>
<p>多个设备可以用来创建一组 RAID。支持的 RAID 级别有 RAID 0、RAID 1、RAID 10、RAID 5 和 RAID 6。从 5.5 版本内核开始，新增对 <code>RAID1c3</code> 和 <code>RAID1c4</code> 的支持，分别是 3 份冗余和 4 份冗余的 RAID 1。可以使用 <code>-d</code> 和 <code>-m</code> 参数分别为数据和元数据配置 RAID 等级。默认情况下，数据有一份副本（<code>single</code>），元数据则被镜像（<code>RAID1</code>）。</p>
<pre tabindex="0"><code># mkfs.btrfs -d single -m raid1 /dev/part1 /dev/part2 ...
</code></pre><h5 id="subvolume">subvolume<a hidden class="anchor" aria-hidden="true" href="#subvolume">#</a></h5>
<p><strong>创建子卷</strong></p>
<p>要创建一个子卷:</p>
<pre tabindex="0"><code># btrfs subvolume create /path/to/subvolume
</code></pre><p><strong>列出子卷列表</strong></p>
<p>要列出当前路径 (<code>path</code>) 下的子卷和它们的 ID:</p>
<pre tabindex="0"><code># btrfs subvolume list -p path
</code></pre><p><strong>删除子卷</strong></p>
<p>要删除一个子卷:</p>
<pre tabindex="0"><code># btrfs subvolume delete /path/to/subvolume
</code></pre><p>自 Linux 4.18 起, 用户可以像移除常规目录一样删除一个子卷 (用 <code>rm -r</code>, <code>rmdir</code> 命令)。</p>
<p><strong><a href="https://linuxhint.com/create-mount-btrfs-subvolumes/">挂载子卷</a></strong></p>
<p>可以使用 <code>subvol=*/path/to/subvolume*</code> 或 <code>subvolid=*objectid*</code> 挂载标志来安装子卷，就像文件系统分区一样。</p>
<pre tabindex="0"><code>$ sudo mount /dev/sdb1 -o subvol=projects /tmp/projects$ sudo mount /dev/sdb1 -o subvolid=261 /tmp/projects
</code></pre><h5 id="使用-btrfs-快照进行增量备份httpszhuanlanzhihucomp259534619"><a href="https://zhuanlan.zhihu.com/p/259534619">使用 Btrfs 快照进行增量备份</a><a hidden class="anchor" aria-hidden="true" href="#使用-btrfs-快照进行增量备份httpszhuanlanzhihucomp259534619">#</a></h5>
<p>*快照(snapshot)*是 Btrfs 的一个有趣的功能。快照是一个子卷的副本。生成快照是立即的。然而，生成快照与执行 <code>rsync</code> 或 <code>cp</code> 不同，快照并不是一创建就会占用空间。</p>
<blockquote>
<p>编者注：来自 <a href="https://link.zhihu.com/?target=https%3A//btrfs.wiki.kernel.org/index.php/SysadminGuide%23Snapshots">BTRFS Wiki</a>：快照简单的来说就是一个子卷，它使用 Btrfs 的 COW 功能与其他子卷共享其数据（和元数据）。</p>
</blockquote>
<p>占用的空间将随着原始子卷或快照本身（如果它是可写的）的数据变化而增加。子卷中已添加/修改的文件和已删除的文件仍然存在于快照中。这是一种方便的备份方式。</p>
<p><strong>使用快照进行备份</strong></p>
<p>快照驻留在子卷所在的同一磁盘上。你可以像浏览普通目录一样浏览它，并按照生成快照时的状态恢复文件的副本。顺便说一下，在快照子卷的同一磁盘上生成快照并不是一个理想的备份策略：如果硬盘坏了，快照也会丢失。快照的一个有趣的功能是可以将快照发送到另一个位置。快照可以被发送到外部硬盘或通过 SSH 发送到远程系统（目标文件系统也需要格式化为 Btrfs）。要实现这个，需要使用命令 <code>btrfs send</code> 和 <code>btrfs receive</code>。</p>
<p><strong>生成快照</strong></p>
<p>要使用 <code>btrfs send</code> 和 <code>btrfs receive</code> 命令，重要的是要将快照创建为只读，而快照默认是可写的。</p>
<p>要创建一个快照:</p>
<pre tabindex="0"><code># btrfs subvolume snapshot source [dest/]name
</code></pre><p><code>source</code>为要创建快照的对象，<code>[dest/]name</code>为快照安放路径。</p>
<p>下面的命令将对 <code>/home</code> 子卷进行快照。请注意 <code>-r</code> 标志代表只读。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">sudo btrfs subvolume snapshot -r /home /.snapshots/home-day1
</code></pre></div><p>快照的名称可以是当前日期，而不是 <code>day1</code>，比如 <code>home-$(date +%Y%m%d)</code>。快照看起来像普通的子目录。你可以把它们放在任何你喜欢的地方。目录 <code>/.snapshots</code> 可能是一个不错的选择，以保持它们的整洁和避免混淆。</p>
<blockquote>
<p>编者注：快照不会对自己进行递归快照。如果你创建了一个子卷的快照，子卷所包含的每一个子卷或快照都会被映射到快照里面的一个同名的空目录。</p>
</blockquote>
<p><strong>使用 btrfs send 进行备份</strong></p>
<p>在本例中，U 盘中的目标 Btrfs 卷被挂载为 <code>/run/media/user/mydisk/bk</code>。发送快照到目标卷的命令是：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">sudo btrfs send /.snapshots/home-day1 | sudo btrfs receive /run/media/user/mydisk/bk
</code></pre></div><p>这被称为初始启动，它相当于一个完整的备份。这个任务需要一些时间，取决于 <code>/home</code> 目录的大小。显然，后续的增量发送只需要更短的时间。</p>
<p><strong>增量备份</strong></p>
<p>快照的另一个有用的功能是能够以增量的方式执行发送任务。让我们再来生成一个快照。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">sudo btrfs subvolume snapshot -r /home /.snapshots/home-day2
</code></pre></div><p>为了执行增量发送任务，需要指定上一个快照作为基础，并且这个快照必须存在于源文件和目标文件中。请注意 <code>-p</code> 选项。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">sudo btrfs send -p /.snapshot/home-day1 /.snapshot/home-day2 | sudo btrfs receive /run/media/user/mydisk/bk
</code></pre></div><p>再来一次（一天之后）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">sudo btrfs subvolume snapshot -r /home /.snapshots/home-day3sudo btrfs send -p /.snapshot/home-day2 /.snapshot/home-day3 | sudo btrfs receive /run/media/user/mydisk/bk
</code></pre></div><p><strong>清理</strong></p>
<p>操作完成后，你可以保留快照。但如果你每天都执行这些操作，你可能最终会有很多快照。这可能会导致混乱，并可能会在你的磁盘上使用大量的空间。因此，如果你认为你不再需要一些快照，删除它们是一个很好的建议。</p>
<p>请记住，为了执行增量发送，你至少需要最后一个快照。这个快照必须存在于源文件和目标文件中。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">sudo btrfs subvolume delete /.snapshot/home-day1sudo btrfs subvolume delete /.snapshot/home-day2sudo btrfs subvolume delete /run/media/user/mydisk/bk/home-day1sudo btrfs subvolume delete /run/media/user/mydisk/bk/home-day2
</code></pre></div><p>注意：第 3 天的快照被保存在源文件和目标文件中。这样，明天（第 4 天），你就可以执行新的增量 <code>btrfs send</code>。</p>
<p>最后的建议是，如果 U 盘的空间很大，可以考虑在目标盘中保留多个快照，而在源盘中只保留最后一个快照。</p>
<h5 id="压缩">压缩<a hidden class="anchor" aria-hidden="true" href="#压缩">#</a></h5>
<p>给现存文件启用压缩，可使用 <code>btrfs filesystem defragment -c alg</code> 命令，<code>alg</code> 处可选填为 <code>zlib</code>，<code>lzo</code> 或 <code>zstd</code>。举例来说，要用 <a href="https://archlinux.org/packages/?name=zstd">zstd</a> 方式给整个文件系统重新压缩，执行下列命令：</p>
<pre tabindex="0"><code># btrfs filesystem defragment -r -v -c zstd /
</code></pre><p>要在新的 Btrfs 分区上安装 Arch Linux 时就启用压缩功能 (充分利用压缩特性)，请在 <a href="https://wiki.archlinux.org/title/Mounting">挂载</a> 文件系统时使用 <code>compress</code> 选项：<code>mount -o compress=zstd /dev/sd*xY* /mnt/</code>。在配置过程中，请在 <a href="https://wiki.archlinux.org/title/Fstab">fstab</a> 中把 <code>compress=zstd</code> 添加到根目录文件系统的挂载选项里。</p>
<h4 id="btrfs-和-lvm-ext4httpslinuxcnarticle-13043-1html"><a href="https://linux.cn/article-13043-1.html">Btrfs 和 LVM-ext4</a><a hidden class="anchor" aria-hidden="true" href="#btrfs-和-lvm-ext4httpslinuxcnarticle-13043-1html">#</a></h4>
<h5 id="两者的共性">两者的共性<a hidden class="anchor" aria-hidden="true" href="#两者的共性">#</a></h5>
<p>尽管两个文件系统之间存在核心差异，但 Btrfs 和 LVM-ext4 实际上有很多共同之处。两者都是成熟且经过充分测试的存储技术。从 Fedora Core 的早期开始，就一直在使用 LVM，而 ext4 在 <a href="https://docs.fedoraproject.org/en-US/Fedora/11/html/Release_Notes/index.html#sect-Release_Notes-Fedora_11_Overview">2009 年成为 Fedora 11 的默认设置</a>。Btrfs 在 2009 年并入 Linux 主线内核，并且 <a href="https://facebookmicrosites.github.io/btrfs/docs/btrfs-facebook.html">Facebook 广泛使用了该文件系统</a>。SUSE Linux Enterprise 12 <a href="https://www.suse.com/releasenotes/x86_64/SUSE-SLES/12/#fate-317221">在 2014 年使其成为默认文件系统</a>。因此，它在生产环境中也有着长久的运行时间。</p>
<p>这两个系统都能很好地防止因意外停电而导致的文件系统损坏，尽管它们的实现方式不同。它们支持的配置包括使用单盘设置和跨越多个设备，并且这两种配置都能够创建近乎即时的快照。有各种工具可以帮助管理这两种系统，包括命令行和图形界面。这两种解决方案在家用台式机和高端服务器上都同样有效。</p>
<h5 id="lvm-ext4-的优势">LVM-ext4 的优势<a hidden class="anchor" aria-hidden="true" href="#lvm-ext4-的优势">#</a></h5>
<p><img loading="lazy" src="/Distributions/Ext4onLVM.jpg" alt=""  />
</p>
<p><a href="https://opensource.com/article/18/4/ext4-filesystem">ext4 文件系统</a> 专注于高性能和可伸缩性，没有太多额外的花哨之处。它能有效地防止长时间后的碎片化，并当碎片化出现后提供了 <a href="https://man7.org/linux/man-pages/man8/e4defrag.8.html">很好的工具</a>。ext4 之所以坚如磐石，是因为它构建在前代的 ext3 文件系统之上，带来了多年的系统内测试和错误修复。</p>
<p>LVM-ext4 环境中的大多数高级功能都来自 LVM 本身。LVM 位于文件系统的“下方”，这意味着它支持任何文件系统。逻辑卷Logical volume（LV）是通用的块设备，因此 <a href="https://libvirt.org/storage.html#StorageBackendLogical">虚拟机可以直接使用它们</a>。这种灵活性使得每个逻辑卷都可以使用合适的文件系统，用合适的选项应对各种情况。这种分层方法还遵循了“小工具协同工作”的 Unix 哲学。</p>
<p>从硬件抽象出来的<a href="https://www.redhat.com/sysadmin/create-volume-group">卷组</a>volume group（VG）允许 LVM 创建灵活的逻辑卷。每个逻辑卷都提取自同一个存储池，但具有自己的设置。调整卷的大小比调整物理分区的大小容易得多，因为没有数据有序放置的限制。LVM <a href="https://www.redhat.com/sysadmin/create-physical-volume">物理卷</a>physical volume（PV）可以是任意数量的分区，甚至可以在系统运行时在设备之间移动。</p>
<p>LVM 支持只读和读写的 <a href="https://tldp.org/HOWTO/LVM-HOWTO/snapshotintro.html">快照</a>，这使得从活动系统创建一致的备份变得很容易。每个快照都有一个定义的大小，更改源卷或快照卷将占用其中的空间。又或者，逻辑卷也可以是<a href="https://man7.org/linux/man-pages/man7/lvmthin.7.html">稀疏配置池</a>thinly provisioned pool的一部分。这允许快照自动使用池中的数据，而不是使用在创建卷时定义的固定大小的块。</p>
<p><strong>有多个磁盘驱动器的 LVM</strong></p>
<p>当有多个设备时，LVM 才真正大放异彩。它原生支持大多数 <a href="https://rhea.dev/articles/2018-08/LVM-RAID-on-Fedora">RAID 级别</a>，每个逻辑卷可以具有不同的 RAID 级别。LVM 将自动为 RAID 配置选择适当的物理设备，或者用户可以直接指定它。基本的 RAID 支持包括用于性能的数据条带化（<a href="https://en.wikipedia.org/wiki/Standard_RAID_levels#RAID_0">RAID0</a>）和用于冗余的镜像（<a href="https://en.wikipedia.org/wiki/Standard_RAID_levels#RAID_1">RAID1</a>）。逻辑卷也可以使用 <a href="https://en.wikipedia.org/wiki/Standard_RAID_levels#RAID_5">RAID5</a>、<a href="https://en.wikipedia.org/wiki/Standard_RAID_levels#RAID_6">RAID6</a> 和 <a href="https://en.wikipedia.org/wiki/Non-standard_RAID_levels#Linux_MD_RAID_10">RAID10</a> 等高级设置。LVM RAID 支持已经成熟，因为 LVM 在底层使用的 <a href="https://man7.org/linux/man-pages/man8/dmsetup.8.html">设备映射器（dm）</a> 和 <a href="https://man7.org/linux/man-pages/man4/md.4.html">多设备（md）</a> 内核支持， 与 <a href="https://fedoramagazine.org/managing-raid-arrays-with-mdadm/">mdadm</a> 使用的一样。</p>
<p>对于具有快速和慢速驱动器的系统，逻辑卷也可以是 <a href="https://man7.org/linux/man-pages/man7/lvmcache.7.html">缓存卷</a>。经典示例是 SSD 和传统磁盘驱动器的组合。缓存卷使用较快的驱动器来存储更频繁访问的数据（或用作写缓存），而慢速的驱动器则用于处理大量数据。</p>
<p>LVM 中大量稳定的功能以及 ext4 的可靠性在既往的使用中早已被证明了。当然，功能越多就越复杂。在配置 LVM 时，要找到合适的功能选项是很有挑战性的。对于单驱动器的台式机系统，LVM 的功能（例如 RAID 和缓存卷）不适用。但是，逻辑卷比物理分区更灵活，快照也很有用。对于正常的桌面使用，LVM 的复杂性会成为典型的用户可能遇到的问题恢复的障碍。</p>
<h5 id="btrfs-的优势">Btrfs 的优势<a hidden class="anchor" aria-hidden="true" href="#btrfs-的优势">#</a></h5>
<p><img loading="lazy" src="/Distributions/Btrfs%e7%bb%93%e6%9e%84.jpg" alt=""  />
</p>
<p>从前几代文件系统中学到的经验指导了构建到 <a href="https://btrfs.wiki.kernel.org/index.php/Main_Page">Btrfs</a> 的功能设计。与 ext4 不同，它可以直接跨越多个设备，因此它具有通常仅在卷管理器中才能找到的功能。它还具有 Linux 文件系统空间中独有的功能（<a href="https://en.wikipedia.org/wiki/ZFS">ZFS</a> 具有相似的功能集，但<a href="https://itsfoss.com/linus-torvalds-zfs/">不要指望它在 Linux 内核中出现</a>）。</p>
<p><strong>Btrfs 的主要功能</strong></p>
<p>也许最重要的功能是对所有数据进行校验和checksumming。校验和与<a href="https://en.wikipedia.org/wiki/Copy-on-write">写时复制</a>copy-on-write（COW）一起，提供了在意外断电后确保文件系统完整性的 <a href="https://btrfs.wiki.kernel.org/index.php/FAQ#Can_I_have_nodatacow_.28or_chattr_.2BC.29_but_still_have_checksumming.3F">关键方法</a>。更独特的是，校验和可以检测数据本身中的错误。悄然的数据损坏（有时也称为 <a href="https://arstechnica.com/information-technology/2014/01/bitrot-and-atomic-cows-inside-next-gen-filesystems/">bitrot</a>）比大多数人意识到的更常见。如果没有主动验证，损坏最终可能会传播到所有可用的备份中。这使得用户没有有效的副本。通过透明地校验所有数据，Btrfs 能够立即检测到任何此类损坏。启用正确的 <a href="https://man7.org/linux/man-pages/man8/mkfs.btrfs.8.html#DUP_PROFILES_ON_A_SINGLE_DEVICE">dup 或 raid 选项</a>，文件系统也可以透明地修复损坏。</p>
<p>写时复制也是 Btrfs 的基本功能，因为它在提供文件系统完整性和即时子卷快照方面至关重要。从公共子卷创建快照后，快照会自动共享底层数据。另外，事后的<a href="https://btrfs.wiki.kernel.org/index.php/Deduplication">重复数据删除</a>deduplication 使用相同的技术来消除相同的数据块。单个文件可以通过使用 <code>cp</code> 的 <a href="https://btrfs.wiki.kernel.org/index.php/UseCases#How_do_I_copy_a_large_file_and_utilize_COW_to_keep_it_from_actually_being_copied.3F">reflink 选项</a> 来使用 COW 功能。reflink 副本对于复制大型文件（例如虚拟机镜像）特别有用，这些文件往往随着时间的推移具有大部分相同的数据。</p>
<p>Btrfs 支持跨越多个设备，而无需卷管理器。多设备支持可提供数据镜像功能以实现冗余和条带化以提高性能。此外，还实验性地支持更高级的 RAID 级别，例如 <a href="https://en.wikipedia.org/wiki/Standard_RAID_levels#RAID_5">RAID 5</a> 和 <a href="https://en.wikipedia.org/wiki/Standard_RAID_levels#RAID_6">RAID 6</a>。与标准 RAID 设置不同，Btrfs 的 RAID1 实际上允许奇数个设备。例如，它可以使用 3 个设备，即使它们的大小不同。</p>
<p>所有 RAID 和 dup 选项都是在文件系统级别指定的。因此，各个子卷不能使用不同的选项。请注意，使用多设备的 RAID1 选项意味着即使一个设备发生故障，卷中的所有数据都是可用的，并且校验功能可以保持数据本身的完整性。这超出了当前典型的 RAID 设置所能提供的范围。</p>
<p><strong>附加功能</strong></p>
<p>Btrfs 还支持快速简便的远程备份。子卷快照可以 <a href="https://fedoramagazine.org/btrfs-snapshots-backup-incremental/">发送到远程系统</a> 进行存储。通过利用文件系统中固有的 COW 元数据，这些传输通过仅发送先前发送的快照中的增量更改而非常有效。诸如 <a href="http://snapper.io/">snapper</a> 之类的用户应用程序使管理这些快照变得容易。</p>
<p>另外，Btrfs 卷可以具有 <a href="https://btrfs.wiki.kernel.org/index.php/Compression">透明压缩</a> 功能，并且 <a href="https://www.man7.org/linux/man-pages/man1/chattr.1.html">chattr +c</a> 可以标记进行压缩的单个文件或目录。压缩不仅可以减少数据消耗的空间，还可以通过减少写入操作量来帮助延长 SSD 的寿命。压缩当然会带来额外的 CPU 开销，但是有很多选项就可以权衡取舍。</p>
<p>Btrfs 集成了文件系统和卷管理器功能，这意味着总体维护比 LVM-ext4 更简单。当然，这种集成的灵活性较低，但是对于大多数台式机甚至服务器而言，设置已足够。</p>
<h5 id="lvm-上使用-btrfs">LVM 上使用 Btrfs<a hidden class="anchor" aria-hidden="true" href="#lvm-上使用-btrfs">#</a></h5>
<p>Btrfs 可以 <a href="https://btrfs.wiki.kernel.org/index.php/Conversion_from_Ext3">就地转换 ext3/ext4 文件系统</a>。就地转换意味着无需将数据复制出来然后再复制回去。数据块本身甚至都不需要修改。因此，对于现有的 LVM-ext4 系统，一种选择是将 LVM 保留在原处，然后简单地将 ext4 转换为 Btrfs。虽然可行且受支持，但有一些原因使它不是最佳选择。</p>
<p>Btrfs 的吸引力之一是与卷管理器集成的文件系统所带来的更轻松的管理。要是在 LVM 之上运行，对于系统维护，仍然要对额外的卷管理器进行一些设置。同样，LVM 设置通常具有多个固定大小的逻辑卷，并具有独立文件系统。虽然 Btrfs 支持给定的计算机上的多个卷，但是许多不错的功能都需要单一卷具有多个子卷。如果每个 LVM 卷都有一个独立的 Btrfs 卷，则用户仍然需要手动管理固定大小的 LVM 卷。虽然能够收缩挂载的 Btrfs 文件系统的能力确实使处理固定大小的卷的工作变得更轻松。通过在线收缩功能，就无需启动 <a href="https://fedoramagazine.org/reclaim-hard-drive-space-with-lvm/">实时镜像</a> 了。</p>
<p>在使用 Btrfs 的多设备支持时，必须仔细考虑逻辑卷的物理位置。对于 Btrfs 而言，每个逻辑卷都是一个单独的物理设备，如果实际情况并非如此，则某些数据可用性功能可能会做出错误的决定。例如，如果单个驱动器发生故障，对数据使用 RAID1 通常可以提供保护。如果实际逻辑卷在同一物理设备上，则没有冗余。</p>
<p>如果强烈需要某些特定的 LVM 功能，例如原始块设备或高速缓存的逻辑卷，则在 LVM 之上运行 Btrfs 是有意义的。在这种配置下，Btrfs 仍然提供其大多数优点，例如校验和和易于发送的增量快照。尽管使用 LVM 会产生一些操作开销，但 Btrfs 的这种开销并不比任何其他文件系统大。</p>
<h5 id="总结-1">总结<a hidden class="anchor" aria-hidden="true" href="#总结-1">#</a></h5>
<p>当尝试在 Btrfs 和 LVM-ext4 之间进行选择时，没有一个正确的答案。每个用户都有独特的要求，并且同一用户可能拥有具有不同需求的不同系统。看一下每个配置的功能集，并确定是否有令人心动的功能。如果没有，坚持默认值没有错。选择这两种设置都有很好的理由。</p>
<h3 id="snapperhttpszhopensuseorgsdbsnapper_tutorial"><a href="https://zh.opensuse.org/SDB:Snapper_Tutorial">Snapper</a><a hidden class="anchor" aria-hidden="true" href="#snapperhttpszhopensuseorgsdbsnapper_tutorial">#</a></h3>
<p>Snapper 是 openSUSE 下用于创建和管理文件系统快照（以下简称快照）的工具。快照保存了文件系统在某个时间点的状态，从而可以轻松实现系统回滚或数据备份。</p>
<p>Snapper 可以在 <strong>Btrfs</strong> 文件系统（推荐）及采用 XFS 或 Ext4 文件系统的 <strong>LVM</strong> 精简配置卷上使用，本文主要介绍在 Btrfs 文件系统上使用 Snapper 的方法。</p>
<h4 id="快照类型">快照类型<a hidden class="anchor" aria-hidden="true" href="#快照类型">#</a></h4>
<p>Snapper 快照可分为两大类型：</p>
<ul>
<li><strong>快照对</strong>：由一对快照组成，在进行某项操作前拍摄一个“前快照”（pre），操作后再拍摄一个“后快照”（post），从而可以比较两个快照对差异而撤销该操作。快照对是一一对应的，如果删除了某一快照，则对应的快照也会被删除。</li>
<li><strong>单一快照（single）</strong>：由一个单独的快照组成，与其他快照没有特殊联系。可用于备份或回滚整个系统等操作。</li>
</ul>
<p>快照对和单一快照既可以手动创建，也可以根据配置自动创建。自动创建的快照又可分为三种类型：</p>
<ul>
<li><strong>时间线快照</strong>：每小时自动创建的单一快照。</li>
<li><strong>安装快照</strong>：在安装软件包前后自动创建的一对快照对。可用于撤销软件包更改。</li>
<li><strong>管理快照</strong>：在使用 YaST 管理系统前后自动创建的一堆快照对。可用于撤销配置更改。</li>
</ul>
<p>这三种自动创建的快照均可单独启用和配置，从而提供了极大的灵活性。</p>
<h4 id="默认配置">默认配置<a hidden class="anchor" aria-hidden="true" href="#默认配置">#</a></h4>
<p>要在分区或 Btrfs 子卷启用快照，需要创建配置文件。Snapper 的配置文件存储在 <code>/etc/snapper/configs</code> 中。</p>
<p>如果你的根分区大于 16 GB，并且在安装 openSUSE 时使用默认分区配置，则根分区的配置文件应已被自动创建。默认配置启用了安装快照和管理快照，并排除了部分目录，可以满足大多数需求。以下列表显示了排除的所有目录：</p>
<ul>
<li>
<p><code>/boot/grub2/i386-pc</code>、<code>/boot/grub2/x86_64-efi</code>、<code>/boot/grub2/powerpc-ieee1275</code>、<code>/boot/grub2/s390x-emu</code></p>
<p>不能回滚引导加载程序配置。上面列出的目录是架构专属目录。前两个目录位于 AMD64/Intel 64 计算机上，后两个目录分别位于 IBM POWER 和 IBM Z 上。</p>
</li>
<li>
<p><code>/home</code></p>
<p>如果独立的分区中没有 <code>/home</code>，便会将该目录排除以免在回滚时发生数据丢失。</p>
</li>
<li>
<p><code>/opt</code>、<code>/var/opt</code></p>
<p>第三方产品通常安装到 <code>/opt</code> 下。排除此目录是为了防止在回滚时卸装这些应用程序。</p>
</li>
<li>
<p><code>/srv</code></p>
<p>包含 Web 和 FTP 服务器的数据。排除此目录是为了防止在回滚时发生数据丢失。</p>
</li>
<li>
<p><code>/tmp</code>、<code>/var/tmp</code>、<code>/var/cache</code>、<code>/var/crash</code></p>
<p>包含临时文件和超速缓存的所有目录都会排除在快照范围之外。</p>
</li>
<li>
<p><code>/usr/local</code></p>
<p>在手动安装软件时会用到此目录。系统会将该目录排除以免在回滚时卸载这些安装的软件。</p>
</li>
<li>
<p><code>/var/lib/libvirt/images</code></p>
<p>使用 libvirt 管理的虚拟机映像的默认位置。为确保回滚期间虚拟机映像不会替换为旧版本而被排除。默认情况下，此子卷是使用<code>写入时不复制</code>选项创建的。</p>
</li>
<li>
<p><code>/var/lib/mailman</code>、<code>/var/spool</code></p>
<p>包含邮件或邮件队列的目录会排除，以免在回滚后造成邮件丢失。</p>
</li>
<li>
<p><code>/var/lib/bind</code></p>
<p>包含 DNS 服务器的区域数据。排除该目录是为了确保回滚后名称服务器仍能运作。</p>
</li>
<li>
<p><code>/var/lib/mariadb</code>、<code>/var/lib/mysql</code>、<code>/var/lib/pgqsl</code></p>
<p>这些目录包含数据库数据。默认情况下，这些子卷是使用<code>写入时不复制</code>选项创建的。</p>
</li>
<li>
<p><code>/var/log</code></p>
<p>日志文件所在的位置。排除该目录是为了在对受损的系统进行回滚后能够对日志文件进行分析。</p>
</li>
</ul>
<p>如果你希望使用 openSUSE 的默认配置，但在安装 openSUSE 时未开启快照功能，可以使用以下命令创建根分区的默认配置文件：</p>
<p><strong>注意：</strong> 要使用该默认配置文件，请确保根分区大小至少为 16 GB，并使用 openSUSE 安装程序建议的包含子卷的 Btrfs 根文件系统（安装程序默认分区设置）</p>
<pre tabindex="0"><code>snapper -c root create-config /
</code></pre><p>确保 snapper-zypp-plugin 软件包已安装以启用安装快照：</p>
<pre tabindex="0"><code>zypper install snapper-zypp-plugin
</code></pre><h4 id="手动配置">手动配置<a hidden class="anchor" aria-hidden="true" href="#手动配置">#</a></h4>
<h5 id="创建和装入新子卷">创建和装入新子卷<a hidden class="anchor" aria-hidden="true" href="#创建和装入新子卷">#</a></h5>
<p>系统支持在 <code>/</code> 层次下创建新的子卷，并永久性装入该卷。此类子卷将从快照中排除。切勿在现有快照中创建此类子卷，因为在回滚之后，您将无法再删除快照。</p>
<p>SUSE Linux Enterprise Server 上配置了 <code>/@/</code> 子卷，该子卷充当永久性子卷（例如 <code>/opt</code>、<code>/srv</code>、<code>/home</code> 等）的独立根目录。您创建和永久装入的任何新子卷都需要在这个初始根文件系统中创建。</p>
<p>为此，请运行以下命令。在此示例中，从 <code>/dev/sda2</code> 创建了一个新子卷 <code>/usr/important</code>。</p>
<pre tabindex="0"><code>sudo mount /dev/sda2 -o subvol=@ /mntsudo btrfs subvolume create /mnt/usr/importantsudo umount /mnt
</code></pre><p><code>/etc/fstab</code> 中的相应项需类似于：</p>
<pre tabindex="0"><code>/dev/sda2 /usr/important btrfs subvol=@/usr/important 0 0
</code></pre><p>提示：子卷可能包含经常更改的文件，例如虚拟化的磁盘映像、数据库文件或日志文件。如果是这样，可考虑对此卷禁用写入时复制功能，以免复制磁盘块。可在 <code>/etc/fstab</code> 中使用 <code>nodatacow</code> 装入选项来实现此目的：</p>
<pre tabindex="0"><code>/dev/sda2 /usr/important btrfs nodatacow,subvol=@/usr/important 0 0
</code></pre><p>或者，要为单个文件或目录禁用写入时复制功能，请使用命令 <code>chattr +C 路径</code>。</p>
<h5 id="创建配置文件">创建配置文件<a hidden class="anchor" aria-hidden="true" href="#创建配置文件">#</a></h5>
<p>希望在特定分区或子卷启用快照，可以以下命令创建相应的配置文件：</p>
<pre tabindex="0"><code>snapper -c 配置文件名 create-config 分区或子卷的挂载点
</code></pre><p>这将根据 <code>/etc/snapper/config-templates/default</code> 提供的默认值创建配置文件。</p>
<p><strong>注意：</strong> 在创建配置文件前请确保目标分区或子卷已被创建。不能为同一分区或子卷创建多个配置文件。</p>
<p>例如，为防止回滚时数据丢失，默认的根分区配置排除了 <code>/home</code> 目录，可以使用上述命令为 <code>/home</code> 创建配置文件：</p>
<pre tabindex="0"><code>snapper -c home create-config /home
</code></pre><p>该命令会使用 <code>/etc/snapper/config-templates/default</code> 提供的默认值创建 <code>/etc/snapper/configs/home</code> 文件。</p>
<p>可以使用</p>
<pre tabindex="0"><code>snapper list-configs
</code></pre><p>查看现有配置文件。</p>
<h5 id="启用禁用自动快照">启用/禁用自动快照<a hidden class="anchor" aria-hidden="true" href="#启用禁用自动快照">#</a></h5>
<p>你可以选择性地启用/禁用自动创建的快照类型：</p>
<p>启用时间线快照</p>
<pre tabindex="0"><code>snapper -c 配置文件名 set-config &quot;TIMELINE_CREATE=yes&quot;
</code></pre><p>禁用时间线快照</p>
<pre tabindex="0"><code>snapper -c 配置文件名 set-config &quot;TIMELINE_CREATE=no&quot;
</code></pre><p>时间线快照默认会启用，但根分区除外。</p>
<p><strong>注意：</strong> 以下两种快照包含的内容由安装的软件包或修改的配置而定，与特定分区或子卷无关。默认为启用状态。</p>
<p>启用安装快照</p>
<pre tabindex="0"><code>zypper install snapper-zypp-plugin
</code></pre><p>禁用安装快照</p>
<pre tabindex="0"><code>zypper remove snapper-zypp-plugin
</code></pre><p>使用 YaST 或 Zypper 安装包时所创建的快照会由 <code>snapper-zypp-plugin</code> 进行处理。何时创建快照由 XML 配置文件 <code>/etc/snapper/zypp-plugin.conf</code> 定义。</p>
<p>启用管理快照</p>
<pre tabindex="0"><code>在 /etc/sysconfig/yast2 中将 USE_SNAPPER 设置为 yes
</code></pre><p>禁用管理快照</p>
<pre tabindex="0"><code>在 /etc/sysconfig/yast2 中将 USE_SNAPPER 设置为 no
</code></pre><h5 id="配置文件参数">配置文件参数<a hidden class="anchor" aria-hidden="true" href="#配置文件参数">#</a></h5>
<p>Snapper 的行为由配置文件参数定义，除了直接使用文本编辑器编辑配置文件外，还可以使用</p>
<pre tabindex="0"><code>snapper -c 配置文件名称 set-config &quot;参数名称=参数&quot;
</code></pre><p>修改配置文件参数。</p>
<p>以下对几个常用配置案例进行说明，完整的参数说明可参阅 snapper-configs(5) ：</p>
<pre tabindex="0"><code>man snapper-configs
</code></pre><p><strong>允许普通用户管理快照</strong></p>
<p>默认情况下仅 root 用户可以管理快照，要允许普通用户或组管理快照，可运行：</p>
<pre tabindex="0"><code>snapper -c 配置文件名称 set-config &quot;ALLOW_USERS=用户名&quot; &quot;ALLOW_GROUPS=组名&quot; &quot;SYNC_ACL=yes&quot;
</code></pre><p>必须配置“SYNC_ACL=yes”以允许普通用户访问快照所在目录。</p>
<p><strong>自动清理旧快照</strong></p>
<p>为防止快照占据全部磁盘空间，Snapper 提供了几种自动清理旧快照的机制，可通过一系列参数配置自动清理过程：</p>
<table>
<thead>
<tr>
<th>清理机制</th>
<th>说明</th>
<th>启用选项</th>
<th>配置参数</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>编号</td>
<td>根据快照编号进行清理</td>
<td>NUMBER_CLEANUP=yes</td>
<td>NUMBER_LIMIT=数字或范围</td>
<td>定义要保留的快照数量。</td>
<td>如果启用了定额支持，应使用范围。如果未启用定额支持，应使用单个数字。</td>
</tr>
<tr>
<td>NUMBER_LIMIT_IMPORTANT=数字或范围</td>
<td>定义要保留的含 important 标签的快照数量，内核更新等的安装快照自带该标签。</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>NUMBER_MIN_AGE=秒</td>
<td>定义满足上述条件的快照被清理前最少应保留的时间。0 表示无限制。</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>时间线</td>
<td>根据快照创建时间进行清理</td>
<td>TIMELINE_CLEANUP=yes</td>
<td>TIMELINE_LIMIT_HOURLY=数字或范围</td>
<td>定义要保留的每小时首张快照的数量。</td>
<td>如果启用了定额支持，应使用范围。如果未启用定额支持，应使用单个数字。</td>
</tr>
<tr>
<td>TIMELINE_LIMIT_DAILY=数字或范围</td>
<td>定义要保留的每日首张快照的数量。</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>TIMELINE_LIMIT_WEEKLY=数字或范围</td>
<td>定义要保留的每周首张快照的数量，此处的周由星期一开始。</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>TIMELINE_LIMIT_MONTHLY=数字或范围</td>
<td>定义要保留的每月首张快照的数量。</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>TIMELINE_LIMIT_YEARLY=数字或范围</td>
<td>定义要保留的每年首张快照的数量。</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>TIMELINE_MIN_AGE=秒</td>
<td>定义满足上述条件的快照被清理前最少应保留的时间。0 表示无限制。</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>无差异快照对</td>
<td>清理没有差异的快照对。如运行 Yast2 后未作任何修改，则自动清理创建的管理快照。</td>
<td>EMPTY_PRE_POST_CLEANUP=yes</td>
<td>EMPTY_PRE_POST_CLEANUP=秒</td>
<td>定义无差异快照对被清理前最少应保留的时间。0 表示无限制。</td>
<td></td>
</tr>
<tr>
<td>磁盘定额</td>
<td>定义快照可占用空间的百分比</td>
<td>运行snapper setup-quota</td>
<td>SPACE_LIMIT=表示百分比的小数</td>
<td>定义快照可占用空间的百分比</td>
<td>仅支持 Btrfs 文件系统需至少启用编号或时间线清理算法中的一个启用定额支持后，编号和时间线清理算法的部分参数应当使用范围值。清理算法会清理快照至上限值，如果未满足定额配置则在下限值范围内尽量清理快照以满足定额。</td>
</tr>
</tbody>
</table>
<h5 id="管理配置文件">管理配置文件<a hidden class="anchor" aria-hidden="true" href="#管理配置文件">#</a></h5>
<p>可以使用 snapper 命令快速管理配置文件：</p>
<p>列出配置文件</p>
<pre tabindex="0"><code>snapper list-configs
</code></pre><p>显示特定的配置文件</p>
<pre tabindex="0"><code>snapper -c 配置文件名称 get-config
</code></pre><p>删除配置文件</p>
<pre tabindex="0"><code>snapper -c 配置文件名称 delete-config
</code></pre><h4 id="快照管理">快照管理<a hidden class="anchor" aria-hidden="true" href="#快照管理">#</a></h4>
<p>可以使用 snapper 工具或 Yast2 模块进行查看、创建、比较快照等操作。</p>
<p>snapper 工具提供了一系列子命令，可以在文本界面进行快照管理。本节介绍了一些常用命令和参数，更多信息可参阅 snapper(8)：</p>
<pre tabindex="0"><code>man snapper
</code></pre><p><strong>注意：</strong> 管理快照时可使用 “-c 配置文件名” 指定配置文件，如未指定则默认使用 root 配置文件，下述示例均未指定配置文件。</p>
<p><strong>查看快照</strong></p>
<pre tabindex="0"><code>snapper list
</code></pre><p>将列出 root 配置的所有快照。</p>
<p>可以使用 “-t” 参数列出特定类型的快照。</p>
<p>例如，列出 root 配置下的所有快照对：</p>
<pre tabindex="0"><code>snapper list -t pre-post
</code></pre><p>列出 home 配置下的所有单一快照：</p>
<pre tabindex="0"><code>snapper -c home list -t single
</code></pre><p>你还可以使用</p>
<pre tabindex="0"><code>snapper list -a
</code></pre><p>列出所有配置下的快照。</p>
<p><strong>创建快照</strong></p>
<pre tabindex="0"><code>snapper create
</code></pre><p>将使用 root 配置文件创建一个单一快照。</p>
<p>可以使用“-t”参数指定快照类型（默认值为 single），使用“-d”参数添加描述。手动创建的快照默认不会自动被清理，使用“&ndash;cleanup-algorithm”参数指定自动清理算法。还可以使用“&ndash;userdata”参数定义自定义数据（如 important 标记）。</p>
<p>例如，创建当前系统的单一快照，标记为重要，并指定时间线清理算法：</p>
<pre tabindex="0"><code>snapper create -t single --description &quot;系统快照&quot; --userdata &quot;important=yes&quot; --cleanup-algorithm timeline
</code></pre><p>要创建一个快照对，首先创建一个前快照，使用“&ndash;print-number”选项以列出快照编号：</p>
<pre tabindex="0"><code>snapper create -t pre --print-number --description &quot;Before&quot;
</code></pre><p>假设列出的快照编号为 30，将其作为“&ndash;pre-number”参数的值创建后快照：</p>
<pre tabindex="0"><code>snapper create -t post --pre-number 30 --description &quot;After&quot;
</code></pre><p>你也可以使用</p>
<pre tabindex="0"><code>snapper create --command &quot;要运行的命令&quot;
</code></pre><p>以自动创建运行命令前后的快照对。</p>
<p><strong>比较快照</strong></p>
<p>有两种比较方法：</p>
<pre tabindex="0"><code>snapper status &lt;第一个快照编号&gt;..&lt;第二个快照编号&gt; //第一个快照的创建时间要早于第二个
</code></pre><p>将显示您在两个快照时间内修改的全部文件的路径和文件名。</p>
<p>例如，下述命令可以比较当前系统状态与 161 号快照的差异：</p>
<pre tabindex="0"><code>snapper status 161..0 //0 表示当前系统，它不是快照，但你可以认为是比所有快照都新的一个快照。
</code></pre><p>第二种：</p>
<pre tabindex="0"><code>snapper diff &lt;第一个快照编号&gt;..&lt;第二个快照编号&gt; 文件名
</code></pre><p>将以 diff 的格式显示指定文件的差异，如果未指定文件名，将显示所有文件的差异。</p>
<p><strong>撤销修改</strong></p>
<pre tabindex="0"><code>snapper undochange &lt;修改前的快照编号&gt;..&lt;修改后的快照编号&gt; &lt;文件名&gt;
</code></pre><p>比如你误删除了某个文件，可以使用：</p>
<pre tabindex="0"><code>snapper undochange &lt;删除文件前的快照编号&gt;..0 文件名 //0 表示当前系统，它不是快照，但你可以认为是比所有快照都新的一个快照。
</code></pre><p>来撤销。</p>
<p><strong>删除快照</strong></p>
<pre tabindex="0"><code>snapper delete 快照编号或范围
</code></pre><p>例如，要删除 16 号快照：</p>
<pre tabindex="0"><code>snapper delete 16
</code></pre><p>要删除 10 号到 15 号快照：</p>
<pre tabindex="0"><code>snapper delete 10-15
</code></pre><p>可以结合“-s”参数以在删除快照后立刻释放可用空间而不必等待 Btrfs 进程回收。</p>
<p><strong>回滚整个系统</strong></p>
<p>SUSE Linux Enterprise Server 上包含的 GRUB 2 版本可以从 Btrfs 快照进行引导。与 Snapper 的回滚功能相结合，就能恢复配置错误的系统。只有针对默认 Snapper 配置（<code>根</code>）创建的快照才可引导。</p>
<p><strong>注意：</strong> 要回滚整个系统，请确保根文件系统为 openSUSE 安装程序默认的带子卷的 Btrfs 文件系统。从 SUSE Linux Enterprise Server  15  开始，只有在根分区的默认子卷配置未更改过的情况下，才支持系统回滚。</p>
<p>如果因为更新或病毒等原因导致系统出现重大错误，并保留了错误前的快照，则可以回滚整个系统到错误前的状态。</p>
<pre tabindex="0"><code>snapper rollback 要回滚的快照编号
</code></pre><p>该命令将创建当前系统状态的只读快照 A 及指定编号快照的可读写快照 B，并使用快照 B 替换根分区的默认子卷，重新启动系统后即可实现回滚。</p>
<p>你还可以在引导系统时选择<em>Start bootloader from a read-only snapshot</em>，以引导想要回滚的快照，在检查无误后在引导的快照中执行：</p>
<pre tabindex="0"><code>snapper rollback
</code></pre><p>不指定快照编号时，将创建根分区默认子卷（即原系统）的只读快照 A 和当前系统（即目前引导的快照）的可读写快照 B，并使用快照 B 替换根分区的默认子卷，重新启动系统后选择默认引导项即可实现回滚。</p>
<h3 id="sudohttpsdocumentationsusecomzh-cnsles15-gahtmlsles-allcha-adm-sudohtml"><a href="https://documentation.suse.com/zh-cn/sles/15-GA/html/SLES-all/cha-adm-sudo.html">sudo</a><a hidden class="anchor" aria-hidden="true" href="#sudohttpsdocumentationsusecomzh-cnsles15-gahtmlsles-allcha-adm-sudohtml">#</a></h3>
<p>许多命令和系统实用程序都需要以 <code>root</code> 身份运行才能执行。为了确保安全和避免发生意外运行危险命令，通常建议不要直接以 <code>root</code> 身份登录。建议的做法是以非特权的普通用户身份工作，并使用 <code>sudo</code> 命令来运行需要较高特权的命令。</p>
<p>在 SUSE Linux Enterprise Server 上，<code>sudo</code> 默认配置与 su 的工作方式类似。但是，<code>sudo</code> 可让用户以高度可配置的方式使用任何其他用户的特权来运行命令。这样，便可为某些用户和组指派具有特定特权的角色。举例来说，可以允许组 <code>users</code> 的成员使用 <code>wilber</code> 的特权运行命令。通过禁止指定任何命令选项，可以进一步限制对命令的权限。虽然 su 始终需要 <code>root</code> 口令才能使用 PAM 进行身份验证，但是您可以将 <code>sudo</code> 配置为使用您自己的身份凭证进行身份验证。这样就不需要共享 <code>root</code> 口令，从而提高了安全性。</p>
<h4 id="sudo-基本用法"><code>sudo</code> 基本用法<a hidden class="anchor" aria-hidden="true" href="#sudo-基本用法">#</a></h4>
<p>虽然 <code>sudo</code> 简单易用，功能却十分强大。</p>
<h5 id="运行单个命令">运行单个命令<a hidden class="anchor" aria-hidden="true" href="#运行单个命令">#</a></h5>
<p>以普通用户身份登录后，您可以在命令前加上 <code>sudo</code> 以 <code>root</code> 身份运行任何命令。按照提示输入口令后，如果身份验证成功，您便能以 <code>root</code> 身份运行命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># id -un 命令会打印当前用户的登录名</span>
$ id -un
tux

<span style="color:#75715e"># 在输入过程中不会显示口令，无论是明文还是密文均不显示。 </span>
$ sudo id -un
root<span style="color:#960050;background-color:#1e0010">&#39;</span>s password:
root

<span style="color:#75715e"># 只有以 sudo 开头的命令才会使用较高的特权运行。如果是不带 sudo 前缀的相同命令，仍会使用当前用户的特权运行。 </span>
$ id -un
tux

<span style="color:#75715e"># 在限定时间内，您无需再次输入 root 口令。 </span>
$ sudo id -un
root
</code></pre></div><p>I/O 重定向的工作方式与您预期的可能不同：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo echo s &gt; /proc/sysrq-trigger
bash: /proc/sysrq-trigger: Permission denied
$ sudo cat &lt; /proc/1/maps
bash: /proc/1/maps: Permission denied
</code></pre></div><p>只有 <code>echo</code>/<code>cat</code> 二进制会使用较高特权运行，重定向则由用户外壳使用用户特权执行。您可以按<a href="#%E5%90%AF%E5%8A%A8%E5%A4%96%E5%A3%B3">启动外壳</a>中所述启动外壳，也可以使用 <code>dd</code> 实用程序来启动：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ echo s | sudo dd of<span style="color:#f92672">=</span>/proc/sysrq-trigger
$ sudo dd <span style="color:#66d9ef">if</span><span style="color:#f92672">=</span>/proc/1/maps | cat
</code></pre></div><h5 id="启动外壳">启动外壳<a hidden class="anchor" aria-hidden="true" href="#启动外壳">#</a></h5>
<p>必须在每条命令前加上 <code>sudo</code> 可能很繁琐。虽然可以将外壳指定为命令 <code>sudo bash</code>，但还是建议您使用以下其中一种内置机制来启动外壳：</p>
<ul>
<li>
<p><code>sudo -s (&lt;命令&gt;)</code></p>
<p>启动 <code>SHELL</code> 环境变量所指定的外壳或目标用户的默认外壳。如果给定了命令，则会将该命令传递给外壳（使用 <code>-c</code> 选项），否则外壳会以交互模式运行。</p>
<pre tabindex="0"><code>$ sudo -s
root's password:
$ exit
</code></pre></li>
<li>
<p><code>sudo -i (&lt;命令&gt;)</code></p>
</li>
<li>
<p>与 <code>-s</code> 类似，但是会将外壳启动为登录外壳。也就是说，系统会对外壳的启动文件（<code>.profile</code> 等）进行处理，并会将当前的工作目录设置为目标用户的主目录。</p>
<pre tabindex="0"><code>$ sudo -i
root's password:
$ exit
</code></pre></li>
</ul>
<h5 id="环境变量">环境变量<a hidden class="anchor" aria-hidden="true" href="#环境变量">#</a></h5>
<p>默认情况下，<code>sudo</code> 不会传播环境变量：</p>
<pre tabindex="0"><code>$ ENVVAR=test env | grep ENVVAR
ENVVAR=test
$ ENVVAR=test sudo env | grep ENVVAR
root's password:

$
</code></pre><p>输出为空即表明在使用 <code>sudo</code> 运行的命令的环境中不存在环境变量 <code>ENVVAR</code>。</p>
<p>此行为可通过 <code>env_reset</code> 选项进行更改，请参见下文<a href="#%E6%9C%89%E7%94%A8%E7%9A%84%E6%A0%87%E5%BF%97%E5%92%8C%E9%80%89%E9%A1%B9">有用的标志和选项</a>。</p>
<h4 id="配置-sudo">配置 <code>sudo</code><a hidden class="anchor" aria-hidden="true" href="#配置-sudo">#</a></h4>
<p><code>sudo</code> 是一个非常灵活的工具，提供各种配置选项。</p>
<p>注意：如果您不小心将自己锁定在 <code>sudo</code> 之外，则可以使用 <code>su -</code> 及 <code>root</code> 口令来获取 root 外壳。要修复该错误，请运行 <code>visudo</code>。</p>
<h5 id="编辑配置文件">编辑配置文件<a hidden class="anchor" aria-hidden="true" href="#编辑配置文件">#</a></h5>
<p><code>sudo</code> 的主要策略配置文件为 <code>/etc/sudoers</code>。如果此文件中存在错误，您可能便会无法进入系统，因此强烈建议您使用 <code>visudo</code> 来编辑配置文件。此举可防止同时更改打开的文件，并会在保存修改之前检查语法错误。</p>
<p>您还可以通过设置 <code>EDITOR</code> 环境变量来使用除 vi 以外的编辑器（不论名字如何），例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo EDITOR<span style="color:#f92672">=</span>/usr/bin/nano visudo
</code></pre></div><p>不过，<code>/etc/sudoers</code> 文件本身是由系统包提供的，更新时这些修改可能会取消。因此，建议您将自定义配置放到 <code>/etc/sudoers.d/</code> 目录下的文件中。该目录下的任何文件都会自动纳入系统中。要在该子目录下创建或编辑文件，请运行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">sudo visudo -f /etc/sudoers.d/NAME
</code></pre></div><p>或者，使用其他编辑器（例如 <code>nano</code>）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">sudo EDITOR<span style="color:#f92672">=</span>/usr/bin/nano visudo -f /etc/sudoers.d/NAME
</code></pre></div><p>注意：<code>/etc/sudoers</code> 中的 <code>#includedir</code> 命令（用于 <code>/etc/sudoers.d</code>）会忽略以 <code>~</code>（波浪号）结尾或包含 <code>.</code>（点）的文件。</p>
<p>关于 <code>visudo</code> 命令的详细信息，请运行 <code>man 8 visudo</code>。</p>
<h5 id="sudoers-基本配置语法">sudoers 基本配置语法<a hidden class="anchor" aria-hidden="true" href="#sudoers-基本配置语法">#</a></h5>
<p>在 sudoers 配置文件中，有两种类型的选项：字符串和标志。字符串可以包含任何值，而标志则只能在“ON”或“OFF”之间切换。sudoers 配置文件最重要的语法构造为：</p>
<pre tabindex="0"><code># Everything on a line after a # gets ignored, 

Defaults !insults # Disable the insults flag 

Defaults env_keep += &quot;DISPLAY HOME&quot; # Add DISPLAY and HOME to env_keep
tux ALL = NOPASSWD: /usr/bin/frobnicate, PASSWD: /usr/bin/journalctl 
</code></pre><ul>
<li><code>#include</code> 和 <code>#includedir</code> 这两个普通命令例外。其后跟数字，用于指定 UID。</li>
<li>去除 <code>!</code> 可将指定的标志设置为“ON”。</li>
</ul>
<p><strong>有用的标志和选项</strong></p>
<table>
<thead>
<tr>
<th>选项名称</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>targetpw</code></td>
<td>此标志控制调用用户是需要输入目标用户（例如 <code>root</code>）的口令 (ON) 还是需要输入调用用户的口令 (OFF)。</td>
<td><code>Defaults targetpw # Turn targetpw flag ON</code></td>
</tr>
<tr>
<td><code>rootpw</code></td>
<td>如果设置了该选项，<code>sudo</code> 会提示输入 <code>root</code> 口令，而非目标用户或调用者的口令。默认值为“OFF”。</td>
<td><code>Defaults !rootpw # Turn rootpw flag OFF</code></td>
</tr>
<tr>
<td><code>env_reset</code></td>
<td>如果设置了该选项，<code>sudo</code> 会构造一个仅包含 <code>TERM</code>、<code>PATH</code>、<code>HOME</code>、<code>MAIL</code>、<code>SHELL</code>、<code>LOGNAME</code>、<code>USER</code>、<code>USERNAME</code> 和 <code>SUDO_*</code> 集的最小环境。此外，会从调用环境导入 <code>env_keep</code> 中列出的变量。默认值为“ON”。</td>
<td><code>Defaults env_reset # Turn env_reset flag ON</code></td>
</tr>
<tr>
<td><code>env_keep</code></td>
<td><code>env_reset</code> 标志设为“ON”时要保留的环境变量列表。</td>
<td><code># Set env_keep to contain EDITOR and PROMPT Defaults env_keep = &quot;EDITOR PROMPT&quot; Defaults env_keep += &quot;JRE_HOME&quot; # Add JRE_HOME Defaults env_keep -= &quot;JRE_HOME&quot; # Remove JRE_HOME</code></td>
</tr>
<tr>
<td><code>env_delete</code></td>
<td><code>env_reset</code> 标志设为“OFF”时要去除的环境变量列表。</td>
<td><code># Set env_delete to contain EDITOR and PROMPT Defaults env_delete = &quot;EDITOR PROMPT&quot; Defaults env_delete += &quot;JRE_HOME&quot; # Add JRE_HOME Defaults env_delete -= &quot;JRE_HOME&quot; # Remove JRE_HOME</code></td>
</tr>
</tbody>
</table>
<p>还可以使用 <code>Defaults</code> 令牌为用户、主机和命令集合创建别名。并且，可以仅将选项应用到特定用户集。</p>
<p>关于 <code>/etc/sudoers</code> 配置文件的详细信息，请参见 <code>man 5 sudoers</code>。</p>
<h5 id="sudoers-中的规则">sudoers 中的规则<a hidden class="anchor" aria-hidden="true" href="#sudoers-中的规则">#</a></h5>
<p>sudoers 配置中的规则可能会非常复杂，因此本节仅涉及基本内容。每个规则都遵循基本模式（<code>[]</code> 标记的是可选部分）：</p>
<pre tabindex="0"><code>#Who      Where         As whom      Tag                What
User_List Host_List = [(User_List)] [NOPASSWD:|PASSWD:] Cmnd_List
</code></pre><ul>
<li>
<p><code>User_List</code></p>
<p>一个或多个（用 <code>,</code> 分隔）标识符：用户名、格式为 <code>%GROUPNAME</code> 的组或格式为 <code>#UID</code> 的用户 ID。可以使用 <code>!</code> 前缀来取反。</p>
</li>
<li>
<p><code>Host_List</code></p>
<p>一个或多个（用 <code>,</code> 分隔）标识符：（完全限定的）主机名或 IP 地址。可以使用 <code>!</code> 前缀来取反。<code>Host_List</code> 的惯常选项为 <code>ALL</code>。</p>
</li>
<li>
<p><code>NOPASSWD:|PASSWD:</code></p>
<p>如果用户在 <code>NOPASSWD:</code> 后面运行的命令与 <code>CMDSPEC</code> 匹配，系统不会提示用户输入口令。</p>
<p><code>PASSWD</code> 为默认选项，仅当两个选项位于同一行时才需要指定它：</p>
<pre tabindex="0"><code>tux ALL = PASSWD: /usr/bin/foo, NOPASSWD: /usr/bin/bar
</code></pre></li>
<li>
<p><code>Cmnd_List</code></p>
<p>一个或多个（用 <code>,</code> 分隔）区分符：可执行文件的路径，后跟允许使用的自变量或什么也不跟。</p>
<pre tabindex="0"><code>/usr/bin/foo     # Anything allowed
/usr/bin/foo bar # Only &quot;/usr/bin/foo bar&quot; allowed
/usr/bin/foo &quot;&quot;  # No arguments allowed
</code></pre></li>
</ul>
<p><code>ALL</code> 可以用作 <code>User_List</code>、<code>Host_List</code> 和 <code>Cmnd_List</code>。</p>
<p>允许 <code>tux</code> 在无需输入口令的情况下以 root 身份运行所有命令的规则：</p>
<pre tabindex="0"><code>tux ALL = NOPASSWD: ALL
</code></pre><p>允许 <code>tux</code> 运行 <code>systemctl restart apache2</code> 的规则：</p>
<pre tabindex="0"><code>tux ALL = /usr/bin/systemctl restart apache2
</code></pre><p>允许 <code>tux</code> 在不带自变量的情况下以 <code>admin</code> 身份运行 <code>wall</code> 的规则：</p>
<pre tabindex="0"><code>tux ALL = (admin) /usr/bin/wall &quot;&quot;
</code></pre><p>警告：以下类型的构造</p>
<pre tabindex="0"><code>ALL ALL = ALL
</code></pre><p>在没有 <code>Defaults targetpw</code> 的情况下<em>切勿</em>使用，否则任何人都能以 <code>root</code> 身份运行命令。</p>
<h4 id="常见使用情况">常见使用情况<a hidden class="anchor" aria-hidden="true" href="#常见使用情况">#</a></h4>
<p>尽管默认配置对于简单的设置和桌面环境通常已经够用，但是自定义配置非常有用。</p>
<h5 id="在无需-root-口令的情况下使用-sudo">在无需 <code>root</code> 口令的情况下使用 <code>sudo</code><a hidden class="anchor" aria-hidden="true" href="#在无需-root-口令的情况下使用-sudo">#</a></h5>
<p>在具有特殊限制（“用户 X 只能以 <code>root</code>” 身份运行命令 Y）的情况下，无法实现此目的。在其他情况下，还是建议进行某种分隔。按照惯例，组 <code>wheel</code> 的成员能以 root 身份运行所有带有 <code>sudo</code> 的命令。</p>
<ol>
<li>
<p>将自己添加到 <code>wheel</code> 组</p>
<p>如果您自己的用户帐户尚不是 <code>wheel</code> 组的成员，请添加该帐户，具体做法是运行 <code>sudo usermod -a -G wheel 用户名</code>然后注销并再次登录。运行 <code>groups 用户名</code>以确认更改是否成功。</p>
</li>
<li>
<p>将使用调用用户的口令进行身份验证的选项设为默认设置。</p>
<p>使用 <code>visudo</code> 创建文件 <code>/etc/sudoers.d/userpw</code>并添加：</p>
<pre tabindex="0"><code>Defaults !targetpw
</code></pre></li>
<li>
<p>选择新默认规则。</p>
<p>根据是否想要用户重新输入口令，取消对 <code>/etc/sudoers</code> 中特定行的注释，并将默认规则注释掉。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">## Uncomment to allow members of group wheel to execute any command</span>
<span style="color:#75715e"># %wheel ALL=(ALL) ALL</span>

<span style="color:#75715e">## Same thing without a password</span>
<span style="color:#75715e"># %wheel ALL=(ALL) NOPASSWD: ALL</span>
</code></pre></div></li>
<li>
<p>提高默认规则的限制性</p>
<p>将 <code>/etc/sudoers</code> 中允许一切操作的规则注释掉或去除：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">ALL     ALL<span style="color:#f92672">=(</span>ALL<span style="color:#f92672">)</span> ALL   <span style="color:#75715e"># WARNING! Only use this together with &#39;Defaults targetpw&#39;!</span>
</code></pre></div></li>
<li>
<p>警告：切勿漏掉这一步，否则<em>任何</em>用户都能以 <code>root</code> 身份执行<em>任何</em>命令。</p>
</li>
<li>
<p>测试配置</p>
<p>尝试以 <code>wheel</code> 的成员和非成员身份运行 <code>sudo</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># user tux</span>
$ groups
users wheel
$ sudo id -un
tux<span style="color:#960050;background-color:#1e0010">&#39;</span>s password:
root

<span style="color:#75715e"># use wilber</span>
$ groups
users
$ sudo id -un
wilber is not in the sudoers file.  This incident will be reported.
</code></pre></div></li>
</ol>
<h5 id="对-xorg-应用程序使用-sudo">对 X.Org 应用程序使用 <code>sudo</code><a hidden class="anchor" aria-hidden="true" href="#对-xorg-应用程序使用-sudo">#</a></h5>
<p>在使用 <code>sudo</code> 启动图形应用程序时，可能会出现以下错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo xterm
xterm: Xt error: Can<span style="color:#960050;background-color:#1e0010">&#39;</span>t open display: %s
xterm: DISPLAY is not set
</code></pre></div><p>YaST 会选择 ncurses 界面而非图形界面。</p>
<p>要在通过 <code>sudo</code> 启动的应用程序中使用 X.Org，需要传播环境变量 <code>DISPLAY</code> 和 <code>XAUTHORITY</code>。要进行此项配置，请创建文件 <code>/etc/sudoers.d/xorg</code>并添加下面一行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">Defaults env_keep <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;DISPLAY XAUTHORITY&#34;</span>
</code></pre></div><p>如尚未设置 <code>XAUTHORITY</code> 变量，请按如下方式设置：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">export XAUTHORITY<span style="color:#f92672">=</span>~/.Xauthority
</code></pre></div><p>现在，X.Org 应用程序便可正常运行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo yast2
</code></pre></div><h3 id="zypperhttpsdocumentationsusecomzh-cnsles15-gahtmlsles-allcha-sw-clhtmlsec-zypper"><a href="https://documentation.suse.com/zh-cn/sles/15-GA/html/SLES-all/cha-sw-cl.html#sec-zypper">Zypper</a><a hidden class="anchor" aria-hidden="true" href="#zypperhttpsdocumentationsusecomzh-cnsles15-gahtmlsles-allcha-sw-clhtmlsec-zypper">#</a></h3>
<p>Zypper 是用于安装、更新和去除包的命令行包管理器。它还可管理储存库。这一点对于完成远程软件管理任务或从外壳脚本管理软件尤其有用。</p>
<h4 id="一般使用">一般使用<a hidden class="anchor" aria-hidden="true" href="#一般使用">#</a></h4>
<p>Zypper 的常用语法为：</p>
<pre tabindex="0"><code>zypper [--global-options] COMMAND  [--command-options] [arguments]
</code></pre><p>有关常规选项和所有命令的列表，请参见 <code>zypper help</code>。要获取有关特定命令的帮助，请键入 <code>zypper help   命令</code>。</p>
<ul>
<li>
<p>Zypper 命令</p>
<p>执行 Zypper 最简单的方式是，键入其名称后跟一个命令。例如，要将所有需要的增补程序应用于系统，请使用：</p>
<pre tabindex="0"><code>$ sudo zypper patch
</code></pre></li>
<li>
<p>全局选项</p>
<p>此外，您还可以选择使用一个或多个全局选项，只需在命令前面键入它们即可：</p>
<pre tabindex="0"><code>$ sudo zypper --non-interactive patch
</code></pre><p>在上面的示例中，选项 <code>--non-interactive</code> 表示在不询问任何问题的情况下运行命令（自动应用默认回答）。</p>
</li>
<li>
<p>命令特定的选项</p>
<p>要使用特定于某个命令的选项，请紧接在该命令后面键入这些选项：</p>
<pre tabindex="0"><code>$ sudo zypper patch --auto-agree-with-licenses
</code></pre><p>在上面的示例中，<code>--auto-agree-with-licenses</code> 用于将所有需要的增补程序应用于系统，不要求您确认任何许可条款，而是自动接受许可条款。</p>
</li>
<li>
<p>自变量</p>
<p>某些命令需要一个或多个自变量。例如，使用 <code>install</code> 命令时，需要指定您要<em>安装</em>的一个或多个包：</p>
<pre tabindex="0"><code>$ sudo zypper install mplayer
</code></pre><p>某些选项还需要单个自变量。用以下命令可列出所有已知模式：</p>
<pre tabindex="0"><code>$ zypper search -t pattern
</code></pre></li>
</ul>
<p>您可以组合上述所有模式。例如，下面的命令在冗长模式下运行时将安装 mc and vim 包（来自 <code>factory</code> 储存库）：</p>
<pre tabindex="0"><code>$ sudo zypper -v install --from factory mc vim
</code></pre><p><code>--from</code> 选项确保了在从指定储存库请求包时保留所有储存库的启用状态（用于解析任何依赖项）。</p>
<p>多数 Zypper 命令都有 <code>dry-run</code> 选项，它模拟给定的命令。它可用于测试。</p>
<pre tabindex="0"><code>$ sudo zypper remove --dry-run MozillaFirefox
</code></pre><p>Zypper 支持 <code>--userdata 字符串</code>全局选项。您可以使用此选项指定一个将会写入 Zypper 的日志文件和插件（例如 Btrfs 插件）的字符串。它可以用于标记和标识日志文件中的事务。</p>
<pre tabindex="0"><code>$ sudo zypper --userdata STRING patch
</code></pre><h4 id="使用-zypper-安装和删除软件">使用 Zypper 安装和删除软件<a hidden class="anchor" aria-hidden="true" href="#使用-zypper-安装和删除软件">#</a></h4>
<p>要安装或去除包，请使用以下命令：</p>
<pre tabindex="0"><code>$ sudo zypper install PACKAGE_NAME$ sudo zypper remove PACKAGE_NAME
</code></pre><p>警告：不要去除必需的系统包，例如 glibc 、zypper、kernel。如果去除这些包，系统可能会变得不稳定，或完全停止工作。</p>
<h5 id="选择要安装或去除的包">选择要安装或去除的包<a hidden class="anchor" aria-hidden="true" href="#选择要安装或去除的包">#</a></h5>
<p>可以使用 <code>zypper install</code> 和 <code>zypper remove</code> 命令通过多种方法来找到包。</p>
<ul>
<li>
<p>按确切的包名称</p>
<pre tabindex="0"><code>$ sudo zypper install MozillaFirefox
</code></pre></li>
<li>
<p>按确切的包名称和版本号</p>
<pre tabindex="0"><code>$ sudo zypper install MozillaFirefox-52.2
</code></pre></li>
<li>
<p>按储存库别名和包名称</p>
<pre tabindex="0"><code>$ sudo zypper install mozilla:MozillaFirefox
</code></pre><p>其中 <code>mozilla</code> 是用于安装的储存库别名。</p>
</li>
<li>
<p>使用通配符按包名称</p>
<p>您可以选择名称以特定字符串开头或结尾的所有包。使用通配符要小心，特别是去除包的时候。以下命令将安装名称以“Moz”开头的所有包：</p>
<pre tabindex="0"><code>$ sudo zypper install 'Moz*'
</code></pre><p>提示：在调试问题时，您有时需要临时安装大量的 <code>-debuginfo</code> 包，以获取有关正在运行的进程的详细信息。在调试会话完成后，如果您需要清理环境，请运行以下命令：</p>
<pre tabindex="0"><code>$ sudo zypper remove '*-debuginfo'
</code></pre></li>
<li>
<p>按功能</p>
<p>例如，要安装不知道名称的包，这些功能就很有用。下面的命令将安装包 MozillaFirefox：</p>
<pre tabindex="0"><code>$ sudo zypper install firefox
</code></pre></li>
<li>
<p>按功能、硬件体系结构或版本</p>
<ul>
<li>
<p>所需硬件体系结构的名称需要追加在功能的后面，两者以句点分隔。例如，要指定 AMD64/Intel 64 体系结构（在 Zypper 中命名为 <code>x86_64</code>），请使用：</p>
<pre tabindex="0"><code>$ sudo zypper install 'firefox.x86_64'
</code></pre></li>
<li>
<p>版本必须追加到字符串的末尾，并且前面必须带有一个运算符：<code>&lt;</code>（小于）、<code>&lt;=</code>（小于等于）、<code>=</code>（等于）、<code>&gt;=</code>（大于等于）或 <code>&gt;</code>（大于）。</p>
<pre tabindex="0"><code>$ sudo zypper install 'firefox&gt;=52.2'
</code></pre></li>
<li>
<p>还可以指定硬件体系结构与版本组合要求：</p>
<pre tabindex="0"><code>$ sudo zypper install 'firefox.x86_64&gt;=52.2'
</code></pre></li>
</ul>
</li>
<li>
<p>按 RPM 文件的路径</p>
<p>您还可以指定包的本地或远程路径：</p>
<pre tabindex="0"><code>$ sudo zypper install /tmp/install/MozillaFirefox.rpm$ sudo zypper install http://download.example.com/MozillaFirefox.rpm
</code></pre></li>
</ul>
<h5 id="同时安装和去除包">同时安装和去除包<a hidden class="anchor" aria-hidden="true" href="#同时安装和去除包">#</a></h5>
<p>要同时安装和去除包，请使用 <code>+/-</code> 修饰符。要安装 emacs 并同时去除 vim ，请使用：</p>
<pre tabindex="0"><code>$ sudo zypper install emacs -vim
</code></pre><p>要去除  emacs 并同时安装 vim ，请使用：</p>
<pre tabindex="0"><code>$ sudo zypper remove emacs +vim
</code></pre><p>为避免 <code>-</code> 开头的包名称被解释为命令行选项，要始终把它用作第二个自变量。如果做不到这点，在它之前加上 <code>--</code>：</p>
<pre tabindex="0"><code>$ sudo zypper install -emacs +vim       # Wrong$ sudo zypper install vim -emacs        # Correct$ sudo zypper install -- -emacs +vim    # Correct$ sudo zypper remove emacs +vim         # Correct
</code></pre><h5 id="清理已去除包的依赖项">清理已去除包的依赖项<a hidden class="anchor" aria-hidden="true" href="#清理已去除包的依赖项">#</a></h5>
<p>如果您想将在指定的包去除后不再需要的所有包（随指定的包）自动去除，请使用 <code>--clean-deps</code> 选项：</p>
<pre tabindex="0"><code>$ sudo zypper rm PACKAGE_NAME --clean-deps
</code></pre><h5 id="在脚本中使用-zypper">在脚本中使用 Zypper<a hidden class="anchor" aria-hidden="true" href="#在脚本中使用-zypper">#</a></h5>
<p>默认情况下，在安装或删除选定包之前发生问题时，Zypper 会要求确认。您可以使用 <code>--non-interactive</code> 选项覆盖此行为。必须在实际命令（<code>install</code>、<code>remove</code> 和 <code>patch</code>）的前面指定此选项，如下所示：</p>
<pre tabindex="0"><code>$ sudo zypper --non-interactive install PACKAGE_NAME
</code></pre><p>该选项允许在脚本和 cron 任务中使用 Zypper。</p>
<h5 id="安装或下载源包">安装或下载源包<a hidden class="anchor" aria-hidden="true" href="#安装或下载源包">#</a></h5>
<p>要安装某个包的对应源代码包，请使用：</p>
<pre tabindex="0"><code>$ zypper source-install PACKAGE_NAME
</code></pre><p>以 <code>root</code> 身份执行时，源包的默认安装位置为 <code>/usr/src/packages/</code>；以用户身份运行时，则为 <code>~/rpmbuild</code>。可以在本地 <code>rpm</code> 配置中更改这些值。</p>
<p>使用此命令还会安装指定包的版本依赖项。如果不想执行此操作，请添加开关 <code>-D</code>：</p>
<pre tabindex="0"><code>$ sudo zypper source-install -D PACKAGE_NAME
</code></pre><p>要只安装版本依赖项，请使用 <code>-d</code>。</p>
<pre tabindex="0"><code>$ sudo zypper source-install -d PACKAGE_NAME
</code></pre><p>当然，只有当储存库列表中启用了含有源包的储存库时，才能这样做（默认添加但不启用它）。</p>
<p>可使用以下方法来获取储存库中所有源包的列表：</p>
<pre tabindex="0"><code>$ zypper search -t srcpackage
</code></pre><p>您也可以将所有已安装软件包的源包下载到本地目录。要下载源包，请使用：</p>
<pre tabindex="0"><code>$ zypper source-download
</code></pre><p>默认的下载目录是 <code>/var/cache/zypper/source-download</code>。您可以使用 <code>--directory</code> 选项更改下载目录。若只想显示缺失或多余的包而不进行下载或删除任何内容，请使用 <code>--status</code> 选项。要删除多余的源包，请使用 <code>--delete</code> 选项。要禁用删除，请使用 <code>--no-delete</code> 选项。</p>
<h5 id="从禁用的储存库安装包">从禁用的储存库安装包<a hidden class="anchor" aria-hidden="true" href="#从禁用的储存库安装包">#</a></h5>
<p>通常，您只能安装或刷新来自启用的储存库的包。<code>--plus-content 标记</code>选项可帮助您指定要刷新的、要在当前 Zypper 会话期间暂时启用的，以及要在会话完成后禁用的储存库。</p>
<p>例如，要启用可以提供其他 <code>-debuginfo</code> 或 <code>-debugsource</code> 包的储存库，请使用 <code>--plus-content debug</code>。可以多次指定此选项。</p>
<p>要暂时启用此类“调试”储存库以安装特定的 <code>-debuginfo</code> 包，请按如下所示使用该选项：</p>
<pre tabindex="0"><code>$ sudo zypper --plus-content debug \   install &quot;debuginfo(build-id)=eb844a5c20c70a59fc693cd1061f851fb7d046f4&quot;
</code></pre><p>对于缺少的 debuginfo 包，<code>gdb</code> 将会报告 <code>build-id</code> 字符串。</p>
<h5 id="实用程序">实用程序<a hidden class="anchor" aria-hidden="true" href="#实用程序">#</a></h5>
<p>要校验所有依赖项是否仍然满足，并修复缺少的依赖项，请使用：</p>
<pre tabindex="0"><code>$ zypper verify
</code></pre><p>除了依赖项必须满足外，某些包还“推荐”其他包。只有在实际可用并可安装时才会安装这些推荐包。如果推荐的包在推荐它们的包已安装（通过添加其他包或硬件）之后才可用，请使用以下命令：</p>
<pre tabindex="0"><code>$ sudo zypper install-new-recommends
</code></pre><p>此命令在插入网络摄像头或 Wi-Fi 设备后非常有用。如果可用，它将安装设备驱动程序和相关软件。只有在满足特定硬件依赖项后，才可安装驱动程序和相关软件。</p>
<h4 id="使用-zypper-更新软件">使用 Zypper 更新软件<a hidden class="anchor" aria-hidden="true" href="#使用-zypper-更新软件">#</a></h4>
<p>用 Zypper 更新软件有三种方式：安装包、安装包的新版本或更新整个分发包。最后一种方式可通过 <code>zypper dist-upgrade</code> 来实现。</p>
<h5 id="安装全部所需的增补程序">安装全部所需的增补程序<a hidden class="anchor" aria-hidden="true" href="#安装全部所需的增补程序">#</a></h5>
<p>要安装所有适用于您系统的正式发布的增补程序，请运行：</p>
<pre tabindex="0"><code>$ sudo zypper patch
</code></pre><p>系统将会检查您计算机上配置的储存库中提供的所有增补程序是否与您的安装相关。如果相关（未分为<code>可选</code>或<code>功能</code>类别），则会立即安装这些增补程序。</p>
<p>如果即将安装的增补程序所包含的更改要求重引导系统，您会在重引导前收到警告。</p>
<p>单纯使用 <code>zypper patch</code> 命令不会应用来自第三方储存库的包。要同时更新第三方储存库，请使用 <code>with-update</code> 命令选项，如下所示：</p>
<pre tabindex="0"><code>$ sudo zypper patch --with update
</code></pre><p>要额外安装可选增补程序，请使用：</p>
<pre tabindex="0"><code>$ sudo zypper patch --with-optional
</code></pre><p>要安装与特定 Bugzilla 问题相关的所有增补程序，请使用：</p>
<pre tabindex="0"><code>$ sudo zypper patch --bugzilla=NUMBER
</code></pre><p>要安装与特定 CVE 数据库项相关的所有增补程序，请使用：</p>
<pre tabindex="0"><code>$ sudo zypper patch --cve=NUMBER
</code></pre><p>例如，要安装 CVE 编号为 <code>CVE-2010-2713</code> 的安全增补程序，请执行：</p>
<pre tabindex="0"><code>$ sudo zypper patch --cve=CVE-2010-2713
</code></pre><p>如果只想安装影响 Zypper 和包管理本身的增补程序，请使用：</p>
<pre tabindex="0"><code>$ sudo zypper patch --updatestack-only
</code></pre><p>请记住，如果您使用了 <code>updatestack-only</code> 命令选项，将会丢弃原本还会更新其他储存库的其他命令选项。</p>
<h5 id="列出增补程序">列出增补程序<a hidden class="anchor" aria-hidden="true" href="#列出增补程序">#</a></h5>
<p>为了让您确定增补程序是否可用，Zypper 允许您查看以下信息：</p>
<ul>
<li>
<p>所需增补程序的数目</p>
<p>要列出所需增补程序（适用于您的系统但尚未安装的增补程序）的数目，请使用 <code>patch-check</code>：</p>
<pre tabindex="0"><code>$ zypper patch-checkLoading repository data...Reading installed packages...5 patches needed (1 security patch)
</code></pre><p>可以结合 <code>--updatestack-only</code> 选项使用此命令，以便仅列出影响 Zypper 和包管理本身的增补程序。</p>
</li>
<li>
<p>所需增补程序的列表</p>
<p>要列出全部所需的增补程序（适用于您的系统但尚未安装的增补程序），请使用 <code>list-patches</code>：</p>
<pre tabindex="0"><code>$ zypper list-patchesLoading repository data...Reading installed packages...Repository     | Name        | Version | Category | Status  | Summary---------------+-------------+---------+----------+---------+---------SLES12-Updates | SUSE-2014-8 | 1       | security | needed  | openssl: Update for OpenSSL
</code></pre></li>
<li>
<p>所有增补程序的列表</p>
<p>要列出可用的所有增补程序，而不管它们是否已安装或适用于您的安装，请使用 <code>zypper patches</code>。</p>
<p>还可以列出并安装与特定问题相关的增补程序。要列出特定的增补程序，请使用带以下选项的 <code>zypper list-patches</code> 命令：</p>
<ul>
<li>
<p>按 Bugzilla 问题</p>
<p>要列出与 Bugzilla 问题相关的全部所需增补程序，请使用 <code>--bugzilla</code> 选项。</p>
<p>要列出针对特定 Bug 的增补程序，您也可以指定 Bug 编号：<code>--bugzilla=编号</code>。要搜索与多个 Bugzilla 问题相关的增补程序，请在 bug 编号之间添加逗号，例如：</p>
<pre tabindex="0"><code>$ zypper list-patches --bugzilla=972197,956917
</code></pre></li>
<li>
<p>按 CVE 编号</p>
<p>要列出与 CVE（公共漏洞和披露）数据库中某个项相关的全部所需增补程序，请使用 <code>--cve</code> 选项。</p>
<p>要列出针对特定 CVE 数据库项的增补程序，您也可以指定 CVE 编号：<code>--cve=*编号*</code>。要搜索与多个 CVE 数据库项相关的增补程序，请在 CVE 编号之间添加逗号，例如：</p>
<pre tabindex="0"><code>$ zypper list-patches --bugzilla=CVE-2016-2315,CVE-2016-2324
</code></pre></li>
</ul>
</li>
</ul>
<p>要列出所有增补程序而不管是否需要安装它们，请另外使用 <code>--all</code> 选项。例如，要列出指派有 CVE 编号的所有增补程序，请使用：</p>
<pre tabindex="0"><code>$ zypper list-patches --all --cveIssue | No.           | Patch             | Category    | Severity  | Status------+---------------+-------------------+-------------+-----------+----------cve   | CVE-2015-0287 | SUSE-SLE-Module.. | recommended | moderate  | neededcve   | CVE-2014-3566 | SUSE-SLE-SERVER.. | recommended | moderate  | not needed[...]
</code></pre><h5 id="安装新的包版本">安装新的包版本<a hidden class="anchor" aria-hidden="true" href="#安装新的包版本">#</a></h5>
<p>如果某个安装源只包含新包，但未提供增补程序，则 <code>zypper patch</code> 不会产生任何作用。要使用可用的较新版本更新所有已安装的包（同时还要保持系统完整性），请使用︰</p>
<pre tabindex="0"><code>$ sudo zypper update
</code></pre><p>要更新个别包，请用更新或安装命令指定包：</p>
<pre tabindex="0"><code>$ sudo zypper update PACKAGE_NAME$ sudo zypper install PACKAGE_NAME
</code></pre><p>可使用此命令来获取所有新的可安装包的列表：</p>
<pre tabindex="0"><code>$ zypper list-updates
</code></pre><p>请注意，此命令只会列出符合以下准则的包︰</p>
<ul>
<li>与已安装的包拥有相同的供应商，</li>
<li>由至少与已安装包拥有相同优先级的储存库提供，</li>
<li>可安装（满足所有依赖项）。</li>
</ul>
<p>所有新的可用包（无论是否可安装）的列表可通过以下方式获取：</p>
<pre tabindex="0"><code>$ sudo zypper list-updates --all
</code></pre><p>要找出新包无法安装的原因，请使用上面所述的 <code>zypper install</code> 或 <code>zypper update</code> 命令。</p>
<h5 id="识别孤立的包">识别孤立的包<a hidden class="anchor" aria-hidden="true" href="#识别孤立的包">#</a></h5>
<p>每当您从 Zypper 中去除某个储存库或者升级系统时，某些包可能会进入“孤立”状态。这些<em>孤立的</em>包不再属于任何活动储存库。以下命令可以列出这些包：</p>
<pre tabindex="0"><code>$ sudo zypper packages --orphaned
</code></pre><p>借助此列表，您可以确定是否仍然需要某个包，或者是否可以安全去除某个包。</p>
<h4 id="识别使用已删除文件的进程和服务">识别使用已删除文件的进程和服务<a hidden class="anchor" aria-hidden="true" href="#识别使用已删除文件的进程和服务">#</a></h4>
<p>在增补、更新或去除包时，系统上可能有一些正在运行的进程会继续使用更新或去除后已被删除的文件。运行 <code>zypper ps</code> 可以列出使用已删除文件的进程。如果此类进程属于某个已知的服务，则会列出服务名称，方便您重启动该服务。默认情况下，<code>zypper ps</code> 会显示一个表：</p>
<pre tabindex="0"><code>PID   | PPID | UID | User  | Command      | Service      | Files------+------+-----+-------+--------------+--------------+-------------------814   | 1    | 481 | avahi | avahi-daemon | avahi-daemon | /lib64/ld-2.19.s-&gt;      |      |     |       |              |              | /lib64/libdl-2.1-&gt;      |      |     |       |              |              | /lib64/libpthrea-&gt;      |      |     |       |              |              | /lib64/libc-2.19-&gt;[...]
</code></pre><ul>
<li>PID：进程的 ID</li>
<li>PPID：父进程的 ID</li>
<li>UID：运行进程的用户的 ID</li>
<li>User：运行进程的用户的登录名</li>
<li>Command：用于执行进程的命令</li>
<li>Service：服务名称（仅当命令与系统服务关联时才显示）</li>
<li>Files：已删除文件的列表</li>
</ul>
<p>通过如下方式可控制 <code>zypper ps</code> 的输出格式：</p>
<ul>
<li>
<p><code>zypper ps -s</code></p>
<p>创建一份简短表格，其中不会显示已删除的文件。</p>
<pre tabindex="0"><code>PID   | PPID | UID  | User    | Command      | Service------+------+------+---------+--------------+--------------814   | 1    | 481  | avahi   | avahi-daemon | avahi-daemon817   | 1    | 0    | root    | irqbalance   | irqbalance1567  | 1    | 0    | root    | sshd         | sshd1761  | 1    | 0    | root    | master       | postfix1764  | 1761 | 51   | postfix | pickup       | postfix1765  | 1761 | 51   | postfix | qmgr         | postfix2031  | 2027 | 1000 | tux     | bash         |
</code></pre></li>
<li>
<p><code>zypper ps -ss</code></p>
<p>仅显示与系统服务关联的进程。</p>
<pre tabindex="0"><code>PID   | PPID | UID  | User    | Command      | Service------+------+------+---------+--------------+--------------814   | 1    | 481  | avahi   | avahi-daemon | avahi-daemon817   | 1    | 0    | root    | irqbalance   | irqbalance1567  | 1    | 0    | root    | sshd         | sshd1761  | 1    | 0    | root    | master       | postfix1764  | 1761 | 51   | postfix | pickup       | postfix1765  | 1761 | 51   | postfix | qmgr         | postfix
</code></pre></li>
<li>
<p><code>zypper ps -sss</code></p>
<p>仅显示使用已删除文件的系统服务。</p>
<pre tabindex="0"><code>avahi-daemonirqbalancepostfixsshd
</code></pre></li>
<li>
<p><code>zypper ps --print &quot;systemctl status %s&quot;</code></p>
<p>显示用于检索可能需要重启动的服务状态信息的命令。</p>
<pre tabindex="0"><code>systemctl status avahi-daemonsystemctl status irqbalancesystemctl status postfixsystemctl status sshd
</code></pre></li>
</ul>
<h4 id="用-zypper-管理安装源">用 Zypper 管理安装源<a hidden class="anchor" aria-hidden="true" href="#用-zypper-管理安装源">#</a></h4>
<p>Zypper 的所有安装或增补程序命令均基于已知安装源列表。要列出系统已知的所有储存库，请使用命令：</p>
<pre tabindex="0"><code>$ zypper repos
</code></pre><p>结果将类似于与以下输出：</p>
<pre tabindex="0"><code># | Alias        | Name          | Enabled | Refresh--+--------------+---------------+---------+--------1 | SLEHA-12-GEO | SLEHA-12-GEO  | Yes     | No2 | SLEHA-12     | SLEHA-12      | Yes     | No3 | SLES12       | SLES12        | Yes     | No
</code></pre><p>当在各个命令中指定储存库时，可以使用别名、URI 或 <code>zypper repos</code> 命令输出中的储存库编号。储存库别名是用于储存库处理命令中的储存库名称的简短版本。请注意，在修改储存库列表后，储存库编号可能会更改。别名本身不会更改。</p>
<p>默认情况下不显示储存库的 URI 或优先级之类的细节。用以下命令可以列出所有细节：</p>
<pre tabindex="0"><code>$ zypper repos -d
</code></pre><h4 id="添加安装源">添加安装源<a hidden class="anchor" aria-hidden="true" href="#添加安装源">#</a></h4>
<p>要添加安装源，请运行</p>
<pre tabindex="0"><code>$ sudo zypper addrepo URI ALIAS
</code></pre><p>URI 可以是因特网储存库、网络资源、目录、CD 或 DVD。ALIAS 是储存库的唯一简写标识符。您可以随意选择别名，前提是它必须唯一。如果指定的别名已在使用，Zypper 将发出警告。</p>
<h4 id="刷新储存库">刷新储存库<a hidden class="anchor" aria-hidden="true" href="#刷新储存库">#</a></h4>
<p><code>zypper</code> 可让您从配置的储存库中提取包的更改。要提取更改，请运行：</p>
<pre tabindex="0"><code>$ sudo zypper refresh
</code></pre><p>注意：有些命令默认会自动执行 <code>refresh</code>，因此您不需要明确运行该命令。</p>
<p>使用 <code>refresh</code> 命令时搭配 <code>--plus-content</code> 选项还可查看已禁用储存库中的更改：</p>
<pre tabindex="0"><code>$ sudo zypper --plus-content refresh
</code></pre><p>该选项虽然会提取储存库中的更改，但会使禁用储存库的状态保持不变，即仍为禁用。</p>
<h5 id="删除储存库">删除储存库<a hidden class="anchor" aria-hidden="true" href="#删除储存库">#</a></h5>
<p>要从列表中去除某个储存库，请将命令 <code>zypper removerepo</code> 与要删除的储存库的别名或编号结合使用。例如</p>
<pre tabindex="0"><code>$ sudo zypper removerepo 1$ sudo zypper removerepo &quot;SLEHA-12-GEO&quot;
</code></pre><h5 id="修改储存库">修改储存库<a hidden class="anchor" aria-hidden="true" href="#修改储存库">#</a></h5>
<p>用 <code>zypper modifyrepo</code> 启用或禁用储存库。您还可以用该命令更改储存库的属性（例如刷新行为、名称或优先级）。以下命令将会启用名为 <code>updates</code> 的储存库、打开自动刷新并将其优先级设置为 20：</p>
<pre tabindex="0"><code>$ sudo zypper modifyrepo -er -p 20 'updates'
</code></pre><p>修改储存库并不局限于单个储存库 —— 您也可以对组执行该操作︰</p>
<ul>
<li>-a：所有储存库</li>
<li>-l：本地储存库</li>
<li>-t：远程储存库</li>
<li>-m 类型：特定类型的储存库（其中类型可以是以下之一：http、https、ftp、cd、dvd、dir、file、cifs、smb、nfs、hd 和 iso）</li>
</ul>
<p>要重命名安装源别名，请使用 <code>renamerepo</code> 命令。以下示例将别名从 <code>Mozilla Firefox</code> 更改为 <code>firefox</code>：</p>
<pre tabindex="0"><code>$ sudo zypper renamerepo 'Mozilla Firefox' firefox
</code></pre><h4 id="用-zypper-查询储存库和包">用 Zypper 查询储存库和包<a hidden class="anchor" aria-hidden="true" href="#用-zypper-查询储存库和包">#</a></h4>
<p>Zypper 提供各种查询储存库或包的方式。要获取所有可用的产品、模式、包或增补程序的列表，请使用以下命令：</p>
<pre tabindex="0"><code>$ zypper products$ zypper patterns$ zypper packages$ zypper patches
</code></pre><p>要查询特定包的所有储存库，请使用 <code>search</code>。要获得有关特定包的信息，请使用 <code>info</code> 命令。</p>
<h5 id="搜索软件">搜索软件<a hidden class="anchor" aria-hidden="true" href="#搜索软件">#</a></h5>
<p><code>zypper search</code> 命令可对包名或（视情况）对包摘要和说明执行搜索。括在 <code>/</code> 中的字符串会解译为正则表达式。默认情况下搜索不区分大小写。</p>
<ul>
<li>
<p>执行简单搜索来查找包含 <code>fire</code> 的包名称</p>
<pre tabindex="0"><code>$ zypper search &quot;fire&quot;
</code></pre></li>
<li>
<p>执行简单搜索来查找确切的包 <code>MozillaFirefox</code></p>
<pre tabindex="0"><code>$ zypper search --match-exact &quot;MozillaFirefox&quot;
</code></pre></li>
<li>
<p>同时在包描述和摘要中搜索</p>
<pre tabindex="0"><code>$ zypper search -d fire
</code></pre></li>
<li>
<p>仅显示尚未安装的包</p>
<pre tabindex="0"><code>$ zypper search -u fire
</code></pre></li>
<li>
<p>显示包含字符串 <code>fir</code> 且该字符串后面不是 <code>e</code> 的包</p>
<pre tabindex="0"><code>$ zypper se &quot;/fir[^e]/&quot;
</code></pre></li>
</ul>
<h5 id="搜索特定功能">搜索特定功能<a hidden class="anchor" aria-hidden="true" href="#搜索特定功能">#</a></h5>
<p>要搜索提供特殊功能的包，请使用命令 <code>what-provides</code>。例如，如果您想知道哪个包提供 Perl 模块 <code>SVN::Core</code>，请使用以下命令：</p>
<pre tabindex="0"><code>$ zypper what-provides 'perl(SVN::Core)'
</code></pre><p><code>what-provides 包名</code> 与 <code>rpm -q --whatprovides 包名</code> 类似，不过 RPM 只能查询 RPM 数据库（即所有已安装的包的数据库）。另一方面，Zypper 将告诉您任意储存库的功能的提供商，而非仅已安装的储存库功能的提供商。</p>
<h5 id="显示包信息">显示包信息<a hidden class="anchor" aria-hidden="true" href="#显示包信息">#</a></h5>
<p>要查询个别包，请使用 <code>info</code> 命令，并用完整包名称作为自变量。这会显示有关某个包的详细信息。如果包名与储存库中的所有包名都不匹配，该命令会输出非包匹配项的详细信息。如果您请求特定类型（通过使用 <code>-t</code> 选项），但该类型不存在，该命令会输出其他可用的匹配项，但不提供详细信息。</p>
<p>如果您指定源包，该命令会显示基于该源包构建的二进制包。如果您指定二进制包，该命令会输出用来构建该二进制包的源包。</p>
<p>如果还要显示该包必需/推荐的包，则使用选项 <code>--requires</code> 和 <code>--recommends</code>：</p>
<pre tabindex="0"><code>zypper info --requires MozillaFirefox
</code></pre><h4 id="显示生命周期信息">显示生命周期信息<a hidden class="anchor" aria-hidden="true" href="#显示生命周期信息">#</a></h4>
<p>要检查您的产品和所支持包的生命周期，请如下所示使用 <code>zypper lifecycle</code> 命令：</p>
<pre tabindex="0"><code>$ zypper lifecycleProduct end of supportCodestream: SUSE Linux Enterprise Server 15             2028-04-23    SUSE Linux Enterprise Server 15                     n/a*Module end of supportBasesystem Module                                       2021-07-31No packages with end of support different from product.*) See https://www.suse.com/lifecycle for latest information
</code></pre><h4 id="配置-zypper">配置 Zypper<a hidden class="anchor" aria-hidden="true" href="#配置-zypper">#</a></h4>
<p>Zypper 现在随附配置文件，允许您永久更改 Zypper 的行为（系统范围或用户特定）。要进行系统范围更改，请编辑 <code>/etc/zypp/zypper.conf</code>。要进行用户特定的更改，请编辑 <code>~/.zypper.conf</code>。如果 <code>~/.zypper.conf</code> 尚不存在，您可以使用 <code>/etc/zypp/zypper.conf</code> 作为模板：将其复制到 <code>~/.zypper.conf</code> 并根据您的喜好进行调整。请参见文件中的注释，获取有关可用选项的帮助。</p>
<h4 id="查错">查错<a hidden class="anchor" aria-hidden="true" href="#查错">#</a></h4>
<p>如果您在访问配置的储存库中的包时遇到问题（例如，尽管您知道某个包在某个储存库中，但 Zypper 找不到该包），刷新储存库或许可以解决问题：</p>
<pre tabindex="0"><code>sudo zypper refresh
</code></pre><p>如果不起作用，则尝试</p>
<pre tabindex="0"><code>sudo zypper refresh -fdb
</code></pre><p>这会强制完全刷新和重构建数据库，包括强制下载原始元数据。</p>
<h4 id="btrfs-文件系统上的-zypper-回滚功能">Btrfs 文件系统上的 Zypper 回滚功能<a hidden class="anchor" aria-hidden="true" href="#btrfs-文件系统上的-zypper-回滚功能">#</a></h4>
<p>如果根分区上使用的是 Btrfs 文件系统，且系统中安装了 <code>snapper</code>，当 Zypper 提交对文件系统所做的更改以创建相应的文件系统快照时，会自动调用 <code>snapper</code>。这些快照可用于还原 Zypper 进行的任何更改。</p>
<h3 id="rpmhttpsdocumentationsusecomzh-cnsles15-gahtmlsles-allcha-sw-clhtmlsec-rpm"><a href="https://documentation.suse.com/zh-cn/sles/15-GA/html/SLES-all/cha-sw-cl.html#sec-rpm">RPM</a><a hidden class="anchor" aria-hidden="true" href="#rpmhttpsdocumentationsusecomzh-cnsles15-gahtmlsles-allcha-sw-clhtmlsec-rpm">#</a></h3>
<p>RPM（RPM 程序包管理器）用于管理软件包。其主要程命令为 <code>rpm</code> 和 <code>rpmbuild</code>。用户、系统管理员和包构建人员可以查询强大的 RPM 数据库以获得有关已安装软件的详细信息。</p>
<p><code>rpm</code> 有五种模式：安装、卸装（或更新）软件包、重构建 RPM 数据库、查询 RPM 库或独立 RPM 存档、对包执行完整性检查以及对包签名。<code>rpmbuild</code> 可用于从原始源构建可安装的包。</p>
<p>用特殊的二进制格式对可安装 RPM 存档进行打包。这些存档由要安装的程序文件和某些元信息组成，这些元信息供 <code>rpm</code> 在安装过程中配置软件包使用或者储存在 RPM 数据库中进行存档。RPM 存档通常具有扩展名 <code>.rpm</code>。</p>
<p>对于一些包，软件开发所需的组件（库、报头、包含文件等）已纳入独立的包中。只有当您要自己编译软件时才需要这些开发包（例如最新的 GNOME 包）。可以通过扩展名 <code>-devel</code> 确定这些开发包，例如包 <code>alsa-devel</code> 和 <code>gimp-devel</code>。</p>
<h4 id="校验包真实性">校验包真实性<a hidden class="anchor" aria-hidden="true" href="#校验包真实性">#</a></h4>
<p>RPM 包具有 GPG 签名。要校验 RPM 包的签名，请使用 <code>rpm --checksig    PACKAGE-1.2.3.rpm</code> 命令确定该包是来自 SUSE 还是另一个可信机构。特别建议对来自因特网的更新包使用此命令。</p>
<p>修复操作系统中的问题时，您可能需要将问题临时修复 (PTF) 安装到生产系统中。SUSE 提供的包已使用特殊的 PTF 密钥签名。要手动导入该密钥，请使用以下命令：</p>
<pre tabindex="0"><code>sudo rpm --import \/usr/share/doc/packages/suse-build-key/suse_ptf_key.asc
</code></pre><p>导入该密钥后，您可以在系统上安装 PTF 包。</p>
<h4 id="管理包安装更新和卸装">管理包：安装、更新和卸装<a hidden class="anchor" aria-hidden="true" href="#管理包安装更新和卸装">#</a></h4>
<p>安装 RPM 存档的步骤通常十分简单，执行运行：<code>rpm -i PACKAGE.rpm</code>。使用此命令可以安装包，但前提是满足其依赖关系并且不与其他包冲突。如果出现错误消息，<code>rpm</code> 将请求那些需要安装的包以满足依赖关系要求。在后台，RPM 数据库确保不出现冲突 － 一个特定文件只能属于一个包。通过选择不同的选项，您可以强制 <code>rpm</code> 忽略这些默认设置，但这只供专家用户使用。否则，将影响系统的完整性并可能使系统无法更新。</p>
<p>选项 <code>-U</code> 或 <code>--upgrade</code> 以及 <code>-F</code> 或 <code>--freshen</code> 可用于更新包（例如，<code>rpm -F  PACKAGE.rpm</code>）。此命令将删除旧版本的文件并立即安装新文件。两个版本之间的差别是：<code>-U</code> 安装系统中以前不存在的包，而 <code>-F</code> 只更新以前安装的包。更新时，<code>rpm</code> 使用以下策略小心更新配置文件：</p>
<ul>
<li>如果配置文件未被系统管理员更改，则 <code>rpm</code> 将安装适当文件的新版本。系统管理员无需执行任何操作。</li>
<li>如果配置文件在更新前曾被系统管理员更改，则 <code>rpm</code> 会以扩展名 <code>.rpmorig</code> 或 <code>.rpmsave</code>（备份文件）保存更改的文件，并安装新包中的版本。仅当原先安装的文件和较新的版本不同时，才执行此操作。如果是这种情况，则将备份文件（<code>.rpmorig</code> 或 <code>.rpmsave</code>）与新安装的文件进行比较，并在新文件中再次进行更改。之后，请删除所有 <code>.rpmorig</code> 和 <code>.rpmsave</code> 文件，以免以后的更新出现问题。</li>
<li>如果配置文件已存在并且 <code>.spec</code> 文件中指定了 <code>noreplace</code> 标签，则出现 <code>.rpmnew</code> 文件。</li>
</ul>
<p>更新后，在使用 <code>.rpmsave</code> 和 <code>.rpmnew</code> 文件进行比较后应将它们删除，从而防止它们阻碍以后的更新。如果 RPM 数据库以前未能识别文件，则将为其指派扩展名 <code>.rpmorig</code>。  否则，将使用 <code>.rpmsave</code>。换句话说，<code>.rpmorig</code> 是从异系统格式更新为 RPM 的结果。而 <code>.rpmsave</code> 是从较早的 RPM 更新为较新的 RPM 的结果。<code>.rpmnew</code> 不提供任何有关系统管理员是否对配置文件进行过任何更改的信息。<code>/var/adm/rpmconfigcheck</code> 中提供这些文件的列表。不覆盖某些配置文件（如 <code>/etc/httpd/httpd.conf</code>）以允许继续进行操作。</p>
<p><code>-U</code> 开关的作用并<em>不</em>完全等同于使用 <code>-e</code> 选项进行卸载以及使用 <code>-i</code> 选项进行安装，它还有其他作用。只要可能，就可以使用 <code>-U</code>。</p>
<p>要去除包，请输入 <code>rpm -e PACKAGE</code>。仅当不存在未解决的依赖项问题时，此命令才会删除包。例如，只要有其他程序需要 Tcl/Tk，理论上就不能删除它。即使是在这种情况下，RPM 也会向数据库寻求帮助。如果出于任何原因无法进行此删除操作（即使<em>不</em>存在其他依赖项），则最好使用选项 <code>--rebuilddb</code> 重构建 RPM 数据库。</p>
<h4 id="增量-rpm-包">增量 RPM 包<a hidden class="anchor" aria-hidden="true" href="#增量-rpm-包">#</a></h4>
<p>增量 RPM 包包含旧版本和新版本的 RPM 包之间的差别。在旧 RPM 上应用增量 RPM 将得到全新的 RPM。不需要旧 RPM  的副本，因为增量 RPM 也可以与已安装的 RPM 一起工作。增量 RPM 包的大小甚至比增补程序 RPM  小，这有利于通过因特网传送更新包。缺点是，涉及增量 RPM 的更新操作与使用纯粹 RPM 或增补程序 RPM 进行更新的情况相比，占用的 CPU 周期要长得多。</p>
<p><code>makedeltarpm</code> 和 <code>applydelta</code> 二进制文件是增量 RPM 套件（包 <code>deltarpm</code>）的一部分，可帮助您创建和应用增量 RPM 包。使用以下命令可以创建名为 <code>new.delta.rpm</code> 的增量 RPM。以下命令假设 <code>old.rpm</code> 和 <code>new.rpm</code> 是存在的：</p>
<pre tabindex="0"><code>sudo makedeltarpm old.rpm new.rpm new.delta.rpm
</code></pre><p>如果旧包已经安装，则使用 <code>applydeltarpm</code> 可以从文件系统重新构建新的 RPM：</p>
<pre tabindex="0"><code>sudo applydeltarpm new.delta.rpm new.rpm
</code></pre><p>如果不访问文件系统而从旧 RPM 得到它，请使用 <code>-r</code> 选项：</p>
<pre tabindex="0"><code>sudo applydeltarpm -r old.rpm new.delta.rpm new.rpm
</code></pre><h4 id="rpm-查询">RPM 查询<a hidden class="anchor" aria-hidden="true" href="#rpm-查询">#</a></h4>
<p>带 <code>-q</code> 选项的 <code>rpm</code> 将启动查询，如此用户便可查看 RPM 存档（通过添加选项 <code>-p</code>）并查询已安装包的 RPM 数据库。可以使用多个开关指定所需信息的类型。</p>
<table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>-i</code></td>
<td style="text-align:left">包信息</td>
</tr>
<tr>
<td style="text-align:left"><code>-l</code></td>
<td style="text-align:left">文件列表</td>
</tr>
<tr>
<td style="text-align:left"><code>-f FILE</code></td>
<td style="text-align:left">查询包含文件 <em>FILE</em> 的包（必须使用 <em>FILE</em> 指定完整路径）</td>
</tr>
<tr>
<td style="text-align:left"><code>-s</code></td>
<td style="text-align:left">带有状态信息的文件列表（间接指定 <code>-l</code>）</td>
</tr>
<tr>
<td style="text-align:left"><code>-d</code></td>
<td style="text-align:left">仅列出文档文件（间接指定 <code>-l</code>）</td>
</tr>
<tr>
<td style="text-align:left"><code>-c</code></td>
<td style="text-align:left">仅列出配置文件（间接指定 <code>-l</code>）</td>
</tr>
<tr>
<td style="text-align:left"><code>--dump</code></td>
<td style="text-align:left">带有完整详细信息的文件列表（将用于 <code>-l</code>、<code>-c</code> 或 <code>-d</code>）</td>
</tr>
<tr>
<td style="text-align:left"><code>--provides</code></td>
<td style="text-align:left">列出包中可被另一个包通过 <code>--requires</code> 请求的功能</td>
</tr>
<tr>
<td style="text-align:left"><code>--requires</code>, <code>-R</code></td>
<td style="text-align:left">包需要的功能</td>
</tr>
<tr>
<td style="text-align:left"><code>--scripts</code></td>
<td style="text-align:left">安装脚本（预安装、后安装、卸载）</td>
</tr>
</tbody>
</table>
<p>例如，命令 <code>rpm -q -i wget</code> 显示</p>
<pre tabindex="0"><code>Name        : wgetVersion     : 1.14Release     : 17.1Architecture: x86_64Install Date: Mon 30 Jan 2017 14:01:29 CETGroup       : Productivity/Networking/Web/UtilitiesSize        : 2046483License     : GPL-3.0+Signature   : RSA/SHA256, Thu 08 Dec 2016 07:48:44 CET, Key ID 70af9e8139db7c82Source RPM  : wget-1.14-17.1.src.rpmBuild Date  : Thu 08 Dec 2016 07:48:34 CETBuild Host  : sheep09Relocations : (not relocatable)Packager    : https://www.suse.com/Vendor      : SUSE LLC &lt;https://www.suse.com/&gt;URL         : http://www.gnu.org/software/wget/Summary     : A Tool for Mirroring FTP and HTTP ServersDescription :Wget enables you to retrieve WWW documents or FTP files from a server.This can be done in script files or via the command line.Distribution: SUSE Linux Enterprise 12
</code></pre><p>只有当您指定带有完整路径的完整文件名时，选项 <code>-f</code> 才起作用。根据需要提供任意多个文件名。例如：</p>
<pre tabindex="0"><code>rpm -q -f /bin/rpm /usr/bin/wgetrpm-4.11.2-15.1.x86_64wget-1.14-17.1.x86_64
</code></pre><p>如果只知道部分文件名，则可以使用外壳脚本。当运行所显示的脚本时，将部分文件名以参数的形式传递给脚本。</p>
<pre tabindex="0"><code>#! /bin/shfor i in $(rpm -q -a -l | grep $1); do    echo &quot;\&quot;$i\&quot; is in package:&quot;    rpm -q -f $i    echo &quot;&quot;done
</code></pre><p><code>rpm -q --changelog PACKAGE</code> 命令会按日期排序显示有关特定包的详细更改信息列表。</p>
<p>借助已安装的 RPM 数据库，可以进行校验检查。使用 <code>-V</code> 或 <code>--verify</code> 启动这些检查。使用此选项，<code>rpm</code> 显示安装后已被更改的包中的所有文件。<code>rpm</code> 使用 8 个字符符号给出有关以下更改的一些提示：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>5</code></td>
<td>MD5 校验和</td>
</tr>
<tr>
<td><code>S</code></td>
<td>文件大小</td>
</tr>
<tr>
<td><code>L</code></td>
<td>符号链接</td>
</tr>
<tr>
<td><code>T</code></td>
<td>修改时间</td>
</tr>
<tr>
<td><code>D</code></td>
<td>主要和次要设备编号</td>
</tr>
<tr>
<td><code>U</code></td>
<td>拥有者</td>
</tr>
<tr>
<td><code>G</code></td>
<td>组</td>
</tr>
<tr>
<td><code>M</code></td>
<td>方式（权限和文件类型）</td>
</tr>
</tbody>
</table>
<p>对于配置文件，将输出字母 <code>c</code>。例如，对于 <code>/etc/wgetrc</code>（<code>wget</code> 包）的更改：</p>
<pre tabindex="0"><code>rpm -V wgetS.5....T c /etc/wgetrc
</code></pre><p>RPM 数据库的文件被放置在 <code>/var/lib/rpm</code> 中。如果分区 <code>/usr</code> 的大小为 1 GB，则此数据库可能会占用将近 30 MB，特别是在完全更新之后。如果数据库比预期大得多，则最好使用选项 <code>--rebuilddb</code> 重构建数据库。在执行此操作之前，制作旧数据库的备份。<code>cron</code> 脚本 <code>cron.daily</code> 每天制作数据库的副本（用 gzip 打包）并将这些副本储存在 <code>/var/adm/backup/rpmdb</code> 中。副本的数目是由 <code>/etc/sysconfig/backup</code> 中的变量 <code>MAX_RPMDB_BACKUPS</code>（默认值为 <code>5</code>）控制的。对于 1 GB 的 <code>/usr</code>，单个备份的大小大约为 1 MB。</p>
<h4 id="安装和编译源包">安装和编译源包<a hidden class="anchor" aria-hidden="true" href="#安装和编译源包">#</a></h4>
<p>所有源包都带有 <code>.src.rpm</code> 扩展名（源 RPM）。</p>
<p>源包可以从安装媒体复制到硬盘并使用 YaST 解压缩。但是，在包管理器中它们不会被标记为已安装 (<code>[i]</code>)。这是因为源包不是在 RPM 数据库中输入的。只有已安装的操作系统软件列在 RPM 数据库中。安装源包时，只将源代码添加到系统中。</p>
<p>以下目录必须可用于 <code>/usr/src/packages</code> 中的 <code>rpm</code> 和 <code>rpmbuild</code>（除非在诸如 <code>/etc/rpmrc</code> 这样的文件中指定自定义设置）：</p>
<ul>
<li>
<p><code>SOURCES</code></p>
<p>代表原始源（<code>.tar.bz2</code> 或 <code>.tar.gz</code> 文件等）和特定于发布版本的调整（多为 <code>.diff</code> 或 <code>.patch</code> 文件）</p>
</li>
<li>
<p><code>SPECS</code></p>
<p>代表 <code>.spec</code> 文件，类似于元 Makefile，该文件控制构建进程</p>
</li>
<li>
<p><code>BUILD</code></p>
<p>在此目录中解压缩、增补和编译所有源</p>
</li>
<li>
<p><code>RPMS</code></p>
<p>储存完整的二进制包的位置</p>
</li>
<li>
<p><code>SRPMS</code></p>
<p>这里是源 RPM</p>
</li>
</ul>
<p>使用 YaST 安装源包时，将在 <code>/usr/src/packages</code> 中安装所有需要的组件：源和调整在 <code>SOURCES</code> 中，相关的 <code>.spec</code> 文件在 <code>SPECS</code> 中。</p>
<p>警告：不要对系统组件（<code>glibc</code>、<code>rpm</code> 等）进行试验，因为这样做会影响系统的稳定性。</p>
<p>下面的示例使用 <code>wget.src.rpm</code> 包。安装源包后，应具有类似以下列表中的文件：</p>
<pre tabindex="0"><code>/usr/src/packages/SOURCES/wget-1.11.4.tar.bz2/usr/src/packages/SOURCES/wgetrc.patch/usr/src/packages/SPECS/wget.spec
</code></pre><p><code>rpmbuild -bX /usr/src/packages/SPECS/wget.spec</code> 会启动编译。<em>X</em> 是通配符，代表构建进程的不同阶段。以下简要描述：</p>
<ul>
<li>
<p><code>-bp</code></p>
<p>在 <code>/usr/src/packages/BUILD</code> 中准备源：解压和打增补程序。</p>
</li>
<li>
<p><code>-bc</code></p>
<p>执行与 <code>-bp</code> 相同的操作，但还进行编译。</p>
</li>
<li>
<p><code>-bi</code></p>
<p>执行与 <code>-bp</code> 相同的操作，但还安装生成的软件。注意：如果包不支持 BuildRoot 功能，则可能会重写配置文件。</p>
</li>
<li>
<p><code>-bb</code></p>
<p>执行与 <code>-bi</code> 相同的操作，但还创建二进制包。如果编译成功，二进制包应该在 <code>/usr/src/packages/RPMS</code> 中。</p>
</li>
<li>
<p><code>-ba</code></p>
<p>执行与 <code>-bb</code> 相同的操作，但还创建源 RPM。如果编译成功，二进制包应该在 <code>/usr/src/packages/SRPMS</code> 中。</p>
</li>
<li>
<p><code>--short-circuit</code></p>
<p>跳过某些步骤。</p>
</li>
</ul>
<p>现在可以使用 <code>rpm -i</code> 或最好使用 <code>rpm -U</code> 来安装创建的二进制 RPM。使用 <code>rpm</code> 进行安装使它显示在 RPM 数据库中。</p>
<h4 id="使用-build-编译-rpm-包">使用 build 编译 RPM 包<a hidden class="anchor" aria-hidden="true" href="#使用-build-编译-rpm-包">#</a></h4>
<p>许多包存在的风险是构建进程中会将许多不需要的文件添加到正在运行的系统中。为防止发生这种情况，请使用 <code>build</code>，它将创建构建包的已定义环境。要建立这一 chroot 环境，<code>build</code> 脚本必须和完整的包树结构一起提供。可以通过 NFS 或从 DVD 使用硬盘上的此树。使用 <code>build --rpms DIRECTORY</code> 设置位置。与 <code>rpm</code> 不同，<code>build</code> 命令在源目录中查找 <code>.spec</code> 文件。要用系统中 <code>/media/dvd</code> 下装入的 DVD 构建 <code>wget</code>（如上例所示），请以 <code>root</code> 用户身份使用以下命令：</p>
<pre tabindex="0"><code>cd /usr/src/packages/SOURCES/mv ../SPECS/wget.spec .build --rpms /media/dvd/suse/ wget.spec
</code></pre><p>随后，将在 <code>/var/tmp/build-root</code> 建立一个最小的环境。在此环境中构建包。完成后，生成的包位于 <code>/var/tmp/build-root/usr/src/packages/RPMS</code> 中。</p>
<p><code>build</code> 脚本提供多个其他选项。例如，使脚本优先选择您自己的 RPM、忽略构建环境的初始化或者将 <code>rpm</code> 命令限制在上述阶段之一。</p>
<h4 id="用于-rpm-存档和-rpm-数据库的工具">用于 RPM 存档和 RPM 数据库的工具<a hidden class="anchor" aria-hidden="true" href="#用于-rpm-存档和-rpm-数据库的工具">#</a></h4>
<p>Midnight Commander (<code>mc</code>) 可以显示 RPM 存档的内容并复制部分内容。它将存档表示为虚拟文件系统，提供 Midnight Commander 所有常用的菜单选项。使用 F3 键显示 <code>HEADER</code>。使用光标键和 Enter 键查看存档结构。使用 F5 键复制部分存档。</p>
<p>拥有全部功能的包管理器将作为 YaST 模块提供。</p>
<h3 id="firewall-cmdhttpszhopensuseorgsdbfirewall-cmd"><a href="https://zh.opensuse.org/SDB:Firewall-cmd">Firewall-cmd</a><a hidden class="anchor" aria-hidden="true" href="#firewall-cmdhttpszhopensuseorgsdbfirewall-cmd">#</a></h3>
<p>Firewall-cmd 是 Firewalld 的命令行工具。</p>
<p>firewall-cmd(firewalld command line client) 是 firewalld 的主要命令行工具。它可以用来获取 firewalld 的状态信息，获取运行时和永久环境的防火墙配置，也可以用来修改这些配置。根据所选择的策略，你需要通过 Root 认证才能访问或更改 firewalld 的配置。它只有在 firewalld 运行的情况下才能使用。firewall-cmd 充当 nftables/iptables 的前端。</p>
<p>该文主要描述 firewall-cmd 的简易使用方法，更多内容详见：<a href="https://firewalld.org/documentation/">Firewalld Documentation</a></p>
<h4 id="准备工作">准备工作<a hidden class="anchor" aria-hidden="true" href="#准备工作">#</a></h4>
<p>openSUSE 已经默认安装并激活了 firewalld ，但你可以使用下列方法安装 firewalld ：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo zypper ref
$ sudo zypper update
$ sudo zypper install firewalld
</code></pre></div><h4 id="firewalld-的基本概念">Firewalld 的基本概念<a hidden class="anchor" aria-hidden="true" href="#firewalld-的基本概念">#</a></h4>
<h5 id="区域zone">区域（zone）<a hidden class="anchor" aria-hidden="true" href="#区域zone">#</a></h5>
<p>firewalld 将所有的网络数据流量划分为多个区域，再根据数据包的源IP地址或传入网络接口等条件，将数据流量转入相应区域的防火墙规则中。</p>
<p>你可以通过运行以下 ls 命令查看所有的区域：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ls -l /usr/lib/firewalld/zones/
</code></pre></div><p>使用 cat 指令查阅某个区域的详细内容</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat /usr/lib/firewalld/zones/*.xml
</code></pre></div><p>* 的可以替换成：</p>
<ol>
<li>block：拒绝所有传入的网络连接。只有从系统内部发起的网络连接才可能有效；</li>
<li>dmz：隔离区域也称为非军事化区域 (Demilitarized zone) ，为您的局域网提供有限的访问权限，并且只允许选定的传入端口；</li>
<li>drop：终止所有传入链接，只允许传出的链接；</li>
<li>external：对路由器类型的连接很有用。你需要局域网和广域网的接口来进行伪装（NAT）才能正常工作。</li>
<li>home：适用于家庭电脑，如局域网内的笔记本电脑和台式机，您可以信任其他电脑。只允许选定的 TCP/IP 端口；</li>
<li>internal：用于内部网络，当你几乎信任局域网内的其他服务器或计算机时；</li>
<li>public（系统默认值）：适用于始终处于公共区域的云服务器或托管在您处的服务器。您不信任网络上的任何其他计算机和服务器。您只允许使用所需的端口和服务；</li>
<li>trusted：允许任何的网络链接；</li>
<li>work：适用于您信任您的同事和其他服务器的工作场所。</li>
</ol>
<p>查看所有区域：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo firewall-cmd --get-zones
</code></pre></div><p>查看默认区域：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo firewall-cmd --get-default-zone  <span style="color:#75715e">#### OR</span>
$ sudo grep -i DefaultZone /etc/firewalld/firewalld.conf
</code></pre></div><p>openSUSE 默认的区域是 public ，默认启用的服务是 ssh 和 dhcpv6-client 。 查看网络接口名称：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ip link show
</code></pre></div><p>当 NetworkManager 添加新的接口连接（如 eth0 或 ens3）时，它们将被连接到默认的区域。通过运行以下命令进行验证：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ firewall-cmd --get-active-zones
</code></pre></div><h5 id="服务services">服务（services）<a hidden class="anchor" aria-hidden="true" href="#服务services">#</a></h5>
<p>服务是一个包含了本地端口、协议、源端口、目的地和防火墙帮助模块 (firewall helper modules) 的列表。</p>
<p>查询与 public 相关的防火墙规则或服务：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo firewall-cmd --list-all --zone<span style="color:#f92672">=</span>public
public <span style="color:#f92672">(</span>active<span style="color:#f92672">)</span>
  target: default
  icmp-block-inversion: no
  interfaces: wlan0
  sources: 
  services: dhcpv6-client
  ports: 
  protocols: 
  masquerade: no
  forward-ports: 
  source-ports: 
  icmp-blocks: 
  rich rules:
</code></pre></div><p>在该查询结果中，默认区域是 public ，允许的服务是 dhcpv6-client 。假设你需要删除 dhcpv6-client ，那么你应该运行如下指令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo firewall-cmd --remove-service<span style="color:#f92672">=</span>dhcpv6-client --permanent --zone<span style="color:#f92672">=</span>public
$ sudo firewall-cmd --reload <span style="color:#75715e">#### 重载防火墙</span>
$ sudo firewall-cmd --list-services <span style="color:#75715e">#### 列出所有服务</span>
</code></pre></div><p>运行下列指令查询特定区域允许的服务列表：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo firewall-cmd --list-services <span style="color:#75715e">#### 查询当前区域允许的服务</span>
$ sudo firewall-cmd --list-services --zone<span style="color:#f92672">=</span>* <span style="color:#75715e">#### 将 * 替换成你所需要查询服务的区域</span>
$ sudo firewall-cmd --list-all-zones <span style="color:#75715e">#### 查询全部区域的服务或防火墙规则</span>
</code></pre></div><h4 id="启动检查和关闭-firewalld-服务">启动、检查和关闭 firewalld 服务<a hidden class="anchor" aria-hidden="true" href="#启动检查和关闭-firewalld-服务">#</a></h4>
<p>启动（Start）并激活（Enable）防火墙：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo systemctl start firewalld
$ sudo systemctl enable firewalld
</code></pre></div><p>检查防火墙服务状态：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo systemctl status firewalld
</code></pre></div><p>检查防火墙状态：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo firewall-cmd --state
</code></pre></div><p>检查 firewalld 是否开机启动：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo systemctl is-enabled firewalld
</code></pre></div><p>更改规则后，重启防火墙让规则生效：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo firewall-cmd --reload
</code></pre></div><p>暂停（Stop）和关闭（Disable）防火墙：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo systemctl stop firewalld
$ sudo systemctl disable firewalld
</code></pre></div><h4 id="运行时和永久规则">运行时和永久规则<a hidden class="anchor" aria-hidden="true" href="#运行时和永久规则">#</a></h4>
<p>运行时的 firewalld 配置更改是临时性的，当你重新启动 openSUSE 或 firewalld 时，它们就会消失。永久规则则不受影响。 例如</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$  sudo firewall-cmd --zone<span style="color:#f92672">=</span>public --add-service<span style="color:#f92672">=</span>kdeconnect <span style="color:#75715e">#### 运行时规则</span>
$  sudo firewall-cmd --zone<span style="color:#f92672">=</span>public --add-service<span style="color:#f92672">=</span>kdeconnect --permanent <span style="color:#75715e">#### 永久规则</span>
</code></pre></div><p>添加永久性规则</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo firewall-cmd --zone<span style="color:#f92672">=</span>* --add-service<span style="color:#f92672">=</span>** --permanent <span style="color:#75715e">#### 将 * 替换成区域，将 ** 替换成服务名称，如 https.</span>
$ sudo firewall-cmd --reload <span style="color:#75715e">#### 重启防火墙让规则生效。</span>
</code></pre></div><p>确认规则是否生效：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo firewall-cmd --list-services
$ sudo firewall-cmd --list-services --permanent
</code></pre></div><p>查询 firewalld 支持的服务列表</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo firewall-cmd --get-services
$ sudo firewall-cmd --get-services | grep kdeconnect
$ ls -l /usr/lib/firewalld/services/
$ cat /usr/lib/firewalld/services/kdeconnect.xml
</code></pre></div><h4 id="firewall-cmd-规则集样例">Firewall-cmd 规则集样例<a hidden class="anchor" aria-hidden="true" href="#firewall-cmd-规则集样例">#</a></h4>
<p>添加 DNS 服务（TCP/UDP 端口：53，区域为 public，永久性规则）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo firewall-cmd --zone<span style="color:#f92672">=</span>public --add-service<span style="color:#f92672">=</span>dns --permanent
</code></pre></div><p>删除某个服务（例如 VNC 服务器服务，TCP 端口：5900-5903，区域为 public，永久性规则）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo firewall-cmd --zone<span style="color:#f92672">=</span>public --remove-service<span style="color:#f92672">=</span>vnc-server --permanent
</code></pre></div><p>开放特定的端口（TCP/UDP），例如开放 TCP/UDP 端口：55527：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo firewall-cmd --zone<span style="color:#f92672">=</span>public --add-port<span style="color:#f92672">=</span>55527/tcp --permanent
$ sudo firewall-cmd --zone<span style="color:#f92672">=</span>public --add-port<span style="color:#f92672">=</span>55527/udp --permanent
</code></pre></div><p>查看已开放的端口：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo firewall-cmd --zone<span style="color:#f92672">=</span>public --list-ports
$ sudo firewall-cmd --zone<span style="color:#f92672">=</span>public --list-ports --permanent
</code></pre></div><p>拒绝/禁用特定端口：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo firewall-cmd --zone<span style="color:#f92672">=</span>public --remove-port<span style="color:#f92672">=</span>23/tcp --permanent
</code></pre></div><p>注意，当 firewalld 的区域是 public 的时候，绝大多数端口是默认禁用的。</p>
<h5 id="编写端口转发-firewalld-规则">编写端口转发 Firewalld 规则<a hidden class="anchor" aria-hidden="true" href="#编写端口转发-firewalld-规则">#</a></h5>
<p>将同一服务器上的 TCP 端口 443 转发到 8080：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo firewall-cmd --zone<span style="color:#f92672">=</span>public --add-forward-port<span style="color:#f92672">=</span>port<span style="color:#f92672">=</span>80:proto<span style="color:#f92672">=</span>tcp:toport<span style="color:#f92672">=</span><span style="color:#ae81ff">8080</span> --permanent
</code></pre></div><p>要删除上述端口转发，请运行下列指令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo firewall-cmd --zone<span style="color:#f92672">=</span>public --remove-forward-port<span style="color:#f92672">=</span>port<span style="color:#f92672">=</span>80:proto<span style="color:#f92672">=</span>tcp:toport<span style="color:#f92672">=</span><span style="color:#ae81ff">8080</span>
</code></pre></div><p>如果您需要将流量 (端口 443) 转发到 192.168.2.42 端口 443 的 lxd 服务器/容器，请开启伪装功能：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo firewall-cmd --zone<span style="color:#f92672">=</span>public --add-masquerade
$ sudo firewall-cmd --zone<span style="color:#f92672">=</span>public --add-forward-port<span style="color:#f92672">=</span>port<span style="color:#f92672">=</span>443:proto<span style="color:#f92672">=</span>tcp:toport<span style="color:#f92672">=</span>443:toaddr<span style="color:#f92672">=</span>192.168.2.42 --permanent
</code></pre></div><p>要删除上述伪装规则，请运行下列指令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo firewall-cmd --zone<span style="color:#f92672">=</span>public --remove-masquerade
$ sudo firewall-cmd --zone<span style="color:#f92672">=</span>public --remove-forward-port<span style="color:#f92672">=</span>port<span style="color:#f92672">=</span>443:proto<span style="color:#f92672">=</span>tcp:toport<span style="color:#f92672">=</span>443:toaddr<span style="color:#f92672">=</span>192.168.2.42 --permanent
</code></pre></div><p>列出规则：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo firewall-cmd --zone<span style="color:#f92672">=</span>public --list-all --permanent
</code></pre></div><h4 id="rich-rule-示例httpsforumsuseorgcnttopic13503uhsiung"><a href="https://forum.suse.org.cn/t/topic/13503?u=hsiung">Rich rule 示例</a><a hidden class="anchor" aria-hidden="true" href="#rich-rule-示例httpsforumsuseorgcnttopic13503uhsiung">#</a></h4>
<p>假设你想只允许从 192.168.0.0 子网的 IP 地址访问 KDE Connect 的端口，运行下列指令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo firewall-cmd --permanent --zone<span style="color:#f92672">=</span>public --add-rich-rule<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;rule family=&#34;ipv4&#34; source address=&#34;192.168.0.0/24&#34; port protocol=&#34;tcp&#34; port=&#34;1714-1764&#34; accept&#39;</span>
$ sudo firewall-cmd --permanent --zone<span style="color:#f92672">=</span>public --add-rich-rule<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;rule family=&#34;ipv4&#34; source address=&#34;192.168.0.0/24&#34; port protocol=&#34;udp&#34; port=&#34;1714-1764&#34; accept&#39;</span>
</code></pre></div><p>要验证新规则，请运行下列指令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo firewall-cmd --list-rich-rules --permanent
</code></pre></div><p>您可以通过以下方式删除富规则：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo firewall-cmd --permanent --zone<span style="color:#f92672">=</span>public --remove-rich-rule <span style="color:#e6db74">&#39;rule family=&#34;ipv4&#34; source address=&#34;192.168.0.0/24&#34; port protocol=&#34;udp&#34; port=&#34;1714-1764&#34; accept&#39;</span> 
</code></pre></div><h4 id="其他">其他<a hidden class="anchor" aria-hidden="true" href="#其他">#</a></h4>
<p>如果你更青睐于GUI，那么你可以考虑使用Yast自带的防火墙，或者使用 firewall-config:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo zypper install firewall-config
</code></pre></div><h2 id="opensuse-tips">openSUSE Tips<a hidden class="anchor" aria-hidden="true" href="#opensuse-tips">#</a></h2>
<h3 id="为什么选择-opensusehttpszhopensuseorge4b8bae4bb80e4b988e98089e68ba9_opensuse"><a href="https://zh.opensuse.org/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9_openSUSE">为什么选择 openSUSE</a><a hidden class="anchor" aria-hidden="true" href="#为什么选择-opensusehttpszhopensuseorge4b8bae4bb80e4b988e98089e68ba9_opensuse">#</a></h3>
<h3 id="free-and-open-sourcehttpszhopensuseorgfree_and_open_source"><a href="https://zh.opensuse.org/Free_and_Open_Source">Free and Open Source</a><a hidden class="anchor" aria-hidden="true" href="#free-and-open-sourcehttpszhopensuseorgfree_and_open_source">#</a></h3>
<p>确定你心目中的贡献者们是什么样的，从而聚拢到这样的人。</p>
<h4 id="狭义的自由开源概念">狭义的自由开源概念<a hidden class="anchor" aria-hidden="true" href="#狭义的自由开源概念">#</a></h4>
<p>狭义的自由开源概念是：自由地开放源代码。即：软件作者把源代码公开发布，给予你修改并二次发布的权利。就这样，没别的了。</p>
<p>测试、调试、故障受理与修复、接受新功能请求、接受代码合并请求、接受别人的帮助、用户社区建立、互动、整个自由开源生态的维护，统统都是完全没有，谁愿意干谁干，跟我没有关系。或者这么说：“写完拉倒”，哪怕洪水滔天。这从 <a href="https://zh.opensuse.org/Free_and_Open_Source#GPL">GPL 许可证</a>的“无保声明”中可以看出端倪。</p>
<h4 id="广义的自由开源概念">广义的自由开源概念<a hidden class="anchor" aria-hidden="true" href="#广义的自由开源概念">#</a></h4>
<p>实际上如果你看过<a href="https://www.youtube.com/results?search_query=Revolution+OS">操作系统革命</a>你就会明白：开放源代码其实并不是这一运动想要实现的全部，它的最终目的是普及自由精神，建立自由社区。</p>
<p>目前这一精神在自由开源软件上的表现有：</p>
<ul>
<li>源代码开源。</li>
<li>来自软件所有者的开发门槛为零。</li>
<li>不重新发明轮子。如果有已有实现并可以扩展，那么扩展它。</li>
<li>文档开源。使用维基等。</li>
<li>组织并形成用户互助社区。积极帮助用户（在不影响开发的前提下）。同时在开发上尽量面向用户，把用户的反应纳入到重大修改的考量因素当中去，积极采纳合理意见。</li>
<li>积极回应故障汇报并提供修复。</li>
<li>积极回应新功能请求。能做的做，不能做的解释原因寻求理解。</li>
<li>形成良性的贡献者添加内容和用户反馈渠道。</li>
<li>重视并维护由类似软件共同组成的生态的和谐稳定。（简单说就是：我开发 KDE 是因为 GNOME 满足不了我的需求，而不是为了搞死 GNOME。）</li>
</ul>
<p>现在您可以拿来同狭义的自由开源概念做比较，发现如果说狭义的自由开源概念只是指某种行为，那么广义的自由开源概念已经是指一种氛围了。</p>
<h4 id="opensuse-秉持的自由开源概念">openSUSE 秉持的自由开源概念<a hidden class="anchor" aria-hidden="true" href="#opensuse-秉持的自由开源概念">#</a></h4>
<p><a href="https://www.csslayer.info/wordpress/linux/opensuse-community-is-the-best-c/">openSUSE 项目是完全做到“广义的自由开源概念”的社区</a>。</p>
<p>同时我们一直持有的相关理念还有：</p>
<ul>
<li>积极的与上游合作。不“内化”补丁或修改，除非上游出于种种原因不收。</li>
<li>积极的为整个生态着想。</li>
<li>不搞歧视或二等公民。</li>
<li>尊重许可证、版权甚至是专利</li>
</ul>
<p>如果你认同这些，那么您适合这个社区。</p>
<h3 id="用户字体">用户字体<a hidden class="anchor" aria-hidden="true" href="#用户字体">#</a></h3>
<p>Dolphin 下单击安装字体目录为</p>
<pre tabindex="0"><code>/home/用户名/.fonts
</code></pre><p>如果下载好的字体文件无法直接点开安装（例如 *.ttc），或者字体太多，不想一个一个地安装，可以将字体文件全部放到字体文件夹中。然后运行：</p>
<pre tabindex="0"><code>fc-cache -fv
</code></pre><h3 id="装入-ntfs-分区">装入 NTFS 分区<a hidden class="anchor" aria-hidden="true" href="#装入-ntfs-分区">#</a></h3>
<ol>
<li>
<p>安装 <code>ntfs-3g</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">sudo zypper in ntfs-3g
</code></pre></div></li>
<li>
<p>创建一个要充当安装点的目录，如 <code>~/mounts/windows</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">mkdir ~/mounts/windows
</code></pre></div></li>
<li>
<p>确定所需的 Windows 分区。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">sudo fdisk -l
</code></pre></div></li>
<li>
<p>以读写模式装入分区。使用相应的 Windows 分区替换占位符 <em>DEVICE</em>：</p>
<pre tabindex="0"><code>ntfs-3g /dev/DEVICE MOUNT POINT
</code></pre><p>要在只读模式下使用 Windows 分区，请追加 <code>-o ro</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">ntfs-3g /dev/DEVICE MOUNT POINT -o ro
</code></pre></div><p><code>ntfs-3g</code> 命令使用当前用户 (UID) 和组 (GID) 装入给定设备。如果要为其他用户设置写权限，请使用命令 <code>id</code>     <code> USER</code> 获取 UID 和 GID 值的输出。设置方式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">id usernamentfs-3g /dev/DEVICE MOUNT POINT -o uid<span style="color:#f92672">=</span>1000,gid<span style="color:#f92672">=</span><span style="color:#ae81ff">100</span>
</code></pre></div></li>
<li>
<p>要卸载资源，请运行 <code>fusermount -u 安装点</code>。</p>
</li>
</ol>
<h3 id="任务栏透明化httpsaskubuntucomquestions1173618how-to-make-kde-plasma-taskbar-panel-transparent"><a href="https://askubuntu.com/questions/1173618/how-to-make-kde-plasma-taskbar-panel-transparent">任务栏透明化</a><a hidden class="anchor" aria-hidden="true" href="#任务栏透明化httpsaskubuntucomquestions1173618how-to-make-kde-plasma-taskbar-panel-transparent">#</a></h3>
<p>Go to <em>System Settings | Window Management | Window Rules</em>. Press New&hellip; button. Give some description to the new rule, <code>Dock Transparency</code>, for example. Then select only <code>Dock (panel)</code> in &ldquo;Window type&rdquo; field.</p>
<p>之后在 Appearance &amp; Fixes 中调整 opacity。</p>
<h3 id="使用-24-小时制">使用 24 小时制<a hidden class="anchor" aria-hidden="true" href="#使用-24-小时制">#</a></h3>
<p>点击桌面右侧的时间 =&gt; 点击弹出面板的左上角 Config Digital Clock =&gt; Appearance 的 Time display 设置为 24 小时（但是窗口管理器还是12小时制）。</p>
<h3 id="主题">主题<a hidden class="anchor" aria-hidden="true" href="#主题">#</a></h3>
<p>不是我喜欢黑暗主题，而是热门的好看的主题都是黑暗主题。所以尝试如下：</p>
<ul>
<li>全局黑暗主题为 <a href="https://github.com/EliverLara/Sweet">Sweet</a></li>
<li>chrome 黑暗主题
<ul>
<li>系统设置 Theme 使用 GTK+，可以使标题栏，设置菜单栏为黑暗，但是网页、设置页为白色。</li>
<li>Chrome 黑暗模式：在网址栏输入  <code>chrome://flags/#enable-force-dark</code>，启用。可以使设置页面黑暗，网页黑暗，但是进入 segmentfault，你会发现 segment 不见了（即表现不好）。</li>
<li>安装 dark reader 插件。可以使网页黑暗，比 chrome 自带表现要好。但是打开新页面时，还是有短暂的白色。</li>
</ul>
</li>
<li>Firefox 黑暗主题
<ul>
<li>设置页的颜色会与系统一致，也就是与 chrome 相反。</li>
<li>firefox theme 会改变标题栏、设置菜单栏颜色。</li>
</ul>
</li>
</ul>
<p>实际上你会发现，无法达到一致的黑暗，反而使得眼睛不舒服，所以我放弃了黑暗主题。</p>
<p>亮色混合主题：</p>
<ul>
<li>Global Theme 为 openSUSE</li>
<li>Plasma 为 Edna-light</li>
<li>Window Decorations 为 Edna-light</li>
<li>Font 为 Source Hans Sans CN 和 Jet Brains Moon</li>
<li>Icon 为 Papirus</li>
<li>SSDM Theme 为 chili for plasma</li>
<li>kconsole 主题为 sweet</li>
<li>开始改为 application dashboard</li>
</ul>
<p>实际你会发现，混合主题没有一个单独主题搭配的那么协调。</p>
<p>窗体内容亮色，其他部分为黑暗，即标准主题:</p>
<ul>
<li>全局主题 Sweet</li>
<li>Colors 为 Breeze，使得 window 内容为亮色</li>
<li>Window Decorations 为 sweet-dark-transparent，设置标题栏</li>
<li>Icon 为 Papirus</li>
<li>SSDM Theme 为 sweet</li>
<li>fcitx 为 dartmouth。</li>
</ul>
<p>感觉可以。</p>
<p>Desktop Effects：</p>
<ul>
<li>Magic Lamp 400ms</li>
<li>Wobbly Windows</li>
</ul>
<p>不如不要。</p>
<h3 id="常用软件httpszhopensuseorge5b8b8e794a8e8bdafe4bbb6"><a href="https://zh.opensuse.org/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6">常用软件</a><a hidden class="anchor" aria-hidden="true" href="#常用软件httpszhopensuseorge5b8b8e794a8e8bdafe4bbb6">#</a></h3>
<h3 id="remove-a-file-using-inode-numberhttpssysadmineracom20170310unix-how-to-remove-a-file-using-inode-number"><a href="https://sysadminera.com/2017/03/10/unix-how-to-remove-a-file-using-inode-number/">Remove a file using inode number</a><a hidden class="anchor" aria-hidden="true" href="#remove-a-file-using-inode-numberhttpssysadmineracom20170310unix-how-to-remove-a-file-using-inode-number">#</a></h3>
<p>用 7zip 解压出一个乱码文件，删除不了，因此考虑用 inode 删除。</p>
<ol>
<li>
<p>Use -i flag to get the inode number of any file (First column is your inode)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ls -li
</code></pre></div></li>
<li>
<p>In find command, use -inum flag with inode number and ls at the end to list a file</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ find . -inum &lt;inode number&gt; -ls
</code></pre></div></li>
<li>
<p>In find command, use -inum flag with inode number and pass the rm using exec arugment to delete a file</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ find . -inum &lt;inode number&gt; -exec rm <span style="color:#f92672">{}</span> <span style="color:#ae81ff">\;</span>
</code></pre></div></li>
</ol>
<h3 id="unziphttpsforumsuseorgcntgui510"><a href="https://forum.suse.org.cn/t/gui/510">unzip</a><a hidden class="anchor" aria-hidden="true" href="#unziphttpsforumsuseorgcntgui510">#</a></h3>
<p>openSUSE 中文论坛讨论：<a href="https://forum.suse.org.cn/t/gui/510">大家都用什么 gui 压缩软件？</a></p>
<h4 id="问题描述httpsjuejincnpost7033637038574436366heading-0"><a href="https://juejin.cn/post/7033637038574436366#heading-0">问题描述</a><a hidden class="anchor" aria-hidden="true" href="#问题描述httpsjuejincnpost7033637038574436366heading-0">#</a></h4>
<p>ZIP文件在不同平台压缩时，对于文件名会有不同的编码，主要分为下面两类：</p>
<ol>
<li>Windows平台，默认的中文编码为GBK，因此压缩后的文件名编码格式为GBK。</li>
<li>Linux/MacOS平台，默认的中文编码为UTF8，因此压缩后的文件名编码格式为UTF8。</li>
</ol>
<p>这样就存在一个问题，在Windows上压缩的文件放到MacOS上解压，或者将Windows上压缩的文件上传到服务器上解压后处理，里面的文件名都会出现乱码情况。出现这个问题，主要是因为ZIP标准公布于1989年1月，那时还没有Unicode标准。在当前ZIP标准中，<code>Info-ZIP Unicode Path Extra Field(0x7075)</code>会记录UTF8的编码名。</p>
<p>但是，这个字段不是强制字段，允许为空，Linux/Mac OS在压缩时都不会记录这个标识，因此，无法识别出zip包采用的编码方式，导致解压时会出现乱码。</p>
<h4 id="解决httpswwwmarkjourcomarticle20190506-unzip-chinesehtml"><a href="https://www.markjour.com/article/20190506-unzip-chinese.html">解决</a><a hidden class="anchor" aria-hidden="true" href="#解决httpswwwmarkjourcomarticle20190506-unzip-chinesehtml">#</a></h4>
<h5 id="系统还未编译安装unzip">系统还未编译安装Unzip<a hidden class="anchor" aria-hidden="true" href="#系统还未编译安装unzip">#</a></h5>
<p><strong>更改源码解决乱码</strong></p>
<p>调试发现问题出现在 <code>MultiByteToWideChar</code> 方法里，如 <code>MultiByteToWideChar(CP_ACP,0,fn,-1,tfn,MAX_PATH);</code> 到这里时 <code>fn</code> 中的 <code>name</code> 属性值还是正常的，在这个方法内部执行完 <code>tfn</code> 就乱了。</p>
<p>解决方法：</p>
<p>打开 unzip.cpp 源文件，找到函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">ZRESULT TUnzip<span style="color:#f92672">::</span>Get(<span style="color:#66d9ef">int</span> index,ZIPENTRY <span style="color:#f92672">*</span>ze)
{
    <span style="color:#75715e">// ......
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// ......
</span><span style="color:#75715e"></span>}
</code></pre></div><p>这个函数里有</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#ifdef UNICODE
</span><span style="color:#75715e"></span>  MultiByteToWideChar(CP_UTF8,<span style="color:#ae81ff">0</span>,fn,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,tfn,MAX_PATH);
<span style="color:#75715e">#else
</span><span style="color:#75715e"></span>  strcpy(tfn,fn);
<span style="color:#75715e">#endif
</span></code></pre></div><p>把 CP_UTF8 改为 CP_ACP（CP_ACP 指示要使用当前设置的 API 默认 Windows ANSI 代码页）</p>
<p>重新编译后</p>
<p>这样就解决了解压中文文件名称乱码的问题</p>
<p><strong>编译时解决源码问题（无需更改源码）</strong></p>
<p>上面的情况，我们我观察到unzip源代码这段开始的地方有判断</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#ifndef Ext_ASCII_TO_Native
</span></code></pre></div><p>这样问题似乎更简单了，不用改源代码，只需在 make 时定义 <code>Ext_ASCII_TO_Native</code> 即可，这样 <code>Ext_ASCII_TO_Native</code> 实际为一个空的宏，不进行任何转换操作。</p>
<p>比如，使用下面的方法编译</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ make -DExt_ASCII_TO_Native
</code></pre></div><p>或者在 bash 执行下面两行</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ export LOCAL_UNZIP<span style="color:#f92672">=</span>-DExt_ASCII_TO_Native
$ make
</code></pre></div><p>unzip 解压缩含中文文件名 zip 包是出现乱码的问题解决！</p>
<h5 id="如果您的系统已经安装了-unzip">如果您的系统已经安装了 unzip<a hidden class="anchor" aria-hidden="true" href="#如果您的系统已经安装了-unzip">#</a></h5>
<p><strong>unzip 行命令解压，指定字符集</strong></p>
<p>通过 unzip 行命令解压，指定字符集</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ unzip -O CP936 xxx.zip <span style="color:#75715e"># 用GBK, GB18030 也可以</span>
</code></pre></div><p>有的发行版并没有如 Ubuntu 那样<a href="https://blog.kelu.org/tech/2021/12/20/debian-unzip-chinese-charater.html">安装了 unzip-iconv 补丁</a>，因此需要安装该补丁以启用“指定字符集”功能。</p>
<p>注意：<a href="https://aur.archlinux.org/packages/unzip-natspec">unzip-natspec</a> 是较新的方案，<a href="https://aur.archlinux.org/packages/gbkunzip">gbkunzip</a> 是依云的一个Python脚本解决方案。</p>
<p><strong>在环境变量中，指定 unzip 参数</strong></p>
<p>在环境变量中，指定 unzip 参数，总是以指定的字符集显示和解压文件
/etc/environment 中加入 2 行</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">UNZIP<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;-O CP936&#34;</span>
ZIPINFO<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;-O CP936&#34;</span>
</code></pre></div><p><strong>利用 python 来处理</strong></p>
<p>复制以下内容（Python）保存为 myuzip.py 文件脚本，并修改运行权限为可运行（<code>chmod +x uzip</code>）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#75715e">#!/usr/bin/env python</span>
<span style="color:#75715e"># -*- coding: utf-8 -*-</span>
<span style="color:#75715e"># uzip.py</span>

<span style="color:#f92672">import</span> os
<span style="color:#f92672">import</span> sys
<span style="color:#f92672">import</span> zipfile

print <span style="color:#e6db74">&#34;Processing File &#34;</span> <span style="color:#f92672">+</span> sys<span style="color:#f92672">.</span>argv[<span style="color:#ae81ff">1</span>]

file<span style="color:#f92672">=</span>zipfile<span style="color:#f92672">.</span>ZipFile(sys<span style="color:#f92672">.</span>argv[<span style="color:#ae81ff">1</span>],<span style="color:#e6db74">&#34;r&#34;</span>);
<span style="color:#66d9ef">for</span> name <span style="color:#f92672">in</span> file<span style="color:#f92672">.</span>namelist():
    utf8name<span style="color:#f92672">=</span>name<span style="color:#f92672">.</span>decode(<span style="color:#e6db74">&#39;gbk&#39;</span>)
    print <span style="color:#e6db74">&#34;Extracting &#34;</span> <span style="color:#f92672">+</span> utf8name
    pathname <span style="color:#f92672">=</span> os<span style="color:#f92672">.</span>path<span style="color:#f92672">.</span>dirname(utf8name)
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> os<span style="color:#f92672">.</span>path<span style="color:#f92672">.</span>exists(pathname) <span style="color:#f92672">and</span> pathname<span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;&#34;</span>:
        os<span style="color:#f92672">.</span>makedirs(pathname)
    data <span style="color:#f92672">=</span> file<span style="color:#f92672">.</span>read(name)
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> os<span style="color:#f92672">.</span>path<span style="color:#f92672">.</span>exists(utf8name):
        fo <span style="color:#f92672">=</span> open(utf8name, <span style="color:#e6db74">&#34;w&#34;</span>)
        fo<span style="color:#f92672">.</span>write(data)
        fo<span style="color:#f92672">.</span>close
file<span style="color:#f92672">.</span>close()
</code></pre></div><p>这样以后我们解压缩时只需要运行此文件即可</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ./myuzip.py xxxx.zip
</code></pre></div><h3 id="乱码问题httpswikiarchlinuxorgtitlelocalization_e7ae80e4bd93e4b8ade69687simplified_chinese_e7ae80e4bd93e4b8ade69687e4b9b1e7a081e997aee9a298"><a href="https://wiki.archlinux.org/title/Localization_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)/Simplified_Chinese_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#.E4.B9.B1.E7.A0.81.E9.97.AE.E9.A2.98">乱码问题</a><a hidden class="anchor" aria-hidden="true" href="#乱码问题httpswikiarchlinuxorgtitlelocalization_e7ae80e4bd93e4b8ade69687simplified_chinese_e7ae80e4bd93e4b8ade69687e4b9b1e7a081e997aee9a298">#</a></h3>
<p><a href="https://github.com/justjavac/unicode-encoding-error-table">Unicode 中文乱码速查表</a></p>
<table>
<thead>
<tr>
<th>xxxxxx</th>
<th>示例</th>
<th>特点</th>
<th>产生原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>古文码</td>
<td>鐢辨湀瑕佸ソ濂藉涔犲ぉ澶╁悜涓?</td>
<td>大都为不认识的古文，并加杂日韩文</td>
<td>以 GBK 方式读取 UTF-8 编码的中文</td>
</tr>
<tr>
<td>口字码</td>
<td>����Ҫ�¨2�ѧϰ������</td>
<td>大部分字符为小方块</td>
<td>以 UTF-8 的方式读取 GBK 编码的中文</td>
</tr>
<tr>
<td>符号码</td>
<td>ç”±æœˆè|�å￥½å￥½å-|ä1 å¤©å¤©å�‘ä¸Š</td>
<td>大部分字符为各种符号</td>
<td>以 ISO8859-1 方式读取 UTF-8 编码的中文</td>
</tr>
<tr>
<td>拼音码</td>
<td>óéÔÂòaoÃoÃÑ§Ï°ììììÏòéÏ</td>
<td>大部分字符为头顶带有各种类似声调符号的字母</td>
<td>以 ISO8859-1 方式读取 GBK 编码的中文</td>
</tr>
<tr>
<td>问句码</td>
<td>由月要好好学习天天向??</td>
<td>字符串长度为偶数时正确，长度为奇数时最后的字符变为问号</td>
<td>以 GBK 方式读取 UTF-8 编码的中文，然后又用 UTF-8 的格式再次读取</td>
</tr>
<tr>
<td>锟拷码</td>
<td>锟斤拷锟斤拷要锟矫猴拷学习锟斤拷锟斤拷锟斤拷</td>
<td>全中文字符，且大部分字符为“锟斤拷”这几个字符</td>
<td>以 UTF-8 方式读取 GBK 编码的中文，然后又用 GBK 的格式再次读取</td>
</tr>
<tr>
<td>烫烫烫</td>
<td>烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫</td>
<td>字符显示为“烫烫烫”这几个字符</td>
<td>VC Debug 模式下，栈内存未初始化</td>
</tr>
<tr>
<td>屯屯屯</td>
<td>屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯</td>
<td>字符显示为“屯屯屯”这几个字符</td>
<td>VC Debug 模式下，堆内存未初始化</td>
</tr>
</tbody>
</table>
<p>避免乱码基本原则：使用 utf-8 代替 gbk/gb2312。</p>
<h4 id="文件名乱码">文件名乱码<a hidden class="anchor" aria-hidden="true" href="#文件名乱码">#</a></h4>
<p>安装 <a href="https://archlinux.org/packages/?name=convmv">convmv</a>，使用 <code>convmv</code> 命令转换编码格式。示例：</p>
<pre tabindex="0"><code>$ convmv -f GBK -t UTF-8 --notest --nosmart file
</code></pre><p><code>-f</code> 指定原始编码，<code>-t</code> 指定输出编码。使用 <code>convmv --list</code> 可查询所有支持的编码。 <code>--notest</code> 表示非测试而是要进行转码（如果不使用该参数只会打印出转换结果而不会实际转码），<code>--smart</code> 表示如果已经是 UTF-8 则忽略。</p>
<h4 id="文件内容乱码">文件内容乱码<a hidden class="anchor" aria-hidden="true" href="#文件内容乱码">#</a></h4>
<p>使用 <code>iconv</code> 命令转换格式。示例：</p>
<pre tabindex="0"><code>$ iconv -f GBK -t UTF-8 -o new-file origin-file
</code></pre><p><code>-f</code> 指定原始编码，<code>-t</code> 指定输出编码。使用 <code>iconv -l</code> 可查询所有支持的编码。<code>-o</code> 指定输出文件。</p>
<h4 id="zip-压缩包乱码">zip 压缩包乱码<a hidden class="anchor" aria-hidden="true" href="#zip-压缩包乱码">#</a></h4>
<p>避免方法：非 utf8 编码环境下（一般 windows 下的中文环境即是）不使用 zip 进行压缩（建议使用 <a href="https://wiki.archlinux.org/title/7z_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">7z</a>)。 解决方案：安装使用 <a href="https://aur.archlinux.org/packages/unzip-iconv/">unzip-iconv</a> [package not found] 或者 <a href="https://aur.archlinux.org/packages/unzip-natspec/">unzip-natspec</a> 取代原版的 <a href="https://archlinux.org/packages/?name=unzip">unzip</a> 来解压缩，示例：</p>
<pre tabindex="0"><code>$ unzip -O gbk file.zip
</code></pre><p><code>file.zip</code> 是压缩文件，<code>gbk</code> 是该文件的编码格式，以 <code>-O</code> 指定（原版 unzip 无 <code>-O</code> 选项）。</p>
<h3 id="zypper-autoremovehttpsforumsuseorgcnttopic1413713uhsiung"><a href="https://forum.suse.org.cn/t/topic/14137/13?u=hsiung">zypper autoremove</a><a hidden class="anchor" aria-hidden="true" href="#zypper-autoremovehttpsforumsuseorgcnttopic1413713uhsiung">#</a></h3>
<p>zypper 提供了 subcommand 子命令的功能，可以将自定义脚本当作 zypper 命令来执行。所以可以编写这样一个脚本：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo cp zypper-autoremove.sh /usr/lib/zypper/commands/zypper-autoremove
$ sudo chmod u+x /usr/lib/zypper/commands/zypper-autoremove
$ sudo zypper autoremove
<span style="color:#75715e">#!/bin/sh</span>
packages<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>zypper -tqn --no-refresh pa --unneeded |grep <span style="color:#e6db74">&#39;^i |&#39;</span> |awk -F <span style="color:#e6db74">&#34;|&#34;</span> <span style="color:#e6db74">&#39;{print $3}&#39;</span><span style="color:#66d9ef">)</span>

<span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> <span style="color:#e6db74">&#34;</span>$packages<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
  sudo zypper rm -u $packages
<span style="color:#66d9ef">else</span>
  echo No unneeded package found.
<span style="color:#66d9ef">fi</span>
</code></pre></div><p>命名为 <code>zypper-autoremove</code>，放在你的 <code>$PATH</code> 下或者 <code>/usr/lib/zypper/commands</code> 里面，就可以通过</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ zypper autoremove
</code></pre></div><p>命令来实现清理无用包的功能了。</p>
<h3 id="ntfs-3g-与-ntfs3-驱动httpsbiluohcgithubiopostsntfs3gvsntfs3"><a href="https://biluohc.github.io/posts/ntfs3gvsntfs3/">ntfs-3g 与 ntfs3 驱动</a><a hidden class="anchor" aria-hidden="true" href="#ntfs-3g-与-ntfs3-驱动httpsbiluohcgithubiopostsntfs3gvsntfs3">#</a></h3>
<p>Linux Kernel 5.15 合并了 Paragon 提供的 NTFS3 内核驱动， 拥有更高的性能和更多的特性</p>
<p>总结：内核驱动开销变低, 读取性能有所提升，写入性能大幅提升，不考虑硬盘速度的话，写入速度接近10x</p>
<h3 id="kde-tipshttpsforumsuseorgcnttopic14131uhsiung"><a href="https://forum.suse.org.cn/t/topic/14131?u=hsiung">KDE Tips</a><a hidden class="anchor" aria-hidden="true" href="#kde-tipshttpsforumsuseorgcnttopic14131uhsiung">#</a></h3>
<h4 id="trash-cli">trash-cli<a hidden class="anchor" aria-hidden="true" href="#trash-cli">#</a></h4>
<p><code>rm -rf</code> 文件会彻底消失掉。为了避免误操作,有人写了一个替代品 <a href="https://github.com/andreafrancia/trash-cli">trash-cli</a> ，从命令行里面删除的时候移动到回收站，也就是 <a href="https://specifications.freedesktop.org/trash-spec/trashspec-1.0.html"><code>trash:/</code></a></p>
<p>不过 trash-cli 有点臃肿和重复，kde 的 kioclient5 可以做一样的事情</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kioclient5 move &lt;filename&gt; trash:/
<span style="color:#75715e"># 这里可以用文件通配符: 删除所有 .jpg 文件</span>
kioclient5 move *.jpg trash:/ 
</code></pre></div><p>可以在 <code>.bashrc</code> 里面加入这个命令来放心地删除文件</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#66d9ef">function</span> krm<span style="color:#f92672">(){</span>
    kioclient5 move <span style="color:#e6db74">&#34;</span>$@<span style="color:#e6db74">&#34;</span> trash:/
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="liberate-super-key">liberate Super Key<a hidden class="anchor" aria-hidden="true" href="#liberate-super-key">#</a></h4>
<p>为了避免快捷键冲突，我给所有软件 (比如 Emacs) 添加自定义快捷键都会用 SuperKey（Microsoft 叫 WinKey，Appple 叫 CommandKey）来弄。这时候就需要禁用 SuperKey 启动开始菜单来防止误操作。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kwriteconfig5 --file kwinrc --group ModifierOnlyShortcuts --key Meta <span style="color:#e6db74">&#34;&#34;</span>
<span style="color:#75715e"># 重载配置</span>
qdbus org.kde.KWin /KWin reconfigure
</code></pre></div><p><code>kwriteconfig5</code> 那条命令的实际作用是在<code>~/.config/kwinrc</code> 里面修改了这部分</p>
<pre tabindex="0"><code>[ModifierOnlyShortcuts]
Meta=
</code></pre><p>如果你想迁移你的 KDE 设置，可以把所用自定义的设置都用脚本来表示，比如说禁用键盘上的锁屏键</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 修改 ~/.config/kglobalshortcutsrc 里面 [ksmserver] 中 Lock Session= 的值为 &#34;,,Lock Session&#34;</span>
kwriteconfig5 --file kglobalshortcutsrc --group ksmserver --key <span style="color:#e6db74">&#34;Lock Session&#34;</span> <span style="color:#e6db74">&#34;,,Lock Session&#34;</span>
</code></pre></div><h4 id="custom-context-menu">Custom Context Menu<a hidden class="anchor" aria-hidden="true" href="#custom-context-menu">#</a></h4>
<p>KDE 可以添加自定义的右键菜单，比如说我自用的通过 <code>Inkscape</code> 把 <code>.svg</code> 转换成 <code>.eps</code>（ LaTeX 插入 .eps 方便一些）</p>
<p>把如下的内容丢进 <code>~/.local/share/kservices5/ServiceMenus/svg2eps.desktop</code> 即可。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>Desktop Entry<span style="color:#f92672">]</span>
Type<span style="color:#f92672">=</span>Service
ServiceTypes<span style="color:#f92672">=</span>KonqPopupMenu/Plugin
MimeType<span style="color:#f92672">=</span>image/svg+xml
Actions<span style="color:#f92672">=</span>svg2eps
Icon<span style="color:#f92672">=</span>view-refresh

<span style="color:#f92672">[</span>Desktop Action svg2eps<span style="color:#f92672">]</span>
Name<span style="color:#f92672">=</span>convert svg to eps
Icon<span style="color:#f92672">=</span>view-refresh
Exec<span style="color:#f92672">=</span>inkscape -D <span style="color:#e6db74">&#34;%f&#34;</span> --export-type<span style="color:#f92672">=</span>eps
</code></pre></div><p>唯一重点的一行是 <code>Exec=</code>。</p>
<p>原始的命令是 <code>inkscape -D &lt;filename&gt; --export-type=eps</code>，然后把 <code>&lt;filename&gt;</code>换成 <code>%f</code>, Dolphin 就会在从右键使用的时候自动传入目标文件。(大写的版本<code>%F</code>会传入一组文件)。</p>
<p>具体的写法在 <a href="https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html#exec-variables">Freedesktop Desktop Entry Specification-&gt; The Exec key</a> 里面。</p>
<p><code>MimeType=</code> 是匹配文件格式，可以用 <code>file --mime-type -b &lt;filename&gt;</code> 来获取，或者从 <a href="https://github.com/freedesktop/xdg-shared-mime-info/blob/master/data/freedesktop.org.xml.in">freedesktop/xdg-shared-mime-info</a> 里面查</p>
<p>你可能注意到，右键菜单里面的格式，用的和 launcher(开始菜单）用的是用样的格式 <code>.desktop</code></p>
<p>如果仔细考虑一下，他们本质上是没有区别的，只不过一个从 launcher 里面打开，另一个从右键呼出。不过通过右键打开的，可以获取一些文件和目录的信息。</p>
<p>详细的教程 <a href="https://develop.kde.org/docs/dolphin/service-menus/">https://develop.kde.org/docs/extend/dolphin/service-menus/</a></p>
<h4 id="长命令通知">长命令通知<a hidden class="anchor" aria-hidden="true" href="#长命令通知">#</a></h4>
<p>如果一个命令需要运行的特别特别久，可以在命令后面加上 <code>&amp;&amp; notify-send &lt;message&gt;&quot;</code></p>
<p>比如 <code>ls &amp;&amp; notify-send &quot;finished at $(date +%c)&quot;</code></p>
<p>不过这个通知一会就会消失，可以在设置里面，把 low priority 的通知设置成 show in history</p>
<p>这个同时还可以插入图片，想知道可以搜以下 KNotify/Knotifications 的 API…</p>
<h4 id="command-palette">Command Palette<a hidden class="anchor" aria-hidden="true" href="#command-palette">#</a></h4>
<p>自从某一个版本以后，用 KDE 框架写的软件都” 自动 “地获得了一个命令面板功能 Ctrl+Alt+i，正式的名称应该是 KCommandBar。</p>
<p>这里有两个好玩的：</p>
<ul>
<li>
<p>okular ” 自动 “地获得搜索最近打开文件的能力</p>
</li>
<li>
<p>Kate 可以更加方便地调用外部程序（类似于 <a href="https://github.com/mawww/kakoune/blob/master/doc/writing_scripts.asciidoc#writing-kak-scripts">Kakoune 那种几乎完全借助外部程序处理文档编辑的操作</a>）。</p>
<p>需要做的就是从菜单栏的 Tools -&gt; External Tools -&gt; Configure 里面添加新的外部程序，比如 google 搜索选定的文本。</p>
<p>也可以这样操作来安装这个 google 搜索：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">echo <span style="color:#e6db74">&#34;[General]
</span><span style="color:#e6db74">actionName=externaltool_GoogleSearch
</span><span style="color:#e6db74">arguments=https://www.google.com/search?q=%{Document:Selection:Text}
</span><span style="color:#e6db74">executable=/usr/bin/xdg-open
</span><span style="color:#e6db74">icon=plasma-search
</span><span style="color:#e6db74">name=GoogleSearch
</span><span style="color:#e6db74">output=Ignore
</span><span style="color:#e6db74">reload=false
</span><span style="color:#e6db74">save=None&#34;</span> &gt; ~/.config/kate/externaltools/googlesearch 
</code></pre></div><p>然后这样搜索一段选定的文本了</p>
</li>
</ul>
<h3 id="openqahttpsforumsuseorgcnttopic13525uhsiung"><a href="https://forum.suse.org.cn/t/topic/13525?u=hsiung">openQA</a><a hidden class="anchor" aria-hidden="true" href="#openqahttpsforumsuseorgcnttopic13525uhsiung">#</a></h3>
<p>大致的原理就是开一个虚拟机，然后模拟用户活动：<a href="https://openqa.opensuse.org/">https://openqa.opensuse.org</a></p>
<p>而且测试的项目也很多，除了安装，重启，安装桌面环境之类常规的测试。还有一些很特别的，比如说从 GNOME 桌面启动 Firefox，然后在关于界面一定会在某个坐标出现 Firefox 的 logo。打开 Dophin 然后右键菜单，新建文件的地方一定可以有那个文本文件。</p>
<p>另外还有两个项目也在使用来自 SUSE 的 openQA:</p>
<ul>
<li>Debian:
<a href="https://openqa.debian.net/">https://openqa.debian.net</a>
<a href="https://wiki.debian.org/Outreachy/Round15/Projects/TestingDebianWithOpenQA">https://wiki.debian.org/Outreachy/Round15/Projects/TestingDebianWithOpenQA</a></li>
<li>Fedora
<a href="https://openqa.stg.fedoraproject.org/">https://openqa.stg.fedoraproject.org</a>
<a href="https://fedoraproject.org/wiki/OpenQA">https://fedoraproject.org/wiki/OpenQA</a></li>
</ul>
<h3 id="sdbhttpsforumsuseorgcnttopic135037uhsiung"><a href="https://forum.suse.org.cn/t/topic/13503/7?u=hsiung">SDB</a><a hidden class="anchor" aria-hidden="true" href="#sdbhttpsforumsuseorgcnttopic135037uhsiung">#</a></h3>
<p>支持资料库。</p>
<blockquote>
<p><strong>Support Database</strong> (SDB) articles are written as solutions for technical problems with openSUSE.</p>
</blockquote>
<h3 id="给-pdf-电子书加目录httpsforumsuseorgcnttopic14862uhsiung"><a href="https://forum.suse.org.cn/t/topic/14862?u=hsiung">给 pdf 电子书加目录</a><a hidden class="anchor" aria-hidden="true" href="#给-pdf-电子书加目录httpsforumsuseorgcnttopic14862uhsiung">#</a></h3>
<p>对许多人来说 pdf 格式的电子书最头疼的两件事：</p>
<ol>
<li>每页都是没经过 OCR 处理过的图片</li>
<li>没有目录(ABBYY)</li>
</ol>
<p>以下这个批量加目录的方法我用好久了，见过我这么操作过的都想学一下，这里详细地记录以下，也方便以后有人再问的时候 <code>:)</code></p>
<p>用到的软件是 pdftk <a href="https://gitlab.com/pdftk-java/pdftk">pdftk-java / pdftk-java · GitLab</a> 。linux 发行版一般都有这个这个软件可以直接安装。</p>
<p>pdftk 的用法就是：输出 (dump_data) pdf 的元信息 (data.txt)，编辑以后，重新倒入 (update_info) 到 pdf 文件里面</p>
<p>主要是这两条命令:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">pdftk <span style="color:#f92672">[</span>my.pdf<span style="color:#f92672">]</span> dump_data &gt; <span style="color:#f92672">[</span>data.txt<span style="color:#f92672">]</span>
pdftk <span style="color:#f92672">[</span>my.pdf<span style="color:#f92672">]</span> update_info <span style="color:#f92672">[</span>data.txt<span style="color:#f92672">]</span> output my2.pdf
</code></pre></div><p>在第一条命令输出的 <code>data.txt</code> 里面加入如下的内容，然后通过第二条命令就可以创建新的目录条目</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ini" data-lang="ini"><span style="color:#a6e22e">BookmarkBegin</span>
<span style="color:#a6e22e">BookmarkTitle: name</span>
<span style="color:#a6e22e">BookmarkLevel: level</span>
<span style="color:#a6e22e">BookmarkPageNumber: page number</span>
</code></pre></div><p>另外电子书的第一页通常是封面，紧接着的是其它的东西。但是书里面标注的页码的第一页往往后面的某页。</p>
<p>PDF 支持把页码标注成其它的格式 (<em>page_labels</em>)，第一页标注成 cover，第二到第十页标注成罗马数字，然后从第十一页标注成 1,2,3,4,5,6…</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ini" data-lang="ini"><span style="color:#75715e"># 把第一页标注成名字为 cover 的非数字 (NoNumber)</span>
<span style="color:#a6e22e">PageLabelBegin</span>
<span style="color:#a6e22e">PageLabelNewIndex: 1</span>
<span style="color:#a6e22e">PageLabelStart: 1</span>
<span style="color:#a6e22e">PageLabelPrefix: cover</span>
<span style="color:#a6e22e">PageLabelNumStyle: NoNumber</span>

<span style="color:#75715e"># 从第二页 (PageLabelNewIndex) 开始标注成小写罗马数字 (LowercaseRomanNumerals)</span>
<span style="color:#a6e22e">PageLabelBegin</span>
<span style="color:#a6e22e">PageLabelNewIndex: 2</span>
<span style="color:#a6e22e">PageLabelStart: 1 # 从数字 1 开始数，如果这里变成 3</span>  <span style="color:#f92672">=</span><span style="color:#e6db74">&gt; 起始的罗马数字会是 iii</span>
<span style="color:#a6e22e">PageLabelNumStyle: LowercaseRomanNumerals</span>

<span style="color:#75715e"># 从 {true start page} 开始用普通的数字标注</span>
<span style="color:#a6e22e">PageLabelBegin</span>
<span style="color:#a6e22e">PageLabelNewIndex: {true start page}</span>
<span style="color:#a6e22e">PageLabelStart: 1</span>
<span style="color:#a6e22e">PageLabelNumStyle: DecimalArabicNumerals</span>
</code></pre></div><p>对于一本书，这种手动添加的方法会很慢，下面是一个小脚本来半自动化。</p>
<p>由于电子书 100% 可以搜索到这种格式的目录 <code>编号 标题 页码</code>。如果搜索不到，也可以直接从书里面复制。</p>
<p><img loading="lazy" src="/Distributions/7a08413d34869d1979f631fcdb47a35c75174fa8_2_345x217.png" alt=""  />
</p>
<p>复制粘贴一下，调整成这种格式</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ini" data-lang="ini"><span style="color:#a6e22e">14</span>
<span style="color:#a6e22e">I: Reduction Semantics	1</span>
	<span style="color:#a6e22e">1 Semantics via Syntax	5</span>
	<span style="color:#a6e22e">2 Analyzing Syntactic Semantics	13</span>
	<span style="color:#a6e22e">3 The λ-Calculus	23</span>
	<span style="color:#a6e22e">4 ISWIM	45</span>
<span style="color:#a6e22e">II: PLT Redex	201</span>
	<span style="color:#a6e22e">11 The Basics	205</span>
	<span style="color:#a6e22e">12 Variables and Meta-functions	217</span>
	<span style="color:#a6e22e">13 Layered Development	227</span>
	<span style="color:#a6e22e">14 Testing	237</span>
<span style="color:#a6e22e">......</span>
</code></pre></div><p>第一行是对于人类，而非 pdf 格式来说真正的第一页</p>
<p>后面根据行首 tab 的数量来决定目录的层级</p>
<p>每行后面的数字是页码</p>
<p>然后用这个小脚本 <code>toc-gen.py</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#!/usr/bin/env python3</span>

<span style="color:#75715e">#</span>
<span style="color:#75715e"># Usage</span>
<span style="color:#75715e"># toc-gen.py  &lt; edited-toc.txt</span>
<span style="color:#75715e">#</span>

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">make_offset</span>(off: int):
    <span style="color:#66d9ef">if</span> off <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>:
        print(<span style="color:#e6db74">&#34;&#34;&#34;PageLabelBegin
</span><span style="color:#e6db74">PageLabelNewIndex: 1
</span><span style="color:#e6db74">PageLabelStart: 1
</span><span style="color:#e6db74">PageLabelPrefix: cover
</span><span style="color:#e6db74">PageLabelNumStyle: NoNumber&#34;&#34;&#34;</span>)

    <span style="color:#66d9ef">if</span> off <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">2</span>:
        print(<span style="color:#e6db74">&#34;&#34;&#34;PageLabelBegin
</span><span style="color:#e6db74">PageLabelNewIndex: 2
</span><span style="color:#e6db74">PageLabelStart: 1
</span><span style="color:#e6db74">PageLabelNumStyle: LowercaseRomanNumerals&#34;&#34;&#34;</span>)

    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;&#34;&#34;PageLabelBegin
</span><span style="color:#e6db74">PageLabelNewIndex: </span><span style="color:#e6db74">{</span>off<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span><span style="color:#e6db74">PageLabelStart: 1
</span><span style="color:#e6db74">PageLabelNumStyle: DecimalArabicNumerals&#34;&#34;&#34;</span>)


<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">make_bookmark</span>(t: str, l: int, p: int):
    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;&#34;&#34;BookmarkBegin
</span><span style="color:#e6db74">BookmarkTitle: </span><span style="color:#e6db74">{</span>t<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span><span style="color:#e6db74">BookmarkLevel: </span><span style="color:#e6db74">{</span>l<span style="color:#e6db74">}</span><span style="color:#e6db74">
</span><span style="color:#e6db74">BookmarkPageNumber: </span><span style="color:#e6db74">{</span>p<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;&#34;&#34;</span>)


<span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;__main__&#39;</span>:
    offset <span style="color:#f92672">=</span> int(input())
    make_offset(offset)
    <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>:
        <span style="color:#66d9ef">try</span>:
            line <span style="color:#f92672">=</span> input()
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> line<span style="color:#f92672">.</span>strip():
                <span style="color:#66d9ef">break</span>
        <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">EOFError</span>:
            <span style="color:#66d9ef">break</span>

        title <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34; &#34;</span><span style="color:#f92672">.</span>join(line<span style="color:#f92672">.</span>split()[<span style="color:#ae81ff">0</span>:<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])
        n_of_tabs <span style="color:#f92672">=</span> len(line) <span style="color:#f92672">-</span> len(line<span style="color:#f92672">.</span>lstrip())
        page <span style="color:#f92672">=</span> int(line<span style="color:#f92672">.</span>split()[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])

        make_bookmark(t<span style="color:#f92672">=</span>title,
                      l<span style="color:#f92672">=</span>n_of_tabs <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>,
                      p<span style="color:#f92672">=</span>page <span style="color:#f92672">+</span> offset)
</code></pre></div><p>来获取这些内容，把这些内容粘贴到 <code>[data.txt]</code> 后面，然后再用 pdftk 的第二条命令</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ini" data-lang="ini"><span style="color:#a6e22e">PageLabelBegin</span>
<span style="color:#a6e22e">PageLabelNewIndex: 1</span>
<span style="color:#a6e22e">PageLabelStart: 1</span>
<span style="color:#a6e22e">PageLabelPrefix: cover</span>
<span style="color:#a6e22e">PageLabelNumStyle: NoNumber</span>
<span style="color:#a6e22e">PageLabelBegin</span>
<span style="color:#a6e22e">PageLabelNewIndex: 2</span>
<span style="color:#a6e22e">PageLabelStart: 1</span>
<span style="color:#a6e22e">PageLabelNumStyle: LowercaseRomanNumerals</span>
<span style="color:#a6e22e">PageLabelBegin</span>
<span style="color:#a6e22e">PageLabelNewIndex: 14</span>
<span style="color:#a6e22e">PageLabelStart: 1</span>
<span style="color:#a6e22e">PageLabelNumStyle: DecimalArabicNumerals</span>
<span style="color:#a6e22e">BookmarkBegin</span>
<span style="color:#a6e22e">BookmarkTitle: Reduction Semantics</span>
<span style="color:#a6e22e">BookmarkLevel: 1</span>
<span style="color:#a6e22e">BookmarkPageNumber: 15</span>
<span style="color:#a6e22e">BookmarkBegin</span>
<span style="color:#a6e22e">BookmarkTitle: Semantics via Syntax</span>
<span style="color:#a6e22e">BookmarkLevel: 2</span>
<span style="color:#a6e22e">BookmarkPageNumber: 19</span>
<span style="color:#a6e22e">BookmarkBegin</span>
<span style="color:#a6e22e">BookmarkTitle: Analyzing Syntactic Semantics</span>
<span style="color:#a6e22e">BookmarkLevel: 2</span>
<span style="color:#a6e22e">BookmarkPageNumber: 27</span>
<span style="color:#a6e22e">BookmarkBegin</span>
<span style="color:#a6e22e">BookmarkTitle: The λ-Calculus</span>
<span style="color:#a6e22e">BookmarkLevel: 2</span>
<span style="color:#a6e22e">BookmarkPageNumber: 37</span>
<span style="color:#a6e22e">BookmarkBegin</span>
<span style="color:#a6e22e">BookmarkTitle: ISWIM</span>
<span style="color:#a6e22e">BookmarkLevel: 2</span>
<span style="color:#a6e22e">BookmarkPageNumber: 59</span>
<span style="color:#a6e22e">BookmarkBegin</span>
<span style="color:#a6e22e">BookmarkTitle: An Abstract Syntax Machine</span>
<span style="color:#a6e22e">BookmarkLevel: 2</span>
<span style="color:#a6e22e">BookmarkPageNumber: 79</span>
<span style="color:#a6e22e">BookmarkBegin</span>
<span style="color:#a6e22e">BookmarkTitle: Abstract Register Machines</span>
<span style="color:#a6e22e">BookmarkLevel: 2</span>
<span style="color:#a6e22e">BookmarkPageNumber: 103</span>
<span style="color:#a6e22e">BookmarkBegin</span>
<span style="color:#a6e22e">BookmarkTitle: Tail Calls and More Space Savings</span>
<span style="color:#a6e22e">BookmarkLevel: 2</span>
<span style="color:#a6e22e">BookmarkPageNumber: 121</span>
<span style="color:#a6e22e">BookmarkBegin</span>
<span style="color:#a6e22e">BookmarkTitle: Control: Errors, Exceptions, and Continuations</span>
<span style="color:#a6e22e">BookmarkLevel: 2</span>
<span style="color:#a6e22e">BookmarkPageNumber: 129</span>
<span style="color:#a6e22e">BookmarkBegin</span>
<span style="color:#a6e22e">BookmarkTitle: State: Imperative Assignment</span>
<span style="color:#a6e22e">..............</span>
</code></pre></div><p><strong>Bingo!</strong> 这下舒服了 <code>:)</code></p>
<h3 id="kde-pim-使用指北httpsimbearchildcyouarchives202111kde-pim-guide"><a href="https://imbearchild.cyou/archives/2021/11/kde-pim-guide/">KDE PIM 使用指北</a><a hidden class="anchor" aria-hidden="true" href="#kde-pim-使用指北httpsimbearchildcyouarchives202111kde-pim-guide">#</a></h3>
<h2 id="opensuse-questions">openSUSE Questions<a hidden class="anchor" aria-hidden="true" href="#opensuse-questions">#</a></h2>
<h3 id="解决kde下kde-wallet重装系统后每次登陆需要输入密码httpscloudtencentcomdeveloperarticle1688182"><a href="https://cloud.tencent.com/developer/article/1688182">解决KDE下KDE Wallet重装系统后每次登陆需要输入密码</a><a hidden class="anchor" aria-hidden="true" href="#解决kde下kde-wallet重装系统后每次登陆需要输入密码httpscloudtencentcomdeveloperarticle1688182">#</a></h3>
<p>在每次重装或者配置桌面后<code>kdewallet</code>总是在登陆系统之后提示输入密码，虽然在输入密码后能够继续正常使用，但是每次登陆系统都需要输入一次密码还是很烦人的。</p>
<p>出现的原因：</p>
<p>在重新配置桌面或者重装系统之后KDE Wallet所需要的一些必备需要依赖组件未能找到，所以导致不能正确运行KDE Wallet，所以只要安装其所需的组件即可。而其所需的但是未能自动安装的依赖组件正是 <code>pam_kwallet</code>，kwallet-pam 与 GnuPG keys 不兼容，所以 KDE Wallet 必须使用 <code>blowfish</code> 加密方式。</p>
<p>解决方案 ：</p>
<p>安装缺失的组件</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">sudo zypper in  pam_kwallet
</code></pre></div><p>为了保险起见，查看个人目录下是否存在<code>~/.kde4/share/apps/kwallet</code>文件夹，如果存在则将其删除或者重命名以避免出现冲突，并且还需要确定使用的钱包名为<code>kdewallet</code>并且密码为当前用户的密码。</p>
<p>如此便可完全正常使用<code>KDE Wallet</code></p>
<p>解决方案参考<code>arch wiki</code>的<a href="https://wiki.archlinux.org/index.php?title=KDE_Wallet_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)&amp;oldid=570870">KDE Wallet</a>小节中。</p>
<h3 id="could-not-open-a-connection-to-your-authentication-agent">Could not open a connection to your authentication agent<a hidden class="anchor" aria-hidden="true" href="#could-not-open-a-connection-to-your-authentication-agent">#</a></h3>
<p>执行ssh-add时出现</p>
<pre tabindex="0"><code>ssh-agent bash
</code></pre><h3 id="无法读取-exfat--7z-和-rar">无法读取 exfat 、 .7z 和 .rar<a hidden class="anchor" aria-hidden="true" href="#无法读取-exfat--7z-和-rar">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo zypper in fuse-exfat exfat-utils
$ sudo zypper in p7zip-full
$ sudo zypper in unrar 
</code></pre></div><h3 id="vscode-keychain-issueshttpscodevisualstudiocomdocseditorsettings-sync_troubleshooting-keychain-issues-for-kdehttpsgithubcommicrosoftvscodeissues92972issuecomment-608572519">vscode <a href="https://code.visualstudio.com/docs/editor/settings-sync#_troubleshooting-keychain-issues">keychain issues</a> <a href="https://github.com/microsoft/vscode/issues/92972#issuecomment-608572519">for KDE</a><a hidden class="anchor" aria-hidden="true" href="#vscode-keychain-issueshttpscodevisualstudiocomdocseditorsettings-sync_troubleshooting-keychain-issues-for-kdehttpsgithubcommicrosoftvscodeissues92972issuecomment-608572519">#</a></h3>
<pre tabindex="0"><code>$ sudo zypper in gnome-keyring
</code></pre><p>提示添加密码的时候为空就行了，否则每次启动 vscode 都需要输入一次密码。</p>
<h3 id="typora-字体问题">Typora 字体问题<a hidden class="anchor" aria-hidden="true" href="#typora-字体问题">#</a></h3>
<p><img loading="lazy" src="/Distributions/typoraFontFamilay.png" alt=""  />
</p>
<h3 id="如果-typora-字体如上面那样每个字大小不一样">如果 Typora 字体如上面那样，每个字大小不一样：<a hidden class="anchor" aria-hidden="true" href="#如果-typora-字体如上面那样每个字大小不一样">#</a></h3>
<ul>
<li>
<p>整个应用的语言设置为英语</p>
</li>
<li>
<p>在 conf.user.json 指定字体</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#f92672">&#34;defaultFontFamily&#34;</span>: {
    <span style="color:#f92672">&#34;standard&#34;</span>: <span style="color:#e6db74">&#34;Source Han Sans CN&#34;</span>, <span style="color:#75715e">//String - Defaults to &#34;Times New Roman&#34;.
</span><span style="color:#75715e"></span>    <span style="color:#f92672">&#34;serif&#34;</span>: <span style="color:#e6db74">&#34;Source Han Sans CN&#34;</span>, <span style="color:#75715e">// String - Defaults to &#34;Times New Roman&#34;.
</span><span style="color:#75715e"></span>    <span style="color:#f92672">&#34;sansSerif&#34;</span>: <span style="color:#e6db74">&#34;Source Han Sans CN&#34;</span>, <span style="color:#75715e">// String - Defaults to &#34;Arial&#34;.
</span><span style="color:#75715e"></span>    <span style="color:#f92672">&#34;monospace&#34;</span>: <span style="color:#e6db74">&#34;JetBrains Mono&#34;</span> <span style="color:#75715e">// String - Defaults to &#34;Courier New&#34;.
</span><span style="color:#75715e"></span>  }
}
</code></pre></div></li>
</ul>
<h3 id="flatpak-run-invalid-mit-magic-cookie-1-keyhttpsforumsopensuseorgshowthreadphp539546-cannot-run-flatpaks-anymore"><a href="https://forums.opensuse.org/showthread.php/539546-Cannot-run-flatpaks-anymore">flatpak run: Invalid MIT-MAGIC-COOKIE-1 key</a><a hidden class="anchor" aria-hidden="true" href="#flatpak-run-invalid-mit-magic-cookie-1-keyhttpsforumsopensuseorgshowthreadphp539546-cannot-run-flatpaks-anymore">#</a></h3>
<pre tabindex="0"><code>rm .Xauthority
</code></pre><h3 id="nothing-provides-libuuid-needed-by-the-to-be-installed-xmind">nothing provides &lsquo;libuuid&rsquo; needed by the to be installed xmind<a hidden class="anchor" aria-hidden="true" href="#nothing-provides-libuuid-needed-by-the-to-be-installed-xmind">#</a></h3>
<p>BearChild, [7/21/22 10:14 PM]
强行装即可
libuuid 的依赖对于大多数 opensuse 安装来讲，都可以忽略，打包的问题</p>
<h3 id="high-cpu-usage-of-goldendict">High cpu usage of Goldendict<a hidden class="anchor" aria-hidden="true" href="#high-cpu-usage-of-goldendict">#</a></h3>
<p>full-text search 在 openSUSE 中是默认开启的，Disable full-text search: Preferences =&gt; Full-text search</p>
<h3 id="disabling-mouse-scroll-wheel-switching-between-virtual-desktopshttpswwwredditcomrkdecomments6l9fvedisabling_mouse_scrollwheel_switching_between"><a href="https://www.reddit.com/r/kde/comments/6l9fve/disabling_mouse_scrollwheel_switching_between/">Disabling mouse scroll-wheel switching between virtual desktops</a><a hidden class="anchor" aria-hidden="true" href="#disabling-mouse-scroll-wheel-switching-between-virtual-desktopshttpswwwredditcomrkdecomments6l9fvedisabling_mouse_scrollwheel_switching_between">#</a></h3>
<p>Right-click the desktop -&gt; Configure Desktop and Wallpaper&hellip; -&gt; Mouse actions -&gt; &ldquo;vertical scrollwheel: Standard Menu&rdquo;</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://sakamotokurome.github.io/tags/unix/">Unix</a></li>
      <li><a href="https://sakamotokurome.github.io/tags/linux/">Linux</a></li>
      <li><a href="https://sakamotokurome.github.io/tags/opensuse/">openSUSE</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://sakamotokurome.github.io/posts/gentooinstallation/">
    <span class="title">« Prev Page</span>
    <br>
    <span>Gentoo Installation</span>
  </a>
  <a class="next" href="https://sakamotokurome.github.io/posts/fedora/">
    <span class="title">Next Page »</span>
    <br>
    <span>Fedora</span>
  </a>
</nav>

  </footer>
</article>

<div class="disqus-container">
  <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    this.page.identifier = '2c175d';
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "sakamotokurome" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://sakamotokurome.github.io/">Sakamoto Kurome</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
</body>

</html>
