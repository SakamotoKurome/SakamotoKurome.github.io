<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Ubuntu System | Sakamoto Kurome</title>
<meta name="keywords" content="Unix, Linux, Ubuntu" />
<meta name="description" content="Wine 简介 Wine 是在x86、x86-64容许类Unix操作系统在X Window System运行Microsoft Windows程序的软件。另外，Wine也提供">
<meta name="author" content="Sakamoto Kurome">
<link rel="canonical" href="https://sakamotokurome.github.io/posts/ubuntusystem/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css" integrity="sha256-yIlj/i15RiAA/Q&#43;xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://sakamotokurome.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://sakamotokurome.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://sakamotokurome.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://sakamotokurome.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://sakamotokurome.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.90.0" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>

<link rel="stylesheet" href="https://sakamotokurome.github.io/custom.css">
<meta name="google-site-verification" content="i2r403EffR8m-KBf7EHi6AYg7tfnMshaXTAynoYPnpE" />
<script async src="https://www.googletagmanager.com/gtag/js?id=G-K2Y212LPQ2"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-K2Y212LPQ2', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="Ubuntu System" />
<meta property="og:description" content="Wine 简介 Wine 是在x86、x86-64容许类Unix操作系统在X Window System运行Microsoft Windows程序的软件。另外，Wine也提供" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://sakamotokurome.github.io/posts/ubuntusystem/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-08T15:32:32&#43;08:00" />
<meta property="article:modified_time" content="2022-03-08T15:32:32&#43;08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Ubuntu System"/>
<meta name="twitter:description" content="Wine 简介 Wine 是在x86、x86-64容许类Unix操作系统在X Window System运行Microsoft Windows程序的软件。另外，Wine也提供"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://sakamotokurome.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Ubuntu System",
      "item": "https://sakamotokurome.github.io/posts/ubuntusystem/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Ubuntu System",
  "name": "Ubuntu System",
  "description": "Wine 简介 Wine 是在x86、x86-64容许类Unix操作系统在X Window System运行Microsoft Windows程序的软件。另外，Wine也提供",
  "keywords": [
    "Unix", "Linux", "Ubuntu"
  ],
  "articleBody": "Wine 简介 Wine 是在x86、x86-64容许类Unix操作系统在X Window System运行Microsoft Windows程序的软件。另外，Wine也提供程序运行库（Winelib）来帮助计算机程序设计师将Windows程序移植到类Unix系统；也有不少软件经过Wine测试后发布，比如Picasa、uTorrent、MediaCoder。\nWine通过提供一个兼容层来将Windows的系统调用转换成与POSIX标准的系统调用。它还提供了Windows系统运行库的替代品和一些系统组件的替代品。为了避免著作权问题，Wine主要使用黑箱测试逆向工程来编写。\nWine最早是“Windows Emulator”，即Windows模拟器的缩写，但Wine现在为“Wine Is Not an Emulator”的递归缩写，即Wine不是模拟器。Wine的正确名称是“Wine”，而不是全大写或全小写。\nWine计划在1993年由Bob Amstadt及Eric Youngdale发起，最初目的是为了让16位Windows 3.1程序可以在Linux上执行，但随着电脑和时代的演进，Wine也一路支持到更新的Windows和64位的计算机体系结构。\n由于Windows的DLL为封闭源代码，所以程序员只能由最底层的设计开始，耗费大量的时间来编写和测试，最后达至兼容，这过程是困难且缓慢的。\n在1999年期间，当Corel加入这个计划后，Wine很快便能兼容WordPerfect Office，但Corel不久便停止支持这项计划，所以Wine的发展又逐渐趋缓，一直到2006年Google积极参与这个计划后，Wine的发展才又恢复起色，最后终于在2008年发布首个稳定版，其后便以每两周发布一个新版的速度发展着，除此之外，Google每年所举办的夏日代码大赛活动也对Wine有着不少贡献。\nWine虽然是从Linux开始发展，但现在已经支持多种平台，有BSD、Mac OS X与Solaris-x86，在2013年的自由及开源软件开发者欧洲会议上，Wine的项目领导人Alexandre Julliard（英语：Alexandre Julliard）表示目前将积极支持Android平台。\n在2008年，Wine已经能够完美运行很多知名程序，例如Lotus Notes及Microsoft Office 2007，Photoshop CS2，但其可靠性及稳定性仍有待改善。如果该程序包含本地的微软Windows系统的库，那样Wine便可很顺利运行该程序。\n有些Wine DLLs亦已能完美地取代Windows原来的DLLs，使得有些程序可完美运行。\n最晚到2006年，Wine上面已经可以完全基于Wine DLL完美地运行暴雪发行的多款3D游戏了，如魔兽世界、魔兽争霸等。\n注：以下如果使用zsh，~ 应替换为 $HOME才能正常使用\n安装 使用 Ubuntu 仓库版本\n$ sudo apt install wine 使用 wine 仓库安装最新版本\n如果您之前安装过来自其他仓库的 Wine 安装包，请在尝试安装 WineHQ 安装包之前删除它及依赖它的所有安装包（如：wine-mono、wine-gecko、winetricks），否则可能导致依赖冲突。\n如果您使用的是 64 位系统，请开启 32 bit 架构支持（如果您之前没有开启的话）：\n# Verifying you have 64-bit kernel architecture. $ dpkg --print-architecture # Verifying you have multi-arch support enabled.  $ dpkg --print-foreign-architectures # Enabling multi-arch support. $ sudo dpkg --add-architecture i386 $ sudo apt update 下载添加仓库密钥：\n$ wget -nc https://dl.winehq.org/wine-builds/winehq.key $ sudo apt-key add winehq.key 并添加 Ubuntu 20.04 仓库：\n$ sudo add-apt-repository 'deb https://dl.winehq.org/wine-builds/ubuntu/ focal main' 安装：\n$ sudo apt update $ sudo apt install --install-recommends winehq-stable 配置 配置Wine的方式通常有：\n winecfg是Wine的图形界面配置程序。控制台下调用$ winecfg（或指定系统目录：$ WINEPREFIX=~/.系统目录 winecfg）即可启动 control.exe是Windows控制面板的Wine实现，通过$ wine control命令启动 regedit是Wine的注册表编辑器，比较前两者，该工具能配置更多东西。部分常用键值参见：WineHQ’s article on Useful Registry Keys  初始设置 通过全局菜单，应用程序 - 附件 - 终端 ，输入命令： winecfg 这将在你的家目录中创建一个隐藏文件夹（.wine），其中包含类似于在Windows中的虚拟C：驱动器以及注册表文件。一旦该目录中创建完，wine配置窗口将出现。该窗口将允许您定制wine的各种设置，其中包括Windows版本，DLL替换，显示设置，驱动器映射，以及应用程序的特定设置。单击OK按钮关闭该窗口。\nWINEPREFIX Wine默认将配置文件和安装的Windows程序保存在~/.wine。这样的目录称为一个\"Wine prefix\"或\"Wine bottle\"（下文称“系统目录”）。每次运行Windows程序（包括内置程序，如winecfg）时，系统目录会自动创建（如果缺失）或更新。系统目录中存放有文件夹 ~/.wine/drive_c 相当于Windows下C:\\C盘（更确切的说应是系统盘）。\n通过设置WINEPREFIX环境变量，可以更改Wine系统目录的位置。如果希望让不同的Windows程序使用不同的系统环境或配置，这一变量会非常有用。建议把你安装的不同的Windows程序分给不同的WINEPREFIX，便于打包和隔离。当你要启动这个Windows程序前也记得要设置WINEPREFIX。\n例如，如果您使用 $ env WINEPREFIX=~/.win-a wine-A程序.exe参数来运行一个程序。另一个使用 $ env WINEPREFIX=~/.win-b wine-B程序.exe参数，这两个程序将使用独立的C盘和注册表配置。\n以下命令会建立一个默认的系统目录，且不启动任何Windows程序：\n$ env WINEPREFIX=~/.customprefix wineboot -u WINEARCH 这个WINEARCH 决定了你模拟的Windows是32位或是64位的x86。对应的值为win32及win64，如果你的Unix系统是64位的它就默认是win64。\n发行版所提供的wine一般都有32位及64位两个包，直接对应所模拟的Windows位数，包里面的Unix二进制及运行库也都是对应位数。\n对于64位用户，默认创建的系统目录是64位环境的。若想使用纯32位环境，修改WINEARCH 变量win32为即可： $ WINEARCH=win32 winecfg这样就会生成32位Wine环境。若不设置WINEARCH得到的就是64位环境。\n通过WINEPREFIX变量，在不同的系统目录分别创建32位和64位环境：\n$ WINEARCH=win32 WINEPREFIX=~/win32 winecfg $ WINEPREFIX=~/win64 winecfg 注意： 系统目录创建过程中，64位版本的wine将视全部目录如同64位系统目录，也将不会在已存在的目录中创建任何32位的。创建32位系统目录，您必须让Wine创建指定的WINEPREFIX目录。\nwinetricks也接受WINEPREFIX变量，以安装Steam为例：\n$ WINEARCH=win32 WINEPREFIX=~/.local/share/wineprefixes/steam winetricks steam 编辑 ~/.bashrc，使得 WINEPREFIX 和 WINEARCH 永久生效\nexport WINEPREFIX=$HOME/.config/wine/ export WINEARCH=win32 图形驱动 你需要安装32位的显卡驱动。缺少或未能正确配置驱动的一个标志是 Wine 在终端窗口里报告如下内容：\nDirect rendering is disabled, most likely your OpenGL drivers have not been installed correctly 注意： 在安装对应的库以后，你可能需要重启 X\n声音 Wine程序有可能遇到某些声音问题。首先，确保winecfg中只启用了一种声卡驱动。目前，Wine对Alsa的支持最好。\nMIDI 支持\nMIDI 是九十年代非常流行的游戏声音系统。如果你尝试运行老一点的游戏，音乐无法开箱即用的情况并不罕见。 Wine 拥有非常优秀的 MIDI 支持。但是首先你需要确保 Wine 会使用正确的 MIDI 输出。详细设置参考 Wine Wiki\n字体 中文乱码\n将中文字体copy到对应wine的目录（本地安装的wine是~/.wine，playonlinux是.PlayOnLinux/wineprefix/对应目录）下的drive_c/windows/Fonts/。\n在wine目录下任意位置添加modify_font.reg文件：\nREGEDIT4 [HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\FontLink\\SystemLink] \"Lucida Sans Unicode\"=\"SourceHanSans.ttc\" \"Microsoft Sans Serif\"=\"SourceHanSans.ttc\" \"MS Sans Serif\"=\"SourceHanSans.ttc\" \"Tahoma\"=\"SourceHanSans.ttc\" \"Tahoma Bold\"=\"SourceHanSans.ttc\" \"msyh\"=\"SourceHanSans.ttc\" \"Arial\"=\"SourceHanSans.ttc\" \"Arial Black\"=\"SourceHanSans.ttc\" 将SourceHanSans.ttc改成自己想改的中文字体。\n在wine命令提示符运行：\n$ regedit modify_font.reg 语言区域\n如果安装的系统LANG不为zh-CN，那么wine运行程序的默认语种也不会是中文，这可能导致一部分乱码。解决这个问题，用\n$ env LANG=zh_CN.UTF-8 wine example.exe 运行程序\n启动器和菜单 Wine不会为内置程序（如winecfg、winebrowser）创建桌面启动器和菜单项。但手动安装的Windows程序通常会自动创建启动器和菜单项。在Windows下，安装程序（如setup.exe）通常会在桌面和开始菜单建立快捷方式，而Wine下会创建遵循freedesktop.org规范的.desktop文件（即启动器，相当于快捷方式）。\n提示： 如果启动器没有自动创建，或者这些文件丢失了，可以尝试使用winemenubuilder修复。\nGnome3 中清理 Wine 菜单启动项\n系统全局的菜单启动器安装在 /usr/share/applications/，清除相应程序的“.desktop”文件即可从整个系统删除该启动器。\n如果这样还是无法解决问题，那么很可能 Wine 的启动器存放在用户级别的 ~/.local/share/applications/wine/Programs/ 目录中。删除相应的“.desktop”文件即可清理对应启动项。删除整个 Programs 文件夹将清理所有 Wine 程序的启动项。\n安装/运行/卸载 Windows 程序 警告： 千万不要以root身份运行Wine！详情参见本文。\n使用wine安装应用程序，可以按照以下步骤：\n 从某个地址下载Windows应用程序.exe（可执行文件）. 把它放在一个方便的目录（例如，桌面或个人文件夹） 打开终端，并且切换到.exe文件所在的目录。 输入命令 wine application-name.exe 。  这将使用Wine启动.EXE。如果它是一个安装程序，它应该像在windows一样的运行。如果应用程序要求目录来安装应用程序，选择把它放在 C:\\Program Files 。\n运行Windows程序格式为 WINEPREFIX=\"wine配置文件存放地\" wine [路径]程序.exe 参数 ，如：\n$ wine notepad.exe c:/abc.txt $ wine notepad.exe ~/.wine/drive_c/abc.txt 路径可以是Unix路径，也可以是（在有WINEPREFIX情况下的）Windows路径，wine会自动判断。\n对wine来说，你Unix系统里的其他文件（即模拟的C盘之外的文件）的Windows路径都以Z盘开头：\n$ wine notepad.exe z:/home/username/.wine/drive_c/abc.txt 内置的msiexec程序可以运行MSI安装包：\n$ [wine] msiexec /i path_to_msi 还可以通过在终端运行 winefile 使用 Wine 文件浏览器。\n在某些情况下，应用程序需要被从一个特定位置上运行。在这种情况下创建命令启动\n$ sh -c \"cd /home/USER/.wine/drive_c/Program Files/APPDIR; wine game.exe\" wine uninstaller 这将打开一个类似于Windows的程序“添加/删除程序”控制面板，让您卸载wine安装的应用程序。通过 wine 直接运行卸载程序也应该正常工作。或者，您也可以简单地删除应用程序的文件夹。\n技巧 提示： 此外您可能会感兴趣以下文章的开始所提供的链接\n Wine程序数据库 (Wine Application Database, AppDB) —— 特定Windows程序的Wine兼容情况（运行时的已知问题、用户评分、指南等等），Rating一列由运行结果好到坏为Platinum、Gold、Silver、Bronze、Garbage，无近期结果或近期仍然Silver以下的就放弃吧。 WineHQ论坛 —— 要是看完上述网页还有问题，可以到这里咨询  OpenGL 模式 很多游戏（比如魔兽争霸啦）都支持OpenGL模式，在Wine下可能比默认DirectX模式性能更好。一般添加-opengl启动程序即可，但不同程序可能有所不同：\n$ wine /path/to/3d_game.exe -opengl 请参考AppDB，了解特定程序的相关信息。\nWine 控制台 有些时候，可能需要运行.exe给游戏打补丁，比如给古董游戏添加宽屏支持。这时直接通过Wine运行可能没有用。那么，打开终端，运行一下命令：\n$ wineconsole cmd 将进入一个和Windows下cmd一样的命令行环境。在该环境下试试也许就可以了。\nwinetricks 使用Winetricks快速脚本，能够方便地安装许多Windows组件，包括DirectX、msxml（被Office 2007、IE浏览器依赖）visual运行库还有其他更多的。\n使用 Ubuntu 仓库版本\n$ sudo apt install winetricks 使用 Github 安装最新版本\n$ cd \"${HOME}/.local/bin\" $ wget https://raw.githubusercontent.com/Winetricks/winetricks/master/src/winetricks $ chmod u+x winetricks 可以用winetricks list-all来看看它支持什么。\nUsing winetricks\n获得 winetricks 后，您只需在控制台输入sh winetricks即可运行它。如果你先chmod +x winetricks ，你也可以使用./winetricks。如果不带参数运行，winetricks 会显示一个带有可用包列表的 GUI。如果您知道要安装的软件包的名称，可以将它们附加到 winetricks 命令，它将立即开始安装过程。例如，\n$ sh winetricks corefonts vcrun6 将安装 corefonts 和 vcrun6 软件包。\n所有 Wine 命令一样，winetricks 知道 WINEPREFIX 环境变量。\n$ env WINEPREFIX=~/.winetest sh winetricks mfc40 拥有多个 Wine 版本的用户可以指定 winetricks 应该使用哪个版本\n$ env WINE=~/wine-git/wine sh winetricks mfc40 使用 ~/wine-git 目录中的 Wine 安装 mfc40 包。\nMono \u0026 Gecko Mono 是 .NET Framework 的开源和跨平台实现。Wine 可以使用 Windows 构建的 Mono 来运行 .NET 应用程序。\nWine 实现了自己的 Internet Explorer 版本。该实现基于Mozilla 的 Gecko Layout Engine的自定义版本。\n在 USTC MIRROR 分别下载对应的版本，放入~/.cache/wine就可以了。\nCrossOver CrossOver是Wine的付费、商业化版本，提供更全面的终端用户支持。它包括脚本、补丁、GUI和可能永远不会被Wine项目接受的第三方软件。这种组合使得那些不太懂技术的人运行Windows程序变得相当容易。\n首先在 CrossOver 下载 .bin 安装包，然后要把 .bin 文件设置成可执行的：chmod u+x crossover.bin，接下来运行该文件：./crossover.bin。\n无限试用\ncrossover 有15天的试用期，crossover的时间验证信息写在每一个winebottle容器中，相互是完全隔离（不是写在全局配置中）。即使一个容器过期了，依然可以创建新的容器，并重新计算试用期，所以不需要重装软件本身。\n即使重装程序，已经过期的容器依旧不能用，不过可以删除该容器，或者删除容器下的.eval文件。\n$ rm ~/.cxoffice/**/.eval Tutorials 相对于 wine 而言，CrossOver 更加简洁方便，全程使用 GUI。\n在 Select Application 的时候，即使列表中没有列出你需要安装的 Windows 软件，依旧可以尝试使用默认的 Unlisted application，如一些 roguelike、galgame 游戏是可以直接运行的。\n如果无法运行：\n 如果报错缺少dll，这时就在网上查找一下，比如 sskin.dll，如果教程使用的 winetricks，则可以在 winetricks/files/verbs/all.txt 找到具体的依赖名称，如 Visual C++ 6 SP4 libraries，然后可以在 Select Application 输入依赖名来安装，如果下载慢，也可以通过软件显示的下载链接直接下载。 如果什么错也没报，那么就需要参考 Unsupported Troubleshooting 安装依赖或配置 winecfg，确保在安装游戏的时候没有选择升级依赖（比如 DirectX ）并且之后安装了必要的依赖项。推荐游戏自带的 CommonRedist 或在 WineHQ - Browse Applications、PlayOnLinux、PCGamingWiki 上找依赖，可以但不推荐在虚拟机中运行一下看报错。 如果先是正常运行，之后 wine 报错 page fault 退出，那么可以参考 Gathering debug logs in Crossover Linux 创建 crash log。  凡是依赖解决了，游戏一般是能够运行了，但是运行的好不好，有没有bug就不敢保证了，比如 Skul - The Hero Slayer 是可以直接运行的，但是无法正常显示血量，即使重新安装依赖也是如此。\n以下测试的是运行游戏所必须的依赖：\n  Sekiro Shadows Die Twice\n Microsoft Visual C++ 6.0 (4.2 \u0026 6.0) Redistributable    The Elder Scrolls V Skyrim Special Edition\n DirectX for Modern Games 使用 SkyrimSELauncher.exe 配置，使用 SkyrimSE.exe 启动    Life is Strange - Before the Storm\n 先安装下面两个依赖，如果 FitGirl 报 Getting unarc.dll returned an error code -6，就 try using the set memory limit to 2 gb option；如果是 Miss files，那么就重装。 Microsoft Visual C++ 6.0 (4.2 \u0026 6.0) Redistributable DirectX for Modern Games 游戏需要加载一会儿，这个时候屏幕没反应。    NieR - Automata\n DirectX for Modern Games 如果 unable to input name for profile creation，可以尝试将 CrossOver 升级到最新版本。    Dead Cells\n 参考 [playonlinux/dead cells](playonlinux/dead cells) 的 SourceCode 安装依赖后能够运行 DirectX for Modern Games OpenAL，安装后要在 Wine Configuration  Libraries 中添加 openal32（不加，点击无反应、闪退）（Libraries 中是运行时自动加载进来的库，而需要的 openal32 没有自动加载进来，因此手动添加） Microsoft Visual C++ 6.0 (4.2 \u0026 6.0) Redistributable    The Binding of Isaac Rebirth Repentance\n 要在 Wine Configuration  Libraries 中添加 openal32（不加，点击无反应、闪退） 《以撒的結合：重生》給新玩家的基本攻略    Valiant Hearts The Great War\n Copy over the cracked content from the /Crack directory on the image to your game install directory manually.    DARK SOULS REMASTERED\n 更改语言：In the game installation folder find the “steam_emu.ini”, open it and find the line with language, change it to schinese.（在 font 目录可以找到所有语言）    Braid\n DirectX for Modern Games    Dying Light Platinum Edition\n Microsoft Visual C++ 6.0 (4.2 \u0026 6.0) Redistributable    DXVK 游戏使用 Vulkan 将获取更好的性能，为使用 Vulkan，需启用 DXVK。DXVK provides a Vulkan-based translation layer for DXGI, D3D10 and D3D11, which can be used on Linux with Wine.\n打开 System Information，如果在属性下找到了 “vulkan.present”=“yes”，则表示支持 vulkan 并可以安装 DXVK。\n首先安装驱动程序\n$ sudo apt install mesa-vulkan-drivers mesa-vulkan-drivers:i386 libvulkan1 libvulkan1:i386 vulkan-utils 然后像安装普通软件那样，在 Select an Application to install 搜索并选择 DXVK (Upstream) 安装——DXVK (Builtin) 可能会导致游戏无法运行。安装后就自动启用了，也可以通过右键一个 BottleSettingsDXVK Vulkan backand for D3D11(Custom) 启用。\nEsync 注：Some Windows applications will not work correctly which ESync enabled. 例如 My Friend Pedro 开了后闪退，应该先保证正确运行，再考虑提升性能。\nWhat is “wine esync” and how should I set it up?\nthe thing with Far Cry 4, 3 and Primal also Dirt Rally in wine is that it massively loads wineserver and synchronizing all the time, so it is stuck at around 20 fps on ryzen, all those games mentioned. with esync, wineserver is skipped for synchronizing and eventfd is being used, thus increasing performance that much. Games that are CPU bound with wineserver having huge load (wineserver is singlethreaded) benefit the most of this\nWhat is the function of esync? Why most games need it disabled?\nThe function of esync is to provide lightweight thread synchronization facilities (events/semaphores/mutexes) so that game code that uses them heavily will run faster.\nIt does this using a linux-specific facility called eventfd, which is built around file descriptors. These are a limited resource normally not needed in large quantities, and therefore traditionally made available to a process only in moderate quantities. This helps prevent runaway processes and malicious code from consuming so many descriptors that none are left for other processes (a denial of service).\nTherefore, when a game that uses tens of thousands of thread synchronization objects is run with esync, it will fail unless the system’s per-process file descriptor limit is much higher than the traditional default. Some linux distributions have already adopted a high default, while others still default to a thousand or so. That’s why these games run fine with esync on some distributions but fail on others unless the system’s DefaultLimitNOFILE setting is increased.\nEdit: If you’re interested in esync technical issues that are not distribution-specific, check out this comment.\nHowToEsync What is Esync?\nEsync removes wineserver overhead for synchronization objects. This increases performance for a lot of games, especially ones that rely heavily on multithreading.\nA more detailed explanation can be found here.\nHow to check Esync compatibility\nSystems using Systemd 240 and newer are already compatible with Esync.\nIf you’re unsure that your system is compatible, run the ulimit -Hn command. If the value printed is equal to or greater than 524288, then your system is Esync-compatible.\nHow to make your system Esync compatible\nIf your system is not Esync-compatible (ulimit -Hn, which prints the limit for number of opened files for a process, prints a value lower than 524288, like 4096), you have 2 different methods of solving this problem. Which method is preferable depends on the distribution currently in use. Applying both methods should have no negative side effect.\n Modifying Systemd configuration  This method applies to Ubuntu and other systems using systemd. You (with root privileges or sudo) need to edit both /etc/systemd/system.conf and /etc/systemd/user.conf by adding DefaultLimitNOFILE=524288. If DefaultLimitNOFILE= already exists in both system.conf and user.conf, add 524288 after = and make sure to uncomment the line (remove the # in the beginning of the line) to make it functional.\nOnce the files are edited, restart your computer for the changes to take effect. To verify if the limits were applied, run ulimit -Hn to see 524288 being reported.\nIf the value printed still says something like 4096, try the ulimits method below.\nModifying ulimits.conf  On Linux distributions not using Systemd or distributions using pam-limits.conf (Arch Linux, Fedora, Solus,… ), you (with root privileges or sudo) need to edit /etc/security/limits.conf.\nChange username to your actual username. Once the file is edited, reboot for the changes to take effect, and verify by running ulimit -Hn to see the new limit (524288).\nusername hard nofile 524288 中文乱码 注：某些游戏会因为语言设置而无法运行。\n修改步骤：打开容器 C:Drive，返回到顶层文件夹（即容器名称），即可找到cxbottle.conf，在文件最后面添加如下内容：\n[EnvironmentVariables] \"LANG\" = \"zh_CN.UTF-8\" Third-party apps Bottles Proton PlayOnLinux Lutris 实例 Cemu 用 Crossover 试了一下，不能用 vulkan，很卡，鼠标延迟很高。\nOffice 2013 Pro 注：在安装前先在 AppDB 中查找要安装的应用，在 Test Results 部分有相关教程，如 Microsoft Office 2013 Test Results\n注：要提高安装成功率，第一，不同 wine 版本安装结果是不同的，AppDB 有相应的信息；第二，winetricks 如果提供安装镜像的话，一定要用该镜像，winetrics 是一个很大的脚本，打开脚本搜索 office2013pro 即可找到官方镜像下载链接；第三，如果第一次安装失败，可以再尝试安装一次。\nI installed office 2013 and I used to get a black window after starting it up. I fixed the black screen by following the solution posted in the [WineHQ-Forum](https://forum.winehq.org/viewtopic.php?f=8\u0026t=28446\u0026p=109296\u0026hilit=office 2013#p109284).\nHere’s what I did:\nInstall Components\n$ sudo apt install winbind cabextract Create Clean 32bit Prefix for Win7\nCrete a clean 32 bit prefix and start up winecfg:\n$ env WINEPREFIX=~/.wine-office2013pro WINEARCH=win32 winecfg In the winecfg applications tab select “Windows version: Windows 7” Close wine config and install winetricks\nInstall Libraries\nThen start winetricks for your prefix\n$ env WINEPREFIX=~/.wine-office2013pro WINEARCH=win32 winetricks accept “select the default wineprefix” with OK. Now, select “Install Windows DLL components” and go and install msxml6（这个时候会下载 msxml6，可以手动下载后移动到~/.cache/winetricks中）\nTo fix the problem in PowerPoint (not enough memory), I added two overrides with winecfg in Library section: “riched20” and “usp10”.\n如果是中文软件需安装中文字体。\n在这里我直接使用 winetrics 成功安装 office2013pro（wine 6）：\n$ env WINEPREFIX=~/.wine-office2013pro WINEARCH=win32 winetricks office2013pro 这样下面步骤不需要了。\nFix Black Window\nIn order to fix the black window that impedes Office 13 to be used, add the HKCU\\Software\\Wine\\Direct3D\\MaxVersionGL new DWORD value 30002 (hexa) to the registry.\nHere’s how to do this: In Winetricks select Run regedit and wait for the Registry Editor window to open. In the folder tree expand HKEY_CURRENT_USER - Software - Wine and create a new key in the Wine folder. To do so, right click, select new–key and name it Direct3D. Now create new–DWORD Value, rename the file to MaxVersionGL and set the value data to 30002 (hexadecimal). Close the Registry Editor window.\nClose the winetricks window and run installer:\nInstall Office 2013\n$ env LANG=zh_CN.UTF-8 WINEPREFIX=~/.wine-office2013pro WINEARCH=win32 wine ~/PathTo/Office2013Setup.x86.exe From here, the install runs and completes 100%.\n安装后可以在 ~/.local/share/applications/wine 下找到 微信、QQ 的 .desktop 文件，右键编辑，将 Exec=env 行改为 Exec=env LANG=zh_CN.utf8\nWeChat Linux 安装微信的可选方案总结\n 腾讯官方 Web 版微信 Franz + 微信（基于 Web 版） Electronic-Wechat（基于 Web 版） 虚拟机 + 微信原生 PC 客户端 CrossOver + 微信原生 PC 客户端 Winetricks（基于 Wine） + 微信原生 PC 客户端 Winetricks-ZH（基于 Wine） + 微信原生 PC 客户端 AppImage + AppImage 打包构建的（Wine + 微信原生 PC 客户端） Flatpak + Flatpak 打包构建的（Deepin-Wine + 微信原生 PC 客户端） Wine + PlayonLinux + 微信原生 PC 客户端  Genshin Impact  Lutris An Anime Game Launcher 葡萄玩：跑腾讯云游戏，再用云游戏玩国服原神。  QEMU KVM QEMU 的图形前端 与其他的虚拟化程序如 VirtualBox 和 VMware 不同, QEMU不提供管理虚拟机的GUI（运行虚拟机时出现的窗口除外），也不提供创建具有已保存设置的持久虚拟机的方法。除非您已创建自定义脚本以启动虚拟机，否则必须在每次启动时在命令行上指定运行虚拟机的所有参数。\nLibvirt提供了一种管理 QEMU 虚拟机的便捷方式。有关可用的前端，请参阅 libvirt 客户端列表。\n创建新虚拟系统 创建硬盘镜像 除非直接从 CD-ROM 或网络引导（并且不安装系统到本地），运行 QEMU 时都需要硬盘镜像。硬盘镜像是一个文件，存储虚拟机硬盘上的内容。\n一个硬盘镜像可能是 raw镜像, 和客户机器上看到的内容一模一样，并且将始终使用主机上的来宾硬盘驱动器的全部容量。此方法提供的I / O开销最小，但可能会浪费大量空间，因为guest虚拟机上未使用的空间无法在主机上使用。\n另外一种方式是qcow2 格式，仅当客户系统实际写入内容的时候，才会分配镜像空间。对客户机器来说，硬盘大小表现为完整大小，即使它可能仅占用主机系统上的非常小的空间。此映像格式还支持QEMU快照功能。但是，使用此格式而不是 raw 可能会影响性能。\nQEMU 提供 qemu-img命令创建硬盘镜像.例如创建一个 4 GB raw 格式的镜像:\n$ qemu-img create -f raw image_file 4G 您也可以用 -f qcow2 创建一个 qcow2 镜像。\n用 dd 或 fallocate 也可以创建一个 raw 镜像。\n警告： 如果硬盘镜像存储在 Btrfs 系统上，则应在创建任何映像之前考虑禁用该目录的 写时复制。\n调整镜像大小\n警告： 调整包含NTFS引导文件系统的镜像将无法启动已安装的操作系统，推荐在操作之前进行备份\n执行 qemu-img 带 resize 选项调整硬盘驱动镜像的大小.它适用于 raw 和 qcow2. 例如, 增加镜像 10 GB 大小, 运行:\n$ qemu-img resize disk_image +10G 在磁盘映像扩容后，必须使用虚拟机内部系统的分区工具对该镜像进行分区并格式化后才能真正开始使用新空间。 在收缩磁盘映像时，必须首先使用虚拟机内部系统的分区工具减少分该分区的大小，然后相应地收缩磁盘映像，否则收缩磁盘映像将导致数据丢失！\n安装操作系统 这是你第一次需要去启动模拟器的步骤，为了在磁盘镜像上安装操作系统，你必须同时将磁盘镜像与安装介质装载到虚拟机上，从安装介质中启动操作系统。\n以i386的客户机为例，为了从CD-ROM内的把可用于启动的ISO文件安装到磁盘镜像上，你需要：\n$ qemu-system-x86_64 -cdrom iso_image -boot order=d -drive file=disk_image,format=raw 在安装完操作系统后，就可以直接从QEMU镜像内启动了。\n注意： 默认情况下仅分配给虚拟机128MB的内存， 分配的内存大小可以通过 -m 调整， 比如 -m 512M 或 -m 2G。\n提示：\n 相较于指定 -boot order=x ，一部分用户感觉使用 -boot menu=on 启用boot菜单的体验更舒服些，至少在配置和实验时是这样的。 当使用无界面（headless）模式时， 将会默认在本地5900端口启动一个VNC服务器， 可以用 TigerVNC 连接到客户机的系统上: vncviewer :5900 若你在安装过程中需要替换软盘或CD，可以使用QEMU机器监视器（在虚拟机窗口中按Ctrl + Alt + 2）来删除存储设备并将其连接到虚拟机。使用info block查看块设备，然后使用change命令换出设备。按下Ctrl + Alt + 1返回虚拟机。  运行虚拟化的系统 qemu-system-* 程序 (例如 qemu-system-i386 或 qemu-system-x86_64, 取决于客户机架构)用来运行虚拟化的客户机. 用法是:\n$ qemu-system-i386 options disk_image 所有 qemu-system-*的选项是相同的。\n默认 QEMU会在窗口中显示虚拟机的视频输出.有一点要记住:当您单击QEMU窗口,鼠标指针被捕获。要放开，按 Ctrl+Alt+g.\n警告： QEMU 不应以 root 身份运行. 如果必须以root身份在某个脚本中运行QEMU，那么你需要使用 -runas 选项让QEMU放弃root权限\n启用 KVM KVM 必须要您处理器和内核支持, 和必要的 kernel modules加载。更多信息参见 KVM。\n要在KVM模式中启动QEMU, 追加 -enable-kvm到启动选项. 要检查是否为正在运行的 VM 启用了 KVM，请使用 Ctrl+Alt+Shift+2 进入 QEMU Monitor，然后键入 info kvm。\n注意：\n -machine 选项中的 accel=kvm 参数与-enable-kvm 或 -accel kvm 选项是等价的。 CPU模型 host 需要 KVM。 如果你使用GUI工具去启动QEMU，但是性能体验极差，那么最好检查一下是否真的开启了KVM支持，因为QEMU可能选择了备用的模拟模式，即软件级模拟。 需要启用KVM才能正常启动windows7和windows8，否则会出现“蓝屏”.  启用 IOMMU (Intel VT-d/AMD-Vi) 的支持 首先启用IOMMU。\n确保您的 CPU 支持 AMD-Vi/Intel Vt-d 并且已经在 BIOS 中打开。通常这个选项会在类似“其他 CPU 特性”的菜单里，也有可能隐藏在超频选项之中。选项可能就叫做 “VT-d” 或者 “AMD-Vi” ，也有可能是更通用的名称，比如“虚拟化技术”之类。有可能您主板的手册并不会解释这些。\n设置内核参数以启用 IOMMU，注意不同品牌的 CPU 所需的内核参数并不同。\n 对于 Intel CPU(VT-d)，使用 intel_iommu=on。 对于 AMD CPU(AMD-Vi)，使用 amd_iommu=on。  您同时需要设置iommu=pt，这将防止Linux试图接触(touching)无法直通的设备。\n在重启之后，检查 dmesg 以确认 IOMMU 已经被正确启用：\n$ dmesg | grep -e DMAR -e IOMMU ... [ 0.000000] Intel-IOMMU: enabled ... 添加 -device intel-iommu 选项创建IOMMU设备:\n$ qemu-system-x86_64 -enable-kvm -machine q35 -device intel-iommu -cpu host .. 注意： 在基于Intel CPU的系统上用 -device intel-iommu 创建QEMU内的IOMMU设备将会禁用PCI直通， 如果需要PCI直通，则不应设置-device intel-iommu。\n宿主机和虚拟机数据交互 网络 我们可以利用任何支持文件传输的网络协议实现客户机和宿主机之间的数据交互, 例如 NFS, SMB, NBD, HTTP, FTP, 或 SSH, 当然这么做的前提是你已经配置好二者之间的网络，且在系统上启动了相应的服务程序。\n在默认情况下，用户模式的客户机能够通过10.0.2.2这个IP访问到宿主机。任何运行于宿主机上的服务端程序都可以通过这个地址被访问到，比如说我们可以通过这个IP访问到宿主机上的SSH服务器或SMB服务器。因此在这种情况下，客户机能够挂载宿主机通过SMB or NFS暴露出来的目录，也可以访问宿主机上的HTTP服务器等。 通常情况下宿主机无法访问客户机上的服务，不过你也可以通过一些特殊的网络配置达到这个目的 (参阅#Tap 网络)\nQEMU 端口转发 QEMU能够将宿主机的端口转发到客户机上以实现一些功能，例如从宿主机上访问客户机的SSH端口。\n举个例子，将宿主机上的10022端口与客户机上的22 (SSH) 端口进行绑定， 对应的QEMU命令如下：\n$ qemu-system-x86_64 disk_image -nic user,hostfwd=tcp::10022-:22 确认你客户机上的sshd程序正在运行，然后可以通过如下命令连接到客户机的SSH端口\n$ ssh guest-user@localhost -p 10022 你可以用 SSHFS 把客户机的整个文件系统都挂到宿主机上，这样就可以在宿主机上对客户机的文件系统进行读写了。\n想进行多端口转发的话, 只需要在-nic参数中指定多个hostfwd, 以VNC端口为例:\n$ qemu-system-x86_64 disk_image -nic user,hostfwd=tcp::10022-:22,hostfwd=tcp::5900-:5900 QEMU 的内置SMB服务器 QEMU的文档中指出它有一个内置的SMB服务器，但实际上，它只是在宿主机上加载一个自动生成的smb.conf配置文件 (位于/tmp/qemu-smb.random_string)，然后启动宿主机上的Samba，使得客户机能够通过一个IP地址进行访问 (默认的IP地址是10.0.2.4)。这个方法只适用于用户网络，在你不想在宿主机开启通常的Samba服务 (客户机同样能访问这类Samba服务) 时这个方法还挺好用的。\n宿主机上必须安装 Samba。通过如下QEMU命令启用这项特性:\n$ sudo apt install samba $ qemu-system-x86_64 disk_image -net nic -net user,smb=shared_dir_path shared_dir_path 就是你想要在宿主机和客户机之间共享的目录。\n接着，在客户机内，你应该能够通过10.0.2.4访问到名为qemu的共享文件夹。例如在Windows Explorer中前往 \\\\10.0.2.4\\qemu 这个地址。\n注意：\n 如果你像这样多次指定共享选项 -net user,smb=shared_dir_path1 -net user,smb=shared_dir_path2 or -net user,smb=shared_dir_path1,smb=shared_dir_path2 qemu只会共享参数中最后的一个目录。 如果你不能访问共享文件夹且客户机系统为 Windows, 请检查 NetBIOS 协议是否被启用 并确认防火墙没有屏蔽NetBIOS协议的 端口 如果你不能访问共享文件夹且客户机系统为 Windows 10 Enterprise 或 Education 或 Windows Server 2016, 请启用游客访问.  共享多个文件夹并在运行时增删文件夹的一个方法是：共享一个空目录，然后在其中创建指向其余共享目录的符号链接。可以用下面的脚本修改SMB服务器的配置，这个脚本还能使宿主机上不允许执行的文件在客户机内拥有执行权限。\n#!/bin/bash eval $(ps h -C smbd -o pid,args | grep /tmp/qemu-smb | gawk '{print \"pid=\"$1\";conf=\"$6}') echo \"[global] allow insecure wide links = yes [qemu] follow symlinks = yes wide links = yes acl allow execute always = yes\"  $conf # in case the change is not detected automatically: smbcontrol --configfile=$conf $pid reload-config 仅当客户机第一次访问到网络驱动后，才能将该脚本启用，并作用于qemu启动的SMB服务器。共享多文件的另一个方法是在配置文件里加入额外的共享路径，就像下面这样\n$ echo \"[myshare] path=another_path read only=no guest ok=yes force user=username\"  $conf 这个共享文件夹可以在客户机内通过\\\\10.0.2.4\\*myshare*访问。\n网络 采用TAP设备（tun 与 tap 设备，都是虚拟网络设备，tun 设备用来实现三层隧道（三层 ip 数据报），tap 设备用来实现二层隧道（二层以太网数据帧）。）和网桥（使用网桥可以将多个接口连接到同一网段内，这一功能等同于交换式集线器。）的虚拟网络的性能应该会比使用用户模式网络或VDE要好，原因在于TAP设备和网桥是在内核中实现的。\n此外，虚拟网络的性能可以通过将网络设备直接注册到虚拟机中改善，这比默认情况下模拟e1000 NIC的性能表现要更好，参阅 [安装 virtio 驱动](#安装 virtio 驱动) 获得更多相关信息。\n关于链路层地址的限制 若在QEMU启动中指定了 -net nic 参数，QEMU将会为虚拟机注册一块虚拟网卡，其链路层地址为 52:54:00:12:34:56 。然而，当在多台虚拟机之间搭建桥接网络时，每台虚拟机在tap设备的虚拟机端都需要拥有一个独一无二的链路层地址 (MAC)，否则网桥会因为收到多个不同源却拥有相同MAC地址的数据包而无法正常工作。即使你为多个tap设备配置了不同的MAC地址也依旧会出现这个问题，因为当数据包通过tap设备时，tap设备并不会改写包内的链路层地址。\n因此请确保每个虚拟机拥有自己独一无二的网卡地址, 并且它们都以 52:54: 开头。 可以通过如下命令手动设置虚拟机的MAC地址, 下面的’X’可以替换成任何16进制字符:\n$ qemu-system-x86_64 -net nic,macaddr=52:54:XX:XX:XX:XX -net vde disk_image 用户模式 默认情况下，没有任何-netdev参数，QEMU将使用带有内置DHCP服务器的用户模式网络。当您的虚拟机运行其DHCP客户端时，将为其分配IP地址，它们将能够通过QEMU伪装的IP来访问物理主机的网络。\n警告： 仅适用于TCP和UDP协议，因此ICMP协议（包括ping）将不起作用。 请勿使用ping测试网络连接。\n如果主机已连接Internet，则此默认配置可以使您的虚拟机轻松访问Internet。但是如果您同时启动多个虚拟机，则虚拟机将无法在外部网络上直接看到，虚拟机也将无法相互通信。\nQEMU的用户模式网络可以提供更多功能，例如内置TFTP或SMB服务器，将主机端口重定向到虚拟机（例如，允许SSH连接到虚拟机）或将虚拟机连接到VLAN（vlan 全程 virtual lan，能够用来虚拟分配以太网。归属于不同的 VLAN ID 的设备之间需要一个路由才能够通信，这意味这不同的 VLAN ID 将以太网划分成了不同的分组。），以便它们可以彼此通信。 有关更多详细信息，请参见-net user标志上的QEMU文档。\n但是，用户模式网络在效用和性能上都有局限性。更高级的网络配置需要使用TAP设备或其他方法。\nTap 网络 Tap devices是一个Linux内核特性，允许您创建作为真实网络接口的虚拟网络接口。发送到tap接口的包将被传递到一个用户空间程序(如QEMU)，该程序将自己绑定到该接口。\nQEMU可以为虚拟机使用tap网络，因此发送到tap接口的包将被发送到虚拟机，并显示为来自虚拟机中的网络接口(通常是以太网接口)。相反，虚拟机通过其网络接口发送的所有内容都将出现在tap接口上。\nLinux桥接驱动程 序支持Tap设备，因此可以将Tap设备彼此桥接在一起，也可以连接其他主机接口，如eth0。如果您希望您的虚拟机能够相互通信，或者希望LAN上的其他机器能够与虚拟机通信，那么这是非常理想的方案。\n警告： 如果您将tap设备和一些主机接口桥接在一起，例如eth0，您的虚拟机将直接出现在外部网络上，这将使它们遭受攻击的可能。根据您的虚拟机可以访问的资源，您可能需要采取所有precautions来保护您的虚拟机。如果风险太大,虚拟机没有资源或您设置多个虚拟机,一个更好的解决方案可能是使用host-only networking建立NAT。在这种情况下，您只需要在主机上安装一个防火墙，而不是为每个虚拟机安装多个防火墙。\n正如在用户模式网络部分中指出的，tap设备提供比用户模式具有更高的网络性能。如果虚拟机中的操作系统支持virtio网络驱动程序，那么网络性能也会显著提高。假设使用tap0设备，virtio驱动程序在客户端上使用，并且没有使用脚本来帮助启动/停止网络，使用下面的qemu命令：\n-net nic,model=virtio -net tap,ifname=tap0,script=no,downscript=no 但是，如果已经使用带有virtio网络驱动程序的Tap设备，则甚至可以通过启用vhost来提高网络性能，例如：\n-net nic,model=virtio -net tap,ifname=tap0,script=no,downscript=no,vhost=on 仅主机网络\n如果为网桥提供了IP地址，并且使能发往该网桥的流量允许，但没有实际接口（例如eth0）连接到网桥，则虚拟机与虚拟机间，虚拟机与主机间能够相互通信。但是，如果您没有在物理主机上设置IP掩蔽，则他们将无法与外部网络进行通信。 此配置被其他虚拟化软件（例如VirtualBox）称为“仅主机网络模式”。\n提示：\n  如果你想设置IP掩蔽，例如虚拟机的NAT，请查看Internet sharing#Enable NAT页面。\n  您也许想在网桥接口上运行一个DHCP服务器来服务虚拟网络。例如，使用172.20.0.1/16子网，dnsmasq作为DHCP服务器:\n# ip addr add 172.20.0.1/16 dev br0 # ip link set br0 up # dnsmasq --interface=br0 --bind-interfaces --dhcp-range=172.20.0.2,172.20.255.254   内部网络\n如果您不为网桥提供IP地址并在iptables添加INPUT规则链，将所有流向网桥中的数据丢弃，则虚拟机将能够彼此通信，但无法与物理主机或外部网络通信。此配置被其他虚拟化软件（例如VirtualBox）称为“内部网络”。您将需要为虚拟机分配静态IP地址，或在其中一个虚拟机上运行DHCP服务器。\n在默认情况下，iptables将丢弃桥接网络中的数据包。您可能需要使用这样的iptables规则来允许桥接网络中的数据包:\n# iptables -I FORWARD -m physdev --physdev-is-bridged -j ACCEPT 使用 qemu-bridge-helper 桥接网络\n这种方法不需要启动脚本，并且很容易适应多个tap和多个桥。它使用/usr/lib/qemu/qemu-bridge-helper，允许在现有桥上创建tap设备。\n提示： 参见 Network bridge 获取创建网桥的信息.\n首先，创建一个配置文件，包含QEMU使用的所有网桥的名称:\n/etc/qemu/bridge.conf allow bridge0 allow bridge1 ... 现在启动虚拟机：\n$ qemu-system-i386 -net nic -net bridge,br=bridge0 [...] 在多个TAP设备的情况下，最基本的用法是要为所有NIC指定VLAN：\n$ qemu-system-i386 -net nic -net bridge,br=bridge0 -net nic,vlan=1 -net bridge,vlan=1,br=bridge1 [...] 手工创建网桥\n将虚拟机连接到主机接口，如eth0，这可能是最常见的配置。这种配置使虚拟机看起来直接位于外部网络，与物理主机位于同一以太网段。\n物理设备和Tap设备之间通过iptables进行网络共享\n桥接网络能在有线接口(例如eth0)之间工作，并且很容易设置。但是，如果主机通过无线设备连接到网络，则无法进行桥接。\n解决这个问题的一种方法是，给tap设备设置一个静态IP，使linux自动处理它的路由，然后通过iptables规则转发tap接口和连接到网络的设备之间的通信。\n通过 VDE2 配置网络 VDE全称为Virtual Distributed Ethernet，作为uml_switch的一个扩展，是一个用于管理虚拟网络的工具包\n其基本的思想是创建一个虚拟的开关，就如插座那样，允许虚拟机和物理机通过\"插入\"连接彼此。下面的配置非常简单，然而，VDE的功能远比展示的更强大，其能够接入虚拟开关，在不同的主机上运行它们并监听开关上的通信。\n本方法的优点在于无需sudo特权，普通用户一般没有运行modprobe的权限。\nVDE2 网桥 任何连接到vde上的虚拟机都会暴露给外部。举个例子，每台虚拟机都能直接从ADSL路由器那收到DHCP的配置信息。\n简化配置参数 如果你经常需要以不同的网络配置选项运行QEMU，就会发现时常得输入大量的-netdev和-device选项组合，这些是大量重复性的劳动。可以用-nic选项将二者结合，就如下面这样，底下这些参数：\n-netdev tap,id=network0,ifname=tap0,script=no,downscript=no,vhost=on -device virtio-net-pci,netdev=network0 可简化为:\n-nic tap,script=no,downscript=no,vhost=on,model=virtio-net-pci 要注意的是缺失了网络ID，因此将会以model=创建这些设备。{ic|-nic}}命令的前半部分参数正是-netdev的参数，而后半部分参数（model=之后的部分）则与设备有关，原本设备所提供的参数同样可以在此使用（例如，可以指定smb=）。若要完全禁用网络，可以用-nic none。\n图形 QEMU 可以使用一下几个图形输出：std, cirrus, vmware, qxl, xenfs 和 vnc。\n使用 vnc 选项，你可以单独运行客户机，并且通过 VNC 连接。\nstd\n使用 -vga std 你可以得到最高 2560 x 1600 像素的分辨率。从 QEMU 2.2 开始是默认选项。\nqxl\nQXL是一个支持2D的并行虚拟化图形驱动。需要在客户机中安装驱动并在启动QEMU时设置-vga qxl选项。你可能也会想使用#SPICE优化QXL的图形表现。\n在Linux客户机中，需要加载qxl和bochs_drm这两个内核模块，以获得一个比较好的效果。\nQXL设备的默认VGA内存大小为16M，这样的内存大小最高支持QHD (2560x1440)的分辨率，如果想要一个更高的分辨率，请增加vga_memmb。\nvmware\n尽管Bug有点多，但相比于std和cirrus它的表现会更好。对于Arch Linux客户机来说可以安装xf86-video-vmware和xf86-input-vmmouse获取VMware驱动。\nvirtio\nvirtio-vga / virtio-gpu 是一个基于virgl的3D并行虚拟化图形驱动。目前依旧处于开发中，仅支持最近的（= 4.4）的Linux客户机，且需要以gallium-drivers=virgl选项编译mesa (=11.2)。\n若要在客户机上启用3D加速，那么需要用-vga virtio选项选择此vga，并用-display sdl,gl=on或-display gtk,gl=on在显示设备上启用opengl上下文，这两个选项分别适用于sdl输出和gtk输出。如果配置成功了，那么在客户机的kernel log里可以看到：\n# dmesg | grep drm [drm] pci: virtio-vga detected [drm] virgl 3d acceleration enabled cirrus\ncirrus是2.2之前默认的图形选项，不应当在现代操作系统中使用它。\nnone\n这就像一台完全没有VGA卡的PC，无法通过-vnc访问它。另外，这种情况与使用-nographic选项不同，-nographic会让QEMU模拟VGA卡，只是关闭了SDL输出。\nSPICE SPICE project旨在为用户提供一种完全开源的方式，无缝地对虚拟机进行远程访问。\nVNC 可以用-vnc :*X*选项将QEMU的VGA输出重定向至VNC会话中。将*X*替换为输出目标的编号（0代表之后监听在5900，1代表监听在5901…）。\n$ qemu-system-x86_64 -vnc :0 警告： 默认的VNC服务器没有使用任何验证手段，用户可以从任何主机上连接到VNC。\n基本的口令验证\n可以通过使用password选项很容易地设置访问口令。必须在QEMU Monitor中指定口令，仅当用户提供口令时才有可能连接到VNC。\n$ qemu-system-x86_64 -vnc :0,password -monitor stdio 在QEMU Monitor中设置口令需使用change vnc password命令，然后指定一个口令。\n底下的命令将在启动VNC时直接为其设置口令：\n$ printf \"change vnc password\\n%s\\n\" MYPASSWORD | qemu-system-x86_64 -vnc :0,password -monitor stdio 注意： 口令被限制在8个字符内，可以用暴力破解的方式猜到口令。因此在公网上推荐使用更细致的保护措施。\n音频 -audiodev标识用于设定后端音频驱动及其相关选项。最简单的情况下，你需要选择一个驱动并设置一个id。\n-audiodev pa,id=snd0 使用音频设备 Intel HD Audio\n模拟Intel HD Audio需要添加控制器和编解码器设备。可以用如下命令列出可用的Intel HDA Audio设备：\n$ qemu-system-x86_64 -device help | grep hda 添加音频控制器：\n-device ich9-intel-hda 添加音频编解码器并将其映射到宿主机的音频后端id上。\n-device hda-output,audiodev=snd0 Intel 82801AA AC97\n模拟AC97需要添加声卡设备并将其映射到宿主机的一个音频后端id上。\n-device AC97,audiodev=snd0 无音频设备 通过如下命令获取支持模拟的音频驱动列表：\n$ qemu-system-x86_64 -soundhw help 比如，要在客户机上模拟hda驱动，需要使用-device intel-hda -device hda-duplex选项启动QEMU。\n注意： 客户机的显卡模拟驱动可能也会导致客户机中的音频质量出现问题，需要一个个进行排查。使用qemu-system-x86_64 -h | grep vga列出可用的选项\n安装 virtio 驱动 QEMU为用户提供并行虚拟化块设备和网络设备的能力，其是借助virtio驱动实现的，拥有更好的性能表现以及更低的开销。\nvirtio块设备需要使用-drive指定一个disk image的参数，且需要带上if=virtio参数：\n$ qemu-system-x86_64 -boot order=c -drive file=disk_image,if=virtio 网络配置也是类似的：\n$ qemu-system-x86_64 -nic user,model=virtio-net-pci 注意： 仅有当客户机有virtio设备对应的驱动时该方法才能起效，Linux是有这方面支持的，不过无法保证这些驱动能够兼容其他操作系统。\n以下以windows为例。\n块设备驱动 Windows没有自带virtio驱动，因此需要在安装时加载该驱动。镜像文件可以从Fedora 仓库下载。\n通过ISO加载只对Windows Vista和Windows Server 2008及其之后的版本有效。这个方法的具体操作是在主磁盘设备和Windows安装盘外挂载一个额外的cdrom设备，将系统镜像与virtio驱动一同加载：\n$ qemu-system-x86_64 ... \\ -drive file=windows_disk_image,index=0,media=disk,if=virtio \\ -drive file=windows.iso,index=2,media=cdrom \\ -drive file=virtio.iso,index=3,media=cdrom \\ ... 在安装过程中，Windows Installer会询问你“Where do you want to install Windows?”，其会返回一个警告表示没有找到任何磁盘设备。接下来跟着如下示例中的步骤进行操作（基于Windows Server 2012 R2 with Update）：\n Select the option Load Drivers. Uncheck the box for Hide drivers that are not compatible with this computer’s hardware. Click the browse button and open the CDROM for the virtio iso, usually named “virtio-win-XX”. Now browse to E:\\viostor\\[your-os]\\amd64, select it, and confirm.  现在应该能看到virtio磁盘出现在列表中了，等待着被选中、格式化并安装。\n网络驱动 安装virtio网络驱动程序要容易一些，只需如上所述添加-net参数即可。\n$ qemu-system-i386 -m 4G -vga std -drive file=windows_disk_image,if=virtio -net nic,model=virtio-net-pci -cdrom virtio-win-0.1-185.iso Windows将检测网络适配器并尝试为其找到驱动程序。如果失败，请转到“设备管理器”，找到带有感叹号图标的网络适配器（双击打开），切换到驱动程序并单击“更新驱动程序”，然后选择虚拟CD-ROM。别忘了选中显示要递归搜索目录的复选框。\nBalloon 驱动 如果想要追踪客户机内存状态（比如通过virsh的dommemstat命令）或者在运行时改变客户机内存大小（尽管依然无法改变实际的内存大小，不过可以通过inflating balloon驱动限制内存的使用），那么请在客户机上安装balloon驱动吧。\nQEMU 监视器 QEMU运行时会提供一个监视器console界面以方便用户同虚拟机进行交互。QEMU监视器提供了许多有趣的功能，例如获取当前虚拟机的信息，热插拔设备，创建快照等。在QEMU监视器console中运行help或?命令获得完整的命令列表。\n访问QEMU监视器Console 图形化界面\n当使用默认的std图形选项时，可以通过按下Ctrl+Alt+2组合键或从QEMU窗口上的View  compatmonitor0访问到QEMU监视器。若要返回到虚拟机的图形界面，那么按下Ctrl+Alt+1或者View  VGA就行。\n然而，这种标准的访问方式不够方便，而且并不是在QEMU的所有图形化输出方式中都适用。\nTelnet\n启动QEMU时带上-monitor telnet:127.0.0.1:*port*,server,nowait参数可以启用telnet。虚拟机启动后可以通过telnet访问到监视器：\n$ telnet 127.0.0.1 port 注意： 如果指定 127.0.0.1 作为监听地址，那么只能在运行QEMU的宿主机上连接到该监视器。如果想要远程访问，QEMU需要在0.0.0.0上进行监听：-monitor telnet:0.0.0.0:*port*,server,nowait。还要记住的是，最好对firewall进行配置，该连接是完全不进行认证和加密的，因此需要通过防火墙确保本地网络环境是可信的。\nUNIX socket\n通过-monitor unix:*socketfile*,server,nowait参数运行QEMU，之后就可以通过socat或openbsd-netcat连接到监视器上。\n例如，如果QEMU是通过如下命令启动：\n$ qemu-system-x86_64 [...] -monitor unix:/tmp/monitor.sock,server,nowait [...] 就可以像这样连接到监视器上：\n$ socat - UNIX-CONNECT:/tmp/monitor.sock 或者通过这种方式:\n$ nc -U /tmp/monitor.sock TCP\n可以使用-monitor tcp:127.0.0.1:*port*,server,nowait参数将监视器暴露于TCP端口上，然后用netcat（openbsd-netcat或gnu-netcat都可）进行连接：\n$ nc 127.0.0.1 port 注意： 为了能够从其它设备上通过TCP socket访问到监视器，而不仅仅从运行QEMU的主机上连接，需要像前面Telnet中描述的那样，在0.0.0.0地址上进行监听。\n标准 I/O\n如果以-monitor stdio参数运行QEMU，那么其实是可以在运行QEMU的终端下访问到监视器的。\n在Monitor conosle下向虚拟机发送按键行为 由于在某些配置下，宿主机可能会拦截一些按键组合另作他用，这导致要在虚拟机中触发一些特定按键组合变得有些困难（一个显然的例子就是Ctrl+Alt+F*组合，该组合用于改变当前的tty）。我们采用在monitor console下发送按键组合的方式解决该问题。只需切换到monitor console下，然后使用sendkey命令，即可将按键转发至虚拟机中，例如：\n(qemu) sendkey ctrl-alt-f2 通过 monitor console 创建快照和管理快照 注意： 该特性\"只\"支持qcow2格式的虚拟机磁盘镜像，对于raw是无效的。\n有时候我们很需要将虚拟机的当前状态进行保存，或是将虚拟机重置到之前的快照状态，而且最好是随时能进行这些操作。QEMU monitor console为用户提供了必要的功能，进行快照创建，快照管理，以及快照恢复。\n Use savevm name 用于创建一个名为name的快照。 Use loadvm name 用于将虚拟机状态恢复至快照name。 Use delvm name 用于删除快照name。 Use info snapshots 用于查看保存的快照列表，这些快照由一个自增长的ID和标签名（用户创建快照时赋予）进行标识。  以冻结模式运行虚拟机 QEMU支持以冻结态运行虚拟机（需使用-snapshot参数），换句话说，虚拟机关闭时，对于虚拟机的一切修改都会丢弃。当用户对磁盘镜像写入时，这些变动最终写入的位置是/tmp目录下的一个临时文件，QEMU关机时将会把他们丢弃。\n不过，即使虚拟机运行于冻结状态下，依旧可以通过monitor console将这些变化写入磁盘镜像（如果你想的话）。使用下面的命令：\n(qemu) commit all 另外如果在冻结状态下创建快照，这些快照在QEMU退出时都会被丢弃，除非你显式地commit了他们。\nmonitor console中的开机和暂停命令 在QEMU monitor console下也可以模拟对物理机的一些操作：\n system_powerdown 会向虚拟机发送ACPI关机信号，效果就类似物理机上按下电源按钮。 system_reset 会重置虚拟机，类似物理机上的重置按钮。该操作可能导致数据丢失或文件系统的损坏，这是因为虚拟机并不是\"干净地\"重启的。 stop 会暂停虚拟机。 cont 使暂停的虚拟机恢复运行。  虚拟机截屏 可以在monitor console下运行该命令，获取PPM格式的截屏图片：\n(qemu) screendump file.ppm QEMU 机器协议 QEMU机器协议（QMP）是一个基于JSON格式的协议，使得其他应用程序可以通过该协议控制QEMU实例。类似#QEMU 监视器，其提供了与运行中的虚拟机进行交互的能力，且能够编程进行控制。关于QMP各命令的描述可以在这个qmp-commands链接中找到。\n技巧 改善虚拟机的性能表现 底下是一些可以改善虚拟机性能表现的技术，例如：\n  启用#启用 KVM：QEMU的启动命令加上-enable-kvm选项。\n  通过-cpu host选项让QEMU模拟宿主机上的特定CPU，如果没有该选项QEMU尝试模拟的是一个更为通用的CPU。\n  特别的，如果客户机是Windows，启用Hyper-V enlightenments可以改善性能：-cpu host,hv_relaxed,hv_spinlocks=0x1fff,hv_vapic,hv_time.\n  如果宿主机有多个核心，可以用-smp选项为客户机分配更多核心。\n  检查是否为虚拟机分配的足够的内存。默认情况下，QEMU仅仅为每台虚拟机分配128MiB的内存，可以使用-m选项分配更多的内存。例如，-m 1024代表启动一台内存为1024MiB的虚拟机。\n  如果客户机操作系统支持相关的驱动，可以使用virtio创建网络设备或块设备。\n  使用TAP设备代替user-mode网络，参阅#Tap 网络。\n  如果客户机需要进行大量的磁盘写工作，在宿主机文件系统上设置合适的挂载选项可以优化该工作。例如，可以用barrier=0选项挂载一个ext4 file system。在使用这些性能强化选项之前最好阅读相关文档，因为性能上的提升通常伴随着数据完整性下降的代价。\n  如果有一块原始磁盘镜像，你可能会想要禁用cache：\n$ qemu-system-x86_64 -drive file=disk_image,if=virtio,cache=none   使用原生的Linux AIO：\n$ qemu-system-x86_64 -drive file=disk_image,if=virtio,aio=native,cache.direct=on   如果正同时运行多台虚拟机，而它们拥有同样的操作系统，可以通过启用内核页归并节省内存。参阅#开启KSM。\n  在一些情况下，可以在运行时从安装了balloon驱动的客户机上回收内存，这需要QEMU启动该客户机时使用-device virtio-balloon选项。\n  允许使用一个ICH-9 AHCI控制器的仿真层，尽管它并不稳定。AHCI的仿真模拟支持NCQ，因此可以同时处理多个读写请求：\n$ qemu-system-x86_64 -drive id=disk,file=disk_image,if=none -device ich9-ahci,id=ahci -device ide-drive,drive=disk,bus=ahci.0   参阅 https://www.linux-kvm.org/page/Tuning_KVM 获取更多信息\n开机时启动QEMU虚拟机 通过libvirt实现\n如果虚拟机是通过libvirt设置的，可以用virsh autostart将其配置为开机自启，或者通过virt-managerGUI中虚拟机的Boot Options，选择\"Start virtual machine on host boot up\"实现开机自启。\n通过systemd service实现\n可以用如下的systemd unit和config配置开机时启动QEMU VM。\n/etc/systemd/system/qemu@.service [Unit] Description=QEMU virtual machine [Service] Environment=\"haltcmd=kill -INT $MAINPID\" EnvironmentFile=/etc/conf.d/qemu.d/%i ExecStart=/usr/bin/qemu-system-x86_64 -name %i -enable-kvm -m 512 -nographic $args ExecStop=/bin/bash -c ${haltcmd} ExecStop=/bin/bash -c 'while nc localhost 7100; do sleep 1; done' [Install] WantedBy=multi-user.target 注意： 为了方便地结束任务，该service会等待至console端口被释放（这意味着VM已被关闭）。\n接着创建per-VM配置文件，命名为/etc/conf.d/qemu.d/*vm_name*，在其中设置好args和haltcmd变量，配置示例：\n/etc/conf.d/qemu.d/one args=\"-hda /dev/vg0/vm1 -serial telnet:localhost:7000,server,nowait,nodelay \\ -monitor telnet:localhost:7100,server,nowait,nodelay -vnc :0\" haltcmd=\"echo 'system_powerdown' | nc localhost 7100\" # or netcat/ncat /etc/conf.d/qemu.d/two args=\"-hda /srv/kvm/vm2 -serial telnet:localhost:7001,server,nowait,nodelay -vnc :1\" haltcmd=\"ssh powermanager@vm2 sudo poweroff\" 对该变量的描述如下：\n args - 使用的QEMU命令行参数。 haltcmd - 安全关闭虚拟机的命令，在第一个例子中，QEMU monitor是通过-monitor telnet:..选项暴露至telnet，因而关闭虚拟机是通过nc命令在monitor console中发送system_powerdown，完成ACPI关机的工作。在另一个例子里，使用的则是SSH。  若要设置启动时运行哪个虚拟机，enable qemu@*vm_name*.service这个systemd单元\n鼠标整合 添加-usb -device usb-tablet选项以避免点击客户机系统的窗口时鼠标被捕获。该选项代表QEMU能够在不捕获鼠标的情况下，向系统报告鼠标的位置，该选项启用时还会覆盖PS/2鼠标模拟功能。 命令示例：\n$ qemu-system-x86_64 -hda disk_image -m 512 -usb -device usb-tablet 宿主机的USB设备传递至虚拟机 从客户机访问连接到宿主机USB口的设备是可能的，首先需要识别设备连接的位置，可以用lsusb命令找到设备连接位置，例如：\n$ lsusb ... Bus 003 Device 007: ID 0781:5406 SanDisk Corp. Cruzer Micro U3 上面以显示的数字分别用于标识\n 003 host_bus 007 host_addr 0781 vendor_id 5406 product_id  基本的思想是在QEMU中-device usb-ehci,id=ehci或-device qemu-xhci,id=xhci分别对EHCI (USB 2)或XHCI (USB 3)（在win7无法自动安装 USB3 驱动，因此应用 USB2）控制器进行模拟，然后将物理设备通过-device usb-host,..选项进行添加。\n识别出该设备，并将其连接至任一总线以及宿主机上的地址，通用的语法如下：\n-device usb-host,bus=controller_id.0,vendorid=0xvendor_id,productid=0xproduct_id 应用于上面例子中使用的设备，它变成：\n-device usb-ehci,id=ehci -device usb-host,bus=ehci.0,vendorid=0x0781,productid=0x5406 运行QEMU时会遇到 libusb couldn't open USB device Permission denied 权限错误，可以通过 udev 为设备设定合适的权限。\n$ vi /etc/udev/rules.d/50-usbtinyisp.rules SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"0781\", ATTRS{idProduct}==\"5406\", GROUP=\"vane\", MODE=\"0660\" $ ls -al /dve/bus/usb/003/007 crw-rw---- 1 root vane 189, 11 Nov 7 12:37 /dev/bus/usb/003/007 使用SPICE进行USB重定向 使用#SPICE时可以将USB设备从客户端重定向至虚拟机中，无需使用QEMU命令。还支持为配置USB重定向插槽数（插槽数将决定可同时重定向的最大设备数）。相比于前面那种使用-usbdevice进行重定向的方法，SPICE方法的优势在于可以在虚拟机启动后USB设备热插拔，移除或添加USB设备时无需停机。这个方法还允许通过网络将客户端的USB设备重定向至服务端。总之，其是在QEMU虚拟机中使用USB设备最灵活的方法。\n开启KSM Kernel Samepage Merging (KSM) 是Linux内核的一个特性，允许应用程序向内核申请同其他申请页归并的进程进行页归并，KSM机制允许客户虚拟机之间进行页共享。当许多客户机运行相似的操作系统时，这个机制可以节省客观的内存。\n多屏支持 Linux的QXL驱动支持默认支持四头（虚拟屏幕），可以通过qxl.heads=N这一内核参数进行变更。\n复制和粘贴 在宿主机和客户机之间共享剪贴板的方法之一是使用SPICE远程桌面协议，通过SPICE客户端访问客户机，你需要遵照#SPICE节中描述的步骤，通过该方式运行的客户机将支持与宿主机进行复制粘贴的操作。\nlibvirt Libvirt 是一组软件的汇集，提供了管理虚拟机和其它虚拟化功能（如：存储和网络接口等）的便利途径。这些软件包括：一个长期稳定的 C 语言 API、一个守护进程（libvirtd）和一个命令行工具（virsh）。Libvirt 的主要目标是提供一个单一途径以管理多种不同虚拟化方案以及虚拟化主机，包括：KVM/QEMU，Xen，LXC，OpenVZ 或 VirtualBox hypervisors。\nLibvirt 的一些主要功能如下：\n VM management（虚拟机管理）：各种虚拟机生命周期的操作，如：启动、停止、暂停、保存、恢复和迁移等；多种不同类型设备的热插拔操作，包括磁盘、网络接口、内存、CPU等。 Remote machine support（支持远程连接）：Libvirt 的所有功能都可以在运行着 libvirt 守护进程的机器上执行，包括远程机器。通过最简便且无需额外配置的 SSH 协议，远程连接可支持多种网络连接方式。 Storage management（存储管理）：任何运行 libvirt 守护进程的主机都可以用于管理多种类型的存储：创建多种类型的文件镜像（qcow2，vmdk，raw，…），挂载 NFS 共享，枚举现有 LVM 卷组，创建新的 LVM 卷组和逻辑卷，对裸磁盘设备分区，挂载 iSCSI 共享，以及更多…… Network interface management（网络接口管理）：任何运行 libvirt 守护进程的主机都可以用于管理物理的和逻辑的网络接口，枚举现有接口，配置（和创建）接口、桥接、VLAN、端口绑定。 Virtual NAT and Route based networking（虚拟 NAT 和基于路由的网络）：任何运行 libvirt 守护进程的主机都可以管理和创建虚拟网络。Libvirt 虚拟网络使用防火墙规则实现一个路由器，为虚拟机提供到主机网络的透明访问。  安装 基于守护进程/客户端的架构的 libvirt 只需要安装在需要要实现虚拟化的机器上。注意，服务器和客户端可以是相同的物理机器。\n服务端\n安装 libvirt 以及至少一个虚拟运行环境（hypervisor）：libvirt 的 KVM/QEMU 驱动 是 libvirt 的首选驱动，如果 KVM 功能已启用，则支持全虚拟化和硬件加速的客户机。\n$ sudo apt update $ sudo apt install qemu-kvm libvirt-daemon-system 安装 libvirt-daemon-system 后，需要将用于管理虚拟机的用户添加到libvirt组中。这对于 sudo 组的成员是自动完成的，但对于应该访问系统范围的 libvirt 资源的其他任何人，都需要另外完成。这样做将授予用户访问高级网络选项的权限。\n在终端中输入：\n$ sudo adduser $USER libvirt 如果选择的用户是当前用户，您需要注销并重新登录才能使新的组成员身份生效。\n客户端\n客户端是用于管理和访问虚拟机的用户界面。\n virsh — virsh 是用于管理和配置域（虚拟机）的命令行程序。 Virtual Machine Manager — 使用libvirt对KVM，Xen，LXC进行管理的图形化工具。  配置 对于系统 级别的管理任务（如：全局配置和镜像卷 位置），libvirt 要求至少要设置授权和启动守护进程。\n注意： 对于用户会话 级别的管理任务，守护进程的安装和设置不是 必须的。授权总是仅限本地，前台程序将启动一个 libvirtd 守护进程的本地实例。\n设置授权 自 libvirt：连接授权：Libvirt 守护进程允许管理员分别为客户端连接的每个网络 socket 选择不同授权机制。这主要是通过 libvirt 守护进程的主配置文件 /etc/libvirt/libvirtd.conf 来实现的。每个 libvirt socket 可以有独立的授权机制配置。目前的可选项有 none、polkit 和 sasl。\n由于 libvirt 在安装时将把 polkit 作为依赖一并安装，所以 polkit 通常是 unix_sock_auth 参数的默认值。但基于文件的权限仍然可用。\n使用 polkit\n注意： 为使 polkit 认证工作正常，应该重启一次系统。\nlibvirt 守护进程在 polkit 策略配置文件（/usr/share/polkit-1/actions/org.libvirt.unix.policy）中提供了两种策略：\n org.libvirt.unix.manage 面向完全的管理访问（读写模式后台 socket），以及 org.libvirt.unix.monitor 面向仅监视察看访问（只读 socket）。  默认的面向读写模式后台 socket 的策略将请求认证为管理员。这点类似于 sudo 认证，但它并不要求客户应用最终以 root 身份运行。默认策略下也仍然允许任何应用连接到只读 socket。\n基于文件的权限授权\n为了给 libvirt 组用户定义基于文件的权限以管理虚拟机，取消下列行的注释：\n$ vim /etc/libvirt/libvirtd.conf #unix_sock_group = \"libvirt\" #unix_sock_ro_perms = \"0777\" # set to 0770 to deny non-group libvirt users #unix_sock_rw_perms = \"0770\" #auth_unix_ro = \"none\" #auth_unix_rw = \"none\" 有些资料提到可以通过改变某些特定 libvirt 目录的权限以简化管理。需要记住的是：包更新时，这些变更会丢失。如要修改这些系统目录的权限，需要 root 用户权限。\n守护进程 libvirtd.service 和 virtlogd.service这两个服务单元都要启动。可以把 libvirtd.service 设置为启用，这时系统将同时启用 virtlogd.service 和 virtlockd.socket 两个服务单元，因此后二者不必再设置为启用。\n测试 测试 libvirt 在系统级工作是否正常：\n$ virsh -c qemu:///system 测试 libvirt 在用户会话级工作是否正常：\n$ virsh -c qemu:///session 管理 绝大部分的 libvirt 管理可以通过三个工具实现：virt-manager（图形界面）、virsh 和 guestfish（它是 libguestfs 的一部分）。\nvirsh Visrsh 用于管理客户域（虚拟机），在脚本式虚拟化管理环境中工作良好。由于需要通过通讯管道与虚拟运行环境通讯，绝大部分 virsh 命令需要管理员权限。尽管如此，一些典型的管理操作如域的创建、运行等也可以像VirtualBox 那样以普通用户身份执行。\nVirsh 允许带命令行选项执行。如果不带则进入其内置的交互式终端：virsh。交互式终端支持 tab 键命令补全。\n从命令行执行：\n$ virsh [可选项]  [参数]... 在交互式终端里运行：\nvirsh #  [参数]... 帮助也是可用的：\n$ virsh help [option*] or [group-keyword*] 存储池 存储池是指保存卷的位置。Libvirt 中卷的定义相当于其他系统中虚拟磁盘或虚拟机镜像的概念。存储池应该是一个目录、一个网络文件系统或一个分区（此处包括 LVM）。存储池可以在活动与不活动之间切换，可以为其分配存储空间。\n以下示例为添加存储池、目录和 LVM 卷的方法：\n$ virsh pool-define-as name type [source-host] [source-path] [source-dev] [source-name] [] [--source-format format] $ virsh pool-define-as poolname dir - - - - /home/username/.local/libvirt/images $ virsh pool-define-as poolname fs - - /dev/vg0/images - mntpoint 上述示例仅仅定义了存储池的信息，下面创建它：\n$ virsh pool-build poolname $ virsh pool-start poolname $ virsh pool-autostart poolname 删除它的命令：\n$ virsh pool-undefine poolname 提示： 对于 LVM 存储池而言：\n 最佳实践是仅把一个卷组分配给一个存储池。 请为存储池选择一个与 LVM 卷组不同的名字。否则当存储池被删除时，该卷组也将被删除。  用 virt-manager 新建存储池\n首先，连接到虚拟运行环境（例如QEMU/KVM的系统/用户会话）。然后，右键点击一个连接（例如QEMU/KVM）选择详情，切换到存储选项卡，点击左下角的**+**，按照向导操作。\n存储卷 存储池被创建之后，就可以在存储池中创建存储卷。如果你想新建一个域（虚拟机），那么这一步可以跳过，因为这一步可以在创建域的过程中完成。\n用 virsh 新建卷\n新建卷，列出卷，变更卷大小，删除卷：\n$ virsh vol-create-as poolname volumename 10GiB --format aw|bochs|raw|qcow|qcow2|vmdk $ virsh vol-upload --pool poolname volumename volumepath $ virsh vol-list poolname $ virsh vol-resize --pool poolname volumename 12GiB $ virsh vol-delete --pool poolname volumename $ virsh vol-dumpxml --pool poolname volumename # for details. 域 虚拟机被称作**“域”**。如果你想在命令行下操作，使用virsh列出，创建，暂停，关闭……域。virt-viewer可以用来查看使用virsh启动的域。域的创建通常以图形化的virt-manager或者命令行下的virt-install完成。 创建新域通常需要安装媒介，例如存储池中的iso文件或是直接从光驱安装。\n列出活动的和不活动的域：\n# virsh list --all 用 virt-install 新建域\n对于很详细的域（虚拟机）配置，可以用 virt-manager 新建域更简单地完成。但是，基础配置同样可以用virt-install完成并且同样运行顺利。至少要配置--name, --memory, 存储(--disk, --filesystem,或--nodisks),和安装方法（通常来说是.iso文件或CD）。查看virt-install(1)得到未列出的选项和更多的详情。\nWindows:\n$ virt-install \\  --name=windows7 \\  --memory 2048 \\  --cdrom /dev/sr0 \\  --os-variant=win7 \\  --disk /mnt/storage/domains/windows7.qcow2,size=20GiB \\  --network network=vm-net \\  --graphics spice 导入现有的卷：\n$ virt-install \\  --name demo \\  --memory 512 \\  --disk /home/user/VMs/mydisk.img \\  --import 用 virt-manager 新建域\n首先，连接到虚拟运行环境（例如 QEMU/KVM system 或用户 session，在连接上右击并选择 新建，然后跟随向导完成。\n 在第四步中取消选中立即分配全部虚拟磁盘空间会加快创建过程并节省实际虚拟磁盘空间占用；然而，这将导致将来花费额外的磁盘整理时间。 在第五步中打开高级选项并确认虚拟化类型设为 kvm（这通常是首选模式）。如果要求附加的硬件配置，选中安装前定制选项。  管理域\n启动域：\n$ virsh start domain $ virt-viewer --connect qemu:///session domain 正常关闭域；强制关闭域:\n$ virsh shutdown domain $ virsh destroy domain 在libvirtd启动时自动启动域:\n$ virsh autostart domain $ virsh autostart domain --disable 在宿主机关闭时自动关闭域:\n使用libvirt-guests.serviceSystemd服务，运行中的域可以在宿主机关闭时自动挂起/关闭。同时这个服务还可以让挂起/休眠的域在宿主机启动的时候自动恢复。查看/etc/conf.d/libvirt-guests并设置相关选项。\n编辑一个域的XML配置：\n$ virsh edit domain 注意： 直接被QEMU启动的虚拟机不被libvirt管理。\n网络 这里是有关 libvirt 网络的一个正宗的概述。\n默认情况下，当 libvirtd 服务启动后，即创建了一个名为 default 的 NAT 网桥与外部网络联通（仅 IPv4）。对于其他的网络连接需求，可创建下列四种类型的网络以连接到虚拟机：\n bridge — 这是一个虚拟设备，它通过一个物理接口直接共享数据。使用场景为：宿主机有 静态 网络、不需与其它域连接、要占用全部进出流量，并且域运行于 系统 层级。有关如何在现有默认网桥时增加另一个网桥的方法，请参阅 网桥。网桥创建后，需要将它指定到相应客户机的 .xml 配置文件中。 network — 这是一个虚拟网络，它可以与其它虚拟机共用。使用场景为：宿主机有 动态 网络（例如：NetworkManager）或使用无线网络。 macvtap — 直接连接到宿主机的一个物理网络接口。 user — 本地网络，仅用于用户 会话。  绝大多数用户都可以通过 virsh 的各种可选项创建具有各种功能的网络，一般来说比通过 GUI 程序（像 virt-manager 之类）更容易做到。也可以按用 virt-install 新建域 所述实现。\n注意： libvirt 通过 dnsmasq 处理 DHCP 和 DNS 请求，以启动每个虚拟网络的不同实例。也会为特定的路由添加 iptables 规则并启用 ip_forward 内核参数。这也意味着宿主机上已运行的dnsmasq并不是libvirt所必须的（并可能干扰到libvirt的dnsmasq实例）。\nUEFI 支持 Libvirt 可以通过 qemu 和 OVMF 来支持 UEFI 虚拟机。 安装 ovmf 。 添加下面的内容到 /etc/libvirt/qemu.conf 。\n$ vim /etc/libvirt/qemu.conf nvram = [ \"/usr/share/ovmf/x64/OVMF_CODE.fd:/usr/share/ovmf/x64/OVMF_VARS.fd\" ] 重启 libvirtd\n现在你可以创建一个 UEFI 虚拟机了。 你可以通过 virt-manager 来创建。当你进行到向导的最后一步时：\n 勾选在安装前自定义配置，之后点击完成。 在概况屏幕, 将固件改为’UEFI x86_64'。 点击开始安装 在启动屏幕，你需要使用linuxefi命令来启动安装程序，并且你需要在系统中运行efibootmgr验证确实运行在UEFI模式下。  QEMU-KVM Win7 环境准备   安装QEMU：sudo apt install qemu-kvm\n  下载 Windows virtio driver iso：https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/archive-virtio/virtio-win-0.1.102/，因为要将磁盘挂接为 virtio 磁盘。\n需使用 virtio-win-0.1.102，我使用最新的 virtio-win-0.1.208.iso，Windows安装程序会提示驱动没有包含签名错误No signed device drivers were found. Make sure that the installation media contains the correct drivers, and then click OK\n  创建系统盘 qemu-img create -f qcow2 Windows7-VM.img 30G，这将作为Win7的操作系统盘。\n  创建启动脚本\n$ vi start_Windows7_VM.sh #!/bin/bash DISKIMG=$HOME/.vm/Windows7-VM.img exec qemu-system-x86_64 --enable-kvm \\  -cpu host,hv_relaxed,hv_spinlocks=0x1fff,hv_vapic,hv_time \\  -drive file=${DISKIMG},if=virtio \\  -net nic,model=virtio-net-pci -net user,smb=$HOME/Downloads \\  -m 4096 \\  -smp cores=2,threads=4 \\  -monitor stdio \\  -vga std \\  -audiodev pa,id=snd0 -device ich9-intel-hda -device hda-output,audiodev=snd0 \\  -usb -device usb-tablet \\  -rtc base=localtime,clock=host \\  -name 'Windows7 VM' \\  $@ $ chmod u+x start_Windows7_VM.sh   ./start_Windows7_VM.sh -boot d -cdrom $HOME/Downloads/cn_windows_7_ultimate_x64_dvd_x15-66043.iso -drive file=$HOME/Downloads/virtio-win-0.1.102.iso,index=3,media=cdrom\n  安装 Win 7  选择 Custom（advanced）  选择 CD Drive (E:) virtio-win  选择 viostor  安装 Win7 Virtio SCSI Driver  安装好以后，就可以看到安装的目标磁盘了  进入常规的 Win7 安装流程  安装 Virtio 网络驱动 但是安装失败：\n尝试 device manager 安装：\n[QEMU 的内置SMB服务器](#QEMU 的内置SMB服务器) 宿主机的USB设备传递至虚拟机 QEMU-KVM WinXP SP3 windows_xp.sh #!/bin/bash DISKIMG=$HOME/.vm/WindowsXP-VM.img exec qemu-system-x86_64 --enable-kvm \\  -cpu host,hv_relaxed,hv_spinlocks=0x1fff,hv_vapic,hv_time \\  -drive file=${DISKIMG} \\  -net nic,model=rtl8139 -net user,smb=$HOME/Downloads \\  -m 4096 \\  -cpu Nehalem \\  -rtc base=localtime,clock=host \\  -usb -device usb-tablet \\  -monitor stdio \\  -vga std \\  $@ Windows XP cannot connect to samba share You have ‘client min protocol = NT1’ set, there is another similar setting ‘server min protocol’ which from Samba 4.11.0 is set to SMBv2. Your XP is probably only using SMBv1, so it will not be able to see or connect to your Samba server.\nSo you have to edit the [global] section in the /etc/samba/smb.conf and add the server min protocol = NT1 option here. Then restart the Samba service.\n例如：\n$ ps h -C smbd -o pid,args 1707 /usr/sbin/smbd --foreground --no-process-group $ vim /tmp/qemu-smb.SL95F1/smb.conf [global] server min protocol = NT1 $ sudo smbcontrol 1707 reload-config 或者编写如下脚本\n#!/bin/bash echo \"[global] server min protocol = NT1\"  /tmp/**/smb.conf sudo smbcontrol $(ps h -C smbd -o pid) reload-config Windows XP 上网提示：您的时钟快了/慢了 此时，无论你怎么调整日期和时间，都不能解决上网问题。即使把日期从2020年调整到2015年，此时虽然不在提示 “您的时钟快了”，也有证书期限等异常。\n出现这种问题的原因，是因为 Windows XP 确实太老了，Google Chrome、Mozilla Firefox 及其内核的浏览器已经不支持了。\nVirtual Machine Manager 键盘不能输入的问题\n在 Display 中，设定 keymap，比如 en-us\n无网络\n在 NIC 中，将 Device model 设置为 rtl8139\nQEMU-KVM Gentoo Configuration Host To create a disk image for the virtual machine, run:\n$ qemu-img create -f qcow2 Gentoo-VM.img 30G Download a minimal Gentoo LiveCD from here.\nSince QEMU requires a lot of options, it would be a good idea to put them into a shell script, e.g.:\n$ vim start_Gentoo_VM.sh #!/bin/bash DISKIMG=$HOME/VirtualMachine/Gentoo-VM.img exec qemu-system-x86_64 -enable-kvm \\  -bios /usr/share/edk2-ovmf/OVMF_CODE.fd \\  -cpu host \\  -drive file=${DISKIMG},if=virtio \\  -netdev user,id=vmnic,hostname=Gentoo-VM,hostfwd=tcp::10022-:22 \\  -device virtio-net,netdev=vmnic \\  -device virtio-rng-pci \\  -m 4G \\  -smp 2 \\  -monitor stdio \\  -vga std \\  -audiodev pa,id=snd0 -device ich9-intel-hda -device hda-output,audiodev=snd0 \\  -name \"Gentoo VM\" \\  $@ $ chmod u+x start_Gentoo_VM.sh Change the path to your disk image Gentoo-VM.img in the script. You can add more options when calling the script. To boot the disk image, run:\n$ ./start_Gentoo_VM.sh -boot d -cdrom $HOME/Downloads/install-amd64-minimal-20211107T170547Z.iso Install the guest per the Gentoo Handbook. See the guest section for optimum support. After the installation start the script without the additional options.\nUsing UEFI with QEMU UEFI for x86 QEMU/KVM VMs is called OVMF (Open Virtual Machine Firmware). It comes from EDK2 (EFI Development Kit), which is the UEFI reference implementation.\n$ sudo apt-get install ovmf 检查是否安装，命令为：\n$ dpkg -L ovmf | grep OVMF.fd /usr/share/ovmf/ OVMF.fd /usr/share/qemu/ OVMF.fd 要在虚拟机中运行操作系统的映像文件，添加 -bios /usr/share/ovmf/OVMF.fd。该代码调用名为 OVMF.fd 的文件，该文件是 Qemu 的 UEFI 固件。\n$ qemu-system-x86_64 -bios /usr/share/ovmf/OVMF.fd -cdrom ubuntu-21.04-desktop-amd64.iso 这个名为ovmf的包其实就是名为TianoCore的程序。该名称本身代表开放虚拟机固件)。\n“BdsDxe: failed to load Boot0001”\nsolution: Try hitting F2 to enter the OVMF settings during guest boot and manually pick a new boot drive option.\nOthers 通过 Qemu 安装 Windows 到硬盘 双系统新思路。今天装windows, 在linux上先用虚拟机，把硬盘直通进去，在raw盘上装好，然后更新grub, 再重启就可以直接接进去了。\n这样可以避免装机还要做启动盘，装机过程中的重启也可以避免了。\nwin的安装过程中驱动都是按照虚拟机的配置安装的，但是win10是自动装驱动的，重启进去后过了一会显卡驱动自动都装好了。\nLooking Glass Looking Glass 讓 Linux 可完美玩 Windows 遊戲 超低延遲不掉格\n當用戶安裝了虛擬電腦（VM）實行 Windows，並執行遊戲時，它採用的 KVM frame relay 技術可將 Windows 顯示記憶體，透過 PCI pass-through 直接由 Windows VM 被配置的顯示卡，複製到 Linux 被配置的顯示卡，這樣 Linux 便可在極為低延遲的情況下，接近完美顯示 Windows 遊戲的內容。\n簡單來說，就是一部 Linux 電腦裡面裝有虛擬電腦運行的 Windows，Windows 遊戲實行時，在被配置的顯示卡記憶體資料，在主機板 PCI 通道直接複製到 Linux 被配置的顯示卡。即是說 Windows 遊戲原本畫面，可高速反映到 Liunx 的虛擬電腦軟件上。這樣 Linux 用戶就算不 Dual boot 或使用兩個熒幕，在 Linux 上都可得到接近相同的打機體驗。\nxrdp xrdp 使用 RDP（Microsoft 远程桌面协议）为远程计算机提供图形登录。xrdp 接受来自各种 RDP 客户端的连接：FreeRDP、rdesktop、NeutrinoRDP 和 Microsoft 远程桌面客户端（适用于 Windows、macOS、iOS 和 Android）。\n正如 Windows 到 Windows 远程桌面一样，xrdp 不仅支持图形远程处理，还支持\n 双向剪贴板传输（文本、位图、文件） 音频重定向 驱动器重定向（在远程机器上安装本地客户端驱动器）  RDP 传输默认使用 TLS 加密。\nQEMU/KVM VS Virtualbox Linux 系统上的虚拟化解决方案 – KVM 和 VirtualBox\nKVM 提供了一些 VirtualBox 没有的功能，反之亦然。IT 世界中没有通用工具，因此使用适合您需求的工具非常重要。基本思想是：如果你想安装二进制 Linux 发行版作为来宾，使用 KVM。它速度更快，并且它的驱动程序包含在官方内核树中。如果您的客户涉及大量编译并且需要一些更高级的功能，并且/或者不是 Linux 系统，那么最好使用 VirtualBox。\n技术原因很简单：KVM 更好地与 Linux 集成，它更小更快，虽然你可以在 Linux 以外的其他客户机上使用它，但我们发现体验相当麻烦：BSD 的 I/O 和 Solaris 往往很慢（确切地说，是 OpenIndiana）在引导安装 ISO 后会立即出现恐慌。由于我们使用当前版本的 BSD（并且经常从源代码编译/更新系统）并且还需要 Solaris，我们发现 VirtualBox 是一个更好的选择。Oracle VirtualBox 的另一个优点是它支持挂起，即您可以将机器状态保存在主机的硬盘上并关闭 VirtualBox，当（重新)启动时，系统将从它离开的地方恢复。这就是为什么我们提到源代码编译：如果你有一台嘈杂的机器，你不想一夜之间离开，但你的 Gentoo 虚拟机只是编译一个新的 gcc 版本，暂停机器状态，关闭主机，明天继续。\n桌面虚拟化、KVM 还是 Virtualbox？\n这两者中的哪一个更适合在 Linux 台式机/笔记本电脑上运行 Windows 10 虚拟机？\n  带有virt-manager 的QEMU/KVM应该可以与 Virtualbox 媲美。\nVirtualbox 没问题，特别是如果跨主机操作系统使用相同的虚拟化很重要，但 QEMU/KVM 是更好的投资。QEMU/HAXM 也应该可以在 Mac 和 Windows 上运行，尽管它目前还不够成熟。\n  KVM, obviously. You’re probably going to need to learn how to manage it, but it is a much better system and allows abstraction on completely unexposed CPU hardware so you can easily take your image and put it onto another KVM. Windows doesn’t like to have it’s CPUs exchange on it very often.\n  KVM 与 VirtualBox\n  表现\n这是要考虑的最重要的领域之一，即管理程序的性能将如何影响您的基础架构。KVM 是 1 类管理程序（这些虚拟机管理程序直接运行在宿主机的硬件上来控制硬件和管理客操作系统），而 VirtualBox 是 2 类管理程序（这些虚拟机管理程序运行在传统的操作系统上，就像其他计算机程序那样运行），这意味着 KVM 应该优于 VirtualBox。\n根据SPECvirt_sc2013 基准测试，VirtualBox 通常比 KVM 需要更多时间来创建和启动服务器，而 KVM 以接近本机的速度运行应用程序，比其他行业管理程序更快。尽管对于典型负载，差异可能微不足道。\n  管理程序管理\n这两个给定的应用程序都可以通过 GUI 进行管理。Virtualbox 相对来说有更好的 GUI，但 KVM 的当前 GUI 使其管理比以往任何时候都更容易。”\n如果您更喜欢命令行，那么 KVM 中有各种命令行选项。Virtualbox 也提供了一个命令行界面，但它不如 KVM virsh 全面。您不能直接从 bash 启动 Virtualbox VM。\n  可扩展性\nKVM 继承了 Linux 的性能，如果来宾机器和请求的数量增加，可以扩展以匹配需求负载。KVM 允许对要求最苛刻的应用程序工作负载进行虚拟化，并且是许多企业虚拟化设置的基础，例如数据中心和私有云。\nVirtualBox 可以为每个 VM 提供多达 32 个虚拟 CPU，而不管主机上物理存在多少 CPU 内核。还可以为具有多达 1024 个 CPU 的主机提供支持。\n  安全\nKVM 提供增强的安全性，因为它结合使用 SELinux 和安全虚拟化 (sVirt)。VirtualBox 可以执行虚拟机的安全实时迁移和磁盘映像加密。它还包括远程桌面协议 (RDP) 身份验证和用于创建进一步身份验证要求以帮助提高安全性的 SDK。您可以在此页面上看到 Virtualbox 的安全功能列表。\n  成本和定价\nKVM 是一个开源的免费平台，由 Red Hat 等供应商提供有偿支持。虽然 Virtualbox 在限制范围内是免费的。一旦您超过一定的使用水平，您必须获得产品许可。\n  支持\n对于 KVM，您需要依赖开源社区和您自己的 IT 组织或受支持的供应商（如红帽）的支持。Oracle 正在积极开发 Virtualbox，您可以从他们那里获得任何支持。\n  VirtualBox 执行 .vbs 文件\n$ cscript test.vbs 删除备份\n删除虚拟机备份，当前状态前一个备份删除得快，两个备份之间的备份删除得慢。\n共享文件夹\n固定分配的共享文件夹对于定义共享文件夹的虚拟机是永久存在的；\n临时分配的共享文件夹在虚拟机运行时添加/删除，虚拟机关闭后消失。\n把img系统镜像转为VDI或VMDK格式文件\n$ VBoxManage convertdd *.img *.vdi 在 virtualbox 新建虚拟机时指定 vdi 硬盘文件，就可以安装系统\n增加现有虚拟机的磁盘大小 下面是你迟早会遇到的情况。\n你在 VirtualBox 中安装了一个或多个操作系统。在创建这些虚拟操作系统的同时，你还在 VirtualBox 中为它们创建了虚拟硬盘。\n你指定了虚拟磁盘的最大大小，比如说 15 或 20GB，但现在使用了一段时间后，你发现你的虚拟机已经没有空间了。\n虽然在 Ubuntu 和其他操作系统上有释放磁盘空间的方法，但更稳健的处理方式是增加 VirtualBox 中创建的虚拟机的磁盘大小。\n是的，你可以在 VirtualBox 中扩大虚拟硬盘，即使在创建之后也可以。虽然这是一个安全且经过测试的过程，但我们强烈建议你在执行这样的操作之前，先创建一个虚拟机的备份。\n我将向你展示如何在 VirtualBox 中以图形和命令行（对于 Linux 极客）方式调整磁盘大小。这两种方法都很简单直接。\n方法 1：在 VirtualBox 中使用虚拟媒体管理器\nVirtualBox 6 增加了一个调整虚拟磁盘大小的图形化选项。你可以在 VirtualBox 主页的文件选项卡中找到它。\n进入 “File - Virtual Media Manager”：\n在列表中选择一个虚拟机，然后使用 “Size” 滑块或输入你需要的大小值。完成后点击 “Apply”。\n请记住，虽然你增加了虚拟磁盘的大小，但如果你的空间是动态分配的，那么实际的分区大小仍然不变。\n方法 2：使用 Linux 命令行增加 VirtualBox 磁盘空间\n如果你使用 Linux 操作系统作为宿主机，在宿主机中打开终端并输入以下命令来调整 VDI 的大小：\nVBoxManage modifymedium \"/path_to_vdi_file\" --resize  在你按下回车执行命令后，调整大小的过程应该马上结束。\n 注意事项\nVirtualBox 早期版本命令中的 *modifyvdi 和 modifyhd 命令也支持，并在内部映射到 modifymedium 命令。\n 如果你不确定虚拟机的保存位置，可以在 VirtualBox 主页面点击 “Files - Preferences” 或使用键盘快捷键 Ctrl+G 找到默认位置。\nSeamless Mode 虚拟机通常在一个窗口中运行来宾操作系统及其程序。但是，VirtualBox和VMware都有一些功能，允许您在主机桌面上运行虚拟化程序，从而将它们从监狱中释放出来。…\n这意味着您可以在不使用虚拟机窗口和来宾操作系统桌面的情况下使用程序。如果使用多个监视器，甚至可以将虚拟机中的不同窗口放置在不同的监视器上。\n工作原理\n所有这些特性都同样工作。启动虚拟机，启动您想要使用的程序，然后启用“无缝模式”或“统一模式”。来宾操作系统的桌面和虚拟机窗口将消失，将来宾操作系统的窗口留在桌面上。它们看起来正在运行，好像它们在您的主机操作系统上运行，但虚拟机仍在后台运行。程序仍然是沙盒，因此它们无法访问主机操作系统的文件——它们似乎正在主机操作系统上运行。\n无论您使用的是Windows、Linux还是Mac，这些技巧都有效。您可以在Linux桌面上无缝运行Windows程序，也可以在Windows桌面上运行Linux软件。\n使用virtualbox的无缝模式\n请注意，VirtualBox只允许您在Windows、Linux和Solaris客户机上使用此功能。如果你设法让MacOSX在VirtualBox虚拟机上运行，或者你正在使用像俳句这样的小众操作系统，你将无法使用这个功能。\n在使用此功能之前，必须在要使用的来宾虚拟机内安装VirtualBox来宾添加软件包。如果您还没有这样做，请启动虚拟机，单击“设备”菜单，然后选择“安装来宾添加”。系统将提示您安装软件。\n要使用此功能，请同时按“主机键”（通常是右Ctrl键，但它显示在虚拟机窗口的右下角）和“L”。也可以单击“视图”菜单，然后选择“切换到无缝模式”。\nVirtualBox将隐藏来宾操作系统的桌面背景，使其看起来好像来宾操作系统的程序正在主机操作系统的桌面上运行。但是，正在运行的应用程序不会出现在操作系统的标准任务栏上。\n要退出无缝模式，只需按主机键，然后再次按L。您还可以在任务栏上方找到VirtualBox菜单，您可以将鼠标悬停在上面查看。单击查看并再次选择切换到无缝模式以禁用无缝模式。\n使用vmware的unity模式\nVMware有一个类似的功能，名为Unity mode。它可以在免费的VMware Player、VMware Workstation和VMware的其他付费应用程序上使用。与VirtualBox一样，VMware的Unity模式适用于Windows和Linux客户机。\nVBox+WinXP SP3 Windows XP; Guest Additions installation stuck; Virtualbox 6.1.18\nDisconnect network. It helps me.\nvs VMWare 工具是用来解决问题的，没必要看到开源就意识形态附体\npiix4_smbus Host SMBus controller not enabled\n从内核的说明文档来看，这个 piix4 实际上是 Intel 82371AB 南桥芯片，多功能总线控制器，而在 VMware 里面并没有这个真实的芯片组，但在启动时最会尝试载入这个驱动模块，所以会报错，但对系统没有任何影响。\n虚拟机网络模式 桥接\n桥接网络是指本地物理网卡和虚拟网卡通过VMnet0虚拟交换机进行桥接，物理网卡和虚拟网卡在拓扑图上处于同等地位，那么物理网卡和虚拟网卡就相当于处于同一个网段，虚拟交换机就相当于一台现实网络中的交换机,所以两个网卡的IP地址也要设置为同一网段。\n所以当我们要在局域网使用虚拟机，对局域网其他pc提供服务时，例如提供ftp，提供ssh，提供http服务，那么就要选择桥接模式。\n例如大学宿舍里有一个路由器，宿舍里四个人连接这个路由器，路由器的wanip就不理会了，这个ip是动态获取的，而lanip默认是192.168.1.1,子网掩码是255.255.255.0。而其他四个人是自动获取ip，假设四个人的ip是:\nA:192.168.1.100/255.255.255.0,\nB:192.168.1.101/255.255.255.0\nC:192.168.1.102/255.255.255.0\nD:192.168.1.103/255.255.255.0\n那么虚拟机的ip可以设置的ip地址是192.168.1.2-192.168.1.99,192.168.1.104-192.168.1.254 (即网络地址全0和全1的除外，再除去ABCD四个人的ip地址)\n那么虚拟机的ip地址可以设置为192.168.1.98/255.255.255.0，设置了这个ip地址，ABCD这四个人就可以通过192.168.1.98访问虚拟机了，如果虚拟机需要上外网，那么还需要配置虚拟机的路由地址，就是192.168.1.1了，这样，虚拟机就可以上外网了，但是，上网我们一般是通过域名去访问外网的，所以我们还需要为虚拟机配置一个dns服务器，我们可以简单点，把dns服务器地址配置为google的dns服务器:8.8.8.8,到此，虚拟机就可以上网了。\nNAT\nNAT模式中，就是让虚拟机借助NAT(网络地址转换)功能，通过宿主机器所在的网络来访问公网。\nNAT模式中，虚拟机的网卡和物理网卡的网络，不在同一个网络，虚拟机的网卡，是在vmware提供的一个虚拟网络。\nNAT和桥接的比较:\n NAT模式和桥接模式虚拟机都可以上外网。 由于NAT的网络在vmware提供的一个虚拟网络里，所以局域网其他主机是无法访问虚拟机的，而宿主机可以访问虚拟机，虚拟机可以访问局域网的所有主机，因为真实的局域网相对于NAT的虚拟网络，就是NAT的虚拟网络的外网。 桥接模式下，多个虚拟机之间可以互相访问；NAT模式下，多个虚拟机之间也可以相互访问。  如果你建一个虚拟机，只是给自己用，不需要给局域网其他人用，那么可以选择NAT，毕竟NAT模式下的虚拟系统的TCP/IP配置信息是由VMnet8(NAT)虚拟网络的DHCP服务器提供的，只要虚拟机的网路配置是DHCP，那么你不需要进行任何其他的配置，只需要宿主机器能访问互联网即可，就可以让虚拟机联网了。\n例如你想建多个虚拟机集群，作为测试使用，而宿主机可能是一个笔记本，ip不固定。这种应用场景，我们需要采用nat模式了，但是我们要考虑一个问题，虚拟机之间是需要互访的，默认采用dhcp，虚拟机的ip每次重启，ip都是不固定的，所以我们需要手工设置虚拟机的ip地址。\nHost-Only\n在Host-Only模式下，虚拟网络是一个全封闭的网络，它唯一能够访问的就是主机。其实Host-Only网络和NAT网络很相似，不同的地方就是Host-Only网络没有NAT服务，所以虚拟网络不能连接到Internet。主机和虚拟机之间的通信是通过VMware Network Adepter VMnet1虚拟网卡来实现的。\nHost-Only的宗旨就是建立一个与外界隔绝的内部网络，来提高内网的安全性。这个功能或许对普通用户来说没有多大意义，但大型服务商会常常利用这个功能。\npodman Podman: A tool for managing OCI containers and pods.\nAndroid-x86 android x86 是一个自由而开源的项目，将谷歌制作的安卓系统从 ARM 架构移植到了 x86 架构，可以让用户在他们的桌面电脑上运行安卓系统来享受所有的安卓功能和应用程序及游戏。\n首次启动运行该安卓系统，运行：\n$ qemu-img create -f qcow2 Android8-VM.img 30G $ gedit start_Android8_VM.sh #!/bin/bash DISKIMG=/media/kurome/Ventoy/QemuKVM/Android8-VM.img exec qemu-system-x86_64 --enable-kvm \\  -hda ${DISKIMG} \\  -net nic -net user \\  -m 4096 \\  -smp cores=2,threads=4 \\  -monitor stdio \\  -vga std \\  -soundhw es1370 \\  -usb -device usb-tablet \\  -name 'Andriod8 VM' \\  $@ $ chmod u+x start_Android8_VM.sh $ ./start_Android8_VM.sh -boot d -cdrom ~/Downloads/android-x86_64-9.0-r2.iso 在，安卓系统已经完全安装在你的 android.img 文件中，你应该使用下面的 QEMU 命令来启动它，而不是前面的命令：\n$ ./start_Android8_VM.sh Anbox Anbox 简介 Anbox 是 “Android in a box” 的缩写。Anbox 是一个基于容器的方法，可以在普通的 GNU/Linux 系统上启动完整的 Android 系统。\nAnbox 可以让你在 Linux 系统上运行 Android，而没有虚拟化的迟钝，因为核心的 Android 操作系统已经使用 Linux 命名空间（LXE）放置到容器中了。\nAndroid 容器不能直接访问到任何硬件，所有硬件的访问都是通过在主机上的守护进程进行的。\n每个应用程序将在一个单独窗口打开，就像其它本地系统应用程序一样，并且它可以显示在启动器中。\n安装使用 Anbox 也可作为 snap 软件包安装，请确保你已经在你的系统上启用了 snap 支持。\n为使 Anbox 工作，确保需要的内核模块已经安装在你的系统中。对于基于 Ubuntu 的用户，使用下面的 PPA 来安装它。\n$ sudo add-apt-repository ppa:morphis/anbox-support $ sudo apt update $ sudo apt install linux-headers-generic anbox-modules-dkms 在你安装 anbox-modules-dkms 软件包后，你必须手动重新加载内核模块，或需要系统重新启动。\n$ sudo modprobe ashmem_linux $ sudo modprobe binder_linux 安装 anbox。\n$ sudo apt install anbox 如果你已经在你的系统上安装 snap，其它的步骤可以忽略。\n$ sudo snap install --devmode --beta anbox 默认情况下，Anbox 并没有带有 Google Play Store。因此，我们需要手动下载每个应用程序（APK），并使用 Android 调试桥（ADB）安装它。\n$ sudo apt install android-tools-adb 既然我们不能使用 Play Store ，你就得从信得过的网站来下载 APK 软件包，像 APKMirror ，然后手动安装它。\n首先，你需要启动 ADB 服务。为做到这样，运行下面的命令。\n$ adb devices 安装语法格式：\n$ adb install Name-Of-Your-Application.apk Waydroid Waydroid是一个基于lxc容器技术，用以启动完整安卓系统的方案。\nGenymotion Android Virtual Devices for all your development \u0026 testing needs\nLooking Glass An extremely low latency KVMFR (KVM FrameRelay) implementation for guests with VGA PCI Passthrough.\nLibVF.IO Commodity GPU Multiplexing Driven By VFIO \u0026 YAML.\nOSX-KVM/macOS-Simple-KVM macOS VM in QEMU\nquickemu Quickly create and run optimised Windows, macOS and Linux desktop virtual machines.\nPackage Management dpkg 管理软件包 dpkg 意即 Debian 包管理器（Debian PacKaGe manager）。dpkg 是一个可以安装、构建、删除及管理 Debian 软件包的命令行工具。\n其它的一些工具如 dpkg-deb 和 dpkg-query 等使用 dpkg 作为执行某些操作的前端。\n现在大多数系统管理员使用 Apt、Apt-Get 及 Aptitude 等工具，不用费心就可以轻松地管理软件。\n尽管如此，必要的时候还是需要用 dpkg 来安装某些软件。\n常见命令及文件位置 dpkg 命令的语法:\n$ dpkg [ ...]  dpkg 相关文件的位置在 /var/lib/dpkg\n/var/lib/dpkg/status 包含了被 dpkg 命令（install、remove 等）所修改的包的信息\n/var/lib/dpkg/status 包含了可用包的列表\n安装/升级软件 在基于 Debian 的系统里，用以下命令来安装 .deb 软件包。要是已经安装了软件包，就会升级它。\n$ sudo dpkg -i package.deb 从文件夹里安装软件 在基于 Debian 的系统里，用下列命令从目录中逐个安装软件。这会安装 /opt/software 目录下的所有以 .deb 为后缀的软件。\n$ sudo dpkg -iR /opt/software 显示已安装软件列表 以下命令可以列出 Debian 系的系统中所有已安装的软件，同时会显示软件版本和描述信息。\n$ dpkg -l 查看指定的已安装软件 用以下命令列出指定的一个已安装软件，同时会显示软件版本和描述信息。\n$ dpkg -l package 查看软件安装目录 以下命令可以在基于 Debian 的系统上查看软件的安装路径。\n$ dpkg -L package 查看 deb 包内容 下列命令可以查看 deb 包内容。它会显示 .deb 包中的一系列文件。\n$ dpkg -c package.deb 显示软件的详细信息 以下命令可以显示软件的详细信息，如软件名、软件类别、版本、维护者、软件架构、依赖的软件、软件描述等等。\n$ dpkg -s package 查看文件属于哪个软件 用以下命令来查看文件属于哪个软件。\n$ dpkg -S /path/file 移除/删除软件 以下命令可以用来移除/删除一个已经安装的软件，但不删除配置文件。\n$ sudo dpkg -r package 清除软件 以下命令可以用来移除/删除包括配置文件在内的所有文件。\n$ sudo dpkg -P package Debian 打包入门 deb包本身有三部分组成：\n注：原文写的不是很好，具体学习还是看官方的 Debian 新维护者手册\nCardbook 是用于管理基于 CardDav 和 vCard 标准的联系人的Thunderbird扩展。\n使用 dh_make 在当前目录下创建一个 debian 目录。\n$ dh_make\\  --native \\  --single \\  --packagename cardbook_1.0.0 \\  --email minkush@example.com 一些重要的文件，比如 control、rules、changelog、copyright 等文件被初始化其中。所创建的文件的完整列表如下：\n$ find debian debian debian/manpage.sgml.ex debian/cardbook.doc-base.EX debian/changelog debian/control debian/postrm.ex debian/postinst.ex debian/source debian/source/format debian/README.Debian debian/manpage.1.ex debian/salsa-ci.yml.ex debian/rules debian/cardbook.cron.d.ex debian/README.source debian/preinst.ex debian/prerm.ex debian/copyright debian/cardbook-docs.docs debian/README debian/manpage.xml.ex 在当前目录执行 dpkg-buildpackage -us -uc -ui 将会在上层目录创建一个空的包文件以及四个名为 .changes、.deb、 .dsc、 .tar.gz 的文件。\n .dsc 文件包含了所发生的修改和签名 .deb 文件是用于安装的主要包文件。 .tar.gz （tarball）包含了源代码。  这个过程也在 debian/cardbook/usr/share/doc/cardbook 目录下创建了 README 和 changelog 文件。它们包含了关于这个包的基本信息比如描述、作者、版本。\n检查这个包安装的内容：\n$ dpkg -c cardbook_1.0.0_amd64.deb /usr /usr/share /usr/share/doc /usr/share/doc/cardbook /usr/share/doc/cardbook/README.Debian /usr/share/doc/cardbook/changelog.gz /usr/share/doc/cardbook/copyright build-essential 在 Ubuntu 中安装构建基础包（build-essential），只需要在终端中简单输入这个命令：\n$ sudo apt update \u0026\u0026 sudo apt install build-essential 构建基础包（build-essential）实际上是属于 Debian 的。在它里面其实并不是一个软件。它包含了创建一个 Debian 包（.deb）所需的软件包列表。这些软件包包括 libc、gcc、g++、make、dpkg-dev 等。构建基础包包含这些所需的软件包作为依赖，所以当你安装它时，你只需一个命令就能安装所有这些软件包。\n请不要认为构建基础包是一个可以在一个命令中神奇地安装从 Ruby 到 Go 的所有开发工具的超级软件包。它包含一些开发工具，但不是全部。\nPackage converter  alien：Alien is really designed to be used to convert from alien file formats to the packaging format used by the distribution you run it on. gentoo-zh：gentoo 本质是通过 bash 安装软件，因此，可以参考此仓库尝试手动安装软件。  Is linux binary universal to all kinds of distributions?\nThis is two questions:\nIs a Linux binary universal to all distributions?\nIt depends:\n If the program is using nothing outside the Linux kernel, it will be universal except for the 32- or 64-bit question. A Linux “hello world” (a minimalistic program that just prints “hello world” to a terminal window) could probably be independent of the distribution. If the program is using any non-kernel library or service (which is most of Linux, the kernel is fairly small), there are differences in which libraries are included, which versions these libraries are and where they are located. So in this (most common) case distributions are not equal.  Why do many commercial programs say that they only work on one or a few distributions?\nBecause there is a very large number of Linux distributions, and nobody wants to test their program on all of them.\nA commercial vendor will normally say that they support only the distributions they have tested their software on. It may or may not work on other distributions, from the vendor’s perspective the point is just that you can’t complain if it does not work on a distribution they don’t support.\nWhich distributions are selected for testing depends on what the vendor expects their customers to be using. Commercial/professional programs commonly pick enterprise distributions, possibly through a reasoning similar to “people who paid for their OS are more likely to pay for our software”, possibly simply by counting the distributions used by their existing customers.\nSee also Mark Shuttleworth (the guy that is the reason we have an Ubuntu in the first place) on [binary compatibility between Ubuntu and Debian](https://wiki.ubuntu.com/MarkShuttleworth#What about binary compatibility) - Debian is the closest distribution relative of Ubuntu.\nAPT Debian 使用一套名为 Advanced Packaging Tool（APT）的工具来管理包系统。在基于 Debian 的 Linux 发行版中，有各种工具可以与 APT 进行交互，以方便用户安装、删除和管理的软件包。apt-get 便是其中一款广受欢迎的命令行工具，但是最常用的命令都被分散在了 apt-get、apt-cache 和 apt-config 这三条命令当中，apt 命令的引入就是为了解决命令过于分散的问题。（简单来说就是：apt = apt-get、apt-cache 和 apt-config 中最常用命令选项的集合）\n   apt 命令 取代的命令 命令的功能     apt install apt-get install 安装软件包   apt remove apt-get remove 移除软件包   apt purge apt-get purge 移除软件包及配置文件   apt update apt-get update 刷新存储库索引   apt upgrade apt-get upgrade 升级所有可升级的软件包   apt autoremove apt-get autoremove 自动删除不需要的包   apt full-upgrade apt-get dist-upgrade 在升级软件包时自动处理依赖关系   apt search apt-cache search 搜索应用程序   apt show apt-cache show 显示装细节   apt list  列出包含条件的包（已安装，可升级等）   apt edit-sources  编辑源列表    列出所有手动安装软件 $ apt-mark showmanual 查看软件包依赖 当你在 Linux 中安装一个软件包，有时这个软件包还需要其他的软件包来使它工作正常。这些额外的软件包就叫作这个包的依赖。假如这些软件包之前没有在系统中被安装，那么这些依赖在安装这个软件包的同时会被自动安装上。\n使用 apt show 来查看依赖\n你可以使用 apt show 命令 来展示一个包的详细信息。其中依赖信息就是其中一部分，你可以在以 “Depends” 打头的那些行中看到它们。\n例如，下面展示的是使用 apt show 展示 ubuntu-restricted-extras 这个包的详细信息：\n$ apt show ubuntu-restricted-extras Package: ubuntu-restricted-extras Version: 67 ... Depends: ubuntu-restricted-addons Recommends: libavcodec-extra, ttf-mscorefonts-installer, unrar ... 如你所见，ubuntu-restricted-extras 包依赖于 ubuntu-restricted-addons 这个软件包。\n但你得小心的是依赖包还可能依赖于其他包，这样一直循环往复直到尽头。但幸好 APT 包管理器可以为你处理这些复杂的依赖关系，自动地安装所有的依赖（大多数情况下）。\n什么是推荐包？\n你注意到了上面结果输出中以 “Recommends” 开头的那些行了吗？\n推荐包不是软件包的直接依赖，但它们可以开启软件包的一些额外功能。\n正如你上面看到的那样， ubuntu-restricted-extras 包有 ttf-mscorefonts-installer 这个推荐包，用来在 Ubuntu 上安装 Microsoft 的字体。\n这些推荐包也会默认被一同安装上，假如你想显式地禁止这些推荐包的安装，你可以像下面这样使用 –-no-install-recommends 选项。\n$ sudo apt install --no-install-recommends package_name 使用 apt-cache 来直接获取依赖信息\n上面通过 apt show 的方式会获取到大量信息，假如你想在脚本中获取到依赖信息，那么 apt-cache 命令将会给你一个更好且更简洁的输出结果。\n$ apt-cache depends package_name 使用 dpkg 来查看一个 DEB 文件的依赖\napt 和 apt-cache 都作用于软件仓库中的软件包，但假如你下载了一个 DEB 文件，那么这两个命令就不起作用了。\n在这种情形下，你可以使用 dpkg 命令的 -I 或 --info 选项。\n$ dpkg -I path_to_deb_file 依赖信息就可以在以 “Depends” 开头的那些行中找到。\n使用 apt-rdepends 来查看依赖及依赖的依赖\n假如你想查看更多关于依赖的信息，那么你可以使用 apt-rdepends 工具。这个工具可以创建完整的依赖树。这样你就可以得到一个软件包的依赖以及这些依赖的依赖。\n它不是一个常规的 apt 命令，所以你需要从 universe 软件仓库中安装上它：\n$ sudo apt install apt-rdepends 这个命令的输出通常很多，取决于依赖树的大小。\neading package lists... Done Building dependency tree Reading state information... Done shutter Depends: procps Depends: xdg-utils imagemagick Depends: imagemagick-6.q16 (= 8:6.9.2.10+dfsg-2~) imagemagick-6.q16 Depends: hicolor-icon-theme Depends: libc6 (= 2.4) Depends: libmagickcore-6.q16-6 (= 8:6.9.10.2) Depends: libmagickwand-6.q16-6 (= 8:6.9.10.2) hicolor-icon-theme libc6 Depends: libcrypt1 (= 1:4.4.10-10ubuntu4) Depends: libgcc-s1 libcrypt1 Depends: libc6 (= 2.25) apt-rdepends 工具的功能非常多样，它还可以用来计算反向依赖。这意味着你可以查看某个特定的包被哪些软件包依赖。\n$ apt-rdepends -r package_name 输出可能会非常多，因为它将打印出反向依赖树。\n$ apt-rdepends -r ffmpeg Reading package lists... Done Building dependency tree Reading state information... Done ffmpeg Reverse Depends: ardour-video-timeline (= 1:5.12.0-3ubuntu4) Reverse Depends: deepin-screen-recorder (5.0.0-1build2) Reverse Depends: devede (4.15.0-2) Reverse Depends: dvd-slideshow (0.8.6.1-1) Reverse Depends: green-recorder (= 3.2.3) Repository Mirror Select the fastest mirror\nYou can use deb mirror to have the best mirror picked for you automatically.\napt-get now supports a ‘mirror’ method that will automatically select a good mirror based on your location. Putting:\ndeb mirror://mirrors.ubuntu.com/mirrors.txt precise main restricted universe multiverse deb mirror://mirrors.ubuntu.com/mirrors.txt precise-updates main restricted universe multiverse deb mirror://mirrors.ubuntu.com/mirrors.txt precise-backports main restricted universe multiverse deb mirror://mirrors.ubuntu.com/mirrors.txt precise-security main restricted universe multiverse on the top in your /etc/apt/sources.list file should be all that is needed to make it automatically pick a mirror for you based on your geographical location.\nThe command line way\nThere are many command line tools available to find the best APT mirrors based on download speed. I have tested the following tools and they are working just fine in my Ubuntu 20.04 LTS desktop.\n Apt-select Apt-smart  apt-fast apt-fast: A shellscript wrapper for apt that speeds up downloading of packages.\n$ sudo apt-get install aria2 $ sudo add-apt-repository ppa:apt-fast/stable $ sudo apt-get update $ sudo apt-get -y install apt-fast $ sudo nano /etc/apt-fast.conf MIRRORS=('https://mirrors.bfsu.edu.cn/ubuntu/,https://mirrors.tuna.tsinghua.edu.cn/ubuntu/') apt-aria2 #!/bin/bash  ## apt-aria2: To help download packages faster via aria2, instead of wget. ## Author: Anjishnu Sarkar ## Version: 0.5 ## Acknowledgement: This script is a rewrite of the apt-fast script by ## Matt Parnell (admin@mattparnell.com) (http://www.mattparnell.com) ## Usage: Same as apt-get. Using the option \"-y\" always. ## BUG: ## *) If this script is interuppted, then next time aria2 starts downloading ## the same from the begining. Can be solved - something to do with .st file. ## TODO: ## *) Start installing via apt-get as soon as first package is downloaded ## and also keep downloading at the same time. This however might lead ## to dependencies not being satisfied. ## Initialization(s): Download=\"False\" Install=\"True\" Confirm=\"True\" UniqueName=\"$RANDOM\" Options=\"$@\" ## Checking for commands which requires download while test -n \"${1}\" do case \"${1}\" in install|upgrade|dist-upgrade|source|build-dep) ## Download Download=\"True\" ;; update|remove|autoremove|purge|dselect-upgrade|clean|autoclean|check) ## Anything other than download Download=\"False\" ;; -d) ## Download only (don't install) Install=\"False\" ;; -y) ## No need to ask for confirmation Confirm=\"False\" ;; *) ## Nothing to be done. If any wrong options/commands are given then ## let apt-get handle it. ;; esac shift done ## In case download is true if [ \"$Download\" == \"True\" ];then ## Installing pre-requisite(s): aria2 if ! which aria2c  /dev/null; then echo \"Aria2 not installed. Installing aria2 first via apt-get\" apt-get -y --force-yes install aria2 fi ArchiveDir=/var/cache/apt/archives/ cd ${ArchiveDir}/partial PrintUris=$(apt-get --yes --print-uris ${Options}) if [ $? -ne 0 ];then echo \"Aborting.\" exit 1 fi PackageInfo=$(echo \"$PrintUris\" | awk '/Reading package/,/After this operation/') # echo \"$PrintUris\" | grep ^\\' | cut -d\\' -f2  \"$UniqueName\"-uris.txt echo \"$PrintUris\" | grep \"http:\" | cut -d\\' -f2  \"$UniqueName\"-uris.txt NumberOfPackages=$(wc -l \"$UniqueName\"-uris.txt | awk '{print $1}') ## Print info echo \"$PackageInfo\" echo \"Number of packages to be downloaded: $NumberOfPackages\" ## Check whether package has already been installed or not InstallUpgradeMsg=$(echo \"$PackageInfo\" | grep \\  -e \"The following NEW packages will be installed:\" \\  -e \"The following packages will be upgraded:\") if [ -z \"$InstallUpgradeMsg\" ];then rm -f \"$UniqueName\"-uris.txt exit 0 fi ## In $InstallUpgradeMsg is not null, then proceed... ## If confirm is true if [ \"$Confirm\" == \"True\" ];then echo -n \"Do you want to continue [y|n]? \" read Ans case \"$Ans\" in y|yes|\"\") ;; n|no|*) echo \"Abort.\" rm -f \"$UniqueName\"-uris.txt exit 1 ;; esac fi if [ $NumberOfPackages -ne 0 ];then ## Downloading the packages echo \"Proceeding with downloading ...\" while read DebUrl do DebName=$(basename \"$DebUrl\") echo \"$DebName\" AptConf=\"/etc/apt/apt.conf\" if [ -f \"$AptConf\" ];then http_proxy=$(grep -i \"http::proxy\" \"$AptConf\" | cut -d \\\" -f2) fi if [ -n \"$http_proxy\" ];then echo \"Using proxy...\" aria2c -c -s 10 -j 10 --http-proxy=$http_proxy \"$DebUrl\" else echo \"Not using proxy...\" aria2c -c -s 10 -j 10 \"$DebUrl\" fi if [ $? -eq 0 ];then mv $DebName ${ArchiveDir} fi done \"$UniqueName\"-uris.txt fi rm -f \"$UniqueName\"-uris.txt # echo \"Installing...\" if [ \"$Install\" == \"True\" ];then apt-get -y --force-yes ${Options} fi else ## Cases when download is false apt-get ${Options} fi PPA 软件仓库是一组文件，其中包含各种软件及其版本的信息，以及校验和等其他一些详细信息。每个版本的 Ubuntu 都有自己的四个官方软件仓库：\n Main - Canonical 支持的自由开源软件。 Universe - 社区维护的自由开源软件。 Restricted - 设备的专有驱动程序。 Multiverse - 受版权或法律问题限制的软件。  你可以在 这里 看到所有版本的 Ubuntu 的软件仓库。你可以浏览并转到各个仓库。\n这些信息存储在系统的 /etc/apt/sources.list 文件中。如果查看此文件的内容，你就会看到里面有软件仓库的网址。# 开头的行将被忽略。\nUbuntu 不会在官方仓库中立即提供新版本的软件。他们需要一个步骤来检查此新版本的软件是否与系统兼容，从而可以确保系统的稳定性。这意味着它需要经过几周才能在 Ubuntu 上可用，在某些情况下，这可能需要几个月的时间。\n为获取最新版本的软件，需要使用 PPA，PPA (Personal Package Archives) 允许开发者上传要构建的 Ubuntu 源包，并通过 Launchpad 作为 apt 的软件仓库发布。\n通过如下命令添加 PPA 软件仓库并获取最新版本软件：\n$ sudo add-apt-repository  $ sudo apt-get update $ sudo apt-get install  当你使用 PPA 时，它不会更改原始的 sources.list 文件。相反，它在 /etc/apt/sources.d 目录中创建了两个文件，一个 .list 文件和一个带有 .save 后缀的备份文件。这是一种安全措施，可以确保添加的 PPA 不会和原始的 sources.list 文件弄混，它还有助于移除 PPA。\n开发人员为他们的软件创建的 PPA 称为官方 PPA。但有时，个人会创建由其他开发人员所创建的项目的 PPA。为什么会有人这样做？ 因为许多开发人员只提供软件的源代码。\n如果 PPA 不适用于你的系统版本，你可以点击应用程序 PPA 页面的 View package details，在这里，你可以单击软件包以显示更多详细信息，还可以在此处找到包的源代码和 DEB 文件。建议 使用 Gdebi 安装这些 DEB 文件 而不是通过软件中心，因为 Gdebi 在处理依赖项方面要好得多。\n就安全性而言，很少见到因为使用 PPA 之后你的 Linux 系统被黑客攻击或注入恶意软件。到目前为止，我不记得发生过这样的事件。官方 PPA 可以不加考虑的使用，使用非官方 PPA 完全是你自己的决定。根据经验，如果程序需要 sudo 权限，则应避免通过第三方 PPA 进行安装。\nSnap \u0026 Flatpak A fundamental difference between Snap and Flatpak\nFlatpak is designed to install and update “apps”; user-facing software such as video editors, chat programs and more.\nsnaps can install anything which contains a kernel, printer drivers, audio subsystems and more.\nSnap and Flatpak are the software behind two universal Linux app stores: the Snap Store and Flathub.\n讨论 openSUSE 群\nFlatpak使用bubblewrap来隔离应用程序，bwrap是非常轻量化的沙箱程序，因此攻击面极小。但bwrap需要用户对Linux程序工作方式有准确的了解（使用哪些syscall），Flatpak相当于充当了一个bwrap的前端帮助控制bwrap权限。\n目前Flatpak的问题在于seccomp权限太过广泛，但目前Flatpak维护者已经意识到了这个问题（注释：在他们踩了一次坑之后），已经计划打算解决了。\n另一个问题是程序请求的权限过于广泛，但这更多是一个决策问题而不是技术问题，而且你可以用Flatseal手动调整权限。\nFlatpak你不能用常规程序方式来理解，每个程序都是一个完全独立的空间，只有给予了权限才有对应访问权，也可以用Portals调用文件选择器来获得单独一个文件的完全访问权，Flatpak版的Steam是把所有程序配置文件放在~/.var/app里面了，类似安卓下面的分区存储做法。\nAppImage就只是个自挂载程序，自带的文件透明挂载到它自己的根文件系统下面，所以依然依赖主机的一部分库。所以是的，跟打包者用的系统有关系。\nFlatpak不是这种机制，每个Flatpak空间是完全空白的，需要打包者自己选择加入哪些东西，所以Flatpak跨发行版的兼容性也更好。\n良好打包的AppImage可以有很好的跨发行版兼容性，但是代价就是需要手工测试每个发行版下面的效果。在跨发行版兼容性这点上我更看好Flatpak。\n最后，不要跟我提Snap，我不想碰那个东西，也对它没有研究的兴趣。\nFlatpak确实有很多可取之处，或者不能说是Flatpak可取，而是Linux桌面软件生态现状决定了，只有更激进的手段才能改变现状。\nAppImage那种策略还是过于不痛不痒了，结果就是程序仅仅是被打包成一个个单文件，但背后的库依赖地狱、权限隔离问题一个都没解决。\n但AppImage作者的想法本来也不是靠AppImage颠覆，他是希望Linux能够重新恢复LSB，确保发行版之间的兼容性本身可靠而不是依赖Flatpak这些技术，就类似于Windows上的软件不需要什么沙箱模拟器，你几乎可以保证旧版本的软件能在新版本运行。\n其实也可以说明，微软那种在桌面上采取的策略，很可能难以在Linux社区里推广开来，微软那种做法，确保绝对的向下兼容性，不是谁都有精力来做的。\n比如说如果让微软来做Wayland，那微软根本就不会把Wayland做出来，而是把X11一直迭代、削减臃肿功能直到性能和现代化图形技术栈的性能相匹敌，同时确保向下兼容性。而最新一代的X11很可能和最早的X11已经彻底不一样了，甚至会有“检测程序版本然后自动匹配对应的X11功能”这些奇怪的兼容性策略出来。或许有一天微软会把新项目叫做Wayland，但这个改名也仅仅是营销目的而不是技术目的。\n毕竟LSB已经没了，Ubuntu甚至砍掉32位兼容性，也可以说明其实Linux这边并没有太多人在乎这问题。\n毕竟“反正源代码都在那，重新编译一遍不就好了吗”\nFedora 群\n空のあお, [2/28/22 8:25 PM] 软件有不同版本的依赖 这些依赖很难共存 有些旧版依赖还有更旧的依赖 不说二进制兼容，有些连源码兼容都搞不定 就算搞定了，一段时间过后依赖升级了，还是得坏 flatpak的做法是维护abi稳定的qt和gtk两大ui库和必要桌面库的runtime，用来公用 通过容器隔离app，让每个app自己构建所需的特定依赖到容器里\n竹林里有冰, [2/28/22 8:33 PM] sandbox他是用bubblewrap实现的吧，你可以直接使用bubblewrap，应该一样可以做到他的沙盒化，更小巧一点 bubblewrap的缺点就是需要针对每个程序写上配置，除了有点麻烦其他倒还不错\nNeomonk Zen, [2/28/22 8:36 PM] 也不知flatpak的软件仓库，有没什么审核机制来防止恶意软件，如果没有的话，那还蛮可怕的，想想Chrome和Android的软件市场，都有很多恶意软件\nRobin Lee, [2/28/22 8:39 PM] 没有深入的审核，跟各大发行版的官方包差不多，但flatpak可以限制应用权限\n在 Ubuntu 上使用 Flatpak The official Flatpak PPA is the recommended way to install Flatpak. To install it, run the following in a terminal:\n$ sudo add-apt-repository ppa:flatpak/stable $ sudo apt update $ sudo apt install flatpak Flathub is the best place to get Flatpak apps. To enable it, run:\n$ flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo To complete setup, restart your system. Now all you have to do is install some apps!\nQuestions snap “canonical-livepatch” has “install-snap” change in progress\nSnap 包是 Ubuntu 16.04 LTS 发布时引入的新应用格式包。目前已流行在很多 Linux 发行版上。并且可以很方便地安装常用软件，如 VLC、Sublime Text、VSCode、Node、WPS等\n当你在安装完 Snap 后，你会发现在在根目录下会出现如 /dev/loop0 的挂载点，这些挂载点正是 Snap 软件包的目录。\n  原因是软件之前安装了一次，只是安装失败。\n$ snap changessnap abort 5 ## 5 为安装失败软件的 ID   现在重新安装\n  一些软件最好在官网下载或在 Snap 中下载，官方 Repository 可能并不新，比如 VLC。\ntasksel: Install Group Software 安装\n$ sudo apt install tasksel list tasks\n$ tasksel --list-tasks displays description\n$ tasksel --task-desc dns-server install\n$ sudo apt install dns-server pacstall An AUR-inspired package manager for Ubuntu\nAppImage Linux apps that run anywhere\n包管理器的进化 今天，每个可计算设备都会使用某种软件来完成预定的任务。在软件开发的上古时期，为了找出软件中的 bug 和其它缺陷，软件会被严格的测试。在近十年间，软件被通过互联网来频繁分发，以试图通过持续不断的安装新版本的软件来解决软件的缺陷问题。在很多情况下，每个独立的应用软件都有其自带的更新器。而其它一些软件则让用户自己去搞明白如何获取和升级软件。\nLinux 较早采用了维护一个中心化的软件仓库来发布软件更新这种做法，用户可以在这个软件仓库里查找并安装软件。在这篇文章里， 笔者将回顾在 Linux 上的如何进行软件安装的历史，以及现代操作系统如何保持更新以应对软件安全漏洞（CVE）不断的曝光。\n手动安装软件 曾几何时，软件都是通过 FTP 或邮件列表（LCTT 译注：即通过邮件列表发布源代码的补丁包）来分发的（最终这些发布方式在互联网的迅猛发展下都演化成为一个个现今常见的软件发布网站）。（一般在一个 tar 文件中）只有一个非常小的文件包含了创建二进制的说明。你需要做的是先解压这个包，然后仔细阅读当中的 README 文件， 如果你的系统上恰好有 GCC（LCTT 译注：GNU C Compiler）或者其它厂商的 C 编译器的话，你得首先运行 ./configure 脚本，并在脚本后添加相应的参数，如库函数的路径、创建可执行文件的路径等等。除此之外，这个配置过程也会检查你操作系统上的软件依赖是否满足安装要求。如果缺失了任何主要的依赖，该配置脚本会退出不再继续安装，直到你满足了该依赖。如果该配置脚本正常执行完毕，将会创建一个 Makefile 文件。\n当有了一个 Makefile 文件时， 你就可以接下去执行 make 命令（该命令由你所使用的编译器提供）。make 命令也有很多参数，被称为 make 标识flag，这些标识能为你的系统优化最终生成出来的二进制可执行文件。在计算机世界的早期，这些优化是非常重要的，因为彼时的计算机硬件正在为了跟上软件迅速的发展而疲于奔命。今日今时，编译标识变得更加通用而不是为了优化哪些具体的硬件型号，这得益于现代硬件和现代软件相比已经变得成本低廉，唾手可得。\n最后，在 make 完成之后， 你需要运行 make install （或 sudo make install）（LCTT 译注：依赖于你的用户权限） 来“真正”将这个软件安装到你的系统上。可以想象，为你系统上的每一个软件都执行上述的流程将是多么无聊费时，更不用说如果更新一个已经安装的软件将会多复杂，多么需要精力投入。（LCTT 译注：上述流程也称 CMMI 安装， 即Configure、Make、Make Install）\n软件包 package（LCTT 译注：下文简称“包”）这个概念是用来解决在软件安装、升级过程中的复杂性的。包将软件安装升级中需要的多个数据文件合并成一个单独的文件，这将便于传输和（通过压缩文件来）减小存储空间（LCTT 译注：减少存储空间这一点在现在已经不再重要），包中的二进制可执行文件已根据开发者所选择的编译标识预编译。包本身包括了所有需要的元数据，如软件的名字、软件的说明、版本号，以及要运行这个软件所需要的依赖包等等。\n不同流派的 Linux 发行版都创造了它们自己的包格式，其中最常用的包格式有：\n .deb：这种包格式由 Debian、Ubuntu、Linux Mint 以及其它的变种使用。这是最早被发明的包类型。 .rpm：这种包格式最初被称作红帽包管理器Red Hat Package Manager（LCTT 译注： 取自英文的首字母）。使用这种包的 Linux 发行版有 Red Hat、Fedora、SUSE 以及其它一些较小的发行版。 .tar.xz：这种包格式只是一个软件压缩包而已，这是 Arch Linux 所使用的格式。  尽管上述的包格式自身并不能直接管理软件的依赖问题，但是它们的出现将 Linux 软件包管理向前推进了一大步。\n软件仓库 多年以前（当智能电话还没有像现在这样流行时），非 Linux 世界的用户是很难理解软件仓库的概念的。甚至今时今日，大多数完全工作在 Windows 下的用户还是习惯于打开浏览器，搜索要安装的软件（或升级包），下载然后安装。但是，智能电话传播了软件“商店”（LCTT 译注： 对应 Linux 里的软件仓库）这样一个概念。智能电话用户获取软件的方式和包管理器的工作方式已经非常相近了。些许不同的是，尽管大多数软件商店还在费力美化它的图形界面来吸引用户，大多数 Linux 用户还是愿意使用命令行来安装软件。总而言之，软件仓库是一个中心化的可安装软件列表，上面列举了在当前系统中预先配置好的软件仓库里所有可以安装的软件。\n包管理器 包管理器用来和相应的软件仓库交互，获取软件的相应信息。下面对流行做一个简短介绍。\n基于 PRM 包格式的包管理器 更新基于 RPM 的系统，特别是那些基于 Red Hat 技术的系统，有着非常有趣而又详实的历史。实际上，现在的 YUM 版本（用于 企业级发行版）和 DNF（用于社区版）就融合了好几个开源项目来提供它们现在的功能。\nRed Hat 最初使用的包管理器，被称为 RPM（红帽包管理器Red Hat Package Manager），时至今日还在使用着。不过，它的主要作用是安装本地的 RPM 包，而不是去在软件仓库搜索软件。后来开发了一个叫 up2date 的包管理器，它被用来通知用户包的最新更新，还能让用户在远程仓库里搜索软件并便捷的安装软件的依赖。尽管这个包管理器尽职尽责，但一些社区成员还是感觉 up2date 有着明显的不足。\n现在的 YUM 来自于好几个不同社区的努力。1999-2001 年一群在 Terra Soft Solution 的伙计们开发了Yellowdog Updater（YUP），将其作为 Yellow Dog Linux 图形安装器的后端。杜克大学Duke University喜欢这个主意就决定去增强它的功能，它们开发了Yellowdog Updater, Modified（YUM），这最终被用来帮助管理杜克大学的 Red Hat 系统。Yum 壮大的很快，到 2005 年，它已经被超过一半的 Linux 市场所采用。今日，几乎所有的使用 RPM 的的 Linux 都会使用 YUM 来进行包管理（当然也有一些例外）。\nDandified Yum（DNF）是 YUM 的下一代接班人。从 Fedora 18 开始被作为包管理器引入系统，不过它并没有被企业版所采用，所以它只在 Fedora（以及变种）上占据了主导地位。DNF 的用法和 YUM 几乎一模一样，它主要是用来解决性能问题、晦涩无说明的API、缓慢/不可靠的依赖解析，以及偶尔的高内存占用。DNF 是作为 YUM 的直接替代品来开发的，因此这里笔者就不重复它的用法了，你只用简单的将 yum 替换为 dnf 就行了。\nZypper 是用来管理 RPM 包的另外一个包管理器。这个包管理器主要用于 SUSE（和 openSUSE），在MeeGo、Sailfish OS、Tizen 上也有使用。它最初开发于 2006 年，已经经过了多次迭代。除了作为系统管理工具 YaST 的后端和有些用户认为它比 YUM 要快之外也没有什么好多说的。\n基于 Debian 的包管理器 作为一个现今仍在被积极维护的最古老的 Linux 发行版之一，Debian 的包管理系统和基于 RPM 的系统的包管理系统非常类似。它使用扩展名为 “.deb” 的包，这种文件能被一个叫做 dpkg 的工具所管理。dpgk 同 rpm 非常相似，它被设计成用来管理在存在于本地（硬盘）的包。它不会去做包依赖关系解析（它会做依赖关系检查，不过仅此而已），而且在同远程软件仓库交互上也并无可靠的途径。为了提高用户体验并便于使用，Debian 项目开始了一个软件项目：Deity，最终这个代号被丢弃并改成了现在的 Advanced Pack Tool（APT）。\n在 1998 年，APT 测试版本发布（甚至早于 1999 年的 Debian 2.1 发布），许多用户认为 APT 是基于 Debian 系统标配功能之一。APT 使用了和 RPM 一样的风格来管理仓库，不过和 YUM 使用单独的 .repo 文件不同，APT 曾经使用 /etc/apt/sources.list 文件来管理软件仓库，后来的变成也可以使用 /etc/apt/sources.d 目录来管理。如同基于 RPM 的系统一样，你也有很多很多选项配置来完成同样的事情。你可以编辑和创建前述的文件，或者使用图形界面来完成上述工作（如 Ubuntu 的“Software \u0026 Updates”）。\n现今大多数的 Ubuntu 教程里都径直使用了 apt。 单独一个 apt 设计用来实现那些最常用的 APT 命令的。apt 命令看上去是用来整合那些被分散在 apt-get、apt-cache 以及其它一些命令的的功能的。它还加上了一些额外的改进，如色彩、进度条以及其它一些小功能。\n基于 Arch 的包管理器 Arch Linux 使用称为 packman 的包管理器。和 .deb 以及 .rpm 不同，它使用更为传统的 LZMA2 压缩包形式 .tar.xz 。这可以使 Arch Linux 包能够比其它形式的压缩包（如 gzip）有更小的尺寸。自从 2002 年首次发布以来， pacman 一直在稳定发布和改善。使用它最大的好处之一是它支持 Arch Build System，这是一个从源代码级别构建包的构建系统。该构建系统借助一个叫 PKGBUILD 的文件，这个文件包含了如版本号、发布号、依赖等等的元数据，以及一个为编译遵守 Arch Linux 需求的包所需要的带有必要的编译选项的脚本。而编译的结果就是前文所提的被 pacman 所使用的 .tar.xz 的文件。\n上述的这套系统技术上导致了 Arch User Respository（AUR）的产生，这是一个社区驱动的软件仓库，仓库里包括有 PKGBUILD 文件以及支持补丁或脚本。这给 Arch Linux 带了无穷无尽的软件资源。最为明显的好处是如果一个用户（或开发者）希望他开发的软件能被广大公众所使用，他不必通过官方途径去在主流软件仓库获得许可。而不利之处则是它必须将依赖社区的流程，类似于 Docker Hub、 Canonical 的 Snap Packages（LCTT 译注： Canonical 是 Ubuntu 的发行公司），或者其它类似的机制。\n有很多特定于 AUR 的包管理器能被用来从 AUR 里的 PGKBUILD 文件下载、编译、安装。其中 yaourt 和 pacaur 颇为流行。不过，这两个项目已经被 Arch Wiki 列为“不继续开发以及有已知的问题未解决”。因为这个原因，这里直接讨论 aurman，除了会搜索 AUR 以及包含几个有帮助的（其实很危险）的选项之外，它的工作机制和 pacman 极其类似。\nconda 简介 Conda 是一个开源的软件包管理系统和环境管理系统，用于安装多个版本的软件包及其依赖关系，并在它们之间轻松切换。 Conda 是为 Python 程序创建的，适用于 Linux，OS X 和 Windows，也可以打包和分发其他软件。\n安装 conda分为anaconda和miniconda。anaconda是包含一些常用包的版本（这里的常用不代表你常用），miniconda则是精简版，需要啥装啥，所以推荐使用miniconda。\nminiconda官网：https://conda.io/miniconda.html\n选择适合自己的版本下载：\n$ wget -c https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh 这里选择的是latest-Linux版本，所以下载的程序会随着python的版本更新而更新。\n安装：\n$ chmod 777 Miniconda3-latest-Linux-x86_64.sh $ bash Miniconda3-latest-Linux-x86_64.sh 加不加入环境变量都可以。所谓的会污染环境等等问题可能都是将大量的软件直接安装在conda的base环境中引起的，只要养成好的使用习惯，灵活使用conda create 命令将不同的软件安装到自己单独的虚拟环境中就可以了。把conda这条蟒蛇关进一个一个的笼子里，才能更好的为我们的科研服务~\n添加频道 这个道理跟家里的电视机是一样一样的，安装conda就相当于买了一台电视机，但是有电视了不意味着你就能看节目了，你要手动添加频道才能看你想看的电视节目。\n添加清华的镜像channels：\n$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ $ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ $ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/ $ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/ 为了分担清华源镜像的压力，北京外国语大学也开启了镜像站点，同样是由清华TUNA团队维护的，如果有小伙伴遇到清华源速度很慢的情况的话，可以考虑换成北外的镜像。\n$ conda config --add channels https://mirrors.bfsu.edu.cn/anaconda/cloud/bioconda/ $ conda config --add channels https://mirrors.bfsu.edu.cn/anaconda/cloud/conda-forge/ $ conda config --add channels https://mirrors.bfsu.edu.cn/anaconda/pkgs/free/ $ conda config --add channels https://mirrors.bfsu.edu.cn/anaconda/pkgs/main/ 显示安装的频道\n$ conda config --set show_channel_urls yes 查看已经添加的channels\n$ conda config --get channels 已添加的channel在哪里查看\n$ vim ~/.condarc 软件包管理 $ conda install gatk 搜索安装包 $ conda search gatk 安装完成后，可以用“which 软件名”来查看该软件安装的位置：\n$ which gatk 安装特定版本 $ conda install 软件名=版本号 $ conda install gatk=3.7 这时conda会先卸载已安装版本，然后重新安装指定版本。\n查看已安装软件 $ conda list 更新指定软件 $ conda update gatk 卸载指定软件 $ conda remove gatk 环境管理 退出conda环境 退出也很简单，之前我们是. ./activate 或者 (. ~/miniconda3/bin/activate)现在退出只要:\n$ . ./deactivate # 或者用  $ conda deactivate 就退出当前的环境了\n创建conda环境 之前创建的时候显示的是（base）这是conda的基本环境，有些软件依赖的是python2的版本，当你还是使用你的base的时候你的base里的python会被自动降级，有可能会引发别的软件的报错，所以，可以给一些特别的软件一些特别的关照，比如创建一个单独的环境。\n在conda环境下，输入conda env list（或者输入conda info --envs也是一样滴）查看当前存在的环境：\n$ conda env list 创建一个新的环境\n$ conda create -n python2 python=2  -n: 设置新的环境的名字 python=2 指定新环境的python的版本，非必须参数 这里也可以用一个-y参数，可以直接跳过安装的确认过程。  conda会创建一个新的python2的环境，并且会很温馨的提示你只要输入conda activate python2就可以启动这个环境了。\n删除环境 $ conda remove -n myenv --all 重命名环境 实际上conda并没有提供这样的功能，但是可以曲线救国，原理是先克隆一个原来的环境，命名成想要的名字，再把原来的环境删掉即可\n接下来演示把一个原来叫做py2的环境重新命名成python2：\n$ conda create -n python2 --clone py2 $ conda remove -n py2 --all 自动更新 Ubuntu 默认的配置会每天自动安装安全更新而忽略其它包的更新。\n更新机制 Ubuntu 默认定义了 4 个 systemd unit 执行更新任务，它们分别是：\n/lib/systemd/system/apt-daily-upgrade.service /lib/systemd/system/apt-daily-upgrade.timer /lib/systemd/system/apt-daily.service /lib/systemd/system/apt-daily.timer 中的 apt-daily.timer 和 apt-daily-upgrade.timer 是两个触发器，分别在每天指定的时间触发 apt-daily.service 和 apt-daily-upgrade.service。这两个 service 的类型都是 oneshot，意思是当任务完成后 service 进程退出。这两个 service 其实调用的是同一个脚本： /usr/lib/apt/apt.systemd.daily。apt-daily.service 为脚本传入参数 “update”，其功能为检查系统的更新并下载对应的更新包。apt-daily-upgrade.service 为脚本传入参数 “install”，其功能为安装更新并删除缓存在本地的更新包。\napt-daily.timer 默认每天触发两次，分别为 6 点和 18 点，主要是为了缓解服务器端的下载压力。我们可以根据自身业务的特点设置合适的触发时间。\napt-daily-upgrade.service 默认每天在 6 点触发一次，我们也可以设置为其它时间，比如午夜。\napt.systemd.daily /usr/lib/apt/apt.systemd.daily 脚本负责完成与更新相关的一系列工作，这些工作主要分为两大块：\n 检查更新并下载更新包 安装更新并清理更新包  apt.systemd.daily 脚本中调用 apt-config 命令从 /etc/apt/apt.conf.d/10periodic 文件和 /etc/apt/apt.conf.d/20auto-upgrades 读中取配变量，并根据这些变量的值来控制系统的更新策略。下面我们介绍几个比较重要的配置项。\n隔多少天执行一次 apt-get update，默认是 1 天，0 表示不执行该操作：\nAPT::Periodic::Update-Package-Lists \"1\"; 隔多少天执行一次 apt-get upgrade –download-only 下载更新包，0 表示不执行该操作：\nAPT::Periodic::Download-Upgradeable-Packages \"0\"; 下载的更新版被缓存在目录 /var/cache/apt/archives/ 中，执行升级操作时直接从缓存目录中读取包文件而不是从网络上下载。\n隔多少天执行一次 apt-get autoclean 清除无用的更新包，0 表示不执行该操作：\nAPT::Periodic::AutocleanInterval \"0\"; 隔多少天执行一次 Unattended-Upgrade 执行系统安全更新(或者所有包的更新)，0 表示不执行该操作：\nAPT::Periodic::Unattended-Upgrade \"1\"; 通过这些配置，我们可以控制自动更新的频率和行为。注意，到目前为止的配置还只能安装系统的安全更新，如果要想安装所有包的更新还需要其它的配置。\n在继续介绍后面的内容前，让我们先来了解一下 apt.systemd.daily 脚本中用到的 apt-config 命令和 apt.systemd.daily 脚本依赖的配置文件。\napt-config 命令\napt-config 是一个被 APT 套件使用的内部命令，使用它可以在脚本中提取 /etc/apt/apt.conf 目录下配置文件中的信息。\n比如，如果要在脚本中获取 APT::Periodic::Update-Package-Lists 的设置，可以使用下面的代码：\n#!/bin/bash ABC=0 eval $(apt-config shell ABC APT::Periodic::Update-Package-Lists) echo ${ABC} 此时脚本变量 ABC 中保存的就是 APT::Periodic::Update-Package-Lists 的值。\n10periodic 和 20auto-upgrades\n/etc/apt/apt.conf.d/10periodic 是 update-notifier-common 的配置文件：\n$ dpkg-query -S /etc/apt/apt.conf.d/10periodic update-notifier-common: /etc/apt/apt.conf.d/10periodic 在 ubuntu 16.04 和 18.04 中，这两个文件的默认内容是一样的。apt.systemd.daily 脚本在注释中说我们可以通过 /etc/apt/apt.conf.d/10periodic 文件自定义相关的变量值，它通过 get-config 命令来获得这些变量的值。但是测试的结果是 /etc/apt/apt.conf.d/20auto-upgrades 文件中的变量会覆盖 /etc/apt/apt.conf.d/10periodic 文件中的变量。看来是 get-config 命令根据文件名称的顺序，排在后面的文件中的变量会覆盖前面文件中的变量。\n在 desktop 版本中，通过 GUI 程序修改相关的变量，这两个文件都会被修改并保持一致，所以在 server 版中我们最好也同时修改这两个文件并保持其内容一致。\nunattended-upgrades Ubuntu 实际上是通过 unattended-upgrades 命令来自动安装更新的。Ubuntu 16.04/18.04 默认安装了这个包，如果碰到没有安装的情况你还可以通过下面的命令自行安装：\n$ sudo apt install unattended-upgrades unattended-upgrades 的配置文件为 /etc/apt/apt.conf.d/50unattended-upgrades。\n注意，unattended-upgrades 不仅能够安装系统的安全更新，还可以安装所有包的更新。但是默认的配置只安装安全更新，我们可以通过配置项让 unattended-upgrades 安装所有的包更新或者只安装安全更新。\nunattended-upgrades 命令被设计为通过 cron 定时执行系统更新，但在 Ubuntu 16.04/18.04 中是通过 systemd 的 timer unit 定时触发 service unit 执行的。\nunattended-upgrades 命令的日志文件存放在 /var/log/unattended-upgrades 目录下。\nunattended-upgrade 命令常见的用法之一是检查系统是否有更新：\n$ sudo unattended-upgrade --dry-run 另一种用法是安装更新：\n$ sudo unattended-upgrade 在 apt.systemd.daily 脚本中执行 unattended-upgrade 命令时，由于更新包已经提前下载到缓存目录了(/var/cache/apt/archives)，所以直接它直接使用缓存中的更新包。\n配置文件 50unattended-upgrades\n50unattended-upgrades 文件中的默认配置只是安装安全更新：\nUnattended-Upgrade::Allowed-Origins { \"${distro_id}:${distro_codename}\"; \"${distro_id}:${distro_codename}-security\"; \"${distro_id}ESM:${distro_codename}\"; // \"${distro_id}:${distro_codename}-updates\"; // \"${distro_id}:${distro_codename}-proposed\"; // \"${distro_id}:${distro_codename}-backports\"; }; 如果要自动安装所有包的更新，只要取消下面行的注释就行了：\n\"${distro_id}:${distro_codename}-updates\"; 我们还可以通过黑名单的方式指定不更新哪些包：\nUnattended-Upgrade::Package-Blacklist { \"vim\"; \"libc6\"; \"libc6-dev\"; \"libc6-i686\"; }; 下面的配置项指定在更新后移除无用的包：\nUnattended-Upgrade::Remove-Unused-Kernel-Packages \"true\"; Unattended-Upgrade::Remove-Unused-Dependencies \"true\"; 有些更新需要重启系统，而默认的配置是不重启系统的。下面的配置允许重启系统(更新完成后，如果需要重启，立即重启系统)：\nUnattended-Upgrade::Automatic-Reboot \"true\"; 但是多数情况下我们更期望指定一个时间让系统重启(如果需要重启，在下面配置中指定的时间重启系统)：\nUnattended-Upgrade::Automatic-Reboot-Time \"02:38\"; 在系统更新的过程中发生了错误怎么办？当然是通知管理员啦！下面的配置在发生错误时给管理员发送邮件：\nUnattended-Upgrade::Mail \"user@example.com\"; Unattended-Upgrade::MailOnlyOnError \"true\"; 注意：如果要向外网发送邮件，需要安装 mailx 等工具。\n关闭自动更新 如果你的主机运行在封闭的环境中，并且无法连接到有效的更新源，此时可以选择关闭自动更新功能。首选的方法是停止相关的服务：\n$ sudo systemctl stop apt-daily.service $ sudo systemctl stop apt-daily.timer $ sudo systemctl stop apt-daily-upgrade.service $ sudo systemctl stop apt-daily-upgrade.timer $ sudo systemctl disable apt-daily.service $ sudo systemctl disable apt-daily.timer $ sudo systemctl disable apt-daily-upgrade.service $ sudo systemctl disable apt-daily-upgrade.timer 或者修改自动更新程序的配置文件也可以，同时更新 /etc/apt/apt.conf.d/10periodic 和 /etc/apt/apt.conf.d/20auto-upgrades：\nAPT::Periodic::Update-Package-Lists \"1\"; APT::Periodic::Unattended-Upgrade \"1\"; 改为\nAPT::Periodic::Update-Package-Lists \"0\"; APT::Periodic::Unattended-Upgrade \"0\"; 文件系统 fstab /etc/fstab是用来存放文件系统的静态信息的文件。当系统启动的时候，系统会自动地从这个文件读取信息，并且会自动将此文件中指定的文件系统挂载到指定的目录。\n查看/etc/fstab\n# cat /etc/fstab      tmpfs /tmp tmpfs nodev,nosuid 0 0 /dev/sda1 / ext4 defaults,noatime 0 1 /dev/sda2 none swap defaults,nodelalloc 0 0 /dev/sda3 /home ext4 defaults,noatime 0 2 分别解释一下各字段的用处：\n  要挂载的分区或存储设备  挂载的目录位置  挂载分区的文件系统类型，比如：ext3、ext4、xfs、swap  挂载使用的参数有哪些。举例如下：  auto - 在启动时或键入了 mount -a 命令时自动挂载。 noauto - 只在你的命令下被挂载。 exec - 允许执行此分区的二进制文件。 noexec - 不允许执行此文件系统上的二进制文件。 ro - 以只读模式挂载文件系统。 rw - 以读写模式挂载文件系统。 user - 允许任意用户挂载此文件系统，若无显示定义，隐含启用 noexec, nosuid, nodev 参数。 users - 允许所有 users 组中的用户挂载文件系统. nouser - 只能被 root 挂载。 owner - 允许设备所有者挂载。 sync - I/O 同步进行。 async - I/O 异步进行。 dev - 解析文件系统上的块特殊设备。 nodev - 不解析文件系统上的块特殊设备。 suid - 允许 suid 操作和设定 sgid 位。这一参数通常用于一些特殊任务，使一般用户运行程序时临时提升权限。 nosuid - 禁止 suid 操作和设定 sgid 位。 noatime - 不更新文件系统上 inode 访问记录，可以提升性能。 nodiratime - 不更新文件系统上的目录 inode 访问记录，可以提升性能(参见 atime 参数)。 relatime - 实时更新 inode access 记录。只有在记录中的访问时间早于当前访问才会被更新。（与 noatime 相似，但不会打断如 mutt 或其它程序探测文件在上次访问后是否被修改的进程。），可以提升性能。 flush - vfat 的选项，更频繁的刷新数据，复制对话框或进度条在全部数据都写入后才消失。 defaults - 使用文件系统的默认挂载参数，例如 ext4 的默认参数为:rw, suid, dev, exec, auto, nouser, async.    dump 工具通过它决定何时作备份。dump 会检查其内容，并用数字来决定是否对这个文件系统进行备份。 允许的数字是 0 和 1 。0 表示忽略， 1 则进行备份。大部分的用户是没有安装 dump 的 ，对他们而言  应设为 0。  fsck 读取  的数值来决定需要检查的文件系统的检查顺序。允许的数字是0, 1, 和2。 根目录应当获得最高的优先权 1, 其它所有需要被检查的设备设置为 2。 0 表示设备不会被 fsck 所检查。  示例：\n/dev/sda1 /mnt/LinuxOSBuckup ext4 defaults 0 2 UUID of Storage Devices Finding UUID with blkid\n$ sudo blkid Finding UUID with ls\n$ ls -l /dev/disk/by-uuid Finding UUID with lsblk\n$ sudo lsblk -f LVM 在对磁盘分区的大小进行规划时，往往不能确定这个分区要使用的空间的大小。而使用 fdisk、gdisk 等工具对磁盘分区后，每个分区的大小就固定了。如果分区设置的过大，就白白浪费了磁盘空间；如果分区设置的过小，就会导致空间不够用的情况出现。对于分区过小的问题，可以从新划分磁盘的分区，或者通过软连接的方式将此分区的目录链接到另外一个分区。这样虽然能够临时解决问题，但是给管理带来了麻烦。类似的问题可以通过 LVM 来解决。\nLVM 是什么 LVM 是 Logical Volume Manager 的缩写，中文一般翻译为 “逻辑卷管理”，它是 Linux 下对磁盘分区进行管理的一种机制。LVM 是建立在磁盘分区和文件系统之间的一个逻辑层，系统管理员可以利用 LVM 在不重新对磁盘分区的情况下动态的调整分区的大小。如果系统新增了一块硬盘，通过 LVM 就可以将新增的硬盘空间直接扩展到原来的磁盘分区上。\nLVM 的优点如下：\n 文件系统可以跨多个磁盘，因此大小不再受物理磁盘的限制。 可以在系统运行状态下动态地扩展文件系统大小。 可以以镜像的方式冗余重要数据到多个物理磁盘上。 可以很方便地导出整个卷组，并导入到另外一台机器上。  LVM 也有一些缺点：\n 在从卷组中移除一个磁盘的时候必须使用 reducevg 命令(这个命令要求root权限，并且不允许在快照卷组中使用)。 当卷组中的一个磁盘损坏时，整个卷组都会受影响。 因为增加了一个逻辑层，存储的性能会受影响。  LVM 的优点对服务器的管理非常有用，但对于桌面系统的帮助则没有那么显著，所以需要我们根据使用的场景来决定是否应用 LVM。\nLVM 中的基本概念 通过 LVM 技术，可以屏蔽掉磁盘分区的底层差异，在逻辑上给文件系统提供了一个卷的概念，然后在这些卷上建立相应的文件系统。下面是 LVM 中主要涉及的一些概念。\n **物理存储设备(Physical Media)：**指系统的存储设备文件，比如 /dev/sda、/dev/sdb 等。 **PV(物理卷 Physical Volume)：**指硬盘分区或者从逻辑上看起来和硬盘分区类似的设备(比如 RAID 设备)。 **VG(卷组 Volume Group)：**类似于非 LVM 系统中的物理硬盘，一个 LVM 卷组由一个或者多个 PV(物理卷)组成。 **LV(逻辑卷 Logical Volume)：**类似于非 LVM 系统上的磁盘分区，LV 建立在 VG 上，可以在 LV 上建立文件系统。 **PE(Physical Extent)：**PV(物理卷)中可以分配的最小存储单元称为 PE，PE 的大小是可以指定的。 **LE(Logical Extent)：**LV(逻辑卷)中可以分配的最小存储单元称为 LE，在同一个卷组中，LE 的大小和 PE 的大小是一样的，并且一一对应。  可以这么理解，LVM 是把硬盘的分区分成了更小的单位(PE)，再用这些单元拼成更大的看上去像分区的东西(PV)，进而用 PV 拼成看上去像硬盘的东西(VG)，最后在这个新的硬盘上创建分区(LV)。文件系统则建立在 LV 之上，这样就在物理硬盘和文件系统中间添加了一层抽象(LVM)。下图大致描述了这些概念之间的关系：\n对上图中的结构做个简单的介绍：\n两块物理硬盘 A 和 B 组成了 LVM 的底层结构，这两块硬盘的大小、型号可以不同。PV 可以看做是硬盘上的分区，因此可以说物理硬盘 A 划分了两个分区，物理硬盘 B 划分了三个分区。然后将前三个 PV 组成一个卷组 VG1，后两个 PV 组成一个卷组 VG2。接着在卷组 VG1 上划分了两个逻辑卷 LV1 和 LV2，在卷组 VG2 上划分了一个逻辑卷 LV3。最后，在逻辑卷 LV1、LV2 和 LV3 上创建文件系统，分别挂载在 /usr、/home 和 /var 目录。\nLVM 工具 在安装 Linux 时，如果选择使用 LVM 创建分区，就会安装 LVM 相关的工具。当前这个软件包的名称为 lvm2，其中包含了大量 LVM 工具。比如单是查看 LVM 相关实体状态的命令就有如下一些：\n$ sudo pvscan $ sudo pvs $ sudo pvdisplay $ sudo vgscan $ sudo vgs $ sudo vgdisplay $ sudo lvscan $ sudo lvs $ sudo lvdisplay 如果安装系统时没有默认安装 LVM 工具包，可以通过下面的命令安装它们：\n$ sudo apt update $ sudo apt install lvm2 接下来我们通过例子来演示如何使用 LVM 来一步步的创建出逻辑卷(LV)，然后在 LV 上创建文件系统并挂载到 Linux 系统中。\n使用 gdisk 对物理磁盘进行分区 目前常见的磁盘分区格式有两种，MBR 分区和 GPT 分区。\nMBR 分区，MBR 的意思是 “主引导记录”。MBR 最大支持 2TB 容量，在容量方面存在着极大的瓶颈。\nGPT 分区，GPT 意为 GUID 分区表，它支持的磁盘容量比 MBR 大得多。这是一个正逐渐取代 MBR 的新标准，它是由 UEFI 辅住而形成的，将来 UEFI 用于取代老旧的 BIOS，而 GPT 则取代老旧的 MBR。\n使用 fdisk 工具创建 MBR 磁盘分区，而 gdisk 是 Linux 系统中 GPT 格式的磁盘分区管理工具。\n假设我们的 Linux 系统中增加了一块新的磁盘，系统对应的设备名为 /dev/sdb，下面我们通过 gdisk 命令对这个磁盘进行分区。\n在用 gdisk 命令对磁盘分区前，我们先用 parted 命令查看 /dev/sdb 当前的分区情况：\n$ sudo parted /dev/sdb print 下面通过 gdisk 命令创建分区：\n$ sudo gdisk /dev/sdb 通过 p 命令可以查看磁盘当前的状态：输出中的前几行是磁盘的基本信息，比如总大小，一共有多少个扇区(sector)，每个扇区的大小，当前剩余的空间等等。\n然后是已经存在的分区信息：\n 第一列 Number 显示了分区的编号，比如 1 号指 /dev/sdb1。 第二列 Start 表示磁盘分区的起始位置。 第三列 End 表示磁盘分区的结束位置。 第四列 Size 显示分区的容量。 第五列 Code 和第六列 Name 显示分区类型的 ID和名称，比如 Linux filesystem 为 8300，Linux swap 为 8200，Linux LVM 为 8e00。  通过 n 命令来创建新分区：\n分区编号和开始/结束的扇区都直接通过回车选择默认值，这样所有的磁盘空间都划分到了一个分区中，然后输入 8e00 说明我们要创建的分区类型为 Linux LVM。最后输入 w 命令并确认执行分区操作。分区成功后可通过 p 命令查看我们创建的分区的信息。\n创建物理卷 PV # pvcreate DEVICE 现在我们可以基于磁盘分区 /dev/sdb1 来创建 LVM 物理卷(LV)，可以通过 pvcreate 命令来完成：\n$ sudo pvcreate /dev/sdb1 此时 /dev/sdb1 已经完成了从磁盘分区到 PV 的华丽转身！注意上面的命令，磁盘分区被直接转换成了 PV，连名称都没有变化！我们可以通过 pvs 命令查看 /dev/sdb1，目前它还没有被加入到 VG 中。\n创建卷组 VG # vgcreate    ... 基于一个或多个 PV，可以创建 VG。我们使用刚才创建的 PV /dev/sdb1 来创建一个名称为 nickvg 的 VG：\n$ sudo vgcreate -s 32G nickvg /dev/sdb1 注意 vgcreate 命令中的 -s 选项，它指定了 PE(Physical Extent) 的大小。可以通 vgs 命令观察 VG 的信息：\n$ sudo vgs nickvg 如果目标 VG 已经存在，则使用 vgextend 把 PV 加入到 VG 中即可。\n# vgextend   创建逻辑卷 LV # lvcreate -L   -n  有了 VG 就可以创建逻辑卷 LV 了，lvcreate 命令用来创建 LV，让我们在前面创建的 nickvg 上创建名称为 nicklv00 的 LV：\n$ sudo lvcreate -L 15G -n nicklv00 nickvg 选项 -L 指定新建 LV 的容量，这里是 15G；选项 -n 则指定新建 LV 的名称，这里为 nicklv00。可以通过 lvs 命令观察 LV 的信息，注意需要同时指出 LV 所在的 VG：\n$ sudo lvs nickvg/nicklv00 如果你想让要创建的逻辑卷拥有卷组（VG）的所有未使用空间，请使用以下命令：\n# lvcreate -l +100%FREE  -n  格式化逻辑卷(创建文件系统) # mkfs. /dev/mapper/- # mount /dev/mapper/-  当我们创建 LV nickvg/nicklv00 时，其实是创建了名称为 /dev/nickvg/nicklv00 的设备文件。\n现在你的逻辑卷应该已经在/dev/mapper/和/dev/YourVolumeGroupName中了。\n现在我们来格式化这个逻辑卷(在该 LV 上创建文件系统)，目标为比较常见的 ext4 格式：\n$ sudo mkfs.ext4 /dev/nickvg/nicklv00 然后创建个目录，比如 /home/doc，并把新建的文件系统挂载到这个目录上：\n$ sudo mkdir /home/doc $ sudo mount /dev/nickvg/nicklv00 /home/doc 最后可以通过 df 命令查看这个文件系统的使用情况。\n开机自动挂载 编辑 /etc/fstab 文件：\n$ sudo vim /etc/fstab 把下面的行添加的文件末尾并保存文件：\n/dev/mapper/nickvg-nicklv00 /home/doc ext4 defaults 0 2 调整逻辑卷 同时缩小逻辑卷和其文件系统\n 注意： 只有ext2，ext3，ext4，ReiserFS和 XFS 文件系统支持以下操作。\n 将MyVolGroup组中的逻辑卷mediavol扩大10GiB，并同时扩大其文件系统：\n# lvresize -L +10G --resizefs MyVolGroup/mediavol 将MyVolGroup组中的逻辑卷mediavol大小调整为15GiB，并同时调整其文件系统：\n# lvresize -L 15G --resizefs MyVolGroup/mediavol 将卷组中的所有剩余空间分配给mediavol：\n# lvresize -l +100%FREE --resizefs MyVolGroup/mediavol 重命名卷 重命名卷组\n要重命名一个卷组，请使用vgrename(8)命令。\n可使用下面的任意一条命令将卷组vg02重命名为my_volume_group\n# vgrename /dev/vg02 /dev/my_volume_group # vgrename vg02 my_volume_group 重命名逻辑卷\n要重命名一个逻辑卷，请使用lvrename(8)命令。\n可使用下面的任意一条命令将vg02组中的逻辑卷lvold重命名为lvnew.\n# lvrename /dev/vg02/lvold /dev/vg02/lvnew # lvrename vg02 lvold lvnew 移除逻辑卷 警告： 在移除逻辑卷之前，请先备份好数据以免丢失！\n首先，找到你所要移除的逻辑卷的名称。你可以使用以下命令来查看系统的所有逻辑卷：\n# lvs 接下来，找到你所要移除的逻辑卷的挂载点\n$ lsblk 并卸载它：\n# umount / 最后，使用以下命令来移除逻辑卷：\n# lvremove / 例如：\n# lvremove VolGroup00/lvolhome 请输入y来确定你要执行移除逻辑卷操作。\n此外，请不要忘了更新/etc/fstab。\n你可以再次使用lvs命令来确认你的逻辑卷已被移除。\nLVM 快照 LVM 机制还提供了对 LV 做快照的功能，也就是说可以给文件系统做一个备份，这也是设计 LVM 快照的主要目的。LVM 的快照功能采用写时复制技术(Copy-On-Write，COW)，这比传统的备份技术的效率要高很多。创建快照时不用停止服务，就可以对数据进行备份。说明：LVM 还支持 thin 类型的快照，但是本文中的快照都是指 COW 类型的快照。\nLVM 采用的写时复制，是指当 LVM 快照创建的时候，仅创建到实际数据的 inode 的硬链接(hark-link)而已。只要实际的数据没有改变，快照就只包含指向数据的 inode 的指针，而非数据本身。快照会跟踪原始卷中块的改变，一旦你更改了快照对应的文件或目录，这个时候原始卷上将要改变的数据会在改变之前拷贝到快照预留的空间。\nLVM 快照的原理\n创建快照实际上也是创建了一个逻辑卷，只不过该卷的属性与普通逻辑卷的属性有些不一样。我们可以通过下图来理解快照数据卷(图中的实线框表示快照区域，虚线框表示文件系统)：\n左图为最初创建的快照数据卷状况，LVM 会预留一个区域 (比如左图的左侧三个 PE 区块) 作为数据存放处。 此时快照数据卷内并没有任何数据，而快照数据卷与源数据卷共享所有的 PE 数据， 因此你会看到快照数据卷的内容与源数据卷中的内容是一模一样的。 等到系统运行一阵子后，假设 A 区域的数据被更新了(上面右图所示)，则更新前系统会将该区域的数据移动到快照数据卷中， 所以在右图的快照数据卷中被占用了一块 PE 成为 A，而其他 B 到 I 的区块则还是与源数据卷共享！\n由於快照区与原本的 LV 共享很多 PE 区块，因此快照区与被快照的 LV 必须要在同一个 VG 上头，下面两点非常重要：\n VG中需要预留存放快照本身的空间，不能全部被占满。 快照所在的 VG 必须与被备份的 LV 的 VG 相同，否则创建快照会失败。  创建 LVM 快照\n其实快照就是一个特殊类型的数据卷，所以创建快照的命令和创建数据卷的命令相同，也是 lvcreate：\n# lvcreate --size 100M --snapshot --name snap01 /dev/vg0/lv 此时如果把 LV snap01 挂载到系统中，里面的内容和 LV /dev/vg0/lv 中的内容是一样的。\n创建的快照的大小可以比源数据卷小，但是当源数据卷中的数据更新过多时会导致快照容量不足而引起的错误并丢失数据。如上你可以修改少于100M的数据，直到该快照逻辑卷空间不足为止。\n创建快照后，如果源数据卷中的文件被更新了，快照系统中则保存着其创建快照时的版本。\n还原部分数据\n如果我们明确的知道需要还原某个文件，可以挂载快照数据卷，直接拷贝其中旧版本的文件即可。\n合并快照(merge snapshot)\n要将逻辑卷卷’lv' 恢复到创建快照’snap01’时的状态，即还原整个数据卷上的数据，请使用：\n# lvconvert --merge /dev/vg0/snap01 如果逻辑卷处于活动状态，则在下次重新启动时将进行合并（merging）(合并（merging）甚至可在LiveCD中进行)。\n注意： 合并后快照将被删除。\n可以拍摄多个快照，每个快照都可以任意与对应的逻辑卷合并。\n快照可以被挂载，并可用dd或者tar备份。使用dd备份的快照的大小为拍摄快照后对应逻辑卷中变更过文件的大小。 要使用备份，只需创建并挂载一个快照，并将备份写入或解压到其中。再将快照合并到对应逻辑卷即可。\n快照主要用于提供一个文件系统的拷贝，以用来备份; 比起直接备份分区，使用快照备份可以提供一个更符合原文件系统的镜像。\nZFS 历史 ZFS 是由 Matthew Ahrens 和 Jeff Bonwick 在 2001 年开发的。ZFS 是作为 Sun MicroSystem 公司的 OpenSolaris 的下一代文件系统而设计的。在 2008 年，ZFS 被移植到了 FreeBSD 。同一年，一个移植 ZFS on Linux 的项目也启动了。然而，由于 ZFS 是CDDL 许可的，它和 GPL 不兼容，因此不能将它迁移到 Linux 内核中。为了解决这个问题，绝大多数 Linux 发行版提供了一些方法来安装 ZFS　。\n在甲骨文公司收购太阳微系统公司之后不久，OpenSolaris 就闭源了，这使得 ZFS 的之后的开发也变成闭源的了。许多 ZFS 开发者对这件事情非常不满。三分之二的 ZFS 核心开发者，包括 Ahrens 和 Bonwick，因为这个决定而离开了甲骨文公司。他们加入了其它公司，并于 2013 年 9 月创立了 OpenZFS 这一项目。该项目引领着 ZFS 的开源开发。\n让我们回到上面提到的许可证问题上。既然 OpenZFS 项目已经和 Oracle 公司分离开了，有人可能好奇他们为什么不使用和 GPL 兼容的许可证，这样就可以把它加入到 Linux 内核中了。根据 OpenZFS 官网 的介绍，更改许可证需要联系所有为当前 OpenZFS 实现贡献过代码的人（包括初始的公共 ZFS 代码以及 OpenSolaris 代码），并得到他们的许可才行。这几乎是不可能的（因为一些贡献者可能已经去世了或者很难找到），因此他们决定保留原来的许可证。\n特性 正如前面所说过的，ZFS 是一个先进的文件系统。因此，它有一些有趣的特性。\n存储池 与大多数文件系统不同，ZFS 结合了文件系统和卷管理器的特性。这意味着，它与其他文件系统不同，ZFS 可以创建跨越一系列硬盘或池的文件系统。不仅如此，你还可以通过添加硬盘来增大池的存储容量。ZFS 可以进行分区和格式化。\n写时拷贝 Copy-on-write 是另一个有趣并且很酷的特性。在大多数文件系统上，当数据被重写时，它将永久丢失。而在 ZFS 中，新数据会写到不同的块。写完成之后，更新文件系统元数据信息，使之指向新的数据块（LCTT 译注：更新之后，原数据块成为磁盘上的垃圾，需要有对应的垃圾回收机制）。这确保了如果在写新数据的时候系统崩溃（或者发生其它事，比如突然断电），那么原数据将会保存下来。这也意味着，在系统发生崩溃之后，不需要运行 fsck 来检查和修复文件系统。\n快照 写时拷贝使得 ZFS 有了另一个特性：snapshots。ZFS 使用快照来跟踪文件系统中的更改。快照包含文件系统的原始版本（文件系统的一个只读版本），实时文件系统则包含了自从快照创建之后的任何更改。没有使用额外的空间。因为新数据将会写到实时文件系统新分配的块上。如果一个文件被删除了，那么它在快照中的索引也会被删除。所以，快照主要是用来跟踪文件的更改，而不是文件的增加和创建。\n快照可以挂载成只读的，以用来恢复一个文件的过去版本。实时文件系统也可以回滚到之前的快照。回滚之后，自从快照创建之后的所有更改将会丢失。\n数据完整性验证和自动修复 当向 ZFS 写入新数据时，会创建该数据的校验和。在读取数据的时候，使用校验和进行验证。如果前后校验和不匹配，那么就说明检测到了错误，然后，ZFS 会尝试自动修正错误。\nRAID-Z ZFS 不需要任何额外软件或硬件就可以处理 RAID（磁盘阵列）。毫不奇怪，因为 ZFS 有自己的 RAID 实现：RAID-Z 。RAID-Z 是 RAID-5 的一个变种，不过它克服了 RAID-5 的写漏洞：意外重启之后，数据和校验信息会变得不同步（LCTT 译注：RAID-5 的条带在正写入数据时，如果这时候电源中断，那么奇偶校验数据将跟该部分数据不同步，因此前边的写无效；RAID-Z 用了 “可变宽的 RAID 条带” 技术，因此所有的写都是全条带写入）。为了使用基本级别的 RAID-Z（RAID-Z1），你需要至少三块磁盘，其中两块用来存储数据，另外一块用来存储奇偶校验信息。而 RAID-Z2 需要至少两块磁盘存储数据以及两块磁盘存储校验信息。RAID-Z3 需要至少两块磁盘存储数据以及三块磁盘存储校验信息。另外，只能向 RAID-Z 池中加入偶数倍的磁盘，而不能是奇数倍的。\n巨大的存储潜力 创建 ZFS 的时候，它是作为最后一个文件系统而设计的 。那时候，大多数文件系统都是 64 位的，ZFS 的创建者决定直接跳到 128 位，等到将来再来证明这是对的。这意味着 ZFS 的容量大小是 32 位或 64 位文件系统的 1600 亿亿倍。事实上，Jeff Bonwick（其中一个创建者）说：“完全填满一个 128 位的存储池所需要的能量，从字面上讲，比煮沸海洋需要的还多。”\n如何安装 ZFS？ 如果你想立刻使用 ZFS（开箱即用），那么你需要安装 FreeBSD 或一个使用 illumos 内核的操作系统。illumos 是 OpenSolaris 内核的一个克隆版本。\n事实上，支持 ZFS 是一些有经验的 Linux 用户选择 BSD 的主要原因。\n如果你想在 Linux 上尝试 ZFS，那么只能在存储文件系统上使用。据我所知，没有任何 Linux 发行版可以在根目录上安装 ZFS，实现开箱即用。如果你对在 Linux 上尝试 ZFS 感兴趣，那么 ZFS on Linux 项目 上有大量的教程可以指导你怎么做。\n在 Ubuntu 上使用 ZFS 如果您正在考虑将 ZFS 用于您的超高速 NVMe SSD，这可能不是一个最佳选择。 它比别的文件系统要慢，不过，这完全没有问题， 它旨在存储大量的数据并保持安全。\n$ sudo apt-get install zfsutils-linux 创建池 在 ZFS 中，池大致相当于 RAID 。 它们很灵活且易于操作。\nRAID0\nRAID0 只是把你的硬盘集中到一个池子里面，就像一个巨大的驱动器一样。 它可以提高你的驱动器速度，（LCTT 译注：数据条带化后，并行访问，可以提高文件读取速度）但是如果你的驱动器有损坏，你可能会失丢失数据。\n在计算机数据存储中，数据条带化是一种对逻辑顺序数据（例如文件）进行分段的技术，以便将连续的段存储在不同的物理存储设备上。\n要使用 ZFS 实现 RAID0，只需创建一个普通的池。\n$ sudo zpool create your-pool /dev/sdc /dev/sdd RAID1（镜像）\n您可以在 ZFS 中使用 mirror 关键字来实现 RAID1 功能。 RAID1 会创建一个一对一的驱动器副本。 这意味着您的数据一直在备份。 它也提高了性能。 当然，你将一半的存储空间用于了复制。\n$ sudo zpool create your-pool mirror /dev/sdc /dev/sdd RAID5/RAIDZ1\nZFS 将 RAID5 功能实现为 RAIDZ1。 RAID5 要求驱动器至少是 3 个。并允许您通过将备份奇偶校验数据写入驱动器空间的 1/n（n 是驱动器数），留下的是可用的存储空间。 如果一个驱动器发生故障，阵列仍将保持联机状态，但应尽快更换发生故障的驱动器（LCTT 译注：与原文翻译略有不同，原文是驱动器的数目是三的倍数，根据 wiki， RAID5 至少需要 3 块驱动器，也可以从下面的命令中猜测)。\n$ sudo zpool create your-pool raidz1 /dev/sdc /dev/sdd /dev/sde RAID6/RAIDZ2\nRAID6 与 RAID5 几乎完全相同，但它至少需要四个驱动器。 它将奇偶校验数据加倍，最多允许两个驱动器损坏，而不会导致阵列关闭（LCTT 译注：这里也与原文略有出入，原文是驱动器的数目是四的倍数，根据 wiki ，RAID6 至少需要四个驱动器)。\n$ sudo zpool create your-pool raidz2 /dev/sdc /dev/sdd /dev/sde /dev/sdf RAID10（条带化镜像）\nRAID10 旨在通过数据条带化提高存取速度和数据冗余来成为一个两全其美的解决方案。 你至少需要四个驱动器，但只能使用一半的空间。 您可以通过在同一个池中创建两个镜像来创建 RAID10 中的池（LCTT 译注：这里也与原文略有出入，原文是驱动器的数目是四的倍数，根据 wiki， RAID10 至少需要四个驱动器）。\n$ sudo zpool create your-pool mirror /dev/sdc /dev/sdd mirror /dev/sde /dev/sdf 池的操作 还有一些管理工具，一旦你创建了你的池，你就必须使用它们来操作。 首先，检查你的池的状态。\n$ sudo zpool status 更新\n当你更新 ZFS 时，你也需要更新你的池。 当您检查它们的状态时，您的池会通知您任何更新。 要更新池，请运行以下命令。\n$ sudo zpool upgrade your-pool 你也可以更新全部池。\n$ sudo zpool upgrade -a 添加驱动器\n您也可以随时将驱动器添加到池中。 告诉 zpool 池的名称和驱动器的位置，它会处理好一切。\n$ sudo zpool add your-pool /dev/sdx 实例 使用两块硬盘上的等容量分区建立 raid 1。\n$ ls -l /dev/disk/by-id usb-JMicron_Generic_DISK00_0123456789ABCDEF-0:0-part1 - ../../sdb1 usb-JMicron_Generic_DISK01_0123456789ABCDEF-0:1-part2 - ../../sdc2 $ sudo zpool create -f -o ashift=12 -o cachefile=/etc/zfs/zpool.cache -O compression=lz4 -O xattr=sa -O relatime=on -O acltype=posixacl -O dedup=off -m none dpool mirror usb-JMicron_Generic_DISK00_0123456789ABCDEF-0:0-part1 usb-JMicron_Generic_DISK01_0123456789ABCDEF-0:1-part2 $ sudo zfs create -o mountpoint=none -o canmount=off dpool/DATA $ sudo zfs create -o mountpoint=/home/kurome/DataPool dpool/DATA/important $ sudo zpool export dpool $ sudo zpool import dpool udev 如果你使用Linux比较长时间了，那你就知道，在对待设备文件这块，Linux改变了几次策略。在Linux早期，设备文件仅仅是是一些带有适当的属性集的普通文件，它由mknod命令创建，文件存放在/dev目录下。后来，采用了devfs, 一个基于内核的动态设备文件系统，他首次出现在2.3.46内核中。Mandrake，Gentoo等Linux分发版本采用了这种方式。devfs创建 的设备文件是动态的。但是devfs有一些严重的限制，从2.6.13版本后移走了。目前取代他的便是文本要提到的udev－－一个用户空间程序。\n目前很多的Linux分发版本采纳了udev的方式，因为它在Linux设备访问，特别是那些对设备有极端需求的站点(比如需要控制上千个硬盘)和热插拔设备(比如USB摄像头和MP3播放器)上解决了几个问题。下面我我们来看看如何管理udev设备。\n实际上，对于那些为磁盘，终端设备等准备的标准配置文件而言，你不需要修改什么。但是，你需要了解udev配置来使用新的或者外来设备，如果不修改配置， 这些设备可能无法访问，或者说Linux可能会采用不恰当的名字，属组或权限来创建这些设备文件。你可能也想知道如何修改RS－232串口，音频设备等文件的属组或者权限。这点在实际的Linux实施中是会遇到的。\n为什么使用udev 在此之前的设备文件管理方法(静态文件和devfs)有几个缺点：\n 不确定的设备映射。特别是那些动态设备，比如USB设备，设备文件到实际设备的映射并不可靠和确定。举一个例子：如果你有两个USB打印机。一个可能称 为/dev/usb/lp0,另外一个便是/dev/usb/lp1。但是到底哪个是哪个并不清楚，lp0,lp1和实际的设备没有一一对应的关系，因为 他可能因为发现设备的顺序，打印机本身关闭等原因而导致这种映射并不确定。理想的方式应该是：两个打印机应该采用基于他们的序列号或者其他标识信息的唯一 设备文件来映射。但是静态文件和devfs都无法做到这点。 没有足够的主/辅设备号。我们知道，每一个设备文件是有两个8位的数字：一个是主设备号 ，另外一个是辅设备号来分配的。这两个8位的数字加上设备类型(块设备或者字符设备)来唯一标识一个设备。不幸的是，关联这些身边的的数字并不足够。 /dev目录下文件太多。一个系统采用静态设备文件关联的方式，那么这个目录下的文件必然是足够多。而同时你又不知道在你的系统上到底有那些设备文件是激活的。 命名不够灵活。尽管devfs解决了以前的一些问题，但是它自身又带来了一些问题。其中一个就是命名不够灵活；你别想非常简单的就能修改设备文件的名字。缺省的devfs命令机制本身也很奇怪，他需要修改大量的配置文件和程序。 内核内存使用，devfs特有的另外一个问题是，作为内核驱动模块，devfs需要消耗大量的内存，特别当系统上有大量的设备时(比如上面我们提到的系统一个上有好几千磁盘时)  udev的目标是想解决上面提到的这些问题，他通采用用户空间(user-space)工具来管理/dev/目录树，他和文件系统分开。知道如何改变缺省配置能让你之大如何定制自己的系统，比如创建设备字符连接，改变设备文件属组，权限等。\nudev配置文件 主要的udev配置文件是/etc/udev/udev.conf。这个文件通常很短，他可能只是包含几行#开头的注释，然后有几行选项：\nudev_root=“/dev/” udev_rules=“/etc/udev/rules.d/” udev_log=“err“ 上面的第二行非常重要，因为他表示udev规则存储的目录，这个目录存储的是以.rules结束的文件。每一个文件处理一系列规则来帮助udev分配名字给设备文件以保证能被内核识别。\n你的/etc/udev/rules.d下面可能有好几个udev规则文件，这些文件一部分是udev包安装的，另外一部分则是可能是别的硬件或者软件包 生成的。比如在Fedora Core 5系统上，sane-backends包就会安装60-libsane.rules文件，另外initscripts包会安装60-net.rules文 件。这些规则文件的文件名通常是两个数字开头，它表示系统应用该规则的顺序。\n规则文件里的规则有一系列的键/值对组成，键/值对之间用逗号(,)分割。每一个键或者是用户匹配键，或者是一个赋值键。匹配键确定规则是否被应用，而赋 值键表示分配某值给该键。这些值将影响udev创建的设备文件。匹配键和赋值键操作符解释见下表：\n   操作符 匹配或赋值 解释     == 匹配 相等比较   != 匹配 不等比较   = 赋值 分配一个特定的值给该键，他可以覆盖之前的赋值。   += 赋值 追加特定的值给已经存在的键   := 赋值 分配一个特定的值给该键，后面的规则不可能覆盖它。    这有点类似我们常见的编程语言，比如C语言。只是这里的键一次可以处理多个值。有一些键在udev规则文件里经常出现，这些键的值可以使用通配符(*,?,甚至范围，比如[0-9])，这些常用键列举如下：\n   键 含义     ACTION 一个时间活动的名字，比如add，当设备增加的时候   KERNEL 在内核里看到的设备名字，比如sd*表示任意SCSI磁盘设备   DEVPATH 内核设备路径，比如/devices/*   SUBSYSTEM 子系统名字，比如sound,net   BUS 总线的名字，比如IDE,USB   DRIVER 设备驱动的名字，比如ide-cdromID 独立于内核名字的设备名字   SYSFS{ value} sysfs属性值，他可以表示任意   ENV{ key} 环境变量，可以表示任意   PROGRAM 可执行的外部程序，如果程序返回0值，该键则认为为真(true)   RESULT 上一个PROGRAM调用返回的标准输出。   NAME 根据这个规则创建的设备文件的文件名。注意：仅仅第一行的NAME描述是有效的，后面的均忽略。 如果你想使用使用两个以上的名字来访问一个设备的话，可以考虑SYMLINK键。   SYMLINK 根据规则创建的字符连接名   OWNER 设备文件的属组   GROUP 设备文件所在的组。   MODE 设备文件的权限，采用8进制   RUN 为设备而执行的程序列表   LABEL 在配置文件里为内部控制而采用的名字标签(下下面的GOTO服务)   GOTO 跳到匹配的规则（通过LABEL来标识），有点类似程序语言中的GOTO   IMPORT{ type} 导入一个文件或者一个程序执行后而生成的规则集到当前文件   WAIT_FOR_SYSFS 等待一个特定的设备文件的创建。主要是用作时序和依赖问题。   PTIONS 特定的选项： last_rule 对这类设备终端规则执行； ignore_device 忽略当前规则； ignore_remove 忽略接下来的并移走请求。all_partitions 为所有的磁盘分区创建设备文件。    我们给出一个列子来解释如何使用这些键。下面的例子来自Fedora Core 5系统的标准配置文件。\nKERNEL==\"*\", OWNER=\"root\" GROUP=\"root\", MODE=\"0600\" KERNEL==\"tty\", NAME=\"%k\", GROUP=\"tty\", MODE=\"0666\", OPTIONS=\"last_rule\" KERNEL==\"scd[0-9]*\", SYMLINK+=\"cdrom cdrom-%k\" KERNEL==\"hd[a-z]\", BUS==\"ide\", SYSFS{removable}==\"1\", SYSFS{device/media}==\"cdrom\", SYMLINK+=\"cdrom cdrom-%k\" ACTION==\"add\", SUBSYSTEM==\"scsi_device\", RUN+=\"/sbin/modprobe sg\" 上面的例子给出了5个规则，每一个都是KERNEL或者ACTION键开头：\n 第一个规则是缺省的，他匹配任意被内核识别到的设备，然后设定这些设备的属组是root，组是root，访问权限模式是0600(-rw——-)。这也是一个安全的缺省设置保证所有的设备在默认情况下只有root可以读写 第二个规则也是比较典型的规则了。它匹配终端设备(tty)，然后设置新的权限为0600，所在的组是tty。它也设置了一个特别的设备文件名:%K。在这里例子里，%k代表设备的内核名字。那也就意味着内核识别出这些设备是什么名字，就创建什么样的设备文件名。 第三行开始的KERNEL==”scd[0-9]*”,表示 SCSI CD-ROM 驱动. 它创建一对设备符号连接：cdrom和cdrom-%k。 第四行，开始的 KERNEL==”hd[a-z]“, 表示ATA CDROM驱动器。这个规则创建和上面的规则相同的符号连接。ATA CDROM驱动器需要sysfs值以来区别别的ATA设备，因为SCSI CDROM可以被内核唯一识别。. 第五行以 ACTION==”add”开始，它告诉udev增加 /sbin/modprobe sg 到命令列表，当任意SCSI设备增加到系统后，这些命令将执行。其效果就是计算机应该会增加sg内核模块来侦测新的SCSI设备。  当然，上面仅仅是一小部分例子，如果你的系统采用了udev方式，那你应该可以看到更多的规则。如果你想修改设备的权限或者创建信的符号连接，那么你需要熟读这些规则，特别是要仔细注意你修改的那些与之相关的设备。\n修改你的udev配置 在修改udev配置之前，我们一定要仔细，通常的考虑是：你最好不要修改系统预置的那些规则，特别不要指定影响非常广泛的配置，比如上面例子中的第一行。不正确的配置可能会导致严重的系统问题或者系统根本就无法这个正确的访问设备。\n而我们正确的做法应该是在/etc/udev/rules.d/下创建一个新的规则文件。确定你给出的文件的后缀是rules文件名给出的数字序列应该比标准配置文件高。比如，你可以创建一个名为99-my-udev.rules的规则文件。在你的规则文件中，你可以指定任何你想修改的配置，比如，假设你 修改修改floppy设备的所在组，还准备创建一个新的符号连接/dev/floppy，那你可以这么写：\nKERNEL==”fd[0-9]*“, GROUP=“users“, SYMLINK+=“floppy“ 有些发行版本，比如Fedora，采用了外部脚本来修改某些特定设备的属组，组关系和权限。因此上面的改动可能并不见得生效。如果你遇到了这个问题，你就需要跟踪和修改这个脚本来达到你的目的。或者你可以修改PROGRAM或RUN键的值来做到这点。\n某些规则的修改可能需要更深的挖掘。比如，你可能想在一个设备上使用sysfs信息来唯一标识一个设备。这些信息最好通过udevinfo命令来获取。\n$ udevinfo –a –p $(udevinfo –q path –n /dev/hda) 上面的命令两次使用udevinfo：一次是返回sysfs设备路径(他通常和我们看到的Linux设备文件名所在路径－－/dev/hda－－不同)；第 二次才是查询这个设备路径，结果将是非常常的syfs信息汇总。你可以找到最够的信息来唯一标志你的设备，你可以采用适当的替换udev配置文件中的 SYSFS选项。下面的结果就是上面的命令输出\n[root@localhost rules.d]# udevinfo -a -p $(udevinfo -q path -n /dev/hda1) Udevinfo starts with the device specified by the devpath and then walks up the chain of parent devices. It prints for every device found,all possible attributes in the udev rules key format. A rule to match, can be composed by the attributes of the device and the attributes from one single parent device. looking at device '/block/hda/hda1': KERNEL==\"hda1\" SUBSYSTEM==\"block\" DRIVER==\"\" ATTR{stat}==\" 1133 2268 2 4\" ATTR{size}==\"208782\" ATTR{start}==\"63\" ATTR{dev}==\"3:1\" looking at parent device '/block/hda': KERNELS==\"hda\" SUBSYSTEMS==\"block\" DRIVERS==\"\" ATTRS{stat}==\"28905 18814 1234781 302540 34087 133247 849708 981336 0 218340 1283968\" ATTRS{size}==\"117210240\" ATTRS{removable}==\"0\" ATTRS{range}==\"64\" ATTRS{dev}==\"3:0\" looking at parent device '/devices/pci0000:00/0000:00:1f.1/ide0/0.0': KERNELS==\"0.0\" SUBSYSTEMS==\"ide\" DRIVERS==\"ide-disk\" ATTRS{modalias}==\"ide:m-disk\" ATTRS{drivename}==\"hda\" ATTRS{media}==\"disk\" looking at parent device '/devices/pci0000:00/0000:00:1f.1/ide0': KERNELS==\"ide0\" SUBSYSTEMS==\"\" DRIVERS==\"\" looking at parent device '/devices/pci0000:00/0000:00:1f.1': KERNELS==\"0000:00:1f.1\" SUBSYSTEMS==\"pci\" DRIVERS==\"PIIX_IDE\" ATTRS{broken_parity_status}==\"0\" ATTRS{enable}==\"1\" ATTRS{modalias}==\"pci:v00008086d000024CAsv0000144Dsd0000C009bc01sc01i8a\" ATTRS{local_cpus}==\"1\" ATTRS{irq}==\"11\" ATTRS{class}==\"0x01018a\" ATTRS{subsystem_device}==\"0xc009\" ATTRS{subsystem_vendor}==\"0x144d\" ATTRS{device}==\"0x24ca\" ATTRS{vendor}==\"0x8086\" looking at parent device '/devices/pci0000:00': KERNELS==\"pci0000:00\" SUBSYSTEMS==\"\" DRIVERS==\"\" 举一个例子：假设你想修改USB扫描仪的配置。通过一系列的尝试，你已经为这个扫描仪标识了Linux设备文件(每次打开扫描仪时，名字都会变)。你可以使 用上面的命令替换这个正确的Linux设备文件名，然后定位输出的采用SYSFS{idVendor}行和SYSFS{idProduct}行。最后你可 以使用这些信息来为这个扫描仪创建新的选项。\nSYSFS{idVendor}==\"0686\", SYSFS{idProduct}==\"400e\", SYMLINK+=\"scanner\", MODE=\"0664\", group=\"scanner\" 上面的例子表示将扫描仪的组设置为scanner，访问权限设置为0664,同时创建一个/dev/scanner的符号连接。\nMounting usb automatically \u0026 having usb’s label as mountpoint Note for Ubuntu Server 11.10: This script fails on Ubuntu Server 11.10 due to the obsolete vol_id command. vol_id has been superseded by blkid. To fix the script, replace “vol_id” by “blkid -o udev” in the udev-auto-mount.sh script.\nI’ve been banging my head around this for a while now, and I think I’ve found a working solution. This is developed and tested on a Debian-based system, so it should work on Ubuntu. I’ll point out the assumptions it makes so it can be adapted to other systems as well.\n It will automatically mount USB drives on plugin, and shouldn’t take much to adapt for Firewire. It uses UDEV, so no monkeying with HAL/DeviceKit/GNOME-Anything. It automagically creates a /media/LABEL directory to mount the device to. However, it may interfere with other automounters; I can’t test for that. I expect that, with Gnome-VFS active, both may try to do the mount … if Gnome-VFS fails the mount, it might not configure a desktop icon. Unmounting from Gnome should be possible, but might require gksudo or similar.  I have not tested this on system boot, but the only reason I can see that it might not work is if it tries to mount the USB drive before the system is ready for mounts. If that’s the case, you’ll probably need one additional tweak to the mount script. (I’m checking with ServerFault to see if there’s any advice, but not much interest in it over there.)\nOn to it, then.\nUDEV references  Writing udev Rules (the reference for udev rules) man udev (see your system for the latest version) man udevadm (udev admin tool; again see your system for latest) Backup to USB drive on mount (completely different problem, but helpful for understanding the solution)  Background (UDEV? Whuzzat?) UDEV is the kernel’s hotplug system. It’s what automagically configures the proper devices and device symlinks (eg /dev/disk/by-label/), both at boot time and for devices added while the system is running.\nD-Bus and HAL are used for sending hardware events to listeners like Desktop Environments. So when you log into GNOME and insert a CD or plug in a USB drive, that event follows this chain:\nkernel - udev - dbus - hal - gnome-vfs/nautilus (mount) And presto, your drive gets mounted. But in a headless system, we don’t want to have to log in to get the benefits of automounting.\nUdev Rules Since UDEV lets us write rules and run programs on device insertion, this is an ideal choice. We’re going to take advantage of Debian/Ubuntu’s existing rules, let them setup the /dev/disk/by-label/ symlink for us, and add another rule that will mount the device for us.\nUDEV’s rules are kept in /etc/udev/rules.d (and /lib/udev/rules.d on Karmic), and are processed in numerical order. Any file not starting with a number gets processed after the numbered files. On my system, HAL rules are in a file called 90-hal.rules, so I put my rules in 89-local.rules so they get processed before they get to HAL. Primarily, you need to make sure these rules happen after the 60-persistent-storage.rules. local.rules may be good enough.\nPut this in your new rules file:\n# /etc/udev/rules.d/local.rules # /etc/udev/rules.d/89-local.rules # ADD rule: if we have a valid ID_FS_LABEL_ENC, and it's USB, mkdir and mount ENV{ID_FS_LABEL_ENC}==\"?*\", ACTION==\"add\", SUBSYSTEMS==\"usb\", \\ RUN+=\"/usr/local/sbin/udev-automounter.sh %k\"  Make sure there’s no spaces after the \\, just a newline (\\n). Change SUBSYSTEMS==\"usb\" to SUBSYSTEMS==\"usb|ieee1394\" for Firewire support. If you want the device to always be owned by a particular user, add an OWNER=\"username\" clause. If you just need the files owned by a particular user, tweak the mount script instead.  Reading the Rule\nThis adds a program to run to the device’s list of programs to run. It identifies USB partition devices by , then passes this information to a script that performs the mount. Specifically, this rule is matching:\n  ENV{ID_FS_LABEL_ENC}==\"?\\*\" – an environment variable set by an earlier system rule. Doesn’t exist for non-filesystems, so that’s why we check for it. We actually want to use ID_FS_LABEL for the mount point, but I haven’t convinced UDEV to escape it for me, so we’ll let the mount script handle that.\nThis and other environment variables are obtained by udev using the vol_id command (deprecated). It’s a handy tool to see nice quick details on a partition:\n$ sudo vol_id /dev/sdc1 ID_FS_TYPE=ext2 ID_FS_UUID=a40d282a-4a24-4593-a0ab-6f2600f920dd ID_FS_LABEL=Travel Dawgs ID_FS_LABEL_ENC=Travel\\x20Dawgs ID_FS_LABEL_SAFE=Travel_Dawgs   ACTION==\"add\" – only match add events…\n  SUBSYSTEMS==\"usb\" – only match devices that are on the USB bus. We use SUBSYSTEMS here because this matches against our device’s parents; the device we’re interested in will actually be SUBSYSTEM==“scsi”. Matching against a parent USB device avoids adding our program to the internal drives.\n  RUN+=\"...\" – not a match, but an action: add this program to the list of programs to run. In the program’s arguments, %k gets expanded to the device name (eg sdc1, not /dev/sdc1) and $env{FOO} gets the contents of environment variable FOO.\n  Testing the Rule\nThe first reference link (above) is an excellent UDEV tutorial, but it’s slightly out of date. The programs it runs for testing your rules (udevtest in particular) have been replaced by the catch-all udevadm utility.\nAfter you’ve added the rule, plug in your device. Give it a few seconds, then check to see what device it’s been assigned to with:\n$ ls -l /dev/disk/by-label/* lrwxrwxrwx 1 root root 10 2009-10-25 07:27 label_Foo - ../../sda1 lrwxrwxrwx 1 root root 10 2009-10-25 07:27 label_Bar - ../../sdb1 lrwxrwxrwx 1 root root 10 2009-10-25 07:27 label_Baz - ../../sdc1 If your removeable drive contains label_Baz, it’s on device sdc1. Run this and look at the output towards the end:\n$ sudo udevadm test /sys/block/sdc/sdc1 parse_file: reading (...) (many lines about files it reads) import_uevent_var: import into environment: (...) (many lines about env variables) (...) (many lines tracing rule matches \u0026 programs run) update_link: found 1 devices with name 'disk/by-label/LABEL_BAZ' update_link: found '/block/sdc/sdc1' for 'disk/by-label/LABEL_BAZ' update_link: compare (our own) priority of '/block/sdc/sdc1' 0 = 0 update_link: 'disk/by-label/LABEL_BAZ' with target 'sdc1' has the highest priority 0, create it udevtest: run: '/usr/local/sbin/udev-automounter.sh sdc1 LABEL_BAZ' udevtest: run: 'socket:/org/freedesktop/hal/udev_event' udevtest: run: 'socket:@/org/kernel/udev/monitor' Look for the script name from our RUN+= rule in the last few lines (3rd from the bottom in this example). You can see the arguments that would be used for this device. You can run that command now to check that the arguments are sound; if it works on your commandline, it should work automatically when a device is inserted.\nYou can also monitor UDEV events in realtime: run sudo udevadm monitor (see man udevadm for details on the switches). Then just plug in a new device and watch events scroll by. (Probably overkill unless you’re into really low-level details…)\nReloading the Rules\nOnce you’ve verified the rule is getting read properly, you need to tell UDEV to reload its rules so the new one takes effect. Use any of these methods (if the first doesn’t work, the second should… but try the first first):\n run sudo udevadm control --reload-rules run sudo /etc/init.d/udev reload reboot  Script! Actually, 2 Scripts… Here’s the first script. Since the program we run needs to complete quickly, this just spins the second script off in the background. Put this in /usr/local/sbin/udev-automounter.sh:\n#!/bin/sh # # USAGE: usb-automounter.sh DEVICE # DEVICE is the actual device node at /dev/DEVICE /usr/local/sbin/udev-auto-mount.sh ${1} \u0026 Here’s the second script. This does a bit more input checking. Put this in /usr/local/sbin/udev-auto-mount.sh. You may want to tweak the mount options below. This script now handles finding the partition LABEL on its own; UDEV only sends the DEVICE name.\nIf there’s a problem mounting drives at boot-time, you can put a nice long sleep 60 in this script, to give the system time to come all the way up before the script attempts to mount the drive.\nI’ve given a suggestion in the comments for how to check (run ps to see if a webserver is running), but you’ll want to tweak that for your system. I think most any network servers you might be using would suffice for this purpose – nfsd, smbd, apache, etc. The risk, of course, is that the mount script will fail if the service isn’t running, so maybe testing a particular file’s existence would be a better solution.\n#!/bin/sh # # USAGE: udev-auto-mount.sh DEVICE # DEVICE is the actual device node at /dev/DEVICE # # This script takes a device name, looks up the partition label and # type, creates /media/LABEL and mounts the partition. Mount options # are hard-coded below. DEVICE=$1 # check input if [ -z \"$DEVICE\" ]; then exit 1 fi # test that this device isn't already mounted device_is_mounted=`grep ${DEVICE} /etc/mtab` if [ -n \"$device_is_mounted\" ]; then echo \"error: seems /dev/${DEVICE} is already mounted\" exit 1 fi # If there's a problem at boot-time, this is where we'd put # some test to check that we're booting, and then run # sleep 60 # so the system is ready for the mount below. # # An example to experiment with: # Assume the system is \"booted enough\" if the HTTPD server is running. # If it isn't, sleep for half a minute before checking again. # # The risk: if the server fails for some reason, this mount script # will just keep waiting for it to show up. A better solution would # be to check for some file that exists after the boot process is complete. # # HTTPD_UP=`ps -ax | grep httpd | grep -v grep` # while [ -z \"$HTTPD_UP\" ]; do # sleep 30 # HTTPD_UP=`ps -ax | grep httpd | grep -v grep` # done # pull in useful variables from vol_id, quote everything Just In Case eval `/sbin/vol_id /dev/${DEVICE} | sed 's/^/export /; s/=/=\"/; s/$/\"/'` if [ -z \"$ID_FS_LABEL\" ] || [ -z \"$ID_FS_TYPE\" ]; then echo \"error: ID_FS_LABEL is empty! did vol_id break? tried /dev/${DEVICE}\" exit 1 fi # test mountpoint - it shouldn't exist if [ ! -e \"/media/${ID_FS_LABEL}\" ]; then # make the mountpoint mkdir \"/media/${ID_FS_LABEL}\" # mount the device # # If expecting thumbdrives, you probably want # mount -t auto -o sync,noatime [...] # # If drive is VFAT/NFTS, this mounts the filesystem such that all files # are owned by a std user instead of by root. Change to your user's UID # (listed in /etc/passwd). You may also want \"gid=1000\" and/or \"umask=022\", eg: # mount -t auto -o uid=1000,gid=1000 [...] # # case \"$ID_FS_TYPE\" in vfat) mount -t vfat -o sync,noatime,uid=1000 /dev/${DEVICE} \"/media/${ID_FS_LABEL}\" ;; # I like the locale setting for ntfs ntfs) mount -t auto -o sync,noatime,uid=1000,locale=en_US.UTF-8 /dev/${DEVICE} \"/media/${ID_FS_LABEL}\" ;; # ext2/3/4 don't like uid option ext*) mount -t auto -o sync,noatime /dev/${DEVICE} \"/media/${ID_FS_LABEL}\" ;; esac # all done here, return successful exit 0 fi exit 1 Super Bonus Cleanup Script! One more script. All this does is unmount the device and remove the mountpoint directories. It assumes it has privs to do this, so you’ll need to run it with sudo. This script now takes the full mountpoint on the commandline, eg:\n$ /usr/local/sbin/udev-unmounter.sh \"/media/My Random Disk\" Put this in /usr/local/sbin/udev-unmounter.sh:\n#!/bin/sh # # USAGE: udev-unmounter.sh MOUNTPT # MOUNTPT is a mountpoint we want to unmount and delete. MOUNTPT=\"$1\" if [ -z \"$MOUNTPT\" ]; then exit 1 fi # test mountpoint - it should exist if [ -e \"${MOUNTPT}\" ]; then # very naive; just run and pray umount -l \"${MOUNTPT}\" \u0026\u0026 rmdir \"${MOUNTPT}\" \u0026\u0026 exit 0 echo \"error: ${MOUNTPT} failed to unmount.\" exit 1 fi echo \"error: ${MOUNTPT} does not exist\" exit 1 Systemd LINUX PID 1 和 SYSTEMD 要说清 Systemd，得先从Linux操作系统的启动说起。Linux 操作系统的启动首先从 BIOS 开始，然后由 Boot Loader 载入内核，并初始化内核。内核初始化的最后一步就是启动 init 进程。这个进程是系统的第一个进程，PID 为 1，又叫超级进程，也叫根进程。它负责产生其他所有用户进程。所有的进程都会被挂在这个进程下，如果这个进程退出了，那么所有的进程都被 kill 。如果一个子进程的父进程退了，那么这个子进程会被挂到 PID 1 下面。（注：PID 0 是内核的一部分，主要用于内进换页，参看：Process identifier）\nSysV Init PID 1 这个进程非常特殊，其主要就任务是把整个操作系统带入可操作的状态。比如：启动 UI – Shell 以便进行人机交互，或者进入 X 图形窗口。传统上，PID 1 和传统的 Unix System V 相兼容的，所以也叫 sysvinit，这是使用得最悠久的 init 实现。Unix System V 于1983年 release。\n在 sysvint 下，有好几个运行模式，又叫 runlevel。比如：常见的 3 级别指定启动到多用户的字符命令行界面，5 级别指定启起到图形界面，0 表示关机，6 表示重启。其配置在 /etc/inittab 文件中。\n与此配套的还有 /etc/init.d/ 和 /etc/rc[X].d，前者存放各种进程的启停脚本（需要按照规范支持 start，stop子命令），后者的 X 表示不同的 runlevel 下相应的后台进程服务，如：/etc/rc3.d 是 runlevel=3 的。 里面的文件主要是 link 到 /etc/init.d/ 里的启停脚本。其中也有一定的命名规范：S 或 K 打头的，后面跟一个数字，然后再跟一个自定义的名字，如：S01rsyslog，S02ssh。S 表示启动，K表示停止，数字表示执行的顺序。\nUpStart Unix 和 Linux 在 sysvint 运作多年后，大约到了2006年的时候，Linux内核进入2.6时代，Linux有了很多更新。并且，Linux开始进入桌面系统，而桌面系统和服务器系统不一样的是，桌面系统面临频繁重启，而且，用户会非常频繁的使用硬件的热插拔技术。于是，这些新的场景，让 sysvint 受到了很多挑战。\n比如，打印机需要CUPS等服务进程，但是如果用户没有打机印，启动这个服务完全是一种浪费，而如果不启动，如果要用打印机了，就无法使用，因为sysvint 没有自动检测的机制，它只能一次性启动所有的服务。另外，还有网络盘挂载的问题。在 /etc/fstab 中，负责硬盘挂载，有时候还有网络硬盘（NFS 或 iSCSI）在其中，但是在桌面机上，有很可能开机的时候是没有网络的， 于是网络硬盘都不可以访问，也无法挂载，这会极大的影响启动速度。sysvinit 采用 netdev 的方式来解决这个问题，也就是说，需要用户自己在 /etc/fstab 中给相应的硬盘配置上 netdev 属性，于是 sysvint 启动时不会挂载它，只有在网络可用后，由专门的 netfs 服务进程来挂载。这种管理方式比较难以管理，也很容易让人掉坑。\n所以，Ubuntu 开发人员在评估了当时几个可选的 init 系统后，决定重新设计这个系统，于是，这就是我们后面看到的 upstart 。 upstart 基于事件驱动的机制，把之前的完全串行的同步启动服务的方式改成了由事件驱动的异步的方式。比如：如果有U盘插入，udev 得到通知，upstart 感知到这个事件后触发相应的服务程序，比如挂载文件系统等等。因为使用一个事件驱动的玩法，所以，启动操作系统时，很多不必要的服务可以不用启动，而是等待通知，lazy 启动。而且事件驱动的好处是，可以并行启动服务，他们之间的依赖关系，由相应的事件通知完成。\nupstart 有着很不错的设计，其中最重要的两个概念是 Job 和 Event。\nJob 有一般的Job，也有service的Job，并且，upstart 管理了整个 Job 的生命周期，比如：Waiting, Starting, pre-Start, Spawned, post-Start, Running, pre-Stop, Stopping, Killed, post-Stop等等，并维护着这个生命周期的状态机。\nEvent 分成三类，signal, method 和 hooks。signal 就是异步消息，method 是同步阻塞的。hooks 也是同步的，但介于前面两者之间，发出hook事件的进程必须等到事件完成，但不检查是否成功。\n但是，upstart 的事件非常复杂，也非常纷乱，各种各样的事件（事件没有归好类）导致有点凌乱。不过因为整个事件驱动的设计比之前的 sysvinit 来说好太多，所以，也深得欢迎。\nSystemd 直到2010的有一天，一个在 RedHat工作的工程师 Lennart Poettering 和 Kay Sievers ，开始引入了一个新的 init 系统—— systemd。这是一个非常非常有野心的项目，这个项目几乎改变了所有的东西，systemd 不但想取代已有的 init 系统，而且还想干更多的东西。\nLennart 同意 upstart 干的不错，代码质量很好，基于事件的设计也很好。但是他觉得 upstart 也有问题，其中最大的问题还是不够快，虽然 upstart 用事件可以达到一定的启动并行度，但是，本质上来说，这些事件还是会让启动过程串行在一起。 如：NetworkManager 在等 D-Bus 的启动事件，而 D-Bus 在等 syslog 的启动事件。\nLennart 认为，实现上来说，upstart 其实是在管理一个逻辑上的服务依赖树，但是这个服务依赖树在表现形式上比较简单，你只需要配置——“启动 B好了就启动A”或是“停止了A后就停止B”这样的规则。但是，Lennart 说，这种简单其实是有害的（this simplification is actually detrimental）。他认为，\n  从一个系统管理的角度出来，他一开始会设定好整个系统启动的服务依赖树，但是这个系统管理员要人肉的把这个本来就非常干净的服务依整树给翻译成计算机看的懂的 Event/Action 形式，而且 Event/Action 这种配置方式是运行时的，所以，你需要运行起来才知道是什么样的。\n  Event逻辑从头到脚到处都是，这个事件扩大了运维的复杂度，还不如之前的 sysvint。 也就是说，当用户配置了 “启动 D-Bus 后请启动 NetworkManager”， 这个 upstart 可以干，但是反过来，如果，用户启动 NetworkManager，我们应该先去启动他的前置依赖 D-Bus，然而你还要配置相应的反向 Event。本来，我只需要配置一条依赖的，结果现在我要配置很多很多情况下的Event。\n  最后，upstart 里的 Event 的并不标准，很混乱，没有良好的定义。比如：既有，进程启动，运行，停止的事件，也有USB设备插入、可用、拔出的事件，还有文件系统设备being mounted、 mounted 和 umounted 的事件，还有AC电源线连接和断开的事件。你会发现，这进程启停的、USB的、文件系统的、电源线的事件，看上去长得很像， 但是没有被标准化抽像出来掉，因为绝大多数的事件都是三元组：start, condition, stop 。这种概念设计模型并没有在 upstart 中出现。因为 upstart 被设计为单一的事件，而忽略了逻辑依赖。\n  当然，如果 systemd 只是解决 upstart 的问题，他就改造 upstart 就好了，但是 Lennart 的野心不只是想干个这样的事，他想干的更多。\n首先，systemd 清醒的认识到了 init 进程的首要目标是要让用户快速的进入可以操作OS的环境，所以，这个速度一定要快，越快越好，所以，systemd 的设计理念就是两条：\n To start less. And to start more in parallel.  也就是说，按需启动，能不启动就不启动，如果要启动，能并行启动就并行启动，包括你们之间有依赖，我也并行启动。按需启动还好理解，那么，有依赖关系的并行启动，它是怎么做到的？这里，systemd 借鉴了 MacOS 的 Launchd 的玩法（在Youtube上有一个分享——Launchd: One Program to Rule them All，在苹果的开源网站上也有相关的设计文档——About Daemons and Services）\n要解决这些依赖性，systemd 需要解决好三种底层依赖—— Socket， D-Bus ，文件系统。\n  Socket依赖。如果服务C依赖于服务S的socket，那么就要先启动S，然后再启动C，因为如果C启动时找不到S的Socket，那么C就会失败。systemd 可以帮你在S还没有启动好的时候，建立一个socket，用来接收所有的C的请求和数据，并缓存之，一旦S全部启动完成，把systemd替换好的这个缓存的数据和Socket描述符替换过去。\n  D-Bus依赖。D-Bus 全称 Desktop Bus，是一个用来在进程间通信的服务。除了用于用户态进程和内核态进程通信，也用于用户态的进程之前。现在，很多的现在的服务进程都用 D-Bus 而不是Socket来通信。比如：NetworkManager 就是通过 D-Bus 和其它服务进程通讯的，也就是说，如果一个进程需要知道网络的状态，那么就必需要通过 D-Bus 通信。D-Bus 支持 “Bus Activation”的特性。也就是说，A要通过 D-Bus 服务和B通讯，但是B没有启动，那么 D-Bus 可以把B起来，在B启动的过程中，D-Bus 帮你缓存数据。systemd 可以帮你利用好这个特性来并行启动 A 和 B。\n  文件系统依赖。系统启动过程中，文件系统相关的活动是最耗时的，比如挂载文件系统，对文件系统进行磁盘检查（fsck），磁盘配额检查等都是非常耗时的操作。在等待这些工作完成的同时，系统处于空闲状态。那些想使用文件系统的服务似乎必须等待文件系统初始化完成才可以启动。systemd 参考了 autofs 的设计思路，使得依赖文件系统的服务和文件系统本身初始化两者可以并发工作。autofs 可以监测到某个文件系统挂载点真正被访问到的时候才触发挂载操作，这是通过内核 automounter 模块的支持而实现的。比如一个 open() 系统调用作用在某个文件系统上的时候，而这个文件系统尚未执行挂载，此时 open() 调用被内核挂起等待，等到挂载完成后，控制权返回给 open() 系统调用，并正常打开文件。这个过程和 autofs 是相似的。\n  下图来自 Lennart 的演讲里的一页PPT，展示了不同 init 系统的启动。\n除此之外，systemd 还在启动时管理好了一些下面的事。\n用C语言取代传统的脚本式的启动。前面说过，sysvint 用 /etc/rcX.d 下的各种脚本启动。然而这些脚本中需要使用 awk, sed, grep, find, xargs 等等这些操作系统的命令，这些命令需要生成进程，生成进程的开销很大，关键是生成完这些进程后，这个进程就干了点屁大的事就退了。换句话说就是，我操作系统干了那么多事为你拉个进程起来，结果你就把个字串转成小写就退了，把我操作系统当什么了？\n在正常的一个 sysvinit 的脚本里，可能会有成百上千个这样的命令。所以，慢死。因此，systemd 全面用 C 语言全部取代了。一般来说，sysvinit 下，操作系统启动完成后，用 echo $$ 可以看到，pid 被分配到了上千的样子，而 systemd 的系统只是上百。\n另外，systemd 是真正一个可以管住服务进程的——可以跟踪上服务进程所fork/exec出来的所有进程。\n  我们知道， 传统 Unix/Linux 的 Daemon 服务进程的最佳实践基本上是这个样子的（具体过程可参看这篇文章“[SysV Daemon](http://0pointer.de/public/systemd-man/daemon.html#SysV Daemons)”）\n 进程启动时，关闭所有的打开的文件描述符（除了标准描述符0,1,2），然后重置所有的信号处理。 调用 fork() 创建子进程，在子进程中 setsid()，然后父进程退出（为了后台执行） 在子进程中，再调用一次 fork()，创建孙子进程，确定没有交互终端。然后子进程退出。 在孙子进程中，把标准输入标准输出标准错误都连到 /dev/null 上，还要创建 pid 文件，日志文件，处理相关信号 …… 最后才是真正开始提供服务。    在上面的这个过程中，服务进程除了两次 fork 外还会 fork 出很多很多的子进程（比如说一些Web服务进程，会根据用户的请求链接来 fork 子进程），这个进程树是相当难以管理的，因为，一旦父进程退出来了，子进程就会被挂到 PID 1下，所以，基本上来说，你无法通过服务进程自已给定的一个pid文件来找到所有的相关进程（这个对开发者的要求太高了），所以，在传统的方式下用脚本启停服务是相当相当的 Buggy 的，因为无法做对所有的服务生出来的子子孙孙做到监控。\n  为了解决这个问题，upstart 通过变态的 strace 来跟踪进程中的 fork() 和 exec() 或 exit() 等相关的系统调用。这种方法相当笨拙。 systemd 使用了一个非常有意思的玩法来 tracking 服务进程生出来的所有进程，那就是用 cgroup （我在 Docker 的基础技术“cgroup篇”中讲过这个东西）。cgroup主要是用来管理进程组资源配额的事，所以，无论服务如何启动新的子进程，所有的这些相关进程都会同属于一个 cgroup，所以，systemd 只需要简单的去遍历一下相应的 cgroup 的那个虚文件系统目录下的文件，就可以正确的找到所有的相关进程，并将他们一一停止。\n  另外，systemd 简化了整个 daemon 开发的过程：\n 不需要两次 fork()，只需要实现服务本身的主逻辑就可以了。 不需要 setsid()，systemd 会帮你干 不需要维护 pid文件，systemd 会帮处理。 不需要管理日志文件或是使用syslog，或是处理HUP的日志reload信号。把日志打到 stderr 上，systemd 帮你管理。 处理 SIGTERM 信号，这个信号就是正确退出当前服务，不要做其他的事。 ……  除此之外，systemd 还能——\n 自动检测启动的服务间有没有环形依赖。 内建 autofs 自动挂载管理功能。 日志服务。systemd 改造了传统的 syslog 的问题，采用二进制格式保存日志，日志索引更快。 快照和恢复。对当前的系统运行的服务集合做快照，并可以恢复。 ……  还有好多好多，他接管很多很多东西，于是就让很多人不爽了，因为他在干了很多本不属于 PID 1 的事。\nSystemd 争论和八卦 于是 systemd 这个东西成了可能是有史以来口水战最多的一个开源软件了。systemd 饱受各种争议，最大的争议就是他破坏了 Unix 的设计哲学（相关的哲学可以读一下《Unix编程艺术》），干了一个大而全而且相当复杂的东西。当然，Lennart 并不同意这样的说法，他后来又写一篇blog “The Biggest Myths”来解释 systemd 并不是这样的，大家可以前往一读。\n这个争议大到什么样子呢？2014 年，Debian Linux 因为想准备使用 systemd 来作为标准的 init 守护进程来替换 sysvinit 。而围绕这个事的争论达到了空前的热度，争论中充满着仇恨，systemd 的支持者和反对者都在互相辱骂，导致当时 Debian 阵营开始分裂。还有人给 Lennart 发了死亡威胁的邮件，用比特币雇凶买杀手，扬言要取他的性命，在Youbute上传了侮辱他的歌曲，在IRC和各种社交渠道上给他发下流和侮辱性的消息。这已经不是争议了，而是一种不折不扣的仇恨！\n于是，Lennart 在 Google Plus 上发了贴子，批评整个 Linux 开源社区和 Linus 本人。他大意说，\n 这个社区太病态了，全是 ass holes，你们不停用各种手段在各种地方用不同的语言和方式来侮辱和漫骂我。我还是一个年轻人，我从来没有经历过这样的场面，但是今天我已经对这种场面很熟悉了。我有时候说话可能不准确，但是我不会像他样那样说出那样的话，我也没有被这些事影响，因为我脸皮够厚，所以，为什么我可以在如何大的反对声面前让 systemd 成功，但是，你们 Linux 社区太可怕了。你们里面的有精神病的人太多了。另外，对于Linus Torvalds，你是这个社区的 Role Model，但可惜你是一个 Bad Role Model，你在社区里的刻薄和侮辱性的言行，基本从一定程度上鼓励了其它人跟你一样，当然，并不只是你一个人的问题，而是在你周围聚集了一群和你一样的这样干的人。送你一句话—— A fish rots from the head down ！一条鱼是从头往下腐烂的……\n 这篇契文很长，喜欢八卦的同学可以前往一读。感受一下 Lennart 当时的心态（我觉得能算上是非常平稳了）。\nLinus也在被一媒体问起 systemd 这个事来（参看“Torvalds says he has no strong opinions on systemd”），Linus在采访里说，\n 我对 systemd 和 Lennart 的贴子没有什么强烈的想法。虽然，传统的 Unix 设计哲学—— “Do one thing and Do it well”，很不错，而且我们大多数人也实践了这么多年，但是这并不代表所有的真实世界。在历史上，也不只有systemd 这么干过。但是，我个人还是 old-fashioned 的人，至少我喜欢文本式的日志，而不是二进制的日志。但是 systemd 没有必要一定要有这样的品味。哦，我说细节了……\n 今天，systemd 占据了几乎所有的主流的 Linux 发行版的默认配置，包括：Arch Linux、CentOS、CoreOS、Debian、Fedora、Megeia、OpenSUSE、RHEL、SUSE企业版和 Ubuntu。而且，对于 CentOS, CoreOS, Fedora, RHEL, SUSE这些发行版来说，不能没有 systemd。（Ubuntu 还有一个不错的wiki – Systemd for Upstart Users 阐述了如何在两者间切换）\n其它 还记得在《缓存更新的套路》一文中，我说过，如果你要做好架构，首先你得把计算机体系结构以及很多老古董的基础技术吃透了。因为里面会有很多可以借鉴和相通的东西。那么，你是否从这篇文章里看到了一些有分布式架构相似的东西？\n比如：从 sysvinit 到 upstart 再到 systemd，像不像是服务治理？Linux系统下的这些服务进程，是不是很像分布式架构中的微服务？还有那个D-Bus，是不是很像SOA里的ESB？而 init 系统是不是很像一个控制系统？甚至像一个服务编排（Service Orchestration）系统？\n分布式系统中的服务之间也有很多依赖，所以，在启动一个架构的时候，如果我们可以做到像 systemd 那样并行启动的话，那么是不是就像是一个微服务的玩法了？\n嗯，你会发现，技术上的很多东西是相通的，也是互相有对方的影子，所以，其实技术并不多。关键是我们学在了表面还是看到了本质。\n命令 Systemd 是 Linux 系统工具，用来启动守护进程，已成为大多数发行版的标准配置。\n系统管理 Systemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面。\nsystemctl\nsystemctl是 Systemd 的主命令，用于管理系统。\n# 重启系统 $ sudo systemctl reboot # 关闭系统，切断电源 $ sudo systemctl poweroff # CPU停止工作 $ sudo systemctl halt # 暂停系统 $ sudo systemctl suspend # 让系统进入冬眠状态 $ sudo systemctl hibernate # 让系统进入交互式休眠状态 $ sudo systemctl hybrid-sleep # 启动进入救援状态（单用户状态） $ sudo systemctl rescue systemd-analyze\nsystemd-analyze命令用于查看启动耗时。\n# 查看启动耗时 $ systemd-analyze # 查看每个服务的启动耗时 $ systemd-analyze blame # 显示瀑布状的启动过程流$ $ systemd-analyze critical-chain # 显示指定服务的启动流 $ systemd-analyze critical-chain atd.service hostnamectl\nhostnamectl命令用于查看当前主机的信息。\n# 显示当前主机的信息 $ hostnamectl # 设置主机名。 $ sudo hostnamectl set-hostname rhel7 localectl\nlocalectl命令用于查看本地化设置。\n# 查看本地化设置 $ localectl # 设置本地化参数。 $ sudo localectl set-locale LANG=en_GB.utf8 $ sudo localectl set-keymap en_GB timedatectl\ntimedatectl命令用于查看当前时区设置。\n# 查看当前时区设置 $ timedatectl # 显示所有可用的时区 $ timedatectl list-timezones # 设置当前时区 $ sudo timedatectl set-timezone America/New_York $ sudo timedatectl set-time YYYY-MM-DD $ sudo timedatectl set-time HH:MM:SS loginctl\nloginctl命令用于查看当前登录的用户。\n# 列出当前session $ loginctl list-sessions # 列出当前登录用户 $ loginctl list-users # 列出显示指定用户的信息 $ loginctl show-user ruanyf Unit 含义\nSystemd 可以管理所有系统资源。不同的资源统称为 Unit（单元）。简单说，单元就是 Systemd 的最小功能单位，是单个进程的描述。一个个小的单元互相调用和依赖，组成一个庞大的任务管理系统，这就是 Systemd 的基本思想。\n由于 Systemd 要做的事情太多，导致单元有很多不同的种类，大概一共有12种。\n Service unit：系统服务 Target unit：多个 Unit 构成的一个组 Device Unit：硬件设备 Mount Unit：文件系统的挂载点 Automount Unit：自动挂载点 Path Unit：文件或路径 Scope Unit：不是由 Systemd 启动的外部进程 Slice Unit：进程组，资源分配 Snapshot Unit：Systemd 快照，可以切回某个快照 Socket Unit：进程间通信的 socket Swap Unit：swap 文件 Timer Unit：定时器  systemctl list-units命令可以查看当前系统的所有 Unit 。\n# 列出正在运行的 Unit $ systemctl list-units # 列出所有Unit，包括没有找到配置文件的或者启动失败的 $ systemctl list-units --all # 列出所有没有运行的 Unit $ systemctl list-units --all --state=inactive # 列出所有加载失败的 Unit $ systemctl list-units --failed # 列出所有正在运行的、类型为 service 的 Unit $ systemctl list-units --type=service Unit 的状态\nsystemctl status命令用于查看系统状态和单个 Unit 的状态。\n# 显示系统状态 $ systemctl status # 显示单个 Unit 的状态 $ sysystemctl status bluetooth.service # 显示远程主机的某个 Unit 的状态 $ systemctl -H root@rhel7.example.com status httpd.service 例如查看 httpd 状态\n$ sudo systemctl status httpd httpd.service - The Apache HTTP Server Loaded: loaded (/usr/lib/systemd/system/httpd.service; enabled) Active: active (running) since 金 2014-12-05 12:18:22 JST; 7min ago Main PID: 4349 (httpd) Status: \"Total requests: 1; Current requests/sec: 0; Current traffic: 0 B/sec\" CGroup: /system.slice/httpd.service ├─4349 /usr/sbin/httpd -DFOREGROUND ├─4350 /usr/sbin/httpd -DFOREGROUND ├─4351 /usr/sbin/httpd -DFOREGROUND ├─4352 /usr/sbin/httpd -DFOREGROUND ├─4353 /usr/sbin/httpd -DFOREGROUND └─4354 /usr/sbin/httpd -DFOREGROUND 12月 05 12:18:22 localhost.localdomain systemd[1]: Starting The Apache HTTP Server... 12月 05 12:18:22 localhost.localdomain systemd[1]: Started The Apache HTTP Server. 12月 05 12:22:40 localhost.localdomain systemd[1]: Started The Apache HTTP Server. 上面的输出结果含义如下。\n Loaded行：配置文件的位置，是否设为开机启动 Active行：表示正在运行 Main PID行：主进程ID Status行：由应用本身（这里是 httpd ）提供的软件当前状态 CGroup块：应用的所有子进程 日志块：应用的日志  除了status命令，systemctl还提供了三个查询状态的简单方法，主要供脚本内部的判断语句使用。\n# 显示某个 Unit 是否正在运行 $ systemctl is-active application.service # 显示某个 Unit 是否处于启动失败状态 $ systemctl is-failed application.service # 显示某个 Unit 服务是否建立了启动链接 $ systemctl is-enabled application.service Unit 管理\n对于用户来说，最常用的是下面这些命令，用于启动和停止 Unit（主要是 service）。\n# 立即启动一个服务 $ sudo systemctl start apache.service # 立即停止一个服务 $ sudo systemctl stop apache.service # 重启一个服务 $ sudo systemctl restart apache.service # 杀死一个服务的所有子进程 $ sudo systemctl kill apache.service # 重新加载一个服务的配置文件 $ sudo systemctl reload apache.service # 重载所有修改过的配置文件 $ sudo systemctl daemon-reload # 显示某个 Unit 的所有底层参数 $ systemctl show httpd.service # 显示某个 Unit 的指定属性的值 $ systemctl show -p CPUShares httpd.service # 设置某个 Unit 的指定属性 $ sudo systemctl set-property httpd.service CPUShares=500 有时候，该命令可能没有响应，执行systemctl stop服务停不下来。这时候就不得不\"杀进程\"了，向正在运行的进程发出kill信号，执行systemctl kill。\n依赖关系\nUnit 之间存在依赖关系：A 依赖于 B，就意味着 Systemd 在启动 A 的时候，同时会去启动 B。\nsystemctl list-dependencies命令列出一个 Unit 的所有依赖。\n$ systemctl list-dependencies nginx.service 上面命令的输出结果之中，有些依赖是 Target 类型（详见下文），默认不会展开显示。如果要展开 Target，就需要使用--all参数。\n$ systemctl list-dependencies --all nginx.service Unit 的配置文件 概述\n每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit 。\n除了系统默认的单元文件/lib/systemd/system，Systemd 默认从目录/etc/systemd/system/读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录/usr/lib/systemd/system/。那些支持 Systemd 的软件，安装的时候，也会自动在/usr/lib/systemd/system目录添加一个配置文件。\nsystemctl enable命令用于在/etc/systemd/system/和/usr/lib/systemd/system之间，建立符号链接关系。\n$ sudo systemctl enable clamd@scan.service # 等同于 $ sudo ln -s '/usr/lib/systemd/system/clamd@scan.service' '/etc/systemd/system/multi-user.target.wants/clamd@scan.service' 如果配置文件里面设置了开机启动，systemctl enable命令相当于激活开机启动。\n与之对应的，systemctl disable命令用于在两个目录之间，撤销符号链接关系，相当于撤销开机启动。\n$ sudo systemctl disable clamd@scan.service 配置文件的后缀名，就是该 Unit 的种类，比如sshd.socket。如果省略，Systemd 默认后缀名为.service，所以sshd会被理解成sshd.service。\n设置开机启动以后，软件并不会立即启动，必须等到下一次开机。如果想现在就运行该软件，那么要执行systemctl start命令。\n配置文件的状态\nsystemctl list-unit-files命令用于列出所有配置文件。\n# 列出所有配置文件 $ systemctl list-unit-files # 列出指定类型的配置文件 $ systemctl list-unit-files --type=service 这个命令会输出一个列表。\n$ systemctl list-unit-filesUNIT FILE STATEchronyd.service enabledclamd@.service staticclamd@scan.service disabled 这个列表显示每个配置文件的状态，一共有四种。\n enabled：已建立启动链接 disabled：没建立启动链接 static：该配置文件没有[Install]部分（无法执行），只能作为其他配置文件的依赖 masked：该配置文件被禁止建立启动链接  注意，从配置文件的状态无法看出，该 Unit 是否正在运行。这必须执行前面提到的systemctl status命令。\n$ systemctl status bluetooth.service 一旦修改配置文件，就要让 Systemd 重新加载配置文件，然后重新启动，否则修改不会生效。\n$ sudo systemctl daemon-reload $ sudo systemctl restart httpd.service 配置文件的格式\n配置文件就是普通的文本文件，可以用文本编辑器打开。\nsystemctl cat命令可以查看配置文件的内容。\n$ systemctl cat sshd.service [Unit] Description=OpenSSH server daemon Documentation=man:sshd(8) man:sshd_config(5) After=network.target sshd-keygen.service Wants=sshd-keygen.service [Service] EnvironmentFile=/etc/sysconfig/sshd ExecStart=/usr/sbin/sshd -D $OPTIONS ExecReload=/bin/kill -HUP $MAINPID Type=simpleKill Mode=process Restart=on-failure RestartSec=42s [Install] WantedBy=multi-user.target 从上面的输出可以看到，配置文件分成几个区块。每个区块的第一行，是用方括号表示的区别名，比如[Unit]。注意，配置文件的区块名和字段名，都是大小写敏感的。\n每个区块内部是一些等号连接的键值对。\n[Section] Directive1=value Directive2=value . . . 注意，键值对的等号两侧不能有空格。\n配置文件的区块\n[Unit]区块通常是配置文件的第一个区块，用来定义 Unit 的元数据，以及配置与其他 Unit 的关系。它的主要字段如下。\n  Description：当前服务的简单描述\n  Documentation：文档地址\n  启动顺序\n Before：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动 After：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之前启动。如network.target或sshd-keygen.service需要启动，那么sshd.service应该在它们之后启动。    依赖关系：\n举例来说，某 Web 应用需要 postgresql 数据库储存数据。在配置文件中，Before、After 只定义要在 postgresql 之后启动，而没有定义依赖 postgresql 。上线后，由于某种原因，postgresql 需要重新启动，在停止服务期间，该 Web 应用就会无法建立数据库连接。\n注意，Wants字段与Requires字段只涉及依赖关系，与启动顺序无关，默认情况下是同时启动的。\n Wants：与当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败。如sshd.service与sshd-keygen.service之间存在\"弱依赖\"关系，即如果\"sshd-keygen.service\"启动失败或停止运行，不影响sshd.service继续执行。 Requires：当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败。Requires字段则表示\"强依赖\"关系，即如果该服务启动失败或异常退出，那么sshd.service也必须退出。    BindsTo：与Requires类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行\n  Conflicts：这里指定的 Unit 不能与当前 Unit 同时运行\n  Condition...：当前 Unit 运行必须满足的条件，否则不会运行\n  Assert...：当前 Unit 运行必须满足的条件，否则会报启动失败\n  StartLimitIntervalSec=interval, StartLimitBurst=burst：设置单元的启动频率限制。 也就是该单元在 interval 时间内最多允许启动 burst 次。\n   [Service]区块用来定义如何启动当前服务，只有 Service 类型的 Unit 才有这个区块。它的主要字段如下。\n  EnvironmentFile字段：指定当前服务的环境参数文件。该文件内部的key=value键值对，可以用$key的形式，在当前配置文件中获取。sshd 的环境参数文件是/etc/sysconfig/sshd。\n  ExecStart字段：定义启动进程时执行的命令。是配置文件里面最重要的字段。上面的例子中，启动sshd，执行的命令是/usr/sbin/sshd -D $OPTIONS，其中的变量$OPTIONS就来自EnvironmentFile字段指定的环境参数文件。与之作用相似的，还有如下这些字段。\n ExecReload字段：重启服务时执行的命令 ExecStop字段：停止服务时执行的命令 ExecStartPre字段：启动服务之前执行的命令 ExecStartPost字段：启动服务之后执行的命令 ExecStopPost字段：停止服务之后执行的命令    Type：字段定义启动类型。它可以设置的值如下。\n simple（默认值）：ExecStart字段启动的进程为主进程 forking：ExecStart字段将以fork()方式启动，此时父进程将会退出，子进程将成为主进程 oneshot：类似于simple，但只执行一次，Systemd 会等它执行完，才启动其他服务 dbus：类似于simple，但会等待 D-Bus 信号后启动 notify：类似于simple，启动结束后会发出通知信号，然后 Systemd 再启动其他服务 idle：类似于simple，但是要等到其他任务都执行完，才会启动该服务。一种使用场合是为让该服务的输出，不与其他服务的输出相混合    KillMode字段：定义 Systemd 如何停止服务。\n control-group（默认值）：当前控制组里面的所有子进程，都会被杀掉 process：只杀主进程。比如sshd的KillMode设为process，子进程打开的 SSH session 仍然保持连接。 mixed：主进程将收到 SIGTERM 信号，子进程收到 SIGKILL 信号 none：没有进程会被杀掉，只是执行服务的 stop 命令。    Restart：Restart字段：定义了服务退出后，Systemd 重启该服务的方式。\n no（默认值）：退出后不会重启 on-success：只有正常退出时（退出状态码为0），才会重启 on-failure：非正常退出时（退出状态码非0），包括被信号终止和超时，才会重启。比如sshd任何意外的失败，都将重启sshd；如果 sshd 正常停止（比如执行systemctl stop命令），它就不会重启。对于守护进程，推荐设为on-failure。 on-abnormal：只有被信号终止和超时，才会重启。对于那些允许发生错误退出的服务，可以设为on-abnormal。 on-abort：只有在收到没有捕捉到的信号终止时，才会重启 on-watchdog：超时退出，才会重启 always：不管是什么退出原因，总是重启     退出原因(↓) | Restart= (→) no always on-success on-failure on-abnormal on-abort on-watchdog     正常退出  X X       退出码不为\"0\"  X  X      进程被强制杀死  X  X X X    systemd 操作超时  X  X X     看门狗超时  X  X X  X      RestartSec字段：表示 Systemd 重启服务之前，需要等待的秒数。\n  TimeoutSec：定义 Systemd 停止当前服务之前等待的秒数\n  所有的启动设置之前，都可以加上一个连词号（-），表示\"抑制错误\"，即发生错误的时候，不影响其他命令的执行。比如，EnvironmentFile=-/etc/sysconfig/sshd（注意等号后面的那个连词号），就表示即使/etc/sysconfig/sshd文件不存在，也不会抛出错误。\n [Install]通常是配置文件的最后一个区块，定义如何安装这个配置文件，即怎样做到开机启动。它的主要字段如下。\n WantedBy字段：表示该服务所在的 Target，它的值是一个或多个 Target。Target的含义是服务组，表示一组服务。WantedBy=multi-user.target指的是，sshd 所在的 Target 是multi-user.target。当前 Unit 激活时（enable）符号链接会放入/etc/systemd/system目录下面 [Target 名].wants子目录中，如multi-user.target.wants子目录。 RequiredBy：它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入/etc/systemd/system目录下面以 Target 名 + .required后缀构成的子目录中 Alias：当前 Unit 可用于启动的别名 Also：当前 Unit 激活（enable）时，会被同时激活的其他 Unit  Unit 配置文件的完整字段清单，请参考官方文档。\nTarget 启动计算机的时候，需要启动大量的 Unit。如果每一次启动，都要一一写明本次启动需要哪些 Unit，显然非常不方便。Systemd 的解决方案就是 Target。\n简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于\"状态点\"，启动某个 Target 就好比启动到某种状态。\n传统的init启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。\n# 查看当前系统的所有 Target $ systemctl list-unit-files --type=target # 查看一个 Target 包含的所有 Unit $ systemctl list-dependencies multi-user.target # 查看启动时的默认 Target，在这个组里的所有服务，都将开机启动。 $ systemctl get-default # 设置启动时的默认 Target $ sudo systemctl set-default multi-user.target # 切换 Target 时，默认不关闭前一个 Target 启动的进程， # systemctl isolate 命令改变这种行为， # 关闭前一个 Target 里面所有不属于后一个 Target 的进程 $ sudo systemctl isolate multi-user.target Target 与 传统 RunLevel 的对应关系如下。\nTraditional runlevel New target name Symbolically linked to... Runlevel 0 | runlevel0.target - poweroff.target Runlevel 1 | runlevel1.target - rescue.target Runlevel 2 | runlevel2.target - multi-user.target Runlevel 3 | runlevel3.target - multi-user.target Runlevel 4 | runlevel4.target - multi-user.target Runlevel 5 | runlevel5.target - graphical.target Runlevel 6 | runlevel6.target - reboot.target 它与init进程的主要差别如下。\n（1）默认的 RunLevel（在/etc/inittab文件设置）现在被默认的 Target 取代，位置是/etc/systemd/system/default.target，通常符号链接到graphical.target（图形界面）或者multi-user.target（多用户命令行）。\n（2）启动脚本的位置，以前是/etc/init.d目录，符号链接到不同的 RunLevel 目录 （比如/etc/rc3.d、/etc/rc5.d等），现在则存放在/lib/systemd/system和/etc/systemd/system目录。\n（3）配置文件的位置，以前init进程的配置文件是/etc/inittab，各种服务的配置文件存放在/etc/sysconfig目录。现在的配置文件主要存放在/lib/systemd目录，在/etc/systemd目录里面的修改可以覆盖原始设置。\n日志管理 Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用journalctl一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是/etc/systemd/journald.conf。\njournalctl功能强大，用法非常多。\n# 查看所有日志（默认情况下 ，只保存本次启动的日志） $ sudo journalctl # 查看内核日志（不显示应用日志） $ sudo journalctl -k # 查看系统本次启动的日志 $ sudo journalctl -b $ sudo journalctl -b -0 # 查看上一次启动的日志（需更改设置） $ sudo journalctl -b -1 # 查看指定时间的日志 $ sudo journalctl --since=\"2012-10-30 18:17:16\" $ sudo journalctl --since \"20 min ago\" $ sudo journalctl --since yesterday $ sudo journalctl --since \"2015-01-10\" --until \"2015-01-11 03:00\" $ sudo journalctl --since 09:00 --until \"1 hour ago\" # 显示尾部的最新10行日志 $ sudo journalctl -n # 显示尾部指定行数的日志 $ sudo journalctl -n 20 # 实时滚动显示最新日志 $ sudo journalctl -f # 查看指定服务的日志 $ sudo journalctl /usr/lib/systemd/systemd # 查看指定进程的日志 $ sudo journalctl _PID=1 # 查看某个路径的脚本的日志 $ sudo journalctl /bin/bash # 查看指定用户的日志 $ sudo journalctl _UID=33 --since today # 查看某个 Unit 的日志 $ sudo journalctl -u nginx.service $ sudo journalctl -u nginx.service --since today # 实时滚动显示某个 Unit 的最新日志 $ sudo journalctl -u nginx.service -f # 合并显示多个 Unit 的日志 $ journalctl -u nginx.service -u php-fpm.service --since today # 查看指定优先级（及其以上级别）的日志，共有8级 # 0: emerg # 1: alert # 2: crit # 3: err # 4: warning # 5: notice # 6: info # 7: debug $ sudo journalctl -p err -b # 日志默认分页输出，--no-pager 改为正常的标准输出 $ sudo journalctl --no-pager # 以 JSON 格式（单行）输出 $ sudo journalctl -b -u nginx.service -o json # 以 JSON 格式（多行）输出，可读性更好 $ sudo journalctl -b -u nginx.serviceqq -o json-pretty # 显示日志占据的硬盘空间 $ sudo journalctl --disk-usage # 指定日志文件占据的最大空间 $ sudo journalctl --vacuum-size=1G # 指定日志文件保存多久 $ sudo journalctl --vacuum-time=1years 定时器示例 邮件脚本 先写一个发邮件的脚本mail.sh。\n#!/usr/bin/env bash echo \"This is the body\" | /usr/bin/mail -s \"Subject\" someone@example.com 上面代码的someone@example.com，请替换成你的邮箱地址。\n然后，执行这个脚本。\n$ bash mail.sh 执行后，你应该就会收到一封邮件，标题为Subject。\n如果你的 Linux 系统不能发邮件，建议安装 ssmtp 或者 msmtp。另外，mail命令的用法，可以参考这里。\nService 单元 Service 单元就是所要执行的任务，比如发送邮件就是一种 Service。\n新建 Service 非常简单，就是在/usr/lib/systemd/system目录里面新建一个文件，比如mytimer.service文件，你可以写入下面的内容。\n[Unit] Description=MyTimer [Service] ExecStart=/bin/bash /path/to/mail.sh 注意，定义的时候，所有路径都要写成绝对路径，比如bash要写成/bin/bash，否则 Systemd 会找不到。\n现在，启动这个 Service。\n$ sudo systemctl start mytimer.service 如果一切正常，你应该就会收到一封邮件。\nTimer 单元 Service 单元只是定义了如何执行任务，要定时执行这个 Service，还必须定义 Timer 单元。\n/usr/lib/systemd/system目录里面，新建一个mytimer.timer文件，写入下面的内容。\n[Unit] Description=Runs mytimer every hour [Timer] OnUnitActiveSec=1h Unit=mytimer.service [Install] WantedBy=multi-user.target 这个 Timer 单元文件分成几个部分。\n[Timer]部分定制定时器。Systemd 提供以下一些字段。\n OnActiveSec：定时器生效后，多少时间开始执行任务 OnBootSec：系统启动后，多少时间开始执行任务 OnStartupSec：Systemd 进程启动后，多少时间开始执行任务 OnUnitActiveSec：该单元上次执行后，等多少时间再次执行 OnUnitInactiveSec： 定时器上次关闭后多少时间，再次执行 OnCalendar：基于绝对时间，而不是相对时间执行 AccuracySec：如果因为各种原因，任务必须推迟执行，推迟的最大秒数，默认是60秒 Unit：真正要执行的任务，默认是同名的带有.service后缀的单元 Persistent：如果设置了该字段，即使定时器到时没有启动，也会自动执行相应的单元 WakeSystem：如果系统休眠，是否自动唤醒系统  上面的脚本里面，OnUnitActiveSec=1h表示一小时执行一次任务。其他的写法还有OnCalendar=*-*-* 02:00:00表示每天凌晨两点执行，OnCalendar=Mon *-*-* 02:00:00表示每周一凌晨两点执行，具体请参考中文手册。\nSystem time 一个操作系统通过如下内容确定时间：时间数值、时间标准、时区和夏令时调节(中国已经废止)。本文分别介绍各个部分的定义及如何设置他们。要维护准确的系统时间，请参考 网络时间协议 一文。\n硬件时钟和系统时钟 系统用两个时钟保存时间：硬件时钟和系统时钟。\n硬件时钟(即实时时钟 RTC 或 CMOS 时钟)仅能保存：年、月、日、时、分、秒这些时间数值，无法保存时间标准(UTC 或 localtime)和是否使用夏令时调节。\n系统时钟(即软件时间) 与硬件时间分别维护，保存了：时间、时区和夏令时设置。Linux 内核保存为自 UTC 时间 1970 年1月1日经过的秒数。初始系统时钟是从硬件时间计算得来，计算时会考虑/etc/adjtime的设置。系统启动之后，系统时钟与硬件时钟独立运行，Linux 通过时钟中断计数维护系统时钟。\n如果系统时间是按 32 位整数保存的，最大只能记到 2038 年，所以 32 位 Linux 系统将在 2038 年停止工作。\n大部分操作系统的时间管理包括如下方面：\n 启动时根据硬件时钟设置系统时间 运行时通过时间同步联网校正时间 关机时根据系统时间设置硬件时间  读取时间 下面命令可以获得硬件时间和系统时间(硬件时钟按 localtime 显示):\n$ timedatectl Local time: Thu 2022-01-27 10:35:26 CST Universal time: Thu 2022-01-27 02:35:26 UTC RTC time: Thu 2022-01-27 02:35:26 Time zone: Asia/Shanghai (CST, +0800) System clock synchronized: yes NTP service: active RTC in local TZ: no 名词解释：\n CST：(China Standard Time,UTC+8:00) 中国沿海时间(北京时间) UTC：(Universal Time Coordinated,UTC) 世界协调时间 GMT：(Greenwich Mean Time ,GMT）格林威治时间 LT：(locale time）本地时间  设置时间 设置系统时间的本地时间：\n# timedatectl set-time \"yyyy-MM-dd hh:mm:ss\" 例如:\n# timedatectl set-time \"2014-05-26 11:13:54\" 设置时间为2014年，5月26日，11时13分54秒。\n时间标准 时间表示有两个标准：localtime 和 UTC(Coordinated Universal Time) 。UTC 是与时区无关的全球时间标准。尽管概念上有差别，UTC 和 GMT (格林威治时间) 是一样的。localtime 标准则依赖于当前时区。\n时间标准由操作系统设定，Windows 默认使用 localtime，Mac OS 默认使用 UTC，而 UNIX 系列的操作系统两者都有。使用 Linux 时，最好将硬件时钟设置为 UTC 标准，并在所有操作系统中使用。这样 Linux 系统就可以自动调整夏令时设置，而如果使用 localtime 标准那么系统时间不会根据夏令时自动调整。\n通过如下命令可以检查当前设置，systemd 默认硬件时钟为协调世界时（UTC）。\n$ timedatectl status | grep local RTC in local TZ: no 硬件时间可以用 hwclock 命令设置，将硬件时间设置为 localtime：\n# timedatectl set-local-rtc 1 硬件时间设置成 UTC：\n# timedatectl set-local-rtc 0 上述命令会自动生成/etc/adjtime，无需单独设置。\n注意： 如果不存在 /etc/adjtime，systemd 会假定硬件时间按 UTC 设置。\n系统启动装入 rtc 驱动时可能会根据系统时钟设置硬件时钟。是否设置依赖于平台、内核版本和内核编译选项。如果进行了设置，此时会假定硬件时钟为 UTC 标准，/sys/class/rtc/rtcN/hctosys(N=0,1,2,..) 会设置成 1。后面 systemd 会根据/etc/adjtime重新设置。\n如果设置成本地时间，处理夏令时有些麻烦。如果夏令时调整发生在关机时，下次启动时时间会出现问题（更多信息）。最新的内核直接从实时时钟芯片（RTC）读取时间，不使用 hwclock，内核把从 RTC 读取的时间当作 UTC 处理。所以如果硬件时间是地方时，系统启动一开始识别的时间是错误的，之后很快会进行矫正。这可能导致一些问题（尤其是时间倒退时）。\nWindows 系统使用 UTC 如果同时安装了 Windows 操作系统（默认使用地方时），那么一般 RTC 会被设置为地方时。Windows 其实也能处理 UTC，需要修改注册表。建议让 Windows 使用 UTC，而非让 Linux 使用地方时。Windows 使用 UTC 后，请记得禁用 Windows 的时间同步功能，以防 Windows 错误设置硬件时间。如上文所说，Linux 可以使用NTP服务来在线同步硬件时钟。\n使用 regedit,新建如下 DWORD 值，并将其值设为十六进制的 1。\nHKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation\\RealTimeIsUniversal 也可以用管理员权限启动命令行来完成：\nreg add \"HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\TimeZoneInformation\" /v RealTimeIsUniversal /d 1 /t REG_DWORD /f 如果以上操作不起作用，并且你使用的是 Windows 64位系统，将 DWORD 修改为 QWORD。\n如果 Windows 要求根据夏令时更新时钟，可以允许。时钟仍然是 UTC，仅是显示时间会改变。\n设置时间标准后需要重新设置硬件时间和系统时间。\n如果你有时间偏移问题，再次设置你的时区:\n# timedatectl set-timezone Asia/Shanghai UTC 在Ubuntu的设置 Ubuntu及其衍生发行版会在安装时检测计算机上是否存在Windows，若存在则会默认使用localtime。这是为了让Windows用户能够在不修改注册表的情况下，在Ubuntu内看到正确的时间。\n要改变这种行为，请参见上面的内容。\n时区 检查当前时区：\n$ timedatectl status 显示可用时区：\n$ timedatectl list-timezones 修改时区：\n# timedatectl set-timezone / 例如：\n# timedatectl set-timezone Asia/Shanghai 此命令会创建一个/etc/localtime软链接，指向/usr/share/zoneinfo/中的时区文件，如果手动创建此链接请确保是相对链接而不是绝对链接。\n注意： 如果pre-systemd配置的/etc/timezone仍然存在于你的系统，你可以放心地将其删除，因为它不再使用。\n时钟偏移 最能代表“真实时间”的是国际原子时钟)，所有的时钟都是有误差的。电子时钟的时间是不准的，但是一般有固定的偏移。这种于基值的差称为“time skew”或“时间偏移”。用 hwclock 设置硬件时间时，会计算每天偏移的秒数。偏移值是原硬件时间与新设置硬件时间的差，并且考虑上次硬件时间设置时的偏移。新的偏移值会在设置时钟时写到文件 /etc/adjtime 。\n注意： 如果硬件时间值与原值的差小于 24 小时，偏移量不会重新计算，因为时间过短，无法精确设置偏移。\n如果硬件时钟总是过快或过慢，可能是计算了错误的偏移值。硬件时钟设置错误或者时间标准与其他操作系统不一致导致。删除文件 /etc/adjtime 可以删除偏移值，然后设置正确的硬件时钟和系统时钟，并检查时间标准是不是设置正确。\n注意： 使用 Systemd 时，要使用 /etc/adjtime中的 drift 值(即无法或不想使用 NTP 时); 需要每次调用 hwclock --adjust命令，可以通过 cron 任务实现。\n提高系统时间精度的方法有：\nNTP 可以通过网络时间协议同步 Linux 系统的时间。NTP 也会修正中断频率和每秒滴答数以减少时间偏移。并且每隔 11 分钟同步一次硬件时钟。\n时钟同步 网络时间协议 (NTP) 是一个通过包交换和可变延迟网络来同步计算机系统时间的协议。下列为这个协议的实现：\n NTP 守护进程是这个协议的参考实现，推荐用于时间服务器。它也可以调节中断频率和每秒滴答次数以减少系统时钟误差，使得硬件时钟每隔11秒重新同步一次。 sntp 是一个 SNTP 客户端。它取代了 ntpdate ，并被推荐用于非服务器环境。 systemd-timesyncd 是一个简单的 SNTP 守护进程。它只实现了客户端，专用于从远程服务器查询时间，更适用于绝大部分安装的情形。 OpenNTPD 是 OpenBSD 项目的一部分，同时实现了客户端和服务器。 Chrony 是一个客户端和服务器，更适合漫游，是为不能始终保持在线的系统而特别设计。 ntpclient 是简单的命令行 NTP 客户端  防火墙 保障数据的安全性是继保障数据的可用性之后最为重要的一项工作。防火墙作为公网与内网之间的保护屏障，在保障数据的安全性方面起着至关重要的作用。\n防火墙管理工具 众所周知，相较于企业内网，外部的公网环境更加恶劣，罪恶丛生。在公网与企业内网之间充当保护屏障的防火墙虽然有软件或硬件之分，但主要功能都是依据策略对穿越防火墙自身的流量进行过滤。就像家里安装的防盗门一样，目的是保护亲人和财产安全。防火墙策略可以基于流量的源目地址、端口号、协议、应用等信息来定制，然后防火墙使用预先定制的策略规则监控出入的流量，若流量与某一条策略规则相匹配，则执行相应的处理，反之则丢弃。这样一来，就能够保证仅有合法的流量在企业内网和外部公网之间流动了。\n从RHEL 7系统开始，firewalld防火墙正式取代了iptables防火墙。对于接触Linux系统比较早或学习过RHEL 5/6系统的读者来说，当他们发现曾经掌握的知识在RHEL 7/8中不再适用，需要全新学习firewalld时，难免会有抵触心理。其实，iptables与firewalld都不是真正的防火墙，它们都只是用来定义防火墙策略的防火墙管理工具而已；或者说，它们只是一种服务。iptables服务会把配置好的防火墙策略交由内核层面的netfilter网络过滤器来处理，而firewalld服务则是把配置好的防火墙策略交由内核层面的nftables包过滤框架来处理。换句话说，当前在Linux系统中其实存在多个防火墙管理工具，旨在方便运维人员管理Linux系统中的防火墙策略，我们只需要配置妥当其中的一个就足够了。\n虽然这些工具各有优劣，但它们在防火墙策略的配置思路上是保持一致的。大家甚至可以不用完全掌握本章介绍的内容，只要在这多个防火墙管理工具中任选一款并将其学透，就足以满足日常的工作需求了。\nIptables 在早期的Linux系统中，默认使用的是iptables防火墙管理服务来配置防火墙。尽管新型的firewalld防火墙管理服务已经被投入使用多年，但是大量的企业在生产环境中依然出于各种原因而继续使用iptables。\n策略与规则链 防火墙会按照从上到下的顺序来读取配置的策略规则，在找到匹配项后就立即结束匹配工作并去执行匹配项中定义的行为（即放行或阻止）。如果在读取完所有的策略规则之后没有匹配项，就去执行默认的策略。一般而言，防火墙策略规则的设置有两种：“通”（即放行）和“堵”（即阻止）。当防火墙的默认策略为拒绝时（堵），就要设置允许规则（通），否则谁都进不来；如果防火墙的默认策略为允许，就要设置拒绝规则，否则谁都能进来，防火墙也就失去了防范的作用。\niptables服务把用于处理或过滤流量的策略条目称之为规则，多条规则可以组成一个规则链，而规则链则依据数据包处理位置的不同进行分类，具体如下：\n 在进行路由选择前处理数据包（PREROUTING）； 处理流入的数据包（INPUT）； 处理流出的数据包（OUTPUT）； 处理转发的数据包（FORWARD）； 在进行路由选择后处理数据包（POSTROUTING）。  一般来说，从内网向外网发送的流量一般都是可控且良性的，因此使用最多的就是INPUT规则链，该规则链可以增大黑客人员从外网入侵内网的难度。\n比如在您居住的社区内，物业管理公司有两条规定：禁止小商小贩进入社区；各种车辆在进入社区时都要登记。显而易见，这两条规定应该是用于社区的正门的（流量必须经过的地方），而不是每家每户的防盗门上。根据前面提到的防火墙策略的匹配顺序，可能会存在多种情况。比如，来访人员是小商小贩，则直接会被物业公司的保安拒之门外，也就无须再对车辆进行登记。如果来访人员乘坐一辆汽车进入社区正门，则“禁止小商小贩进入社区”的第一条规则就没有被匹配到，因此按照顺序匹配第二条策略，即需要对车辆进行登记。如果是社区居民要进入正门，则这两条规定都不会匹配到，因此会执行默认的放行策略。\n但是，仅有策略规则还不能保证社区的安全，保安还应该知道采用什么样的动作来处理这些匹配的流量，比如“允许”“拒绝”“登记”“不理它”。这些动作对应到iptables服务的术语中分别是ACCEPT（允许流量通过）、REJECT（拒绝流量通过）、LOG（记录日志信息）、DROP（拒绝流量通过）。“允许流量通过”和“记录日志信息”都比较好理解，这里需要着重讲解的是REJECT和DROP的不同点。就DROP来说，它是直接将流量丢弃而且不响应；REJECT则会在拒绝流量后再回复一条“信息已经收到，但是被扔掉了”信息，从而让流量发送方清晰地看到数据被拒绝的响应信息。\n下面举一个例子，让各位读者更直观地理解这两个拒绝动作的不同之处。比如有一天您正在家里看电视，突然听到有人敲门，您透过防盗门的猫眼一看是推销商品的，便会在不需要的情况下开门并拒绝他们（REJECT）。但如果看到的是债主带了十几个小弟来讨债，此时不仅要拒绝开门，还要默不作声，伪装成自己不在家的样子（DROP）。\n当把Linux系统中的防火墙策略设置为REJECT动作后，流量发送方会看到端口不可达的响应：\n[root@linuxprobe ~]# ping -c 4 192.168.10.10 PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data. From 192.168.10.10 icmp_seq=1 Destination Port Unreachable From 192.168.10.10 icmp_seq=2 Destination Port Unreachable From 192.168.10.10 icmp_seq=3 Destination Port Unreachable From 192.168.10.10 icmp_seq=4 Destination Port Unreachable --- 192.168.10.10 ping statistics --- 4 packets transmitted, 0 received, +4 errors, 100 packet loss, time 3002ms 而把Linux系统中的防火墙策略修改成DROP动作后，流量发送方会看到响应超时的提醒。但是流量发送方无法判断流量是被拒绝，还是接收方主机当前不在线：\n[root@linuxprobe ~]# ping -c 4 192.168.10.10 PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data. --- 192.168.10.10 ping statistics --- 4 packets transmitted, 0 received, 100 packet loss, time 3000ms 基本的命令参数 iptables是一款基于命令行的防火墙策略管理工具，具有大量的参数，学习难度较大。好在对于日常的防火墙策略配置来讲，大家无须深入了解诸如“四表五链”的理论概念，只需要掌握常用的参数并做到灵活搭配即可，这就足以应对日常工作了。\n根据OSI七层模型的定义，iptables属于数据链路层的服务，所以可以根据流量的源地址、目的地址、传输协议、服务类型等信息进行匹配；一旦匹配成功，iptables就会根据策略规则所预设的动作来处理这些流量。另外，再次提醒一下，防火墙策略规则的匹配顺序是从上到下的，因此要把较为严格、优先级较高的策略规则放到前面，以免发生错误。表8-1总结归纳了常用的iptables命令参数。再次强调，无须死记硬背这些参数，只需借助下面的实验来理解掌握即可。\n命令格式 iptables [-t table] COMMAND chain CRETIRIA -j ACTION  -t table ：filter/nat/mangle COMMAND：定义如何对规则进行管理 chain：指定你接下来的规则到底是在哪个链上操作的，当定义策略的时候，是可以省略的 CRETIRIA:指定匹配标准 -j ACTION :指定如何进行处理  参数说明    参数 说明 示例     -F 清空规则链 iptables -F   -L 查看规则链 iptables -L   -A 追加规则 iptables -A INPUT   -D 删除规则 iptables -D INPUT 1   -R 修改规则 iptable -R INPUT 1 -s 192.168.120.0 -j DROP   -I 在头部插入规则 iptables -I INPUT 1 –dport 80 -j ACCEPT   -L 查看规则 iptables -L INPUT   -N 新的规则 iptables -N allowed   -V 查看iptables版本 iptables -V   -p 协议（tcp/udp/icmp） iptables -A INPUT -p tcp   -s 匹配原地址，加\" ! “表示除这个IP外 iptables -A INPUT -s 192.168.1.1   -d 匹配目的地址 iptables -A INPUT -d 192.168.12.1   –sport 匹配源端口流入的数据 iptables -A INPUT -p tcp –sport 22   –dport 匹配目的端口流出的数据 iptables -A INPUT -p tcp –dport 22   -i 匹配入口网卡流入的数据 iptables -A INPUT -i eth0   -o 匹配出口网卡流出的数据 iptables -A FORWARD -o eth0   -j 要进行的处理动作:DROP(丢弃)，REJECT(拒绝)，ACCEPT(接受)，SANT(基于原地址的转换) iptable -A INPUT 1 -s 192.168.120.0 -j DROP   –to-source 指定SANT转换后的地址 iptables -t nat -A POSTROUTING -s 192.168.10.0/24 -j SANT –to-source 172.16.100.1   -t 表名(raw、mangle、nat、filter) iptables -t nat   -m 使用扩展模块来进行数据包的匹配(multiport/tcp/state/addrtype) iptables -m multiport    动作说明 处理动作除了 ACCEPT、REJECT、DROP、REDIRECT 和 MASQUERADE 以外，还多出 LOG、ULOG、DNAT、SNAT、MIRROR、QUEUE、RETURN、TOS、TTL、MARK 等，其中某些处理动作不会中断过滤程序，某些处理动作则会中断同一规则链的过滤，并依照前述流程继续进行下一个规则链的过滤，一直到堆栈中的规则检查完毕为止。透过这种机制所带来的好处是，我们可以进行复杂、多重的封包过滤，简单的说，iptables 可以进行纵横交错式的过滤（tables）而非链状过滤（chains）。\n   动作 说明 示例     ACCEPT 将封包放行，进行完此处理动作后，将不再比对其它规则，直接跳往下一个规则链（nat:postrouting）    REJECT 拦阻该封包，并传送封包通知对方，可以传送的封包有几个选择：ICMP port-unreachable、ICMP echo-reply 或是 tcp-reset（这个封包会要求对方关闭联机），进行完此处理动作后，将不再比对其它规则，直接 中断过滤程序。 iptables -A FORWARD -p TCP –dport 22 -j REJECT –reject-with tcp-reset   DROP 丢弃封包不予处理，进行完此处理动作后，将不再比对其它规则，直接中断过滤程序。    REDIRECT 将封包重新导向到另一个端口（PNAT），进行完此处理动作后，将 会继续比对其它规则。 这个功能可以用来实作通透式 porxy 或用来保护 web 服务器。 iptables -t nat -A PREROUTING -p tcp –dport 80 -j REDIRECT –to-ports 8080   MASQUERADE 改写封包来源 IP 为防火墙 NIC IP，可以指定 port 对应的范围，进行完此处理动作后，直接跳往下一个规则链（mangle:postrouting）。这个功能与 SNAT 略有不同，当进行 IP 伪装时，不需指定要伪装成哪个 IP，IP 会从网卡直接读取，当使用拨接连线时，IP 通常是由 ISP 公司的 DHCP 服务器指派的，这个时候 MASQUERADE 特别有用。 iptables -t nat -A POSTROUTING -p TCP -j MASQUERADE –to-ports 1024-31000   LOG 将封包相关讯息纪录在 /var/log 中，详细位置请查阅 /etc/syslog.conf 组态档，进行完此处理动作后，将会继续比对其它规则。 iptables -A INPUT -p tcp -j LOG –log-prefix “INPUT packets”   SNAT 改写封包来源 IP 为某特定 IP 或 IP 范围，可以指定 port 对应的范围，进行完此处理动作后，将直接跳往下一个规则链（mangle:postrouting）。 iptables -t nat -A POSTROUTING -p tcp-o eth0 -j SNAT –to-source 194.236.50.155-194.236.50.160:1024-32000   DNAT 改写封包目的地 IP 为某特定 IP 或 IP 范围，可以指定 port 对应的范围，进行完此处理动作后，将会直接跳往下一个规则链（filter:input 或 filter:forward）。 iptables -t nat -A PREROUTING -p tcp -d 15.45.23.67 –dport 80 -j DNAT –to-destination 192.168.1.1-192.168.1.10:80-100   MIRROR 镜射封包，也就是将来源 IP 与目的地 IP 对调后，将封包送回，进行完此处理动作后，将会中断过滤程序。    QUEUE 中断过滤程序，将封包放入队列，交给其它程序处理。透过自行开发的处理程序，可以进行其它应用，例如：计算联机费用……等。    RETURN 结束在目前规则链中的过滤程序，返回主规则链继续过滤，如果把自订规则链看成是一个子程序，那么这个动作，就相当于提早结束子程序并返回到主程序中。    MARK 将封包标上某个代号，以便提供作为后续过滤的条件判断依据，进行完此处理动作后，将会继续比对其它规则。 iptables -t mangle -A PREROUTING -p tcp –dport 22 -j MARK –set-mark 2    例子 1．在iptables命令后添加-L参数查看已有的防火墙规则链。\n[root@linuxprobe ~]# iptables -L Chain INPUT (policy ACCEPT) target prot opt source destination ACCEPT udp -- anywhere anywhere udp dpt:domain ACCEPT tcp -- anywhere anywhere tcp dpt:domain ACCEPT udp -- anywhere anywhere udp dpt:bootps ACCEPT tcp -- anywhere anywhere tcp dpt:bootps Chain FORWARD (policy ACCEPT) target prot opt source destination ACCEPT all -- anywhere 192.168.122.0/24 ctstate RELATED,ESTABLISHED ACCEPT all -- 192.168.122.0/24 anywhere ACCEPT all -- anywhere anywhere REJECT all -- anywhere anywhere reject-with icmp-port-unreachable REJECT all -- anywhere anywhere reject-with icmp-port-unreachable Chain OUTPUT (policy ACCEPT) target prot opt source destination ACCEPT udp -- anywhere anywhere udp dpt:bootpc 2．在iptables命令后添加-F参数清空已有的防火墙规则链。\n[root@linuxprobe ~]# iptables -F [root@linuxprobe ~]# iptables -L Chain INPUT (policy ACCEPT) target prot opt source destination Chain FORWARD (policy ACCEPT) target prot opt source destination Chain OUTPUT (policy ACCEPT) target prot opt source destination 3．把INPUT规则链的默认策略设置为拒绝。\n[root@linuxprobe ~]# iptables -P INPUT DROP [root@linuxprobe ~]# iptables -L Chain INPUT (policy DROP) target prot opt source destination Chain FORWARD (policy ACCEPT) target prot opt source destination Chain OUTPUT (policy ACCEPT) target prot opt source destination 前文提到，防火墙策略规则的设置无非有两种方式：“通”和“堵”。当把INPUT链设置为默认拒绝后，就要往里面写入允许策略了，否则所有流入的数据包都会被默认拒绝掉。同学们需要留意的是，规则链的默认策略拒绝动作只能是DROP，而不能是REJECT。\n4．向INPUT链中添加允许ICMP流量进入的策略规则。\n在日常运维工作中，经常会使用ping命令来检查对方主机是否在线，而向防火墙的INPUT规则链中添加一条允许ICMP流量进入的策略规则就默认允许了这种ping命令检测行为。\n[root@linuxprobe ~]# iptables -I INPUT -p icmp -j ACCEPT [root@linuxprobe ~]# ping -c 4 192.168.10.10 PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data. 64 bytes from 192.168.10.10: icmp_seq=1 ttl=64 time=0.154 ms 64 bytes from 192.168.10.10: icmp_seq=2 ttl=64 time=0.041 ms 64 bytes from 192.168.10.10: icmp_seq=3 ttl=64 time=0.038 ms 64 bytes from 192.168.10.10: icmp_seq=4 ttl=64 time=0.046 ms --- 192.168.10.10 ping statistics --- 4 packets transmitted, 4 received, 0 packet loss, time 104ms rtt min/avg/max/mdev = 0.038/0.069/0.154/0.049 ms 5．删除INPUT规则链中刚刚加入的那条策略（允许ICMP流量），并把默认策略设置为允许。\n使用-F参数会清空已有的所有防火墙策略；使用-D参数可以删除某一条指定的策略，因此更加安全和准确。\n[root@linuxprobe ~]# iptables -D INPUT 1 [root@linuxprobe ~]# iptables -P INPUT ACCEPT [root@linuxprobe ~]# iptables -L Chain INPUT (policy ACCEPT) target prot opt source destination Chain FORWARD (policy ACCEPT) target prot opt source destination Chain OUTPUT (policy ACCEPT) target prot opt source destination 6．将INPUT规则链设置为只允许指定网段的主机访问本机的22端口，拒绝来自其他所有主机的流量。\n要对某台主机进行匹配，可直接写出它的IP地址；如需对网段进行匹配，则需要写为子网掩码的形式（比如192.168.10.0/24）。\n[root@linuxprobe ~]# iptables -I INPUT -s 192.168.10.0/24 -p tcp --dport 22 -j ACCEPT [root@linuxprobe ~]# iptables -A INPUT -p tcp --dport 22 -j REJECT [root@linuxprobe ~]# iptables -L Chain INPUT (policy ACCEPT) target prot opt source destination ACCEPT tcp -- 192.168.10.0/24 anywhere tcp dpt:ssh REJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachable ………………省略部分输出信息……………… 再次重申，防火墙策略规则是按照从上到下的顺序匹配的，因此一定要把允许动作放到拒绝动作前面，否则所有的流量就将被拒绝掉，从而导致任何主机都无法访问我们的服务。另外，这里提到的22号端口是ssh服务使用的。\n在设置完上述INPUT规则链之后，使用IP地址在192.168.10.0/24网段内的主机访问服务器（即前面提到的设置了INPUT规则链的主机）的22端口，效果如下：\n[root@Client A ~]# ssh 192.168.10.10 The authenticity of host '192.168.10.10 (192.168.10.10)' can't be established. ECDSA key fingerprint is SHA256:5d52kZi1la/FJK4v4jibLBZhLqzGqbJAskZiME6ZXpQ. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added '192.168.10.10' (ECDSA) to the list of known hosts. root@192.168.10.10's password: 此处输入服务器密码 Activate the web console with: systemctl enable --now cockpit.socket Last login: Wed Jan 20 16:30:28 2021 from 192.168.10.1 然后，再使用IP地址在192.168.20.0/24网段内的主机访问服务器的22端口（虽网段不同，但已确认可以相互通信），效果如下：\n[root@Client B ~]# ssh 192.168.10.10 Connecting to 192.168.10.10:22... Could not connect to '192.168.10.10' (port 22): Connection failed. 由上可以看到，提示连接请求被拒绝了（Connection failed）。\n7．向INPUT规则链中添加拒绝所有人访问本机12345端口的策略规则。\n[root@linuxprobe ~]# iptables -I INPUT -p tcp --dport 12345 -j REJECT [root@linuxprobe ~]# iptables -I INPUT -p udp --dport 12345 -j REJECT [root@linuxprobe ~]# iptables -L Chain INPUT (policy ACCEPT) target prot opt source destination REJECT udp -- anywhere anywhere udp dpt:italk reject-with icmp-port-unreachable REJECT tcp -- anywhere anywhere tcp dpt:italk reject-with icmp-port-unreachable ACCEPT tcp -- 192.168.10.0/24 anywhere tcp dpt:ssh REJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachable ………………省略部分输出信息……………… 8．向INPUT规则链中添加拒绝192.168.10.5主机访问本机80端口（Web服务）的策略规则。\n[root@linuxprobe ~]# iptables -I INPUT -p tcp -s 192.168.10.5 --dport 80 -j REJECT [root@linuxprobe ~]# iptables -L Chain INPUT (policy ACCEPT) target prot opt source destination REJECT tcp -- 192.168.10.5 anywhere tcp dpt:http reject-with icmp-port-unreachable REJECT udp -- anywhere anywhere udp dpt:italk reject-with icmp-port-unreachable REJECT tcp -- anywhere anywhere tcp dpt:italk reject-with icmp-port-unreachable ACCEPT tcp -- 192.168.10.0/24 anywhere tcp dpt:ssh REJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachable ………………省略部分输出信息……………… 9．向INPUT规则链中添加拒绝所有主机访问本机1000～1024端口的策略规则。\n前面在添加防火墙策略时，使用的是-I参数，它默认会把规则添加到最上面的位置，因此优先级是最高的。如果工作中需要添加一条最后“兜底”的规则，那就用-A参数吧。这两个参数的效果差别还是很大的：\n[root@linuxprobe ~]# iptables -A INPUT -p tcp --dport 1000:1024 -j REJECT [root@linuxprobe ~]# iptables -A INPUT -p udp --dport 1000:1024 -j REJECT [root@linuxprobe ~]# iptables -L Chain INPUT (policy ACCEPT) target prot opt source destination REJECT tcp -- 192.168.10.5 anywhere tcp dpt:http reject-with icmp-port-unreachable REJECT udp -- anywhere anywhere udp dpt:italk reject-with icmp-port-unreachable REJECT tcp -- anywhere anywhere tcp dpt:italk reject-with icmp-port-unreachable ACCEPT tcp -- 192.168.10.0/24 anywhere tcp dpt:ssh REJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachable REJECT tcp -- anywhere anywhere tcp dpts:cadlock2:1024 reject-with icmp-port-unreachable REJECT udp -- anywhere anywhere udp dpts:cadlock2:1024 reject-with icmp-port-unreachable ………………省略部分输出信息……………… 有关iptables命令的知识讲解到此就结束了，大家是不是意犹未尽？考虑到Linux防火墙的发展趋势，大家只要能把上面的实例吸收消化，就可以完全搞定日常的iptables配置工作了。但是请特别注意，使用iptables命令配置的防火墙规则默认会在系统下一次重启时失效，如果想让配置的防火墙策略永久生效，还要执行保存命令：\n[root@linuxprobe ~]# iptables-save  # Generated by xtables-save v1.8.2 on Wed Jan 20 16:56:27 2021 ………………省略部分输出信息……………… 对了，如果公司服务器是5/6/7版本的话，对应的保存命令应该是：\n[root@linuxprobe ~]# service iptables save iptables: Saving firewall rules to /etc/sysconfig/iptables: [ OK ] 基本概念 iptables 是一个配置 Linux 内核 防火墙 的命令行工具，是 Netfilter 项目的一部分。术语 iptables 也经常代指该内核级防火墙。iptables 可以直接配置，也可以通过许多 控制台 和 图形化 前端配置。iptables 用于 ipv4，ip6tables 用于 IPv6。iptables和ip6tables 拥有相同的语法，但是有些特别的选项，对 IPv4 和 IPv6 有些不同的。\niptables 可以检测、修改、转发、重定向和丢弃 IPv4 数据包。过滤 IPv4 数据包的代码已经内置于内核中，并且按照不同的目的被组织成 表 的集合。表 由一组预先定义的 链 组成，链 包含遍历顺序规则。每一条规则包含一个谓词的潜在匹配和相应的动作（称为 目标），如果谓词为真，该动作会被执行。也就是说条件匹配。iptables 是用户工具，允许用户使用 链 和 规则。很多新手面对复杂的 linux IP 路由时总是感到气馁，但是，实际上最常用的一些应用案例（NAT 或者基本的网络防火墙）并不是很复杂。\n理解 iptables 如何工作的关键是上面这张图。图中在上面的小写字母代表 表，在下面的大写字母代表 链。从任何网络端口 进来的每一个 IP 数据包都要从上到下的穿过这张图。一种常见的错误认知是认为 iptables 对从内部端口进入的数据包和从面向互联网端口进入的数据包采取不同的处理方式，相反，iptabales 对从任何端口进入的数据包都会采取相同的处理方式。可以定义规则使 iptables 采取不同的方式对待从不同端口进入的数据包。当然一些数据包是用于本地进程的，因此在图中表现为从顶端进入，到  停止，而另一些数据包是由本地进程生成的，因此在图中表现为从  发出，一直向下穿过该流程图。一份关于该流程图如何工作的详细解释请参考这里。\n在大多数使用情况下都不会用到 raw，mangle 和 security 表。\n表(Tables) ptables 包含 5 张表（tables）:\n raw 用于配置数据包，raw 中的数据包不会被系统跟踪。 filter 是用于存放所有与防火墙相关操作的默认表。 nat 用于 网络地址转换（例如：端口转发）。 mangle 用于对特定数据包的修改（参考 损坏数据包）。 security 用于 强制访问控制 网络规则（例如： SELinux – 详细信息参考 该文章）。  大部分情况仅需要使用 filter 和 nat。其他表用于更复杂的情况——包括多路由和路由判定——已经超出了本文介绍的范围。\n链(Chains) 表由链组成，链是一些按顺序排列的规则的列表。默认的 filter 表包含 INPUT， OUTPUT 和 FORWARD 3条内建的链，这3条链作用于数据包过滤过程中的不同时间点，如该上面流程图所示。nat 表包含PREROUTING， POSTROUTING 和 OUTPUT 链。\n使用 iptables(8) 查看其他表中内建链的描述。\n默认情况下，任何链中都没有规则。可以向链中添加自己想用的规则。链的默认规则通常设置为 ACCEPT，如果想确保任何包都不能通过规则集，那么可以重置为 DROP。默认的规则总是在一条链的最后生效，所以在默认规则生效前数据包需要通过所有存在的规则。\n用户可以加入自己定义的链，从而使规则集更有效并且易于修改。如何使用自定义链请参考 Simple stateful firewall。\n规则 (Rules) 数据包的过滤基于 规则。规则由一个目标（数据包包匹配所有条件后的动作）和很多匹配（导致该规则可以应用的数据包所满足的条件）指定。一个规则的典型匹配事项是数据包进入的端口（例如：eth0 或者 eth1）、数据包的类型（ICMP, TCP, 或者 UDP）和数据包的目的端口。\n目标使用 -j 或者 --jump 选项指定。目标可以是用户定义的链（例如，如果条件匹配，跳转到之后的用户定义的链，继续处理）、一个内置的特定目标或者是一个目标扩展。内置目标是 ACCEPT， DROP， QUEUE 和 RETURN，目标扩展是 REJECT 和 LOG。如果目标是内置目标，数据包的命运会立刻被决定并且在当前表的数据包的处理过程会停止。如果目标是用户定义的链，并且数据包成功穿过第二条链，目标将移动到原始链中的下一个规则。目标扩展可以被终止（像内置目标一样）或者不终止（像用户定义链一样）。详细信息参阅 iptables-extensions(8)。\n遍历链(Traversing Chains) 该流程图描述链了在任何接口上收到的网络数据包是按照怎样的顺序穿过表的交通管制链。第一个路由策略包括决定数据包的目的地是本地主机（这种情况下，数据包穿过 INPUT 链），还是其他主机（数据包穿过 FORWARD 链）；中间的路由策略包括决定给传出的数据包使用那个源地址、分配哪个接口；最后一个路由策略存在是因为先前的 mangle 与 nat 链可能会改变数据包的路由信息。数据包通过路径上的每一条链时，链中的每一条规则按顺序匹配；无论何时匹配了一条规则，相应的 target/jump 动作将会执行。最常用的3个 target 是 ACCEPT, DROP ,或者 jump 到用户自定义的链。内置的链有默认的策略，但是用户自定义的链没有默认的策略。在 jump 到的链中，若每一条规则都不能提供完全匹配，那么数据包像下面这张图片描述的一样返回到调用链。在任何时候，若 DROP target 的规则实现完全匹配，那么被匹配的数据包会被丢弃，不会进行进一步处理。如果一个数据包在链中被 ACCEPT，那么它也会被所有的父链 ACCEPT，并且不再遍历其他父链。然而，要注意的是，数据包还会以正常的方式继续遍历其他表中的其他链。\n模块(Modules) 有许多模块可以用来扩展 iptables，例如 connlimit, conntrack, limit 和 recent。这些模块增添了功能，可以进行更复杂的过滤。\nFirewalld RHEL 8系统中集成了多款防火墙管理工具，其中firewalld（Dynamic Firewall Manager of Linux systems，Linux系统的动态防火墙管理器）服务是默认的防火墙配置管理工具，它拥有基于CLI（命令行界面）和基于GUI（图形用户界面）的两种管理方式。\n相较于传统的防火墙管理配置工具，firewalld支持动态更新技术并加入了区域（zone）的概念。简单来说，区域就是firewalld预先准备了几套防火墙策略集合（策略模板），用户可以根据生产场景的不同而选择合适的策略集合，从而实现防火墙策略之间的快速切换。例如，我们有一台笔记本电脑，每天都要在办公室、咖啡厅和家里使用。按常理来讲，这三者的安全性按照由高到低的顺序来排列，应该是家庭、公司办公室、咖啡厅。当前，我们希望为这台笔记本电脑制定如下防火墙策略规则：在家中允许访问所有服务；在办公室内仅允许访问文件共享服务；在咖啡厅仅允许上网浏览。在以往，我们需要频繁地手动设置防火墙策略规则，而现在只需要预设好区域集合，然后轻点鼠标就可以自动切换了，从而极大地提升了防火墙策略的应用效率。firewalld中常见的区域名称（默认为public）以及相应的策略规则如表所示。\n   区域 默认规则策略     trusted 允许所有的数据包   home 拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、mdns、ipp-client、amba-client与dhcpv6-client服务相关，则允许流量   internal 等同于home区域   work 拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、ipp-client与dhcpv6-client服务相关，则允许流量   public 拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、dhcpv6-client服务相关，则允许流量   external 拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量   dmz 拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量   block 拒绝流入的流量，除非与流出的流量相关   drop 拒绝流入的流量，除非与流出的流量相关    终端管理工具 命令行终端是一种极富效率的工作方式，firewall-cmd是firewalld防火墙配置管理工具的CLI（命令行界面）版本。它的参数一般都是以“长格式”来提供的。大家不要一听到长格式就头大，因为RHEL 8系统支持部分命令的参数补齐，其中就包含这条命令（很酷吧）。也就是说，现在除了能用Tab键自动补齐命令或文件名等内容之外，还可以用Tab键来补齐表所示的长格式参数。这太棒了！\n   参数 作用     –get-default-zone 查询默认的区域名称   –set-default-zone= 设置默认的区域，使其永久生效   –get-zones 显示可用的区域   –get-services 显示预先定义的服务   –get-active-zones 显示当前正在使用的区域与网卡名称   –add-source= 将源自此IP或子网的流量导向指定的区域   –remove-source= 不再将源自此IP或子网的流量导向某个指定区域   –add-interface= 将源自该网卡的所有流量都导向某个指定区域   –change-interface= 将某个网卡与区域进行关联   –list-all 显示当前区域的网卡配置参数、资源、端口以及服务等信息   –list-all-zones 显示所有区域的网卡配置参数、资源、端口以及服务等信息   –add-service= 设置默认区域允许该服务的流量   –add-port= 设置默认区域允许该端口的流量   –remove-service= 设置默认区域不再允许该服务的流量   –remove-port= 设置默认区域不再允许该端口的流量   –reload 让“永久生效”的配置规则立即生效，并覆盖当前的配置规则   –panic-on 开启应急状况模式   –panic-off 关闭应急状况模式    与Linux系统中其他的防火墙策略配置工具一样，使用firewalld配置的防火墙策略默认为运行时（Runtime）模式，又称为当前生效模式，而且会随着系统的重启而失效。如果想让配置策略一直存在，就需要使用永久（Permanent）模式了，方法就是在用firewall-cmd命令正常设置防火墙策略时添加–permanent参数，这样配置的防火墙策略就可以永久生效了。但是，永久生效模式有一个“不近人情”的特点，就是使用它设置的策略只有在系统重启之后才能自动生效。如果想让配置的策略立即生效，需要手动执行firewall-cmd –reload命令。\n接下来的实验都很简单，但是提醒大家一定要仔细查看使用的是Runtime模式还是Permanent模式。如果不关注这个细节，就算正确配置了防火墙策略，也可能无法达到预期的效果。\n1．查看firewalld服务当前所使用的区域。\n这是一步非常重要的操作。在配置防火墙策略前，必须查看当前生效的是哪个区域，否则配置的防火墙策略将不会立即生效。\n[root@linuxprobe ~]# firewall-cmd --get-default-zone public 2．查询指定网卡在firewalld服务中绑定的区域。\n在生产环境中，服务器大多不止有一块网卡。一般来说，充当网关的服务器有两块网卡，一块对公网，另外一块对内网，那么这两块网卡在审查流量时所用的策略肯定也是不一致的。因此，可以根据网卡针对的流量来源，为网卡绑定不同的区域，实现对防火墙策略的灵活管控。\n[root@linuxprobe ~]# firewall-cmd --get-zone-of-interface=ens160 public 3．把网卡默认区域修改为external，并在系统重启后生效。\n[root@linuxprobe ~]# firewall-cmd --permanent --zone=external --change-interface=ens160 The interface is under control of NetworkManager, setting zone to 'external'. success [root@linuxprobe ~]# firewall-cmd --permanent --get-zone-of-interface=ens160 external 4．把firewalld服务的默认区域设置为public。\n默认区域也叫全局配置，指的是对所有网卡都生效的配置，优先级较低。在下面的代码中可以看到，当前默认区域为public，而ens160网卡的区域为external。此时便是以网卡的区域名称为准。\n通俗来说，默认区域就是一种通用的政策。例如，食堂为所有人准备了一次性餐具，而环保主义者则会自己携带碗筷。如果您自带了碗筷，就可以用自己的；反之就用食堂统一提供的。\n[root@linuxprobe ~]# firewall-cmd --set-default-zone=public Warning: ZONE_ALREADY_SET: public success [root@linuxprobe ~]# firewall-cmd --get-default-zone  public [root@linuxprobe ~]# firewall-cmd --get-zone-of-interface=ens160 external 5．启动和关闭firewalld防火墙服务的应急状况模式。\n如果想在1s的时间内阻断一切网络连接，有什么好办法呢？大家下意识地会说：“拔掉网线！”这是一个物理级别的高招。但是，如果人在北京，服务器在异地呢？panic紧急模式在这个时候就派上用场了。使用–panic-on参数会立即切断一切网络连接，而使用–panic-off则会恢复网络连接。切记，紧急模式会切断一切网络连接，因此在远程管理服务器时，在按下回车键前一定要三思。\n[root@linuxprobe ~]# firewall-cmd --panic-on success [root@linuxprobe ~]# firewall-cmd --panic-off success 6．查询SSH和HTTPS协议的流量是否允许放行。\n在工作中可以不使用–zone参数指定区域名称，firewall-cmd命令会自动依据默认区域进行查询，从而减少用户输入量。但是，如果默认区域与网卡所绑定的不一致时，就会发生冲突，因此规范写法的zone参数是一定要加的。\n[root@linuxprobe ~]# firewall-cmd --zone=public --query-service=ssh yes [root@linuxprobe ~]# firewall-cmd --zone=public --query-service=https no 7．把HTTPS协议的流量设置为永久允许放行，并立即生效。\n默认情况下进行的修改都属于Runtime模式，即当前生效而重启后失效，因此在工作和考试中尽量避免使用。而在使用–permanent参数时，则是当前不会立即看到效果，而在重启或重新加载后方可生效。于是，在添加了允许放行HTTPS流量的策略后，查询当前模式策略，发现依然是不允许放行HTTPS协议的流量：\n[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --add-service=https success [root@linuxprobe ~]# firewall-cmd --zone=public --query-service=https no 不想重启服务器的话，就用–reload参数吧：\n[root@linuxprobe ~]# firewall-cmd --reload success [root@linuxprobe ~]# firewall-cmd --zone=public --query-service=https yes 8．把HTTP协议的流量设置为永久拒绝，并立即生效。\n由于在默认情况下HTTP协议的流量就没有被允许，所以会有“Warning: NOT_ENABLED: http”这样的提示信息，因此对实际操作没有影响。\n[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --remove-service=http Warning: NOT_ENABLED: http success [root@linuxprobe ~]# firewall-cmd --reload  success 9．把访问8080和8081端口的流量策略设置为允许，但仅限当前生效。\n[root@linuxprobe ~]# firewall-cmd --zone=public --add-port=8080-8081/tcp success [root@linuxprobe ~]# firewall-cmd --zone=public --list-ports 8080-8081/tcp 10．把原本访问本机888端口的流量转发到22端口，要且求当前和长期均有效。\nSSH远程控制协议是基于TCP/22端口传输控制指令的，如果想让用户通过其他端口号也能访问ssh服务，就可以试试端口转发技术了。通过这项技术，新的端口号在收到用户请求后会自动转发到原本服务的端口上，使得用户能够通过新的端口访问到原本的服务。\n来举个例子帮助大家理解。假设小强是电子厂的工人，他喜欢上了三号流水线上的工人小花，但不好意思表白，于是写了一封情书并交给门卫张大爷，希望由张大爷转交给小花。这样一来，情书（信息）的传输由从小强到小花，变成了小强到张大爷再到小花，情书（信息）依然能顺利送达。\n使用firewall-cmd命令实现端口转发的格式有点长，这里为大家总结好了：\nfirewall-cmd --permanent --zone= --add-forward-port=port=:proto=:toport=:toaddr= 上述命令中的目标IP地址一般是服务器本机的IP地址：\n[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --add-forward-port=port=888:proto=tcp:toport=22:toaddr=192.168.10.10 success [root@linuxprobe ~]# firewall-cmd --reload success 在客户端使用ssh命令尝试访问192.168.10.10主机的888端口，访问成功：\n[root@client A ~]# ssh -p 888 192.168.10.10 The authenticity of host '[192.168.10.10]:888 ([192.168.10.10]:888)' can't be established. ECDSA key fingerprint is b8:25:88:89:5c:05:b6:dd:ef:76:63:ff:1a:54:02:1a. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added '[192.168.10.10]:888' (ECDSA) to the list of known hosts. root@192.168.10.10's password:此处输入远程root管理员的密码 Last login: Sun Jul 19 21:43:48 2021 from 192.168.10.10 11．富规则的设置。\n富规则也叫复规则，表示更细致、更详细的防火墙策略配置，它可以针对系统服务、端口号、源地址和目标地址等诸多信息进行更有针对性的策略配置。它的优先级在所有的防火墙策略中也是最高的。比如，我们可以在firewalld服务中配置一条富规则，使其拒绝192.168.10.0/24网段的所有用户访问本机的ssh服务（22端口）：\n[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --add-rich-rule=\"rule family=\"ipv4\" source address=\"192.168.10.0/24\" service name=\"ssh\" reject\" success [root@linuxprobe ~]# firewall-cmd --reload success 在客户端使用ssh命令尝试访问192.168.10.10主机的ssh服务（22端口）：\n[root@client A ~]# ssh 192.168.10.10 Connecting to 192.168.10.10:22... Could not connect to '192.168.10.10' (port 22): Connection failed. 图形管理工具 在各种版本的Linux系统中，几乎没有能让刘遄老师欣慰并推荐的图形化工具，但是firewall-config做到了。它是firewalld防火墙配置管理工具的GUI（图形用户界面）版本，几乎可以实现所有以命令行来执行的操作。毫不夸张地说，即使读者没有扎实的Linux命令基础，也完全可以通过它来妥善配置RHEL 8中的防火墙策略。\n成功 firewall-config 安装后，其工具的界面如图所示：\n其功能具体如下。\n1：选择运行时（Runtime）或永久（Permanent）模式的配置。\n2：可选的策略集合区域列表。\n3：常用的系统服务列表。\n4：主机地址的黑白名单。\n5：当前正在使用的区域。\n6：管理当前被选中区域中的服务。\n7：管理当前被选中区域中的端口。\n8：设置允许被访问的协议。\n9：设置允许被访问的端口。\n10：开启或关闭SNAT（源网络地址转换）技术。\n11：设置端口转发策略。\n12：控制请求icmp服务的流量。\n13：管理防火墙的富规则。\n14：被选中区域的服务，若勾选了相应服务前面的复选框，则表示允许与之相关的流量。\n15：firewall-config工具的运行状态。\n除了图中列出的功能，还有用于将网卡与区域绑定的Interfaces选项，以及用于将IP地址与区域绑定的Sources选项。另外再啰唆一句。在使用firewall-config工具配置完防火墙策略之后，无须进行二次确认，因为只要有修改内容，它就自动进行保存。\n下面进行动手实践环节。\n先将当前区域中请求http服务的流量设置为允许放行，但仅限当前生效。具体配置如图所示：\n尝试添加一条防火墙策略规则，使其放行访问8080～8088端口（TCP协议）的流量，并将其设置为永久生效，以达到系统重启后防火墙策略依然生效的目的。在按照下图所示的界面配置完毕之后，还需要在Options菜单中单击Reload Firewalld命令，让配置的防火墙策略立即生效。这与在命令行中使用–reload参数的效果一样。\n放行访问8080～8088端口的流量：\n让配置的防火墙策略规则立即生效：\n前面在讲解firewall-config工具的功能时，曾经提到了SNAT（Source Network Address Translation，源网络地址转换）技术。SNAT是一种为了解决IP地址匮乏而设计的技术，它可以使得多个内网中的用户通过同一个外网IP接入Internet。该技术的应用非常广泛，甚至可以说我们每天都在使用，只不过没有察觉到罢了。比如，当通过家中的网关设备（无线路由器）访问本书配套站点www.linuxprobe.com时，就用到了SNAT技术。\n大家可以看一下在网络中不使用SNAT技术和使用SNAT技术时的情况。在没有使用SNAT技术的局域网中有多台PC，如果网关服务器没有应用SNAT技术，则互联网中的网站服务器在收到PC的请求数据包，并回送响应数据包时，将无法在网络中找到这个私有网络的IP地址，所以PC也就收不到响应数据包了。在使用SNAT技术处理过的局域网中，由于网关服务器应用了SNAT技术，所以互联网中的网站服务器会将响应数据包发给网关服务器，再由后者转发给局域网中的PC。\n没有使用SNAT技术的网络：\n使用SNAT技术处理过的网络：\n使用iptables命令实现SNAT技术是一件很麻烦的事情，但是在firewall-config中却是小菜一碟了。用户只需按照下图进行配置，并选中Masquerade zone复选框，就自动开启了SNAT技术。\n为了让大家直观查看不同工具在实现相同功能时的区别，针对前面使用firewall-cmd配置的防火墙策略规则，这里使用firewall-config工具进行了重新演示：将本机888端口的流量转发到22端口，且要求当前和长期均有效，具体如下图所示：\n配置本地的端口转发：\n让防火墙效策略规则立即生效：\n用命令配置富规则可真辛苦，幸好我们现在有了图形用户界面的工具。让192.168.10.20主机访问本机的1234端口号，如下图所示。其中Element选项能够根据服务名称、端口号、协议等信息进行匹配；Source与Destination选项后的inverted复选框代表反选功能，将其选中则代表对已填写信息进行反选，即选中填写信息以外的主机地址；Log复选框在选中后，日志不仅会被记录到日志文件中，而且还可以在设置日志的级别（Level）后，再将日志记录到日志文件中，以方便后续的筛查。\n如果生产环境中的服务器有多块网卡在同时提供服务（这种情况很常见），则对内网和对外网提供服务的网卡要选择的防火墙策略区域也是不一样的。也就是说，可以把网卡与防火墙策略区域进行绑定，这样就可以使用不同的防火墙区域策略，对源自不同网卡的流量进行有针对性的监控，效果会更好。\n把网卡与防火墙策略区域进行绑定：\n网卡与策略区域绑定完成：\n最后再提一句，firewall-config工具真的非常实用，很多原本复杂的长命令被图形化按钮替代，设置规则也简单明了，足以应对日常工作。所以再次向大家强调配置防火墙策略的原则—只要能实现所需的功能，用什么工具请随君便。\n服务的访问控制列表 TCP Wrapper是RHEL 6/7系统中默认启用的一款流量监控程序，它能够根据来访主机的地址与本机的目标服务程序做出允许或拒绝的操作。在RHEL 8版本中，它已经被firewalld正式替代。换句话说，Linux系统中其实有两个层面的防火墙，第一种是前面讲到的基于TCP/IP协议的流量过滤工具，而TCP Wrapper服务则是能允许或禁止Linux系统提供服务的防火墙，从而在更高层面保护了Linux系统的安全运行。\nTCP Wrapper服务的防火墙策略由两个控制列表文件所控制，用户可以编辑允许控制列表文件来放行对服务的请求流量，也可以编辑拒绝控制列表文件来阻止对服务的请求流量。控制列表文件修改后会立即生效，系统将会先检查允许控制列表文件（/etc/hosts.allow），如果匹配到相应的允许策略则放行流量；如果没有匹配，则会进一步匹配拒绝控制列表文件（/etc/hosts.deny），若找到匹配项则拒绝该流量。如果这两个文件都没有匹配到，则默认放行流量。\n由于RHEL 8版本已经不再支持TCP Wrapper服务程序，因此我们接下来选择在一台老版本的服务器上进行实验。TCP Wrapper服务的控制列表文件配置起来并不复杂，常用的参数如表所示。\n   客户端类型 示例 满足示例的客户端列表     单一主机 192.168.10.10 IP地址为192.168.10.10的主机   指定网段 192.168.10. IP段为192.168.10.0/24的主机   指定网段 192.168.10.0/255.255.255.0 IP段为192.168.10.0/24的主机   指定DNS后缀 .linuxprobe.com 所有DNS后缀为.linuxprobe.com的主机   指定主机名称 www.linuxprobe.com 主机名称为www.linuxprobe.com的主机   指定所有客户端 ALL 所有主机全部包括在内    在配置TCP Wrapper服务时需要遵循两个原则：\n 编写拒绝策略规则时，填写的是服务名称，而非协议名称； 建议先编写拒绝策略规则，再编写允许策略规则，以便直观地看到相应的效果。  下面编写拒绝策略规则文件，禁止访问本机sshd服务的所有流量（无须修改/etc/hosts.deny文件中原有的注释信息）：\n[root@linuxprobe ~]# vim /etc/hosts.deny # # hosts.deny This file contains access rules which are used to # deny connections to network services that either use # the tcp_wrappers library or that have been # started through a tcp_wrappers-enabled xinetd. # # The rules in this file can also be set up in # /etc/hosts.allow with a 'deny' option instead. # # See 'man 5 hosts_options' and 'man 5 hosts_access' # for information on rule syntax. # See 'man tcpd' for information on tcp_wrappers sshd:* [root@linuxprobe ~]# ssh 192.168.10.10 ssh_exchange_identification: read: Connection reset by peer 接下来，在允许策略规则文件中添加一条规则，使其放行源自192.168.10.0/24网段，且访问本机sshd服务的所有流量。可以看到，服务器立刻就放行了访问sshd服务的流量，效果非常直观：\n[root@linuxprobe ~]# vim /etc/hosts.allow # # hosts.allow This file contains access rules which are used to # allow or deny connections to network services that # either use the tcp_wrappers library or that have been # started through a tcp_wrappers-enabled xinetd. # # See 'man 5 hosts_options' and 'man 5 hosts_access' # for information on rule syntax. # See 'man tcpd' for information on tcp_wrappers sshd:192.168.10. [root@linuxprobe ~]# ssh 192.168.10.10 The authenticity of host '192.168.10.10 (192.168.10.10)' can't be established. ECDSA key fingerprint is 70:3b:5d:37:96:7b:2e:a5:28:0d:7e:dc:47:6a:fe:5c. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added '192.168.10.10' (ECDSA) to the list of known hosts. root@192.168.10.10's password: Last login: Wed May 4 07:56:29 2021 [root@linuxprobe ~]#  Cockpit 驾驶舱管理工具 首先，Cockpit是一个英文单词，即“（飞机、船或赛车的）驾驶舱、驾驶座”，它用名字传达出了功能丰富的特性。其次，Cockpit是一个基于Web的图形化服务管理工具，对用户相当友好，即便是新手也可以轻松上手。而且它天然具备很好的跨平台性，因此被广泛应用于服务器、容器、虚拟机等多种管理场景。最后，红帽公司对Cockpit也十分看重，直接将它默认安装到了RHEL 8系统中，由此衍生的CentOS和Fedora也都标配有Cockpit。\nCockpit在默认情况下就已经被安装到系统中。下面执行dnf命令对此进行确认：\n[root@linuxprobe ~]# dnf install cockpit Updating Subscription Management repositories. Unable to read consumer identity This system is not registered to Red Hat Subscription Management. You can use subscription-manager to register. AppStream 3.1 MB/s | 3.2 kB 00:00 BaseOS 2.7 MB/s | 2.7 kB 00:00 Package cockpit-185-2.el8.x86_64 is already installed. Dependencies resolved. Nothing to do. Complete! 但是，Cockpit服务程序在RHEL 8版本中没有自动运行，下面将它开启并加入到开机启动项中：\n[root@linuxprobe ~]# systemctl start cockpit [root@linuxprobe ~]# systemctl enable cockpit.socket Created symlink /etc/systemd/system/sockets.target.wants/cockpit.socket → /usr/lib/systemd/system/cockpit.socket. 在Cockpit服务启动后，打开系统自带的浏览器，在地址栏中输入“本机地址:9090”即可访问。由于访问Cockpit的流量会使用HTTPS进行加密，而证书又是在本地签发的，因此还需要进行添加并信任本地证书的操作。\n添加额外允许的证书：\n确认信任本地证书：\n进入Cockpit的登录界面后，输入root管理员的账号与系统密码，单击Log In按钮后即可进入：\n进入Cockpit的Web界面，发现里面可谓“别有洞天”。Cockpit总共分为13个功能模块：系统状态（System）、日志信息（Logs）、硬盘存储（Storage）、网卡网络（Networking）、账户安全（Accounts）、服务程序（Services）、软件仓库（Applications）、报告分析（Diagnostic Reports）、内核排错（Kernel Dump）、SElinux、更新软件（Software Updates）、订阅服务（Subscriptions）、终端界面（Terminal）。下面逐一进行讲解。\n1．System\n进入Cockpit界面后默认显示的便是System（系统）界面，在该界面中能够看到系统架构、版本、主机名与时间等信息，还能够动态地展现出CPU、硬盘、内存和网络的复杂情况，这有点类似于Web版的“Winodws系统任务管理器”，属实好用。\n系统状态界面：\n2．Logs\n这个模块能够提供系统的全部日志，但是同学们可能会好奇，“为什么下图中的内容这么有限呢”？原因出在图中的两个选项中：时间和日志级别。通过这两个选项可以让用户更快地找到所需信息，而不是像/var/log/message文件那样一股脑儿地都抛给用户。\n日志信息界面：\n3．Storage\n这个功能模块是同学们最喜欢的一个模块，原因不是这个模块显示了硬盘的I/O读写负载情况，而是可以让用户通过该界面，用鼠标创建出RAID、LVM、VDO和iSCSI等存储设备。是的，您没有看错，RAID和LVM都可以用鼠标进行创建了，是不是很开心呢？\n硬盘存储界面：\n4．Networking\n既然名为Networking模块，那么动态看网卡的输出和接收值肯定是这个模块的标配功能了。我们不仅可以在这里进行网卡的绑定（Bonding）和聚合（Team），还可以创建桥接网卡及添加VLAN。最下方会单独列出与网卡相关的日志信息。\n网卡网络界面：\n**5．**Accounts\n大家千万别小看Accounts模块，虽然它的账户安全界面有些简陋，只有一个用于创建账户的按钮，但只要点击进入某个用户的管理界面中，马上会发现“别有洞天”——账户管理界面，这个界面中的功能非常丰富，我们在这里可以对用户进行重命名，设置用户的权限，还可以锁定、修改密码以及创建SSH密钥信息。\n账户安全界面：\n账户管理界面：\n6．Services\n在Services功能模块的界面中，可以查看系统中已有的服务列表和运行状态。单击某一服务，进入该服务的管理界面后，可以对具体的服务进行开启、关闭操作。在Services功能模块中设置了服务并将其加入到开机启动项后，在系统重启后也依然会为用户提供服务。\n服务程序界面：\n服务管理界面：\n7．Applications\n后期采用Cockpit或红帽订阅服务安装的软件都会显示在这个功能模块中。\n软件仓库界面：\n8．Diagnostic Report\nDiagnostic Report模块的功能是帮助用户收集及分析系统的信息，找到系统出现问题的原因。单击Create Report按钮后大约两分钟左右，会出现报告生成完毕的弹窗。好吧，摊牌了，这个功能其实很鸡肋，就是将sosreport命令做成了一个网页按钮。\n报告分析界面：\n报告生成完毕：\n9．Kernel Dump\nKernel Dump（Kdump）是一个在系统崩溃、死锁或死机时用来收集内核参数的一个服务。举例来说，如果有一天系统崩溃了，这时Kdump服务就会开始工作，将系统的运行状态和内核数据收集到一个名为dump core的文件中，以便后续让运维人员分析并找出问题所在。由于我们在安装系统时没有启动该服务，所以可以等到后续使用时再开启该功能界面。\n内核排错界面：\n10．SElinux\n下图所示为SELinux服务的控制按钮和警告信息界面。\nSElinux管理界面：\n11．Software Updates\n这里提到的Software Updates并不是我们用来更新其他常规软件的一个界面，而是用来对红帽客户订阅的服务进行更新的界面。用户只有在购买了红帽第三方服务后才能使用这里面的功能。在购买了红帽订阅服务后，用户便可以在这里下载到相应服务程序的最新版本和稳定版本。\n更新软件界面：\n12．Subscriptions\n这里依然是一则红帽公司的“小广告”—如果想成为尊贵的红帽服务用户，要付费购买订阅服务。个人用户无须购买，而且这对我们的后续实验没有任何影响。\n订阅服务界面：\n12．Terminal\n压轴的总是在最后。Cockpit服务提供了Shell终端的在线控制平台，可方便用户通过网页上的终端功能管理服务器。这个功能深受运维人员喜爱。\n终端管理界面\n至此，相信各位读者已经充分掌握了防火墙的管理能力。防火墙管理工具有很多种，我们任选其一即可。在配置后续的服务前，大家要记得检查网络和防火墙的状态，以避免出现服务明明配置正确，但无法从外部访问的情况，最终影响实验效果。\n在 Ubuntu 上使用 UFW\u0026GUFW Ubuntu 20.04 随附了一个称为UFW（非复杂防火墙）的防火墙配置工具。 它是用于管理iptables防火墙规则的用户友好型前端。 它的主要目标是使防火墙的管理变得更容易，或者顾名思义，变得简单。而GUFW是UFW的图形介面。\n检查UFW状态 UFW默认情况下处于禁用状态。 您可以使用以下命令检查UFW服务的状态：\n$ sudo ufw status verbose 输出将显示防火墙状态为非活动：\nStatus: inactive 如果UFW已激活，则输出将类似于以下内容：\nStatus: active UFW默认策略 UFW防火墙的默认行为是阻止所有传入和转发流量，并允许所有出站流量。 这意味着除非您专门打开端口，否则任何尝试访问您的服务器的人都将无法连接。 服务器上运行的应用程序和服务将可以访问外界。\n默认策略在/etc/default/ufw文件中定义，可以通过手动修改文件或使用sudo ufw default  命令来更改。\n防火墙策略是建立更复杂和用户定义的规则的基础。 通常，最初的UFW默认策略是一个很好的起点。\n应用配置文件 应用程序配置文件是INI格式的文本文件，描述了服务并包含该服务的防火墙规则。 在安装软件包期间，会在/etc/ufw/applications.d目录中创建应用程序配置文件。\n您可以通过键入以下内容列出服务器上所有可用的应用程序配置文件：\n$ sudo ufw app list Available applications: Nginx Full Nginx HTTP Nginx HTTPS OpenSSH 要查找有关特定配置文件和包含的规则的更多信息，请使用以下命令：\n$ sudo ufw app info 'Nginx Full' Profile: Nginx Full Title: Web Server (Nginx, HTTP + HTTPS) Description: Small, but very powerful and efficient web server Ports: 80,443/tcp 输出显示“ Nginx Full”配置文件打开了端口80和443。\n您也可以为应用创建自定义配置文件。\n启用UFW 如果要从远程位置连接到Ubuntu，则在启用UFW防火墙之前，必须明确允许传入的SSH连接。 否则，您将无法连接到计算机。\n要将您的UFW防火墙配置为允许传入的SSH连接，请键入以下命令：\n$ sudo ufw allow ssh Rules updated Rules updated (v6) 如果SSH在非标准端口上运行，则需要打开该端口。\n例如，如果您的ssh守护程序侦听端口7722，请输入以下命令以允许该端口上的连接：\n$ sudo ufw allow 7722/tcp 现在已将防火墙配置为允许传入的SSH连接，您可以通过键入以下内容来启用它：\n$ sudo ufw enable Command may disrupt existing ssh connections. Proceed with operation (y|n)? y Firewall is active and enabled on system startup 将警告您启用防火墙可能会破坏现有的ssh连接，只需键入y并单击Enter。\n打开端口 根据系统上运行的应用程序，您可能还需要打开其他端口。 打开端口的一般语法如下：\n$ ufw allow port_number/protocol 以下是有关如何允许HTTP连接的几种方法。\n第一种选择是使用服务名称。 UFW检查/etc/services文件中指定服务的端口和协议：\n$ sudo ufw allow http 您还可以指定端口号和协议：\n$ sudo ufw allow 80/tcp 如果未给出协议，则UFW会同时为tcp和udp创建规则。\n另一个选择是使用应用程序配置文件； 在这种情况下，“ Nginx HTTP”：\n$ sudo ufw allow 'Nginx HTTP' UFW还支持使用proto关键字指定协议的另一种语法：\n$ sudo ufw allow proto tcp to any port 80 端口范围\nUFW还允许您打开端口范围。 起始端口和结束端口用冒号（:）分隔，并且您必须指定协议tcp或udp。\n例如，如果要同时在tcp和udp上允许端口从7100到7200，则可以运行以下命令：\n$ sudo ufw allow 7100:7200/tcp 特定的IP地址和端口\n要允许来自给定源IP的所有端口上的连接，请使用from关键字，后跟源地址。\n以下是将IP地址列入白名单的示例：\n$ sudo ufw allow from 64.63.62.61 如果要仅允许给定IP地址访问特定端口，请使用to any port关键字，后跟端口号。\n例如，要允许IP地址为64.63.62.61的计算机访问端口22，请输入：\n$ sudo ufw allow from 64.63.62.61 to any port 22 子网\n允许连接到IP地址子网的语法与使用单个IP地址时的语法相同。 唯一的区别是您需要指定子网掩码。\n下面是一个示例，显示了如何允许访问从192.168.1.1到192.168.1.254的IP地址到端口3360（MySQL ）：\n$ sudo ufw allow from 192.168.1.0/24 to any port 3306 特定网络接口\n要允许在特定的网络接口上进行连接，请使用in on关键字，后跟网络接口(网卡)的名称：\n$ sudo ufw allow in on eth2 to any port 3306 拒绝连接 所有传入连接的默认策略均设置为deny，如果您未更改默认策略，除非您专门打开连接，否则UFW会阻止所有传入连接。\n撰写拒绝规则与撰写允许规则相同； 您只需要使用deny关键字而不是allow。\n假设您打开了端口80和443，并且服务器受到23.24.25.0/24网络的攻击。 要拒绝来自23.24.25.0/24的所有连接，您可以运行以下命令：\n$ sudo ufw deny from 23.24.25.0/24 以下是拒绝访问23.24.25.0/24中的端口80和443的示例，您可以使用以下命令：\n$ sudo ufw deny proto tcp from 23.24.25.0/24 to any port 80,443 删除UFW规则 有两种方法可以通过规则编号和指定实际规则来删除UFW规则。\n按规则号删除规则比较容易，尤其是当您不熟悉UFW时。 要首先通过规则编号删除规则，您需要找到要删除的规则的编号。 要获取编号规则的列表，请使用ufw status numbered命令：\n$ sudo ufw status numbered Status: active To Action From -- ------ ---- [ 1] 22/tcp ALLOW IN Anywhere [ 2] 80/tcp ALLOW IN Anywhere [ 3] 8080/tcp ALLOW IN Anywhere 要删除规则号3，该规则号允许连接到端口8080，请输入：\n$ sudo ufw delete 3 第二种方法是通过指定实际规则来删除规则。 例如，如果您添加了打开端口8069的规则，则可以使用以下命令将其删除：\n$ sudo ufw delete allow 8069 禁用UFW 如果出于任何原因要停止UFW并停用所有规则，则可以使用：\n$ sudo ufw disable 以后，如果您想重新启用UTF并激活所有规则，只需键入：\n$ sudo ufw enable 重设UFW 重置UFW将禁用UFW，并删除所有活动规则。 如果您想还原所有更改并重新开始，这将很有帮助。\n要重置UFW，请输入以下命令：\n$ sudo ufw reset IP伪装 IP伪装是Linux内核中NAT（网络地址转换）的一种变体，它通过重写源IP地址和目标IP地址和端口来转换网络流量。 借助IP伪装，您可以使用一台充当网关的Linux计算机，允许专用网络中的一台或多台计算机与Internet通信。\n使用UFW配置IP伪装涉及几个步骤。\n首先，您需要启用IP转发。 为此，请打开/etc/ufw/sysctl.conf文件，查找并取消注释以下行：net.ipv4.ip_forward = 1：\n$ sudo nano /etc/ufw/sysctl.conf net/ipv4/ip_forward=1 接下来，您需要配置UFW以允许转发数据包。 打开UFW配置文件，找到DEFAULT_FORWARD_POLICY键，然后将值从DROP更改为ACCEPT：\n$ sudo nano /etc/default/ufw DEFAULT_FORWARD_POLICY=\"ACCEPT\" 现在，您需要在nat表中设置POSTROUTING链的默认策略和伪装规则。 为此，请打开/etc/ufw/before.rules文件，附加以下几行：\n$ sudo nano /etc/ufw/before.rules #NAT table rules *nat :POSTROUTING ACCEPT [0:0] # Forward traffic through eth0 - Change to public network interface -A POSTROUTING -s 10.8.0.0/16 -o eth0 -j MASQUERADE # don't delete the 'COMMIT' line or these rules won't be processed COMMIT 别忘了在-A POSTROUTING行中替换eth0以匹配公共网络接口的名称：\n完成后，保存并关闭文件。\n最后，通过禁用和重新启用UFW重新加载UFW规则：\n$ sudo ufw disable $ sudo ufw e Linux Kernel 来自 Wikipedia:\n 内核是计算机操作系统的核心组件，对系统有完全的控制。开机时最先启动，然后负责后续的启动工作。它负责处理其它软件的请求，将这些请求转化为中央处理器的数据处理请求。内核还负责管理内存，管理系统和其它打印机、扬声器等外围设备的通讯，是操作系统最基础的部分。\n 内核包安装在/boot/下的文件系统上。为了能够引导到内核，必须适当配置启动加载器。\nKernel module 内核模块是可以按需加载或卸载的内核代码，可以不重启系统就扩充内核的功能。\n要创建内核模块，请阅读此指南。模块可以设置成内置或者动态加载，要编译成可动态加载，需要在内核配置时将模块配置为 M (模块)。\n获取信息 模块保存在 /lib/modules/kernel_release (使用 uname -r 命令显示当前内核版本)。\n注意： 模块名通常使用 (_) 或 - 连接，但是这些符号在 modprobe 命令和 /etc/modprobe.d/ 配置文件中都是可以相互替换的。\n显示当前装入的内核模块：\n$ lsmod 在上面的输出中：\n Module 显示每个模块的名称 Size 显示每个模块的大小（并不是它们占的内存大小） Used by 显示每个模块被使用的次数和使用它们的模块  显然，这里有很多模块。加载的模块数量取决于你的系统和版本以及正在运行的内容。我们可以这样计数：\n$ lsmod | wc -l 67 modules.builtin 文件中列出了所有构建在内核中的模块\n$ more /lib/modules/$(uname -r)/modules.builtin | head -10 kernel/arch/x86/crypto/crc32c-intel.ko kernel/arch/x86/events/intel/intel-uncore.ko kernel/arch/x86/platform/intel/iosf_mbi.ko kernel/mm/zpool.ko kernel/mm/zbud.ko kernel/mm/zsmalloc.ko kernel/fs/binfmt_script.ko kernel/fs/mbcache.ko kernel/fs/configfs/configfs.ko kernel/fs/crypto/fscrypto.ko 显示模块信息：\n$ modinfo module_name 显示所有模块的配置信息：\n$ modprobe -c | less 显示某个模块的配置信息：\n$ modprobe -c | grep module_name 显示一个装入模块使用的选项：\n$ systool -v -m module_name 显示模块的依赖关系：\n$ modprobe --show-depends module_name 使用systemd自动加载模块 目前，所有必要模块的加载均由 udev 自动完成。所以，如果不需要使用任何额外的模块，就没有必要在任何配置文件中添加启动时加载的模块。但是，有些情况下可能需要在系统启动时加载某个额外的模块，或者将某个模块列入黑名单以便使系统正常运行。\n内核模块可以在/etc/modules-load.d/ 下的文件中明确列出，以便systemd在引导过程中加载它们。 每个配置文件都以 /etc/modules-load.d/.conf的样式命名。 配置文件仅包含要加载的内核模块名称列表，以换行符分隔。 空行和第一个非空白字符为#或;的行被忽略。\n$ cat /etc/modules-load.d/virtio-net.conf # Load virtio_net.ko at boot virtio_net 另见modules-load.d(5)。\n手动加载卸载 控制内核模块载入/移除的命令是kmod 软件包提供的, 要手动装入模块的话，执行:\n# modprobe module_name 按文件名加载模块:\n# insmod filename [args] 注意： 如果升级了内核但是没有重启，路径 /usr/lib/modules/$(uname -r)/ 已经不存在。modprobe 会返回错误 1，没有额外的错误信息。如果出现 modprobe 加载失败，请检查模块路径以确认是否是这个问题导致。\n如果要移除一个模块：\n# modprobe -r module_name 或者:\n# rmmod module_name 配置模块参数 手动加载时设置 传递参数的基本方式是使用 modprobe 选项，格式是 key=value：\n# modprobe module_name parameter_name=parameter_value 使用 /etc/modprobe.d/中的文件 要通过配置文件传递参数，在 /etc/modprobe.d/ 中放入任意名称 .conf 文件，加入:\n$ sudo gedit /etc/modprobe.d/myfilename.conf options modname parametername=parametercontents 例如\n$ sudo gedit /etc/modprobe.d/thinkfan.conf # On thinkpads, this lets the thinkfan daemon control fan speed options thinkpad_acpi fan_control=1 注意： 如果要在启动时就修改内核参数(从 init ramdisk 开始)，需要将相应的.conf-文件加入 mkinitcpio.conf 的 FILES 参数中。\n使用内核命令行 如果模块直接编译进内核，也可以通过启动管理器(GRUB, LILO 或 Syslinux)的内核行加入参数：\nmodname.parametername=parametercontents 例如:\nthinkpad_acpi.fan_control=1 别名 $ cat /etc/modprobe.d/myalias.conf # Lets you use 'mymod' in MODULES, instead of 'really_long_module_name' alias mymod really_long_module_name 有些模块具有别名，以方便其它程序自动装入模块。禁用这些别名可以阻止自动装入，但是仍然可以手动装入。\n$ cat /etc/modprobe.d/modprobe.conf # Prevent autoload of bluetooth alias net-pf-31 off # Prevent autoload of ipv6 alias net-pf-10 off 黑名单 禁用内核模块 对内核模块来说，黑名单是指禁止某个模块装入的机制。当对应的硬件不存在或者装入某个模块会导致问题时很有用。\n有些模块作为 initramfs 的一部分装入。\nmkinitcpio -M 会显示所有自动检测到到模块：要阻止 initramfs 装入某些模块，可以在 /etc/modprobe.d中将它们加入黑名单。并应在映像生成过程中通过modconf挂钩将其添加。\n运行 mkinitcpio -v 会显示各种钩子(例如 filesystem 钩子, SCSI 钩子等)装入的模块。如果您的HOOKS 数组中没有 modconf 钩子（例如，和默认配置不同）则请将该”.conf\"文件添加到/etc/mkinitcpio.conf中的FILES数组中。一旦您将其列入黑名单，请重新生成 initramfs，然后重新启动。\n使用 /etc/modprobe.d/ 中的文件 在 /etc/modprobe.d/ 中创建 .conf 文件，使用 blacklist 关键字屏蔽不需要的模块，例如如果不想装入 pcspkr 模块：\n$ sudo gedit /etc/modprobe.d/nobeep.conf # Do not load the pcspkr module on boot blacklist pcspkr 注意： blacklist 命令将屏蔽一个模板，所以不会自动装入，但是如果其它非屏蔽模块需要这个模块，系统依然会装入它。\n要避免这个行为，可以让 modprobe 使用自定义的 install 命令，而不是像往常一样将模块插入内核，因此您可以通过以下方式强制模块始终无法加载：\n$ sudo gedit /etc/modprobe.d/blacklist.conf ... install MODULE /bin/true ... 这样就可以 “屏蔽” 模块及所有依赖它的模块。\n使用内核命令行 提示： 如果模块损坏导致无法引导系统，这将非常有用。\n您也可以从引导加载程序中将模块列入黑名单。\n如Kernel参数.中所述，只需将module_blacklist=modname1,modname2,modname3 添加到引导加载程序的内核行中即可。\n注意： 将多个模块列入黑名单时，请注意，它们之间仅用逗号分隔。 空格或其他内容可能会破坏语法。\nKernel parameters 一共有三种办法，可以给内核传递参数，用于控制其行为方式：\n 在编译内核时（这个最根本，会决定后面两种方法） 内核启动时(通常是在一个启动管理器里设置). 在运行时 (通过修改在 /proc 和 /sys中的文件).  本页面主要是讲第二种方法。\n配置 内核参数可以在启动时临时修改，也可以永久性写到启动管理器的配置文件中，永远起作用。\n下面示例把参数quiet 和 splash 加到启动管理器。\nsystemd-boot   当启动菜单出现时 按 e进入编辑界面:\ninitrd=\\initramfs-linux.img root=/dev/sda2 quiet splash   如果想永久加入参数，编辑 /boot/loader/entries/arch.conf (假设你已经设置好了 EFI system partition) 的options 行:\n  注意：\n 如果没有设置显示启动菜单, 你需要按住Space启动电脑来进入启动菜单 。 如果不能够从启动菜单上进行编辑，修改 /boot/loader/loader.conf 加入 editor 1 来开启编辑功能。  更多信息请参见 systemd-boot .\nGRUB   在菜单出现后按 e 然后将它们添加至 linux 行：\nlinux /boot/vmlinuz-linux root=UUID=978e3e81-8048-4ae1-8a06-aa727458e8ff ro quiet splash 按 b 以便用这些参数启动。\n  要使改变在重启后仍生效，您可以手动编辑 /boot/grub/grub.cfg 中的如上内容。对于初学者，建议编辑 /etc/default/grub 并将您的内核选项添加至 GRUB_CMDLINE_LINUX_DEFAULT 行：\nGRUB_CMDLINE_LINUX_DEFAULT=\"quiet splash\" 然后重新生成 grub.cfg 文件：\n# grub-mkconfig -o /boot/grub/grub.cfg   有关配置GRUB的更多信息，请参阅 GRUB 。\n发布时间表 内核发布时间表：有吗？ 短的回答是，每两到三个月就有一个新的内核版本发布。长的回答是，这不是一个硬性规定。\n这个意思是，你经常会看到每两到三个月就有一个新的内核版本发布。这是内核维护者团队的目标，但并没有规定新版本必须在前一个版本的 8 周后准时发布的期限。\n新的内核版本（通常）是由 Linus Torvalds 在它准备好的时候发布的。通常是每 2 到 3 个月发布一次。该版本被宣布为“稳定”，一般以 X.Y 的格式编号。\n但这并不是 X.Y 开发的结束。稳定版会有更多的小版本以进行错误的修复。这些小版本在稳定版的内核上又增加了一个点，就像是 X.Y.Z。\n虽然 X.Y（通常）是由 Linux 创造者 Linus Torvalds 发布的，但是维护稳定的 X.Y 内核、合并错误修复和发布 X.Y.Z 版本的责任是由另外的内核开发者负责的。\n一个内核版本支持多长时间？ 和发布一样，一个内核版本支持多长时间也没有固定的日期和时间表。\n一个普通的稳定内核版本通常会被支持两个半月到三个月，这取决于下一个稳定内核版本的发布时间。\n例如，稳定版内核 5.14 会在稳定版内核 5.15 发布后的几周内达到生命末期。结束支持是由该稳定内核版本的维护者在 Linux 内核邮件列表中宣布的。用户和贡献者会被要求切换到新发布的稳定版本。\n但这只适用于正常的稳定内核版本，还有 LTS（长期支持）内核版本，它们的支持期要比 3 个月长得多。\nLTS 内核：它支持多长时间？ LTS 内核也没有固定的发布时间表。通常，每年都有一个 LTS 内核版本，一般是当年的最后一个版本，它至少会被支持两年。但同样，这里也没有固定的规则。\nLTS 内核的维护者可以同意某个 LTS 内核的维护时间超过通常的两年。这个协议是根据必要性和参与的人员来达成的。\n这种情况经常发生在 Android 项目中。由于两年的时间不足以让制造商结束对他们的硬件和软件功能的支持，你经常会发现一些 LTS 内核会被支持六年之久。\n你可以 在 Linux 内核网站上 找到这个信息。\n你的发行版可能没有跟随通常的 Linux 内核版本 如果你检查你的 Linux 内核版本，你可能会发现 你的发行版使用了一个旧的内核。也有可能该发行版提供的内核已经在内核网站上被标记为到达了生命末期。\n不要惊慌。你的发行版会负责修补内核的错误和漏洞。除非你真的在使用一个不知名的 Linux 发行版，否则你可以相信你的发行版会保持它的安全和健全。\n如果你有足够的理由，比如为了支持更新的硬件，你可以自由地在你使用的任何发行版或 Ubuntu 中安装最新的 Linux 内核 。\n如果你想了解更多细节，我已经 在这里解释了为什么你的发行版使用过时的 Linux 内核。\n安装内核 dpkg\n从 kernel.ubuntu.com 网站手动下载可用的最新 Linux 内核：\n linux-image-X.Y.Z-generic-.deb linux-modules-X.Y.Z-generic-.deb  手动安装内核：\n$ sudo dpkg --install *.deb 重启系统，使用新内核：\n$ sudo reboot 检查是否如你所愿：\n$ uname -r apt-get\n不同于上一个方法，这种方法会从 Ubuntu 官方仓库下载、安装内核版本：\n运行：\n$ sudo apt-get upgrade linux-image-generic XanMod Kernel 最新内核集成的一些新特性的确是可以提升性能的。xanmod 内核的安装可以去它们的官方网站来查询，xanmod 内核的特性很多地方都有，官方也写的有很多，不过大多数还是以下几点：\n 改善了 CPU 调度能力 改善了 I/O 的调度能力 增加了一些和性能有关的第三方补丁 使用了最新的 GCC 进行编译 使用了最新的 MicroCode  安装的方式也比较简单，添加源并且更新安装就行了：\n$ echo 'deb http://deb.xanmod.org releases main' | sudo tee /etc/apt/sources.list.d/xanmod-kernel.list \u0026\u0026 wget -qO - https://dl.xanmod.org/gpg.key | sudo apt-key add - 然后安装，我个人安装的是最新的 5.8.1 的 edge：\n$ sudo apt update \u0026\u0026 sudo apt install linux-xanmod-edge 安装完毕后还可以安装最新的微码：\n$ sudo apt update \u0026\u0026 sudo apt install linux-xanmod 重启以应用\n$ sudo reboot Zen/Liquorix Kernel  一些内核黑客合作的结果，是适合日常使用的优秀内核 以吞吐量和功耗为代价来换取性能 相对 linux 内核加入了 Fsync 功能。Fsync 是维尔福公司发布的一个可以帮助提升大量多线程应用运行帧率的特殊内核补丁，这对改善游戏性能有很大帮助。在一些采用 .Net 的 wine 游戏中会有 明显的性能提升 如果你使用英伟达显卡，记得更换驱动为相应的 dkms 版本。一般来说较新的显卡安装 nvidia-dkms 即可。DKMS，即 Dynamic Kernel Module System。可以使内核变更（如升级）后自动编译模块，适配新内核。  Questions about: I’m not a kernel expert, but my understanding is that there are different ways for the kernel to prioritize tasks to be processed by the CPU. Priority on a server or workstation is different from a gaming PC. The Zen (and Liquorix) kernel alters the way this is done to optimise for gaming and multimedia. From what I can tell, the difference between the Zen and Liquorix kernels is the scheduler used, but are otherwise the same. There’s more info here.\nUbuntu Prerequisites:\n$ sudo add-apt-repository ppa:damentz/liquorix \u0026\u0026 sudo apt-get update The Liquorix kernel can be installed by way of meta-packages. This will guarantee that the latest kernel is installed on every upgrade.\n64-bit:\n$ sudo apt-get install linux-image-liquorix-amd64 linux-headers-liquorix-amd64 可选内核 切換内核 可以通过修改 /etc/default/grub 中的 GRUB_DEFAULT 值来改变默认启动项。\n查看 grub menu 目前的選項 ：\n$ grep -A100 submenu /boot/grub/grub.cfg |grep menuentry submenu 'Advanced options for Ubuntu' $menuentry_id_option 'gnulinux-advanced-4a67ec61-9cd5-4a26-b00f-9391a34c8a29' { menuentry 'Ubuntu, with Linux 4.4.0-1062-aws' --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option 'gnulinux-4.4.0-1062-aws-advanced-4a67ec61-9cd5-4a26-b00f-9391a34c8a29' { menuentry 'Ubuntu, with Linux 4.4.0-1062-aws (recovery mode)' --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option 'gnulinux-4.4.0-1062-aws-recovery-4a67ec61-9cd5-4a26-b00f-9391a34c8a29' { menuentry 'Ubuntu, with Linux 4.4.0-1061-aws' --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option 'gnulinux-4.4.0-1061-aws-advanced-4a67ec61-9cd5-4a26-b00f-9391a34c8a29' { menuentry 'Ubuntu, with Linux 4.4.0-1061-aws (recovery mode)' --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option 'gnulinux-4.4.0-1061-aws-recovery-4a67ec61-9cd5-4a26-b00f-9391a34c8a29' { 接下來修改 grub config 檔案：\n$ sudo nano /etc/default/grup 找到 GRUB_DEFAULT=0 ，將數字 0 改成想用來開機的 kernel，以這個例子來說：\n 0 = ‘Ubuntu, with Linux 4.4.0-1062-aws’ = ‘gnulinux-4.4.0-1062-aws-advanced-4a67ec61-9cd5-4a26-b00f-9391a34c8a29’ 1 = ‘Ubuntu, with Linux 4.4.0-1062-aws (recovery mode)’ = ‘gnulinux-4.4.0-1062-aws-recovery-4a67ec61-9cd5-4a26-b00f-9391a34c8a29’ 2 = ‘Ubuntu, with Linux 4.4.0-1061-aws’ = ‘gnulinux-4.4.0-1061-aws-advanced-4a67ec61-9cd5-4a26-b00f-9391a34c8a29’ 3 = ‘Ubuntu, with Linux 4.4.0-1061-aws (recovery mode)’ = ‘gnulinux-4.4.0-1061-aws-recovery-4a67ec61-9cd5-4a26-b00f-9391a34c8a29’  GRUB 启动项序号从 0 开始计数，0 代表第一个启动项，也是上述选项的默认值，1 表示第二个启动项，以此类推。主菜单和子菜单项之间用  隔开。\n下面的例子启动的是主菜单项 ‘Advanced options for Arch Linux’ 下子菜单的第三项：\n  使用数字编号：\nGRUB_DEFAULT=2 # or GRUB_DEFAULT=\"12\"   使用菜单标题：\nGRUB_DEFAULT=\"Advanced options for UbuntuUbuntu, with Linux 4.4.0-1061-aws\"   还可以这样：\nGRUB_DEFAULT=\"gnulinux-advanced-4a67ec61-9cd5-4a26-b00f-9391a34c8a29gnulinux-4.4.0-1061-aws-advanced-4a67ec61-9cd5-4a26-b00f-9391a34c8a29\"   更新 grup 設定：\n$ sudo update-grub $ sudo reboot   删除旧内核 随着时间的流逝，持续的内核更新会在系统中积聚大量的不再使用的内核，浪费你的磁盘空间。每个内核镜像和其相关联的模块/头文件会占用200-400MB的磁盘空间，因此由不再使用的内核而浪费的磁盘空间会快速地增加。\nGRUB管理器为每个旧内核都维护了一个GRUB入口，以备你想要使用它们。\n作为磁盘清理的一部分，如果你不再使用这些，你可以考虑清理掉这些镜像。\n在删除旧内核之前，记住最好留有2个最近的内核（最新的和上一个版本），以防主要的版本出错。\n在Ubuntu内核镜像包含了以下的包。\n linux-image-: 内核镜像 linux-image-extra-: 额外的内核模块 linux-headers-: 内核头文件  首先检查系统中安装的内核镜像。\n$ dpkg --list | grep linux-image $ dpkg --list | grep linux-headers 在列出的内核镜像中，你可以移除一个特定的版本。\n$ sudo apt-get purge linux-image-3.19.0-15 $ sudo apt-get purge linux-headers-3.19.0-15 上面的命令会删除内核镜像和它相关联的内核模块和头文件。\n注意如果你还没有升级内核那么删除旧内核会自动触发安装新内核。这样在删除旧内核之后，GRUB配置会自动升级来移除GRUB菜单中相关GRUB入口。\n如果你有很多没用的内核，你可以用shell表达式来一次性地删除多个内核。注意这个括号表达式只在bash或者兼容的shell中才有效。\n$ sudo apt-get purge linux-image-3.19.0-{18,20,21,25} $ sudo apt-get purge linux-headers-3.19.0-{18,20,21,25} 上面的命令会删除4个内核镜像：3.19.0-18、3.19.0-20、3.19.0-21 和 3.19.0-25。\n如果GRUB配置由于任何原因在删除旧内核后没有正确升级，你可以尝试手动用update-grub2命令来更新配置。\n$ sudo update-grub2 现在就重启来验证GRUB菜单是否已经正确清理了。\n编写第一个内核模块 容器 Namespace 概念 **namespace 是 Linux 内核用来隔离内核资源的方式。**通过 namespace 可以让一些进程只能看到与自己相关的一部分资源，而另外一些进程也只能看到与它们自己相关的资源，这两拨进程根本就感觉不到对方的存在。具体的实现方式是把一个或多个进程的相关资源指定在同一个 namespace 中。\nLinux namespaces 是对全局系统资源的一种封装隔离，使得处于不同 namespace 的进程拥有独立的全局系统资源，改变一个 namespace 中的系统资源只会影响当前 namespace 里的进程，对其他 namespace 中的进程没有影响。\n用途 实际上，Linux 内核实现 namespace 的一个主要目的就是实现轻量级虚拟化(容器)服务。在同一个 namespace 下的进程可以感知彼此的变化，而对外界的进程一无所知。这样就可以让容器中的进程产生错觉，认为自己置身于一个独立的系统中，从而达到隔离的目的。也就是说 linux 内核提供的 namespace 技术为 docker 等容器技术的出现和发展提供了基础条件。\n我们可以从 docker 实现者的角度考虑该如何实现一个资源隔离的容器。比如是不是可以通过 chroot 命令切换根目录的挂载点，从而隔离文件系统。为了在分布式的环境下进行通信和定位，容器必须要有独立的 IP、端口和路由等，这就需要对网络进行隔离。同时容器还需要一个独立的主机名以便在网络中标识自己。接下来还需要进程间的通信、用户权限等的隔离。最后，运行在容器中的应用需要有进程号(PID)，自然也需要与宿主机中的 PID 进行隔离。也就是说这六种隔离能力是实现一个容器的基础，让我们看看 linux 内核的 namespace 特性为我们提供了什么样的隔离能力：\n上表中的前六种 namespace 正是实现容器必须的隔离技术，至于新近提供的 Cgroup namespace 目前还没有被 docker 采用。相信在不久的将来各种容器也会添加对 Cgroup namespace 的支持。\n发展历史 Linux 在很早的版本中就实现了部分的 namespace，比如内核 2.4 就实现了 mount namespace。大多数的 namespace 支持是在内核 2.6 中完成的，比如 IPC、Network、PID、和 UTS。还有个别的 namespace 比较特殊，比如 User，从内核 2.6 就开始实现了，但在内核 3.8 中才宣布完成。同时，随着 Linux 自身的发展以及容器技术持续发展带来的需求，也会有新的 namespace 被支持，比如在内核 4.6 中就添加了 Cgroup namespace。\nLinux 提供了多个 API 用来操作 namespace，它们是 clone()、setns() 和 unshare() 函数，为了确定隔离的到底是哪项 namespace，在使用这些 API 时，通常需要指定一些调用参数：CLONE_NEWIPC、CLONE_NEWNET、CLONE_NEWNS、CLONE_NEWPID、CLONE_NEWUSER、CLONE_NEWUTS 和 CLONE_NEWCGROUP。如果要同时隔离多个 namespace，可以使用 | (按位或)组合这些参数。同时我们还可以通过 /proc 下面的一些文件来操作 namespace。\n查看进程所属的 namespace\n从版本号为 3.8 的内核开始，/proc/[pid]/ns 目录下会包含进程所属的 namespace 信息，使用下面的命令可以查看当前进程所属的 namespace 信息：\n$ ll /proc/$$/ns total 0 lrwxrwxrwx 1 kurome kurome 0 Mar 3 11:33 cgroup - 'cgroup:[4026531835]' lrwxrwxrwx 1 kurome kurome 0 Mar 3 11:33 ipc - 'ipc:[4026531839]' lrwxrwxrwx 1 kurome kurome 0 Mar 3 11:33 mnt - 'mnt:[4026531840]' lrwxrwxrwx 1 kurome kurome 0 Mar 3 11:33 net - 'net:[4026532008]' lrwxrwxrwx 1 kurome kurome 0 Mar 3 11:33 pid - 'pid:[4026531836]' lrwxrwxrwx 1 kurome kurome 0 Mar 3 11:33 pid_for_children - 'pid:[4026531836]' lrwxrwxrwx 1 kurome kurome 0 Mar 3 11:33 time - 'time:[4026531834]' lrwxrwxrwx 1 kurome kurome 0 Mar 3 11:33 time_for_children - 'time:[4026531834]' lrwxrwxrwx 1 kurome kurome 0 Mar 3 11:33 user - 'user:[4026531837]' lrwxrwxrwx 1 kurome kurome 0 Mar 3 11:33 uts - 'uts:[4026531838]' 首先，这些 namespace 文件都是链接文件。链接文件的内容的格式为 xxx:[inode number]。其中的 xxx 为 namespace 的类型，inode number 则用来标识一个 namespace，我们也可以把它理解为 namespace 的 ID。如果两个进程的某个 namespace 文件指向同一个链接文件，说明其相关资源在同一个 namespace 中。\n其次，在 /proc/[pid]/ns 里放置这些链接文件的另外一个作用是，一旦这些链接文件被打开，只要打开的文件描述符(fd)存在，那么就算该 namespace 下的所有进程都已结束，这个 namespace 也会一直存在，后续的进程还可以再加入进来。\n除了打开文件的方式，我们还可以通过文件挂载的方式阻止 namespace 被删除。比如我们可以把当前进程中的 uts 挂载到 ~/uts 文件：\n$ touch ~/uts $ sudo mount --bind /proc/$$/ns/uts ~/uts 使用 stat 命令检查下结果：\n$ stat ~/uts 很神奇吧，~/uts 的 inode 和链接文件中的 inode number 是一样的，它们是同一个文件。\nclone() 函数 我们可以通过 clone() 在创建新进程的同时创建 namespace。clone() 在 C 语言库中的声明如下：\n/* Prototype for the glibc wrapper function */ #define _GNU_SOURCE #include int clone(int (*fn)(void *), void *child_stack, int flags, void *arg); 实际上，clone() 是在 C 语言库中定义的一个封装(wrapper)函数，它负责建立新进程的堆栈并且调用对编程者隐藏的 clone() 系统调用。Clone() 其实是 linux 系统调用 fork() 的一种更通用的实现方式，它可以通过 flags 来控制使用多少功能。一共有 20 多种 CLONE_ 开头的 falg(标志位) 参数用来控制 clone 进程的方方面面(比如是否与父进程共享虚拟内存等)，下面我们只介绍与 namespace 相关的 4 个参数：\n fn：指定一个由新进程执行的函数。当这个函数返回时，子进程终止。该函数返回一个整数，表示子进程的退出代码。 child_stack：传入子进程使用的栈空间，也就是把用户态堆栈指针赋给子进程的 esp 寄存器。调用进程(指调用 clone() 的进程)应该总是为子进程分配新的堆栈。 flags：表示使用哪些 CLONE_ 开头的标志位，与 namespace 相关的有CLONE_NEWIPC、CLONE_NEWNET、CLONE_NEWNS、CLONE_NEWPID、CLONE_NEWUSER、CLONE_NEWUTS 和 CLONE_NEWCGROUP。 arg：指向传递给 fn() 函数的参数。  setns() 函数 通过 setns() 函数可以将当前进程加入到已有的 namespace 中。setns() 在 C 语言库中的声明如下：\n#define _GNU_SOURCE #include int setns(int fd, int nstype); 和 clone() 函数一样，C 语言库中的 setns() 函数也是对 setns() 系统调用的封装：\n fd：表示要加入 namespace 的文件描述符。它是一个指向 /proc/[pid]/ns 目录中文件的文件描述符，可以通过直接打开该目录下的链接文件或者打开一个挂载了该目录下链接文件的文件得到。 nstype：参数 nstype 让调用者可以检查 fd 指向的 namespace 类型是否符合实际要求。若把该参数设置为 0 表示不检查。  前面我们提到：可以通过挂载的方式把 namespace 保留下来。保留 namespace 的目的是为以后把进程加入这个 namespace 做准备。在 docker 中，使用 docker exec 命令在已经运行着的容器中执行新的命令就需要用到 setns() 函数。为了把新加入的 namespace 利用起来，还需要引入 execve() 系列的函数，该函数可以执行用户的命令，比较常见的用法是调用 /bin/bash 并接受参数运行起一个 shell。\nunshare() 函数 通过 unshare 函数可以在原进程上进行 namespace 隔离。也就是创建并加入新的 namespace 。unshare() 在 C 语言库中的声明如下：\n#define _GNU_SOURCE #include int unshare(int flags); 和前面两个函数一样，C 语言库中的 unshare() 函数也是对 unshare() 系统调用的封装。调用 unshare() 的主要作用就是：不启动新的进程就可以起到资源隔离的效果，相当于跳出原先的 namespace 进行操作。\n系统还默认提供了一个叫 unshare 的命令，其实就是在调用 unshare() 系统调用。下面的 demo 使用 unshare 命令把当前进程的 user namespace 设置成了 root：\n$ whoami nick $ unshare --map-root-user --user sh -c whoami root cgroups 简介 说实话，一些未知的软件应用可能需要被控制或限制——至少是为了稳定性或者某种程度上的安全性。很多时候，一个bug或者仅仅只是烂代码就有可能破坏掉整个机器甚至可能削弱整个生态。幸运的是，有一种方式可以控制应用程序，Linux控制组（cgroups）是一个内核功能，用于限制、记录和隔离一个或多个进程对CPU、内存、磁盘I/O 以及网络的访问及使用。\n即，cgroups(Control Groups) 是 linux 内核提供的一种机制，这种机制可以根据需求把一系列系统任务及其子任务整合(或分隔)到按资源划分等级的不同组内，从而为系统资源管理提供一个统一的框架。简单说，cgroups 可以限制、记录任务组所使用的物理资源。本质上来说，cgroups 是内核附加在程序上的一系列钩子(hook)，通过程序运行时对资源的调度触发相应的钩子以达到资源追踪和限制的目的。\n控制组技术最初是由谷歌开发的，最终在2.6.24版本（2008年1月）中并入Linux内核主线。这项技术被部分重新设计，添加了kernfs（用于分割一些sysfs逻辑），这些改变被合并到3.15和3.16版本的内核中。\n实现 cgroups 的主要目的是为不同用户层面的资源管理提供一个统一化的接口。从单个任务的资源控制到操作系统层面的虚拟化（Linux 容器或者LXC），cgroups 提供了四大功能：\n 资源限制：一个控制组可以配置成不能超过指定的内存限制或是不能使用超过一定数量的处理器或限制使用特定的外围设备。 优先级：一个或者多个控制组可以配置成使用更少或者更多的CPU 时间片数量或者磁盘 IO 带宽，实际上就等同于控制了任务运行的优先级。 记录：一个控制组的资源使用情况会被监督以及测量。 控制：进程组可以被冻结，暂停或者重启。  概念 Task(任务) 在 linux 系统中，内核本身的调度和管理并不对进程和线程进行区分，只是根据 clone 时传入的参数的不同来从概念上区分进程和线程。这里使用 task 来表示系统的一个进程或线程。\nCgroup(控制组) cgroups 中的资源控制以 cgroup 为单位实现。Cgroup 表示按某种资源控制标准划分而成的任务组，包含一个或多个子系统。一个任务可以加入某个 cgroup，也可以从某个 cgroup 迁移到另一个 cgroup。\nSubsystem(子系统) cgroups 中的子系统就是一个资源调度控制器(又叫 controllers)。比如 CPU 子系统可以控制 CPU 的时间分配，内存子系统可以限制内存的使用量。内核版本 4.10.0，支持的 subsystem 如下( cat /proc/cgroups)：\n blkio 对块设备的 IO 进行限制。 cpu 限制 CPU 时间片的分配，与 cpuacct 挂载在同一目录。 cpuacct 生成 cgroup 中的任务占用 CPU 资源的报告，与 cpu 挂载在同一目录。 cpuset 给 cgroup 中的任务分配独立的 CPU(多处理器系统) 和内存节点。 devices 允许或禁止 cgroup 中的任务访问设备。 freezer 暂停/恢复 cgroup 中的任务。 hugetlb 限制使用的内存页数量。 memory 对 cgroup 中的任务的可用内存进行限制，并自动生成资源占用报告。 net_cls 使用等级识别符（classid）标记网络数据包，这让 Linux 流量控制器（tc 指令）可以识别来自特定 cgroup 任务的数据包，并进行网络限制。 net_prio 允许基于 cgroup 设置网络流量(netowork traffic)的优先级。 perf_event 允许使用 perf 工具来监控 cgroup。 pids 限制任务的数量。  Hierarchy(层级) 层级有一系列 cgroup 以一个树状结构排列而成，每个层级通过绑定对应的子系统进行资源控制。层级中的 cgroup 节点可以包含零个或多个子节点，子节点继承父节点挂载的子系统。一个操作系统中可以有多个层级。\n接口 （以下为 Ubuntu 20.04，内核 5.13.0-30-generic）\ncgroups 以文件的方式提供应用接口，我们可以通过 mount 命令来查看 cgroups 默认的挂载点：\n$ mount | grep cgroup tmpfs on /sys/fs/cgroup type tmpfs (ro,nosuid,nodev,noexec,mode=755,inode64) cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,name=systemd) ... cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset) 第一行的 tmpfs 说明 /sys/fs/cgroup 目录下的文件都是存在于内存中的临时文件。\n第二行的挂载点 /sys/fs/cgroup/systemd 用于 systemd 系统对 cgroups 的支持。\n其余的挂载点则是内核支持的各个子系统的根级层级结构。\n需要注意的是，在使用 systemd 系统的操作系统中，/sys/fs/cgroup 目录都是由 systemd 在系统启动的过程中挂载的，并且挂载为只读的类型。换句话说，系统是不建议我们在 /sys/fs/cgroup 目录下创建新的目录并挂载其它子系统的。这一点与之前的操作系统不太一样。\n下面让我们来探索一下 /sys/fs/cgroup 目录及其子目录下都是些什么：\n$ ls /sys/fs/cgroup blkio cpu,cpuacct freezer misc net_prio rdma cpu cpuset hugetlb net_cls perf_event systemd cpuacct devices memory net_cls,net_prio pids unified /sys/fs/cgroup 目录下是各个子系统的根目录。我们以 memory 子系统为例，看看 memory 目录下都有什么？\n$ ls /sys/fs/cgroup/memory cgroup.clone_children memory.memsw.limit_in_bytes cgroup.event_control memory.memsw.max_usage_in_bytes cgroup.procs memory.memsw.usage_in_bytes cgroup.sane_behavior memory.move_charge_at_immigrate memory.failcnt memory.numa_stat memory.force_empty memory.oom_control memory.kmem.failcnt memory.pressure_level memory.kmem.limit_in_bytes memory.soft_limit_in_bytes memory.kmem.max_usage_in_bytes memory.stat memory.kmem.slabinfo memory.swappiness memory.kmem.tcp.failcnt memory.usage_in_bytes memory.kmem.tcp.limit_in_bytes memory.use_hierarchy memory.kmem.tcp.max_usage_in_bytes notify_on_release memory.kmem.tcp.usage_in_bytes release_agent memory.kmem.usage_in_bytes system.slice memory.limit_in_bytes tasks memory.max_usage_in_bytes user.slice memory.memsw.failcnt 这些文件就是 cgroups 的 memory 子系统中的根级设置。比如 memory.limit_in_bytes 中的数字用来限制进程的最大可用内存，memory.swappiness 中保存着使用 swap 的权重等等。\n手动方法 你可以直接或者间接（通过LXC、libvirt或者Docker）访问及管理控制组，这里我首先介绍使用sysfs以及libgroups库。接下来的示例需要你预先安装一个必须的包。\n$ sudo apt-get install libcgroup1 cgroup-tools 我将使用一个简单的shell脚本文件test.sh作为示例应用程序，它将会在无限while循环中运行以下两个命令。\n$ cat test.sh !/bin/shwhile [ 1 ]; do echo \"hello world\" sleep 60 done 安装必要的包后，你可以直接通过sysfs的目录结构来配置你的控制组，例如，要在内存子系统中创建一个叫做foo的控制组，只需要在/sys/fs/cgroup/memory底下新建一个叫做foo的目录：\n$ sudo mkdir /sys/fs/cgroup/memory/foo 在我们使用 cgroups 时，最好不要直接在各个子系统的根目录下直接修改其配置文件。推荐的方式是为不同的需求在子系统树中定义不同的节点。\ncgroups 的文件系统会在创建文件目录的时候自动创建配置文件：\n$ ls /sys/fs/cgroup/memory/foo cgroup.clone_children memory.memsw.failcnt cgroup.event_control memory.memsw.limit_in_bytes cgroup.procs memory.memsw.max_usage_in_bytes memory.failcnt memory.memsw.usage_in_bytes memory.force_empty memory.move_charge_at_immigrate memory.kmem.failcnt memory.numa_stat memory.kmem.limit_in_bytes memory.oom_control memory.kmem.max_usage_in_bytes memory.pressure_level memory.kmem.slabinfo memory.soft_limit_in_bytes memory.kmem.tcp.failcnt memory.stat memory.kmem.tcp.limit_in_bytes memory.swappiness memory.kmem.tcp.max_usage_in_bytes memory.usage_in_bytes memory.kmem.tcp.usage_in_bytes memory.use_hierarchy memory.kmem.usage_in_bytes notify_on_release memory.limit_in_bytes tasks memory.max_usage_in_bytes 默认情况下，每个新建的控制组将会继承对系统整个内存池的访问权限。但对于某些应用程序，这些程序拒绝释放已分配的内存并继续分配更多内存，这种默认继承方式显然不是个好主意。要使程序的内存限制变得更为合理，你需要更新文件memory.limit_in_bytes。\n限制控制组foo下运行的任何应用的内存上限为50MB：\n$ echo 50000000 | sudo tee /sys/fs/cgroup/memory/foo/memory.limit_in_bytes 验证设置：\n$ sudo cat memory.limit_in_bytes 49999872 请注意，回读的值始终是内核页面大小的倍数（即4096字节或4KB）。这个值是内存的最小可分配大小。\n启动应用程序test.sh：\n$ sh ~/test.sh 使用进程ID（PID），将应用程序移动到内存控制器底下的控制组foo：\n$ echo 2152 | sudo tee /sys/fs/cgroup/memory/foo/cgroup.procs 使用相同的PID，列出正在运行的进程并验证它是否在正确的控制组下运行：\n$ ps -o cgroup 2152 CGROUP 5:devices:/user.slice,4:pids:/user.slice/user-1000.slice/user@1000.service,3:m... 或者通过 /proc/[pid]/cgroup 来查看指定进程属于哪些 cgroup：\n$ cat /proc/2152/cgroup 13:cpuset:/ 12:blkio:/ 11:misc:/ 10:rdma:/ 9:freezer:/ 8:cpu,cpuacct:/ 7:perf_event:/ 6:hugetlb:/ 5:devices:/user.slice 4:pids:/user.slice/user-1000.slice/user@1000.service 3:memory:/foo #here 2:net_cls,net_prio:/ 1:name=systemd:/user.slice/user-1000.slice/user@1000.service/gnome\\x2dsession\\x2dmanager.slice/gnome-session-manager@ubuntu.service 0::/user.slice/user-1000.slice/user@1000.service/gnome\\x2dsession\\x2dmanager.slice/gnome-session-manager@ubuntu.service 每一行包含用冒号隔开的三列，他们的含义分别是：\n cgroup 树的 ID， 和 /proc/cgroups 文件中的 ID 一一对应。 和 cgroup 树绑定的所有 subsystem，多个 subsystem 之间用逗号隔开。这里 name=systemd 表示没有和任何 subsystem 绑定，只是给他起了个名字叫 systemd。 进程在 cgroup 树中的路径，即进程所属的 cgroup，这个路径是相对于挂载点的相对路径。  你还可以通过读取文件来监控控制组正在使用的资源。在这种情况下，你可以查看你的进程（以及生成的子进程）被分配的内存大小。\n$ cat /sys/fs/cgroup/memory/foo/memory.usage_in_bytes 188416 当进程“迷路”时 现在让我们重新创建相同的场景，但这次我们将控制组foo的内存限制从50MB改为500 bytes：\n$ echo 500 | sudo tee /sys/fs/cgroup/memory/foo/memory.limit_in_bytes 注意：如果任务超出其定义的限制，内核将进行干预，并在某些情况下终止该任务。\n同样，当您重新读取值时，它将始终是内核页面大小的倍数。因此，虽然您将其设置为500字节，但它实际上被设置为4 KB：\n$ cat /sys/fs/cgroup/memory/foo/memory.limit_in_bytes 4096 启动应用程序test.sh，将其移动到控制组下并监视系统日志：\n$ sudo tail -f /var/log/messages ... 请注意，内核的Out-Of-Mempry Killer（也叫做oom-killer 内存不足杀手）在应用程序达到4KB限制时就会介入。它会杀死应用程序，应用程序将不再运行，你可以通过输入以下命令进行验证：\n$ ps -o cgroup 2152 使用libcgroup 之前描述的许多早期步骤都可以通过libcgroup包中提供的管理工具进行简化。例如，使用cgcreate二进制文件的单个命令即可创建sysfs条目和文件。\n输入以下命令即可在内存子系统下创建一个叫做foo的控制组：\n$ sudo cgcreate -g memory:foo 注意：libcgroup提供了一种管理控制组中任务的机制。\n使用与之前相同的方法，你就可以开始设置内存阈值：\n$ echo 50000000 | sudo tee /sys/fs/cgroup/memory/foo/memory.limit_in_bytes 验证新配置的设置：\n$ sudo cat memory.limit_in_bytes 50003968 使用cgexec二进制文件在控制组foo中运行应用程序：\n$ sudo cgexec -g memory:foo ~/test.sh 使用它的进程ID - PID来验证应用程序是否在控制组和子系统（内存）下运行：\n$ ps -o cgroup 2945 CGROUP 6:memory:/foo,1:name=systemd:/user.slice/user-0.slice/session-1.scope 如果您的应用程序不再运行，并且您想要清理并删除控制组，则可以使用二进制文件cgdelete来执行此操作。要从内存控制器下删除控制组foo，请输入：\n$ sudo cgdelete memory:foo 持久组 您也可以通过一个简单的配置文件和服务的启动来完成上述所有操作。您可以在/etc/cgconfig.conf文件中定义所有控制组名称和属性。以下为foo组添加了一些属性：\n$ cat /etc/cgconfig.conf group foo { cpu { cpu.shares = 100; } memory { memory.limit_in_bytes = 5000000; } } cpu.shares选项定义了该组的CPU优先级。默认情况下，所有组都继承1024 shares（CPU share指的是控制组中的任务被分配到的CPU的 time的优先级，即值越大，分配到的CPU time越多，这个值需大于等于2），即100%的CPU time（CPU time是CPU用于处理一个程序所花费的时间）。通过将cpu.shares的值降低到更保守的值（如100），这个组将会被限制只能使用大概10%的CPU time。\n就如之前讨论的，在控制组中运行的进程也可以被限制它能访问的CPUs（内核）的数量。将以下部分添加到同一个配置文件cgconfig.conf中组名底下。\ncpuset { cpuset.cpus=\"0-5\"; } 有了这个限制，这个控制组会将应用程序绑定到到0核到5核——也就是说，它只能访问系统上的前6个CPU核。\n接下来，您需要使用cgconfig服务加载此配置。首先，启用cgconfig以在系统启动时能够加载上述配置：\n$ sudo systemctl enable cgconfig Create symlink from /etc/systemd/system/sysinit.target.wants/cgconfig.service to /usr/lib/systemd/system/cgconfig.service. 现在，启动cgconfig服务并手动加载相同的配置文件（或者您可以跳过此步骤直接重启系统）：\n$ sudo systemctl start cgconfig 在控制组foo下启动该应用程序并将其绑定到您设置的内存和CPU限制：\n$ sudo cgexec -g memory,cpu,cpuset:foo ~/test.sh \u0026 除了将应用程序启动到预定义的控制组之外，其余所有内容都将在系统重新启动后持续存在。但是，您可以通过定义依赖于cgconfig服务的启动初始脚本来启动该应用程序，自动执行该过程。\n总结 通常来说，限制一个机器上一个或者多个任务的权限是必要的。控制组提供了这项功能，通过使用它，您可以对一些特别重要或无法控制的应用程序实施严格的硬件和软件限制。如果一个应用程序没有设置上限阈值或限制它可以在系统上消耗的内存量，cgroups可以解决这个问题。如果另一个应用程序没有CPU上的限制，那么cgroups可以再一次解决您的问题。您可以通过cgroup完成这么多工作，只需花一点时间，您就可以使用你的操作系统环境恢复稳定性，安全性和健全性。\n使用 Systemd 当 Linux 的 init 系统发展到 systemd 之后，systemd 与 cgroups 发生了融合(或者说 systemd 提供了 cgroups 的使用和管理接口)。\nSystemd 依赖 cgroups\n要理解 systemd 与 cgroups 的关系，我们需要先区分 cgroups 的两个方面：层级结构(A)和资源控制(B)。首先 cgroups 是以层级结构组织并标识进程的一种方式，同时它也是在该层级结构上执行资源限制的一种方式。我们简单的把 cgroups 的层级结构称为 A，把 cgrpups 的资源控制能力称为 B。\n对于 systemd 来说，A 是必须的，如果没有 A，systemd 将不能很好的工作。而 B 则是可选的，如果你不需要对资源进行控制，那么在编译 Linux 内核时完全可以去掉 B 相关的编译选项。\nSystemd 默认挂载的 cgroups 系统\n在系统的开机阶段，systemd 会把支持的 controllers (subsystem 子系统)挂载到默认的 /sys/fs/cgroup/ 目录下面，除了 systemd 目录外，其它目录都是对应的 subsystem。\n/sys/fs/cgroup/systemd 目录是 systemd 维护的自己使用的非 subsystem 的 cgroups 层级结构。换句话说就是，并不允许其它的程序动这个目录下的内容。其实 /sys/fs/cgroup/systemd 目录对应的 cgroups 层级结构就是 systemd 用来使用 cgoups 中 feature A 的。\nCgroup 的默认层级\n过将 cgroup 层级系统与 systemd unit 树绑定，systemd 可以把资源管理的设置从进程级别移至应用程序级别。因此，我们可以使用 systemctl 指令，或者通过修改 systemd unit 的配置文件来管理 unit 相关的资源。\n默认情况下，systemd 会自动创建 slice、scope 和 service unit 的层级来为 cgroup 树提供统一的层级结构。\n系统中运行的所有进程，都是 systemd init 进程的子进程。在资源管控方面，systemd 提供了三种 unit 类型：\n service： 一个或一组进程，由 systemd 依据 unit 配置文件启动。service 对指定进程进行封装，这样进程可以作为一个整体被启动或终止。 scope：一组外部创建的进程。由进程通过 fork() 函数启动和终止、之后被 systemd 在运行时注册的进程，scope 会将其封装。例如：用户会话、 容器和虚拟机被认为是 scope。 slice： 一组按层级排列的 unit。slice 并不包含进程，但会组建一个层级，并将 scope 和 service 都放置其中。真正的进程包含在 scope 或 service 中。在这一被划分层级的树中，每一个 slice 单位的名字对应通向层级中一个位置的路径。  以通过 systemd-cgls 命令来查看 cgroups 的层级结构\nControl group /: -.slice ├─419 bpfilter_umh ├─user.slice │ ├─user-125.slice │ │ ├─session-c1.scope │ │ │ ├─1101 gdm-session-worker [pam/gdm-launch-environment] │ │ │ ├─1158 /usr/lib/gdm3/gdm-x-session dbus-run-session -- gnome-session - │ │ │ ├─1160 /usr/lib/xorg/Xorg vt1 -displayfd 3 -auth /run/user/125/gdm/Xau │ │ │ ├─1347 dbus-run-session -- gnome-session --autostart /usr/share/gdm/gr │ │ │ ├─1348 dbus-daemon --nofork --print-address 4 --session │ │ │ ├─1349 /usr/libexec/gnome-session-binary --systemd --autostart /usr/sh │ │ │ ├─1352 /usr/libexec/at-spi-bus-launcher │ │ │ ├─1357 /usr/bin/dbus-daemon --config-file=/usr/share/defaults/at-spi2/ │ │ │ ├─1378 /usr/bin/gnome-shell │ │ │ ├─1432 ibus-daemon --panel disable --xim │ │ │ ├─1435 /usr/libexec/ibus-dconf │ │ │ ├─1438 /usr/libexec/ibus-x11 --kill-daemon │ │ │ ├─1440 /usr/libexec/ibus-portal │ │ │ ├─1451 /usr/libexec/at-spi2-registryd --use-gnome-session service、scope 和 slice unit 被直接映射到 cgroup 树中的对象。当这些 unit 被激活时，它们会直接一一映射到由 unit 名建立的 cgroup 路径中。例如，cron.service 属于 system.slice，会直接映射到 cgroup system.slice/cron.service/ 中。 注意，所有的用户会话、虚拟机和容器进程会被自动放置在一个单独的 scope 单元中。\n默认情况下，系统会创建四种 slice：\n -.slice：根 slice system.slice：所有系统 service 的默认位置 user.slice：所有用户会话的默认位置 machine.slice：所有虚拟机和 Linux 容器的默认位置  创建临时的 cgroup\n对资源管理的设置可以是 transient(临时的)，也可以是 persistent (永久的)。我们先来介绍如何创建临时的 cgroup。\n需要使用 systemd-run 命令创建临时的 cgroup，它可以创建并启动临时的 service 或 scope unit，并在此 unit 中运行程序。systemd-run 命令默认创建 service 类型的 unit，比如我们创建名称为 toptest 的 service 运行 top 命令：\n$ sudo systemd-run --unit=toptest --slice=test top -b 然后查看一下 test.slice 的状态：\n$ sudo systemctl status test.slice 创建了一个 test.slice/toptest.service cgroup 层级关系。再看看 toptest.service 的状态：\n$ sudo systemctl status toptest.service top 命令被包装成一个 service 运行在后台了！\n接下来我们就可以通过 systemctl 命令来限制 toptest.service 的资源了。在限制前让我们先来看一看 top 进程的 cgroup 信息：\n$ cat /proc/2850/cgroup 比如我们限制 toptest.service 的 CPUShares 为 600，可用内存的上限为 550M：\n$ sudo systemctl set-property toptest.service CPUShares=600 MemoryLimit=500M 再次检查 top 进程的 cgroup 信息：\n$ cat /proc/2850/cgroup 在 CPU 和 memory 子系统中都出现了 toptest.service 的名字。同时去查看 /sys/fs/cgroup/memory/test.slice 和 /sys/fs/cgroup/cpu/test.slice 目录，这两个目录下都多出了一个 toptest.service 目录。我们设置的 CPUShares=600 MemoryLimit=500M 被分别写入了这些目录下的对应文件中。\n临时 cgroup 的特征是，所包含的进程一旦结束，临时 cgroup 就会被自动释放。比如我们 kill 掉 top 进程，然后再查看 /sys/fs/cgroup/memory/test.slice 和 /sys/fs/cgroup/cpu/test.slice 目录，刚才的 toptest.service 目录已经不见了。\n通过配置文件修改 cgroup\n所有被 systemd 监管的 persistent cgroup(持久的 cgroup)都在 /usr/lib/systemd/system/ 目录中有一个 unit 配置文件。比如我们常见的 service 类型 unit 的配置文件。我们可以通过设置 unit 配置文件来控制应用程序的资源，persistent cgroup 的特点是即便系统重启，相关配置也会被保留。需要注意的是，scope unit 不能以此方式创建。下面让我们为 cron.service 添加 CPU 和内存相关的一些限制，编辑 /lib/systemd/system/cron.service 文件：\n$ sudo vim /lib/systemd/system/cron.service [Service] CPUShares=600 MemoryLimit=500M EnviromentFile=-/etc/default/cron ExecStart=/usr/sbin/cron -f $EXTRA_OPTS IgnoreSIGPIPE=false KillMode=process 然后重新加载配置文件并重启 cron.service：\n$ sudo systemctl daemon-reload $ sudo systemctl restart cron.service 现在去查看 /sys/fs/cgroup/memory/system.slice/cron.service/memory.limit_in_bytes 和 /sys/fs/cgroup/cpu/system.slice/cron.service/cpu.shares 文件，是不是已经包含我们配置的内容了！\n通过 systemctl 命令修改 cgroup\n除了编辑 unit 的配置文件，还可以通过 systemctl set-property 命令来修改 cgroup，这种方式修该的配置也会在重启系统时保存下来。现在我们把 cron.service 的 CPUShares 改为 700：\n$ sudo systemctl set-property cron.service CPUShares=700 查看 /sys/fs/cgroup/cpu/system.slice/cron.service/cpu.shares 文件的内容应该是 700，重启系统后该文件的内容还是 700。\nSystemd-cgtop 命令\n类似于 top 命令，systemd-cgtop 命令显示 cgoups 的实时资源消耗情况。\n通过它我们就可以分析应用使用资源的情况。\nLXC LXC（Linux容器，Linux Container）相当于你运行了一个接近于裸机的虚拟机。这项技术始于2008年，LXC的大部分功能来自于Solaris容器（又叫做Solaries Zones）以及之前的FreeBSD jails技术。 LXC并不是创建一个成熟的虚拟机，而是创建了一个拥有自己进程程和网络空间的虚拟环境，使用命名空间来强制进程隔离并利用内核的控制组（cgroups）功能，该功能可以限制，计算和隔离一个或多个进程的CPU，内存，磁盘I / O和网络使用情况。 您可以将这种用户空间框架想像成是chroot的高级形式。\n chroot 是一个改变当前运行进程以及其子进程的根目录的操作。一个运行在这种环境的程序无法访问根目录外的文件和命令。\n 注意：LXC使用命名空间来强制进程隔离，同时利用内核的控制组来计算以及限制一个或多个进程的CPU，内存，磁盘I / O和网络使用。\n但容器究竟是什么？简短的答案是容器将软件应用程序与操作系统分离，为用户提供干净且最小的Linux环境，与此同时在一个或多个隔离的“容器”中运行其他所有内容。容器的目的是启动一组有限数量的应用程序或服务（通常称为微服务），并使它们在独立的沙盒环境中运行。\n这种隔离可防止在给定容器内运行的进程监视或影响在另一个容器中运行的进程。此外，这些集装箱化服务不会影响或干扰主机。能够将分散在多个物理服务器上的许多服务合并为一个的想法是数据中心选择采用该技术的众多原因之一。\n容器有以下几个特点：\n 安全性：容器里可以运行网络服务，这可以限制安全漏洞或违规行为造成的损害。那些成功利用那个容器的一个或多个应用的安全漏洞的入侵者将会被限制在只能在那个容器中做一些操作。 隔离性：容器允许在同一物理机器上部署一个或多个应用程序，即使这些应用程序必须在不同的域下运行，每个域都需要独占访问其各自的资源。例如，通过将每个容器关联的不同IP地址，在不同容器中运行的多个应用程序可以绑定到同一物理网络接口。 虚拟化和透明性：容器为系统提供虚拟化环境，这个环境可以隐藏或限制系统底层的物理设备或系统配置的可见性。容器背后的一般原则是避免更改运行应用程序的环境，但解决安全性或隔离问题除外。  使用LXC的工具 对于大多数现代Linux发行版，内核都启用了控制组，但您很可能仍需要安装LXC工具。\n对于Ubuntu或Debian，只需键入：\n$ sudo apt-get install lxc 现在，在开始使用这些工具之前，您需要配置您的环境。在此之前，您需要验证当前用户是否同时在/etc/subuid和/etc/subgid中定义了uid和gid：\n$ cat /etc/subuid petros:100000:65536 $ cat /etc/subgid petros:100000:65536 如果~/.config/lxc不存在，则创建该目录，并且把配置文件/etc/lxc/default.conf复制到~/.config/lxc/default.conf.，将以下两行添加到文件末尾：\nlxc.id_map = u 0 100000 65536 lxc.id_map = g 0 100000 65536 结果如下：\n$ cat ~/.config/lxc/default.conf lxc.network.type = veth lxc.network.link = lxcbr0 lxc.network.flags = up lxc.network.hwaddr = 00:16:3e:xx:xx:xx lxc.id_map = u 0 100000 65536 lxc.id_map = g 0 100000 65536 将以下命令添加到/etc/lxc/lxc-usernet文件末尾（把第一列换成你的username）：\npetros veth lxcbr0 10 最快使这些配置生效的方法是重启或者将用户登出再登入。\n重新登录后，请验证当前是否已加载veth网络驱动程序：\n$ lsmod | grep veth veth 16384 0 如果没有，请输入：\n$ sudo modprobe veth 现在您可以使用LXC工具集来下载，运行，管理Linux容器。\n接下来，下载容器镜像并将其命名为“example-container”。当您键入以下命令时，您将看到一长串许多Linux发行版和版本支持的容器：\n$ sudo lxc-create -t download -n example-container 将会有三个弹出框让您分别选择发行版名称（distribution），版本号（release）以及架构（architecture）。请选择以下三个选项：\nDistribution: ubuntu Release: xenial Architecture: amd64 选择后点击Enter，rootfs将在本地下载并配置。出于安全原因，每个容器不附带OpenSSH服务器或用户帐户。同时也不会提供默认的root密码。要更改root密码并登录，必须在容器目录路径中运行lxc-attach或chroot（在启动之后）。\n启动容器：\n$ sudo lxc-start -n example-container -d -d选项表示隐藏容器，它会在后台运行。如果您想要观察boot的过程，只需要将-d换成-F。那么它将在前台运行，登录框出现时结束。\n你可能会遇到如下错误：\n$ sudo lxc-start -n example-container -d lxc-start: tools/lxc_start.c: main: 366 The container failed to start. lxc-start: tools/lxc_start.c: main: 368 To get more details, run the container in foreground mode. lxc-start: tools/lxc_start.c: main: 370 Additional information can be obtained by setting the --logfile and --logpriority options. 如果你遇到了，您需要通过在前台运行lxc-start服务来调试它：\n$ sudo lxc-start -n example-container -F lxc-start: conf.c: instantiate_veth: 2685 failed to create veth pair (vethQ4NS0B and vethJMHON2): Operation not supported lxc-start: conf.c: lxc_create_network: 3029 failed to create netdev lxc-start: start.c: lxc_spawn: 1103 Failed to create the network. lxc-start: start.c: __lxc_start: 1358 Failed to spawn container \"example-container\". lxc-start: tools/lxc_start.c: main: 366 The container failed to start. lxc-start: tools/lxc_start.c: main: 370 Additional information can be obtained by setting the --logfile and --logpriority options. 从以上示例，你可以看到模块veth没有被引入，在引入之后，将会解决这个问题。\n之后，打开第二个terminal窗口，验证容器的状态。\n$ sudo lxc-info -n example-container Name: example-container State: RUNNING PID: 1356 IP: 10.0.3.28 CPU use: 0.29 seconds BlkIO use: 16.80 MiB Memory use: 29.02 MiB KMem use: 0 bytes Link: vethPRK7YU TX bytes: 1.34 KiB RX bytes: 2.09 KiB Total bytes: 3.43 KiB 也可以通过另一种方式来查看所有安装的容器，运行命令：\n$ sudo lxc-ls -f NAME STATE AUTOSTART GROUPS IPV4 IPV6 example-container RUNNING 0 - 10.0.3.28 - 但是问题是你仍然不能登录进去，你只需要直接attach到正在运行的容器，创建你的用户，使用passwd命令改变相关的密码。\n$ sudo lxc-attach -n example-container root@example-container:/# root@example-container:/# useradd petros root@example-container:/# passwd petros Enter new UNIX password: Retype new UNIX password: passwd: password updated successfully 更改密码后，您将能够从控制台直接登录到容器，而无需使用lxc-attach命令：\n$ sudo lxc-console -n example-container 如果要通过网络连接到此运行容器，请安装OpenSSH服务器：\n# apt-get install openssh-server 抓取容器的本地IP地址：\n# ip addr show eth0|grep inet inet 10.0.3.25/24 brd 10.0.3.255 scope global eth0 inet6 fe80::216:3eff:fed8:53b4/64 scope link 然后在主机的新的控制台窗口中键入：\n$ ssh 10.0.3.25 瞧！您现在可以SSH到正在运行的容器并键入您的用户名和密码。\n在主机系统上，而不是在容器内，可以观察在启动容器后启动和运行的LXC进程：\n$ ps aux | grep lxc | grep -v grep ... 要停止容器，请键入（在主机）：\n$ sudo lxc-stop -n example-container 停止后，验证容器的状态：\n$ sudo lxc-ls -f NAME STATE AUTOSTART GROUPS IPV4 IPV6 example-container STOPPED 0 - - - $ sudo lxc-info -n example-container Name: example-container State: STOPPED 要彻底销毁容器 - 即从主机system—type清除它：\n$ sudo lxc-destroy -n example-container Destroyed container example-container 销毁后，可以验证是否已将其删除：\n$ sudo lxc-info -n example-container example-container doesn't exist $ sudo lxc-ls -f 注意：如果您尝试销毁正在运行的容器，该命令将失败并告知您容器仍在运行：\n$ sudo lxc-destroy -n example-container example-container is running 在销毁容器前必须先停止它。\n高级配置 有时，可能需要配置一个或多个容器来完成一个或多个任务。 LXC通过让管理员修改位于/var/lib/lxc中的容器配置文件来简化这一过程：\n$ sudo su # cd /var/lib/lxc # ls example-container 容器的父目录将包含至少两个文件：1）容器配置文件和 2）容器的整个rootfs：\n# cd example-container/ # ls config rootfs 假设您想要在主机系统启动时自动启动名称为example-container的容器。那么您需要将以下行添加到容器的配置文件/var/lib/lxc/example-container/config的尾部：\n# Enable autostart lxc.start.auto = 1 重新启动容器或重新启动主机系统后，您应该看到如下内容：\n$ sudo lxc-ls -f NAME STATE AUTOSTART GROUPS IPV4 IPV6 example-container RUNNING 1 - 10.0.3.25 - 注意 AUTOSTART 字段现在被设置为“1”。\n如果在容器启动时，您希望容器绑定装载主机上的目录路径，请将以下行添加到同一文件的尾部：\n# 将挂载系统路径绑定到本地路径 lxc.mount.entry = /mnt mnt none bind 0 0 通过上面的示例，当容器重新启动时，您将看到容器本地的 / mnt目录可访问的主机/ mnt目录的内容。\n特权与非特权容器 您经常会发现在与LXC相关的内容中讨论特权容器和非特权容器的概念。但它们究竟是什么呢？这个概念非常简单，并且LXC容器可以在任一配置下运行。\n根据设计，无特权容器被认为比特权容器更安全，更保密。无特权容器运行时，容器的root UID映射到主机系统上的非root UID。这使得攻击者即使破解了容器，也难以获得对底层主机的root权限。简而言之，如果攻击者设法通过已知的软件漏洞破坏了您的容器，他们会立即发现自己无法获取任何主机权限。\n特权容器可能使系统暴露于此类攻击。这就是为什么我们最好在特权模式下运行尽量少的容器。确定需要特权访问的容器，并确保付出额外的努力来定期更新并以其他方式锁定它们。\n然而，Docker又是什么呢？ 我花了相当多的时间谈论Linux容器，但是Docker呢？它是生产中部署最多的容器解决方案。自首次推出以来，Docker已经风靡Linux计算世界。 Docker是一种Apache许可的开源容器化技术，旨在自动化在容器内创建和部署微服务这类重复性任务。 Docker将容器视为非常轻量级和模块化的虚拟机。最初，Docker是在LXC之上构建的，但它已经远离了这种依赖，从而带来了更好的开发人员和用户体验。与LXC非常相似，Docker继续使用内核cgroup子系统。该技术不仅仅是运行容器，还简化了创建容器，构建映像，共享构建的映像以及对其进行版本控制的过程。\nDocker主要关注于：\n 可移植性：Docker提供基于镜像的部署模型。这种类型的可移植性允许更简单的方式在多个环境中共享应用程序或服务集合（以及它们的所有依赖）。 版本控制：单个Docker镜像由一系列组合层组成。每当镜像被更改时，都会创建一个新层。例如，每次用户指定命令（例如运行或复制）时，都会创建一个新层。 Docker将重用这些层用于新的容器构建。分层到Docker是它自己的版本控制方法。 回滚：再次，每个Docker镜像都有很多层。如果您不想使用当前运行的层，则可以回滚到以前的版本。这种敏捷性使软件开发人员可以更轻松地持续集成和部署他们的软件技术。 快速部署：配置新硬件通常需要数天时间。并且，安装和配置它的工作量和开销是非常繁重的。使用Docker，您可以在几秒钟将镜像启动并运行，相比于之前，节省了大量的时间。当你使用完一个容器时，你可以轻松地销毁它。  从本质上说，Docker和LXC都非常相似。它们都是用户空间和轻量级虚拟化平台，它们利用cgroup和命名空间来管理资源隔离。但是，两者之间也存在许多明显的差异。\n进程管理 Docker将容器限制为单个进程运行。如果您的应用程序包含X个并发进程，Docker将要求您运行X个容器，每个容器都有自己单独的进程。 LXC不是这样，LXC运行具有传统init进程的容器，反过来，可以在同一容器内托管多个进程。例如，如果要托管LAMP（Linux + Apache + MySQL + PHP）服务器，每个应用程序的每个进程都需要跨越多个Docker容器。\n状态管理 Docker被设计为无状态，意味着它不支持持久存储。有很多方法可以解决这个问题，但同样，只有在进程需要时才需要它。创建Docker镜像时，它将包含只读层。这不会改变。在运行时，如果容器的进程对其内部状态进行任何更改，则将保持内部状态和镜像的当前状态之间的差异，直到对Docker镜像进行提交（创建新层）或直到容器被删除，差异也会消失。\n可移植性 在讨论Docker时，这个词往往被过度使用——因为它是Docker相对于LXC的最重要的优势。 Docker从应用程序中抽象出网络，存储和操作系统细节方面做得更好。这样就形成了一个真正独立于配置的应用程序，保证应用程序的环境始终保持不变，无论启用它的机器配置环境如何。\nDocker旨在使开发人员和系统管理员都受益。它已成为许多DevOps（开发人员+维护人员）工具链中不可或缺的一部分。开发人员可以专注于编写代码，而无需担心最终托管它的系统是什么。使用Docker，无需安装和配置复杂数据库，也无需担心在不兼容的语言工具链版本之间切换。 Docker为维护人员提供了更多的灵活性，通常可以减少托管一些较小和更基本的应用程序所需的物理系统数量。 Docker简化了软件交付。新功能和错误/安全修复程序可以快速到达客户，无需任何麻烦，意外或停机。\n总结 为了基础设施安全性和系统稳定性而隔离进程并不像听起来那么痛苦。 Linux内核提供了所有必要的工具，使简单易用的用户空间应用程序【如LXC（甚至Docker）】能够在隔离的沙盒环境中管理操作系统的微实例及其本地服务。\n沙箱 在计算机安全领域，沙箱(Sandbox)是一种程序的隔离运行机制，其目的是限制不可信进程的权限。沙箱技术经常被用于执行未经测试的或不可信的客户程序。为了避免不可信程序可能破坏其它程序的运行，沙箱技术通过为不可信客户程序提供虚拟化的磁盘、内存以及网络资源，而这种虚拟化手段对客户程序来说是透明的。由于沙箱里的资源被虚拟化（或被间接化），所以沙箱里的不可信程序的恶意行为往往会被限制在沙箱中。\n沙箱技术一直是系统安全领域的挑战，不存在说哪一种方案是足够安全的。沙箱技术方案通常是需要结合多种系统安全技术来实现，采用防御纵深(Defence in Depth)的设计原则，筑建多道防御屏障，尽可能地将安全风险将为最低。下面我们主要讨论如何利用Linux kernel所提供的安全功能来建立有效的沙箱技术。\n在讨论之前，我们简单回顾一下Linux安全模型相关的内容（假设读者已经非常熟悉）：\n(1) 每个进程都有自己的地址空间；\n(2) MMU硬件机制来保证地址空间的隔离；\n(3) Kernel是系统的TCB(Trusted Computing Base)，是安全策略的制定者和执行者；\n(4) 进程是最小的权限边界；\n(5) root具有最高权限，它能控制一切；\n(6) 其它用户受DAC(Discretionary Access Control)限制，如文件系统的UGO权限控制。\n进程是最小的权限边界，其根本原因是MMU能保证进程地址空间的隔离。\nLinux Kernel还提供了与进程降权(drop privilege)相关的一些功能：\n setuid POSIX.1e capability chroot jail Quota control (eg, cgroup, namespace) Linux Container Linux Security Module (LSM)  下面我们会介绍如何在实践中利用这些诀窍来构建一个有效的sandbox.\n权限 ugo Linux 系统中文件的 ugo 权限是 Linux 进行权限管理的基本方式。\n所有者和组 Linux 文件的 ugo 权限把对文件的访问者划分为三个类别：文件的所有者、组和其他人。所谓的 ugo 就是指 user(也称为 owner)、group 和 other 三个单词的首字母组合。\n用户和组的信息分别记录在 /etc/passwd、/etc/group 文件中，这两个文件的内容是任何人都有权查看的，可以直接以读取文本文件的方式查看其内容，其中的每一行代表一个用户。\n文件的所有者\n文件的所有者一般是创建该文件的用户，对该文件具有完全的权限。在一台允许多个用户访问的 Linux 主机上，可以通过文件的所有者来区分一个文件属于某个用户。当然，一个用户也无权查看或更改其它用户的文件。\n文件所属的组\n假如有几个用户合作开发同一个项目，如果每个用户只能查看和修改自己创建的文件就太不方便了，也就谈不上什么合作了。所以需要一个机制允许一个用户查看和修改其它用户的文件，此时就用到组的概念的。我们可以创建一个组，然后把需要合作的用户都添加都这个组中。在设置文件的访问权限时，允许这个组中的用户对该文件进行读取和修改。\n其他人\n如果我想把一个文件共享给系统中的所有用户该怎么办？通过组的方式显然是不合适的，因为需要把系统中的所有用户都添加到一个组中。并且系统中添加了新用户该怎么办，每添加一个新用户就把他添加到这个组中吗？这个问题可以通过其他人的概念解决。在设置文件的访问权限时，允许其他人户对该文件进行读取和修改。\n文件属性 使用 ll 命令可以查看文件的属性信息：\n$ ll Desktop drwxr-xr-x 2 nick nick 4.0K Mar 2 15:06 Desktop  drwxr-xr-x 指明文件的类型和 ugo 权限信息。 2 是对文件的引用计数。 nick 是文件的所有者，文件的所有者一般是创建该文件的用户，对该文件具有完全的权限。 nick 是文件所属的组，我们通过 adduser 命令创建用户时一般会创建一个同名的组，该用户就属于与他同名的组(比如笔者机器上的用户 nick 就属于 nick 组)。当我们创建文件和目录时，其默认所属的组就是所有者所在的组。  其它的信息我们暂时忽略。\n文件类型\ndrwxr-xr-x 的第一个字符描述文件的类型，常见的类型有如下几种：\n d 表示目录 - 表示普通文件 l 表示链接文件 b 表示块设备文件 c 表示字符设备文件 s 表示 socket 文件  ugo 权限信息\n10 个字符，除去第一个表示文件类型的字符，其它 9 个字符表示文件的 ugo 权限信息\n这 9 个字符以三个为一组，都是 rwx 或 - 的组合。其中，r 代表可读(read)、 w 代表可写(write)、 x 代表可执行(execute)。 这三个权限的位置不会改变，如果没有对应的权限，就会以 -(减号)代替。\n*第一组为文件所有者的权限，第二组为文件所属组的权限，第三组为其他人的权限。*其表示的具体含义为：文件所有者具有对文件的读写权限，文件所属组的用户具有对文件读写的权限，而其他人只有读取文件的权限。\n下面详细的解释一下文件读写执行的权限：\n r (read)：可以读取文件的实际内容，比如读取文本文件内的文字等。 w (write)：可以编辑、增加、删除文件的内容(但不含删除该文件)。 x (execute)：该文件具有可以被系统执行的权限。  可以看出，对于文件来说，rwx 主要针对的是文件的内容。\n对目录而言，目录中存储的主要是目录下文件名称的列表，这与普通文件是有些不同的：\n r (read contents in directory) 表示具有读取目录下文件名称的权限，也就是说你可以通过 ls 命令把目录下的文件列表查询出来。 w (modify contents of directory) 具有 w 权限表明你可以在该目录下执行如下的操作：  创建新的文件和目录 删除已经存在的文件与目录(不论该文件的权限为何!) 重命名已存在的文件或目录 移动该目录内文件、目录的位置   x (access directory) 目录虽然不能被执行，但是却具有可以执行的权限。目录的 x 权限表示用户是否可以进入该目标并成为当前的工作目录。注意，如果用户对目录没有 x 权限，则无法查看该目录下的文件的内容(注意与 r 权限的区别)。  综上，如果要允许目录被其他人浏览时，至少要给予 r 和 x 的权限。\n改变权限 在新建文件时会根据创建者的身份和其它的一些设置为文件生成默认的权限。\n接下来我们介绍如何通过命令修改文件权限相关的信息。\n改变文件所有者\n通过 chown 命令可以改变文件的所有者：\n$ sudo chown tester testfile 改变文件所属的组\n通过 chgrp 命令可以改变文件所属的组：\n$ sudo chgrp tester testfile 改变文件的权限\n通过 chmod 命令可以改变文件的权限。对于文件的 rwx 权限，有两种表示方法，数字表示法和字符表示法。\n以数字表示权限的方式如下：\n r: 4 w: 2 x: 1  如果是 rwx 权限就是 4 + 2 + 1 = 7 ，r-x 就是 4 + 1 = 5 ，— 则为 0。所以 rw-rw-r– 就可以用 664 来表示。如果我们想把文件的权限修改为 rwxrwxrwx，可以使用下面的命令：\n$ chmod 777 testfile 以字符表示权限的方式如下：用字符 u, g, o 分别代表文件所有者(user)、文件所属的组(group)和其他人(other)，这就是 ugo 权限叫法的由来。只不过还有一个 a 可以表示全部的身份(all)。具体更改权限的语法如下：\nchmod [ugoa][+-=][rwx] 文件/目录 比如我们可以通过下面的命令把 testfile 的权限设为 rw-rw-r–：\n$ chmod ug=rw,o=r testfile 如果想去掉组的 w 权限并给其他人添加 x 权限可以执行下面的命令：\n$ chmod g-w,o+x testfile 我们还可通过 a 为全部身份设置权限，比如 rwx：\n$ chmod a=rwx testfile 特殊权限 setuid 和 setgid 分别是 set uid ID upon execution 和 set group ID upon execution 的缩写。我们一般会再次把它们缩写为 suid 和 sgid。它们是控制文件访问的权限标志(flag)，它们分别允许用户以可执行文件的 owner 或 owner group 的权限运行可执行文件。\nSUID 在 Linux 中，所有账号的密码记录在 /etc/shadow 这个文件中，并且只有 root 可以读写入这个文件：\n$ ll /etc/shadow -rw-r----- 1 root shadow 1.5K Feb 25 12:46 /etc/shadow 如果另一个普通账号 tester 需要修改自己的密码，就要访问 /etc/shadow 这个文件。但是明明只有 root 才能访问 /etc/shadow 这个文件，这究竟是如何做到的呢？事实上，tester 用户是可以修改 /etc/shadow 这个文件内的密码的，就是通过 SUID 的功能。让我们看看 passwd 程序文件的权限信息：\n$ ll /usr/bin/passwd -rwsr-xr-x 1 root root 67K Jul 15 2021 /usr/bin/passwd 上图红框中的权限信息有些奇怪，owner 的信息为 rws 而不是 rwx。当 s 出现在文件拥有者的 x 权限上时，就被称为 SETUID BITS 或 SETUID ，其特点如下：\n SUID 权限仅对二进制可执行文件有效 如果执行者对于该二进制可执行文件具有 x 的权限，执行者将具有该文件的所有者的权限 本权限仅在执行该二进制可执行文件的过程中有效  下面我们来看 tester 用户是如何利用 SUID 权限完成密码修改的：\n tester 用户对于 /usr/bin/passwd 这个程序具有执行权限，因此可以执行 passwd 程序 passwd 程序的所有者为 root tester 用户执行 passwd 程序的过程中会暂时获得 root 权限 因此 tester 用户在执行 passwd 程序的过程中可以修改 /etc/shadow 文件  但是如果由 tester 用户执行 cat 命令去读取 /etc/shadow 文件确是不行的：\n$ ll /bin/cat -rwxr-xr-x 1 root root 43K Sep 5 2019 /bin/cat 原因很清楚，tester 用户没有读 /etc/shadow 文件的权限，同时 cat 程序也没有被设置 SUID。我们可以通过下图来理解这两种情况：\nSGID 当 s 标志出现在用户组的 x 权限时称为 SGID。SGID 的特点与 SUID 相同，我们通过 /usr/bin/mlocate 程序来演示其用法。mlocate 程序通过查询数据库文件 /var/lib/mlocate/mlocate.db 实现快速的文件查找。 mlocate 程序的权限如下图所示：\n$ ll /usr/bin/mlocate -rwxr-sr-x 1 root mlocate 39520 Nov 18 2014 /usr/bin/mlocate* 很明显，它被设置了 SGID 权限。下面是数据库文件 /var/lib/mlocate/mlocate.db 的权限信息：\n$ ll /var/lib/mlocate/mlocate.db -rw-r----- 1 root mlocate 12101109 Aug 13 07:35 /var/lib/mlocate/mlocate.db 普通用户 tester 执行 mlocate 命令时，tester 就会获得用户组 mlocate 的执行权限，又由于用户组 mlocate 对 mlocate.db 具有读权限，所以 tester 就可以读取 mlocate.db 了。程序的执行过程如下图所示：\n除二进制程序外，SGID 也可以用在目录上。当一个目录设置了 SGID 权限后，它具有如下功能：\n 用户若对此目录具有 r 和 x 权限，该用户能够进入该目录 用户在此目录下的有效用户组将变成该目录的用户组 若用户在此目录下拥有 w 权限，则用户所创建的新文件的用户组与该目录的用户组相同  SBIT 其实 SBIT 与 SUID 和 SGID 的关系并不大。SBIT 是 the restricted deletion flag or sticky bit 的简称。\nSBIT 目前只对目录有效，用来阻止非文件的所有者删除文件。比较常见的例子就是 /tmp 目录：\n$ ls -ld /tmp drwxrwxrwt 22 root root 4096 Mar 2 20:57 /tmp 权限信息中最后一位 t 表明该目录被设置了 SBIT 权限。SBIT 对目录的作用是：当用户在该目录下创建新文件或目录时，仅有自己和 root 才有权力删除。\n设置权限 以数字的方式设置权限\nSUID、SGID、SBIT 权限对应的数字如下：\nSUID-4 SGID-2 SBIT-1 所以如果要为一个文件权限为 “-rwxr-xr-x” 的文件设置 SUID 权限，需要在原先的 755 前面加上 4，也就是 4755：\n$ chmod 4755 filename 同样，可以用 2 和 1 来设置 SGID 和 SBIT 权限。设置完成后分别会用 s, s, t 代替文件权限中的 x。\n其实，还可能出现 S 和 T 的情况。s 和 t 是替代 x 这个权限的，但是，如果它本身没有 x 这个权限，添加 SUID、SGID、SBIT 权限后就会显示为大写 S 或大写 T。比如我们为一个权限为 666 的文件添加 SUID、SGID、SBIT 权限：\n$ chmod 666 nickfile $ ll nickfile -rw-rw-rw- 1 nick nick 0 Mar 2 21:03 nickfile $ chmod 7666 nickfile $ ll nickfile -rwSrwSrwT 1 nick nick 0 Mar 2 21:03 nickfile 通过符号类型改变权限\n除了使用数字来修改权限，还可以使用符号：\n$ chmod u+s testfile # 为 testfile 文件加上 SUID 权限。 $ chmod g+s testdir # 为 testdir 目录加上 SGID 权限。 $ chmod o+t testdir # 为 testdir 目录加上 SBIT 权限。 umask 默认权限 为了查看用户创建的文件和目录的默认权限，我们用一个普通的用户创建文件 myfile 和目录 mydir 并查看它们的默认权限：\n$ touch myfile $ mkdir mydir $ ll total 4.0K drwxrwxr-x 2 nick nick 4.0K Mar 2 21:09 mydir -rw-rw-r-- 1 nick nick 0 Mar 2 21:09 myfile 目录的权限为 775，文件的权限为 664。默认情况下对于目录来说最大的权限是 777，对于文件来说最大的权限一般为 666(只有可以执行的文件才添加可执行权限)。所以我们创建的文件和目录的共同特点是从最大权限中减其他用户的写权限。而这个被减去的值就是我们常说的 umask。umask 还是 bash 的一个内置命令，默认输出当前用户的 umask 值：\n$ umask 002 注意，umask 显示的值为从默认的最大权限中减去的值。\n默认策略 系统在用户登录时通过 login 程序调用 pam_umask 模块设置用户默认的 umask。从 login 程序的配置文件 /etc/login.defs 中我们可以找到 umask 相关的配置：\n... UMASK 022 ... USERGROUPS_ENAB yes ... 用户的默认 umask 应该是 022，但当 USERGROUPS_ENAB 被设置为 yes 时(默认值)，对于 uid 和 gid 相同且用户名和主组名相同的用户，系统会把其 umask 改为 002。\n于 root 用户的特殊性，它默认的 umask 与其它用户是不同的，其值为 022：\n# umask 0022 第一个 0 表示 8 进制，这里我们可以暂时忽略它。\n命令 umask 是 bash 的一个内置命令，用来显示或设置新建文件/目录的权限掩码(umask)。前面我们以数字的方式输出了用户默认的 umask 值，这次我们以符号的方式进行输出：\n$ umask -S u=rwx,g=rwx,o=rx 以符号输出的就是用户创建目录时的默认权限，也就是 775。\n为了改变用户创建的文件/目录的默认值，我们可以改变 umask 的默认值。\n设置 umask 值\n最简单的方式就是为 umask 命令指定一个数字：\n$ umask 026 026 的含义为：去掉 group 中的写权限，去掉 other 中的读写权限。\n这时创建的文件权限为 640，目录权限为 751。注意，修改 umask 后只有新建的文件和目录受影响，已经存在的文件和目录的权限不会被影响。\n以符号的方式设置 umask 值\n比如下面的命令：\n$ umask u=,g=w,o=rwx 上面的命令表示从 group 中去掉写权限，从 other 中去掉读写执行的权限。\n注意：\"=\" 号在 umask 命令和 chmod 命令中的作用恰恰相反。在 chmod 命令中，利用它来设置指定的权限，而其余权限则被删除。但是在 umask 命令中，将在原有权限的基础上删除指定的权限。\n在 ~/.bashrc 文件中为用户设置默认的 umask\n如果让用户每次登陆后都执行 umask 命令修改默认的 umask 值是不科学的，我们可以在用户的 ~/.bashrc 文件中执行 umask 命令，这样用户登录后 umask 的值自动就变成了设置的值。把下面的命令添加到 ~/.bashrc 文件的最后一行：\numask 026 与 ACL 如果一个目录没有被设置 default ACL，那么将由 umask 决定新文件的 ACL 权限。这种情况其实就是我们常见的没有 ACL 权限时的情况。比如我们设置 umask 为 026，那么创建的文件和目录的权限就是由它决定的。\n如果一个目录被设置了 default ACL，那么将会由文件创建函数的 mode 参数和目录的 default ACL 共通决定新文件的 ACL 权限，此时 umask 被忽略。还以 umask 026 为例，我们创建一个目录 dir2 并设置 default ACL 权限：\n$ setfacl -m d:u:tester:rwx dir2 $ getfacl dir2 # file: dir2 # owner: nick # group: nick user::rwx group::r-x other::--x default:user::rwx default:user:tester:rwx default:group::rwx default😷:rwx default:other::r-x 然后在 dir2 目录中创建文件 testfile：\n$ dir2 touch testfile $ dir2 ll testfile -rw-rw-r--+ 1 nick nick 0 Mar 2 21:26 testfile 这次 testfile 的权限已经不受 umask 的影响了！\nACL ACL的全称是 Access Control List (访问控制列表) ，一个针对文件/目录的访问控制列表。它在UGO权限管理的基础上为文件系统提供一个额外的、更灵活的权限管理机制。它被设计为UNIX文件权限管理的一个补充。ACL允许你给任何特定的用户或用户组设置任何文件/目录的访问权限。\nACL需要Linux内核和文件系统的配合才能工作，大多数Linux发行版本默认都是支持的。但最好还是能够先检查一下：\n$ sudo tune2fs -l /dev/sda1 | grep \"Default mount options:\" Default mount options: user_xattr acl 设置权限 可以使用setfacl和getfacl命令来设置或观察文件/目录的acl权限。\n当前用户是 nick，再创建两个用户 tester 和 tester1 用来进行测试：\n$ sudo adduser tester 创建文件 aclfile，检查其默认的权限信息：\n$ touch aclfile $ ll aclfile -rw-rw-r-- 1 nick nick 0 Mar 2 21:40 aclfile $ getfacl aclfile # file: aclfile # owner: nick # group: nick user::rw- group::rw- other::r-- 把用户切换为 tester，发现没有写文件的权限：\n$ echo \"hello\"  aclfile bash: aclfile: Permission denied 这是因为 other 没有写 aclfile 文件的权限。\n下面我们为 tester 用户赋予读写 aclfile 文件的权限：\n$ setfacl -m u:tester:rw aclfile 修改成功后再次以 tester 用户的身份向 aclfile 文件写入数据，这次已经可以正常写入了。查看 aclfile 文件的权限：\n$ getfacl aclfile # file: aclfile # owner: nick # group: nick user::rw- user:tester:rw- group::rw- mask::rw- other::r-- 多出了一些信息，其中比较重要的是 user:tester:rw-，就是它让用户 tester 具有了读写 aclfile 的权限。\n针对用户组来设置权限和针对用户的设置几乎一样，只是把小写的 u 换成小写的 g 就行了。\n继承权限 acl 能让创建的子文件或者子文件夹继承父文件夹的权限设置！\n$ mkdir mydir $ ll -d mydir drwxrwxr-x 2 nick nick 4.0K Mar 2 21:09 mydir $ setfacl -m d:u:tester:rwx mydir $ getfacl mydir # file: mydir # owner: nick # group: nick user::rwx group::rwx other::r-x default:user::rwx default:user:tester:rwx default:group::rwx default😷:rwx default:other::r-x 这次多出了一些以 default 开头的行，这些 default 权限信息只能在目录上设置，然后会被目录中创建的文件和目录继承。下面分别在 mydir 目录下创建文件 testfile 和目录 testdir，并查看它们的 acl 权限：\n$ touch testfile $ mkdir testdir $ getfacl testfile # file: testfile # owner: nick # group: nick user::rw- user:tester:rwx group::rwx mask::rw- other::r-- 从上面可以看到文件 testfile 继承了父目录的 acl 权限，因此用户 tester 对它有读写权限。下面再看看 testdir 目录：\n$ getfacl testdir # file: testdir # owner: nick # group: nick user::rwx user:nick:rwx group::rwx mask::rwx other::r-x default:user::rwx default:user:tester:rwx default:group::rwx default😷:rwx default:other::r-x 从图中可以看出，testdir 目录不仅继承了 tester 的访问权限，还继承了父目录上的 default 权限。也就是说我们通过这种方式设置在目录上的权限可以被子目录递归的继承下去。\n操作权限 更改 -m 选项其实是在更改文件和目录的 ACL 权限\n 当一个用户或组的 ACL 权限不存在时，-m 选项执行的是添加操作， 如果一个用户或组的 ACL 权限已经存在时，-m 选项执行的是更新操作。  $ setfacl -m u:tester:rwx aclfile $ setfacl -m u:tester:rw aclfile -set 选项会先清除掉原有的 ACL 权限，然后添加新的权限\n$ setfacl --set u::rw,u:tester:rwx,g::r,o::- aclfile $ getfacl aclfile # file: aclfile # owner: nick # group: nick user::rw- user:tester:rwx group::r-- mask::rwx other::--- 需要注意的是一定要包含 UGO 权限的设置，不能象 -m 一样只包含 ACL 权限。o::- 是另一个需要注意的地方，其完整的写法是 other::-，就像 u::rw 的完整写法是 user::rw- 一样。通常我们可以把 “-” 省略，但是当权限位只包含 “-” 时，就至少要保留一个。如果写成了o::，就会报错。\n删除 通过 setfacl 命令的 -x 选项来删除指定用户或组的 ACL 权限，还可以通过 -b 选项来清除文件和目录上所有的 ACL 权限。\n下面通过 -x 选项删除 user tester 的 ACL 权限，注意命令中只指定了用户的名称而没有指定权限信息：\n$ getfacl aclfile # file: aclfile # owner: nick # group: nick user::rw- user:tester:rwx group::rw- mask::rwx other::r-- $ setfacl -x u:tester aclfile $ getfacl aclfile # file: aclfile # owner: nick # group: nick user::rw- group::rw- mask::rw- other::r-- 下面通过 -b 选项一次性删除 aclfile 上所有的 ACL 权限：\n$ setfacl -b aclfile getfacl aclfile # file: aclfile # owner: nick # group: nick user::rw- group::rw- other::r-- 备份和恢复 常见的文件操作命令 cp 和 mv 等都支持 ACL 权限，只是 cp 命令需要加上 -p 参数。但是 tar 等常见的备份工具不会保留目录和文件的 ACL 权限信息。如果希望备份和恢复带有 ACL 权限的文件和目录，可以先把 ACL 权限信息备份到一个文件里，然后再用 -restore 选项来恢复这些信息。\n使用下面的命令导出 acldir 目录的 ACL 权限信息并保存到文件 acldir.acl 文件中：\n$ getfacl -R acldir  acldir.acl 通过下面的命令把它们的 ACL 权限都恢复回来：\n$ setfacl --restore acldir.acl 实现原理 ACL 条目\n进程权限 ugo 权限信息是文件的属性，它指明了用户与文件之间的关系。但是真正操作文件的却是进程，也就是说用户所拥有的文件访问权限是通过进程来体现的。\n概念：\n  用户 对于支持多任务的 Linux 系统来说，用户就是获取资源的凭证。\n  权限 权限用来控制用户对计算机资源(CPU、内存、文件等)的访问，一般会分为认证和授权两步。比如用户先经过认证机制(authentication)登录系统，然后由授权系统(authorization)对用户的操作进行授权。\n  进程 进程是任何支持多道程序设计的操作系统中的基本概念。通常把进程定义为程序执行时的一个实例。因此，如果有 10 个用户同时运行 vi，就会有 10 个独立的进程(尽管它们共享同一份可执行代码)。\n实际上，是进程在帮助我们完成各种任务。进程就是用户访问计算机资源的代理，用户执行的操作其实是带有用户身份信息的进程执行的操作。\n  进程权限 既然是进程在为用户执行具体的操作，那么当用户要访问系统的资源时就必须给进程赋予权限。也就是说进程必须携带发起这个进程的用户的身份信息才能够进行合法的操作。\n  登陆过程 在 Linux 系统启动后，init 系统会 fork 出子进程执行 /sbin/getty 程序等待用户登录。当用户进行登录操作时，该子进程通过 exec 函数开始执行 /bin/login 程序(此时该进程已经变成了 login 进程)。由 login 进程验证我们的用户名和密码并查询 /etc/passwd 和 /etc/shadow 确定其合法性。如果是合法的用户，该进程再次通过 exec 函数执行用户的默认 shell 程序，此时的 login 进程就变成了 shell 进程(笔者机器上是 bash 进程)。并且**该 shell 进程的有效身份被设置成为该用户的身份，之后 fork 此 shell 进程的子进程都会继承该有效身份。**我们可以通过下图来理解用户从 tty 登录系统的过程：\n简单点说就是：用户登录后， shell 进程的有效用户就是该用户。\nuser id 通过 cat /proc//status 命令，我们可以查看到进程所属的用户和组相关的信息：\nUid: 1000 1000 1000 1000 Gid: 1000 1000 1000 1000 通过 man proc 可以查询到第一行的四个数字分别是 real user id, effective user id, saved set user id 和 filesystem UID，第二行则是对应的组 ID。\nreal user id\nreal user id 是执行进程者的 user id，一般情况下就是用户登录时的 user id。子进程的 real user id 从父进继承。通常这个是不更改的，也不需要更改。比如我以用户 nick 登录 Linux 系统，我接下来运行的所有命令的进程的 real user id 都是 nick 的 user id。\neffective user id\n如果要判断一个进程是否对某个文件有操作权限，验证的是进程的 effective user id，而不是 real user id。\n通常不建议直接使用 root 用户进行操作的，但是在很多情况下，程序可能需要特殊的权限。比如 passwd 程序需要 root 权限才能够为普通用户修改密码，一些 services 程序的操作也经常需要特殊的权限。为此，Linux 中设计了一些特殊的权限（SUID/SGID/SBIT）。这里我们以 passwd 程序为例，为二进制可执行文件 /usr/bin/passwd 设置 set-user-id bit=ON，这个可执行文件被用 exec 启动之后的进程的 effective user id 就是这个可执行文件的 owner id，而并非父进程的 real user id。如果 set-user-id bit=OFF 的时候，这个被 exec 起来的进程的 effective user id 应该是等于进程的 user id 的。\n其实我们通过 ps aux 查看的结果中，第一列显示的就是进程的 effective user。\nsaved set user id\nsaved set user id 相当于是一个 buffer，在 exec 函数启动之后，它会拷贝 effective user id 位的信息覆盖自己。\n对于非 root 用户来说，可以在未来使用 setuid() 函数将 effective user id 设置成为 real user id 或 saved set user id 中的任何一个。但是不允许非 root 用户用 setuid() 函数把 effective user id 设置成为任何第三个 user id。\n对于 root 用户来说，调用 setuid() 的时候，将会设置所有的这三个 user id。\n外部命令 在 shell 中执行的命令分为内部命令和外部命令两种。\n 内部命令：内建的，相当于 shell 的子函数 外部命令：在文件系统的某个路径下的一个可执行文件  外部命令的执行过程如下：\n Shell 通过 fork() 函数建立一个新的子进程，新的子进程为当前 shell 进程的一个副本。 在新的进程里，从 PATH 变量所列出的目录中寻找指定的命令程序。当命令名称包含有斜杠(/)符号时，将略过路径查找步骤。 在新的进程里，通过 exec 系列函数，以所找到的新程序替换 shell 程序并执行。 子进程退出后，最初的 shell 会接着从终端读取并执行下一条命令。  我们通过下面的例子来理解在 shell 中执行外部命令的过程，例子很简单就是通过 cat 命令查看一个文本文件 test.log：\n$ cat test.log 我们先来检查一下当前用户以及相关文件的权限：\n$ uid=1000(nick) gid=1000(nick) groups=1000(nick),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),120(lpadmin),132(lxd),133(sambashare) $ ll /bin/cat -rwxr-xr-x 1 root root 43K Sep 5 2019 /bin/cat $ ll test.log -rw-rw-r-- 1 nick nick 0 Mar 2 23:25 test.log 当前用户 nick 的 real user id 为 1000，/bin/cat 文件的所有者为 root，但是所有人都有执行权限，test.log 文件的所有者为 nick。我们结合下图来介绍 cat test.log 命令的执行过程：\n当我们在 shell 中执行一个外部程序的时候，默认情况下进程的 effective user ID 等于 real user ID，进程的 effective group ID 等于 real group ID(接下来的介绍中省略 group ID)。当我们以用户 nick 登录系统，并在 bash 中键入 cat test.log 命令并回车后。Bash 先通过 fork() 建立一个新的子进程，这个新的子进程是当前 bash 进程的一个副本。新的进程在 PATH 变量指定的路径中搜索 cat 程序，找到 /bin/cat 程序后检查其权限。/bin/cat 程序的所有者为 root，但是其他人具有读和执行的权限，所以新进程可以通过 exec 函数用 cat 程序的代码段替换当前进程中的代码段(把 /bin/cat 程序加载到了内存中，此时的进程已经变成了 cat 进程，cat 进程会从 _start 函数开始执行)。由于 cat 进程是由用户 nick 启动的，所以 cat 进程的 effective user ID 是 1000(nick)。同时 cat 进程的 effective user ID 和 test.log 文件的 owner ID 相同(都是 1000)，所以 cat 进程拥有对此文件的 rw- 权限，那么顺理成章地就可以读写 test.log 文件的内容了。\n脚本 在 shell 中执行脚本的方式和执行外部命令的方式差不多，比如我们要执行下面的脚本：\n$ /bin/bash ./test.sh 这时同样会 fork 出一个子进程。只不过脚本与程序相比没有代码段，也没有 _start 函数，此时 exec 函数就会执行另外一套机制。比如我们在 test.sh 文件的第一行通过 #!/bin/bash 指定了一个解释器，那么解释器程序的代码段会用来替换当前进程的代码段，并且从解释器的 _start 函数开始执行，而这个文本文件被当作命令行参数传给解释器。所以上面的命令执行过程为：Bash 进程 fork/exec 一个子 bash 进程用于执行脚本，子 bash 进程继承父进程的环境变量、用户信息等内容，父进程等待子 bash 进程终止。\n 权限 cgroub sudo fdisk 自动更新 LVM 进程  Capabilities 为了执行权限检查，Linux 区分两类进程：特权进程(其有效用户标识为 0，也就是超级用户 root)和非特权进程(其有效用户标识为非零)。 特权进程绕过所有内核权限检查，而非特权进程则根据进程凭证(通常为有效 UID，有效 GID 和补充组列表)进行完全权限检查。\n以常用的 passwd 命令为例，修改用户密码需要具有 root 权限，而普通用户是没有这个权限的。但是实际上普通用户又可以修改自己的密码，这是怎么回事？在 Linux 的权限控制机制中，有一类比较特殊的权限设置，比如 SUID(Set User ID on execution)。因为程序文件 /bin/passwd 被设置了 SUID 标识，所以普通用户在执行 passwd 命令时，进程是以 passwd 的所有者，也就是 root 用户的身份运行，从而修改密码。\nSUID 虽然可以解决问题，却带来了安全隐患。当运行设置了 SUID 的命令时，通常只是需要很小一部分的特权，但是 SUID 给了它 root 具有的全部权限。因此一旦 被设置了 SUID 的命令出现漏洞，就很容易被利用。也就是说 SUID 机制在增大了系统的安全攻击面。\nLinux 引入了 capabilities 机制对 root 权限进行细粒度的控制，实现按需授权，从而减小系统的安全攻击面。\n简介 从内核 2.2 开始，Linux 将传统上与超级用户 root 关联的特权划分为不同的单元，称为 capabilites。Capabilites 作为线程(Linux 并不真正区分进程和线程)的属性存在，每个单元可以独立启用和禁用。如此一来，权限检查的过程就变成了：在执行特权操作时，如果进程的有效身份不是 root，就去检查是否具有该特权操作所对应的 capabilites，并以此决定是否可以进行该特权操作。比如要向进程发送信号(kill())，就得具有 capability CAP_KILL；如果设置系统时间，就得具有 capability CAP_SYS_TIME。\n下面是从 capabilities man page 中摘取的 capabilites 列表：\n   capability 名称 描述     CAP_AUDIT_CONTROL 启用和禁用内核审计；改变审计过滤规则；检索审计状态和过滤规则   CAP_AUDIT_READ 允许通过 multicast netlink 套接字读取审计日志   CAP_AUDIT_WRITE 将记录写入内核审计日志   CAP_BLOCK_SUSPEND 使用可以阻止系统挂起的特性   CAP_CHOWN 修改文件所有者的权限   CAP_DAC_OVERRIDE 忽略文件的 DAC 访问限制   CAP_DAC_READ_SEARCH 忽略文件读及目录搜索的 DAC 访问限制   CAP_FOWNER 忽略文件属主 ID 必须和进程用户 ID 相匹配的限制   CAP_FSETID 允许设置文件的 setuid 位   CAP_IPC_LOCK 允许锁定共享内存片段   CAP_IPC_OWNER 忽略 IPC 所有权检查   CAP_KILL 允许对不属于自己的进程发送信号   CAP_LEASE 允许修改文件锁的 FL_LEASE 标志   CAP_LINUX_IMMUTABLE 允许修改文件的 IMMUTABLE 和 APPEND 属性标志   CAP_MAC_ADMIN 允许 MAC 配置或状态更改   CAP_MAC_OVERRIDE 覆盖 MAC(Mandatory Access Control)   CAP_MKNOD 允许使用 mknod() 系统调用   CAP_NET_ADMIN 允许执行网络管理任务   CAP_NET_BIND_SERVICE 允许绑定到小于 1024 的端口   CAP_NET_BROADCAST 允许网络广播和多播访问   CAP_NET_RAW 允许使用原始套接字   CAP_SETGID 允许改变进程的 GID   CAP_SETFCAP 允许为文件设置任意的 capabilities   CAP_SETPCAP 参考 capabilities man page   CAP_SETUID 允许改变进程的 UID   CAP_SYS_ADMIN 允许执行系统管理任务，如加载或卸载文件系统、设置磁盘配额等   CAP_SYS_BOOT 允许重新启动系统   CAP_SYS_CHROOT 允许使用 chroot() 系统调用   CAP_SYS_MODULE 允许插入和删除内核模块   CAP_SYS_NICE 允许提升优先级及设置其他进程的优先级   CAP_SYS_PACCT 允许执行进程的 BSD 式审计   CAP_SYS_PTRACE 允许跟踪任何进程   CAP_SYS_RAWIO 允许直接访问 /devport、/dev/mem、/dev/kmem 及原始块设备   CAP_SYS_RESOURCE 忽略资源限制   CAP_SYS_TIME 允许改变系统时钟   CAP_SYS_TTY_CONFIG 允许配置 TTY 设备   CAP_SYSLOG 允许使用 syslog() 系统调用   CAP_WAKE_ALARM 允许触发一些能唤醒系统的东西(比如 CLOCK_BOOTTIME_ALARM 计时器)    程序文件的 capabilities\n在可执行文件的属性中有三个集合来保存三类 capabilities，它们分别是：\n Permitted Inheritable Effective  在进程执行时，Permitted 集合中的 capabilites 自动被加入到进程的 Permitted 集合中。\nInheritable 集合中的 capabilites 会与进程的 Inheritable 集合执行逻辑与操作，以确定进程在执行 execve 函数后哪些 capabilites 被继承。\nEffective 只是一个 bit。如果设置为开启，那么在执行 execve 函数后，Permitted 集合中新增的 capabilities 会自动出现在进程的 Effective 集合中。\n进程的 capabilities\n进程中有五种 capabilities 集合类型，分别是：\n Permitted Inheritable Effective Bounding Ambient  相比文件的 capabilites，进程的 capabilities 多了两个集合，分别是 Bounding 和 Ambient。\n/proc/[pid]/status 文件中包含了进程的五个 capabilities 集合的信息，我们可以通过下面的命名查看当前进程的 capabilities 信息：\n$ cat /proc/$$/status | grep 'Cap' CapInh: 0000000000000000 CapPrm: 0000000000000000 CapEff: 0000000000000000 CapBnd: 000003ffffffffff CapAmb: 0000000000000000 但是这中方式获得的信息无法阅读，我们需要使用 capsh 命令把它们转义为可读的格式：\n$ capsh --decode=0000003fffffffff 使用 getcap 命令和 setcap 命令分别用来查看和设置程序文件的 capabilities 属性。下面我们演示如何使用 capabilities 代替 ping 命令的 SUID。\n因为 ping 命令在执行时需要访问网络，这就需要获得 root 权限，常规的做法是通过 SUID 实现的(和 passwd 命令相同)：\n$ ll /bin/ping -rwsr-xr-x 1 root root 72K Jan 31 2020 /bin/ping $ ll /usr/bin/passwd -rwsr-xr-x 1 root root 67K Jul 15 2021 /usr/bin/passwd 红框中的 s 说明应用程序文件被设置了 SUID，这样普通用户就可以执行这些命令了。\n移除 ping 命令文件上的 SUID 权限：\n$ sudo chmod 755 /bin/ping $ ping baidu.com ping: socket: Operation not permitted 在移除 SUID 权限后，普通用户在执行 ping 命令时碰到了 “ping: socket: Operation not permitted” 错误。\n为 ping 命令文件添加 capabilities\n执行 ping 命令所需的 capabilities 为 cap_net_admin 和 cap_net_raw，通过 setcap 命令可以添加它们：\n$ sudo setcap cap_net_admin,cap_net_raw+ep /bin/ping $ getcap /bin/ping /bin/ping = cap_net_admin,cap_net_raw+ep $ ping baidu.com PING baidu.com (220.181.38.148) 56(84) bytes of data. 64 bytes from 220.181.38.148 (220.181.38.148): icmp_seq=1 ttl=46 time=33.3 ms 64 bytes from 220.181.38.148 (220.181.38.148): icmp_seq=2 ttl=46 time=40.9 ms 被赋予合适的 capabilities 后，ping 命令又可以正常工作了，相比 SUID 它只具有必要的特权，在最大程度上减小了系统的安全攻击面。\n如果要移除刚才添加的 capabilities，执行下面的命令：\n$ sudo setcap cap_net_admin,cap_net_raw-ep /bin/ping $ getcap /bin/ping /bin/ping = 命令中的 ep 分别表示 Effective 和 Permitted 集合，+ 号表示把指定的 capabilities 添加到这些集合中，- 号表示从集合中移除(对于 Effective 来说是设置或者清除位)。\n",
  "wordCount" : "131033",
  "inLanguage": "en",
  "datePublished": "2022-03-08T15:32:32+08:00",
  "dateModified": "2022-03-08T15:32:32+08:00",
  "author":{
    "@type": "Person",
    "name": "Sakamoto Kurome"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://sakamotokurome.github.io/posts/ubuntusystem/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Sakamoto Kurome",
    "logo": {
      "@type": "ImageObject",
      "url": "https://sakamotokurome.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://sakamotokurome.github.io/" accesskey="h" title="Sakamoto Kurome (Alt + H)">Sakamoto Kurome</a>
            <span class="logo-switches">
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://sakamotokurome.github.io/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://sakamotokurome.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://sakamotokurome.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Ubuntu System
    </h1>
    <div class="post-meta"><span title='2022-03-08 15:32:32 +0800 CST'>March 8, 2022</span>&nbsp;·&nbsp;262 min&nbsp;·&nbsp;Sakamoto Kurome

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#winehttpswikiarchlinuxorgtitlewine_e7ae80e4bd93e4b8ade69687" aria-label="Wine"><a href="https://wiki.archlinux.org/title/Wine_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Wine</a></a><ul>
                        
                <li>
                    <a href="#%e7%ae%80%e4%bb%8bhttpszhmwikipediaorgwikiwine" aria-label="简介"><a href="https://zh.m.wikipedia.org/wiki/Wine">简介</a></a></li>
                <li>
                    <a href="#%e5%ae%89%e8%a3%85httpswikiwinehqorgubuntu" aria-label="安装"><a href="https://wiki.winehq.org/Ubuntu">安装</a></a></li>
                <li>
                    <a href="#%e9%85%8d%e7%bd%ae" aria-label="配置">配置</a><ul>
                        
                <li>
                    <a href="#%e5%88%9d%e5%a7%8b%e8%ae%be%e7%bd%aehttpswikiubuntuorgcnubuntuhelpwinezh" aria-label="初始设置"><a href="https://wiki.ubuntu.org.cn/UbuntuHelp:Wine/zh">初始设置</a></a></li>
                <li>
                    <a href="#wineprefix" aria-label="WINEPREFIX">WINEPREFIX</a></li>
                <li>
                    <a href="#winearch" aria-label="WINEARCH">WINEARCH</a></li>
                <li>
                    <a href="#%e5%9b%be%e5%bd%a2%e9%a9%b1%e5%8a%a8" aria-label="图形驱动">图形驱动</a></li>
                <li>
                    <a href="#%e5%a3%b0%e9%9f%b3" aria-label="声音">声音</a></li>
                <li>
                    <a href="#%e5%ad%97%e4%bd%93" aria-label="字体">字体</a></li>
                <li>
                    <a href="#%e5%90%af%e5%8a%a8%e5%99%a8%e5%92%8c%e8%8f%9c%e5%8d%95" aria-label="启动器和菜单">启动器和菜单</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%ae%89%e8%a3%85%e8%bf%90%e8%a1%8c%e5%8d%b8%e8%bd%bd-windows-%e7%a8%8b%e5%ba%8f" aria-label="安装/运行/卸载 Windows 程序">安装/运行/卸载 Windows 程序</a></li>
                <li>
                    <a href="#%e6%8a%80%e5%b7%a7" aria-label="技巧">技巧</a><ul>
                        
                <li>
                    <a href="#opengl-%e6%a8%a1%e5%bc%8f" aria-label="OpenGL 模式">OpenGL 模式</a></li>
                <li>
                    <a href="#wine-%e6%8e%a7%e5%88%b6%e5%8f%b0" aria-label="Wine 控制台">Wine 控制台</a></li>
                <li>
                    <a href="#winetrickshttpswikiwinehqorgwinetricks" aria-label="winetricks"><a href="https://wiki.winehq.org/Winetricks">winetricks</a></a></li>
                <li>
                    <a href="#monohttpswikiwinehqorgmono--geckohttpswikiwinehqorggecko" aria-label="Mono &amp;amp; Gecko"><a href="https://wiki.winehq.org/Mono">Mono</a> &amp; <a href="https://wiki.winehq.org/Gecko">Gecko</a></a></li></ul>
                </li>
                <li>
                    <a href="#crossoverhttpswwwcodeweaverscom" aria-label="CrossOver"><a href="https://www.codeweavers.com">CrossOver</a></a><ul>
                        
                <li>
                    <a href="#tutorialshttpswwwcodeweaverscomsupportwikilinuxlinuxtutorial" aria-label="Tutorials"><a href="https://www.codeweavers.com/support/wiki/linux/linuxtutorial">Tutorials</a></a></li>
                <li>
                    <a href="#dxvkhttpswwwcodeweaverscomsupportwikilinuxlinuxtutorialdxvk" aria-label="DXVK"><a href="https://www.codeweavers.com/support/wiki/linux/linuxtutorial/dxvk">DXVK</a></a></li>
                <li>
                    <a href="#esynchttpsgithubcomzfigurawineblobesyncreadmeesync" aria-label="Esync"><a href="https://github.com/zfigura/wine/blob/esync/README.esync">Esync</a></a><ul>
                        
                <li>
                    <a href="#howtoesynchttpsgithubcomlutrisdocsblobmasterhowtoesyncmd" aria-label="HowToEsync"><a href="https://github.com/lutris/docs/blob/master/HowToEsync.md">HowToEsync</a></a></li></ul>
                </li>
                <li>
                    <a href="#%e4%b8%ad%e6%96%87%e4%b9%b1%e7%a0%81httpsblogcsdnnetqq_35503971articledetails107296647" aria-label="中文乱码"><a href="https://blog.csdn.net/qq_35503971/article/details/107296647">中文乱码</a></a></li></ul>
                </li>
                <li>
                    <a href="#third-party-appshttpswikiarchlinuxorgtitlewinethird-party_applications" aria-label="Third-party apps"><a href="https://wiki.archlinux.org/title/wine#Third-party_applications">Third-party apps</a></a><ul>
                        
                <li>
                    <a href="#bottleshttpsusebottlescom" aria-label="Bottles"><a href="https://usebottles.com/">Bottles</a></a></li>
                <li>
                    <a href="#protonhttpsgithubcomvalvesoftwareproton" aria-label="Proton"><a href="https://github.com/ValveSoftware/Proton">Proton</a></a></li>
                <li>
                    <a href="#playonlinuxhttpswwwplayonlinuxcom" aria-label="PlayOnLinux"><a href="https://www.playonlinux.com/">PlayOnLinux</a></a></li>
                <li>
                    <a href="#lutrishttpslutrisnet" aria-label="Lutris"><a href="https://lutris.net/">Lutris</a></a></li></ul>
                </li>
                <li>
                    <a href="#%e5%ae%9e%e4%be%8b" aria-label="实例">实例</a><ul>
                        
                <li>
                    <a href="#cemuhttpsgithubcomleomaurodesenvcemu-linux" aria-label="Cemu"><a href="https://github.com/leomaurodesenv/cemu-linux">Cemu</a></a></li>
                <li>
                    <a href="#office-2013-prohttpsaskubuntucomquestions879304wine-2-0-says-it-supports-office-2013-how-do-i-actually-install-it" aria-label="Office 2013 Pro"><a href="https://askubuntu.com/questions/879304/wine-2-0-says-it-supports-office-2013-how-do-i-actually-install-it">Office 2013 Pro</a></a></li>
                <li>
                    <a href="#wechathttpswwwtechgrowcnpostsa1930361html" aria-label="WeChat"><a href="https://www.techgrow.cn/posts/a1930361.html">WeChat</a></a></li>
                <li>
                    <a href="#genshin-impact" aria-label="Genshin Impact">Genshin Impact</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#qemu-kvmhttpswikiarchlinuxorgtitleqemu_e7ae80e4bd93e4b8ade69687" aria-label="QEMU KVM"><a href="https://wiki.archlinux.org/title/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">QEMU KVM</a></a><ul>
                        
                <li>
                    <a href="#qemu-%e7%9a%84%e5%9b%be%e5%bd%a2%e5%89%8d%e7%ab%af" aria-label="QEMU 的图形前端">QEMU 的图形前端</a></li>
                <li>
                    <a href="#%e5%88%9b%e5%bb%ba%e6%96%b0%e8%99%9a%e6%8b%9f%e7%b3%bb%e7%bb%9f" aria-label="创建新虚拟系统">创建新虚拟系统</a><ul>
                        
                <li>
                    <a href="#%e5%88%9b%e5%bb%ba%e7%a1%ac%e7%9b%98%e9%95%9c%e5%83%8f" aria-label="创建硬盘镜像">创建硬盘镜像</a></li>
                <li>
                    <a href="#%e5%ae%89%e8%a3%85%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f" aria-label="安装操作系统">安装操作系统</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%bf%90%e8%a1%8c%e8%99%9a%e6%8b%9f%e5%8c%96%e7%9a%84%e7%b3%bb%e7%bb%9f" aria-label="运行虚拟化的系统">运行虚拟化的系统</a><ul>
                        
                <li>
                    <a href="#%e5%90%af%e7%94%a8-kvm" aria-label="启用 KVM">启用 KVM</a></li>
                <li>
                    <a href="#%e5%90%af%e7%94%a8-iommu-intel-vt-damd-vi-%e7%9a%84%e6%94%af%e6%8c%81" aria-label="启用 IOMMU (Intel VT-d/AMD-Vi) 的支持">启用 IOMMU (Intel VT-d/AMD-Vi) 的支持</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%ae%bf%e4%b8%bb%e6%9c%ba%e5%92%8c%e8%99%9a%e6%8b%9f%e6%9c%ba%e6%95%b0%e6%8d%ae%e4%ba%a4%e4%ba%92" aria-label="宿主机和虚拟机数据交互">宿主机和虚拟机数据交互</a><ul>
                        
                <li>
                    <a href="#%e7%bd%91%e7%bb%9c" aria-label="网络">网络</a></li>
                <li>
                    <a href="#qemu-%e7%ab%af%e5%8f%a3%e8%bd%ac%e5%8f%91" aria-label="QEMU 端口转发">QEMU 端口转发</a></li>
                <li>
                    <a href="#qemu-%e7%9a%84%e5%86%85%e7%bd%aesmb%e6%9c%8d%e5%8a%a1%e5%99%a8" aria-label="QEMU 的内置SMB服务器">QEMU 的内置SMB服务器</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%bd%91%e7%bb%9c-1" aria-label="网络">网络</a><ul>
                        
                <li>
                    <a href="#%e5%85%b3%e4%ba%8e%e9%93%be%e8%b7%af%e5%b1%82%e5%9c%b0%e5%9d%80%e7%9a%84%e9%99%90%e5%88%b6" aria-label="关于链路层地址的限制">关于链路层地址的限制</a></li>
                <li>
                    <a href="#%e7%94%a8%e6%88%b7%e6%a8%a1%e5%bc%8f" aria-label="用户模式">用户模式</a></li>
                <li>
                    <a href="#tap-%e7%bd%91%e7%bb%9c" aria-label="Tap 网络">Tap 网络</a></li>
                <li>
                    <a href="#%e9%80%9a%e8%bf%87-vde2-%e9%85%8d%e7%bd%ae%e7%bd%91%e7%bb%9c" aria-label="通过 VDE2 配置网络">通过 VDE2 配置网络</a></li>
                <li>
                    <a href="#vde2-%e7%bd%91%e6%a1%a5" aria-label="VDE2 网桥">VDE2 网桥</a></li>
                <li>
                    <a href="#%e7%ae%80%e5%8c%96%e9%85%8d%e7%bd%ae%e5%8f%82%e6%95%b0" aria-label="简化配置参数">简化配置参数</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%9b%be%e5%bd%a2" aria-label="图形">图形</a></li>
                <li>
                    <a href="#spice" aria-label="SPICE">SPICE</a></li>
                <li>
                    <a href="#vnc" aria-label="VNC">VNC</a></li>
                <li>
                    <a href="#%e9%9f%b3%e9%a2%91" aria-label="音频">音频</a><ul>
                        
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8%e9%9f%b3%e9%a2%91%e8%ae%be%e5%a4%87" aria-label="使用音频设备">使用音频设备</a></li>
                <li>
                    <a href="#%e6%97%a0%e9%9f%b3%e9%a2%91%e8%ae%be%e5%a4%87" aria-label="无音频设备">无音频设备</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%ae%89%e8%a3%85-virtio-%e9%a9%b1%e5%8a%a8" aria-label="安装 virtio 驱动">安装 virtio 驱动</a><ul>
                        
                <li>
                    <a href="#%e5%9d%97%e8%ae%be%e5%a4%87%e9%a9%b1%e5%8a%a8" aria-label="块设备驱动">块设备驱动</a></li>
                <li>
                    <a href="#%e7%bd%91%e7%bb%9c%e9%a9%b1%e5%8a%a8" aria-label="网络驱动">网络驱动</a></li>
                <li>
                    <a href="#balloon-%e9%a9%b1%e5%8a%a8" aria-label="Balloon 驱动">Balloon 驱动</a></li></ul>
                </li>
                <li>
                    <a href="#qemu-%e7%9b%91%e8%a7%86%e5%99%a8" aria-label="QEMU 监视器">QEMU 监视器</a><ul>
                        
                <li>
                    <a href="#%e8%ae%bf%e9%97%aeqemu%e7%9b%91%e8%a7%86%e5%99%a8console" aria-label="访问QEMU监视器Console">访问QEMU监视器Console</a></li>
                <li>
                    <a href="#%e5%9c%a8monitor-conosle%e4%b8%8b%e5%90%91%e8%99%9a%e6%8b%9f%e6%9c%ba%e5%8f%91%e9%80%81%e6%8c%89%e9%94%ae%e8%a1%8c%e4%b8%ba" aria-label="在Monitor conosle下向虚拟机发送按键行为">在Monitor conosle下向虚拟机发送按键行为</a></li>
                <li>
                    <a href="#%e9%80%9a%e8%bf%87-monitor-console-%e5%88%9b%e5%bb%ba%e5%bf%ab%e7%85%a7%e5%92%8c%e7%ae%a1%e7%90%86%e5%bf%ab%e7%85%a7" aria-label="通过 monitor console 创建快照和管理快照">通过 monitor console 创建快照和管理快照</a></li>
                <li>
                    <a href="#%e4%bb%a5%e5%86%bb%e7%bb%93%e6%a8%a1%e5%bc%8f%e8%bf%90%e8%a1%8c%e8%99%9a%e6%8b%9f%e6%9c%ba" aria-label="以冻结模式运行虚拟机">以冻结模式运行虚拟机</a></li>
                <li>
                    <a href="#monitor-console%e4%b8%ad%e7%9a%84%e5%bc%80%e6%9c%ba%e5%92%8c%e6%9a%82%e5%81%9c%e5%91%bd%e4%bb%a4" aria-label="monitor console中的开机和暂停命令">monitor console中的开机和暂停命令</a></li>
                <li>
                    <a href="#%e8%99%9a%e6%8b%9f%e6%9c%ba%e6%88%aa%e5%b1%8f" aria-label="虚拟机截屏">虚拟机截屏</a></li></ul>
                </li>
                <li>
                    <a href="#qemu-%e6%9c%ba%e5%99%a8%e5%8d%8f%e8%ae%ae" aria-label="QEMU 机器协议">QEMU 机器协议</a></li>
                <li>
                    <a href="#%e6%8a%80%e5%b7%a7-1" aria-label="技巧">技巧</a><ul>
                        
                <li>
                    <a href="#%e6%94%b9%e5%96%84%e8%99%9a%e6%8b%9f%e6%9c%ba%e7%9a%84%e6%80%a7%e8%83%bd%e8%a1%a8%e7%8e%b0" aria-label="改善虚拟机的性能表现">改善虚拟机的性能表现</a></li>
                <li>
                    <a href="#%e5%bc%80%e6%9c%ba%e6%97%b6%e5%90%af%e5%8a%a8qemu%e8%99%9a%e6%8b%9f%e6%9c%ba" aria-label="开机时启动QEMU虚拟机">开机时启动QEMU虚拟机</a></li>
                <li>
                    <a href="#%e9%bc%a0%e6%a0%87%e6%95%b4%e5%90%88" aria-label="鼠标整合">鼠标整合</a></li>
                <li>
                    <a href="#%e5%ae%bf%e4%b8%bb%e6%9c%ba%e7%9a%84usb%e8%ae%be%e5%a4%87%e4%bc%a0%e9%80%92%e8%87%b3%e8%99%9a%e6%8b%9f%e6%9c%ba" aria-label="宿主机的USB设备传递至虚拟机">宿主机的USB设备传递至虚拟机</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8spice%e8%bf%9b%e8%a1%8cusb%e9%87%8d%e5%ae%9a%e5%90%91" aria-label="使用SPICE进行USB重定向">使用SPICE进行USB重定向</a></li>
                <li>
                    <a href="#%e5%bc%80%e5%90%afksm" aria-label="开启KSM">开启KSM</a></li>
                <li>
                    <a href="#%e5%a4%9a%e5%b1%8f%e6%94%af%e6%8c%81" aria-label="多屏支持">多屏支持</a></li>
                <li>
                    <a href="#%e5%a4%8d%e5%88%b6%e5%92%8c%e7%b2%98%e8%b4%b4" aria-label="复制和粘贴">复制和粘贴</a></li></ul>
                </li>
                <li>
                    <a href="#libvirthttpswikiarchlinuxorgtitlelibvirt_e7ae80e4bd93e4b8ade69687" aria-label="libvirt"><a href="https://wiki.archlinux.org/title/Libvirt_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">libvirt</a></a><ul>
                        
                <li>
                    <a href="#%e5%ae%89%e8%a3%85httpsubuntucomserverdocsvirtualization-libvirt" aria-label="安装"><a href="https://ubuntu.com/server/docs/virtualization-libvirt">安装</a></a></li>
                <li>
                    <a href="#%e9%85%8d%e7%bd%ae-1" aria-label="配置">配置</a><ul>
                        
                <li>
                    <a href="#%e8%ae%be%e7%bd%ae%e6%8e%88%e6%9d%83" aria-label="设置授权">设置授权</a></li>
                <li>
                    <a href="#%e5%ae%88%e6%8a%a4%e8%bf%9b%e7%a8%8b" aria-label="守护进程">守护进程</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%b5%8b%e8%af%95" aria-label="测试">测试</a></li>
                <li>
                    <a href="#%e7%ae%a1%e7%90%86" aria-label="管理">管理</a><ul>
                        
                <li>
                    <a href="#virsh" aria-label="virsh">virsh</a></li>
                <li>
                    <a href="#%e5%ad%98%e5%82%a8%e6%b1%a0" aria-label="存储池">存储池</a></li>
                <li>
                    <a href="#%e5%ad%98%e5%82%a8%e5%8d%b7" aria-label="存储卷">存储卷</a></li>
                <li>
                    <a href="#%e5%9f%9f" aria-label="域">域</a></li>
                <li>
                    <a href="#%e7%bd%91%e7%bb%9c-2" aria-label="网络">网络</a></li></ul>
                </li>
                <li>
                    <a href="#uefi-%e6%94%af%e6%8c%81" aria-label="UEFI 支持">UEFI 支持</a></li></ul>
                </li>
                <li>
                    <a href="#qemu-kvm-win7httpswwwcnblogscomsammyliup5740129html" aria-label="QEMU-KVM Win7"><a href="https://www.cnblogs.com/sammyliu/p/5740129.html">QEMU-KVM Win7</a></a><ul>
                        
                <li>
                    <a href="#%e7%8e%af%e5%a2%83%e5%87%86%e5%a4%87" aria-label="环境准备">环境准备</a></li>
                <li>
                    <a href="#%e5%ae%89%e8%a3%85-win-7" aria-label="安装 Win 7">安装 Win 7</a></li>
                <li>
                    <a href="#%e5%ae%89%e8%a3%85-virtio-%e7%bd%91%e7%bb%9c%e9%a9%b1%e5%8a%a8" aria-label="安装 Virtio 网络驱动">安装 Virtio 网络驱动</a></li>
                <li>
                    <a href="#qemu-%e7%9a%84%e5%86%85%e7%bd%aesmb%e6%9c%8d%e5%8a%a1%e5%99%a8qemu-%e7%9a%84%e5%86%85%e7%bd%aesmb%e6%9c%8d%e5%8a%a1%e5%99%a8" aria-label="[QEMU 的内置SMB服务器](#QEMU 的内置SMB服务器)">[QEMU 的内置SMB服务器](#QEMU 的内置SMB服务器)</a></li>
                <li>
                    <a href="#%e5%ae%bf%e4%b8%bb%e6%9c%ba%e7%9a%84usb%e8%ae%be%e5%a4%87%e4%bc%a0%e9%80%92%e8%87%b3%e8%99%9a%e6%8b%9f%e6%9c%ba%e5%ae%bf%e4%b8%bb%e6%9c%ba%e7%9a%84usb%e8%ae%be%e5%a4%87%e4%bc%a0%e9%80%92%e8%87%b3%e8%99%9a%e6%8b%9f%e6%9c%ba" aria-label="宿主机的USB设备传递至虚拟机"><a href="#%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%9A%84USB%E8%AE%BE%E5%A4%87%E4%BC%A0%E9%80%92%E8%87%B3%E8%99%9A%E6%8B%9F%E6%9C%BA">宿主机的USB设备传递至虚拟机</a></a></li></ul>
                </li>
                <li>
                    <a href="#qemu-kvm-winxp-sp3" aria-label="QEMU-KVM WinXP SP3">QEMU-KVM WinXP SP3</a><ul>
                        
                <li>
                    <a href="#windows_xpshhttpsgistgithubcomandrusha1000766" aria-label="windows_xp.sh"><a href="https://gist.github.com/andrusha/1000766">windows_xp.sh</a></a><ul>
                        
                <li>
                    <a href="#windows-xp-cannot-connect-to-samba-sharehttpsaskubuntucomquestions1268132windows-xp-cannot-connect-to-samba-share-linux-server-20-04" aria-label="Windows XP cannot connect to samba share"><a href="https://askubuntu.com/questions/1268132/windows-xp-cannot-connect-to-samba-share-linux-server-20-04">Windows XP cannot connect to samba share</a></a></li>
                <li>
                    <a href="#windows-xp-%e4%b8%8a%e7%bd%91%e6%8f%90%e7%a4%ba%e6%82%a8%e7%9a%84%e6%97%b6%e9%92%9f%e5%bf%ab%e4%ba%86%e6%85%a2%e4%ba%86httpsblogcsdnnetjohnnysun2015articledetails104888159" aria-label="Windows XP 上网提示：您的时钟快了/慢了"><a href="https://blog.csdn.net/JohnnySun2015/article/details/104888159">Windows XP 上网提示：您的时钟快了/慢了</a></a></li></ul>
                </li>
                <li>
                    <a href="#virtual-machine-manager" aria-label="Virtual Machine Manager">Virtual Machine Manager</a></li></ul>
                </li>
                <li>
                    <a href="#qemu-kvm-gentoohttpswikigentooorgwikiqemulinux_guest" aria-label="QEMU-KVM Gentoo"><a href="https://wiki.gentoo.org/wiki/QEMU/Linux_guest">QEMU-KVM Gentoo</a></a><ul>
                        
                <li>
                    <a href="#configuration" aria-label="Configuration">Configuration</a><ul>
                        
                <li>
                    <a href="#host" aria-label="Host">Host</a></li>
                <li>
                    <a href="#using-uefi-with-qemuhttpsfedoraprojectorgwikiusing_uefi_with_qemu" aria-label="Using UEFI with QEMU"><a href="https://fedoraproject.org/wiki/Using_UEFI_with_QEMU">Using UEFI with QEMU</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#others" aria-label="Others">Others</a><ul>
                        
                <li>
                    <a href="#%e9%80%9a%e8%bf%87-qemu-%e5%ae%89%e8%a3%85-windows-%e5%88%b0%e7%a1%ac%e7%9b%98" aria-label="通过 Qemu 安装 Windows 到硬盘">通过 Qemu 安装 Windows 到硬盘</a></li>
                <li>
                    <a href="#looking-glasshttpslooking-glassiodocs" aria-label="Looking Glass"><a href="https://looking-glass.io/docs">Looking Glass</a></a></li>
                <li>
                    <a href="#xrdphttpsgithubcomneutrinolabsxrdp" aria-label="xrdp"><a href="https://github.com/neutrinolabs/xrdp">xrdp</a></a></li>
                <li>
                    <a href="#qemukvm-vs-virtualbox" aria-label="QEMU/KVM VS Virtualbox">QEMU/KVM VS Virtualbox</a></li>
                <li>
                    <a href="#virtualbox" aria-label="VirtualBox">VirtualBox</a><ul>
                        
                <li>
                    <a href="#%e5%a2%9e%e5%8a%a0%e7%8e%b0%e6%9c%89%e8%99%9a%e6%8b%9f%e6%9c%ba%e7%9a%84%e7%a3%81%e7%9b%98%e5%a4%a7%e5%b0%8fhttpslinuxcnarticle-12869-1html" aria-label="增加现有虚拟机的磁盘大小"><a href="https://linux.cn/article-12869-1.html">增加现有虚拟机的磁盘大小</a></a></li>
                <li>
                    <a href="#seamless-modehttpswwwtl80cnarticle43389" aria-label="Seamless Mode"><a href="https://www.tl80.cn/article/43389">Seamless Mode</a></a></li>
                <li>
                    <a href="#vboxwinxp-sp3" aria-label="VBox&#43;WinXP SP3">VBox+WinXP SP3</a></li>
                <li>
                    <a href="#vs-vmwarehttpswwwzhihucomquestion33701295" aria-label="vs VMWare"><a href="https://www.zhihu.com/question/33701295">vs VMWare</a></a></li>
                <li>
                    <a href="#%e8%99%9a%e6%8b%9f%e6%9c%ba%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%bc%8fhttpswwwcnblogscomggjuchengarchive201208192646007html" aria-label="虚拟机网络模式"><a href="https://www.cnblogs.com/ggjucheng/archive/2012/08/19/2646007.html">虚拟机网络模式</a></a></li></ul>
                </li>
                <li>
                    <a href="#podmanhttpsgithubcomcontainerspodman" aria-label="podman"><a href="https://github.com/containers/podman">podman</a></a></li>
                <li>
                    <a href="#android-x86httpslinuxcnarticle-11711-1html" aria-label="Android-x86"><a href="https://linux.cn/article-11711-1.html">Android-x86</a></a></li>
                <li>
                    <a href="#anboxhttpslinuxcnarticle-10843-1html" aria-label="Anbox"><a href="https://linux.cn/article-10843-1.html">Anbox</a></a><ul>
                        
                <li>
                    <a href="#anbox-%e7%ae%80%e4%bb%8b" aria-label="Anbox 简介">Anbox 简介</a></li>
                <li>
                    <a href="#%e5%ae%89%e8%a3%85%e4%bd%bf%e7%94%a8" aria-label="安装使用">安装使用</a></li></ul>
                </li>
                <li>
                    <a href="#waydroidhttpswaydroid" aria-label="Waydroid"><a href="https://waydro.id/">Waydroid</a></a></li>
                <li>
                    <a href="#genymotionhttpswwwgenymotioncom" aria-label="Genymotion"><a href="https://www.genymotion.com/">Genymotion</a></a></li>
                <li>
                    <a href="#looking-glasshttpslooking-glassio" aria-label="Looking Glass"><a href="https://looking-glass.io/">Looking Glass</a></a></li>
                <li>
                    <a href="#libvfiohttpsarccomputecombloglibvfio-commodity-gpu-multiplexing" aria-label="LibVF.IO"><a href="https://arccompute.com/blog/libvfio-commodity-gpu-multiplexing/">LibVF.IO</a></a></li>
                <li>
                    <a href="#-osx-kvmhttpsgithubcomkholiaosx-kvmmacos-simple-kvmhttpsgithubcomfoxletmacos-simple-kvm" aria-label="OSX-KVM/macOS-Simple-KVM"><a href="https://github.com/kholia/OSX-KVM"> OSX-KVM</a>/<a href="https://github.com/foxlet/macOS-Simple-KVM">macOS-Simple-KVM</a></a></li>
                <li>
                    <a href="#quickemuhttpsgithubcomquickemu-projectquickemu" aria-label="quickemu"><a href="https://github.com/quickemu-project/quickemu">quickemu</a></a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#package-management" aria-label="Package Management">Package Management</a><ul>
                        
                <li>
                    <a href="#dpkg" aria-label="dpkg">dpkg</a><ul>
                        
                <li>
                    <a href="#%e7%ae%a1%e7%90%86%e8%bd%af%e4%bb%b6%e5%8c%85httpslinuxcnarticle-7953-1html" aria-label="管理软件包"><a href="https://linux.cn/article-7953-1.html">管理软件包</a></a><ul>
                        
                <li>
                    <a href="#%e5%b8%b8%e8%a7%81%e5%91%bd%e4%bb%a4%e5%8f%8a%e6%96%87%e4%bb%b6%e4%bd%8d%e7%bd%ae" aria-label="常见命令及文件位置">常见命令及文件位置</a></li>
                <li>
                    <a href="#%e5%ae%89%e8%a3%85%e5%8d%87%e7%ba%a7%e8%bd%af%e4%bb%b6" aria-label="安装/升级软件">安装/升级软件</a></li>
                <li>
                    <a href="#%e4%bb%8e%e6%96%87%e4%bb%b6%e5%a4%b9%e9%87%8c%e5%ae%89%e8%a3%85%e8%bd%af%e4%bb%b6" aria-label="从文件夹里安装软件">从文件夹里安装软件</a></li>
                <li>
                    <a href="#%e6%98%be%e7%a4%ba%e5%b7%b2%e5%ae%89%e8%a3%85%e8%bd%af%e4%bb%b6%e5%88%97%e8%a1%a8" aria-label="显示已安装软件列表">显示已安装软件列表</a></li>
                <li>
                    <a href="#%e6%9f%a5%e7%9c%8b%e6%8c%87%e5%ae%9a%e7%9a%84%e5%b7%b2%e5%ae%89%e8%a3%85%e8%bd%af%e4%bb%b6" aria-label="查看指定的已安装软件">查看指定的已安装软件</a></li>
                <li>
                    <a href="#%e6%9f%a5%e7%9c%8b%e8%bd%af%e4%bb%b6%e5%ae%89%e8%a3%85%e7%9b%ae%e5%bd%95" aria-label="查看软件安装目录">查看软件安装目录</a></li>
                <li>
                    <a href="#%e6%9f%a5%e7%9c%8b-deb-%e5%8c%85%e5%86%85%e5%ae%b9" aria-label="查看 deb 包内容">查看 deb 包内容</a></li>
                <li>
                    <a href="#%e6%98%be%e7%a4%ba%e8%bd%af%e4%bb%b6%e7%9a%84%e8%af%a6%e7%bb%86%e4%bf%a1%e6%81%af" aria-label="显示软件的详细信息">显示软件的详细信息</a></li>
                <li>
                    <a href="#%e6%9f%a5%e7%9c%8b%e6%96%87%e4%bb%b6%e5%b1%9e%e4%ba%8e%e5%93%aa%e4%b8%aa%e8%bd%af%e4%bb%b6" aria-label="查看文件属于哪个软件">查看文件属于哪个软件</a></li>
                <li>
                    <a href="#%e7%a7%bb%e9%99%a4%e5%88%a0%e9%99%a4%e8%bd%af%e4%bb%b6" aria-label="移除/删除软件">移除/删除软件</a></li>
                <li>
                    <a href="#%e6%b8%85%e9%99%a4%e8%bd%af%e4%bb%b6" aria-label="清除软件">清除软件</a></li></ul>
                </li>
                <li>
                    <a href="#debian-%e6%89%93%e5%8c%85%e5%85%a5%e9%97%a8httpslinuxcnarticle-9878-1html" aria-label="Debian 打包入门"><a href="https://linux.cn/article-9878-1.html">Debian 打包入门</a></a><ul>
                        
                <li>
                    <a href="#build-essentialhttpslinuxcnarticle-13953-1html" aria-label="build-essential"><a href="https://linux.cn/article-13953-1.html">build-essential</a></a></li></ul>
                </li>
                <li>
                    <a href="#package-converter" aria-label="Package converter">Package converter</a></li></ul>
                </li>
                <li>
                    <a href="#apt" aria-label="APT">APT</a><ul>
                        
                <li>
                    <a href="#%e5%88%97%e5%87%ba%e6%89%80%e6%9c%89%e6%89%8b%e5%8a%a8%e5%ae%89%e8%a3%85%e8%bd%af%e4%bb%b6" aria-label="列出所有手动安装软件">列出所有手动安装软件</a></li>
                <li>
                    <a href="#%e6%9f%a5%e7%9c%8b%e8%bd%af%e4%bb%b6%e5%8c%85%e4%be%9d%e8%b5%96" aria-label="查看软件包依赖">查看软件包依赖</a></li>
                <li>
                    <a href="#repository-mirror" aria-label="Repository Mirror">Repository Mirror</a></li>
                <li>
                    <a href="#apt-fasthttpsvituxcomhow-to-speed-up-package-downloads-and-updates-with-apt-fast-on-ubuntu" aria-label="apt-fast"><a href="https://vitux.com/how-to-speed-up-package-downloads-and-updates-with-apt-fast-on-ubuntu/">apt-fast</a></a></li>
                <li>
                    <a href="#apt-aria2httplinuxundertheskyblogspotcom201109accelerate-download-of-apt-get-viahtml" aria-label="apt-aria2"><a href="http://linuxunderthesky.blogspot.com/2011/09/accelerate-download-of-apt-get-via.html">apt-aria2</a></a></li></ul>
                </li>
                <li>
                    <a href="#ppahttpslinuxcnarticle-10456-1html" aria-label="PPA"><a href="https://linux.cn/article-10456-1.html">PPA</a></a></li>
                <li>
                    <a href="#snap--flatpak" aria-label="Snap &amp;amp; Flatpak">Snap &amp; Flatpak</a><ul>
                        
                <li>
                    <a href="#%e8%ae%a8%e8%ae%ba" aria-label="讨论">讨论</a></li>
                <li>
                    <a href="#%e5%9c%a8-ubuntu-%e4%b8%8a%e4%bd%bf%e7%94%a8-flatpakhttpsflatpakorgsetupubuntu" aria-label="在 Ubuntu 上使用 Flatpak"><a href="https://flatpak.org/setup/Ubuntu/">在 Ubuntu 上使用 Flatpak</a></a></li>
                <li>
                    <a href="#questions" aria-label="Questions">Questions</a></li></ul>
                </li>
                <li>
                    <a href="#tasksel-install-group-softwarehttpswwwcybercitibizfaqtasksel-install-group-software-in-command-line" aria-label="tasksel: Install Group Software"><a href="https://www.cyberciti.biz/faq/tasksel-install-group-software-in-command-line/">tasksel: Install Group Software</a></a></li>
                <li>
                    <a href="#pacstallhttpsgithubcompacstallpacstall" aria-label="pacstall"><a href="https://github.com/pacstall/pacstall">pacstall</a></a></li>
                <li>
                    <a href="#appimagehttpsappimageorg" aria-label="AppImage"><a href="https://appimage.org/">AppImage</a></a></li>
                <li>
                    <a href="#%e5%8c%85%e7%ae%a1%e7%90%86%e5%99%a8%e7%9a%84%e8%bf%9b%e5%8c%96httpslinuxcnarticle-9931-1html" aria-label="包管理器的进化"><a href="https://linux.cn/article-9931-1.html">包管理器的进化</a></a><ul>
                        
                <li>
                    <a href="#%e6%89%8b%e5%8a%a8%e5%ae%89%e8%a3%85%e8%bd%af%e4%bb%b6" aria-label="手动安装软件">手动安装软件</a></li>
                <li>
                    <a href="#%e8%bd%af%e4%bb%b6%e5%8c%85" aria-label="软件包">软件包</a></li>
                <li>
                    <a href="#%e8%bd%af%e4%bb%b6%e4%bb%93%e5%ba%93" aria-label="软件仓库">软件仓库</a></li>
                <li>
                    <a href="#%e5%8c%85%e7%ae%a1%e7%90%86%e5%99%a8" aria-label="包管理器">包管理器</a><ul>
                        
                <li>
                    <a href="#%e5%9f%ba%e4%ba%8e-prm-%e5%8c%85%e6%a0%bc%e5%bc%8f%e7%9a%84%e5%8c%85%e7%ae%a1%e7%90%86%e5%99%a8" aria-label="基于 PRM 包格式的包管理器">基于 PRM 包格式的包管理器</a></li>
                <li>
                    <a href="#%e5%9f%ba%e4%ba%8e-debian-%e7%9a%84%e5%8c%85%e7%ae%a1%e7%90%86%e5%99%a8" aria-label="基于 Debian 的包管理器">基于 Debian 的包管理器</a></li>
                <li>
                    <a href="#%e5%9f%ba%e4%ba%8e-arch-%e7%9a%84%e5%8c%85%e7%ae%a1%e7%90%86%e5%99%a8" aria-label="基于 Arch 的包管理器">基于 Arch 的包管理器</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#condahttpswwwjianshucompedaa744ea47d" aria-label="conda"><a href="https://www.jianshu.com/p/edaa744ea47d">conda</a></a><ul>
                        
                <li>
                    <a href="#%e7%ae%80%e4%bb%8b" aria-label="简介">简介</a></li>
                <li>
                    <a href="#%e5%ae%89%e8%a3%85" aria-label="安装">安装</a></li>
                <li>
                    <a href="#%e6%b7%bb%e5%8a%a0%e9%a2%91%e9%81%93" aria-label="添加频道">添加频道</a></li>
                <li>
                    <a href="#%e8%bd%af%e4%bb%b6%e5%8c%85%e7%ae%a1%e7%90%86" aria-label="软件包管理">软件包管理</a><ul>
                        
                <li>
                    <a href="#%e6%90%9c%e7%b4%a2%e5%ae%89%e8%a3%85%e5%8c%85" aria-label="搜索安装包">搜索安装包</a></li>
                <li>
                    <a href="#%e5%ae%89%e8%a3%85%e7%89%b9%e5%ae%9a%e7%89%88%e6%9c%ac" aria-label="安装特定版本">安装特定版本</a></li>
                <li>
                    <a href="#%e6%9f%a5%e7%9c%8b%e5%b7%b2%e5%ae%89%e8%a3%85%e8%bd%af%e4%bb%b6" aria-label="查看已安装软件">查看已安装软件</a></li>
                <li>
                    <a href="#%e6%9b%b4%e6%96%b0%e6%8c%87%e5%ae%9a%e8%bd%af%e4%bb%b6" aria-label="更新指定软件">更新指定软件</a></li>
                <li>
                    <a href="#%e5%8d%b8%e8%bd%bd%e6%8c%87%e5%ae%9a%e8%bd%af%e4%bb%b6" aria-label="卸载指定软件">卸载指定软件</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%8e%af%e5%a2%83%e7%ae%a1%e7%90%86" aria-label="环境管理">环境管理</a><ul>
                        
                <li>
                    <a href="#%e9%80%80%e5%87%baconda%e7%8e%af%e5%a2%83" aria-label="退出conda环境">退出conda环境</a></li>
                <li>
                    <a href="#%e5%88%9b%e5%bb%baconda%e7%8e%af%e5%a2%83" aria-label="创建conda环境">创建conda环境</a></li>
                <li>
                    <a href="#%e5%88%a0%e9%99%a4%e7%8e%af%e5%a2%83" aria-label="删除环境">删除环境</a></li>
                <li>
                    <a href="#%e9%87%8d%e5%91%bd%e5%90%8d%e7%8e%af%e5%a2%83" aria-label="重命名环境">重命名环境</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e8%87%aa%e5%8a%a8%e6%9b%b4%e6%96%b0httpswwwcnblogscomsparkdevp11376560html" aria-label="自动更新"><a href="https://www.cnblogs.com/sparkdev/p/11376560.html">自动更新</a></a><ul>
                        
                <li>
                    <a href="#%e6%9b%b4%e6%96%b0%e6%9c%ba%e5%88%b6" aria-label="更新机制">更新机制</a></li>
                <li>
                    <a href="#aptsystemddaily" aria-label="apt.systemd.daily">apt.systemd.daily</a></li>
                <li>
                    <a href="#unattended-upgrades" aria-label="unattended-upgrades">unattended-upgrades</a></li>
                <li>
                    <a href="#%e5%85%b3%e9%97%ad%e8%87%aa%e5%8a%a8%e6%9b%b4%e6%96%b0" aria-label="关闭自动更新">关闭自动更新</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f" aria-label="文件系统">文件系统</a><ul>
                        
                <li>
                    <a href="#fstabhttpswwwcnblogscomfenggeblogp10178824html" aria-label="fstab"><a href="https://www.cnblogs.com/FengGeBlog/p/10178824.html">fstab</a></a><ul>
                        
                <li>
                    <a href="#uuid-of-storage-deviceshttpslinuxhintcomuuid_storage_devices_linux" aria-label="UUID of Storage Devices"><a href="https://linuxhint.com/uuid_storage_devices_linux/">UUID of Storage Devices</a></a></li></ul>
                </li>
                <li>
                    <a href="#lvmhttpswwwcnblogscomsparkdevp10130934html" aria-label="LVM"><a href="https://www.cnblogs.com/sparkdev/p/10130934.html">LVM</a></a><ul>
                        
                <li>
                    <a href="#lvm-%e6%98%af%e4%bb%80%e4%b9%88" aria-label="LVM 是什么">LVM 是什么</a></li>
                <li>
                    <a href="#lvm-%e4%b8%ad%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5" aria-label="LVM 中的基本概念">LVM 中的基本概念</a></li>
                <li>
                    <a href="#lvm-%e5%b7%a5%e5%85%b7" aria-label="LVM 工具">LVM 工具</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8-gdisk-%e5%af%b9%e7%89%a9%e7%90%86%e7%a3%81%e7%9b%98%e8%bf%9b%e8%a1%8c%e5%88%86%e5%8c%ba" aria-label="使用 gdisk 对物理磁盘进行分区">使用 gdisk 对物理磁盘进行分区</a></li>
                <li>
                    <a href="#%e5%88%9b%e5%bb%ba%e7%89%a9%e7%90%86%e5%8d%b7-pv" aria-label="创建物理卷 PV">创建物理卷 PV</a></li>
                <li>
                    <a href="#%e5%88%9b%e5%bb%ba%e5%8d%b7%e7%bb%84-vg" aria-label="创建卷组 VG">创建卷组 VG</a></li>
                <li>
                    <a href="#%e5%88%9b%e5%bb%ba%e9%80%bb%e8%be%91%e5%8d%b7-lv" aria-label="创建逻辑卷 LV">创建逻辑卷 LV</a></li>
                <li>
                    <a href="#%e6%a0%bc%e5%bc%8f%e5%8c%96%e9%80%bb%e8%be%91%e5%8d%b7%e5%88%9b%e5%bb%ba%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f" aria-label="格式化逻辑卷(创建文件系统)">格式化逻辑卷(创建文件系统)</a></li>
                <li>
                    <a href="#%e5%bc%80%e6%9c%ba%e8%87%aa%e5%8a%a8%e6%8c%82%e8%bd%bd" aria-label="开机自动挂载">开机自动挂载</a></li>
                <li>
                    <a href="#%e8%b0%83%e6%95%b4%e9%80%bb%e8%be%91%e5%8d%b7httpswikiarchlinuxorgtitlelvm_e7ae80e4bd93e4b8ade69687e980bbe8be91e58db7" aria-label="调整逻辑卷"><a href="https://wiki.archlinux.org/title/LVM_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E9%80%BB%E8%BE%91%E5%8D%B7">调整逻辑卷</a></a></li>
                <li>
                    <a href="#%e9%87%8d%e5%91%bd%e5%90%8d%e5%8d%b7" aria-label="重命名卷">重命名卷</a></li>
                <li>
                    <a href="#%e7%a7%bb%e9%99%a4%e9%80%bb%e8%be%91%e5%8d%b7" aria-label="移除逻辑卷">移除逻辑卷</a></li>
                <li>
                    <a href="#lvm-%e5%bf%ab%e7%85%a7httpswwwcnblogscomsparkdevp10232567html" aria-label="LVM 快照"><a href="https://www.cnblogs.com/sparkdev/p/10232567.html">LVM 快照</a></a></li></ul>
                </li>
                <li>
                    <a href="#zfshttpslinuxcnarticle-10034-1html" aria-label="ZFS"><a href="https://linux.cn/article-10034-1.html">ZFS</a></a><ul>
                        
                <li>
                    <a href="#%e5%8e%86%e5%8f%b2" aria-label="历史">历史</a></li>
                <li>
                    <a href="#%e7%89%b9%e6%80%a7httpslinuxcnarticle-7422-1html" aria-label="特性"><a href="https://linux.cn/article-7422-1.html">特性</a></a><ul>
                        
                <li>
                    <a href="#%e5%ad%98%e5%82%a8%e6%b1%a0-1" aria-label="存储池">存储池</a></li>
                <li>
                    <a href="#%e5%86%99%e6%97%b6%e6%8b%b7%e8%b4%9d" aria-label="写时拷贝">写时拷贝</a></li>
                <li>
                    <a href="#%e5%bf%ab%e7%85%a7" aria-label="快照">快照</a></li>
                <li>
                    <a href="#%e6%95%b0%e6%8d%ae%e5%ae%8c%e6%95%b4%e6%80%a7%e9%aa%8c%e8%af%81%e5%92%8c%e8%87%aa%e5%8a%a8%e4%bf%ae%e5%a4%8d" aria-label="数据完整性验证和自动修复">数据完整性验证和自动修复</a></li>
                <li>
                    <a href="#raid-z" aria-label="RAID-Z">RAID-Z</a></li>
                <li>
                    <a href="#%e5%b7%a8%e5%a4%a7%e7%9a%84%e5%ad%98%e5%82%a8%e6%bd%9c%e5%8a%9b" aria-label="巨大的存储潜力">巨大的存储潜力</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e5%ae%89%e8%a3%85-zfs" aria-label="如何安装 ZFS？">如何安装 ZFS？</a></li>
                <li>
                    <a href="#%e5%9c%a8-ubuntu-%e4%b8%8a%e4%bd%bf%e7%94%a8-zfshttpslinuxcnarticle-9346-1html" aria-label="在 Ubuntu 上使用 ZFS"><a href="https://linux.cn/article-9346-1.html">在 Ubuntu 上使用 ZFS</a></a><ul>
                        
                <li>
                    <a href="#%e5%88%9b%e5%bb%ba%e6%b1%a0" aria-label="创建池">创建池</a></li>
                <li>
                    <a href="#%e6%b1%a0%e7%9a%84%e6%93%8d%e4%bd%9c" aria-label="池的操作">池的操作</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%ae%9e%e4%be%8b-1" aria-label="实例">实例</a></li></ul>
                </li>
                <li>
                    <a href="#udevhttpswwwjianshucompf9385d5703a7" aria-label="udev"><a href="https://www.jianshu.com/p/f9385d5703a7">udev</a></a><ul>
                        
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%bf%e7%94%a8udev" aria-label="为什么使用udev">为什么使用udev</a></li>
                <li>
                    <a href="#udev%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6" aria-label="udev配置文件">udev配置文件</a></li>
                <li>
                    <a href="#%e4%bf%ae%e6%94%b9%e4%bd%a0%e7%9a%84udev%e9%85%8d%e7%bd%ae" aria-label="修改你的udev配置">修改你的udev配置</a></li>
                <li>
                    <a href="#mounting-usb-automatically--having-usbs-label-as-mountpointhttpsunixstackexchangecomquestions119973mounting-usb-automatically-having-usbs-label-as-mountpoint" aria-label="Mounting usb automatically &amp;amp; having usb&amp;rsquo;s label as mountpoint"><a href="https://unix.stackexchange.com/questions/119973/mounting-usb-automatically-having-usbs-label-as-mountpoint">Mounting usb automatically &amp; having usb&rsquo;s label as mountpoint</a></a><ul>
                        
                <li>
                    <a href="#udev-references" aria-label="UDEV references">UDEV references</a></li>
                <li>
                    <a href="#background-udev-whuzzat" aria-label="Background (UDEV? Whuzzat?)">Background (UDEV? Whuzzat?)</a></li>
                <li>
                    <a href="#udev-rules" aria-label="Udev Rules">Udev Rules</a></li>
                <li>
                    <a href="#script-actually-2-scripts" aria-label="Script! Actually, 2 Scripts&amp;hellip;">Script! Actually, 2 Scripts&hellip;</a></li>
                <li>
                    <a href="#super-bonus-cleanup-script" aria-label="Super Bonus Cleanup Script!">Super Bonus Cleanup Script!</a></li></ul>
                </li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#systemd" aria-label="Systemd">Systemd</a><ul>
                        
                <li>
                    <a href="#linux-pid-1-%e5%92%8c-systemdhttpscoolshellcnarticles17998htmlsysv_init" aria-label="LINUX PID 1 和 SYSTEMD"><a href="https://coolshell.cn/articles/17998.html#SysV_Init">LINUX PID 1 和 SYSTEMD</a></a><ul>
                        
                <li>
                    <a href="#sysv-init" aria-label="SysV Init">SysV Init</a></li>
                <li>
                    <a href="#upstart" aria-label="UpStart">UpStart</a></li>
                <li>
                    <a href="#systemd-1" aria-label="Systemd">Systemd</a></li>
                <li>
                    <a href="#systemd-%e4%ba%89%e8%ae%ba%e5%92%8c%e5%85%ab%e5%8d%a6" aria-label="Systemd 争论和八卦">Systemd 争论和八卦</a></li>
                <li>
                    <a href="#%e5%85%b6%e5%ae%83" aria-label="其它">其它</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%91%bd%e4%bb%a4httpswwwruanyifengcomblog201603systemd-tutorial-commandshtml" aria-label="命令"><a href="https://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html">命令</a></a><ul>
                        
                <li>
                    <a href="#%e7%b3%bb%e7%bb%9f%e7%ae%a1%e7%90%86" aria-label="系统管理">系统管理</a></li>
                <li>
                    <a href="#unit" aria-label="Unit">Unit</a></li>
                <li>
                    <a href="#unit-%e7%9a%84%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6" aria-label="Unit 的配置文件">Unit 的配置文件</a></li>
                <li>
                    <a href="#target" aria-label="Target">Target</a></li>
                <li>
                    <a href="#%e6%97%a5%e5%bf%97%e7%ae%a1%e7%90%86" aria-label="日志管理">日志管理</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%ae%9a%e6%97%b6%e5%99%a8%e7%a4%ba%e4%be%8bhttpwwwruanyifengcomblog201803systemd-timerhtml" aria-label="定时器示例"><a href="http://www.ruanyifeng.com/blog/2018/03/systemd-timer.html">定时器示例</a></a><ul>
                        
                <li>
                    <a href="#%e9%82%ae%e4%bb%b6%e8%84%9a%e6%9c%ac" aria-label="邮件脚本">邮件脚本</a></li>
                <li>
                    <a href="#service-%e5%8d%95%e5%85%83" aria-label="Service 单元">Service 单元</a></li>
                <li>
                    <a href="#timer-%e5%8d%95%e5%85%83" aria-label="Timer 单元">Timer 单元</a></li></ul>
                </li>
                <li>
                    <a href="#system-timehttpswikiarchlinuxorgtitlesystem_time_e7ae80e4bd93e4b8ade69687" aria-label="System time"><a href="https://wiki.archlinux.org/title/System_time_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">System time</a></a><ul>
                        
                <li>
                    <a href="#%e7%a1%ac%e4%bb%b6%e6%97%b6%e9%92%9f%e5%92%8c%e7%b3%bb%e7%bb%9f%e6%97%b6%e9%92%9f" aria-label="硬件时钟和系统时钟">硬件时钟和系统时钟</a></li>
                <li>
                    <a href="#%e8%af%bb%e5%8f%96%e6%97%b6%e9%97%b4" aria-label="读取时间">读取时间</a></li>
                <li>
                    <a href="#%e8%ae%be%e7%bd%ae%e6%97%b6%e9%97%b4" aria-label="设置时间">设置时间</a></li>
                <li>
                    <a href="#%e6%97%b6%e9%97%b4%e6%a0%87%e5%87%86" aria-label="时间标准">时间标准</a></li>
                <li>
                    <a href="#windows-%e7%b3%bb%e7%bb%9f%e4%bd%bf%e7%94%a8-utc" aria-label="Windows 系统使用 UTC">Windows 系统使用 UTC</a></li>
                <li>
                    <a href="#utc-%e5%9c%a8ubuntu%e7%9a%84%e8%ae%be%e7%bd%ae" aria-label="UTC 在Ubuntu的设置">UTC 在Ubuntu的设置</a></li>
                <li>
                    <a href="#%e6%97%b6%e5%8c%ba" aria-label="时区">时区</a></li>
                <li>
                    <a href="#%e6%97%b6%e9%92%9f%e5%81%8f%e7%a7%bb" aria-label="时钟偏移">时钟偏移</a></li>
                <li>
                    <a href="#%e6%97%b6%e9%92%9f%e5%90%8c%e6%ad%a5" aria-label="时钟同步">时钟同步</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e9%98%b2%e7%81%ab%e5%a2%99httpswwwlinuxprobecombasic-learning-08html" aria-label="防火墙"><a href="https://www.linuxprobe.com/basic-learning-08.html">防火墙</a></a><ul>
                        
                <li>
                    <a href="#%e9%98%b2%e7%81%ab%e5%a2%99%e7%ae%a1%e7%90%86%e5%b7%a5%e5%85%b7" aria-label="防火墙管理工具">防火墙管理工具</a></li>
                <li>
                    <a href="#iptables" aria-label="Iptables">Iptables</a><ul>
                        
                <li>
                    <a href="#%e7%ad%96%e7%95%a5%e4%b8%8e%e8%a7%84%e5%88%99%e9%93%be" aria-label="策略与规则链">策略与规则链</a></li>
                <li>
                    <a href="#%e5%9f%ba%e6%9c%ac%e7%9a%84%e5%91%bd%e4%bb%a4%e5%8f%82%e6%95%b0httpswwwjianshucomp5a604b4ef342" aria-label="基本的命令参数"><a href="https://www.jianshu.com/p/5a604b4ef342">基本的命令参数</a></a><ul>
                        
                <li>
                    <a href="#%e5%91%bd%e4%bb%a4%e6%a0%bc%e5%bc%8f" aria-label="命令格式">命令格式</a></li>
                <li>
                    <a href="#%e5%8f%82%e6%95%b0%e8%af%b4%e6%98%8e" aria-label="参数说明">参数说明</a></li>
                <li>
                    <a href="#%e5%8a%a8%e4%bd%9c%e8%af%b4%e6%98%8e" aria-label="动作说明">动作说明</a></li>
                <li>
                    <a href="#%e4%be%8b%e5%ad%90" aria-label="例子">例子</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5httpswikiarchlinuxorgtitleiptables_e7ae80e4bd93e4b8ade69687e59fbae69cace6a682e5bfb5" aria-label="基本概念"><a href="https://wiki.archlinux.org/title/iptables_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">基本概念</a></a><ul>
                        
                <li>
                    <a href="#%e8%a1%a8tables" aria-label="表(Tables)">表(Tables)</a></li>
                <li>
                    <a href="#%e9%93%bechains" aria-label="链(Chains)">链(Chains)</a></li>
                <li>
                    <a href="#%e8%a7%84%e5%88%99-rules" aria-label="规则 (Rules)">规则 (Rules)</a></li>
                <li>
                    <a href="#%e9%81%8d%e5%8e%86%e9%93%betraversing-chains" aria-label="遍历链(Traversing Chains)">遍历链(Traversing Chains)</a></li>
                <li>
                    <a href="#%e6%a8%a1%e5%9d%97modules" aria-label="模块(Modules)">模块(Modules)</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#firewalld" aria-label="Firewalld">Firewalld</a><ul>
                        
                <li>
                    <a href="#%e7%bb%88%e7%ab%af%e7%ae%a1%e7%90%86%e5%b7%a5%e5%85%b7" aria-label="终端管理工具">终端管理工具</a></li>
                <li>
                    <a href="#%e5%9b%be%e5%bd%a2%e7%ae%a1%e7%90%86%e5%b7%a5%e5%85%b7" aria-label="图形管理工具">图形管理工具</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%9c%8d%e5%8a%a1%e7%9a%84%e8%ae%bf%e9%97%ae%e6%8e%a7%e5%88%b6%e5%88%97%e8%a1%a8" aria-label="服务的访问控制列表">服务的访问控制列表</a></li>
                <li>
                    <a href="#cockpit-%e9%a9%be%e9%a9%b6%e8%88%b1%e7%ae%a1%e7%90%86%e5%b7%a5%e5%85%b7" aria-label="Cockpit 驾驶舱管理工具">Cockpit 驾驶舱管理工具</a></li>
                <li>
                    <a href="#%e5%9c%a8-ubuntu-%e4%b8%8a%e4%bd%bf%e7%94%a8-ufwgufwhttpswwwmyfreaxcomhow-to-setup-a-firewall-with-ufw-on-ubuntu-20-04" aria-label="在 Ubuntu 上使用 UFW&amp;amp;GUFW"><a href="https://www.myfreax.com/how-to-setup-a-firewall-with-ufw-on-ubuntu-20-04/">在 Ubuntu 上使用 UFW&amp;GUFW</a></a><ul>
                        
                <li>
                    <a href="#%e6%a3%80%e6%9f%a5ufw%e7%8a%b6%e6%80%81" aria-label="检查UFW状态">检查UFW状态</a></li>
                <li>
                    <a href="#ufw%e9%bb%98%e8%ae%a4%e7%ad%96%e7%95%a5" aria-label="UFW默认策略">UFW默认策略</a></li>
                <li>
                    <a href="#%e5%ba%94%e7%94%a8%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6" aria-label="应用配置文件">应用配置文件</a></li>
                <li>
                    <a href="#%e5%90%af%e7%94%a8ufw" aria-label="启用UFW">启用UFW</a></li>
                <li>
                    <a href="#%e6%89%93%e5%bc%80%e7%ab%af%e5%8f%a3" aria-label="打开端口">打开端口</a></li>
                <li>
                    <a href="#%e6%8b%92%e7%bb%9d%e8%bf%9e%e6%8e%a5" aria-label="拒绝连接">拒绝连接</a></li>
                <li>
                    <a href="#%e5%88%a0%e9%99%a4ufw%e8%a7%84%e5%88%99" aria-label="删除UFW规则">删除UFW规则</a></li>
                <li>
                    <a href="#%e7%a6%81%e7%94%a8ufw" aria-label="禁用UFW">禁用UFW</a></li>
                <li>
                    <a href="#%e9%87%8d%e8%ae%beufw" aria-label="重设UFW">重设UFW</a></li>
                <li>
                    <a href="#ip%e4%bc%aa%e8%a3%85" aria-label="IP伪装">IP伪装</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#linux-kernel" aria-label="Linux Kernel">Linux Kernel</a><ul>
                        
                <li>
                    <a href="#kernel-modulehttpswikiarchlinuxorgtitlekernel_module_e7ae80e4bd93e4b8ade69687" aria-label="Kernel module"><a href="https://wiki.archlinux.org/title/Kernel_module_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Kernel module</a></a><ul>
                        
                <li>
                    <a href="#%e8%8e%b7%e5%8f%96%e4%bf%a1%e6%81%af" aria-label="获取信息">获取信息</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8systemd%e8%87%aa%e5%8a%a8%e5%8a%a0%e8%bd%bd%e6%a8%a1%e5%9d%97" aria-label="使用systemd自动加载模块">使用systemd自动加载模块</a></li>
                <li>
                    <a href="#%e6%89%8b%e5%8a%a8%e5%8a%a0%e8%bd%bd%e5%8d%b8%e8%bd%bd" aria-label="手动加载卸载">手动加载卸载</a></li>
                <li>
                    <a href="#%e9%85%8d%e7%bd%ae%e6%a8%a1%e5%9d%97%e5%8f%82%e6%95%b0" aria-label="配置模块参数">配置模块参数</a><ul>
                        
                <li>
                    <a href="#%e6%89%8b%e5%8a%a8%e5%8a%a0%e8%bd%bd%e6%97%b6%e8%ae%be%e7%bd%ae" aria-label="手动加载时设置">手动加载时设置</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8-etcmodprobed%e4%b8%ad%e7%9a%84%e6%96%87%e4%bb%b6" aria-label="使用 /etc/modprobe.d/中的文件">使用 /etc/modprobe.d/中的文件</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8%e5%86%85%e6%a0%b8%e5%91%bd%e4%bb%a4%e8%a1%8c" aria-label="使用内核命令行">使用内核命令行</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%88%ab%e5%90%8d" aria-label="别名">别名</a></li>
                <li>
                    <a href="#%e9%bb%91%e5%90%8d%e5%8d%95" aria-label="黑名单">黑名单</a><ul>
                        
                <li>
                    <a href="#%e7%a6%81%e7%94%a8%e5%86%85%e6%a0%b8%e6%a8%a1%e5%9d%97" aria-label="禁用内核模块">禁用内核模块</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8-etcmodprobed-%e4%b8%ad%e7%9a%84%e6%96%87%e4%bb%b6" aria-label="使用 /etc/modprobe.d/ 中的文件">使用 /etc/modprobe.d/ 中的文件</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8%e5%86%85%e6%a0%b8%e5%91%bd%e4%bb%a4%e8%a1%8c-1" aria-label="使用内核命令行">使用内核命令行</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#kernel-parameters" aria-label="Kernel parameters">Kernel parameters</a><ul>
                        
                <li>
                    <a href="#%e9%85%8d%e7%bd%ae-2" aria-label="配置">配置</a><ul>
                        
                <li>
                    <a href="#systemd-boot" aria-label="systemd-boot">systemd-boot</a></li>
                <li>
                    <a href="#grub" aria-label="GRUB">GRUB</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%8f%91%e5%b8%83%e6%97%b6%e9%97%b4%e8%a1%a8httpslinuxcnarticle-13963-1html" aria-label="发布时间表"><a href="https://linux.cn/article-13963-1.html">发布时间表</a></a><ul>
                        
                <li>
                    <a href="#%e5%86%85%e6%a0%b8%e5%8f%91%e5%b8%83%e6%97%b6%e9%97%b4%e8%a1%a8%e6%9c%89%e5%90%97" aria-label="内核发布时间表：有吗？">内核发布时间表：有吗？</a></li>
                <li>
                    <a href="#%e4%b8%80%e4%b8%aa%e5%86%85%e6%a0%b8%e7%89%88%e6%9c%ac%e6%94%af%e6%8c%81%e5%a4%9a%e9%95%bf%e6%97%b6%e9%97%b4" aria-label="一个内核版本支持多长时间？">一个内核版本支持多长时间？</a></li>
                <li>
                    <a href="#lts-%e5%86%85%e6%a0%b8%e5%ae%83%e6%94%af%e6%8c%81%e5%a4%9a%e9%95%bf%e6%97%b6%e9%97%b4" aria-label="LTS 内核：它支持多长时间？">LTS 内核：它支持多长时间？</a></li>
                <li>
                    <a href="#%e4%bd%a0%e7%9a%84%e5%8f%91%e8%a1%8c%e7%89%88%e5%8f%af%e8%83%bd%e6%b2%a1%e6%9c%89%e8%b7%9f%e9%9a%8f%e9%80%9a%e5%b8%b8%e7%9a%84-linux-%e5%86%85%e6%a0%b8%e7%89%88%e6%9c%ac" aria-label="你的发行版可能没有跟随通常的 Linux 内核版本">你的发行版可能没有跟随通常的 Linux 内核版本</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%ae%89%e8%a3%85%e5%86%85%e6%a0%b8httpslinuxcnarticle-12125-1html" aria-label="安装内核"><a href="https://linux.cn/article-12125-1.html">安装内核</a></a><ul>
                        
                <li>
                    <a href="#xanmod-kernelhttpsplumzmearchives12014" aria-label="XanMod Kernel"><a href="https://plumz.me/archives/12014/">XanMod Kernel</a></a></li>
                <li>
                    <a href="#zenhttpswikiubuntucomzenkernelliquorix-kernelhttpsliquorixnet" aria-label="Zen/Liquorix Kernel"><a href="https://wiki.ubuntu.com/ZenKernel">Zen</a>/<a href="https://liquorix.net/">Liquorix Kernel</a></a></li>
                <li>
                    <a href="#%e5%8f%af%e9%80%89%e5%86%85%e6%a0%b8httpswikiarchlinuxorgtitlekernel" aria-label="可选内核"><a href="https://wiki.archlinux.org/title/kernel">可选内核</a></a></li></ul>
                </li>
                <li>
                    <a href="#%e5%88%87%e6%8f%9b%e5%86%85%e6%a0%b8httpsmeetrixioblogawschanging-default-ubuntu-kernelhtml" aria-label="切換内核"><a href="https://meetrix.io/blog/aws/changing-default-ubuntu-kernel.html">切換内核</a></a></li>
                <li>
                    <a href="#%e5%88%a0%e9%99%a4%e6%97%a7%e5%86%85%e6%a0%b8httpslinuxcnarticle-6245-1html" aria-label="删除旧内核"><a href="https://linux.cn/article-6245-1.html">删除旧内核</a></a></li>
                <li>
                    <a href="#%e7%bc%96%e5%86%99%e7%ac%ac%e4%b8%80%e4%b8%aa%e5%86%85%e6%a0%b8%e6%a8%a1%e5%9d%97httpslinuxcnarticle-3251-1html" aria-label="编写第一个内核模块"><a href="https://linux.cn/article-3251-1.html">编写第一个内核模块</a></a></li></ul>
                </li>
                <li>
                    <a href="#%e5%ae%b9%e5%99%a8" aria-label="容器">容器</a><ul>
                        
                <li>
                    <a href="#namespacehttpswwwcnblogscomsparkdevp9365405html" aria-label="Namespace"><a href="https://www.cnblogs.com/sparkdev/p/9365405.html">Namespace</a></a><ul>
                        
                <li>
                    <a href="#%e6%a6%82%e5%bf%b5" aria-label="概念">概念</a></li>
                <li>
                    <a href="#%e7%94%a8%e9%80%94" aria-label="用途">用途</a></li>
                <li>
                    <a href="#%e5%8f%91%e5%b1%95%e5%8e%86%e5%8f%b2" aria-label="发展历史">发展历史</a></li>
                <li>
                    <a href="#clone-%e5%87%bd%e6%95%b0" aria-label="clone() 函数">clone() 函数</a></li>
                <li>
                    <a href="#setns-%e5%87%bd%e6%95%b0" aria-label="setns() 函数">setns() 函数</a></li>
                <li>
                    <a href="#unshare-%e5%87%bd%e6%95%b0" aria-label="unshare() 函数">unshare() 函数</a></li></ul>
                </li>
                <li>
                    <a href="#cgroupshttpdockoneioarticle8433" aria-label="cgroups"><a href="http://dockone.io/article/8433">cgroups</a></a><ul>
                        
                <li>
                    <a href="#%e7%ae%80%e4%bb%8b-1" aria-label="简介">简介</a></li>
                <li>
                    <a href="#%e6%a6%82%e5%bf%b5httpswwwcnblogscomsparkdevp8296063html" aria-label="概念"><a href="https://www.cnblogs.com/sparkdev/p/8296063.html">概念</a></a></li>
                <li>
                    <a href="#%e6%8e%a5%e5%8f%a3" aria-label="接口">接口</a></li>
                <li>
                    <a href="#%e6%89%8b%e5%8a%a8%e6%96%b9%e6%b3%95" aria-label="手动方法">手动方法</a></li>
                <li>
                    <a href="#%e5%bd%93%e8%bf%9b%e7%a8%8b%e8%bf%b7%e8%b7%af%e6%97%b6" aria-label="当进程“迷路”时">当进程“迷路”时</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8libcgroup" aria-label="使用libcgroup">使用libcgroup</a></li>
                <li>
                    <a href="#%e6%8c%81%e4%b9%85%e7%bb%84" aria-label="持久组">持久组</a></li>
                <li>
                    <a href="#%e6%80%bb%e7%bb%93" aria-label="总结">总结</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8-systemdhttpswwwcnblogscomsparkdevp9523194html" aria-label="使用 Systemd"><a href="https://www.cnblogs.com/sparkdev/p/9523194.html">使用 Systemd</a></a></li></ul>
                </li>
                <li>
                    <a href="#lxchttpdockoneioarticle8631" aria-label="LXC"><a href="http://dockone.io/article/8631">LXC</a></a><ul>
                        
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8lxc%e7%9a%84%e5%b7%a5%e5%85%b7" aria-label="使用LXC的工具">使用LXC的工具</a></li>
                <li>
                    <a href="#%e9%ab%98%e7%ba%a7%e9%85%8d%e7%bd%ae" aria-label="高级配置">高级配置</a></li>
                <li>
                    <a href="#%e7%89%b9%e6%9d%83%e4%b8%8e%e9%9d%9e%e7%89%b9%e6%9d%83%e5%ae%b9%e5%99%a8" aria-label="特权与非特权容器">特权与非特权容器</a></li>
                <li>
                    <a href="#%e7%84%b6%e8%80%8cdocker%e5%8f%88%e6%98%af%e4%bb%80%e4%b9%88%e5%91%a2" aria-label="然而，Docker又是什么呢？">然而，Docker又是什么呢？</a><ul>
                        
                <li>
                    <a href="#%e8%bf%9b%e7%a8%8b%e7%ae%a1%e7%90%86" aria-label="进程管理">进程管理</a></li>
                <li>
                    <a href="#%e7%8a%b6%e6%80%81%e7%ae%a1%e7%90%86" aria-label="状态管理">状态管理</a></li>
                <li>
                    <a href="#%e5%8f%af%e7%a7%bb%e6%a4%8d%e6%80%a7" aria-label="可移植性">可移植性</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%80%bb%e7%bb%93-1" aria-label="总结">总结</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%b2%99%e7%ae%b1httpshyperjnet20162016-11-23-linux-sandbox" aria-label="沙箱"><a href="https://hyperj.net/2016/2016-11-23-linux-sandbox/">沙箱</a></a></li></ul>
                </li>
                <li>
                    <a href="#%e6%9d%83%e9%99%90" aria-label="权限">权限</a><ul>
                        
                <li>
                    <a href="#ugohttpswwwcnblogscomsparkdevp9573355html" aria-label="ugo"><a href="https://www.cnblogs.com/sparkdev/p/9573355.html">ugo</a></a><ul>
                        
                <li>
                    <a href="#%e6%89%80%e6%9c%89%e8%80%85%e5%92%8c%e7%bb%84" aria-label="所有者和组">所有者和组</a></li>
                <li>
                    <a href="#%e6%96%87%e4%bb%b6%e5%b1%9e%e6%80%a7" aria-label="文件属性">文件属性</a></li>
                <li>
                    <a href="#%e6%94%b9%e5%8f%98%e6%9d%83%e9%99%90" aria-label="改变权限">改变权限</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%89%b9%e6%ae%8a%e6%9d%83%e9%99%90suidsgidsbit" aria-label="特殊权限"><a href="SUID/SGID/SBIT">特殊权限</a></a><ul>
                        
                <li>
                    <a href="#suid" aria-label="SUID">SUID</a></li>
                <li>
                    <a href="#sgid" aria-label="SGID">SGID</a></li>
                <li>
                    <a href="#sbit" aria-label="SBIT">SBIT</a></li>
                <li>
                    <a href="#%e8%ae%be%e7%bd%ae%e6%9d%83%e9%99%90" aria-label="设置权限">设置权限</a></li></ul>
                </li>
                <li>
                    <a href="#umaskhttpswwwcnblogscomsparkdevp9651890html" aria-label="umask"><a href="https://www.cnblogs.com/sparkdev/p/9651890.html">umask</a></a><ul>
                        
                <li>
                    <a href="#%e9%bb%98%e8%ae%a4%e6%9d%83%e9%99%90" aria-label="默认权限">默认权限</a></li>
                <li>
                    <a href="#%e9%bb%98%e8%ae%a4%e7%ad%96%e7%95%a5" aria-label="默认策略">默认策略</a></li>
                <li>
                    <a href="#%e5%91%bd%e4%bb%a4" aria-label="命令">命令</a></li>
                <li>
                    <a href="#%e4%b8%8e-acl" aria-label="与 ACL">与 ACL</a></li></ul>
                </li>
                <li>
                    <a href="#aclhttpswwwcnblogscomsparkdevp5536868html" aria-label="ACL"><a href="https://www.cnblogs.com/sparkdev/p/5536868.html">ACL</a></a><ul>
                        
                <li>
                    <a href="#%e8%ae%be%e7%bd%ae%e6%9d%83%e9%99%90-1" aria-label="设置权限">设置权限</a></li>
                <li>
                    <a href="#%e7%bb%a7%e6%89%bf%e6%9d%83%e9%99%90" aria-label="继承权限">继承权限</a></li>
                <li>
                    <a href="#%e6%93%8d%e4%bd%9c%e6%9d%83%e9%99%90" aria-label="操作权限">操作权限</a><ul>
                        
                <li>
                    <a href="#%e6%9b%b4%e6%94%b9" aria-label="更改">更改</a></li>
                <li>
                    <a href="#%e5%88%a0%e9%99%a4" aria-label="删除">删除</a></li>
                <li>
                    <a href="#%e5%a4%87%e4%bb%bd%e5%92%8c%e6%81%a2%e5%a4%8d" aria-label="备份和恢复">备份和恢复</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86httpswwwcnblogscomsparkdevp9694015html" aria-label="实现原理"><a href="https://www.cnblogs.com/sparkdev/p/9694015.html">实现原理</a></a></li></ul>
                </li>
                <li>
                    <a href="#%e8%bf%9b%e7%a8%8b%e6%9d%83%e9%99%90httpswwwcnblogscomsparkdevp9694103html" aria-label="进程权限"><a href="https://www.cnblogs.com/sparkdev/p/9694103.html">进程权限</a></a><ul>
                        
                <li>
                    <a href="#%e7%99%bb%e9%99%86%e8%bf%87%e7%a8%8b" aria-label="登陆过程">登陆过程</a></li>
                <li>
                    <a href="#user-id" aria-label="user id">user id</a></li>
                <li>
                    <a href="#%e5%a4%96%e9%83%a8%e5%91%bd%e4%bb%a4" aria-label="外部命令">外部命令</a></li>
                <li>
                    <a href="#%e8%84%9a%e6%9c%ac" aria-label="脚本">脚本</a></li></ul>
                </li>
                <li>
                    <a href="#capabilitieshttpswwwcnblogscomsparkdevp11417781html" aria-label="Capabilities"><a href="https://www.cnblogs.com/sparkdev/p/11417781.html">Capabilities</a></a><ul>
                        
                <li>
                    <a href="#%e7%ae%80%e4%bb%8b-2" aria-label="简介">简介</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8" aria-label="使用">使用</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="winehttpswikiarchlinuxorgtitlewine_e7ae80e4bd93e4b8ade69687"><a href="https://wiki.archlinux.org/title/Wine_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Wine</a><a hidden class="anchor" aria-hidden="true" href="#winehttpswikiarchlinuxorgtitlewine_e7ae80e4bd93e4b8ade69687">#</a></h2>
<h3 id="简介httpszhmwikipediaorgwikiwine"><a href="https://zh.m.wikipedia.org/wiki/Wine">简介</a><a hidden class="anchor" aria-hidden="true" href="#简介httpszhmwikipediaorgwikiwine">#</a></h3>
<p><a href="http://winehq.org/">Wine</a> 是在x86、x86-64容许类Unix操作系统在X Window System运行Microsoft Windows程序的软件。另外，Wine也提供程序运行库（Winelib）来帮助计算机程序设计师将Windows程序移植到类Unix系统；也有不少软件经过Wine测试后发布，比如Picasa、uTorrent、MediaCoder。</p>
<p>Wine通过提供一个兼容层来将Windows的系统调用转换成与POSIX标准的系统调用。它还提供了Windows系统运行库的替代品和一些系统组件的替代品。为了避免著作权问题，Wine主要使用黑箱测试逆向工程来编写。</p>
<p>Wine最早是“Windows Emulator”，即Windows模拟器的缩写，但Wine现在为“Wine Is Not an Emulator”的递归缩写，即Wine不是模拟器。Wine的正确名称是“Wine”，而不是全大写或全小写。</p>
<p>Wine计划在1993年由Bob Amstadt及Eric Youngdale发起，最初目的是为了让16位Windows 3.1程序可以在Linux上执行，但随着电脑和时代的演进，Wine也一路支持到更新的Windows和64位的计算机体系结构。</p>
<p>由于Windows的DLL为封闭源代码，所以程序员只能由最底层的设计开始，耗费大量的时间来编写和测试，最后达至兼容，这过程是困难且缓慢的。</p>
<p>在1999年期间，当Corel加入这个计划后，Wine很快便能兼容WordPerfect Office，但Corel不久便停止支持这项计划，所以Wine的发展又逐渐趋缓，一直到2006年Google积极参与这个计划后，Wine的发展才又恢复起色，最后终于在2008年发布首个稳定版，其后便以每两周发布一个新版的速度发展着，除此之外，Google每年所举办的夏日代码大赛活动也对Wine有着不少贡献。</p>
<p>Wine虽然是从Linux开始发展，但现在已经支持多种平台，有BSD、Mac OS X与Solaris-x86，在2013年的自由及开源软件开发者欧洲会议上，Wine的项目领导人Alexandre Julliard（英语：Alexandre Julliard）表示目前将积极支持Android平台。</p>
<p>在2008年，Wine已经能够完美运行很多知名程序，例如Lotus Notes及Microsoft Office 2007，Photoshop CS2，但其可靠性及稳定性仍有待改善。<strong>如果该程序包含本地的微软Windows系统的库，那样Wine便可很顺利运行该程序。</strong></p>
<p>有些Wine DLLs亦已能完美地取代Windows原来的DLLs，使得有些程序可完美运行。</p>
<p>最晚到2006年，Wine上面已经可以完全基于Wine DLL完美地运行暴雪发行的多款3D游戏了，如魔兽世界、魔兽争霸等。</p>
<p><strong>注</strong>：以下如果使用zsh，<code>~</code> 应替换为 <code>$HOME</code>才能正常使用</p>
<h3 id="安装httpswikiwinehqorgubuntu"><a href="https://wiki.winehq.org/Ubuntu">安装</a><a hidden class="anchor" aria-hidden="true" href="#安装httpswikiwinehqorgubuntu">#</a></h3>
<p><strong>使用 Ubuntu 仓库版本</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install wine
</code></pre></div><p><strong>使用 wine 仓库安装最新版本</strong></p>
<p>如果您之前安装过来自其他仓库的 Wine 安装包，请在尝试安装 WineHQ 安装包之前删除它及依赖它的所有安装包（如：wine-mono、wine-gecko、winetricks），否则可能导致依赖冲突。</p>
<p>如果您使用的是 64 位系统，请<a href="https://www.unixmen.com/enable-32-bit-support-64-bit-ubuntu-13-10-greater/">开启 32 bit 架构支持</a>（如果您之前没有开启的话）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># Verifying you have 64-bit kernel architecture.</span>
$ dpkg --print-architecture
<span style="color:#75715e"># Verifying you have multi-arch support enabled. </span>
$ dpkg --print-foreign-architectures
<span style="color:#75715e"># Enabling multi-arch support.</span>
$ sudo dpkg --add-architecture i386 
$ sudo apt update
</code></pre></div><p>下载添加仓库密钥：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ wget -nc https://dl.winehq.org/wine-builds/winehq.key
$ sudo apt-key add winehq.key
</code></pre></div><p>并添加 Ubuntu 20.04 仓库：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo add-apt-repository <span style="color:#e6db74">&#39;deb https://dl.winehq.org/wine-builds/ubuntu/ focal main&#39;</span>
</code></pre></div><p>安装：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt update
$ sudo apt install --install-recommends winehq-stable
</code></pre></div><h3 id="配置">配置<a hidden class="anchor" aria-hidden="true" href="#配置">#</a></h3>
<p>配置Wine的方式通常有：</p>
<ul>
<li><a href="https://wiki.winehq.org/winecfg">winecfg</a>是Wine的图形界面配置程序。控制台下调用<code>$ winecfg</code>（或指定系统目录：<code>$ WINEPREFIX=~/.系统目录 winecfg</code>）即可启动</li>
<li><a href="https://wiki.winehq.org/control">control.exe</a>是Windows控制面板的Wine实现，通过<code>$ wine control</code>命令启动</li>
<li><a href="https://wiki.winehq.org/regedit">regedit</a>是Wine的注册表编辑器，比较前两者，该工具能配置更多东西。部分常用键值参见：<a href="https://wiki.winehq.org/UsefulRegistryKeys">WineHQ&rsquo;s article on Useful Registry Keys</a></li>
</ul>
<h4 id="初始设置httpswikiubuntuorgcnubuntuhelpwinezh"><a href="https://wiki.ubuntu.org.cn/UbuntuHelp:Wine/zh">初始设置</a><a hidden class="anchor" aria-hidden="true" href="#初始设置httpswikiubuntuorgcnubuntuhelpwinezh">#</a></h4>
<p>通过全局菜单，应用程序 - &gt;附件 - &gt;终端 ，输入命令： <code>winecfg</code> 这将在你的家目录中创建一个隐藏文件夹（.wine），其中包含类似于在Windows中的虚拟C：驱动器以及注册表文件。一旦该目录中创建完，wine配置窗口将出现。该窗口将允许您定制wine的各种设置，其中包括Windows版本，DLL替换，显示设置，驱动器映射，以及应用程序的特定设置。单击OK按钮关闭该窗口。</p>
<h4 id="wineprefix">WINEPREFIX<a hidden class="anchor" aria-hidden="true" href="#wineprefix">#</a></h4>
<p>Wine默认将配置文件和安装的Windows程序保存在<code>~/.wine</code>。这样的目录称为一个&quot;Wine prefix&quot;或&quot;Wine bottle&quot;（下文称“系统目录”）。每次运行Windows程序（包括内置程序，如<code>winecfg</code>）时，系统目录会自动创建（如果缺失）或更新。系统目录中存放有文件夹 <code>~/.wine/drive_c</code> 相当于Windows下<code>C:\</code>C盘（更确切的说应是系统盘）。</p>
<p>通过设置<code>WINEPREFIX</code>环境变量，可以更改Wine系统目录的位置。如果希望让不同的Windows程序使用不同的系统环境或配置，这一变量会非常有用。建议把你安装的不同的Windows程序分给不同的WINEPREFIX，便于打包和隔离。当你要启动这个Windows程序前也记得要设置WINEPREFIX。</p>
<p>例如，如果您使用 <code>$ env WINEPREFIX=~/.win-a wine-A程序.exe</code>参数来运行一个程序。另一个使用 <code>$ env WINEPREFIX=~/.win-b wine-B程序.exe</code>参数，这两个程序将使用独立的C盘和注册表配置。</p>
<p>以下命令会建立一个默认的系统目录，且不启动任何Windows程序：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ env WINEPREFIX<span style="color:#f92672">=</span>~/.customprefix wineboot -u
</code></pre></div><h4 id="winearch">WINEARCH<a hidden class="anchor" aria-hidden="true" href="#winearch">#</a></h4>
<p>这个WINEARCH 决定了你模拟的Windows是32位或是64位的x86。对应的值为win32及win64，如果你的Unix系统是64位的它就默认是win64。</p>
<p>发行版所提供的wine一般都有32位及64位两个包，直接对应所模拟的Windows位数，包里面的Unix二进制及运行库也都是对应位数。</p>
<p>对于64位用户，默认创建的系统目录是64位环境的。若想使用纯32位环境，修改<code>WINEARCH</code> 变量win32为即可： <code>$ WINEARCH=win32 winecfg</code>这样就会生成32位Wine环境。若不设置<code>WINEARCH</code>得到的就是64位环境。</p>
<p>通过<code>WINEPREFIX</code>变量，在不同的系统目录分别创建32位和64位环境：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ WINEARCH<span style="color:#f92672">=</span>win32 WINEPREFIX<span style="color:#f92672">=</span>~/win32 winecfg
$ WINEPREFIX<span style="color:#f92672">=</span>~/win64 winecfg
</code></pre></div><p><strong>注意：</strong> 系统目录创建过程中，64位版本的wine将视全部目录如同64位系统目录，也将不会在已存在的目录中创建任何32位的。创建32位系统目录，您必须让Wine创建指定的<code>WINEPREFIX</code>目录。</p>
<p>winetricks也接受<code>WINEPREFIX</code>变量，以安装Steam为例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ WINEARCH<span style="color:#f92672">=</span>win32 WINEPREFIX<span style="color:#f92672">=</span>~/.local/share/wineprefixes/steam winetricks steam
</code></pre></div><p>编辑 <code>~/.bashrc</code>，使得 WINEPREFIX 和 WINEARCH 永久生效</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">export WINEPREFIX<span style="color:#f92672">=</span>$HOME/.config/wine/
export WINEARCH<span style="color:#f92672">=</span>win32
</code></pre></div><h4 id="图形驱动">图形驱动<a hidden class="anchor" aria-hidden="true" href="#图形驱动">#</a></h4>
<p>你需要安装32位的显卡驱动。缺少或未能正确配置驱动的一个标志是 Wine 在终端窗口里报告如下内容：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">Direct rendering is disabled, most likely your OpenGL drivers have not been installed correctly
</code></pre></div><p><strong>注意：</strong> 在安装对应的库以后，你可能需要重启 X</p>
<h4 id="声音">声音<a hidden class="anchor" aria-hidden="true" href="#声音">#</a></h4>
<p>Wine程序有可能遇到某些声音问题。首先，确保<code>winecfg</code>中只启用了一种声卡驱动。目前，Wine对<a href="https://wiki.archlinux.org/title/Alsa_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Alsa</a>的支持最好。</p>
<p><strong>MIDI 支持</strong></p>
<p><a href="https://wiki.archlinux.org/title/MIDI">MIDI</a> 是九十年代非常流行的游戏声音系统。如果你尝试运行老一点的游戏，音乐无法开箱即用的情况并不罕见。 Wine 拥有非常优秀的 MIDI 支持。但是首先你需要确保 Wine 会使用正确的 MIDI 输出。详细设置参考 <a href="https://wiki.winehq.org/MIDI">Wine Wiki</a></p>
<h4 id="字体">字体<a hidden class="anchor" aria-hidden="true" href="#字体">#</a></h4>
<p><a href="https://www.jianshu.com/p/df2c679f0d12"><strong>中文乱码</strong></a></p>
<p>将中文字体copy到对应wine的目录（本地安装的wine是<code>~/.wine</code>，playonlinux是<code>.PlayOnLinux/wineprefix/对应目录</code>）下的<code>drive_c/windows/Fonts/</code>。</p>
<p>在wine目录下任意位置添加<code>modify_font.reg</code>文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ini" data-lang="ini"><span style="color:#a6e22e">REGEDIT4</span>

<span style="color:#66d9ef">[HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\FontLink\SystemLink]</span>
<span style="color:#a6e22e">&#34;Lucida Sans Unicode&#34;</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;SourceHanSans.ttc&#34;</span>
<span style="color:#a6e22e">&#34;Microsoft Sans Serif&#34;</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;SourceHanSans.ttc&#34;</span>
<span style="color:#a6e22e">&#34;MS Sans Serif&#34;</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;SourceHanSans.ttc&#34;</span>
<span style="color:#a6e22e">&#34;Tahoma&#34;</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;SourceHanSans.ttc&#34;</span>
<span style="color:#a6e22e">&#34;Tahoma Bold&#34;</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;SourceHanSans.ttc&#34;</span>
<span style="color:#a6e22e">&#34;msyh&#34;</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;SourceHanSans.ttc&#34;</span>
<span style="color:#a6e22e">&#34;Arial&#34;</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;SourceHanSans.ttc&#34;</span>
<span style="color:#a6e22e">&#34;Arial Black&#34;</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;SourceHanSans.ttc&#34;</span>
</code></pre></div><p>将<code>SourceHanSans.ttc</code>改成自己想改的中文字体。</p>
<p>在wine命令提示符运行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ regedit modify_font.reg
</code></pre></div><p><strong><a href="https://www.twblogs.net/a/5cb32a72bd9eee48d788acae">语言区域</a></strong></p>
<p>如果安装的系统LANG不为zh-CN，那么wine运行程序的默认语种也不会是中文，这可能导致一部分乱码。解决这个问题，用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ env LANG<span style="color:#f92672">=</span>zh_CN.UTF-8 wine example.exe
</code></pre></div><p>运行程序</p>
<h4 id="启动器和菜单">启动器和菜单<a hidden class="anchor" aria-hidden="true" href="#启动器和菜单">#</a></h4>
<p>Wine不会为内置程序（如<code>winecfg</code>、<code>winebrowser</code>）创建桌面启动器和菜单项。但手动安装的Windows程序通常会自动创建启动器和菜单项。在Windows下，安装程序（如<code>setup.exe</code>）通常会在桌面和开始菜单建立快捷方式，而Wine下会创建遵循freedesktop.org规范的.desktop文件（即启动器，相当于快捷方式）。</p>
<p><strong>提示：</strong> 如果启动器<em>没有</em>自动创建，或者这些文件丢失了，可以尝试使用<a href="https://wiki.winehq.org/winemenubuilder">winemenubuilder</a>修复。</p>
<p><strong>Gnome3 中清理 Wine 菜单启动项</strong></p>
<p>系统全局的菜单启动器安装在 <code>/usr/share/applications/</code>，清除相应程序的“.desktop”文件即可从整个系统删除该启动器。</p>
<p>如果这样还是无法解决问题，那么很可能 Wine 的启动器存放在用户级别的 <code>~/.local/share/applications/wine/Programs/</code> 目录中。删除相应的“.desktop”文件即可清理对应启动项。删除整个 Programs 文件夹将清理所有 Wine 程序的启动项。</p>
<h3 id="安装运行卸载-windows-程序">安装/运行/卸载 Windows 程序<a hidden class="anchor" aria-hidden="true" href="#安装运行卸载-windows-程序">#</a></h3>
<p><strong>警告：</strong> 千万不要以root身份运行Wine！详情参见<a href="https://wiki.winehq.org/FAQ#Should_I_run_Wine_as_root.3F">本文</a>。</p>
<p>使用wine安装应用程序，可以按照以下步骤：</p>
<ol>
<li>从某个地址下载Windows应用程序.exe（可执行文件）.</li>
<li>把它放在一个方便的目录（例如，桌面或个人文件夹）</li>
<li>打开终端，并且切换到.exe文件所在的目录。</li>
<li>输入命令 <code>wine application-name.exe</code> 。</li>
</ol>
<p>这将使用Wine启动.EXE。如果它是一个安装程序，它应该像在windows一样的运行。如果应用程序要求目录来安装应用程序，选择把它放在 C:\Program Files 。</p>
<p>运行Windows程序格式为 <code>WINEPREFIX=&quot;wine配置文件存放地&quot; wine [路径]程序.exe 参数</code> ，如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ wine notepad.exe c:/abc.txt
$ wine notepad.exe ~/.wine/drive_c/abc.txt
</code></pre></div><p>路径可以是Unix路径，也可以是（在有WINEPREFIX情况下的）Windows路径，wine会自动判断。</p>
<p>对wine来说，你Unix系统里的其他文件（即模拟的C盘之外的文件）的Windows路径都以Z盘开头：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ wine notepad.exe z:/home/username/.wine/drive_c/abc.txt
</code></pre></div><p>内置的msiexec程序可以运行MSI安装包：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ <span style="color:#f92672">[</span>wine<span style="color:#f92672">]</span> msiexec /i path_to_msi
</code></pre></div><p>还可以通过在终端运行 winefile 使用 Wine 文件浏览器。</p>
<p>在某些情况下，应用程序需要被从一个特定位置上运行。在这种情况下创建命令启动</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sh -c <span style="color:#e6db74">&#34;cd /home/USER/.wine/drive_c/Program Files/APPDIR; wine game.exe&#34;</span>
</code></pre></div><p><code>wine uninstaller</code> 这将打开一个类似于Windows的程序“添加/删除程序”控制面板，让您卸载wine安装的应用程序。通过 wine 直接运行卸载程序也应该正常工作。或者，您也可以简单地删除应用程序的文件夹。</p>
<h3 id="技巧">技巧<a hidden class="anchor" aria-hidden="true" href="#技巧">#</a></h3>
<p><strong>提示：</strong> 此外您可能会感兴趣以下文章的开始所提供的链接</p>
<ul>
<li><a href="https://appdb.winehq.org/">Wine程序数据库 (Wine Application Database, AppDB)</a> —— 特定Windows程序的Wine兼容情况（运行时的已知问题、用户评分、指南等等），Rating一列由运行结果好到坏为Platinum、Gold、Silver、Bronze、Garbage，无近期结果或近期仍然Silver以下的就放弃吧。</li>
<li><a href="https://forum.winehq.org/">WineHQ论坛</a> —— 要是看完上述网页还有问题，可以到这里咨询</li>
</ul>
<h4 id="opengl-模式">OpenGL 模式<a hidden class="anchor" aria-hidden="true" href="#opengl-模式">#</a></h4>
<p>很多游戏（比如魔兽争霸啦）都支持OpenGL模式，在Wine下<em>可能</em>比默认DirectX模式性能更好。一般添加<code>-opengl</code>启动程序即可，但<em>不同程序可能有所不同</em>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ wine /path/to/3d_game.exe -opengl
</code></pre></div><p>请参考<a href="https://appdb.winehq.org/">AppDB</a>，了解特定程序的相关信息。</p>
<h4 id="wine-控制台">Wine 控制台<a hidden class="anchor" aria-hidden="true" href="#wine-控制台">#</a></h4>
<p>有些时候，可能需要运行<code>.exe</code>给游戏打补丁，比如给古董游戏添加宽屏支持。这时直接通过Wine运行可能没有用。那么，打开终端，运行一下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ wineconsole cmd
</code></pre></div><p>将进入一个和Windows下cmd一样的命令行环境。在该环境下试试也许就可以了。</p>
<h4 id="winetrickshttpswikiwinehqorgwinetricks"><a href="https://wiki.winehq.org/Winetricks">winetricks</a><a hidden class="anchor" aria-hidden="true" href="#winetrickshttpswikiwinehqorgwinetricks">#</a></h4>
<p>使用<a href="https://github.com/Winetricks/winetricks">Winetricks</a>快速脚本，能够方便地安装许多Windows组件，包括DirectX、msxml（被Office 2007、IE浏览器依赖）visual运行库还有其他更多的。</p>
<p><strong>使用 Ubuntu 仓库版本</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install winetricks
</code></pre></div><p><strong>使用 Github 安装最新版本</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cd <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>HOME<span style="color:#e6db74">}</span><span style="color:#e6db74">/.local/bin&#34;</span>
$ wget  https://raw.githubusercontent.com/Winetricks/winetricks/master/src/winetricks
$ chmod u+x winetricks
</code></pre></div><p>可以用<code>winetricks list-all</code>来看看它支持什么。</p>
<p><strong>Using winetricks</strong></p>
<p>获得 winetricks 后，您只需在控制台输入<code>sh winetricks</code>即可运行它。如果你先<code>chmod +x winetricks</code> ，你也可以使用<code>./winetricks</code>。如果不带参数运行，winetricks 会显示一个带有可用包列表的 GUI。如果您知道要安装的软件包的名称，可以将它们附加到 winetricks 命令，它将立即开始安装过程。例如，</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sh winetricks corefonts vcrun6 
</code></pre></div><p>将安装 corefonts 和 vcrun6 软件包。</p>
<p>所有 Wine 命令一样，winetricks 知道 <code>WINEPREFIX</code> 环境变量。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ env WINEPREFIX<span style="color:#f92672">=</span>~/.winetest sh winetricks mfc40 
</code></pre></div><p>拥有多个 Wine 版本的用户可以指定 winetricks 应该使用哪个版本</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ env WINE<span style="color:#f92672">=</span>~/wine-git/wine sh winetricks mfc40 
</code></pre></div><p>使用 ~/wine-git 目录中的 Wine 安装 mfc40 包。</p>
<h4 id="monohttpswikiwinehqorgmono--geckohttpswikiwinehqorggecko"><a href="https://wiki.winehq.org/Mono">Mono</a> &amp; <a href="https://wiki.winehq.org/Gecko">Gecko</a><a hidden class="anchor" aria-hidden="true" href="#monohttpswikiwinehqorgmono--geckohttpswikiwinehqorggecko">#</a></h4>
<p>Mono 是 .NET Framework 的开源和跨平台实现。Wine 可以使用 Windows 构建的 Mono 来运行 .NET 应用程序。</p>
<p>Wine 实现了自己的 Internet Explorer 版本。该实现基于<a href="http://en.wikipedia.org/wiki/Gecko_(layout_engine)">Mozilla 的 Gecko Layout Engine</a>的自定义版本。</p>
<p>在 <a href="http://mirrors.ustc.edu.cn/wine/wine/">USTC MIRROR</a> 分别下载对应的版本，放入<code>~/.cache/wine</code>就可以了。</p>
<h3 id="crossoverhttpswwwcodeweaverscom"><a href="https://www.codeweavers.com">CrossOver</a><a hidden class="anchor" aria-hidden="true" href="#crossoverhttpswwwcodeweaverscom">#</a></h3>
<p>CrossOver是Wine的付费、商业化版本，提供更全面的终端用户支持。它包括脚本、补丁、GUI和可能永远不会被Wine项目接受的第三方软件。这种组合使得那些不太懂技术的人运行Windows程序变得相当容易。</p>
<p>首先在 <a href="https://www.codeweavers.com/crossover/download">CrossOver</a> 下载 .bin 安装包，然后要把 .bin 文件设置成可执行的：<code>chmod u+x crossover.bin</code>，接下来运行该文件：<code>./crossover.bin</code>。</p>
<p><strong><a href="https://www.tspweb.com/key/crossover%E6%97%A0%E9%99%90%E8%AF%95%E7%94%A8.html">无限试用</a></strong></p>
<p>crossover 有15天的试用期，crossover的时间验证信息写在每一个winebottle容器中，相互是完全隔离（不是写在全局配置中）。即使一个容器过期了，依然可以创建新的容器，并重新计算试用期，所以不需要重装软件本身。</p>
<p>即使重装程序，已经过期的容器依旧不能用，不过可以删除该容器，或者删除容器下的.eval文件。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ rm ~/.cxoffice/**/.eval
</code></pre></div><h4 id="tutorialshttpswwwcodeweaverscomsupportwikilinuxlinuxtutorial"><a href="https://www.codeweavers.com/support/wiki/linux/linuxtutorial">Tutorials</a><a hidden class="anchor" aria-hidden="true" href="#tutorialshttpswwwcodeweaverscomsupportwikilinuxlinuxtutorial">#</a></h4>
<p>相对于 wine 而言，CrossOver 更加简洁方便，全程使用 GUI。</p>
<p>在 Select Application 的时候，即使列表中没有列出你需要安装的 Windows 软件，依旧可以尝试使用默认的 Unlisted application，如一些 roguelike、galgame 游戏是可以直接运行的。</p>
<p>如果无法运行：</p>
<ul>
<li>如果报错缺少dll，这时就在网上查找一下，比如 <a href="https://techdot.tech/how-to-fix/wine-runtime-error-cannot-import-dll-isskin-dll/">sskin.dll</a>，如果教程使用的 winetricks，则可以在 <a href="https://github.com/Winetricks/winetricks/blob/master/files/verbs/all.txt">winetricks/files/verbs/all.txt</a> 找到具体的依赖名称，如 Visual C++ 6 SP4 libraries，然后可以在 Select Application 输入依赖名来安装，如果下载慢，也可以通过软件显示的下载链接直接下载。</li>
<li>如果什么错也没报，那么就需要参考  <a href="https://www.codeweavers.com/support/wiki/linux/linuxtutorial/unsupported_deps">Unsupported Troubleshooting</a> 安装依赖或配置 winecfg，确保在安装游戏的时候没有选择升级依赖（比如 DirectX ）并且之后安装了必要的依赖项。推荐游戏自带的 <strong>CommonRedist</strong> 或在 <a href="https://appdb.winehq.org/objectManager.php?sClass=application&amp;sTitle=Browse%20Applications&amp;sOrderBy=appName&amp;bAscending=true">WineHQ  - Browse Applications</a>、<a href="https://www.playonlinux.com/en/supported_apps-1-0.html">PlayOnLinux</a>、<a href="https://www.pcgamingwiki.com/wiki/Home">PCGamingWiki</a> 上找依赖，可以但不推荐在虚拟机中运行一下看报错。</li>
<li>如果先是正常运行，之后 wine 报错 page fault 退出，那么可以参考 <a href="https://www.codeweavers.com/support/wiki/linux/linuxtutorial/debug">Gathering debug logs in Crossover Linux</a> 创建 crash log。</li>
</ul>
<p>凡是依赖解决了，游戏一般是能够运行了，但是运行的好不好，有没有bug就不敢保证了，比如 Skul - The Hero Slayer  是可以直接运行的，但是无法正常显示血量，即使重新安装依赖也是如此。</p>
<p>以下测试的是运行游戏所必须的依赖：</p>
<ul>
<li>
<p>Sekiro Shadows Die Twice</p>
<ul>
<li>Microsoft Visual C++ 6.0 (4.2 &amp; 6.0) Redistributable</li>
</ul>
</li>
<li>
<p>The Elder Scrolls V Skyrim Special Edition</p>
<ul>
<li>DirectX for Modern Games</li>
<li>使用 SkyrimSELauncher.exe 配置，使用 SkyrimSE.exe 启动</li>
</ul>
</li>
<li>
<p>Life is Strange - Before the Storm</p>
<ul>
<li>先安装下面两个依赖，如果 FitGirl 报 <a href="https://www.reddit.com/r/CrackSupport/comments/ggamia/getting_unarcdll_returned_an_error_code_6_on/">Getting unarc.dll returned an error code -6</a>，就 try using the set memory limit to 2 gb option；如果是 Miss files，那么就重装。</li>
<li>Microsoft Visual C++ 6.0 (4.2 &amp; 6.0) Redistributable</li>
<li>DirectX for Modern Games</li>
<li>游戏需要加载一会儿，这个时候屏幕没反应。</li>
</ul>
</li>
<li>
<p>NieR - Automata</p>
<ul>
<li>DirectX for Modern Games</li>
<li>如果 <a href="https://www.codeweavers.com/support/forums/general/?t=27;forumc__=;forumthreadcurPos=0;forumcurPos=0;msg=244698">unable to input name for profile creation</a>，可以尝试将 CrossOver 升级到最新版本。</li>
</ul>
</li>
<li>
<p>Dead Cells</p>
<ul>
<li>参考 [playonlinux/dead cells](playonlinux/dead cells) 的 SourceCode 安装依赖后能够运行</li>
<li>DirectX for Modern Games</li>
<li>OpenAL，安装后要在 Wine Configuration &gt; Libraries 中添加 openal32（不加，点击无反应、闪退）（Libraries 中是运行时自动加载进来的库，而需要的 openal32 没有自动加载进来，因此手动添加）</li>
<li>Microsoft Visual C++ 6.0 (4.2 &amp; 6.0) Redistributable</li>
</ul>
</li>
<li>
<p>The Binding of Isaac Rebirth Repentance</p>
<ul>
<li>要在 Wine Configuration &gt; Libraries 中添加 openal32（不加，点击无反应、闪退）</li>
<li><a href="https://steamcommunity.com/sharedfiles/filedetails/?id=1581384665">《以撒的結合：重生》給新玩家的基本攻略</a></li>
</ul>
</li>
<li>
<p>Valiant Hearts The Great War</p>
<ul>
<li>Copy over the cracked content from the /Crack directory on the image to your game install directory manually.</li>
</ul>
</li>
<li>
<p>DARK SOULS REMASTERED</p>
<ul>
<li>更改语言：In the game installation folder find the &ldquo;steam_emu.ini&rdquo;, open it and find the line with language, change it to schinese.（在 font 目录可以找到所有语言）</li>
</ul>
</li>
<li>
<p>Braid</p>
<ul>
<li>DirectX for Modern Games</li>
</ul>
</li>
<li>
<p>Dying Light Platinum Edition</p>
<ul>
<li>Microsoft Visual C++ 6.0 (4.2 &amp; 6.0) Redistributable</li>
</ul>
</li>
</ul>
<h4 id="dxvkhttpswwwcodeweaverscomsupportwikilinuxlinuxtutorialdxvk"><a href="https://www.codeweavers.com/support/wiki/linux/linuxtutorial/dxvk">DXVK</a><a hidden class="anchor" aria-hidden="true" href="#dxvkhttpswwwcodeweaverscomsupportwikilinuxlinuxtutorialdxvk">#</a></h4>
<p>游戏使用 Vulkan 将获取更好的性能，为使用 Vulkan，需启用 <a href="https://github.com/doitsujin/dxvk">DXVK</a>。DXVK provides a Vulkan-based translation layer for DXGI, D3D10 and D3D11, which can be used on Linux with Wine.</p>
<p>打开 System Information，如果在属性下找到了 <strong>&ldquo;vulkan.present&rdquo;=&ldquo;yes&rdquo;</strong>，则表示支持 vulkan 并可以安装 DXVK。</p>
<p>首先安装驱动程序</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install mesa-vulkan-drivers mesa-vulkan-drivers:i386 libvulkan1 libvulkan1:i386 vulkan-utils
</code></pre></div><p>然后像安装普通软件那样，在 Select an Application to install 搜索并选择 DXVK (Upstream) 安装——DXVK (Builtin) 可能会导致游戏无法运行。安装后就自动启用了，也可以通过右键一个 Bottle&gt;Settings&gt;DXVK Vulkan backand for D3D11(Custom) 启用。</p>
<h4 id="esynchttpsgithubcomzfigurawineblobesyncreadmeesync"><a href="https://github.com/zfigura/wine/blob/esync/README.esync">Esync</a><a hidden class="anchor" aria-hidden="true" href="#esynchttpsgithubcomzfigurawineblobesyncreadmeesync">#</a></h4>
<p>注：Some Windows applications will not work correctly which ESync enabled. 例如 My Friend Pedro 开了后闪退，应该先保证正确运行，再考虑提升性能。</p>
<p><a href="https://www.reddit.com/r/wine_gaming/comments/8vf1ka/what_is_wine_esync_and_how_should_i_set_it_up/"><strong>What is &ldquo;wine esync&rdquo; and how should I set it up?</strong></a></p>
<p>the thing with Far Cry 4, 3 and Primal also Dirt Rally in wine is that it massively loads wineserver and synchronizing all the time, so it is stuck at around 20 fps on ryzen, all those games mentioned. with esync, wineserver is skipped for synchronizing and eventfd is being used, thus increasing performance that much. Games that are CPU bound with wineserver having huge load (wineserver is singlethreaded) benefit the most of this</p>
<p><a href="https://www.reddit.com/r/SteamPlay/comments/b66mz2/what_is_the_function_of_esync_why_most_games_need/"><strong>What is the function of esync? Why most games need it disabled?</strong></a></p>
<p>The function of esync is to provide lightweight thread synchronization facilities (events/semaphores/mutexes) so that game code that uses them heavily will run faster.</p>
<p>It does this using a linux-specific facility called eventfd, which is built around file descriptors. These are a limited resource normally not needed in large quantities, and therefore traditionally made available to a process only in moderate quantities. This helps prevent runaway processes and malicious code from consuming so many descriptors that none are left for other processes (a denial of service).</p>
<p>Therefore, when a game that uses tens of thousands of thread synchronization objects is run with esync, it will fail unless the system&rsquo;s per-process file descriptor limit is much higher than the traditional default. Some linux distributions have already adopted a high default, while others still default to a thousand or so. That&rsquo;s why these games run fine with esync on some distributions but fail on others unless the system&rsquo;s DefaultLimitNOFILE setting is increased.</p>
<p>Edit: If you&rsquo;re interested in esync technical issues that are not distribution-specific, check out <a href="https://github.com/zfigura/wine/issues/11#issuecomment-483060181">this comment</a>.</p>
<h5 id="howtoesynchttpsgithubcomlutrisdocsblobmasterhowtoesyncmd"><a href="https://github.com/lutris/docs/blob/master/HowToEsync.md">HowToEsync</a><a hidden class="anchor" aria-hidden="true" href="#howtoesynchttpsgithubcomlutrisdocsblobmasterhowtoesyncmd">#</a></h5>
<p><strong>What is Esync?</strong></p>
<p>Esync removes wineserver overhead for synchronization objects. This increases performance for a lot of games, especially ones that rely heavily on multithreading.</p>
<p><a href="https://github.com/zfigura/wine/blob/esync/README.esync">A more detailed explanation can be found here</a>.</p>
<p><strong>How to check Esync compatibility</strong></p>
<p>Systems using Systemd 240 and newer are already compatible with Esync.</p>
<p>If you&rsquo;re unsure that your system is compatible, run the <code>ulimit -Hn</code> command. If the value printed is equal to or greater than 524288, then your system is Esync-compatible.</p>
<p><strong>How to make your system Esync compatible</strong></p>
<p>If your system is not Esync-compatible (<code>ulimit -Hn</code>, which prints the limit for number of opened files for a process, prints a value lower than 524288, like 4096), you have 2 different methods of solving this problem. Which method is preferable depends on the distribution currently in use. Applying both methods should have no negative side effect.</p>
<ol>
<li>Modifying Systemd configuration</li>
</ol>
<p>This method applies to Ubuntu and other systems using systemd. You (with root privileges or <code>sudo</code>) need to edit both <code>/etc/systemd/system.conf</code> and <code>/etc/systemd/user.conf</code> by adding <code>DefaultLimitNOFILE=524288</code>. If <code>DefaultLimitNOFILE=</code> already exists in both <code>system.conf</code> and <code>user.conf</code>, add <code>524288</code> after <code>=</code> and make sure to uncomment the line (remove the <code>#</code> in the beginning of the line) to make it functional.</p>
<p>Once the files are edited, restart your computer for the changes to take effect. To verify if the limits were applied, run <code>ulimit -Hn</code> to see <code>524288</code> being reported.</p>
<p>If the value printed still says something like 4096, try the ulimits method below.</p>
<ol start="2">
<li>Modifying ulimits.conf</li>
</ol>
<p>On Linux distributions not using Systemd or distributions using pam-limits.conf (Arch Linux, Fedora, Solus,&hellip; ), you (with root privileges or <code>sudo</code>) need to edit <code>/etc/security/limits.conf</code>.</p>
<p>Change <code>username</code> to your actual username. Once the file is edited, reboot for the changes to take effect, and verify by running <code>ulimit -Hn</code> to see the new limit (<code>524288</code>).</p>
<pre tabindex="0"><code>username hard nofile 524288
</code></pre><h4 id="中文乱码httpsblogcsdnnetqq_35503971articledetails107296647"><a href="https://blog.csdn.net/qq_35503971/article/details/107296647">中文乱码</a><a hidden class="anchor" aria-hidden="true" href="#中文乱码httpsblogcsdnnetqq_35503971articledetails107296647">#</a></h4>
<p><strong>注</strong>：某些游戏会因为语言设置而无法运行。</p>
<p>修改步骤：打开容器 C:Drive，返回到顶层文件夹（即容器名称），即可找到<code>cxbottle.conf</code>，在文件最后面添加如下内容：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#a6e22e">[EnvironmentVariables]</span>
<span style="color:#e6db74">&#34;LANG&#34;</span> = <span style="color:#e6db74">&#34;zh_CN.UTF-8&#34;</span>
</code></pre></div><h3 id="third-party-appshttpswikiarchlinuxorgtitlewinethird-party_applications"><a href="https://wiki.archlinux.org/title/wine#Third-party_applications">Third-party apps</a><a hidden class="anchor" aria-hidden="true" href="#third-party-appshttpswikiarchlinuxorgtitlewinethird-party_applications">#</a></h3>
<h4 id="bottleshttpsusebottlescom"><a href="https://usebottles.com/">Bottles</a><a hidden class="anchor" aria-hidden="true" href="#bottleshttpsusebottlescom">#</a></h4>
<h4 id="protonhttpsgithubcomvalvesoftwareproton"><a href="https://github.com/ValveSoftware/Proton">Proton</a><a hidden class="anchor" aria-hidden="true" href="#protonhttpsgithubcomvalvesoftwareproton">#</a></h4>
<h4 id="playonlinuxhttpswwwplayonlinuxcom"><a href="https://www.playonlinux.com/">PlayOnLinux</a><a hidden class="anchor" aria-hidden="true" href="#playonlinuxhttpswwwplayonlinuxcom">#</a></h4>
<h4 id="lutrishttpslutrisnet"><a href="https://lutris.net/">Lutris</a><a hidden class="anchor" aria-hidden="true" href="#lutrishttpslutrisnet">#</a></h4>
<h3 id="实例">实例<a hidden class="anchor" aria-hidden="true" href="#实例">#</a></h3>
<h4 id="cemuhttpsgithubcomleomaurodesenvcemu-linux"><a href="https://github.com/leomaurodesenv/cemu-linux">Cemu</a><a hidden class="anchor" aria-hidden="true" href="#cemuhttpsgithubcomleomaurodesenvcemu-linux">#</a></h4>
<p>用 Crossover 试了一下，不能用 vulkan，很卡，鼠标延迟很高。</p>
<h4 id="office-2013-prohttpsaskubuntucomquestions879304wine-2-0-says-it-supports-office-2013-how-do-i-actually-install-it"><a href="https://askubuntu.com/questions/879304/wine-2-0-says-it-supports-office-2013-how-do-i-actually-install-it">Office 2013 Pro</a><a hidden class="anchor" aria-hidden="true" href="#office-2013-prohttpsaskubuntucomquestions879304wine-2-0-says-it-supports-office-2013-how-do-i-actually-install-it">#</a></h4>
<p><strong>注</strong>：在安装前先在 <a href="https://appdb.winehq.org/">AppDB</a> 中查找要安装的应用，在 Test Results 部分有相关教程，如 <a href="https://appdb.winehq.org/objectManager.php?sClass=version&amp;iId=28170#testdata">Microsoft Office 2013 Test Results</a></p>
<p><strong>注</strong>：要提高安装成功率，第一，不同 wine 版本安装结果是不同的，AppDB 有相应的信息；第二，winetricks 如果提供安装镜像的话，一定要用该镜像，winetrics 是一个很大的脚本，打开脚本搜索 office2013pro 即可找到官方镜像下载链接；第三，如果第一次安装失败，可以再尝试安装一次。</p>
<p>I installed office 2013 and I used to get a black window after starting it up. I fixed the black screen by following the solution posted in the [WineHQ-Forum](<a href="https://forum.winehq.org/viewtopic.php?f=8&amp;t=28446&amp;p=109296&amp;hilit=office">https://forum.winehq.org/viewtopic.php?f=8&amp;t=28446&amp;p=109296&amp;hilit=office</a> 2013#p109284).</p>
<p>Here&rsquo;s what I did:</p>
<p><strong>Install Components</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install winbind cabextract
</code></pre></div><p><strong>Create Clean 32bit Prefix for Win7</strong></p>
<p>Crete a clean 32 bit prefix and start up winecfg:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ env WINEPREFIX<span style="color:#f92672">=</span>~/.wine-office2013pro WINEARCH<span style="color:#f92672">=</span>win32 winecfg
</code></pre></div><p>In the winecfg applications tab select &ldquo;<strong>Windows version: Windows 7</strong>&rdquo; Close wine config and install winetricks</p>
<p><strong>Install Libraries</strong></p>
<p>Then start winetricks for your prefix</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ env WINEPREFIX<span style="color:#f92672">=</span>~/.wine-office2013pro WINEARCH<span style="color:#f92672">=</span>win32 winetricks
</code></pre></div><p>accept &ldquo;<strong>select the default wineprefix</strong>&rdquo; with OK. Now, select &ldquo;<strong>Install Windows DLL components</strong>&rdquo; and go and install <strong>msxml6</strong>（这个时候会下载 msxml6，可以手动下载后移动到<code>~/.cache/winetricks</code>中）</p>
<p>To fix the problem in PowerPoint (not enough memory), I added two overrides with winecfg in Library section: &ldquo;riched20&rdquo; and &ldquo;usp10&rdquo;.</p>
<p>如果是中文软件需安装中文字体。</p>
<p>在这里我直接使用 winetrics 成功安装 office2013pro（wine 6）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ env WINEPREFIX<span style="color:#f92672">=</span>~/.wine-office2013pro WINEARCH<span style="color:#f92672">=</span>win32 winetricks office2013pro
</code></pre></div><p>这样下面步骤不需要了。</p>
<p><strong>Fix Black Window</strong></p>
<p>In order to fix the black window that impedes Office 13 to be used, add the HKCU\Software\Wine\Direct3D\MaxVersionGL new DWORD value 30002 (hexa) to the registry.</p>
<p>Here&rsquo;s how to do this: In Winetricks select <strong>Run regedit</strong> and wait for the <em>Registry Editor</em> window to open. In the folder tree expand HKEY_CURRENT_USER - Software - Wine and create a new key in the Wine folder. To do so, right click, select <em>new&ndash;&gt;key</em> and name it <strong>Direct3D</strong>. Now create <em>new&ndash;&gt;DWORD Value</em>, rename the file to <strong>MaxVersionGL</strong> and set the value data to <strong>30002</strong> (hexadecimal). Close the Registry Editor window.</p>
<p>Close the winetricks window and run installer:</p>
<p><strong>Install Office 2013</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ env LANG<span style="color:#f92672">=</span>zh_CN.UTF-8 WINEPREFIX<span style="color:#f92672">=</span>~/.wine-office2013pro WINEARCH<span style="color:#f92672">=</span>win32 wine ~/PathTo/Office2013Setup.x86.exe
</code></pre></div><p>From here, the install runs and completes 100%.</p>
<p>安装后可以在 <code>~/.local/share/applications/wine</code> 下找到 微信、QQ 的 .desktop 文件，右键编辑，将 Exec=env 行改为 Exec=env LANG=zh_CN.utf8</p>
<h4 id="wechathttpswwwtechgrowcnpostsa1930361html"><a href="https://www.techgrow.cn/posts/a1930361.html">WeChat</a><a hidden class="anchor" aria-hidden="true" href="#wechathttpswwwtechgrowcnpostsa1930361html">#</a></h4>
<p><strong>Linux 安装微信的可选方案总结</strong></p>
<ul>
<li>腾讯官方 Web 版微信</li>
<li><a href="https://meetfranz.com/">Franz</a> + 微信（基于 Web 版）</li>
<li>Electronic-Wechat（基于 Web 版）</li>
<li>虚拟机 + 微信原生 PC 客户端</li>
<li>CrossOver + 微信原生 PC 客户端</li>
<li><a href="https://github.com/Winetricks/winetricks">Winetricks（基于 Wine）</a> + 微信原生 PC 客户端</li>
<li><a href="https://github.com/hillwoodroc/winetricks-zh">Winetricks-ZH（基于 Wine）</a> + 微信原生 PC 客户端</li>
<li>AppImage + <a href="https://github.com/Hackerl/Wine_Appimage">AppImage 打包构建的（Wine + 微信原生 PC 客户端）</a></li>
<li>Flatpak + <a href="https://gitee.com/wsgalaxy/flatpak-deepinwine-wiki">Flatpak 打包构建的（Deepin-Wine + 微信原生 PC 客户端）</a></li>
<li>Wine + PlayonLinux + 微信原生 PC 客户端</li>
</ul>
<h4 id="genshin-impact">Genshin Impact<a hidden class="anchor" aria-hidden="true" href="#genshin-impact">#</a></h4>
<ul>
<li><a href="https://lutris.net/games/genshin-impact/">Lutris</a></li>
<li><a href="https://gitlab.com/KRypt0n_/an-anime-game-launcher">An Anime Game Launcher</a></li>
<li><a href="https://winegame.net/home">葡萄玩</a>：跑腾讯云游戏，再用云游戏玩国服原神。</li>
</ul>
<h2 id="qemu-kvmhttpswikiarchlinuxorgtitleqemu_e7ae80e4bd93e4b8ade69687"><a href="https://wiki.archlinux.org/title/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">QEMU KVM</a><a hidden class="anchor" aria-hidden="true" href="#qemu-kvmhttpswikiarchlinuxorgtitleqemu_e7ae80e4bd93e4b8ade69687">#</a></h2>
<h3 id="qemu-的图形前端">QEMU 的图形前端<a hidden class="anchor" aria-hidden="true" href="#qemu-的图形前端">#</a></h3>
<p>与其他的虚拟化程序如 VirtualBox 和 VMware 不同, QEMU不提供管理虚拟机的GUI（运行虚拟机时出现的窗口除外），也不提供创建具有已保存设置的持久虚拟机的方法。除非您已创建自定义脚本以启动虚拟机，否则必须在每次启动时在命令行上指定运行虚拟机的所有参数。</p>
<p>Libvirt提供了一种管理 QEMU 虚拟机的便捷方式。有关可用的前端，请参阅 <a href="https://wiki.archlinux.org/title/Libvirt_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#.E5.AE.A2.E6.88.B7.E7.AB.AF">libvirt 客户端列表</a>。</p>
<h3 id="创建新虚拟系统">创建新虚拟系统<a hidden class="anchor" aria-hidden="true" href="#创建新虚拟系统">#</a></h3>
<h4 id="创建硬盘镜像">创建硬盘镜像<a hidden class="anchor" aria-hidden="true" href="#创建硬盘镜像">#</a></h4>
<p>除非直接从 CD-ROM 或网络引导（并且不安装系统到本地），运行 QEMU 时都需要硬盘镜像。硬盘镜像是一个文件，存储虚拟机硬盘上的内容。</p>
<p>一个硬盘镜像可能是 <em>raw</em>镜像, 和客户机器上看到的内容一模一样，并且将始终使用主机上的来宾硬盘驱动器的全部容量。此方法提供的I / O开销最小，但可能会浪费大量空间，因为guest虚拟机上未使用的空间无法在主机上使用。</p>
<p>另外一种方式是<em>qcow2</em> 格式，仅当客户系统实际写入内容的时候，才会分配镜像空间。对客户机器来说，硬盘大小表现为完整大小，即使它可能仅占用主机系统上的非常小的空间。此映像格式还支持QEMU快照功能。但是，使用此格式而不是 <em>raw</em> 可能会影响性能。</p>
<p>QEMU 提供 <code>qemu-img</code>命令创建硬盘镜像.例如创建一个 4 GB <em>raw</em> 格式的镜像:</p>
<pre tabindex="0"><code>$ qemu-img create -f raw image_file 4G
</code></pre><p>您也可以用 <code>-f qcow2</code> 创建一个 <em>qcow2</em> 镜像。</p>
<p>用 <code>dd</code> 或 <code>fallocate</code> 也可以创建一个 <em>raw</em> 镜像。</p>
<p><strong>警告：</strong> 如果硬盘镜像存储在 Btrfs 系统上，则应在创建任何映像之前考虑禁用该目录的 写时复制。</p>
<p><strong>调整镜像大小</strong></p>
<p><strong>警告：</strong> 调整包含NTFS引导文件系统的镜像将无法启动已安装的操作系统，推荐在操作之前进行备份</p>
<p>执行 <code>qemu-img</code> 带 <code>resize</code> 选项调整硬盘驱动镜像的大小.它适用于 <em>raw</em> 和 <em>qcow2</em>. 例如, 增加镜像 10 GB 大小, 运行:</p>
<pre tabindex="0"><code>$ qemu-img resize disk_image +10G
</code></pre><p>在磁盘映像扩容后，必须使用虚拟机内部系统的分区工具对该镜像进行分区并格式化后才能真正开始使用新空间。 在收缩磁盘映像时，必须首先使用虚拟机内部系统的分区工具减少分该分区的大小，然后相应地收缩磁盘映像，否则收缩磁盘映像将导致数据丢失！</p>
<h4 id="安装操作系统">安装操作系统<a hidden class="anchor" aria-hidden="true" href="#安装操作系统">#</a></h4>
<p>这是你第一次需要去启动模拟器的步骤，为了在磁盘镜像上安装操作系统，你必须同时将磁盘镜像与安装介质装载到虚拟机上，从安装介质中启动操作系统。</p>
<p>以i386的客户机为例，为了从CD-ROM内的把可用于启动的ISO文件安装到磁盘镜像上，你需要：</p>
<pre tabindex="0"><code>$ qemu-system-x86_64 -cdrom iso_image -boot order=d -drive file=disk_image,format=raw
</code></pre><p>在安装完操作系统后，就可以直接从QEMU镜像内启动了。</p>
<p><strong>注意：</strong> 默认情况下仅分配给虚拟机128MB的内存， 分配的内存大小可以通过 <code>-m</code> 调整， 比如 <code>-m 512M</code> 或 <code>-m 2G</code>。</p>
<p><strong>提示：</strong></p>
<ul>
<li>相较于指定 <code>-boot order=x</code> ，一部分用户感觉使用 <code>-boot menu=on</code> 启用boot菜单的体验更舒服些，至少在配置和实验时是这样的。</li>
<li>当使用无界面（headless）模式时， 将会默认在本地5900端口启动一个VNC服务器， 可以用 <a href="https://wiki.archlinux.org/title/TigerVNC">TigerVNC</a> 连接到客户机的系统上: <code>vncviewer :5900</code></li>
<li>若你在安装过程中需要替换软盘或CD，可以使用QEMU机器监视器（在虚拟机窗口中按<code>Ctrl + Alt + 2</code>）来删除存储设备并将其连接到虚拟机。使用<code>info block</code>查看块设备，然后使用<code>change</code>命令换出设备。按下<code>Ctrl + Alt + 1</code>返回虚拟机。</li>
</ul>
<h3 id="运行虚拟化的系统">运行虚拟化的系统<a hidden class="anchor" aria-hidden="true" href="#运行虚拟化的系统">#</a></h3>
<p><code>qemu-system-*</code> 程序 (例如 <code>qemu-system-i386</code> 或 <code>qemu-system-x86_64</code>, 取决于客户机架构)用来运行虚拟化的客户机. 用法是:</p>
<pre tabindex="0"><code>$ qemu-system-i386 options disk_image
</code></pre><p>所有 <code>qemu-system-*</code>的选项是相同的。</p>
<p>默认 QEMU会在窗口中显示虚拟机的视频输出.有一点要记住:当您单击QEMU窗口,鼠标指针被捕获。要放开，按 <code>Ctrl+Alt+g</code>.</p>
<p><strong>警告：</strong> QEMU 不应以 root 身份运行. 如果必须以root身份在某个脚本中运行QEMU，那么你需要使用 <code>-runas</code> 选项让QEMU放弃root权限</p>
<h4 id="启用-kvm">启用 KVM<a hidden class="anchor" aria-hidden="true" href="#启用-kvm">#</a></h4>
<p>KVM 必须要您处理器和内核支持, 和必要的 <a href="https://wiki.archlinux.org/title/Kernel_modules">kernel modules</a>加载。更多信息参见 <a href="https://wiki.archlinux.org/title/KVM">KVM</a>。</p>
<p>要在KVM模式中启动QEMU, 追加 <code>-enable-kvm</code>到启动选项. 要检查是否为正在运行的 VM 启用了 KVM，请使用 Ctrl+Alt+Shift+2 进入 QEMU Monitor，然后键入 info kvm。</p>
<p><strong>注意：</strong></p>
<ul>
<li><code>-machine</code> 选项中的 <code>accel=kvm</code> 参数与<code>-enable-kvm</code> 或 <code>-accel kvm</code> 选项是等价的。</li>
<li>CPU模型 <code>host</code> 需要 KVM。</li>
<li>如果你使用GUI工具去启动QEMU，但是性能体验极差，那么最好检查一下是否真的开启了KVM支持，因为QEMU可能选择了备用的模拟模式，即软件级模拟。</li>
<li>需要启用KVM才能正常启动windows7和windows8，否则会出现“蓝屏”.</li>
</ul>
<h4 id="启用-iommu-intel-vt-damd-vi-的支持">启用 IOMMU (Intel VT-d/AMD-Vi) 的支持<a hidden class="anchor" aria-hidden="true" href="#启用-iommu-intel-vt-damd-vi-的支持">#</a></h4>
<p>首先启用IOMMU。</p>
<p>确保您的 CPU 支持 AMD-Vi/Intel Vt-d 并且已经在 BIOS 中打开。通常这个选项会在类似“其他 CPU 特性”的菜单里，也有可能隐藏在超频选项之中。选项可能就叫做 “VT-d” 或者 “AMD-Vi” ，也有可能是更通用的名称，比如“虚拟化技术”之类。有可能您主板的手册并不会解释这些。</p>
<p>设置<a href="https://wiki.ubuntu.com/Kernel/KernelBootParameters">内核参数</a>以启用 IOMMU，注意不同品牌的 CPU 所需的内核参数并不同。</p>
<ul>
<li>对于 Intel CPU(VT-d)，使用 <code>intel_iommu=on</code>。</li>
<li>对于 AMD CPU(AMD-Vi)，使用 <code>amd_iommu=on</code>。</li>
</ul>
<p>您同时需要设置<code>iommu=pt</code>，这将防止Linux试图接触(touching)无法直通的设备。</p>
<p>在重启之后，检查 dmesg 以确认 IOMMU 已经被正确启用：</p>
<pre tabindex="0"><code>$ dmesg | grep -e DMAR -e IOMMU
...
[    0.000000] Intel-IOMMU: enabled
...
</code></pre><p>添加 <code>-device intel-iommu</code> 选项创建IOMMU设备:</p>
<pre tabindex="0"><code>$ qemu-system-x86_64 -enable-kvm -machine q35 -device intel-iommu -cpu host ..
</code></pre><p><strong>注意：</strong> 在基于Intel CPU的系统上用 <code>-device intel-iommu</code> 创建QEMU内的IOMMU设备将会禁用PCI直通， 如果需要PCI直通，则不应设置<code>-device intel-iommu</code>。</p>
<h3 id="宿主机和虚拟机数据交互">宿主机和虚拟机数据交互<a hidden class="anchor" aria-hidden="true" href="#宿主机和虚拟机数据交互">#</a></h3>
<h4 id="网络">网络<a hidden class="anchor" aria-hidden="true" href="#网络">#</a></h4>
<p>我们可以利用任何支持文件传输的网络协议实现客户机和宿主机之间的数据交互, 例如 <a href="https://wiki.archlinux.org/title/NFS">NFS</a>, <a href="https://wiki.archlinux.org/title/SMB">SMB</a>, <a href="https://en.wikipedia.org/wiki/Network_block_device">NBD</a>, HTTP, <a href="https://wiki.archlinux.org/title/Very_Secure_FTP_Daemon">FTP</a>, 或 <a href="https://wiki.archlinux.org/title/SSH">SSH</a>, 当然这么做的前提是你已经配置好二者之间的网络，且在系统上启动了相应的服务程序。</p>
<p>在默认情况下，用户模式的客户机能够通过10.0.2.2这个IP访问到宿主机。任何运行于宿主机上的服务端程序都可以通过这个地址被访问到，比如说我们可以通过这个IP访问到宿主机上的SSH服务器或SMB服务器。因此在这种情况下，客户机能够挂载宿主机通过<a href="https://wiki.archlinux.org/title/SMB">SMB</a> or <a href="https://wiki.archlinux.org/title/NFS">NFS</a>暴露出来的目录，也可以访问宿主机上的HTTP服务器等。 通常情况下宿主机无法访问客户机上的服务，不过你也可以通过一些特殊的网络配置达到这个目的 (参阅<a href="https://wiki.archlinux.org/title/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#Tap_%E7%BD%91%E7%BB%9C">#Tap 网络</a>)</p>
<h4 id="qemu-端口转发">QEMU 端口转发<a hidden class="anchor" aria-hidden="true" href="#qemu-端口转发">#</a></h4>
<p>QEMU能够将宿主机的端口转发到客户机上以实现一些功能，例如从宿主机上访问客户机的SSH端口。</p>
<p>举个例子，将宿主机上的10022端口与客户机上的22 (SSH) 端口进行绑定， 对应的QEMU命令如下：</p>
<pre tabindex="0"><code>$ qemu-system-x86_64 disk_image -nic user,hostfwd=tcp::10022-:22
</code></pre><p>确认你客户机上的sshd程序正在运行，然后可以通过如下命令连接到客户机的SSH端口</p>
<pre tabindex="0"><code>$ ssh guest-user@localhost -p 10022
</code></pre><p>你可以用 <a href="https://wiki.archlinux.org/title/SSHFS">SSHFS</a> 把客户机的整个文件系统都挂到宿主机上，这样就可以在宿主机上对客户机的文件系统进行读写了。</p>
<p>想进行多端口转发的话, 只需要在<code>-nic</code>参数中指定多个<code>hostfwd</code>, 以VNC端口为例:</p>
<pre tabindex="0"><code>$ qemu-system-x86_64 disk_image -nic user,hostfwd=tcp::10022-:22,hostfwd=tcp::5900-:5900
</code></pre><h4 id="qemu-的内置smb服务器">QEMU 的内置SMB服务器<a hidden class="anchor" aria-hidden="true" href="#qemu-的内置smb服务器">#</a></h4>
<p>QEMU的文档中指出它有一个内置的SMB服务器，但实际上，它只是在宿主机上加载一个自动生成的<code>smb.conf</code>配置文件 (位于<code>/tmp/qemu-smb.random_string</code>)，然后启动宿主机上的Samba，使得客户机能够通过一个IP地址进行访问 (默认的IP地址是10.0.2.4)。这个方法只适用于用户网络，在你不想在宿主机开启通常的Samba服务 (客户机同样能访问这类Samba服务) 时这个方法还挺好用的。</p>
<p>宿主机上必须安装 <em>Samba</em>。通过如下QEMU命令启用这项特性:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install samba
$ qemu-system-x86_64 disk_image -net nic -net user,smb<span style="color:#f92672">=</span>shared_dir_path
</code></pre></div><p><code>shared_dir_path</code> 就是你想要在宿主机和客户机之间共享的目录。</p>
<p>接着，在客户机内，你应该能够通过10.0.2.4访问到名为qemu的共享文件夹。例如在Windows Explorer中前往 <code>\\10.0.2.4\qemu</code> 这个地址。</p>
<p><strong>注意：</strong></p>
<ul>
<li>如果你像这样多次指定共享选项 <code>-net user,smb=shared_dir_path1 -net user,smb=shared_dir_path2</code> or <code>-net user,smb=shared_dir_path1,smb=shared_dir_path2</code> qemu只会共享参数中最后的一个目录。</li>
<li>如果你不能访问共享文件夹且客户机系统为 Windows, 请检查 <a href="http://ecross.mvps.org/howto/enable-netbios-over-tcp-ip-with-windows.htm">NetBIOS 协议是否被启用</a> 并确认防火墙没有屏蔽NetBIOS协议的 <a href="https://technet.microsoft.com/en-us/library/cc940063.aspx">端口</a></li>
<li>如果你不能访问共享文件夹且客户机系统为 Windows 10 Enterprise 或 Education 或 Windows Server 2016, 请<a href="https://support.microsoft.com/en-us/help/4046019">启用游客访问</a>.</li>
</ul>
<p>共享多个文件夹并在运行时增删文件夹的一个方法是：共享一个空目录，然后在其中创建指向其余共享目录的符号链接。可以用下面的脚本修改SMB服务器的配置，这个脚本还能使宿主机上不允许执行的文件在客户机内拥有执行权限。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">#!/bin/bash
</span><span style="color:#75715e"></span>eval <span style="color:#66d9ef">$(</span>ps h -C smbd -o pid,args | grep /tmp/qemu-smb | gawk <span style="color:#e6db74">&#39;{print &#34;pid=&#34;$1&#34;;conf=&#34;$6}&#39;</span><span style="color:#66d9ef">)</span>
echo <span style="color:#e6db74">&#34;[global]
</span><span style="color:#e6db74">allow insecure wide links = yes
</span><span style="color:#e6db74">[qemu]
</span><span style="color:#e6db74">follow symlinks = yes
</span><span style="color:#e6db74">wide links = yes
</span><span style="color:#e6db74">acl allow execute always = yes&#34;</span> &gt;&gt; $conf
<span style="color:#75715e"># in case the change is not detected automatically:</span>
smbcontrol --configfile<span style="color:#f92672">=</span>$conf $pid reload-config
</code></pre></div><p>仅当客户机第一次访问到网络驱动后，才能将该脚本启用，并作用于qemu启动的SMB服务器。共享多文件的另一个方法是在配置文件里加入额外的共享路径，就像下面这样</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ echo <span style="color:#e6db74">&#34;[myshare]
</span><span style="color:#e6db74">path=another_path
</span><span style="color:#e6db74">read only=no
</span><span style="color:#e6db74">guest ok=yes
</span><span style="color:#e6db74">force user=username&#34;</span> &gt;&gt; $conf
</code></pre></div><p>这个共享文件夹可以在客户机内通过<code>\\10.0.2.4\*myshare*</code>访问。</p>
<h3 id="网络-1">网络<a hidden class="anchor" aria-hidden="true" href="#网络-1">#</a></h3>
<p>采用<strong>TAP设备</strong>（<a href="https://www.cxyzjd.com/article/Longyu_wlz/107627564">tun 与 tap 设备</a>，都是虚拟网络设备，tun 设备用来实现三层隧道（三层 ip 数据报），tap 设备用来实现二层隧道（二层以太网数据帧）。）和<strong>网桥</strong>（使用网桥可以将多个接口连接到同一网段内，这一功能等同于交换式集线器。）的虚拟网络的性能应该会比使用用户模式网络或VDE要好，原因在于TAP设备和网桥是在内核中实现的。</p>
<p>此外，虚拟网络的性能可以通过将网络设备直接注册到虚拟机中改善，这比默认情况下模拟e1000 NIC的性能表现要更好，参阅 [安装 virtio 驱动](#安装 virtio 驱动) 获得更多相关信息。</p>
<h4 id="关于链路层地址的限制">关于链路层地址的限制<a hidden class="anchor" aria-hidden="true" href="#关于链路层地址的限制">#</a></h4>
<p>若在QEMU启动中指定了 <code>-net nic</code> 参数，QEMU将会为虚拟机注册一块虚拟网卡，其链路层地址为 <code>52:54:00:12:34:56</code> 。然而，当在多台虚拟机之间搭建桥接网络时，每台虚拟机在tap设备的虚拟机端都需要拥有一个独一无二的链路层地址 (MAC)，否则网桥会因为收到多个不同源却拥有相同MAC地址的数据包而无法正常工作。即使你为多个tap设备配置了不同的MAC地址也依旧会出现这个问题，因为当数据包通过tap设备时，tap设备并不会改写包内的链路层地址。</p>
<p>因此请确保每个虚拟机拥有自己独一无二的网卡地址, 并且它们都以 <code>52:54:</code> 开头。 可以通过如下命令手动设置虚拟机的MAC地址, 下面的&rsquo;X&rsquo;可以替换成任何16进制字符:</p>
<pre tabindex="0"><code>$ qemu-system-x86_64 -net nic,macaddr=52:54:XX:XX:XX:XX -net vde disk_image
</code></pre><h4 id="用户模式">用户模式<a hidden class="anchor" aria-hidden="true" href="#用户模式">#</a></h4>
<p>默认情况下，没有任何<code>-netdev</code>参数，QEMU将使用带有内置DHCP服务器的用户模式网络。当您的虚拟机运行其DHCP客户端时，将为其分配IP地址，它们将能够通过QEMU伪装的IP来访问物理主机的网络。</p>
<p><strong>警告：</strong> 仅适用于TCP和UDP协议，因此ICMP协议（包括<code>ping</code>）将不起作用。 请勿使用<code>ping</code>测试网络连接。</p>
<p>如果主机已连接Internet，则此默认配置可以使您的虚拟机轻松访问Internet。但是如果您同时启动多个虚拟机，则虚拟机将无法在外部网络上直接看到，虚拟机也将无法相互通信。</p>
<p>QEMU的用户模式网络可以提供更多功能，例如内置TFTP或SMB服务器，将主机端口重定向到虚拟机（例如，允许SSH连接到虚拟机）或将虚拟机连接到VLAN（vlan 全程 virtual lan，能够用来虚拟分配以太网。归属于不同的 VLAN ID 的设备之间需要一个路由才能够通信，这意味这不同的 VLAN ID 将以太网划分成了不同的分组。），以便它们可以彼此通信。 有关更多详细信息，请参见<code>-net user</code>标志上的QEMU文档。</p>
<p>但是，用户模式网络在效用和性能上都有局限性。更高级的网络配置需要使用TAP设备或其他方法。</p>
<h4 id="tap-网络">Tap 网络<a hidden class="anchor" aria-hidden="true" href="#tap-网络">#</a></h4>
<p><a href="https://en.wikipedia.org/wiki/TUN/TAP">Tap devices</a>是一个Linux内核特性，允许您创建作为真实网络接口的虚拟网络接口。发送到tap接口的包将被传递到一个用户空间程序(如QEMU)，该程序将自己绑定到该接口。</p>
<p>QEMU可以为虚拟机使用tap网络，因此发送到tap接口的包将被发送到虚拟机，并显示为来自虚拟机中的网络接口(通常是以太网接口)。相反，虚拟机通过其网络接口发送的所有内容都将出现在tap接口上。</p>
<p>Linux桥接驱动程    序支持Tap设备，因此可以将Tap设备彼此桥接在一起，也可以连接其他主机接口，如<code>eth0</code>。如果您希望您的虚拟机能够相互通信，或者希望LAN上的其他机器能够与虚拟机通信，那么这是非常理想的方案。</p>
<p><strong>警告：</strong> 如果您将tap设备和一些主机接口桥接在一起，例如<code>eth0</code>，您的虚拟机将直接出现在外部网络上，这将使它们遭受攻击的可能。根据您的虚拟机可以访问的资源，您可能需要采取所有<a href="https://wiki.archlinux.org/title/Firewalls">precautions</a>来保护您的虚拟机。如果风险太大,虚拟机没有资源或您设置多个虚拟机,一个更好的解决方案可能是使用<a href="https://wiki.archlinux.org/title/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E4%BB%85%E4%B8%BB%E6%9C%BA_%E7%BD%91%E7%BB%9C">host-only networking</a>建立NAT。在这种情况下，您只需要在主机上安装一个防火墙，而不是为每个虚拟机安装多个防火墙。</p>
<p>正如在用户模式网络部分中指出的，tap设备提供比用户模式具有更高的网络性能。如果虚拟机中的操作系统支持virtio网络驱动程序，那么网络性能也会显著提高。假设使用tap0设备，virtio驱动程序在客户端上使用，并且没有使用脚本来帮助启动/停止网络，使用下面的qemu命令：</p>
<pre tabindex="0"><code>-net nic,model=virtio -net tap,ifname=tap0,script=no,downscript=no
</code></pre><p>但是，如果已经使用带有virtio网络驱动程序的Tap设备，则甚至可以通过启用vhost来提高网络性能，例如：</p>
<pre tabindex="0"><code>-net nic,model=virtio -net tap,ifname=tap0,script=no,downscript=no,vhost=on
</code></pre><p><strong>仅主机网络</strong></p>
<p>如果为网桥提供了IP地址，并且使能发往该网桥的流量允许，但没有实际接口（例如<code>eth0</code>）连接到网桥，则虚拟机与虚拟机间，虚拟机与主机间能够相互通信。但是，如果您没有在物理主机上设置IP掩蔽，则他们将无法与外部网络进行通信。 此配置被其他虚拟化软件（例如<a href="https://wiki.archlinux.org/title/VirtualBox">VirtualBox</a>）称为“仅主机网络模式”。</p>
<p><strong>提示：</strong></p>
<ul>
<li>
<p>如果你想设置IP掩蔽，例如虚拟机的NAT，请查看<a href="https://wiki.archlinux.org/title/Internet_sharing#Enable_NAT">Internet sharing#Enable NAT</a>页面。</p>
</li>
<li>
<p>您也许想在网桥接口上运行一个DHCP服务器来服务虚拟网络。例如，使用<code>172.20.0.1/16</code>子网，<a href="https://wiki.archlinux.org/title/Dnsmasq">dnsmasq</a>作为DHCP服务器:</p>
<pre tabindex="0"><code># ip addr add 172.20.0.1/16 dev br0
# ip link set br0 up
# dnsmasq --interface=br0 --bind-interfaces --dhcp-range=172.20.0.2,172.20.255.254
</code></pre></li>
</ul>
<p><strong>内部网络</strong></p>
<p>如果您不为网桥提供IP地址并在<a href="https://wiki.archlinux.org/title/Iptables">iptables</a>添加INPUT规则链，将所有流向网桥中的数据丢弃，则虚拟机将能够彼此通信，但无法与物理主机或外部网络通信。此配置被其他虚拟化软件（例如<a href="https://wiki.archlinux.org/title/VirtualBox">VirtualBox</a>）称为“内部网络”。您将需要为虚拟机分配静态IP地址，或在其中一个虚拟机上运行DHCP服务器。</p>
<p>在默认情况下，iptables将丢弃桥接网络中的数据包。您可能需要使用这样的iptables规则来允许桥接网络中的数据包:</p>
<pre tabindex="0"><code># iptables -I FORWARD -m physdev --physdev-is-bridged -j ACCEPT
</code></pre><p><strong>使用 qemu-bridge-helper 桥接网络</strong></p>
<p>这种方法不需要启动脚本，并且很容易适应多个tap和多个桥。它使用<code>/usr/lib/qemu/qemu-bridge-helper</code>，允许在现有桥上创建tap设备。</p>
<p><strong>提示：</strong> 参见 <a href="https://wiki.archlinux.org/title/Network_bridge">Network bridge</a> 获取创建网桥的信息.</p>
<p>首先，创建一个配置文件，包含QEMU使用的所有网桥的名称:</p>
<pre tabindex="0"><code>/etc/qemu/bridge.conf
allow bridge0
allow bridge1
...
</code></pre><p>现在启动虚拟机：</p>
<pre tabindex="0"><code>$ qemu-system-i386 -net nic -net bridge,br=bridge0 [...]
</code></pre><p>在多个TAP设备的情况下，最基本的用法是要为所有NIC指定VLAN：</p>
<pre tabindex="0"><code>$ qemu-system-i386 -net nic -net bridge,br=bridge0 -net nic,vlan=1 -net bridge,vlan=1,br=bridge1 [...]
</code></pre><p><strong>手工创建网桥</strong></p>
<p>将虚拟机连接到主机接口，如<code>eth0</code>，这可能是最常见的配置。这种配置使虚拟机看起来直接位于外部网络，与物理主机位于同一以太网段。</p>
<p><strong>物理设备和Tap设备之间通过iptables进行网络共享</strong></p>
<p>桥接网络能在有线接口(例如eth0)之间工作，并且很容易设置。但是，如果主机通过无线设备连接到网络，则无法进行桥接。</p>
<p>解决这个问题的一种方法是，给tap设备设置一个静态IP，使linux自动处理它的路由，然后通过iptables规则转发tap接口和连接到网络的设备之间的通信。</p>
<h4 id="通过-vde2-配置网络">通过 VDE2 配置网络<a hidden class="anchor" aria-hidden="true" href="#通过-vde2-配置网络">#</a></h4>
<p>VDE全称为Virtual Distributed Ethernet，作为uml_switch的一个扩展，是一个用于管理虚拟网络的工具包</p>
<p>其基本的思想是创建一个虚拟的开关，就如插座那样，允许虚拟机和物理机通过&quot;插入&quot;连接彼此。下面的配置非常简单，然而，VDE的功能远比展示的更强大，其能够接入虚拟开关，在不同的主机上运行它们并监听开关上的通信。</p>
<p>本方法的优点在于无需sudo特权，普通用户一般没有运行modprobe的权限。</p>
<h4 id="vde2-网桥">VDE2 网桥<a hidden class="anchor" aria-hidden="true" href="#vde2-网桥">#</a></h4>
<p>任何连接到vde上的虚拟机都会暴露给外部。举个例子，每台虚拟机都能直接从ADSL路由器那收到DHCP的配置信息。</p>
<h4 id="简化配置参数">简化配置参数<a hidden class="anchor" aria-hidden="true" href="#简化配置参数">#</a></h4>
<p>如果你经常需要以不同的网络配置选项运行QEMU，就会发现时常得输入大量的<code>-netdev</code>和<code>-device</code>选项组合，这些是大量重复性的劳动。可以用<code>-nic</code>选项将二者结合，就如下面这样，底下这些参数：</p>
<pre tabindex="0"><code>-netdev tap,id=network0,ifname=tap0,script=no,downscript=no,vhost=on -device virtio-net-pci,netdev=network0
</code></pre><p>可简化为:</p>
<pre tabindex="0"><code>-nic tap,script=no,downscript=no,vhost=on,model=virtio-net-pci
</code></pre><p>要注意的是缺失了网络ID，因此将会以<code>model=</code>创建这些设备。{ic|-nic}}命令的前半部分参数正是<code>-netdev</code>的参数，而后半部分参数（<code>model=</code>之后的部分）则与设备有关，原本设备所提供的参数同样可以在此使用（例如，可以指定<code>smb=</code>）。若要完全禁用网络，可以用<code>-nic none</code>。</p>
<h3 id="图形">图形<a hidden class="anchor" aria-hidden="true" href="#图形">#</a></h3>
<p>QEMU 可以使用一下几个图形输出：std, cirrus, vmware, qxl, xenfs 和 vnc。</p>
<p>使用 <code>vnc</code> 选项，你可以单独运行客户机，并且通过 VNC 连接。</p>
<p><strong>std</strong></p>
<p>使用 <code>-vga std</code> 你可以得到最高 2560 x 1600 像素的分辨率。从 QEMU 2.2 开始是默认选项。</p>
<p><strong>qxl</strong></p>
<p>QXL是一个支持2D的并行虚拟化图形驱动。需要在客户机中安装驱动并在启动QEMU时设置<code>-vga qxl</code>选项。你可能也会想使用<a href="https://wiki.archlinux.org/title/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#SPICE">#SPICE</a>优化QXL的图形表现。</p>
<p>在Linux客户机中，需要加载<code>qxl</code>和<code>bochs_drm</code>这两个内核模块，以获得一个比较好的效果。</p>
<p>QXL设备的默认VGA内存大小为16M，这样的内存大小最高支持QHD (2560x1440)的分辨率，如果想要一个更高的分辨率，请<a href="https://wiki.archlinux.org/title/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E5%A4%9A%E5%B1%8F%E6%94%AF%E6%8C%81">增加vga_memmb</a>。</p>
<p><strong>vmware</strong></p>
<p>尽管Bug有点多，但相比于std和cirrus它的表现会更好。对于Arch Linux客户机来说可以安装<a href="https://archlinux.org/packages/?name=xf86-video-vmware">xf86-video-vmware</a>和<a href="https://archlinux.org/packages/?name=xf86-input-vmmouse">xf86-input-vmmouse</a>获取VMware驱动。</p>
<p><strong>virtio</strong></p>
<p><code>virtio-vga</code> / <code>virtio-gpu</code> 是一个基于<a href="https://virgil3d.github.io/">virgl</a>的3D并行虚拟化图形驱动。目前依旧处于开发中，仅支持最近的（&gt;= 4.4）的Linux客户机，且需要以<code>gallium-drivers=virgl</code>选项编译<a href="https://archlinux.org/packages/?name=mesa">mesa</a> (&gt;=11.2)。</p>
<p>若要在客户机上启用3D加速，那么需要用<code>-vga virtio</code>选项选择此vga，并用<code>-display sdl,gl=on</code>或<code>-display gtk,gl=on</code>在显示设备上启用opengl上下文，这两个选项分别适用于sdl输出和gtk输出。如果配置成功了，那么在客户机的kernel log里可以看到：</p>
<pre tabindex="0"><code># dmesg | grep drm 
[drm] pci: virtio-vga detected
[drm] virgl 3d acceleration enabled
</code></pre><p><strong>cirrus</strong></p>
<p>cirrus是<a href="https://wiki.qemu.org/ChangeLog/2.2#VGA">2.2之前</a>默认的图形选项，<a href="https://www.kraxel.org/blog/2014/10/qemu-using-cirrus-considered-harmful/">不应当</a>在现代操作系统中使用它。</p>
<p><strong>none</strong></p>
<p>这就像一台完全没有VGA卡的PC，无法通过<code>-vnc</code>访问它。另外，这种情况与使用<code>-nographic</code>选项不同，<code>-nographic</code>会让QEMU模拟VGA卡，只是关闭了SDL输出。</p>
<h3 id="spice">SPICE<a hidden class="anchor" aria-hidden="true" href="#spice">#</a></h3>
<p><a href="https://www.spice-space.org/">SPICE project</a>旨在为用户提供一种完全开源的方式，无缝地对虚拟机进行远程访问。</p>
<h3 id="vnc">VNC<a hidden class="anchor" aria-hidden="true" href="#vnc">#</a></h3>
<p>可以用<code>-vnc :*X*</code>选项将QEMU的VGA输出重定向至VNC会话中。将<code>*X*</code>替换为输出目标的编号（0代表之后监听在5900，1代表监听在5901&hellip;）。</p>
<pre tabindex="0"><code>$ qemu-system-x86_64 -vnc :0
</code></pre><p><strong>警告：</strong> 默认的VNC服务器没有使用任何验证手段，用户可以从任何主机上连接到VNC。</p>
<p><strong>基本的口令验证</strong></p>
<p>可以通过使用<code>password</code>选项很容易地设置访问口令。必须在QEMU Monitor中指定口令，仅当用户提供口令时才有可能连接到VNC。</p>
<pre tabindex="0"><code>$ qemu-system-x86_64 -vnc :0,password -monitor stdio
</code></pre><p>在QEMU Monitor中设置口令需使用<code>change vnc password</code>命令，然后指定一个口令。</p>
<p>底下的命令将在启动VNC时直接为其设置口令：</p>
<pre tabindex="0"><code>$ printf &quot;change vnc password\n%s\n&quot; MYPASSWORD | qemu-system-x86_64 -vnc :0,password -monitor stdio
</code></pre><p><strong>注意：</strong> 口令被限制在8个字符内，可以用暴力破解的方式猜到口令。因此在公网上推荐使用更细致的保护措施。</p>
<h3 id="音频">音频<a hidden class="anchor" aria-hidden="true" href="#音频">#</a></h3>
<p><code>-audiodev</code>标识用于设定后端音频驱动及其相关选项。最简单的情况下，你需要选择一个驱动并设置一个id。</p>
<pre tabindex="0"><code>-audiodev pa,id=snd0
</code></pre><h4 id="使用音频设备">使用音频设备<a hidden class="anchor" aria-hidden="true" href="#使用音频设备">#</a></h4>
<p><strong>Intel HD Audio</strong></p>
<p>模拟Intel HD Audio需要添加控制器和编解码器设备。可以用如下命令列出可用的Intel HDA Audio设备：</p>
<pre tabindex="0"><code>$ qemu-system-x86_64 -device help | grep hda
</code></pre><p>添加音频控制器：</p>
<pre tabindex="0"><code>-device ich9-intel-hda
</code></pre><p>添加音频编解码器并将其映射到宿主机的音频后端id上。</p>
<pre tabindex="0"><code>-device hda-output,audiodev=snd0
</code></pre><p><strong>Intel 82801AA AC97</strong></p>
<p>模拟AC97需要添加声卡设备并将其映射到宿主机的一个音频后端id上。</p>
<pre tabindex="0"><code>-device AC97,audiodev=snd0
</code></pre><h4 id="无音频设备">无音频设备<a hidden class="anchor" aria-hidden="true" href="#无音频设备">#</a></h4>
<p>通过如下命令获取支持模拟的音频驱动列表：</p>
<pre tabindex="0"><code>$ qemu-system-x86_64 -soundhw help
</code></pre><p>比如，要在客户机上模拟<code>hda</code>驱动，需要使用<code>-device intel-hda -device hda-duplex</code>选项启动QEMU。</p>
<p><strong>注意：</strong> 客户机的显卡模拟驱动可能也会导致客户机中的音频质量出现问题，需要一个个进行排查。使用<code>qemu-system-x86_64 -h | grep vga</code>列出可用的选项</p>
<h3 id="安装-virtio-驱动">安装 virtio 驱动<a hidden class="anchor" aria-hidden="true" href="#安装-virtio-驱动">#</a></h3>
<p>QEMU为用户提供并行虚拟化块设备和网络设备的能力，其是借助<a href="https://wiki.libvirt.org/page/Virtio">virtio</a>驱动实现的，拥有更好的性能表现以及更低的开销。</p>
<p>virtio块设备需要使用<code>-drive</code>指定一个disk image的参数，且需要带上<code>if=virtio</code>参数：</p>
<pre tabindex="0"><code>$ qemu-system-x86_64 -boot order=c -drive file=disk_image,if=virtio
</code></pre><p>网络配置也是类似的：</p>
<pre tabindex="0"><code>$ qemu-system-x86_64 -nic user,model=virtio-net-pci
</code></pre><p><strong>注意：</strong> 仅有当客户机有virtio设备对应的驱动时该方法才能起效，Linux是有这方面支持的，不过无法保证这些驱动能够兼容其他操作系统。</p>
<p>以下以windows为例。</p>
<h4 id="块设备驱动">块设备驱动<a hidden class="anchor" aria-hidden="true" href="#块设备驱动">#</a></h4>
<p>Windows没有自带virtio驱动，因此需要在安装时加载该驱动。镜像文件可以从<a href="https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/stable-virtio/virtio-win.iso">Fedora 仓库</a>下载。</p>
<p>通过ISO加载只对Windows Vista和Windows Server 2008及其之后的版本有效。这个方法的具体操作是在主磁盘设备和Windows安装盘外挂载一个额外的cdrom设备，将系统镜像与virtio驱动一同加载：</p>
<pre tabindex="0"><code>$ qemu-system-x86_64 ... \
-drive file=windows_disk_image,index=0,media=disk,if=virtio \
-drive file=windows.iso,index=2,media=cdrom \
-drive file=virtio.iso,index=3,media=cdrom \
...
</code></pre><p>在安装过程中，Windows Installer会询问你“Where do you want to install Windows?”，其会返回一个警告表示没有找到任何磁盘设备。接下来跟着如下示例中的步骤进行操作（基于Windows Server 2012 R2 with Update）：</p>
<ul>
<li>Select the option <em>Load Drivers</em>.</li>
<li>Uncheck the box for <em>Hide drivers that are not compatible with this computer&rsquo;s hardware</em>.</li>
<li>Click the browse button and open the CDROM for the virtio iso, usually named &ldquo;virtio-win-XX&rdquo;.</li>
<li>Now browse to <code>E:\viostor\[your-os]\amd64</code>, select it, and confirm.</li>
</ul>
<p>现在应该能看到virtio磁盘出现在列表中了，等待着被选中、格式化并安装。</p>
<h4 id="网络驱动">网络驱动<a hidden class="anchor" aria-hidden="true" href="#网络驱动">#</a></h4>
<p>安装virtio网络驱动程序要容易一些，只需如上所述添加<code>-net</code>参数即可。</p>
<pre tabindex="0"><code>$ qemu-system-i386 -m 4G -vga std -drive file=windows_disk_image,if=virtio -net nic,model=virtio-net-pci -cdrom virtio-win-0.1-185.iso
</code></pre><p>Windows将检测网络适配器并尝试为其找到驱动程序。如果失败，请转到“设备管理器”，找到带有感叹号图标的网络适配器（双击打开），切换到驱动程序并单击“更新驱动程序”，然后选择虚拟CD-ROM。别忘了选中显示要递归搜索目录的复选框。</p>
<h4 id="balloon-驱动">Balloon 驱动<a hidden class="anchor" aria-hidden="true" href="#balloon-驱动">#</a></h4>
<p>如果想要追踪客户机内存状态（比如通过virsh的dommemstat命令）或者在运行时改变客户机内存大小（尽管依然无法改变实际的内存大小，不过可以通过inflating balloon驱动限制内存的使用），那么请在客户机上安装balloon驱动吧。</p>
<h3 id="qemu-监视器">QEMU 监视器<a hidden class="anchor" aria-hidden="true" href="#qemu-监视器">#</a></h3>
<p>QEMU运行时会提供一个监视器console界面以方便用户同虚拟机进行交互。QEMU监视器提供了许多有趣的功能，例如获取当前虚拟机的信息，热插拔设备，创建快照等。在QEMU监视器console中运行<code>help</code>或<code>?</code>命令获得完整的命令列表。</p>
<h4 id="访问qemu监视器console">访问QEMU监视器Console<a hidden class="anchor" aria-hidden="true" href="#访问qemu监视器console">#</a></h4>
<p><strong>图形化界面</strong></p>
<p>当使用默认的<code>std</code>图形选项时，可以通过按下<code>Ctrl+Alt+2</code>组合键或从QEMU窗口上的<em>View &gt; compatmonitor0</em>访问到QEMU监视器。若要返回到虚拟机的图形界面，那么按下<code>Ctrl+Alt+1</code>或者<em>View &gt; VGA</em>就行。</p>
<p>然而，这种标准的访问方式不够方便，而且并不是在QEMU的所有图形化输出方式中都适用。</p>
<p><strong>Telnet</strong></p>
<p>启动QEMU时带上<code>-monitor telnet:127.0.0.1:*port*,server,nowait</code>参数可以启用<a href="https://wiki.archlinux.org/title/Telnet">telnet</a>。虚拟机启动后可以通过telnet访问到监视器：</p>
<pre tabindex="0"><code>$ telnet 127.0.0.1 port
</code></pre><p><strong>注意：</strong> 如果指定 <code>127.0.0.1</code> 作为监听地址，那么只能在运行QEMU的宿主机上连接到该监视器。如果想要远程访问，QEMU需要在<code>0.0.0.0</code>上进行监听：<code>-monitor telnet:0.0.0.0:*port*,server,nowait</code>。还要记住的是，最好对<a href="https://wiki.archlinux.org/title/Firewall">firewall</a>进行配置，该连接是完全不进行认证和加密的，因此需要通过防火墙确保本地网络环境是可信的。</p>
<p><strong>UNIX socket</strong></p>
<p>通过<code>-monitor unix:*socketfile*,server,nowait</code>参数运行QEMU，之后就可以通过<a href="https://archlinux.org/packages/?name=socat">socat</a>或<a href="https://archlinux.org/packages/?name=openbsd-netcat">openbsd-netcat</a>连接到监视器上。</p>
<p>例如，如果QEMU是通过如下命令启动：</p>
<pre tabindex="0"><code>$ qemu-system-x86_64 [...] -monitor unix:/tmp/monitor.sock,server,nowait [...]
</code></pre><p>就可以像这样连接到监视器上：</p>
<pre tabindex="0"><code>$ socat - UNIX-CONNECT:/tmp/monitor.sock
</code></pre><p>或者通过这种方式:</p>
<pre tabindex="0"><code>$ nc -U /tmp/monitor.sock
</code></pre><p><strong>TCP</strong></p>
<p>可以使用<code>-monitor tcp:127.0.0.1:*port*,server,nowait</code>参数将监视器暴露于TCP端口上，然后用netcat（<a href="https://archlinux.org/packages/?name=openbsd-netcat">openbsd-netcat</a>或<a href="https://archlinux.org/packages/?name=gnu-netcat">gnu-netcat</a>都可）进行连接：</p>
<pre tabindex="0"><code>$ nc 127.0.0.1 port
</code></pre><p><strong>注意：</strong> 为了能够从其它设备上通过TCP socket访问到监视器，而不仅仅从运行QEMU的主机上连接，需要像前面Telnet中描述的那样，在<code>0.0.0.0</code>地址上进行监听。</p>
<p><strong>标准 I/O</strong></p>
<p>如果以<code>-monitor stdio</code>参数运行QEMU，那么其实是可以在运行QEMU的终端下访问到监视器的。</p>
<h4 id="在monitor-conosle下向虚拟机发送按键行为">在Monitor conosle下向虚拟机发送按键行为<a hidden class="anchor" aria-hidden="true" href="#在monitor-conosle下向虚拟机发送按键行为">#</a></h4>
<p>由于在某些配置下，宿主机可能会拦截一些按键组合另作他用，这导致要在虚拟机中触发一些特定按键组合变得有些困难（一个显然的例子就是<code>Ctrl+Alt+F*</code>组合，该组合用于改变当前的tty）。我们采用在monitor console下发送按键组合的方式解决该问题。只需切换到monitor console下，然后使用<code>sendkey</code>命令，即可将按键转发至虚拟机中，例如：</p>
<pre tabindex="0"><code>(qemu) sendkey ctrl-alt-f2
</code></pre><h4 id="通过-monitor-console-创建快照和管理快照">通过 monitor console 创建快照和管理快照<a hidden class="anchor" aria-hidden="true" href="#通过-monitor-console-创建快照和管理快照">#</a></h4>
<p><strong>注意：</strong> 该特性&quot;只&quot;支持<em>qcow2</em>格式的虚拟机磁盘镜像，对于<em>raw</em>是无效的。</p>
<p>有时候我们很需要将虚拟机的当前状态进行保存，或是将虚拟机重置到之前的快照状态，而且最好是随时能进行这些操作。QEMU monitor console为用户提供了必要的功能，进行快照创建，快照管理，以及快照恢复。</p>
<ul>
<li>Use <code>savevm name</code> 用于创建一个名为<em>name</em>的快照。</li>
<li>Use <code>loadvm name</code> 用于将虚拟机状态恢复至快照<em>name</em>。</li>
<li>Use <code>delvm name</code> 用于删除快照<em>name</em>。</li>
<li>Use <code>info snapshots</code> 用于查看保存的快照列表，这些快照由一个自增长的ID和标签名（用户创建快照时赋予）进行标识。</li>
</ul>
<h4 id="以冻结模式运行虚拟机">以冻结模式运行虚拟机<a hidden class="anchor" aria-hidden="true" href="#以冻结模式运行虚拟机">#</a></h4>
<p>QEMU支持以冻结态运行虚拟机（需使用<code>-snapshot</code>参数），换句话说，虚拟机关闭时，对于虚拟机的一切修改都会丢弃。当用户对磁盘镜像写入时，这些变动最终写入的位置是<code>/tmp</code>目录下的一个临时文件，QEMU关机时将会把他们丢弃。</p>
<p>不过，即使虚拟机运行于冻结状态下，依旧可以通过monitor console将这些变化写入磁盘镜像（如果你想的话）。使用下面的命令：</p>
<pre tabindex="0"><code>(qemu) commit all
</code></pre><p>另外如果在冻结状态下创建快照，这些快照在QEMU退出时都会被丢弃，除非你显式地commit了他们。</p>
<h4 id="monitor-console中的开机和暂停命令">monitor console中的开机和暂停命令<a hidden class="anchor" aria-hidden="true" href="#monitor-console中的开机和暂停命令">#</a></h4>
<p>在QEMU monitor console下也可以模拟对物理机的一些操作：</p>
<ul>
<li><code>system_powerdown</code> 会向虚拟机发送ACPI关机信号，效果就类似物理机上按下电源按钮。</li>
<li><code>system_reset</code> 会重置虚拟机，类似物理机上的重置按钮。该操作可能导致数据丢失或文件系统的损坏，这是因为虚拟机并不是&quot;干净地&quot;重启的。</li>
<li><code>stop</code> 会暂停虚拟机。</li>
<li><code>cont</code> 使暂停的虚拟机恢复运行。</li>
</ul>
<h4 id="虚拟机截屏">虚拟机截屏<a hidden class="anchor" aria-hidden="true" href="#虚拟机截屏">#</a></h4>
<p>可以在monitor console下运行该命令，获取PPM格式的截屏图片：</p>
<pre tabindex="0"><code>(qemu) screendump file.ppm
</code></pre><h3 id="qemu-机器协议">QEMU 机器协议<a hidden class="anchor" aria-hidden="true" href="#qemu-机器协议">#</a></h3>
<p>QEMU机器协议（QMP）是一个基于JSON格式的协议，使得其他应用程序可以通过该协议控制QEMU实例。类似<a href="https://wiki.archlinux.org/title/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#QEMU_%E7%9B%91%E8%A7%86%E5%99%A8">#QEMU 监视器</a>，其提供了与运行中的虚拟机进行交互的能力，且能够编程进行控制。关于QMP各命令的描述可以在这个<a href="https://raw.githubusercontent.com/coreos/qemu/master/qmp-commands.hx">qmp-commands</a>链接中找到。</p>
<h3 id="技巧-1">技巧<a hidden class="anchor" aria-hidden="true" href="#技巧-1">#</a></h3>
<h4 id="改善虚拟机的性能表现">改善虚拟机的性能表现<a hidden class="anchor" aria-hidden="true" href="#改善虚拟机的性能表现">#</a></h4>
<p>底下是一些可以改善虚拟机性能表现的技术，例如：</p>
<ul>
<li>
<p>启用<a href="https://wiki.archlinux.org/title/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E5%90%AF%E7%94%A8_KVM">#启用 KVM</a>：QEMU的启动命令加上<code>-enable-kvm</code>选项。</p>
</li>
<li>
<p>通过<code>-cpu host</code>选项让QEMU模拟宿主机上的特定CPU，如果没有该选项QEMU尝试模拟的是一个更为通用的CPU。</p>
</li>
<li>
<p>特别的，如果客户机是Windows，启用<a href="https://blog.wikichoon.com/2014/07/enabling-hyper-v-enlightenments-with-kvm.html">Hyper-V enlightenments</a>可以改善性能：<code>-cpu host,hv_relaxed,hv_spinlocks=0x1fff,hv_vapic,hv_time</code>.</p>
</li>
<li>
<p>如果宿主机有多个核心，可以用<code>-smp</code>选项为客户机分配更多核心。</p>
</li>
<li>
<p>检查是否为虚拟机分配的足够的内存。默认情况下，QEMU仅仅为每台虚拟机分配128MiB的内存，可以使用<code>-m</code>选项分配更多的内存。例如，<code>-m 1024</code>代表启动一台内存为1024MiB的虚拟机。</p>
</li>
<li>
<p>如果客户机操作系统支持相关的驱动，可以使用<a href="https://wiki.libvirt.org/page/Virtio">virtio</a>创建网络设备或块设备。</p>
</li>
<li>
<p>使用TAP设备代替user-mode网络，参阅<a href="https://wiki.archlinux.org/title/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#Tap_%E7%BD%91%E7%BB%9C">#Tap 网络</a>。</p>
</li>
<li>
<p>如果客户机需要进行大量的磁盘写工作，在宿主机文件系统上设置合适的挂载选项可以优化该工作。例如，可以用<code>barrier=0</code>选项挂载一个<a href="https://wiki.archlinux.org/title/Ext4">ext4 file system</a>。在使用这些性能强化选项之前最好阅读相关文档，因为性能上的提升通常伴随着数据完整性下降的代价。</p>
</li>
<li>
<p>如果有一块原始磁盘镜像，你可能会想要禁用cache：</p>
<pre tabindex="0"><code>$ qemu-system-x86_64 -drive file=disk_image,if=virtio,cache=none
</code></pre></li>
<li>
<p>使用原生的Linux AIO：</p>
<pre tabindex="0"><code>$ qemu-system-x86_64 -drive file=disk_image,if=virtio,aio=native,cache.direct=on
</code></pre></li>
<li>
<p>如果正同时运行多台虚拟机，而它们拥有同样的操作系统，可以通过启用<a href="https://en.wikipedia.org/wiki/Kernel_SamePage_Merging_(KSM)">内核页归并</a>节省内存。参阅<a href="https://wiki.archlinux.org/title/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E5%BC%80%E5%90%AFKSM">#开启KSM</a>。</p>
</li>
<li>
<p>在一些情况下，可以在运行时从安装了balloon驱动的客户机上回收内存，这需要QEMU启动该客户机时使用<code>-device virtio-balloon</code>选项。</p>
</li>
<li>
<p>允许使用一个ICH-9 AHCI控制器的仿真层，尽管它并不稳定。AHCI的仿真模拟支持<a href="https://en.wikipedia.org/wiki/Native_Command_Queuing">NCQ</a>，因此可以同时处理多个读写请求：</p>
<pre tabindex="0"><code>$ qemu-system-x86_64 -drive id=disk,file=disk_image,if=none -device ich9-ahci,id=ahci -device ide-drive,drive=disk,bus=ahci.0
</code></pre></li>
</ul>
<p>参阅 <a href="https://www.linux-kvm.org/page/Tuning_KVM">https://www.linux-kvm.org/page/Tuning_KVM</a> 获取更多信息</p>
<h4 id="开机时启动qemu虚拟机">开机时启动QEMU虚拟机<a hidden class="anchor" aria-hidden="true" href="#开机时启动qemu虚拟机">#</a></h4>
<p><strong>通过libvirt实现</strong></p>
<p>如果虚拟机是通过<a href="https://wiki.archlinux.org/title/Libvirt">libvirt</a>设置的，可以用<code>virsh autostart</code>将其配置为开机自启，或者通过<em>virt-manager</em>GUI中虚拟机的Boot Options，选择&quot;Start virtual machine on host boot up&quot;实现开机自启。</p>
<p><strong>通过systemd service实现</strong></p>
<p>可以用如下的systemd unit和config配置开机时启动QEMU VM。</p>
<pre tabindex="0"><code>/etc/systemd/system/qemu@.service
[Unit]
Description=QEMU virtual machine

[Service]
Environment=&quot;haltcmd=kill -INT $MAINPID&quot;
EnvironmentFile=/etc/conf.d/qemu.d/%i
ExecStart=/usr/bin/qemu-system-x86_64 -name %i -enable-kvm -m 512 -nographic $args
ExecStop=/bin/bash -c ${haltcmd}
ExecStop=/bin/bash -c 'while nc localhost 7100; do sleep 1; done'

[Install]
WantedBy=multi-user.target
</code></pre><p><strong>注意：</strong> 为了方便地结束任务，该service会等待至console端口被释放（这意味着VM已被关闭）。</p>
<p>接着创建per-VM配置文件，命名为<code>/etc/conf.d/qemu.d/*vm_name*</code>，在其中设置好<code>args</code>和<code>haltcmd</code>变量，配置示例：</p>
<pre tabindex="0"><code>/etc/conf.d/qemu.d/one
args=&quot;-hda /dev/vg0/vm1 -serial telnet:localhost:7000,server,nowait,nodelay \
 -monitor telnet:localhost:7100,server,nowait,nodelay -vnc :0&quot;

haltcmd=&quot;echo 'system_powerdown' | nc localhost 7100&quot; # or netcat/ncat
/etc/conf.d/qemu.d/two
args=&quot;-hda /srv/kvm/vm2 -serial telnet:localhost:7001,server,nowait,nodelay -vnc :1&quot;

haltcmd=&quot;ssh powermanager@vm2 sudo poweroff&quot;
</code></pre><p>对该变量的描述如下：</p>
<ul>
<li><code>args</code> - 使用的QEMU命令行参数。</li>
<li><code>haltcmd</code> - 安全关闭虚拟机的命令，在第一个例子中，QEMU monitor是通过<code>-monitor telnet:..</code>选项暴露至telnet，因而关闭虚拟机是通过<code>nc</code>命令在monitor console中发送<code>system_powerdown</code>，完成ACPI关机的工作。在另一个例子里，使用的则是SSH。</li>
</ul>
<p>若要设置启动时运行哪个虚拟机，enable <code>qemu@*vm_name*.service</code>这个systemd单元</p>
<h4 id="鼠标整合">鼠标整合<a hidden class="anchor" aria-hidden="true" href="#鼠标整合">#</a></h4>
<p>添加<code>-usb -device usb-tablet</code>选项以避免点击客户机系统的窗口时鼠标被捕获。该选项代表QEMU能够在不捕获鼠标的情况下，向系统报告鼠标的位置，该选项启用时还会覆盖PS/2鼠标模拟功能。 命令示例：</p>
<pre tabindex="0"><code>$ qemu-system-x86_64 -hda disk_image -m 512 -usb -device usb-tablet
</code></pre><h4 id="宿主机的usb设备传递至虚拟机">宿主机的USB设备传递至虚拟机<a hidden class="anchor" aria-hidden="true" href="#宿主机的usb设备传递至虚拟机">#</a></h4>
<p>从客户机访问连接到宿主机USB口的设备是可能的，首先需要识别设备连接的位置，可以用<code>lsusb</code>命令找到设备连接位置，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ lsusb
...
Bus <span style="color:#ae81ff">003</span> Device 007: ID 0781:5406 SanDisk Corp. Cruzer Micro U3
</code></pre></div><p>上面以显示的数字分别用于标识</p>
<ul>
<li>003 host_bus</li>
<li>007 host_addr</li>
<li>0781 vendor_id</li>
<li>5406 product_id</li>
</ul>
<p>基本的思想是在QEMU中<code>-device usb-ehci,id=ehci</code>或<code>-device qemu-xhci,id=xhci</code>分别对EHCI (USB 2)或XHCI (USB 3)（在win7无法自动安装 USB3 驱动，因此应用 USB2）控制器进行模拟，然后将物理设备通过<code>-device usb-host,..</code>选项进行添加。</p>
<p>识别出该设备，并将其连接至任一总线以及宿主机上的地址，通用的语法如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">-device usb-host,bus<span style="color:#f92672">=</span>controller_id.0,vendorid<span style="color:#f92672">=</span>0xvendor_id,productid<span style="color:#f92672">=</span>0xproduct_id
</code></pre></div><p>应用于上面例子中使用的设备，它变成：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">-device usb-ehci,id<span style="color:#f92672">=</span>ehci -device usb-host,bus<span style="color:#f92672">=</span>ehci.0,vendorid<span style="color:#f92672">=</span>0x0781,productid<span style="color:#f92672">=</span>0x5406
</code></pre></div><p>运行QEMU时会遇到 <code>libusb couldn't open USB device Permission denied</code> 权限错误，可以通过 <a href="https://wiki.archlinux.org/title/Udev#About_udev_rules">udev</a> 为设备设定合适的权限。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ vi /etc/udev/rules.d/50-usbtinyisp.rules
SUBSYSTEMS<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;usb&#34;</span>, ATTRS<span style="color:#f92672">{</span>idVendor<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;0781&#34;</span>, ATTRS<span style="color:#f92672">{</span>idProduct<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;5406&#34;</span>, GROUP<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;vane&#34;</span>, MODE<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;0660&#34;</span>

$ ls -al /dve/bus/usb/003/007
crw-rw---- <span style="color:#ae81ff">1</span> root vane 189, <span style="color:#ae81ff">11</span> Nov  <span style="color:#ae81ff">7</span> 12:37 /dev/bus/usb/003/007
</code></pre></div><h4 id="使用spice进行usb重定向">使用SPICE进行USB重定向<a hidden class="anchor" aria-hidden="true" href="#使用spice进行usb重定向">#</a></h4>
<p>使用<a href="https://wiki.archlinux.org/title/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#SPICE">#SPICE</a>时可以将USB设备从客户端重定向至虚拟机中，无需使用QEMU命令。还支持为配置USB重定向插槽数（插槽数将决定可同时重定向的最大设备数）。相比于前面那种使用<code>-usbdevice</code>进行重定向的方法，SPICE方法的优势在于可以在虚拟机启动后USB设备热插拔，移除或添加USB设备时无需停机。这个方法还允许通过网络将客户端的USB设备重定向至服务端。总之，其是在QEMU虚拟机中使用USB设备最灵活的方法。</p>
<h4 id="开启ksm">开启KSM<a hidden class="anchor" aria-hidden="true" href="#开启ksm">#</a></h4>
<p>Kernel Samepage Merging (KSM) 是Linux内核的一个特性，允许应用程序向内核申请同其他申请页归并的进程进行页归并，KSM机制允许客户虚拟机之间进行页共享。当许多客户机运行相似的操作系统时，这个机制可以节省客观的内存。</p>
<h4 id="多屏支持">多屏支持<a hidden class="anchor" aria-hidden="true" href="#多屏支持">#</a></h4>
<p>Linux的QXL驱动支持默认支持四头（虚拟屏幕），可以通过<code>qxl.heads=N</code>这一内核参数进行变更。</p>
<h4 id="复制和粘贴">复制和粘贴<a hidden class="anchor" aria-hidden="true" href="#复制和粘贴">#</a></h4>
<p>在宿主机和客户机之间共享剪贴板的方法之一是使用SPICE远程桌面协议，通过SPICE客户端访问客户机，你需要遵照<a href="https://wiki.archlinux.org/title/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#SPICE">#SPICE</a>节中描述的步骤，通过该方式运行的客户机将支持与宿主机进行复制粘贴的操作。</p>
<h3 id="libvirthttpswikiarchlinuxorgtitlelibvirt_e7ae80e4bd93e4b8ade69687"><a href="https://wiki.archlinux.org/title/Libvirt_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">libvirt</a><a hidden class="anchor" aria-hidden="true" href="#libvirthttpswikiarchlinuxorgtitlelibvirt_e7ae80e4bd93e4b8ade69687">#</a></h3>
<p>Libvirt 是一组软件的汇集，提供了管理虚拟机和其它虚拟化功能（如：存储和网络接口等）的便利途径。这些软件包括：一个长期稳定的 C 语言 API、一个守护进程（libvirtd）和一个命令行工具（virsh）。Libvirt 的主要目标是提供一个单一途径以管理多种不同虚拟化方案以及虚拟化主机，<a href="https://libvirt.org/drivers.html">包括</a>：KVM/QEMU，Xen，LXC，OpenVZ 或 VirtualBox hypervisors。</p>
<p>Libvirt 的一些主要功能如下：</p>
<ul>
<li><strong>VM management（虚拟机管理）</strong>：各种虚拟机生命周期的操作，如：启动、停止、暂停、保存、恢复和迁移等；多种不同类型设备的热插拔操作，包括磁盘、网络接口、内存、CPU等。</li>
<li><strong>Remote machine support（支持远程连接）</strong>：Libvirt 的所有功能都可以在运行着 libvirt 守护进程的机器上执行，包括远程机器。通过最简便且无需额外配置的 SSH 协议，远程连接可支持多种网络连接方式。</li>
<li><strong>Storage management（存储管理）</strong>：任何运行 libvirt 守护进程的主机都可以用于管理多种类型的存储：创建多种类型的文件镜像（qcow2，vmdk，raw，&hellip;），挂载 NFS 共享，枚举现有 LVM 卷组，创建新的 LVM 卷组和逻辑卷，对裸磁盘设备分区，挂载 iSCSI 共享，以及更多&hellip;&hellip;</li>
<li><strong>Network interface management（网络接口管理）</strong>：任何运行 libvirt 守护进程的主机都可以用于管理物理的和逻辑的网络接口，枚举现有接口，配置（和创建）接口、桥接、VLAN、端口绑定。</li>
<li><strong>Virtual NAT and Route based networking（虚拟 NAT 和基于路由的网络）</strong>：任何运行 libvirt 守护进程的主机都可以管理和创建虚拟网络。Libvirt 虚拟网络使用防火墙规则实现一个路由器，为虚拟机提供到主机网络的透明访问。</li>
</ul>
<h4 id="安装httpsubuntucomserverdocsvirtualization-libvirt"><a href="https://ubuntu.com/server/docs/virtualization-libvirt">安装</a><a hidden class="anchor" aria-hidden="true" href="#安装httpsubuntucomserverdocsvirtualization-libvirt">#</a></h4>
<p>基于守护进程/客户端的架构的 libvirt 只需要安装在需要要实现虚拟化的机器上。注意，服务器和客户端可以是相同的物理机器。</p>
<p><strong>服务端</strong></p>
<p>安装 libvirt 以及至少一个虚拟运行环境（hypervisor）：<a href="https://libvirt.org/drvqemu.html">libvirt 的 KVM/QEMU 驱动</a> 是 <em>libvirt</em> 的首选驱动，如果 KVM 功能已启用，则支持全虚拟化和硬件加速的客户机。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt update
$ sudo apt install qemu-kvm libvirt-daemon-system
</code></pre></div><p>安装 libvirt-daemon-system 后，需要将用于管理虚拟机的用户添加到<em>libvirt</em>组中。这对于 sudo 组的成员是自动完成的，但对于应该访问系统范围的 libvirt 资源的其他任何人，都需要另外完成。这样做将授予用户访问高级网络选项的权限。</p>
<p>在终端中输入：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo adduser $USER libvirt
</code></pre></div><p>如果选择的用户是当前用户，您需要注销并重新登录才能使新的组成员身份生效。</p>
<p><strong>客户端</strong></p>
<p>客户端是用于管理和访问虚拟机的用户界面。</p>
<ul>
<li><strong>virsh</strong> — <em>virsh</em> 是用于管理和配置域（虚拟机）的命令行程序。</li>
<li><strong><a href="https://en.wikipedia.org/wiki/Virtual_Machine_Manager">Virtual Machine Manager</a></strong> — 使用libvirt对KVM，Xen，LXC进行管理的图形化工具。</li>
</ul>
<h4 id="配置-1">配置<a hidden class="anchor" aria-hidden="true" href="#配置-1">#</a></h4>
<p>对于<em><strong>系统</strong></em> 级别的管理任务（如：全局配置和镜像<em>卷</em> 位置），libvirt 要求至少要设置授权和启动守护进程。</p>
<p><strong>注意：</strong> 对于用户<em><strong>会话</strong></em> 级别的管理任务，守护进程的安装和设置<em>不是</em> 必须的。授权总是仅限本地，前台程序将启动一个 <strong>libvirtd</strong> 守护进程的本地实例。</p>
<h5 id="设置授权">设置授权<a hidden class="anchor" aria-hidden="true" href="#设置授权">#</a></h5>
<p>自 <a href="https://libvirt.org/auth.html#ACL_server_config">libvirt：连接授权</a>：Libvirt 守护进程允许管理员分别为客户端连接的每个网络 socket 选择不同授权机制。这主要是通过 libvirt 守护进程的主配置文件 <code>/etc/libvirt/libvirtd.conf</code> 来实现的。每个 libvirt socket 可以有独立的授权机制配置。目前的可选项有 <code>none</code>、<code>polkit</code> 和 <code>sasl</code>。</p>
<p>由于 libvirt 在安装时将把 polkit 作为依赖一并安装，所以 polkit 通常是 <code>unix_sock_auth</code> 参数的默认值。但基于文件的权限仍然可用。</p>
<p><strong>使用 polkit</strong></p>
<p><strong>注意：</strong> 为使 <code>polkit</code> 认证工作正常，应该重启一次系统。</p>
<p><em>libvirt</em> 守护进程在 polkit 策略配置文件（<code>/usr/share/polkit-1/actions/org.libvirt.unix.policy</code>）中提供了两种<strong>策略</strong>：</p>
<ul>
<li><code>org.libvirt.unix.manage</code> 面向完全的管理访问（读写模式后台 socket），以及</li>
<li><code>org.libvirt.unix.monitor</code> 面向仅监视察看访问（只读 socket）。</li>
</ul>
<p>默认的面向读写模式后台 socket 的策略将请求认证为管理员。这点类似于 sudo 认证，但它并不要求客户应用最终以 root 身份运行。默认策略下也仍然允许任何应用连接到只读 socket。</p>
<p><strong>基于文件的权限授权</strong></p>
<p>为了给 <em>libvirt</em> 组用户定义基于文件的权限以管理虚拟机，取消下列行的注释：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ vim /etc/libvirt/libvirtd.conf
<span style="color:#75715e">#unix_sock_group = &#34;libvirt&#34;</span>
<span style="color:#75715e">#unix_sock_ro_perms = &#34;0777&#34;  # set to 0770 to deny non-group libvirt users</span>
<span style="color:#75715e">#unix_sock_rw_perms = &#34;0770&#34;</span>
<span style="color:#75715e">#auth_unix_ro = &#34;none&#34;</span>
<span style="color:#75715e">#auth_unix_rw = &#34;none&#34;</span>
</code></pre></div><p>有些资料提到可以通过改变某些特定 libvirt 目录的权限以简化管理。需要记住的是：包更新时，这些变更会丢失。如要修改这些系统目录的权限，需要 root 用户权限。</p>
<h5 id="守护进程">守护进程<a hidden class="anchor" aria-hidden="true" href="#守护进程">#</a></h5>
<p><code>libvirtd.service</code> 和 <code>virtlogd.service</code>这两个服务单元都要启动。可以把 <code>libvirtd.service</code> 设置为启用，这时系统将同时启用 <code>virtlogd.service</code> 和 <code>virtlockd.socket</code> 两个服务单元，因此后二者不必再设置为<strong>启用</strong>。</p>
<h4 id="测试">测试<a hidden class="anchor" aria-hidden="true" href="#测试">#</a></h4>
<p>测试 libvirt 在<em>系统</em>级工作是否正常：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ virsh -c qemu:///system
</code></pre></div><p>测试 libvirt 在用户<em>会话</em>级工作是否正常：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ virsh -c qemu:///session
</code></pre></div><h4 id="管理">管理<a hidden class="anchor" aria-hidden="true" href="#管理">#</a></h4>
<p>绝大部分的 libvirt 管理可以通过三个工具实现：<code>virt-manager</code>（图形界面）、<code>virsh</code> 和 <code>guestfish</code>（它是 <code>libguestfs</code> 的一部分）。</p>
<h5 id="virsh">virsh<a hidden class="anchor" aria-hidden="true" href="#virsh">#</a></h5>
<p>Visrsh 用于管理客户<em>域</em>（虚拟机），在脚本式虚拟化管理环境中工作良好。由于需要通过通讯管道与虚拟运行环境通讯，绝大部分 virsh 命令需要管理员权限。尽管如此，一些典型的管理操作如域的创建、运行等也可以像VirtualBox 那样以普通用户身份执行。</p>
<p>Virsh 允许带命令行选项执行。如果不带则进入其内置的交互式终端：<code>virsh</code>。交互式终端支持 tab 键命令补全。</p>
<p>从命令行执行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ virsh <span style="color:#f92672">[</span>可选项<span style="color:#f92672">]</span> &lt;命令&gt; <span style="color:#f92672">[</span>参数<span style="color:#f92672">]</span>...
</code></pre></div><p>在交互式终端里运行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">virsh <span style="color:#75715e"># &lt;命令&gt; [参数]...</span>
</code></pre></div><p>帮助也是可用的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ virsh help <span style="color:#f92672">[</span>option*<span style="color:#f92672">]</span> or <span style="color:#f92672">[</span>group-keyword*<span style="color:#f92672">]</span>
</code></pre></div><h5 id="存储池">存储池<a hidden class="anchor" aria-hidden="true" href="#存储池">#</a></h5>
<p>存储池是指保存<em>卷</em>的位置。Libvirt 中<em>卷</em>的定义相当于其他系统中<em>虚拟磁盘</em>或<em>虚拟机镜像</em>的概念。存储池应该是一个目录、一个网络文件系统或一个分区（此处包括 LVM）。存储池可以在活动与不活动之间切换，可以为其分配存储空间。</p>
<p>以下示例为<em>添加</em>存储池、目录和 LVM 卷的方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ virsh pool-define-as name type <span style="color:#f92672">[</span>source-host<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>source-path<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>source-dev<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>source-name<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>&lt;target&gt;<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>--source-format format<span style="color:#f92672">]</span>
$ virsh pool-define-as poolname dir - - - - /home/username/.local/libvirt/images
$ virsh pool-define-as poolname fs - -  /dev/vg0/images - mntpoint
</code></pre></div><p>上述示例仅仅定义了存储池的信息，下面创建它：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ virsh pool-build     poolname
$ virsh pool-start     poolname
$ virsh pool-autostart poolname
</code></pre></div><p>删除它的命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ virsh pool-undefine  poolname
</code></pre></div><p><strong>提示：</strong> 对于 LVM 存储池而言：</p>
<ul>
<li>最佳实践是仅把一个卷组分配给一个存储池。</li>
<li>请为存储池选择一个与 LVM 卷组不同的名字。否则当存储池被删除时，该卷组也将被删除。</li>
</ul>
<p><strong>用 virt-manager 新建存储池</strong></p>
<p>首先，连接到虚拟运行环境（例如QEMU/KVM的系统/用户会话）。然后，右键点击一个<strong>连接</strong>（例如<strong>QEMU/KVM</strong>）选择<strong>详情</strong>，切换到<strong>存储</strong>选项卡，点击左下角的**+**，按照向导操作。</p>
<h5 id="存储卷">存储卷<a hidden class="anchor" aria-hidden="true" href="#存储卷">#</a></h5>
<p>存储池被创建之后，就可以在存储池中创建存储卷。如果你想新建一个域（虚拟机），那么这一步可以跳过，因为这一步可以在创建域的过程中完成。</p>
<p><strong>用 virsh 新建卷</strong></p>
<p>新建卷，列出卷，变更卷大小，删除卷：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ virsh vol-create-as      poolname volumename 10GiB --format aw|bochs|raw|qcow|qcow2|vmdk
$ virsh vol-upload  --pool poolname volumename volumepath
$ virsh vol-list           poolname
$ virsh vol-resize  --pool poolname volumename 12GiB
$ virsh vol-delete  --pool poolname volumename
$ virsh vol-dumpxml --pool poolname volumename  <span style="color:#75715e"># for details.</span>
</code></pre></div><h5 id="域">域<a hidden class="anchor" aria-hidden="true" href="#域">#</a></h5>
<p>虚拟机被称作**“域”**。如果你想在命令行下操作，使用<code>virsh</code>列出，创建，暂停，关闭……域。<code>virt-viewer</code>可以用来查看使用<code>virsh</code>启动的域。域的创建通常以图形化的<code>virt-manager</code>或者命令行下的<code>virt-install</code>完成。 创建新域通常需要安装媒介，例如存储池中的<code>iso</code>文件或是直接从光驱安装。</p>
<p>列出活动的和不活动的域：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># virsh list --all</span>
</code></pre></div><p><strong>用 virt-install 新建域</strong></p>
<p>对于很详细的域（虚拟机）配置，可以用 virt-manager 新建域更简单地完成。但是，基础配置同样可以用<code>virt-install</code>完成并且同样运行顺利。至少要配置<code>--name</code>, <code>--memory</code>, 存储(<code>--disk</code>, <code>--filesystem</code>,或<code>--nodisks</code>),和安装方法（通常来说是<code>.iso</code>文件或CD）。查看<a href="https://man.archlinux.org/man/virt-install.1">virt-install(1)</a>得到未列出的选项和更多的详情。</p>
<p>Windows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ virt-install <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  --name<span style="color:#f92672">=</span>windows7           <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  --memory <span style="color:#ae81ff">2048</span>             <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  --cdrom /dev/sr0          <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  --os-variant<span style="color:#f92672">=</span>win7         <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  --disk /mnt/storage/domains/windows7.qcow2,size<span style="color:#f92672">=</span>20GiB <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  --network network<span style="color:#f92672">=</span>vm-net  <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  --graphics spice
</code></pre></div><p>导入现有的卷：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ virt-install  <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  --name demo  <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  --memory <span style="color:#ae81ff">512</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  --disk /home/user/VMs/mydisk.img <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  --import
</code></pre></div><p><strong>用 virt-manager 新建域</strong></p>
<p>首先，连接到虚拟运行环境（例如 QEMU/KVM <em>system</em> 或用户 <em>session</em>，在连接上右击并选择 <em>新建</em>，然后跟随向导完成。</p>
<ul>
<li>在<strong>第四步</strong>中取消选中<strong>立即分配全部虚拟磁盘空间</strong>会加快创建过程并节省实际虚拟磁盘空间占用；<strong>然而</strong>，这将导致将来花费额外的磁盘整理时间。</li>
<li>在<strong>第五步</strong>中打开<strong>高级选项</strong>并确认<strong>虚拟化类型</strong>设为 <strong>kvm</strong>（这通常是首选模式）。如果要求附加的硬件配置，选中<strong>安装前定制</strong>选项。</li>
</ul>
<p><strong>管理域</strong></p>
<p>启动域：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ virsh start domain
$ virt-viewer --connect qemu:///session domain
</code></pre></div><p>正常关闭域；强制关闭域:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ virsh shutdown domain
$ virsh destroy  domain
</code></pre></div><p>在libvirtd启动时自动启动域:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ virsh autostart domain
$ virsh autostart domain --disable
</code></pre></div><p>在宿主机关闭时自动关闭域:</p>
<p>使用<code>libvirt-guests.service</code>Systemd服务，运行中的域可以在宿主机关闭时自动挂起/关闭。同时这个服务还可以让挂起/休眠的域在宿主机启动的时候自动恢复。查看<code>/etc/conf.d/libvirt-guests</code>并设置相关选项。</p>
<p>编辑一个域的XML配置：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ virsh edit domain
</code></pre></div><p><strong>注意：</strong> 直接被QEMU启动的虚拟机不被libvirt管理。</p>
<h5 id="网络-2">网络<a hidden class="anchor" aria-hidden="true" href="#网络-2">#</a></h5>
<p><a href="https://jamielinux.com/docs/libvirt-networking-handbook/">这里</a>是有关 libvirt 网络的一个正宗的概述。</p>
<p>默认情况下，当 <code>libvirtd</code> 服务启动后，即创建了一个名为 <em>default</em> 的 NAT 网桥与外部网络联通（仅 IPv4）。对于其他的网络连接需求，可创建下列四种类型的网络以连接到虚拟机：</p>
<ul>
<li>bridge — 这是一个虚拟设备，它通过一个物理接口直接共享数据。使用场景为：宿主机有 <em>静态</em> 网络、不需与其它域连接、要占用全部进出流量，并且域运行于 <em>系统</em> 层级。有关如何在现有默认网桥时增加另一个网桥的方法，请参阅 <a href="https://wiki.archlinux.org/title/%E7%BD%91%E6%A1%A5">网桥</a>。网桥创建后，需要将它指定到相应客户机的 <code>.xml</code> 配置文件中。</li>
<li>network — 这是一个虚拟网络，它可以与其它虚拟机共用。使用场景为：宿主机有 <em>动态</em> 网络（例如：NetworkManager）或使用无线网络。</li>
<li>macvtap — 直接连接到宿主机的一个物理网络接口。</li>
<li>user — 本地网络，仅用于用户 <em>会话</em>。</li>
</ul>
<p>绝大多数用户都可以通过 <code>virsh</code> 的各种可选项创建具有各种功能的网络，一般来说比通过 GUI 程序（像 <code>virt-manager</code> 之类）更容易做到。也可以按用 virt-install 新建域 所述实现。</p>
<p><strong>注意：</strong> libvirt 通过 dnsmasq 处理 DHCP 和 DNS 请求，以启动每个虚拟网络的不同实例。也会为特定的路由添加 iptables 规则并启用 <code>ip_forward</code> 内核参数。这也意味着宿主机上已运行的dnsmasq并不是libvirt所必须的（并可能干扰到libvirt的dnsmasq实例）。</p>
<h4 id="uefi-支持">UEFI 支持<a hidden class="anchor" aria-hidden="true" href="#uefi-支持">#</a></h4>
<p>Libvirt 可以通过 qemu 和 <a href="https://github.com/tianocore/edk2">OVMF</a> 来支持 UEFI 虚拟机。 安装 ovmf 。 添加下面的内容到 <code>/etc/libvirt/qemu.conf</code> 。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ vim /etc/libvirt/qemu.conf
nvram <span style="color:#f92672">=</span> <span style="color:#f92672">[</span>
    <span style="color:#e6db74">&#34;/usr/share/ovmf/x64/OVMF_CODE.fd:/usr/share/ovmf/x64/OVMF_VARS.fd&#34;</span>
<span style="color:#f92672">]</span>
</code></pre></div><p>重启 <code>libvirtd</code></p>
<p>现在你可以创建一个 UEFI 虚拟机了。 你可以通过 <a href="https://archlinux.org/packages/?name=virt-manager">virt-manager</a> 来创建。当你进行到向导的最后一步时：</p>
<ul>
<li>勾选<strong>在安装前自定义配置</strong>，之后点击<strong>完成</strong>。</li>
<li>在<strong>概况</strong>屏幕, 将固件改为&rsquo;UEFI x86_64'。</li>
<li>点击<strong>开始安装</strong></li>
<li>在启动屏幕，你需要使用linuxefi命令来启动安装程序，并且你需要在系统中运行efibootmgr验证确实运行在UEFI模式下。</li>
</ul>
<h3 id="qemu-kvm-win7httpswwwcnblogscomsammyliup5740129html"><a href="https://www.cnblogs.com/sammyliu/p/5740129.html">QEMU-KVM Win7</a><a hidden class="anchor" aria-hidden="true" href="#qemu-kvm-win7httpswwwcnblogscomsammyliup5740129html">#</a></h3>
<h4 id="环境准备">环境准备<a hidden class="anchor" aria-hidden="true" href="#环境准备">#</a></h4>
<ol>
<li>
<p>安装QEMU：<code>sudo apt install qemu-kvm</code></p>
</li>
<li>
<p>下载 Windows virtio driver iso：https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/archive-virtio/virtio-win-0.1.102/，因为要将磁盘挂接为 virtio 磁盘。</p>
<p>需使用 virtio-win-0.1.102，我使用最新的 virtio-win-0.1.208.iso，Windows安装程序会提示驱动没有包含签名错误<code>No signed device drivers were found. Make sure that the installation media contains the correct drivers, and then click OK</code></p>
</li>
<li>
<p>创建系统盘 <code>qemu-img create -f qcow2 Windows7-VM.img 30G</code>，这将作为Win7的操作系统盘。</p>
</li>
<li>
<p>创建启动脚本</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ vi start_Windows7_VM.sh
<span style="color:#75715e">#!/bin/bash</span>
DISKIMG<span style="color:#f92672">=</span>$HOME/.vm/Windows7-VM.img
exec qemu-system-x86_64 --enable-kvm <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -cpu host,hv_relaxed,hv_spinlocks<span style="color:#f92672">=</span>0x1fff,hv_vapic,hv_time <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -drive file<span style="color:#f92672">=</span><span style="color:#e6db74">${</span>DISKIMG<span style="color:#e6db74">}</span>,if<span style="color:#f92672">=</span>virtio <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -net nic,model<span style="color:#f92672">=</span>virtio-net-pci -net user,smb<span style="color:#f92672">=</span>$HOME/Downloads <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -m <span style="color:#ae81ff">4096</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -smp cores<span style="color:#f92672">=</span>2,threads<span style="color:#f92672">=</span><span style="color:#ae81ff">4</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -monitor stdio <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -vga std <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -audiodev pa,id<span style="color:#f92672">=</span>snd0 -device ich9-intel-hda -device hda-output,audiodev<span style="color:#f92672">=</span>snd0 <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -usb -device usb-tablet <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -rtc base<span style="color:#f92672">=</span>localtime,clock<span style="color:#f92672">=</span>host  <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -name <span style="color:#e6db74">&#39;Windows7 VM&#39;</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    $@

$ chmod u+x start_Windows7_VM.sh
</code></pre></div></li>
<li>
<p><code>./start_Windows7_VM.sh -boot d -cdrom $HOME/Downloads/cn_windows_7_ultimate_x64_dvd_x15-66043.iso -drive file=$HOME/Downloads/virtio-win-0.1.102.iso,index=3,media=cdrom</code></p>
</li>
</ol>
<h4 id="安装-win-7">安装 Win 7<a hidden class="anchor" aria-hidden="true" href="#安装-win-7">#</a></h4>
<ol>
<li>选择 Custom（advanced）</li>
</ol>
<p><img loading="lazy" src="/Distributions/697113-20160805095506903-82521289.jpg" alt="img"  />
</p>
<ol start="2">
<li>选择 CD Drive (E:) virtio-win</li>
</ol>
<p><img loading="lazy" src="/Distributions/697113-20160805095551856-1022452692.jpg" alt="img"  />
</p>
<ol start="3">
<li>选择 viostor</li>
</ol>
<p><img loading="lazy" src="/Distributions/697113-20160805095644122-1127564092.jpg" alt="img"  />
</p>
<ol start="4">
<li>安装 Win7 Virtio SCSI Driver</li>
</ol>
<p><img loading="lazy" src="/Distributions/697113-20160805095724137-1062705244.jpg" alt="img"  />
</p>
<ol start="5">
<li>安装好以后，就可以看到安装的目标磁盘了</li>
</ol>
<p><img loading="lazy" src="/Distributions/697113-20160805095804262-1125252105.jpg" alt="img"  />
</p>
<ol start="6">
<li>进入常规的 Win7 安装流程</li>
</ol>
<p><img loading="lazy" src="/Distributions/697113-20160805095838481-127974813.jpg" alt="img"  />
</p>
<h4 id="安装-virtio-网络驱动">安装 Virtio 网络驱动<a hidden class="anchor" aria-hidden="true" href="#安装-virtio-网络驱动">#</a></h4>
<p><img loading="lazy" src="/Distributions/697113-20160805100148122-512197961.jpg" alt="img"  />
</p>
<p>但是安装失败：</p>
<p><img loading="lazy" src="/Distributions/697113-20160805100403059-506876837.jpg" alt="img"  />
</p>
<p>尝试 device manager 安装：</p>
<p><img loading="lazy" src="/Distributions/697113-20160805100907340-1175076487.jpg" alt="img"  />
</p>
<h4 id="qemu-的内置smb服务器qemu-的内置smb服务器">[QEMU 的内置SMB服务器](#QEMU 的内置SMB服务器)<a hidden class="anchor" aria-hidden="true" href="#qemu-的内置smb服务器qemu-的内置smb服务器">#</a></h4>
<h4 id="宿主机的usb设备传递至虚拟机宿主机的usb设备传递至虚拟机"><a href="#%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%9A%84USB%E8%AE%BE%E5%A4%87%E4%BC%A0%E9%80%92%E8%87%B3%E8%99%9A%E6%8B%9F%E6%9C%BA">宿主机的USB设备传递至虚拟机</a><a hidden class="anchor" aria-hidden="true" href="#宿主机的usb设备传递至虚拟机宿主机的usb设备传递至虚拟机">#</a></h4>
<h3 id="qemu-kvm-winxp-sp3">QEMU-KVM WinXP SP3<a hidden class="anchor" aria-hidden="true" href="#qemu-kvm-winxp-sp3">#</a></h3>
<h4 id="windows_xpshhttpsgistgithubcomandrusha1000766"><a href="https://gist.github.com/andrusha/1000766">windows_xp.sh</a><a hidden class="anchor" aria-hidden="true" href="#windows_xpshhttpsgistgithubcomandrusha1000766">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">#!/bin/bash
</span><span style="color:#75715e"></span>DISKIMG<span style="color:#f92672">=</span>$HOME/.vm/WindowsXP-VM.img
exec qemu-system-x86_64 --enable-kvm <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -cpu host,hv_relaxed,hv_spinlocks<span style="color:#f92672">=</span>0x1fff,hv_vapic,hv_time <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -drive file<span style="color:#f92672">=</span><span style="color:#e6db74">${</span>DISKIMG<span style="color:#e6db74">}</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -net nic,model<span style="color:#f92672">=</span>rtl8139 -net user,smb<span style="color:#f92672">=</span>$HOME/Downloads <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -m <span style="color:#ae81ff">4096</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -cpu Nehalem <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -rtc base<span style="color:#f92672">=</span>localtime,clock<span style="color:#f92672">=</span>host  <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -usb -device usb-tablet <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -monitor stdio <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -vga std <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    $@
</code></pre></div><h5 id="windows-xp-cannot-connect-to-samba-sharehttpsaskubuntucomquestions1268132windows-xp-cannot-connect-to-samba-share-linux-server-20-04"><a href="https://askubuntu.com/questions/1268132/windows-xp-cannot-connect-to-samba-share-linux-server-20-04">Windows XP cannot connect to samba share</a><a hidden class="anchor" aria-hidden="true" href="#windows-xp-cannot-connect-to-samba-sharehttpsaskubuntucomquestions1268132windows-xp-cannot-connect-to-samba-share-linux-server-20-04">#</a></h5>
<p>You have &lsquo;client min protocol = NT1&rsquo; set, there is another similar setting &lsquo;server min protocol&rsquo; which from Samba 4.11.0 is set to SMBv2. Your XP is probably only using SMBv1, so it will not be able to see or connect to your Samba server.</p>
<p>So you have to edit the <code>[global]</code> section in the <code>/etc/samba/smb.conf</code> and add the <code>server min protocol = NT1</code> option here. Then restart the Samba service.</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ps h -C smbd -o pid,args
<span style="color:#ae81ff">1707</span> /usr/sbin/smbd --foreground --no-process-group
$ vim /tmp/qemu-smb.SL95F1/smb.conf
<span style="color:#f92672">[</span>global<span style="color:#f92672">]</span>
server min protocol <span style="color:#f92672">=</span> NT1
$ sudo smbcontrol <span style="color:#ae81ff">1707</span> reload-config
</code></pre></div><p>或者编写如下脚本</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">#!/bin/bash
</span><span style="color:#75715e"></span>echo <span style="color:#e6db74">&#34;[global]
</span><span style="color:#e6db74">server min protocol = NT1&#34;</span> &gt;&gt; /tmp/**/smb.conf
sudo smbcontrol <span style="color:#66d9ef">$(</span>ps h -C smbd -o pid<span style="color:#66d9ef">)</span> reload-config
</code></pre></div><h5 id="windows-xp-上网提示您的时钟快了慢了httpsblogcsdnnetjohnnysun2015articledetails104888159"><a href="https://blog.csdn.net/JohnnySun2015/article/details/104888159">Windows XP 上网提示：您的时钟快了/慢了</a><a hidden class="anchor" aria-hidden="true" href="#windows-xp-上网提示您的时钟快了慢了httpsblogcsdnnetjohnnysun2015articledetails104888159">#</a></h5>
<p>此时，无论你怎么调整日期和时间，都不能解决上网问题。即使把日期从2020年调整到2015年，此时虽然不在提示 “您的时钟快了”，也有证书期限等异常。</p>
<p>出现这种问题的原因，是因为 Windows XP 确实太老了，Google Chrome、Mozilla Firefox 及其内核的浏览器已经不支持了。</p>
<h4 id="virtual-machine-manager">Virtual Machine Manager<a hidden class="anchor" aria-hidden="true" href="#virtual-machine-manager">#</a></h4>
<p><a href="https://blog.51cto.com/wsxxsl/1914181"><strong>键盘不能输入的问题</strong></a></p>
<p>在 Display 中，设定 keymap，比如 en-us</p>
<p><strong>无网络</strong></p>
<p>在 NIC 中，将 Device model 设置为 rtl8139</p>
<h3 id="qemu-kvm-gentoohttpswikigentooorgwikiqemulinux_guest"><a href="https://wiki.gentoo.org/wiki/QEMU/Linux_guest">QEMU-KVM Gentoo</a><a hidden class="anchor" aria-hidden="true" href="#qemu-kvm-gentoohttpswikigentooorgwikiqemulinux_guest">#</a></h3>
<h4 id="configuration">Configuration<a hidden class="anchor" aria-hidden="true" href="#configuration">#</a></h4>
<h5 id="host">Host<a hidden class="anchor" aria-hidden="true" href="#host">#</a></h5>
<p>To create a disk image for the virtual machine, run:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ qemu-img create -f qcow2 Gentoo-VM.img 30G
</code></pre></div><p>Download a minimal Gentoo LiveCD from <a href="https://www.gentoo.org/downloads/">here</a>.</p>
<p>Since QEMU requires a lot of <a href="https://wiki.gentoo.org/wiki/QEMU/Options">options</a>, it would be a good idea to put them into a shell script, e.g.:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ vim start_Gentoo_VM.sh
<span style="color:#75715e">#!/bin/bash</span>
DISKIMG<span style="color:#f92672">=</span>$HOME/VirtualMachine/Gentoo-VM.img
exec qemu-system-x86_64 -enable-kvm <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>        -bios /usr/share/edk2-ovmf/OVMF_CODE.fd <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>        -cpu host <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>        -drive file<span style="color:#f92672">=</span><span style="color:#e6db74">${</span>DISKIMG<span style="color:#e6db74">}</span>,if<span style="color:#f92672">=</span>virtio <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>        -netdev user,id<span style="color:#f92672">=</span>vmnic,hostname<span style="color:#f92672">=</span>Gentoo-VM,hostfwd<span style="color:#f92672">=</span>tcp::10022-:22 <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>        -device virtio-net,netdev<span style="color:#f92672">=</span>vmnic <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>        -device virtio-rng-pci <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>        -m 4G <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>        -smp <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>        -monitor stdio <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>        -vga std <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>        -audiodev pa,id<span style="color:#f92672">=</span>snd0 -device ich9-intel-hda -device hda-output,audiodev<span style="color:#f92672">=</span>snd0 <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>        -name <span style="color:#e6db74">&#34;Gentoo VM&#34;</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>        $@

$ chmod u+x start_Gentoo_VM.sh
</code></pre></div><p>Change the path to your disk image Gentoo-VM.img in the script. You can add more options when calling the script. To boot the disk image, run:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ./start_Gentoo_VM.sh -boot d -cdrom $HOME/Downloads/install-amd64-minimal-20211107T170547Z.iso
</code></pre></div><p>Install the guest per the <a href="https://wiki.gentoo.org/wiki/Handbook:Main_Page">Gentoo Handbook</a>. See the <a href="https://wiki.gentoo.org/wiki/QEMU/Linux_guest#Guest">guest section</a> for optimum support. After the installation start the script without the additional options.</p>
<h5 id="using-uefi-with-qemuhttpsfedoraprojectorgwikiusing_uefi_with_qemu"><a href="https://fedoraproject.org/wiki/Using_UEFI_with_QEMU">Using UEFI with QEMU</a><a hidden class="anchor" aria-hidden="true" href="#using-uefi-with-qemuhttpsfedoraprojectorgwikiusing_uefi_with_qemu">#</a></h5>
<p>UEFI for x86 QEMU/KVM VMs is called OVMF (Open Virtual Machine Firmware). It comes from EDK2 (EFI Development Kit), which is the UEFI reference implementation.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt-get install ovmf 
</code></pre></div><p><a href="https://www.ubuntubuzz.com/2021/04/how-to-boot-uefi-on-qemu.html">检查是否安装</a>，命令为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ dpkg -L ovmf | grep OVMF.fd 
/usr/share/ovmf/ OVMF.fd
/usr/share/qemu/ OVMF.fd
</code></pre></div><p>要在虚拟机中运行操作系统的映像文件，添加 <code>-bios /usr/share/ovmf/OVMF.fd</code>。该代码调用名为 OVMF.fd 的文件，该文件是 Qemu 的 UEFI 固件。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ qemu-system-x86_64 -bios /usr/share/ovmf/OVMF.fd -cdrom ubuntu-21.04-desktop-amd64.iso
</code></pre></div><p>这个名为<em>ovmf的</em>包其实就是名为TianoCore的程序。该名称本身代表<a href="https://github.com/tianocore/tianocore.github.io/wiki/OVMF-FAQ#what-is-open-virtual-machine-firmware-ovmf">开放虚拟机固件</a>)。</p>
<p><a href="https://github.com/utmapp/UTM/issues/2333"><strong>&ldquo;BdsDxe: failed to load Boot0001&rdquo;</strong></a></p>
<p><a href="https://www.reddit.com/r/Proxmox/comments/ckfthg/vm_no_longer_boots_after_creating_windows_10_vm/">solution</a>: Try hitting F2 to enter the OVMF settings during guest boot and manually pick a new boot drive option.</p>
<h3 id="others">Others<a hidden class="anchor" aria-hidden="true" href="#others">#</a></h3>
<h4 id="通过-qemu-安装-windows-到硬盘">通过 Qemu 安装 Windows 到硬盘<a hidden class="anchor" aria-hidden="true" href="#通过-qemu-安装-windows-到硬盘">#</a></h4>
<p>双系统新思路。今天装windows, 在linux上先用虚拟机，把硬盘直通进去，在raw盘上装好，然后更新grub, 再重启就可以直接接进去了。</p>
<p>这样可以避免装机还要做启动盘，装机过程中的重启也可以避免了。</p>
<p>win的安装过程中驱动都是按照虚拟机的配置安装的，但是win10是自动装驱动的，重启进去后过了一会显卡驱动自动都装好了。</p>
<h4 id="looking-glasshttpslooking-glassiodocs"><a href="https://looking-glass.io/docs">Looking Glass</a><a hidden class="anchor" aria-hidden="true" href="#looking-glasshttpslooking-glassiodocs">#</a></h4>
<p><strong><a href="https://unwire.hk/2017/12/20/lookingglass/game-channel/">Looking Glass 讓 Linux 可完美玩 Windows 遊戲 超低延遲不掉格</a></strong></p>
<p>當用戶安裝了虛擬電腦（VM）實行 Windows，並執行遊戲時，它採用的 KVM frame relay 技術可將 Windows 顯示記憶體，透過 PCI pass-through 直接由 Windows VM 被配置的顯示卡，複製到 Linux 被配置的顯示卡，這樣 Linux 便可在極為低延遲的情況下，接近完美顯示 Windows 遊戲的內容。</p>
<p>簡單來說，就是一部 Linux 電腦裡面裝有虛擬電腦運行的 Windows，Windows 遊戲實行時，在被配置的顯示卡記憶體資料，在主機板 PCI 通道直接複製到 Linux 被配置的顯示卡。即是說 Windows 遊戲原本畫面，可高速反映到 Liunx 的虛擬電腦軟件上。這樣 Linux 用戶就算不 Dual boot 或使用兩個熒幕，在 Linux 上都可得到接近相同的打機體驗。</p>
<h4 id="xrdphttpsgithubcomneutrinolabsxrdp"><a href="https://github.com/neutrinolabs/xrdp">xrdp</a><a hidden class="anchor" aria-hidden="true" href="#xrdphttpsgithubcomneutrinolabsxrdp">#</a></h4>
<p>xrdp 使用 RDP（Microsoft 远程桌面协议）为远程计算机提供图形登录。xrdp 接受来自各种 RDP 客户端的连接：FreeRDP、rdesktop、NeutrinoRDP 和 Microsoft 远程桌面客户端（适用于 Windows、macOS、iOS 和 Android）。</p>
<p>正如 Windows 到 Windows 远程桌面一样，xrdp 不仅支持图形远程处理，还支持</p>
<ul>
<li>双向剪贴板传输（文本、位图、文件）</li>
<li>音频重定向</li>
<li>驱动器重定向（在远程机器上安装本地客户端驱动器）</li>
</ul>
<p>RDP 传输默认使用 TLS 加密。</p>
<h4 id="qemukvm-vs-virtualbox">QEMU/KVM VS Virtualbox<a hidden class="anchor" aria-hidden="true" href="#qemukvm-vs-virtualbox">#</a></h4>
<p><a href="https://linuxconfig.org/virtualization-solutions-on-linux-systems-kvm-and-virtualbox"><strong>Linux 系统上的虚拟化解决方案 – KVM 和 VirtualBox</strong></a></p>
<p>KVM 提供了一些 VirtualBox 没有的功能，反之亦然。IT 世界中没有通用工具，因此使用适合您需求的工具非常重要。基本思想是：如果你想安装二进制 Linux 发行版作为来宾，使用 KVM。它速度更快，并且它的驱动程序包含在官方内核树中。如果您的客户涉及大量编译并且需要一些更高级的功能，并且/或者不是 Linux 系统，那么最好使用 VirtualBox。</p>
<p>技术原因很简单：KVM 更好地与 Linux 集成，它更小更快，虽然你可以在 Linux 以外的其他客户机上使用它，但我们发现体验相当麻烦：BSD 的 I/O 和 Solaris 往往很慢（确切地说，是 OpenIndiana）在引导安装 ISO 后会立即出现恐慌。由于我们使用当前版本的 BSD（并且经常从源代码编译/更新系统）并且还需要 Solaris，我们发现 VirtualBox 是一个更好的选择。Oracle VirtualBox 的另一个优点是它支持挂起，即您可以将机器状态保存在主机的硬盘上并关闭 VirtualBox，当（重新)启动时，系统将从它离开的地方恢复。这就是为什么我们提到源代码编译：如果你有一台嘈杂的机器，你不想一夜之间离开，但你的 Gentoo 虚拟机只是编译一个新的 gcc 版本，暂停机器状态，关闭主机，明天继续。</p>
<p><a href="https://www.reddit.com/r/sysadmin/comments/by9fkb/desktop_virtualization_kvm_or_virtualbox/"><strong>桌面虚拟化、KVM 还是 Virtualbox？</strong></a></p>
<p>这两者中的哪一个更适合在 Linux 台式机/笔记本电脑上运行 Windows 10 虚拟机？</p>
<ul>
<li>
<p><a href="https://virt-manager.org/">带有virt-manager 的</a>QEMU/KVM应该可以与 Virtualbox 媲美。</p>
<p>Virtualbox 没问题，特别是如果跨主机操作系统使用相同的虚拟化很重要，但 QEMU/KVM 是更好的投资。QEMU/HAXM 也应该可以在 Mac 和 Windows 上运行，尽管它目前还不够成熟。</p>
</li>
<li>
<p>KVM, obviously. You&rsquo;re probably going to need to learn how to manage it, but it is a much better system and allows abstraction on completely unexposed CPU hardware so you can easily take your image and put it onto another KVM. Windows doesn&rsquo;t like to have it&rsquo;s CPUs exchange on it very often.</p>
</li>
</ul>
<p><a href="https://www.cpqlinux.com/kvm-vs-virtualbox/"><strong>KVM 与 VirtualBox</strong></a></p>
<ul>
<li>
<p>表现</p>
<p>这是要考虑的最重要的领域之一，即管理程序的性能将如何影响您的基础架构。KVM 是 1 类管理程序（这些虚拟机管理程序直接运行在宿主机的硬件上来控制硬件和管理客操作系统），而 VirtualBox 是 2 类管理程序（这些虚拟机管理程序运行在传统的操作系统上，就像其他计算机程序那样运行），这意味着 KVM 应该优于 VirtualBox。</p>
<p><a href="https://www.spec.org/virt_sc2013/">根据SPECvirt_sc2013 基准测试</a>，VirtualBox 通常比 KVM 需要更多时间来创建和启动服务器，而 KVM 以接近本机的速度运行应用程序，比其他行业管理程序更快。尽管对于典型负载，差异可能微不足道。</p>
</li>
<li>
<p>管理程序管理</p>
<p>这两个给定的应用程序都可以通过 GUI 进行管理。Virtualbox 相对来说有更好的 GUI，但 KVM 的当前 GUI 使其管理比以往任何时候都更容易。”</p>
<p>如果您更喜欢命令行，那么 KVM 中有各种命令行选项。Virtualbox 也提供了一个命令行界面，但它不如 KVM virsh 全面。您不能直接从 bash 启动 Virtualbox VM。</p>
</li>
<li>
<p>可扩展性</p>
<p>KVM 继承了 Linux 的性能，如果来宾机器和请求的数量增加，可以扩展以匹配需求负载。KVM 允许对要求最苛刻的应用程序工作负载进行虚拟化，并且是许多企业虚拟化设置的基础，例如数据中心和私有云。</p>
<p>VirtualBox 可以为每个 VM 提供多达 32 个虚拟 CPU，而不管主机上物理存在多少 CPU 内核。还可以为具有多达 1024 个 CPU 的主机提供支持。</p>
</li>
<li>
<p>安全</p>
<p>KVM 提供增强的安全性，因为它结合使用 SELinux 和安全虚拟化 (sVirt)。VirtualBox 可以执行虚拟机的安全实时迁移和磁盘映像加密。它还包括远程桌面协议 (RDP) 身份验证和用于创建进一步身份验证要求以帮助提高安全性的 SDK。<a href="https://docs.oracle.com/en/virtualization/virtualbox/6.0/admin/security-features.html">您可以在此页面</a>上看到 Virtualbox 的安全功能列表。</p>
</li>
<li>
<p>成本和定价</p>
<p>KVM 是一个开源的免费平台，由 Red Hat 等供应商提供有偿支持。虽然 Virtualbox 在限制范围内是免费的。一旦您超过一定的使用水平，您必须获得产品许可。</p>
</li>
<li>
<p>支持</p>
<p>对于 KVM，您需要依赖开源社区和您自己的 IT 组织或受支持的供应商（如红帽）的支持。Oracle 正在积极开发 Virtualbox，您可以从他们那里获得任何支持。</p>
</li>
</ul>
<h4 id="virtualbox">VirtualBox<a hidden class="anchor" aria-hidden="true" href="#virtualbox">#</a></h4>
<p><strong>执行 .vbs 文件</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cscript test.vbs
</code></pre></div><p><strong>删除备份</strong></p>
<p>删除虚拟机备份，当前状态前一个备份删除得快，两个备份之间的备份删除得慢。</p>
<p><strong>共享文件夹</strong></p>
<p>固定分配的共享文件夹对于定义共享文件夹的虚拟机是永久存在的；</p>
<p>临时分配的共享文件夹在虚拟机运行时添加/删除，虚拟机关闭后消失。</p>
<p><strong><a href="https://blog.csdn.net/lionwerson/article/details/104976028">把img系统镜像转为VDI或VMDK格式文件</a></strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ VBoxManage convertdd *.img  *.vdi
</code></pre></div><p>在 virtualbox 新建虚拟机时指定 vdi 硬盘文件，就可以安装系统</p>
<h5 id="增加现有虚拟机的磁盘大小httpslinuxcnarticle-12869-1html"><a href="https://linux.cn/article-12869-1.html">增加现有虚拟机的磁盘大小</a><a hidden class="anchor" aria-hidden="true" href="#增加现有虚拟机的磁盘大小httpslinuxcnarticle-12869-1html">#</a></h5>
<p>下面是你迟早会遇到的情况。</p>
<p>你在 <a href="https://www.virtualbox.org/">VirtualBox</a> 中安装了一个或多个操作系统。在创建这些虚拟操作系统的同时，你还在 VirtualBox 中为它们创建了虚拟硬盘。</p>
<p>你指定了虚拟磁盘的最大大小，比如说 15 或 20GB，但现在使用了一段时间后，你发现你的虚拟机已经没有空间了。</p>
<p>虽然在 Ubuntu 和其他操作系统上有释放磁盘空间的方法，但更稳健的处理方式是增加 VirtualBox 中创建的虚拟机的磁盘大小。</p>
<p>是的，你可以在 VirtualBox 中扩大虚拟硬盘，即使在创建之后也可以。虽然这是一个安全且经过测试的过程，但我们强烈建议你在执行这样的操作之前，先创建一个虚拟机的备份。</p>
<p>我将向你展示如何在 VirtualBox 中以图形和命令行（对于 Linux 极客）方式调整磁盘大小。这两种方法都很简单直接。</p>
<p><strong>方法 1：在 VirtualBox 中使用虚拟媒体管理器</strong></p>
<p>VirtualBox 6 增加了一个调整虚拟磁盘大小的图形化选项。你可以在 VirtualBox 主页的文件选项卡中找到它。</p>
<p>进入 “File -&gt; Virtual Media Manager”：</p>
<p>在列表中选择一个虚拟机，然后使用 “Size” 滑块或输入你需要的大小值。完成后点击 “Apply”。</p>
<p>请记住，虽然你增加了虚拟磁盘的大小，但<strong>如果你的空间是动态分配的，那么实际的分区大小仍然不变</strong>。</p>
<p><strong>方法 2：使用 Linux 命令行增加 VirtualBox 磁盘空间</strong></p>
<p>如果你使用 Linux 操作系统作为宿主机，在宿主机中打开终端并输入以下命令来调整 VDI 的大小：</p>
<pre tabindex="0"><code>VBoxManage modifymedium &quot;/path_to_vdi_file&quot; --resize &lt;megabytes&gt;
</code></pre><p>在你按下回车执行命令后，调整大小的过程应该马上结束。</p>
<blockquote>
<p>注意事项</p>
<p>VirtualBox 早期版本命令中的 <code>*modifyvdi</code> 和 <code>modifyhd</code> 命令也支持，并在内部映射到 <code>modifymedium</code> 命令。</p>
</blockquote>
<p>如果你不确定虚拟机的保存位置，可以在 VirtualBox 主页面点击 “Files -&gt; Preferences” 或使用键盘快捷键 <code>Ctrl+G</code> 找到默认位置。</p>
<h5 id="seamless-modehttpswwwtl80cnarticle43389"><a href="https://www.tl80.cn/article/43389">Seamless Mode</a><a hidden class="anchor" aria-hidden="true" href="#seamless-modehttpswwwtl80cnarticle43389">#</a></h5>
<p>虚拟机通常在一个窗口中运行来宾操作系统及其程序。但是，VirtualBox和VMware都有一些功能，允许您在主机桌面上运行虚拟化程序，从而将它们从监狱中释放出来。&hellip;</p>
<p>这意味着您可以在不使用虚拟机窗口和来宾操作系统桌面的情况下使用程序。如果使用多个监视器，甚至可以将虚拟机中的不同窗口放置在不同的监视器上。</p>
<p><strong>工作原理</strong></p>
<p>所有这些特性都同样工作。启动虚拟机，启动您想要使用的程序，然后启用“无缝模式”或“统一模式”。来宾操作系统的桌面和虚拟机窗口将消失，将来宾操作系统的窗口留在桌面上。它们看起来正在运行，好像它们在您的主机操作系统上运行，但虚拟机仍在后台运行。程序仍然是沙盒，因此它们无法访问主机操作系统的文件——它们似乎正在主机操作系统上运行。</p>
<p>无论您使用的是Windows、Linux还是Mac，这些技巧都有效。您可以在Linux桌面上无缝运行Windows程序，也可以在Windows桌面上运行Linux软件。</p>
<p><strong>使用virtualbox的无缝模式</strong></p>
<p>请注意，VirtualBox只允许您在Windows、Linux和Solaris客户机上使用此功能。如果你设法让MacOSX在VirtualBox虚拟机上运行，或者你正在使用像俳句这样的小众操作系统，你将无法使用这个功能。</p>
<p>在使用此功能之前，必须在要使用的来宾虚拟机内安装VirtualBox来宾添加软件包。如果您还没有这样做，请启动虚拟机，单击“设备”菜单，然后选择“安装来宾添加”。系统将提示您安装软件。</p>
<p>要使用此功能，请同时按“主机键”（通常是右Ctrl键，但它显示在虚拟机窗口的右下角）和“L”。也可以单击“视图”菜单，然后选择“切换到无缝模式”。</p>
<p>VirtualBox将隐藏来宾操作系统的桌面背景，使其看起来好像来宾操作系统的程序正在主机操作系统的桌面上运行。但是，正在运行的应用程序不会出现在操作系统的标准任务栏上。</p>
<p>要退出无缝模式，只需按主机键，然后再次按L。您还可以在任务栏上方找到VirtualBox菜单，您可以将鼠标悬停在上面查看。单击查看并再次选择切换到无缝模式以禁用无缝模式。</p>
<p><strong>使用vmware的unity模式</strong></p>
<p>VMware有一个类似的功能，名为Unity mode。它可以在免费的VMware Player、VMware Workstation和VMware的其他付费应用程序上使用。与VirtualBox一样，VMware的Unity模式适用于Windows和Linux客户机。</p>
<h5 id="vboxwinxp-sp3">VBox+WinXP SP3<a hidden class="anchor" aria-hidden="true" href="#vboxwinxp-sp3">#</a></h5>
<p><strong><a href="https://www.reddit.com/r/virtualbox/comments/l4yvpy/windows_xp_guest_additions_installation_stuck/">Windows XP; Guest Additions installation stuck; Virtualbox 6.1.18</a></strong></p>
<p>Disconnect network. It helps me.</p>
<h5 id="vs-vmwarehttpswwwzhihucomquestion33701295"><a href="https://www.zhihu.com/question/33701295">vs VMWare</a><a hidden class="anchor" aria-hidden="true" href="#vs-vmwarehttpswwwzhihucomquestion33701295">#</a></h5>
<p>工具是用来解决问题的，没必要看到开源就意识形态附体</p>
<p><strong><a href="https://winotes.net/fixing-piix4-host-smbus-controller-not-enabled-error-for-centos-on-vmware/">piix4_smbus Host SMBus controller not enabled</a></strong></p>
<p>从内核的说明文档来看，这个 piix4 实际上是 Intel 82371AB 南桥芯片，多功能总线控制器，而在 VMware 里面并没有这个真实的芯片组，但在启动时最会尝试载入这个驱动模块，所以会报错，但对系统没有任何影响。</p>
<h5 id="虚拟机网络模式httpswwwcnblogscomggjuchengarchive201208192646007html"><a href="https://www.cnblogs.com/ggjucheng/archive/2012/08/19/2646007.html">虚拟机网络模式</a><a hidden class="anchor" aria-hidden="true" href="#虚拟机网络模式httpswwwcnblogscomggjuchengarchive201208192646007html">#</a></h5>
<p><img loading="lazy" src="/Distributions/v2-82deb4be7068ec65b3ab251df22d5130_r.jpg" alt=""  />
</p>
<p><strong>桥接</strong></p>
<p>桥接网络是指本地物理网卡和虚拟网卡通过VMnet0虚拟交换机进行桥接，物理网卡和虚拟网卡在拓扑图上处于同等地位，那么物理网卡和虚拟网卡就相当于处于同一个网段，虚拟交换机就相当于一台现实网络中的交换机,所以两个网卡的IP地址也要设置为同一网段。</p>
<p>所以当我们要在局域网使用虚拟机，对局域网其他pc提供服务时，例如提供ftp，提供ssh，提供http服务，那么就要选择桥接模式。</p>
<p>例如大学宿舍里有一个路由器，宿舍里四个人连接这个路由器，路由器的wanip就不理会了，这个ip是动态获取的，而lanip默认是192.168.1.1,子网掩码是255.255.255.0。而其他四个人是自动获取ip，假设四个人的ip是:</p>
<p>A:192.168.1.100/255.255.255.0,</p>
<p>B:192.168.1.101/255.255.255.0</p>
<p>C:192.168.1.102/255.255.255.0</p>
<p>D:192.168.1.103/255.255.255.0</p>
<p>那么虚拟机的ip可以设置的ip地址是192.168.1.2-192.168.1.99,192.168.1.104-192.168.1.254 (即网络地址全0和全1的除外，再除去ABCD四个人的ip地址)</p>
<p>那么虚拟机的ip地址可以设置为192.168.1.98/255.255.255.0，设置了这个ip地址，ABCD这四个人就可以通过192.168.1.98访问虚拟机了，如果虚拟机需要上外网，那么还需要配置虚拟机的路由地址，就是192.168.1.1了，这样，虚拟机就可以上外网了，但是，上网我们一般是通过域名去访问外网的，所以我们还需要为虚拟机配置一个dns服务器，我们可以简单点，把dns服务器地址配置为google的dns服务器:8.8.8.8,到此，虚拟机就可以上网了。</p>
<p><strong>NAT</strong></p>
<p>NAT模式中，就是让虚拟机借助NAT(网络地址转换)功能，通过宿主机器所在的网络来访问公网。</p>
<p>NAT模式中，虚拟机的网卡和物理网卡的网络，不在同一个网络，虚拟机的网卡，是在vmware提供的一个虚拟网络。</p>
<p>NAT和桥接的比较:</p>
<ul>
<li>NAT模式和桥接模式虚拟机都可以上外网。</li>
<li>由于NAT的网络在vmware提供的一个虚拟网络里，所以局域网其他主机是无法访问虚拟机的，而宿主机可以访问虚拟机，虚拟机可以访问局域网的所有主机，因为真实的局域网相对于NAT的虚拟网络，就是NAT的虚拟网络的外网。</li>
<li>桥接模式下，多个虚拟机之间可以互相访问；NAT模式下，多个虚拟机之间也可以相互访问。</li>
</ul>
<p>如果你建一个虚拟机，只是给自己用，不需要给局域网其他人用，那么可以选择NAT，毕竟NAT模式下的虚拟系统的TCP/IP配置信息是由VMnet8(NAT)虚拟网络的DHCP服务器提供的，只要虚拟机的网路配置是DHCP，那么你不需要进行任何其他的配置，只需要宿主机器能访问互联网即可，就可以让虚拟机联网了。</p>
<p>例如你想建多个虚拟机集群，作为测试使用，而宿主机可能是一个笔记本，ip不固定。这种应用场景，我们需要采用nat模式了，但是我们要考虑一个问题，虚拟机之间是需要互访的，默认采用dhcp，虚拟机的ip每次重启，ip都是不固定的，所以我们需要手工设置虚拟机的ip地址。</p>
<p><strong>Host-Only</strong></p>
<p>在Host-Only模式下，虚拟网络是一个全封闭的网络，它唯一能够访问的就是主机。其实Host-Only网络和NAT网络很相似，不同的地方就是Host-Only网络没有NAT服务，所以虚拟网络不能连接到Internet。主机和虚拟机之间的通信是通过VMware Network Adepter VMnet1虚拟网卡来实现的。</p>
<p>Host-Only的宗旨就是建立一个与外界隔绝的内部网络，来提高内网的安全性。这个功能或许对普通用户来说没有多大意义，但大型服务商会常常利用这个功能。</p>
<h4 id="podmanhttpsgithubcomcontainerspodman"><a href="https://github.com/containers/podman">podman</a><a hidden class="anchor" aria-hidden="true" href="#podmanhttpsgithubcomcontainerspodman">#</a></h4>
<p>Podman: A tool for managing OCI containers and pods.</p>
<h4 id="android-x86httpslinuxcnarticle-11711-1html"><a href="https://linux.cn/article-11711-1.html">Android-x86</a><a hidden class="anchor" aria-hidden="true" href="#android-x86httpslinuxcnarticle-11711-1html">#</a></h4>
<p><a href="http://www.android-x86.org/">android x86</a> 是一个自由而开源的项目，将谷歌制作的安卓系统从 ARM 架构移植到了 x86 架构，可以让用户在他们的桌面电脑上运行安卓系统来享受所有的安卓功能和应用程序及游戏。</p>
<p>首次启动运行该安卓系统，运行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ qemu-img create -f qcow2 Android8-VM.img 30G
$ gedit start_Android8_VM.sh
<span style="color:#75715e">#!/bin/bash</span>
DISKIMG<span style="color:#f92672">=</span>/media/kurome/Ventoy/QemuKVM/Android8-VM.img
exec qemu-system-x86_64 --enable-kvm <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  -hda <span style="color:#e6db74">${</span>DISKIMG<span style="color:#e6db74">}</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  -net nic -net user <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  -m <span style="color:#ae81ff">4096</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  -smp cores<span style="color:#f92672">=</span>2,threads<span style="color:#f92672">=</span><span style="color:#ae81ff">4</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  -monitor stdio <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  -vga std <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  -soundhw es1370 <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  -usb -device usb-tablet <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  -name <span style="color:#e6db74">&#39;Andriod8 VM&#39;</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  $@
$ chmod u+x start_Android8_VM.sh
$ ./start_Android8_VM.sh -boot d -cdrom ~/Downloads/android-x86_64-9.0-r2.iso
</code></pre></div><p>在，安卓系统已经完全安装在你的 <code>android.img</code> 文件中，你应该使用下面的 QEMU 命令来启动它，而不是前面的命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ./start_Android8_VM.sh
</code></pre></div><h4 id="anboxhttpslinuxcnarticle-10843-1html"><a href="https://linux.cn/article-10843-1.html">Anbox</a><a hidden class="anchor" aria-hidden="true" href="#anboxhttpslinuxcnarticle-10843-1html">#</a></h4>
<h5 id="anbox-简介">Anbox 简介<a hidden class="anchor" aria-hidden="true" href="#anbox-简介">#</a></h5>
<p>Anbox 是 “Android in a box” 的缩写。Anbox 是一个基于容器的方法，可以在普通的 GNU/Linux 系统上启动完整的 Android 系统。</p>
<p>Anbox 可以让你在 Linux 系统上运行 Android，而没有虚拟化的迟钝，因为核心的 Android 操作系统已经使用 Linux 命名空间（LXE）放置到容器中了。</p>
<p>Android 容器不能直接访问到任何硬件，所有硬件的访问都是通过在主机上的守护进程进行的。</p>
<p>每个应用程序将在一个单独窗口打开，就像其它本地系统应用程序一样，并且它可以显示在启动器中。</p>
<h5 id="安装使用">安装使用<a hidden class="anchor" aria-hidden="true" href="#安装使用">#</a></h5>
<p>Anbox 也可作为 snap 软件包安装，请确保你已经在你的系统上启用了 snap 支持。</p>
<p>为使 Anbox 工作，确保需要的内核模块已经安装在你的系统中。对于基于 Ubuntu 的用户，使用下面的 PPA 来安装它。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo add-apt-repository ppa:morphis/anbox-support
$ sudo apt update
$ sudo apt install linux-headers-generic anbox-modules-dkms
</code></pre></div><p>在你安装 <code>anbox-modules-dkms</code> 软件包后，你必须手动重新加载内核模块，或需要系统重新启动。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo modprobe ashmem_linux
$ sudo modprobe binder_linux
</code></pre></div><p>安装 anbox。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install anbox
</code></pre></div><p>如果你已经在你的系统上安装 snap，其它的步骤可以忽略。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo snap install --devmode --beta anbox
</code></pre></div><p>默认情况下，Anbox 并没有带有 Google Play Store。因此，我们需要手动下载每个应用程序（APK），并使用 Android 调试桥（ADB）安装它。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install android-tools-adb
</code></pre></div><p>既然我们不能使用 Play Store ，你就得从信得过的网站来下载 APK 软件包，像 <a href="https://www.apkmirror.com/">APKMirror</a> ，然后手动安装它。</p>
<p>首先，你需要启动 ADB 服务。为做到这样，运行下面的命令。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ adb devices
</code></pre></div><p>安装语法格式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ adb install Name-Of-Your-Application.apk
</code></pre></div><h4 id="waydroidhttpswaydroid"><a href="https://waydro.id/">Waydroid</a><a hidden class="anchor" aria-hidden="true" href="#waydroidhttpswaydroid">#</a></h4>
<p>Waydroid是一个基于lxc容器技术，用以启动完整安卓系统的方案。</p>
<h4 id="genymotionhttpswwwgenymotioncom"><a href="https://www.genymotion.com/">Genymotion</a><a hidden class="anchor" aria-hidden="true" href="#genymotionhttpswwwgenymotioncom">#</a></h4>
<p>Android Virtual Devices for all your development &amp; testing needs</p>
<h4 id="looking-glasshttpslooking-glassio"><a href="https://looking-glass.io/">Looking Glass</a><a hidden class="anchor" aria-hidden="true" href="#looking-glasshttpslooking-glassio">#</a></h4>
<p>An extremely low latency KVMFR (KVM FrameRelay) implementation for guests with VGA PCI Passthrough.</p>
<h4 id="libvfiohttpsarccomputecombloglibvfio-commodity-gpu-multiplexing"><a href="https://arccompute.com/blog/libvfio-commodity-gpu-multiplexing/">LibVF.IO</a><a hidden class="anchor" aria-hidden="true" href="#libvfiohttpsarccomputecombloglibvfio-commodity-gpu-multiplexing">#</a></h4>
<p>Commodity GPU Multiplexing Driven By VFIO &amp; YAML.</p>
<h4 id="-osx-kvmhttpsgithubcomkholiaosx-kvmmacos-simple-kvmhttpsgithubcomfoxletmacos-simple-kvm"><a href="https://github.com/kholia/OSX-KVM"> OSX-KVM</a>/<a href="https://github.com/foxlet/macOS-Simple-KVM">macOS-Simple-KVM</a><a hidden class="anchor" aria-hidden="true" href="#-osx-kvmhttpsgithubcomkholiaosx-kvmmacos-simple-kvmhttpsgithubcomfoxletmacos-simple-kvm">#</a></h4>
<p>macOS VM in QEMU</p>
<h4 id="quickemuhttpsgithubcomquickemu-projectquickemu"><a href="https://github.com/quickemu-project/quickemu">quickemu</a><a hidden class="anchor" aria-hidden="true" href="#quickemuhttpsgithubcomquickemu-projectquickemu">#</a></h4>
<p>Quickly create and run optimised Windows, macOS and Linux desktop virtual machines.</p>
<h2 id="package-management">Package Management<a hidden class="anchor" aria-hidden="true" href="#package-management">#</a></h2>
<h3 id="dpkg">dpkg<a hidden class="anchor" aria-hidden="true" href="#dpkg">#</a></h3>
<h4 id="管理软件包httpslinuxcnarticle-7953-1html"><a href="https://linux.cn/article-7953-1.html">管理软件包</a><a hidden class="anchor" aria-hidden="true" href="#管理软件包httpslinuxcnarticle-7953-1html">#</a></h4>
<p><a href="https://wiki.debian.org/Teams/Dpkg">dpkg</a> 意即 Debian 包管理器（Debian PacKaGe manager）。dpkg 是一个可以安装、构建、删除及管理 Debian 软件包的命令行工具。</p>
<p>其它的一些工具如 dpkg-deb 和 dpkg-query 等使用 dpkg 作为执行某些操作的前端。</p>
<p>现在大多数系统管理员使用 Apt、Apt-Get 及 Aptitude 等工具，不用费心就可以轻松地管理软件。</p>
<p>尽管如此，必要的时候还是需要用 dpkg 来安装某些软件。</p>
<h5 id="常见命令及文件位置">常见命令及文件位置<a hidden class="anchor" aria-hidden="true" href="#常见命令及文件位置">#</a></h5>
<p>dpkg 命令的语法:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ dpkg <span style="color:#f92672">[</span>&lt;option&gt; ...<span style="color:#f92672">]</span> &lt;command&gt;
</code></pre></div><p>dpkg 相关文件的位置在 <code>/var/lib/dpkg</code></p>
<p><code>/var/lib/dpkg/status</code> 包含了被 dpkg 命令（install、remove 等）所修改的包的信息</p>
<p><code>/var/lib/dpkg/status</code> 包含了可用包的列表</p>
<h5 id="安装升级软件">安装/升级软件<a hidden class="anchor" aria-hidden="true" href="#安装升级软件">#</a></h5>
<p>在基于 Debian 的系统里，用以下命令来安装 <code>.deb</code> 软件包。要是已经安装了软件包，就会升级它。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo dpkg -i package.deb
</code></pre></div><h5 id="从文件夹里安装软件">从文件夹里安装软件<a hidden class="anchor" aria-hidden="true" href="#从文件夹里安装软件">#</a></h5>
<p>在基于 Debian 的系统里，用下列命令从目录中逐个安装软件。这会安装 <code>/opt/software</code> 目录下的所有以 .deb 为后缀的软件。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo dpkg -iR /opt/software
</code></pre></div><h5 id="显示已安装软件列表">显示已安装软件列表<a hidden class="anchor" aria-hidden="true" href="#显示已安装软件列表">#</a></h5>
<p>以下命令可以列出 Debian 系的系统中所有已安装的软件，同时会显示软件版本和描述信息。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ dpkg -l
</code></pre></div><h5 id="查看指定的已安装软件">查看指定的已安装软件<a hidden class="anchor" aria-hidden="true" href="#查看指定的已安装软件">#</a></h5>
<p>用以下命令列出指定的一个已安装软件，同时会显示软件版本和描述信息。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ dpkg -l package
</code></pre></div><h5 id="查看软件安装目录">查看软件安装目录<a hidden class="anchor" aria-hidden="true" href="#查看软件安装目录">#</a></h5>
<p>以下命令可以在基于 Debian 的系统上查看软件的安装路径。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ dpkg -L package
</code></pre></div><h5 id="查看-deb-包内容">查看 deb 包内容<a hidden class="anchor" aria-hidden="true" href="#查看-deb-包内容">#</a></h5>
<p>下列命令可以查看 deb 包内容。它会显示 .deb 包中的一系列文件。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ dpkg -c package.deb
</code></pre></div><h5 id="显示软件的详细信息">显示软件的详细信息<a hidden class="anchor" aria-hidden="true" href="#显示软件的详细信息">#</a></h5>
<p>以下命令可以显示软件的详细信息，如软件名、软件类别、版本、维护者、软件架构、依赖的软件、软件描述等等。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ dpkg -s package
</code></pre></div><h5 id="查看文件属于哪个软件">查看文件属于哪个软件<a hidden class="anchor" aria-hidden="true" href="#查看文件属于哪个软件">#</a></h5>
<p>用以下命令来查看文件属于哪个软件。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ dpkg -S /path/file
</code></pre></div><h5 id="移除删除软件">移除/删除软件<a hidden class="anchor" aria-hidden="true" href="#移除删除软件">#</a></h5>
<p>以下命令可以用来移除/删除一个已经安装的软件，但不删除配置文件。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo dpkg -r package
</code></pre></div><h5 id="清除软件">清除软件<a hidden class="anchor" aria-hidden="true" href="#清除软件">#</a></h5>
<p>以下命令可以用来移除/删除包括配置文件在内的所有文件。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo dpkg -P package
</code></pre></div><h4 id="debian-打包入门httpslinuxcnarticle-9878-1html"><a href="https://linux.cn/article-9878-1.html">Debian 打包入门</a><a hidden class="anchor" aria-hidden="true" href="#debian-打包入门httpslinuxcnarticle-9878-1html">#</a></h4>
<p>deb包本身有三部分组成：</p>
<p><img loading="lazy" src="/Distributions/955092-20210622185420433-515372381.png" alt=""  />
</p>
<p><strong>注</strong>：原文写的不是很好，具体学习还是看官方的 <a href="https://www.debian.org/doc/manuals/maint-guide/index.zh-cn.html"><strong>Debian 新维护者手册</strong></a></p>
<p><a href="https://addons.mozilla.org/nn-NO/thunderbird/addon/cardbook/?src=hp-dl-featured">Cardbook</a> 是用于管理基于 CardDav 和 vCard 标准的联系人的Thunderbird扩展。</p>
<p>使用 <code>dh_make</code> 在当前目录下创建一个 <code>debian</code> 目录。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ dh_make<span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    --native <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    --single <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    --packagename cardbook_1.0.0 <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    --email minkush@example.com
</code></pre></div><p>一些重要的文件，比如 <code>control</code>、<code>rules</code>、<code>changelog</code>、<code>copyright</code> 等文件被初始化其中。所创建的文件的完整列表如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ find debian
debian
debian/manpage.sgml.ex
debian/cardbook.doc-base.EX
debian/changelog
debian/control
debian/postrm.ex
debian/postinst.ex
debian/source
debian/source/format
debian/README.Debian
debian/manpage.1.ex
debian/salsa-ci.yml.ex
debian/rules
debian/cardbook.cron.d.ex
debian/README.source
debian/preinst.ex
debian/prerm.ex
debian/copyright
debian/cardbook-docs.docs
debian/README
debian/manpage.xml.ex
</code></pre></div><p>在当前目录执行 <code>dpkg-buildpackage -us -uc -ui</code> 将会在上层目录创建一个空的包文件以及四个名为 <code>.changes</code>、<code>.deb</code>、 <code>.dsc</code>、 <code>.tar.gz</code> 的文件。</p>
<ul>
<li><code>.dsc</code> 文件包含了所发生的修改和签名</li>
<li><code>.deb</code> 文件是用于安装的主要包文件。</li>
<li><code>.tar.gz</code> （tarball）包含了源代码。</li>
</ul>
<p>这个过程也在 <code>debian/cardbook/usr/share/doc/cardbook</code> 目录下创建了 <code>README</code> 和 <code>changelog</code> 文件。它们包含了关于这个包的基本信息比如描述、作者、版本。</p>
<p>检查这个包安装的内容：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ dpkg -c cardbook_1.0.0_amd64.deb
/usr
/usr/share
/usr/share/doc
/usr/share/doc/cardbook
/usr/share/doc/cardbook/README.Debian
/usr/share/doc/cardbook/changelog.gz
/usr/share/doc/cardbook/copyright
</code></pre></div><h5 id="build-essentialhttpslinuxcnarticle-13953-1html"><a href="https://linux.cn/article-13953-1.html">build-essential</a><a hidden class="anchor" aria-hidden="true" href="#build-essentialhttpslinuxcnarticle-13953-1html">#</a></h5>
<p>在 Ubuntu 中安装构建基础包（<code>build-essential</code>），只需要在终端中简单输入这个命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt update <span style="color:#f92672">&amp;&amp;</span> sudo apt install build-essential
</code></pre></div><p>构建基础包（<code>build-essential</code>）实际上是属于 Debian 的。在它里面其实并不是一个软件。它包含了创建一个 Debian 包（<code>.deb</code>）所需的软件包列表。这些软件包包括 <code>libc</code>、<code>gcc</code>、<code>g++</code>、<code>make</code>、<code>dpkg-dev</code> 等。构建基础包包含这些所需的软件包作为依赖，所以当你安装它时，你只需一个命令就能安装所有这些软件包。</p>
<p>请不要认为构建基础包是一个可以在一个命令中神奇地安装从 Ruby 到 Go 的所有开发工具的超级软件包。它包含一些开发工具，但不是全部。</p>
<h4 id="package-converter">Package converter<a hidden class="anchor" aria-hidden="true" href="#package-converter">#</a></h4>
<ul>
<li><a href="https://github.com/mildred/alien">alien</a>：Alien is really designed to be used to convert from alien file formats to
the packaging format used by the distribution you run it on.</li>
<li><a href="https://github.com/microcai/gentoo-zh">gentoo-zh</a>：gentoo 本质是通过 bash 安装软件，因此，可以参考此仓库尝试手动安装软件。</li>
</ul>
<p><a href="https://askubuntu.com/questions/23818/is-linux-binary-universal-to-all-kinds-of-distributions"><strong>Is linux binary universal to all kinds of distributions?</strong></a></p>
<p>This is two questions:</p>
<p><em>Is a Linux binary universal to all distributions?</em></p>
<p>It depends:</p>
<ul>
<li>If the program is using nothing outside the Linux kernel, it will be universal except for the 32- or 64-bit question. A Linux &ldquo;hello world&rdquo; (a minimalistic program that just prints &ldquo;hello world&rdquo; to a terminal window) could probably be independent of the distribution.</li>
<li>If the program is using any non-kernel library or service (which is most of Linux, the kernel is fairly small), there are differences in which libraries are included, which versions these libraries are and where they are located. So in this (most common) case distributions are not equal.</li>
</ul>
<p><em>Why do many commercial programs say that they only work on one or a few distributions?</em></p>
<p>Because there is a <a href="http://en.wikipedia.org/wiki/List_of_Linux_distributions">very large number of Linux distributions</a>, and nobody wants to test their program on all of them.</p>
<p>A commercial vendor will normally say that they support only the distributions they have tested their software on. It may or may not work on other distributions, from the vendor&rsquo;s perspective the point is just that you can&rsquo;t complain if it does not work on a distribution they don&rsquo;t support.</p>
<p>Which distributions are selected for testing depends on what the vendor expects their customers to be using. Commercial/professional programs commonly pick enterprise distributions, possibly through a reasoning similar to &ldquo;people who paid for their OS are more likely to pay for our software&rdquo;, possibly simply by counting the distributions used by their existing customers.</p>
<p><em>See also Mark Shuttleworth (the guy that is the reason we have an Ubuntu in the first place) on [binary compatibility between Ubuntu and Debian](<a href="https://wiki.ubuntu.com/MarkShuttleworth#What">https://wiki.ubuntu.com/MarkShuttleworth#What</a> about binary compatibility) - Debian is the <a href="http://www.ubuntu.com/community/ubuntu-and-debian">closest distribution relative</a> of Ubuntu.</em></p>
<h3 id="apt">APT<a hidden class="anchor" aria-hidden="true" href="#apt">#</a></h3>
<p>Debian 使用一套名为 Advanced Packaging Tool（APT）的工具来管理包系统。在基于 Debian 的 Linux 发行版中，有各种工具可以与 APT 进行交互，以方便用户安装、删除和管理的软件包。apt-get 便是其中一款广受欢迎的命令行工具，但是最常用的命令都被分散在了 apt-get、apt-cache 和 apt-config 这三条命令当中，apt 命令的引入就是为了解决命令过于分散的问题。（简单来说就是：apt = apt-get、apt-cache 和 apt-config 中最常用命令选项的集合）</p>
<table>
<thead>
<tr>
<th style="text-align:center">apt 命令</th>
<th style="text-align:center">取代的命令</th>
<th style="text-align:center">命令的功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">apt install</td>
<td style="text-align:center">apt-get install</td>
<td style="text-align:center">安装软件包</td>
</tr>
<tr>
<td style="text-align:center">apt remove</td>
<td style="text-align:center">apt-get remove</td>
<td style="text-align:center">移除软件包</td>
</tr>
<tr>
<td style="text-align:center">apt purge</td>
<td style="text-align:center">apt-get purge</td>
<td style="text-align:center">移除软件包及配置文件</td>
</tr>
<tr>
<td style="text-align:center">apt update</td>
<td style="text-align:center">apt-get update</td>
<td style="text-align:center">刷新存储库索引</td>
</tr>
<tr>
<td style="text-align:center">apt upgrade</td>
<td style="text-align:center">apt-get upgrade</td>
<td style="text-align:center">升级所有可升级的软件包</td>
</tr>
<tr>
<td style="text-align:center">apt autoremove</td>
<td style="text-align:center">apt-get autoremove</td>
<td style="text-align:center">自动删除不需要的包</td>
</tr>
<tr>
<td style="text-align:center">apt full-upgrade</td>
<td style="text-align:center">apt-get dist-upgrade</td>
<td style="text-align:center">在升级软件包时自动处理依赖关系</td>
</tr>
<tr>
<td style="text-align:center">apt search</td>
<td style="text-align:center">apt-cache search</td>
<td style="text-align:center">搜索应用程序</td>
</tr>
<tr>
<td style="text-align:center">apt show</td>
<td style="text-align:center">apt-cache show</td>
<td style="text-align:center">显示装细节</td>
</tr>
<tr>
<td style="text-align:center">apt list</td>
<td style="text-align:center"></td>
<td style="text-align:center">列出包含条件的包（已安装，可升级等）</td>
</tr>
<tr>
<td style="text-align:center">apt edit-sources</td>
<td style="text-align:center"></td>
<td style="text-align:center">编辑源列表</td>
</tr>
</tbody>
</table>
<h4 id="列出所有手动安装软件">列出所有手动安装软件<a hidden class="anchor" aria-hidden="true" href="#列出所有手动安装软件">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ apt-mark showmanual
</code></pre></div><h4 id="查看软件包依赖">查看软件包依赖<a hidden class="anchor" aria-hidden="true" href="#查看软件包依赖">#</a></h4>
<p>当你在 Linux 中安装一个软件包，有时这个软件包还需要其他的软件包来使它工作正常。这些额外的软件包就叫作这个包的依赖。假如这些软件包之前没有在系统中被安装，那么这些依赖在安装这个软件包的同时会被自动安装上。</p>
<p><strong>使用 apt show 来查看依赖</strong></p>
<p>你可以使用 apt show 命令 来展示一个包的详细信息。其中依赖信息就是其中一部分，你可以在以 “Depends” 打头的那些行中看到它们。</p>
<p>例如，下面展示的是使用 <code>apt show</code> 展示 ubuntu-restricted-extras 这个包的详细信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ apt show ubuntu-restricted-extras 
Package: ubuntu-restricted-extras
Version: <span style="color:#ae81ff">67</span>
...
Depends: ubuntu-restricted-addons
Recommends: libavcodec-extra, ttf-mscorefonts-installer, unrar
...
</code></pre></div><p>如你所见，<code>ubuntu-restricted-extras</code> 包依赖于 <code>ubuntu-restricted-addons</code> 这个软件包。</p>
<p>但你得小心的是依赖包还可能依赖于其他包，这样一直循环往复直到尽头。但幸好 APT 包管理器可以为你处理这些复杂的依赖关系，自动地安装所有的依赖（大多数情况下）。</p>
<p><strong>什么是推荐包？</strong></p>
<p>你注意到了上面结果输出中以 “Recommends” 开头的那些行了吗？</p>
<p>推荐包不是软件包的直接依赖，但它们可以开启软件包的一些额外功能。</p>
<p>正如你上面看到的那样， <code>ubuntu-restricted-extras</code> 包有 <code>ttf-mscorefonts-installer</code> 这个推荐包，用来在 Ubuntu 上安装 Microsoft 的字体。</p>
<p>这些推荐包也会默认被一同安装上，假如你想显式地禁止这些推荐包的安装，你可以像下面这样使用 <code>–-no-install-recommends</code> 选项。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install --no-install-recommends package_name
</code></pre></div><p><strong>使用 apt-cache 来直接获取依赖信息</strong></p>
<p>上面通过 <code>apt show</code> 的方式会获取到大量信息，假如你想在脚本中获取到依赖信息，那么 <code>apt-cache</code> 命令将会给你一个更好且更简洁的输出结果。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ apt-cache depends package_name
</code></pre></div><p><strong>使用 dpkg 来查看一个 DEB 文件的依赖</strong></p>
<p><code>apt</code> 和 <code>apt-cache</code> 都作用于软件仓库中的软件包，但假如你下载了一个 DEB 文件，那么这两个命令就不起作用了。</p>
<p>在这种情形下，你可以使用 <code>dpkg</code> 命令的 <code>-I</code> 或 <code>--info</code> 选项。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ dpkg -I path_to_deb_file
</code></pre></div><p>依赖信息就可以在以 “Depends” 开头的那些行中找到。</p>
<p><strong>使用 apt-rdepends 来查看依赖及依赖的依赖</strong></p>
<p>假如你想查看更多关于依赖的信息，那么你可以使用 <code>apt-rdepends</code> 工具。这个工具可以创建完整的依赖树。这样你就可以得到一个软件包的依赖以及这些依赖的依赖。</p>
<p>它不是一个常规的 <code>apt</code> 命令，所以你需要从 universe 软件仓库中安装上它：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install apt-rdepends
</code></pre></div><p>这个命令的输出通常很多，取决于依赖树的大小。</p>
<pre tabindex="0"><code>eading package lists... Done
Building dependency tree
Reading state information... Done
shutter
  Depends: procps
  Depends: xdg-utils
imagemagick
  Depends: imagemagick-6.q16 (&gt;= 8:6.9.2.10+dfsg-2~)
imagemagick-6.q16
  Depends: hicolor-icon-theme
  Depends: libc6 (&gt;= 2.4)
  Depends: libmagickcore-6.q16-6 (&gt;= 8:6.9.10.2)
  Depends: libmagickwand-6.q16-6 (&gt;= 8:6.9.10.2)
hicolor-icon-theme
libc6
  Depends: libcrypt1 (&gt;= 1:4.4.10-10ubuntu4)
  Depends: libgcc-s1
libcrypt1
  Depends: libc6 (&gt;= 2.25)
</code></pre><p><code>apt-rdepends</code> 工具的功能非常多样，它还可以用来计算反向依赖。这意味着你可以查看某个特定的包被哪些软件包依赖。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ apt-rdepends -r package_name
</code></pre></div><p>输出可能会非常多，因为它将打印出反向依赖树。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ apt-rdepends -r ffmpeg
Reading package lists... Done
Building dependency tree       
Reading state information... Done
ffmpeg
  Reverse Depends: ardour-video-timeline <span style="color:#f92672">(</span>&gt;<span style="color:#f92672">=</span> 1:5.12.0-3ubuntu4<span style="color:#f92672">)</span>
  Reverse Depends: deepin-screen-recorder <span style="color:#f92672">(</span>5.0.0-1build2<span style="color:#f92672">)</span>
  Reverse Depends: devede <span style="color:#f92672">(</span>4.15.0-2<span style="color:#f92672">)</span>
  Reverse Depends: dvd-slideshow <span style="color:#f92672">(</span>0.8.6.1-1<span style="color:#f92672">)</span>
  Reverse Depends: green-recorder <span style="color:#f92672">(</span>&gt;<span style="color:#f92672">=</span> 3.2.3<span style="color:#f92672">)</span>
</code></pre></div><h4 id="repository-mirror">Repository Mirror<a hidden class="anchor" aria-hidden="true" href="#repository-mirror">#</a></h4>
<p><a href="https://askubuntu.com/questions/39922/how-do-you-select-the-fastest-mirror-from-the-command-line"><strong>Select the fastest mirror</strong></a></p>
<p>You can use <code>deb mirror</code> to have the best mirror picked for you automatically.</p>
<p>apt-get <a href="http://mvogt.wordpress.com/2011/03/21/the-apt-mirror-method/">now supports</a> a &lsquo;mirror&rsquo; method that will automatically select a good mirror based on your location. Putting:</p>
<pre tabindex="0"><code>deb mirror://mirrors.ubuntu.com/mirrors.txt precise main restricted universe multiverse
deb mirror://mirrors.ubuntu.com/mirrors.txt precise-updates main restricted universe multiverse
deb mirror://mirrors.ubuntu.com/mirrors.txt precise-backports main restricted universe multiverse
deb mirror://mirrors.ubuntu.com/mirrors.txt precise-security main restricted universe multiverse
</code></pre><p>on the top in your <code>/etc/apt/sources.list</code> file should be all that is needed to make it automatically pick a mirror for you based on your geographical location.</p>
<p><a href="https://ostechnix.com/how-to-find-best-ubuntu-apt-repository-mirror/"><strong>The command line way</strong></a></p>
<p>There are many command line tools available to find the best APT mirrors based on download speed. I have tested the following tools and they are working just fine in my Ubuntu 20.04 LTS desktop.</p>
<ol>
<li>Apt-select</li>
<li>Apt-smart</li>
</ol>
<h4 id="apt-fasthttpsvituxcomhow-to-speed-up-package-downloads-and-updates-with-apt-fast-on-ubuntu"><a href="https://vitux.com/how-to-speed-up-package-downloads-and-updates-with-apt-fast-on-ubuntu/">apt-fast</a><a hidden class="anchor" aria-hidden="true" href="#apt-fasthttpsvituxcomhow-to-speed-up-package-downloads-and-updates-with-apt-fast-on-ubuntu">#</a></h4>
<p><a href="https://github.com/ilikenwf/apt-fast">apt-fast</a>: A shellscript wrapper for apt that speeds up downloading of packages.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt-get install aria2
$ sudo add-apt-repository ppa:apt-fast/stable
$ sudo apt-get update
$ sudo apt-get -y install apt-fast
$ sudo nano /etc/apt-fast.conf
MIRRORS<span style="color:#f92672">=(</span><span style="color:#e6db74">&#39;https://mirrors.bfsu.edu.cn/ubuntu/,https://mirrors.tuna.tsinghua.edu.cn/ubuntu/&#39;</span><span style="color:#f92672">)</span>
</code></pre></div><h4 id="apt-aria2httplinuxundertheskyblogspotcom201109accelerate-download-of-apt-get-viahtml"><a href="http://linuxunderthesky.blogspot.com/2011/09/accelerate-download-of-apt-get-via.html">apt-aria2</a><a hidden class="anchor" aria-hidden="true" href="#apt-aria2httplinuxundertheskyblogspotcom201109accelerate-download-of-apt-get-viahtml">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">#!/bin/bash
</span><span style="color:#75715e"></span>
<span style="color:#75715e">## apt-aria2: To help download packages faster via aria2, instead of wget.</span>
<span style="color:#75715e">## Author: Anjishnu Sarkar</span>
<span style="color:#75715e">## Version: 0.5</span>
<span style="color:#75715e">## Acknowledgement: This script is a rewrite of the apt-fast script by</span>
<span style="color:#75715e">## Matt Parnell (admin@mattparnell.com) (http://www.mattparnell.com)</span>
<span style="color:#75715e">## Usage: Same as apt-get. Using the option &#34;-y&#34; always.</span>

<span style="color:#75715e">## BUG:</span>
<span style="color:#75715e">## *) If this script is interuppted, then next time aria2 starts downloading</span>
<span style="color:#75715e">## the same from the begining. Can be solved - something to do with .st file.</span>

<span style="color:#75715e">## TODO:</span>
<span style="color:#75715e">## *) Start installing via apt-get as soon as first package is downloaded</span>
<span style="color:#75715e">##    and also keep downloading at the same time. This however might lead</span>
<span style="color:#75715e">##    to dependencies not being satisfied.</span>

<span style="color:#75715e">## Initialization(s):</span>
Download<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;False&#34;</span>
Install<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;True&#34;</span>
Confirm<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;True&#34;</span>
UniqueName<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$RANDOM<span style="color:#e6db74">&#34;</span>
Options<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$@<span style="color:#e6db74">&#34;</span>

<span style="color:#75715e">## Checking for commands which requires download</span>
<span style="color:#66d9ef">while</span> test -n <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>1<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>
<span style="color:#66d9ef">do</span>
    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>1<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span> in
      install|upgrade|dist-upgrade|source|build-dep<span style="color:#f92672">)</span>
        <span style="color:#75715e">## Download</span>
        Download<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;True&#34;</span>
        ;;
      update|remove|autoremove|purge|dselect-upgrade|clean|autoclean|check<span style="color:#f92672">)</span>
        <span style="color:#75715e">## Anything other than download</span>
        Download<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;False&#34;</span>
        ;;
     -d<span style="color:#f92672">)</span> <span style="color:#75715e">## Download only (don&#39;t install)</span>
        Install<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;False&#34;</span>
        ;;
     -y<span style="color:#f92672">)</span> <span style="color:#75715e">## No need to ask for confirmation</span>
        Confirm<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;False&#34;</span>
        ;;
      *<span style="color:#f92672">)</span>
        <span style="color:#75715e">## Nothing to be done. If any wrong options/commands are given then</span>
        <span style="color:#75715e">## let apt-get handle it.</span>
        ;;
    <span style="color:#66d9ef">esac</span>
    shift
<span style="color:#66d9ef">done</span>

<span style="color:#75715e">## In case download is true</span>
<span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> <span style="color:#e6db74">&#34;</span>$Download<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;True&#34;</span> <span style="color:#f92672">]</span>;<span style="color:#66d9ef">then</span>

    <span style="color:#75715e">## Installing pre-requisite(s): aria2</span>
    <span style="color:#66d9ef">if</span> ! which aria2c &gt; /dev/null; <span style="color:#66d9ef">then</span>
        echo <span style="color:#e6db74">&#34;Aria2 not installed. Installing aria2 first via apt-get&#34;</span>
        apt-get -y --force-yes install aria2
    <span style="color:#66d9ef">fi</span>

    ArchiveDir<span style="color:#f92672">=</span>/var/cache/apt/archives/
    cd <span style="color:#e6db74">${</span>ArchiveDir<span style="color:#e6db74">}</span>/partial

    PrintUris<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>apt-get --yes --print-uris <span style="color:#e6db74">${</span>Options<span style="color:#e6db74">}</span><span style="color:#66d9ef">)</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> $? -ne <span style="color:#ae81ff">0</span> <span style="color:#f92672">]</span>;<span style="color:#66d9ef">then</span>
        echo <span style="color:#e6db74">&#34;Aborting.&#34;</span>
        exit <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">fi</span>

    PackageInfo<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>echo <span style="color:#e6db74">&#34;</span>$PrintUris<span style="color:#e6db74">&#34;</span> | awk <span style="color:#e6db74">&#39;/Reading package/,/After this operation/&#39;</span><span style="color:#66d9ef">)</span>
<span style="color:#75715e">#     echo &#34;$PrintUris&#34; | grep ^\&#39; | cut -d\&#39; -f2 &gt; &#34;$UniqueName&#34;-uris.txt</span>
    echo <span style="color:#e6db74">&#34;</span>$PrintUris<span style="color:#e6db74">&#34;</span> | grep <span style="color:#e6db74">&#34;http:&#34;</span> | cut -d<span style="color:#ae81ff">\&#39;</span> -f2 &gt; <span style="color:#e6db74">&#34;</span>$UniqueName<span style="color:#e6db74">&#34;</span>-uris.txt
    NumberOfPackages<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>wc -l <span style="color:#e6db74">&#34;</span>$UniqueName<span style="color:#e6db74">&#34;</span>-uris.txt | awk <span style="color:#e6db74">&#39;{print $1}&#39;</span><span style="color:#66d9ef">)</span>

    <span style="color:#75715e">## Print info</span>
    echo <span style="color:#e6db74">&#34;</span>$PackageInfo<span style="color:#e6db74">&#34;</span>
    echo <span style="color:#e6db74">&#34;Number of packages to be downloaded: </span>$NumberOfPackages<span style="color:#e6db74">&#34;</span>

    <span style="color:#75715e">## Check whether package has already been installed or not</span>
    InstallUpgradeMsg<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>echo <span style="color:#e6db74">&#34;</span>$PackageInfo<span style="color:#e6db74">&#34;</span> | grep <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>        -e <span style="color:#e6db74">&#34;The following NEW packages will be installed:&#34;</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>        -e <span style="color:#e6db74">&#34;The following packages will be upgraded:&#34;</span><span style="color:#66d9ef">)</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> -z <span style="color:#e6db74">&#34;</span>$InstallUpgradeMsg<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span>;<span style="color:#66d9ef">then</span>
        rm -f <span style="color:#e6db74">&#34;</span>$UniqueName<span style="color:#e6db74">&#34;</span>-uris.txt
        exit <span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">fi</span>
    <span style="color:#75715e">## In $InstallUpgradeMsg is not null, then proceed...</span>

    <span style="color:#75715e">## If confirm is true</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> <span style="color:#e6db74">&#34;</span>$Confirm<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;True&#34;</span> <span style="color:#f92672">]</span>;<span style="color:#66d9ef">then</span>
        echo -n <span style="color:#e6db74">&#34;Do you want to continue [y|n]? &#34;</span>
        read Ans

        <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;</span>$Ans<span style="color:#e6db74">&#34;</span> in
            y|yes|<span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">)</span>   ;;

            n|no|*<span style="color:#f92672">)</span>     echo <span style="color:#e6db74">&#34;Abort.&#34;</span>
                        rm -f <span style="color:#e6db74">&#34;</span>$UniqueName<span style="color:#e6db74">&#34;</span>-uris.txt
                        exit <span style="color:#ae81ff">1</span> ;;
        <span style="color:#66d9ef">esac</span>
    <span style="color:#66d9ef">fi</span>

    <span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> $NumberOfPackages -ne <span style="color:#ae81ff">0</span> <span style="color:#f92672">]</span>;<span style="color:#66d9ef">then</span>
        <span style="color:#75715e">## Downloading the packages</span>
        echo <span style="color:#e6db74">&#34;Proceeding with downloading ...&#34;</span>
        <span style="color:#66d9ef">while</span> read DebUrl
        <span style="color:#66d9ef">do</span>
            DebName<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>basename <span style="color:#e6db74">&#34;</span>$DebUrl<span style="color:#e6db74">&#34;</span><span style="color:#66d9ef">)</span>
            echo <span style="color:#e6db74">&#34;</span>$DebName<span style="color:#e6db74">&#34;</span>

            AptConf<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;/etc/apt/apt.conf&#34;</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> -f <span style="color:#e6db74">&#34;</span>$AptConf<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span>;<span style="color:#66d9ef">then</span>
                http_proxy<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>grep -i <span style="color:#e6db74">&#34;http::proxy&#34;</span> <span style="color:#e6db74">&#34;</span>$AptConf<span style="color:#e6db74">&#34;</span> | cut -d <span style="color:#ae81ff">\&#34;</span> -f2<span style="color:#66d9ef">)</span>
            <span style="color:#66d9ef">fi</span>

            <span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> -n <span style="color:#e6db74">&#34;</span>$http_proxy<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span>;<span style="color:#66d9ef">then</span>
                echo <span style="color:#e6db74">&#34;Using proxy...&#34;</span>
                aria2c -c -s <span style="color:#ae81ff">10</span> -j <span style="color:#ae81ff">10</span> --http-proxy<span style="color:#f92672">=</span>$http_proxy <span style="color:#e6db74">&#34;</span>$DebUrl<span style="color:#e6db74">&#34;</span>
            <span style="color:#66d9ef">else</span>
                echo <span style="color:#e6db74">&#34;Not using proxy...&#34;</span>
                aria2c -c -s <span style="color:#ae81ff">10</span> -j <span style="color:#ae81ff">10</span> <span style="color:#e6db74">&#34;</span>$DebUrl<span style="color:#e6db74">&#34;</span>
            <span style="color:#66d9ef">fi</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> $? -eq <span style="color:#ae81ff">0</span> <span style="color:#f92672">]</span>;<span style="color:#66d9ef">then</span>
                mv $DebName <span style="color:#e6db74">${</span>ArchiveDir<span style="color:#e6db74">}</span>
            <span style="color:#66d9ef">fi</span>
        <span style="color:#66d9ef">done</span> &lt; <span style="color:#e6db74">&#34;</span>$UniqueName<span style="color:#e6db74">&#34;</span>-uris.txt
    <span style="color:#66d9ef">fi</span>
    rm -f <span style="color:#e6db74">&#34;</span>$UniqueName<span style="color:#e6db74">&#34;</span>-uris.txt

<span style="color:#75715e">#     echo &#34;Installing...&#34;</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> <span style="color:#e6db74">&#34;</span>$Install<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;True&#34;</span> <span style="color:#f92672">]</span>;<span style="color:#66d9ef">then</span>
        apt-get -y --force-yes <span style="color:#e6db74">${</span>Options<span style="color:#e6db74">}</span>
    <span style="color:#66d9ef">fi</span>
<span style="color:#66d9ef">else</span>
<span style="color:#75715e">## Cases when download is false</span>
    apt-get <span style="color:#e6db74">${</span>Options<span style="color:#e6db74">}</span>
<span style="color:#66d9ef">fi</span>
</code></pre></div><h3 id="ppahttpslinuxcnarticle-10456-1html"><a href="https://linux.cn/article-10456-1.html">PPA</a><a hidden class="anchor" aria-hidden="true" href="#ppahttpslinuxcnarticle-10456-1html">#</a></h3>
<p>软件仓库是一组文件，其中包含各种软件及其版本的信息，以及校验和等其他一些详细信息。每个版本的 Ubuntu 都有自己的四个官方软件仓库：</p>
<ul>
<li>Main - Canonical 支持的自由开源软件。</li>
<li>Universe - 社区维护的自由开源软件。</li>
<li>Restricted - 设备的专有驱动程序。</li>
<li>Multiverse - 受版权或法律问题限制的软件。</li>
</ul>
<p>你可以在 <a href="http://archive.ubuntu.com/ubuntu/dists/">这里</a> 看到所有版本的 Ubuntu 的软件仓库。你可以浏览并转到各个仓库。</p>
<p>这些信息存储在系统的 <code>/etc/apt/sources.list</code> 文件中。如果查看此文件的内容，你就会看到里面有软件仓库的网址。<code>#</code> 开头的行将被忽略。</p>
<p>Ubuntu 不会在官方仓库中立即提供新版本的软件。他们需要一个步骤来检查此新版本的软件是否与系统兼容，从而可以确保系统的稳定性。这意味着它需要经过几周才能在 Ubuntu 上可用，在某些情况下，这可能需要几个月的时间。</p>
<p>为获取最新版本的软件，需要使用 PPA，PPA (Personal Package Archives) 允许开发者上传要构建的 Ubuntu 源包，并通过 <a href="https://launchpad.net/">Launchpad</a> 作为 apt 的软件仓库发布。</p>
<p>通过如下命令添加 PPA 软件仓库并获取最新版本软件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo add-apt-repository &lt;PPA_info&gt;
$ sudo apt-get update
$ sudo apt-get install &lt;package_in_PPA&gt;
</code></pre></div><p>当你使用 PPA 时，它不会更改原始的 <code>sources.list</code> 文件。相反，它在 <code>/etc/apt/sources.d</code> 目录中创建了两个文件，一个 <code>.list</code> 文件和一个带有 <code>.save</code> 后缀的备份文件。这是一种安全措施，可以确保添加的 PPA 不会和原始的 <code>sources.list</code> 文件弄混，它还有助于移除 PPA。</p>
<p>开发人员为他们的软件创建的 PPA 称为官方 PPA。但有时，个人会创建由其他开发人员所创建的项目的 PPA。为什么会有人这样做？ 因为许多开发人员只提供软件的源代码。</p>
<p>如果 PPA 不适用于你的系统版本，你可以点击应用程序 PPA 页面的 View package details，在这里，你可以单击软件包以显示更多详细信息，还可以在此处找到包的源代码和 DEB 文件。建议 <a href="https://itsfoss.com/gdebi-default-ubuntu-software-center/">使用 Gdebi 安装这些 DEB 文件</a> 而不是通过软件中心，因为 Gdebi 在处理依赖项方面要好得多。</p>
<p>就安全性而言，很少见到因为使用 PPA 之后你的 Linux 系统被黑客攻击或注入恶意软件。到目前为止，我不记得发生过这样的事件。官方 PPA 可以不加考虑的使用，使用非官方 PPA 完全是你自己的决定。根据经验，如果程序需要 sudo 权限，则应避免通过第三方 PPA 进行安装。</p>
<h3 id="snap--flatpak">Snap &amp; Flatpak<a hidden class="anchor" aria-hidden="true" href="#snap--flatpak">#</a></h3>
<p><strong><a href="https://merlijn.sebrechts.be/blog/2020-07-03-snap-vs-flatpak/">A fundamental difference between Snap and Flatpak</a></strong></p>
<p>Flatpak is designed to install and update “apps”; user-facing software such as video editors, chat programs and more.</p>
<p>snaps can install anything which contains a kernel, printer drivers, audio subsystems and more.</p>
<p>Snap and Flatpak are the software behind two universal Linux app stores: the <a href="https://snapcraft.io/store">Snap Store</a> and <a href="https://flathub.org/">Flathub</a><em>.</em></p>
<h4 id="讨论">讨论<a hidden class="anchor" aria-hidden="true" href="#讨论">#</a></h4>
<p><strong>openSUSE 群</strong></p>
<p>Flatpak使用bubblewrap来隔离应用程序，bwrap是非常轻量化的沙箱程序，因此攻击面极小。但bwrap需要用户对Linux程序工作方式有准确的了解（使用哪些syscall），Flatpak相当于充当了一个bwrap的前端帮助控制bwrap权限。</p>
<p>目前Flatpak的问题在于seccomp权限太过广泛，但目前Flatpak维护者已经意识到了这个问题（注释：在他们踩了一次坑之后），已经计划打算解决了。</p>
<p>另一个问题是程序请求的权限过于广泛，但这更多是一个决策问题而不是技术问题，而且你可以用Flatseal手动调整权限。</p>
<p>Flatpak你不能用常规程序方式来理解，每个程序都是一个完全独立的空间，只有给予了权限才有对应访问权，也可以用Portals调用文件选择器来获得单独一个文件的完全访问权，Flatpak版的Steam是把所有程序配置文件放在~/.var/app里面了，类似安卓下面的分区存储做法。</p>
<p>AppImage就只是个自挂载程序，自带的文件透明挂载到它自己的根文件系统下面，所以依然依赖主机的一部分库。所以是的，跟打包者用的系统有关系。</p>
<p>Flatpak不是这种机制，每个Flatpak空间是完全空白的，需要打包者自己选择加入哪些东西，所以Flatpak跨发行版的兼容性也更好。</p>
<p>良好打包的AppImage可以有很好的跨发行版兼容性，但是代价就是需要手工测试每个发行版下面的效果。在跨发行版兼容性这点上我更看好Flatpak。</p>
<p>最后，不要跟我提Snap，我不想碰那个东西，也对它没有研究的兴趣。</p>
<p>Flatpak确实有很多可取之处，或者不能说是Flatpak可取，而是Linux桌面软件生态现状决定了，只有更激进的手段才能改变现状。</p>
<p>AppImage那种策略还是过于不痛不痒了，结果就是程序仅仅是被打包成一个个单文件，但背后的库依赖地狱、权限隔离问题一个都没解决。</p>
<p>但AppImage作者的想法本来也不是靠AppImage颠覆，他是希望Linux能够重新恢复LSB，确保发行版之间的兼容性本身可靠而不是依赖Flatpak这些技术，就类似于Windows上的软件不需要什么沙箱模拟器，你几乎可以保证旧版本的软件能在新版本运行。</p>
<p>其实也可以说明，微软那种在桌面上采取的策略，很可能难以在Linux社区里推广开来，微软那种做法，确保绝对的向下兼容性，不是谁都有精力来做的。</p>
<p>比如说如果让微软来做Wayland，那微软根本就不会把Wayland做出来，而是把X11一直迭代、削减臃肿功能直到性能和现代化图形技术栈的性能相匹敌，同时确保向下兼容性。而最新一代的X11很可能和最早的X11已经彻底不一样了，甚至会有“检测程序版本然后自动匹配对应的X11功能”这些奇怪的兼容性策略出来。或许有一天微软会把新项目叫做Wayland，但这个改名也仅仅是营销目的而不是技术目的。</p>
<p>毕竟LSB已经没了，Ubuntu甚至砍掉32位兼容性，也可以说明其实Linux这边并没有太多人在乎这问题。</p>
<p>毕竟“反正源代码都在那，重新编译一遍不就好了吗”</p>
<p><strong>Fedora 群</strong></p>
<p>空のあお, [2/28/22 8:25 PM]
软件有不同版本的依赖
这些依赖很难共存
有些旧版依赖还有更旧的依赖
不说二进制兼容，有些连源码兼容都搞不定
就算搞定了，一段时间过后依赖升级了，还是得坏
flatpak的做法是维护abi稳定的qt和gtk两大ui库和必要桌面库的runtime，用来公用
通过容器隔离app，让每个app自己构建所需的特定依赖到容器里</p>
<p>竹林里有冰, [2/28/22 8:33 PM]
sandbox他是用bubblewrap实现的吧，你可以直接使用bubblewrap，应该一样可以做到他的沙盒化，更小巧一点
bubblewrap的缺点就是需要针对每个程序写上配置，除了有点麻烦其他倒还不错</p>
<p>Neomonk Zen, [2/28/22 8:36 PM]
也不知flatpak的软件仓库，有没什么审核机制来防止恶意软件，如果没有的话，那还蛮可怕的，想想Chrome和Android的软件市场，都有很多恶意软件</p>
<p>Robin Lee, [2/28/22 8:39 PM]
没有深入的审核，跟各大发行版的官方包差不多，但flatpak可以限制应用权限</p>
<h4 id="在-ubuntu-上使用-flatpakhttpsflatpakorgsetupubuntu"><a href="https://flatpak.org/setup/Ubuntu/">在 Ubuntu 上使用 Flatpak</a><a hidden class="anchor" aria-hidden="true" href="#在-ubuntu-上使用-flatpakhttpsflatpakorgsetupubuntu">#</a></h4>
<p>The official Flatpak PPA is the recommended way to install Flatpak. To install it, run the following in a terminal:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo add-apt-repository ppa:flatpak/stable
$ sudo apt update
$ sudo apt install flatpak
</code></pre></div><p>Flathub is the best place to get Flatpak apps. To enable it, run:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo
</code></pre></div><p>To complete setup, <strong>restart</strong> your system. Now all you have to do is <a href="https://flathub.org/">install some apps</a>!</p>
<h4 id="questions">Questions<a hidden class="anchor" aria-hidden="true" href="#questions">#</a></h4>
<p><strong><a href="https://blog.csdn.net/u011870280/article/details/80213866">snap &ldquo;canonical-livepatch&rdquo; has &ldquo;install-snap&rdquo; change in progress</a></strong></p>
<p>Snap 包是 Ubuntu 16.04 LTS 发布时引入的新应用格式包。目前已流行在很多 Linux 发行版上。并且可以很方便地安装常用软件，如 VLC、Sublime Text、VSCode、Node、WPS等</p>
<p>当你在安装完 Snap 后，你会发现在在根目录下会出现如 /dev/loop0 的挂载点，这些挂载点正是 Snap 软件包的目录。</p>
<ul>
<li>
<p>原因是软件之前安装了一次，只是安装失败。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ snap changessnap abort <span style="color:#ae81ff">5</span>        <span style="color:#75715e">## 5 为安装失败软件的 ID</span>
</code></pre></div></li>
<li>
<p>现在重新安装</p>
</li>
</ul>
<p>一些软件最好在官网下载或在 Snap 中下载，官方 Repository 可能并不新，比如 VLC。</p>
<h3 id="tasksel-install-group-softwarehttpswwwcybercitibizfaqtasksel-install-group-software-in-command-line"><a href="https://www.cyberciti.biz/faq/tasksel-install-group-software-in-command-line/">tasksel: Install Group Software</a><a hidden class="anchor" aria-hidden="true" href="#tasksel-install-group-softwarehttpswwwcybercitibizfaqtasksel-install-group-software-in-command-line">#</a></h3>
<p>安装</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install tasksel
</code></pre></div><p>list tasks</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ tasksel --list-tasks
</code></pre></div><p>displays description</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ tasksel --task-desc dns-server
</code></pre></div><p>install</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install dns-server
</code></pre></div><h3 id="pacstallhttpsgithubcompacstallpacstall"><a href="https://github.com/pacstall/pacstall">pacstall</a><a hidden class="anchor" aria-hidden="true" href="#pacstallhttpsgithubcompacstallpacstall">#</a></h3>
<p>An AUR-inspired package manager for Ubuntu</p>
<h3 id="appimagehttpsappimageorg"><a href="https://appimage.org/">AppImage</a><a hidden class="anchor" aria-hidden="true" href="#appimagehttpsappimageorg">#</a></h3>
<p>Linux apps that run anywhere</p>
<h3 id="包管理器的进化httpslinuxcnarticle-9931-1html"><a href="https://linux.cn/article-9931-1.html">包管理器的进化</a><a hidden class="anchor" aria-hidden="true" href="#包管理器的进化httpslinuxcnarticle-9931-1html">#</a></h3>
<p>今天，每个可计算设备都会使用某种软件来完成预定的任务。在软件开发的上古时期，为了找出软件中的 bug 和其它缺陷，软件会被严格的测试。在近十年间，软件被通过互联网来频繁分发，以试图通过持续不断的安装新版本的软件来解决软件的缺陷问题。在很多情况下，每个独立的应用软件都有其自带的更新器。而其它一些软件则让用户自己去搞明白如何获取和升级软件。</p>
<p>Linux 较早采用了维护一个中心化的软件仓库来发布软件更新这种做法，用户可以在这个软件仓库里查找并安装软件。在这篇文章里， 笔者将回顾在 Linux 上的如何进行软件安装的历史，以及现代操作系统如何保持更新以应对<a href="https://en.wikipedia.org/wiki/Common_Vulnerabilities_and_Exposures">软件安全漏洞（CVE）</a>不断的曝光。</p>
<h4 id="手动安装软件">手动安装软件<a hidden class="anchor" aria-hidden="true" href="#手动安装软件">#</a></h4>
<p>曾几何时，软件都是通过 FTP 或邮件列表（LCTT 译注：即通过邮件列表发布源代码的补丁包）来分发的（最终这些发布方式在互联网的迅猛发展下都演化成为一个个现今常见的软件发布网站）。（一般在一个 tar 文件中）只有一个非常小的文件包含了创建二进制的说明。你需要做的是先解压这个包，然后仔细阅读当中的 <code>README</code> 文件， 如果你的系统上恰好有 GCC（LCTT 译注：GNU C Compiler）或者其它厂商的 C 编译器的话，你得首先运行 <code>./configure</code> 脚本，并在脚本后添加相应的参数，如库函数的路径、创建可执行文件的路径等等。除此之外，这个配置过程也会检查你操作系统上的软件依赖是否满足安装要求。如果缺失了任何主要的依赖，该配置脚本会退出不再继续安装，直到你满足了该依赖。如果该配置脚本正常执行完毕，将会创建一个 <code>Makefile</code> 文件。</p>
<p>当有了一个 <code>Makefile</code> 文件时， 你就可以接下去执行 <code>make</code> 命令（该命令由你所使用的编译器提供）。<code>make</code> 命令也有很多参数，被称为 <code>make</code> 标识flag，这些标识能为你的系统优化最终生成出来的二进制可执行文件。在计算机世界的早期，这些优化是非常重要的，因为彼时的计算机硬件正在为了跟上软件迅速的发展而疲于奔命。今日今时，编译标识变得更加通用而不是为了优化哪些具体的硬件型号，这得益于现代硬件和现代软件相比已经变得成本低廉，唾手可得。</p>
<p>最后，在 <code>make</code> 完成之后， 你需要运行 <code>make install</code> （或 <code>sudo make install</code>）（LCTT 译注：依赖于你的用户权限） 来“真正”将这个软件安装到你的系统上。可以想象，为你系统上的每一个软件都执行上述的流程将是多么无聊费时，更不用说如果更新一个已经安装的软件将会多复杂，多么需要精力投入。（LCTT 译注：上述流程也称 CMMI 安装， 即Configure、Make、Make Install）</p>
<h4 id="软件包">软件包<a hidden class="anchor" aria-hidden="true" href="#软件包">#</a></h4>
<p>package（LCTT 译注：下文简称“包”）这个概念是用来解决在软件安装、升级过程中的复杂性的。包将软件安装升级中需要的多个数据文件合并成一个单独的文件，这将便于传输和（通过压缩文件来）减小存储空间（LCTT 译注：减少存储空间这一点在现在已经不再重要），包中的二进制可执行文件已根据开发者所选择的编译标识预编译。包本身包括了所有需要的元数据，如软件的名字、软件的说明、版本号，以及要运行这个软件所需要的依赖包等等。</p>
<p>不同流派的 Linux 发行版都创造了它们自己的包格式，其中最常用的包格式有：</p>
<ul>
<li>.deb：这种包格式由 Debian、Ubuntu、Linux Mint 以及其它的变种使用。这是最早被发明的包类型。</li>
<li>.rpm：这种包格式最初被称作红帽包管理器Red Hat Package Manager（LCTT 译注： 取自英文的首字母）。使用这种包的 Linux 发行版有 Red Hat、Fedora、SUSE 以及其它一些较小的发行版。</li>
<li>.tar.xz：这种包格式只是一个软件压缩包而已，这是 Arch Linux 所使用的格式。</li>
</ul>
<p>尽管上述的包格式自身并不能直接管理软件的依赖问题，但是它们的出现将 Linux 软件包管理向前推进了一大步。</p>
<h4 id="软件仓库">软件仓库<a hidden class="anchor" aria-hidden="true" href="#软件仓库">#</a></h4>
<p>多年以前（当智能电话还没有像现在这样流行时），非 Linux 世界的用户是很难理解软件仓库的概念的。甚至今时今日，大多数完全工作在 Windows 下的用户还是习惯于打开浏览器，搜索要安装的软件（或升级包），下载然后安装。但是，智能电话传播了软件“商店”（LCTT 译注： 对应 Linux 里的软件仓库）这样一个概念。智能电话用户获取软件的方式和包管理器的工作方式已经非常相近了。些许不同的是，尽管大多数软件商店还在费力美化它的图形界面来吸引用户，大多数 Linux 用户还是愿意使用命令行来安装软件。总而言之，软件仓库是一个中心化的可安装软件列表，上面列举了在当前系统中预先配置好的软件仓库里所有可以安装的软件。</p>
<h4 id="包管理器">包管理器<a hidden class="anchor" aria-hidden="true" href="#包管理器">#</a></h4>
<p>包管理器用来和相应的软件仓库交互，获取软件的相应信息。下面对流行做一个简短介绍。</p>
<h5 id="基于-prm-包格式的包管理器">基于 PRM 包格式的包管理器<a hidden class="anchor" aria-hidden="true" href="#基于-prm-包格式的包管理器">#</a></h5>
<p>更新基于 RPM 的系统，特别是那些基于 Red Hat 技术的系统，有着非常有趣而又详实的历史。实际上，现在的 <a href="https://en.wikipedia.org/wiki/Yum_(software)">YUM</a> 版本（用于 企业级发行版）和 <a href="https://fedoraproject.org/wiki/DNF">DNF</a>（用于社区版）就融合了好几个开源项目来提供它们现在的功能。</p>
<p>Red Hat 最初使用的包管理器，被称为 <a href="https://en.wikipedia.org/wiki/Rpm_(software)">RPM</a>（红帽包管理器Red Hat Package Manager），时至今日还在使用着。不过，它的主要作用是安装本地的 RPM 包，而不是去在软件仓库搜索软件。后来开发了一个叫 <code>up2date</code> 的包管理器，它被用来通知用户包的最新更新，还能让用户在远程仓库里搜索软件并便捷的安装软件的依赖。尽管这个包管理器尽职尽责，但一些社区成员还是感觉 <code>up2date</code> 有着明显的不足。</p>
<p>现在的 YUM 来自于好几个不同社区的努力。1999-2001 年一群在 Terra Soft Solution 的伙计们开发了Yellowdog Updater（YUP），将其作为 <a href="https://en.wikipedia.org/wiki/Yellow_Dog_Linux">Yellow Dog Linux</a> 图形安装器的后端。杜克大学Duke University喜欢这个主意就决定去增强它的功能，它们开发了<a href="https://www.archlinux.org/">Yellowdog Updater, Modified（YUM）</a>，这最终被用来帮助管理杜克大学的 Red Hat 系统。Yum 壮大的很快，到 2005 年，它已经被超过一半的 Linux 市场所采用。今日，几乎所有的使用 RPM 的的 Linux 都会使用 YUM 来进行包管理（当然也有一些例外）。</p>
<p><a href="https://en.wikipedia.org/wiki/DNF_(software)">Dandified Yum（DNF）</a>是 YUM 的下一代接班人。从 Fedora 18 开始被作为包管理器引入系统，不过它并没有被企业版所采用，所以它只在 Fedora（以及变种）上占据了主导地位。DNF 的用法和 YUM 几乎一模一样，它主要是用来解决性能问题、晦涩无说明的API、缓慢/不可靠的依赖解析，以及偶尔的高内存占用。DNF 是作为 YUM 的直接替代品来开发的，因此这里笔者就不重复它的用法了，你只用简单的将 <code>yum</code> 替换为 <code>dnf</code> 就行了。</p>
<p><a href="https://en.opensuse.org/Portal:Zypper">Zypper</a> 是用来管理 RPM 包的另外一个包管理器。这个包管理器主要用于 <a href="https://www.suse.com/">SUSE</a>（和 <a href="https://www.opensuse.org/">openSUSE</a>），在<a href="https://en.wikipedia.org/wiki/MeeGo">MeeGo</a>、<a href="https://sailfishos.org/">Sailfish OS</a>、<a href="https://www.tizen.org/">Tizen</a> 上也有使用。它最初开发于 2006 年，已经经过了多次迭代。除了作为系统管理工具 <a href="https://en.wikipedia.org/wiki/YaST">YaST</a> 的后端和有些用户认为它比 YUM 要快之外也没有什么好多说的。</p>
<h5 id="基于-debian-的包管理器">基于 Debian 的包管理器<a hidden class="anchor" aria-hidden="true" href="#基于-debian-的包管理器">#</a></h5>
<p>作为一个现今仍在被积极维护的最古老的 Linux 发行版之一，Debian 的包管理系统和基于 RPM 的系统的包管理系统非常类似。它使用扩展名为 “.deb” 的包，这种文件能被一个叫做 <code>dpkg</code> 的工具所管理。<code>dpgk</code> 同 <code>rpm</code> 非常相似，它被设计成用来管理在存在于本地（硬盘）的包。它不会去做包依赖关系解析（它会做依赖关系检查，不过仅此而已），而且在同远程软件仓库交互上也并无可靠的途径。为了提高用户体验并便于使用，Debian 项目开始了一个软件项目：Deity，最终这个代号被丢弃并改成了现在的 <a href="https://en.wikipedia.org/wiki/APT_(Debian)">Advanced Pack Tool（APT）</a>。</p>
<p>在 1998 年，APT 测试版本发布（甚至早于 1999 年的 Debian 2.1 发布），许多用户认为 APT 是基于 Debian 系统标配功能之一。APT 使用了和 RPM 一样的风格来管理仓库，不过和 YUM 使用单独的 .repo 文件不同，APT 曾经使用 <code>/etc/apt/sources.list</code> 文件来管理软件仓库，后来的变成也可以使用 <code>/etc/apt/sources.d</code> 目录来管理。如同基于 RPM 的系统一样，你也有很多很多选项配置来完成同样的事情。你可以编辑和创建前述的文件，或者使用图形界面来完成上述工作（如 Ubuntu 的“Software &amp; Updates”）。</p>
<p>现今大多数的 Ubuntu 教程里都径直使用了 <code>apt</code>。 单独一个 <code>apt</code> 设计用来实现那些最常用的 APT 命令的。<code>apt</code> 命令看上去是用来整合那些被分散在 <code>apt-get</code>、<code>apt-cache</code> 以及其它一些命令的的功能的。它还加上了一些额外的改进，如色彩、进度条以及其它一些小功能。</p>
<h5 id="基于-arch-的包管理器">基于 Arch 的包管理器<a hidden class="anchor" aria-hidden="true" href="#基于-arch-的包管理器">#</a></h5>
<p><a href="https://www.archlinux.org/">Arch Linux</a> 使用称为 <a href="https://wiki.archlinux.org/index.php/pacman">packman</a> 的包管理器。和 .deb 以及 .rpm 不同，它使用更为传统的 LZMA2 压缩包形式 .tar.xz 。这可以使 Arch Linux 包能够比其它形式的压缩包（如 gzip）有更小的尺寸。自从 2002 年首次发布以来， <code>pacman</code> 一直在稳定发布和改善。使用它最大的好处之一是它支持 <a href="https://wiki.archlinux.org/index.php/Arch_Build_System">Arch Build System</a>，这是一个从源代码级别构建包的构建系统。该构建系统借助一个叫 <code>PKGBUILD</code> 的文件，这个文件包含了如版本号、发布号、依赖等等的元数据，以及一个为编译遵守 Arch Linux 需求的包所需要的带有必要的编译选项的脚本。而编译的结果就是前文所提的被 <code>pacman</code> 所使用的 .tar.xz 的文件。</p>
<p>上述的这套系统技术上导致了 <a href="https://aur.archlinux.org/">Arch User Respository（AUR）</a>的产生，这是一个社区驱动的软件仓库，仓库里包括有 <code>PKGBUILD</code> 文件以及支持补丁或脚本。这给 Arch Linux 带了无穷无尽的软件资源。最为明显的好处是如果一个用户（或开发者）希望他开发的软件能被广大公众所使用，他不必通过官方途径去在主流软件仓库获得许可。而不利之处则是它必须将依赖社区的流程，类似于 <a href="https://hub.docker.com/">Docker Hub</a>、 Canonical 的 Snap Packages（LCTT 译注： Canonical 是 Ubuntu 的发行公司），或者其它类似的机制。</p>
<p>有很多特定于 AUR 的包管理器能被用来从 AUR 里的 <code>PGKBUILD</code> 文件下载、编译、安装。其中 <code>yaourt</code> 和 <code>pacaur</code> 颇为流行。不过，这两个项目已经被 <a href="https://wiki.archlinux.org/index.php/AUR_helpers#Discontinued_or_problematic">Arch Wiki</a> 列为“不继续开发以及有已知的问题未解决”。因为这个原因，这里直接讨论 <code>aurman</code>，除了会搜索 AUR 以及包含几个有帮助的（其实很危险）的选项之外，它的工作机制和 <code>pacman</code> 极其类似。</p>
<h3 id="condahttpswwwjianshucompedaa744ea47d"><a href="https://www.jianshu.com/p/edaa744ea47d">conda</a><a hidden class="anchor" aria-hidden="true" href="#condahttpswwwjianshucompedaa744ea47d">#</a></h3>
<h4 id="简介">简介<a hidden class="anchor" aria-hidden="true" href="#简介">#</a></h4>
<p>Conda 是一个开源的软件包管理系统和环境管理系统，用于安装多个版本的软件包及其依赖关系，并在它们之间轻松切换。 Conda 是为 Python 程序创建的，适用于 Linux，OS X 和 Windows，也可以打包和分发其他软件。</p>
<h4 id="安装">安装<a hidden class="anchor" aria-hidden="true" href="#安装">#</a></h4>
<p>conda分为anaconda和miniconda。anaconda是包含一些常用包的版本（这里的常用不代表你常用），miniconda则是精简版，需要啥装啥，所以推荐使用miniconda。</p>
<p>miniconda官网：https://conda.io/miniconda.html</p>
<p>选择适合自己的版本下载：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ wget -c https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh
</code></pre></div><p>这里选择的是<code>latest-Linux</code>版本，所以下载的程序会随着python的版本更新而更新。</p>
<p>安装：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ chmod <span style="color:#ae81ff">777</span> Miniconda3-latest-Linux-x86_64.sh
$ bash Miniconda3-latest-Linux-x86_64.sh
</code></pre></div><p>加不加入环境变量都可以。所谓的会污染环境等等问题可能都是将大量的软件直接安装在conda的base环境中引起的，只要养成好的使用习惯，灵活使用conda create 命令将不同的软件安装到自己单独的虚拟环境中就可以了。把conda这条蟒蛇关进一个一个的笼子里，才能更好的为我们的科研服务~</p>
<h4 id="添加频道">添加频道<a hidden class="anchor" aria-hidden="true" href="#添加频道">#</a></h4>
<p>这个道理跟家里的电视机是一样一样的，安装conda就相当于买了一台电视机，但是有电视了不意味着你就能看节目了，你要手动添加频道才能看你想看的电视节目。</p>
<p>添加清华的镜像channels：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/
$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/
$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/
$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/
</code></pre></div><p>为了分担清华源镜像的压力，北京外国语大学也开启了镜像站点，同样是由清华TUNA团队维护的，如果有小伙伴遇到清华源速度很慢的情况的话，可以考虑换成北外的镜像。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ conda config --add channels https://mirrors.bfsu.edu.cn/anaconda/cloud/bioconda/
$ conda config --add channels https://mirrors.bfsu.edu.cn/anaconda/cloud/conda-forge/
$ conda config --add channels https://mirrors.bfsu.edu.cn/anaconda/pkgs/free/
$ conda config --add channels https://mirrors.bfsu.edu.cn/anaconda/pkgs/main/
</code></pre></div><p>显示安装的频道</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ conda config --set show_channel_urls yes 
</code></pre></div><p>查看已经添加的channels</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ conda config --get channels
</code></pre></div><p>已添加的channel在哪里查看</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ vim ~/.condarc
</code></pre></div><h4 id="软件包管理">软件包管理<a hidden class="anchor" aria-hidden="true" href="#软件包管理">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ conda install gatk
</code></pre></div><h5 id="搜索安装包">搜索安装包<a hidden class="anchor" aria-hidden="true" href="#搜索安装包">#</a></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ conda search gatk
</code></pre></div><p>安装完成后，可以用“which 软件名”来查看该软件安装的位置：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ which gatk
</code></pre></div><h5 id="安装特定版本">安装特定版本<a hidden class="anchor" aria-hidden="true" href="#安装特定版本">#</a></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ conda install 软件名<span style="color:#f92672">=</span>版本号
$ conda install gatk<span style="color:#f92672">=</span>3.7
</code></pre></div><p>这时conda会先卸载已安装版本，然后重新安装指定版本。</p>
<h5 id="查看已安装软件">查看已安装软件<a hidden class="anchor" aria-hidden="true" href="#查看已安装软件">#</a></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ conda list
</code></pre></div><h5 id="更新指定软件">更新指定软件<a hidden class="anchor" aria-hidden="true" href="#更新指定软件">#</a></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ conda update gatk
</code></pre></div><h5 id="卸载指定软件">卸载指定软件<a hidden class="anchor" aria-hidden="true" href="#卸载指定软件">#</a></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ conda remove gatk
</code></pre></div><h4 id="环境管理">环境管理<a hidden class="anchor" aria-hidden="true" href="#环境管理">#</a></h4>
<h5 id="退出conda环境">退出conda环境<a hidden class="anchor" aria-hidden="true" href="#退出conda环境">#</a></h5>
<p>退出也很简单，之前我们是<code>. ./activate 或者 (. ~/miniconda3/bin/activate)</code>现在退出只要:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ . ./deactivate
<span style="color:#75715e"># 或者用 </span>
$ conda deactivate
</code></pre></div><p>就退出当前的环境了</p>
<h5 id="创建conda环境">创建conda环境<a hidden class="anchor" aria-hidden="true" href="#创建conda环境">#</a></h5>
<p>之前创建的时候显示的是（base）这是conda的基本环境，有些软件依赖的是python2的版本，当你还是使用你的base的时候你的base里的python会被自动降级，有可能会引发别的软件的报错，所以，可以给一些特别的软件一些特别的关照，比如创建一个单独的环境。</p>
<p>在conda环境下，输入<code>conda env list</code>（或者输入<code>conda info --envs</code>也是一样滴）查看当前存在的环境：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ conda env list
</code></pre></div><p>创建一个新的环境</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ conda create -n python2 python<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>
</code></pre></div><ul>
<li>-n: 设置新的环境的名字</li>
<li>python=2 指定新环境的python的版本，非必须参数</li>
<li>这里也可以用一个-y参数，可以直接跳过安装的确认过程。</li>
</ul>
<p>conda会创建一个新的python2的环境，并且会很温馨的提示你只要输入conda activate python2就可以启动这个环境了。</p>
<h5 id="删除环境">删除环境<a hidden class="anchor" aria-hidden="true" href="#删除环境">#</a></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ conda remove -n myenv --all
</code></pre></div><h5 id="重命名环境">重命名环境<a hidden class="anchor" aria-hidden="true" href="#重命名环境">#</a></h5>
<p>实际上conda并没有提供这样的功能，但是可以曲线救国，原理是先克隆一个原来的环境，命名成想要的名字，再把原来的环境删掉即可</p>
<p>接下来演示把一个原来叫做py2的环境重新命名成python2：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ conda create -n python2 --clone py2
$ conda remove -n py2 --all
</code></pre></div><h3 id="自动更新httpswwwcnblogscomsparkdevp11376560html"><a href="https://www.cnblogs.com/sparkdev/p/11376560.html">自动更新</a><a hidden class="anchor" aria-hidden="true" href="#自动更新httpswwwcnblogscomsparkdevp11376560html">#</a></h3>
<p>Ubuntu 默认的配置会每天自动安装安全更新而忽略其它包的更新。</p>
<h4 id="更新机制">更新机制<a hidden class="anchor" aria-hidden="true" href="#更新机制">#</a></h4>
<p>Ubuntu 默认定义了 4 个 systemd unit 执行更新任务，它们分别是：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">/lib/systemd/system/apt-daily-upgrade.service
/lib/systemd/system/apt-daily-upgrade.timer
/lib/systemd/system/apt-daily.service
/lib/systemd/system/apt-daily.timer
</code></pre></div><p>中的 apt-daily.timer 和 apt-daily-upgrade.timer 是两个触发器，分别在每天指定的时间触发 apt-daily.service 和 apt-daily-upgrade.service。这两个 service 的类型都是 oneshot，意思是当任务完成后 service 进程退出。这两个 service 其实调用的是同一个脚本： <code>/usr/lib/apt/apt.systemd.daily</code>。apt-daily.service 为脚本传入参数 &ldquo;update&rdquo;，其功能为检查系统的更新并下载对应的更新包。apt-daily-upgrade.service 为脚本传入参数 &ldquo;install&rdquo;，其功能为安装更新并删除缓存在本地的更新包。</p>
<p>apt-daily.timer 默认每天触发两次，分别为 6 点和 18 点，主要是为了缓解服务器端的下载压力。我们可以根据自身业务的特点设置合适的触发时间。</p>
<p>apt-daily-upgrade.service 默认每天在 6 点触发一次，我们也可以设置为其它时间，比如午夜。</p>
<h4 id="aptsystemddaily">apt.systemd.daily<a hidden class="anchor" aria-hidden="true" href="#aptsystemddaily">#</a></h4>
<p><code>/usr/lib/apt/apt.systemd.daily</code> 脚本负责完成与更新相关的一系列工作，这些工作主要分为两大块：</p>
<ul>
<li>检查更新并下载更新包</li>
<li>安装更新并清理更新包</li>
</ul>
<p>apt.systemd.daily 脚本中调用 apt-config 命令从 <code>/etc/apt/apt.conf.d/10periodic</code> 文件和 <code>/etc/apt/apt.conf.d/20auto-upgrades</code> 读中取配变量，并根据这些变量的值来控制系统的更新策略。下面我们介绍几个比较重要的配置项。</p>
<p>隔多少天执行一次 apt-get update，默认是 1 天，0 表示不执行该操作：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">APT::Periodic::Update-Package-Lists <span style="color:#e6db74">&#34;1&#34;</span>;
</code></pre></div><p>隔多少天执行一次 apt-get upgrade &ndash;download-only 下载更新包，0 表示不执行该操作：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">APT::Periodic::Download-Upgradeable-Packages <span style="color:#e6db74">&#34;0&#34;</span>;
</code></pre></div><p>下载的更新版被缓存在目录 <code>/var/cache/apt/archives/</code> 中，执行升级操作时直接从缓存目录中读取包文件而不是从网络上下载。</p>
<p>隔多少天执行一次 apt-get autoclean 清除无用的更新包，0 表示不执行该操作：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">APT::Periodic::AutocleanInterval <span style="color:#e6db74">&#34;0&#34;</span>;
</code></pre></div><p>隔多少天执行一次 Unattended-Upgrade 执行系统安全更新(或者所有包的更新)，0 表示不执行该操作：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">APT::Periodic::Unattended-Upgrade <span style="color:#e6db74">&#34;1&#34;</span>;
</code></pre></div><p>通过这些配置，我们可以控制自动更新的频率和行为。注意，<em>到目前为止的配置还只能安装系统的安全更新</em>，如果要想安装所有包的更新还需要其它的配置。</p>
<p>在继续介绍后面的内容前，让我们先来了解一下 apt.systemd.daily 脚本中用到的 apt-config 命令和 apt.systemd.daily 脚本依赖的配置文件。</p>
<p><strong>apt-config 命令</strong></p>
<p>apt-config 是一个被 APT 套件使用的内部命令，使用它可以在脚本中提取 <code>/etc/apt/apt.conf</code> 目录下配置文件中的信息。</p>
<p>比如，如果要在脚本中获取 APT::Periodic::Update-Package-Lists 的设置，可以使用下面的代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">#!/bin/bash
</span><span style="color:#75715e"></span>ABC<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>
eval <span style="color:#66d9ef">$(</span>apt-config shell ABC APT::Periodic::Update-Package-Lists<span style="color:#66d9ef">)</span>
echo <span style="color:#e6db74">${</span>ABC<span style="color:#e6db74">}</span>
</code></pre></div><p>此时脚本变量 ABC 中保存的就是 APT::Periodic::Update-Package-Lists 的值。</p>
<p><strong>10periodic 和 20auto-upgrades</strong></p>
<p><code>/etc/apt/apt.conf.d/10periodic</code> 是 update-notifier-common 的配置文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ dpkg-query -S /etc/apt/apt.conf.d/10periodic
update-notifier-common: /etc/apt/apt.conf.d/10periodic
</code></pre></div><p>在 ubuntu 16.04 和 18.04 中，这两个文件的默认内容是一样的。apt.systemd.daily 脚本在注释中说我们可以通过 <code>/etc/apt/apt.conf.d/10periodic</code> 文件自定义相关的变量值，它通过 get-config 命令来获得这些变量的值。但是测试的结果是 <code>/etc/apt/apt.conf.d/20auto-upgrades</code> 文件中的变量会覆盖 <code>/etc/apt/apt.conf.d/10periodic</code> 文件中的变量。看来是 get-config 命令根据文件名称的顺序，排在后面的文件中的变量会覆盖前面文件中的变量。</p>
<p>在 desktop 版本中，通过 GUI 程序修改相关的变量，这两个文件都会被修改并保持一致，所以在 server 版中我们最好也同时修改这两个文件并保持其内容一致。</p>
<h4 id="unattended-upgrades">unattended-upgrades<a hidden class="anchor" aria-hidden="true" href="#unattended-upgrades">#</a></h4>
<p>Ubuntu 实际上是通过 unattended-upgrades 命令来自动安装更新的。Ubuntu 16.04/18.04 默认安装了这个包，如果碰到没有安装的情况你还可以通过下面的命令自行安装：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt install unattended-upgrades
</code></pre></div><p>unattended-upgrades 的配置文件为 <code>/etc/apt/apt.conf.d/50unattended-upgrades</code>。</p>
<p>注意，unattended-upgrades 不仅能够安装系统的安全更新，还可以安装所有包的更新。但是默认的配置只安装安全更新，我们可以通过配置项让 unattended-upgrades 安装所有的包更新或者只安装安全更新。</p>
<p>unattended-upgrades 命令被设计为通过 cron 定时执行系统更新，但在 Ubuntu 16.04/18.04 中是通过 systemd 的 timer unit 定时触发 service unit 执行的。</p>
<p>unattended-upgrades 命令的日志文件存放在 <code>/var/log/unattended-upgrades</code> 目录下。</p>
<p>unattended-upgrade 命令常见的用法之一是检查系统是否有更新：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo unattended-upgrade --dry-run
</code></pre></div><p>另一种用法是安装更新：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo unattended-upgrade
</code></pre></div><p>在 apt.systemd.daily 脚本中执行 unattended-upgrade 命令时，由于更新包已经提前下载到缓存目录了(<code>/var/cache/apt/archives</code>)，所以直接它直接使用缓存中的更新包。</p>
<p><strong>配置文件 50unattended-upgrades</strong></p>
<p>50unattended-upgrades 文件中的默认配置只是安装安全更新：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">Unattended-Upgrade::Allowed-Origins <span style="color:#f92672">{</span>
        <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>distro_id<span style="color:#e6db74">}</span><span style="color:#e6db74">:</span><span style="color:#e6db74">${</span>distro_codename<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>;
        <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>distro_id<span style="color:#e6db74">}</span><span style="color:#e6db74">:</span><span style="color:#e6db74">${</span>distro_codename<span style="color:#e6db74">}</span><span style="color:#e6db74">-security&#34;</span>;
        <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>distro_id<span style="color:#e6db74">}</span><span style="color:#e6db74">ESM:</span><span style="color:#e6db74">${</span>distro_codename<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>;
//      <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>distro_id<span style="color:#e6db74">}</span><span style="color:#e6db74">:</span><span style="color:#e6db74">${</span>distro_codename<span style="color:#e6db74">}</span><span style="color:#e6db74">-updates&#34;</span>;
//      <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>distro_id<span style="color:#e6db74">}</span><span style="color:#e6db74">:</span><span style="color:#e6db74">${</span>distro_codename<span style="color:#e6db74">}</span><span style="color:#e6db74">-proposed&#34;</span>;
//      <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>distro_id<span style="color:#e6db74">}</span><span style="color:#e6db74">:</span><span style="color:#e6db74">${</span>distro_codename<span style="color:#e6db74">}</span><span style="color:#e6db74">-backports&#34;</span>;
<span style="color:#f92672">}</span>;
</code></pre></div><p>如果要自动安装所有包的更新，只要取消下面行的注释就行了：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>distro_id<span style="color:#e6db74">}</span><span style="color:#e6db74">:</span><span style="color:#e6db74">${</span>distro_codename<span style="color:#e6db74">}</span><span style="color:#e6db74">-updates&#34;</span>;
</code></pre></div><p>我们还可以通过黑名单的方式指定不更新哪些包：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">Unattended-Upgrade::Package-Blacklist <span style="color:#f92672">{</span>
      <span style="color:#e6db74">&#34;vim&#34;</span>;
      <span style="color:#e6db74">&#34;libc6&#34;</span>;
      <span style="color:#e6db74">&#34;libc6-dev&#34;</span>;
      <span style="color:#e6db74">&#34;libc6-i686&#34;</span>;
<span style="color:#f92672">}</span>;
</code></pre></div><p>下面的配置项指定在更新后移除无用的包：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">Unattended-Upgrade::Remove-Unused-Kernel-Packages <span style="color:#e6db74">&#34;true&#34;</span>;
Unattended-Upgrade::Remove-Unused-Dependencies <span style="color:#e6db74">&#34;true&#34;</span>;
</code></pre></div><p>有些更新需要重启系统，而默认的配置是不重启系统的。下面的配置允许重启系统(更新完成后，如果需要重启，立即重启系统)：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">Unattended-Upgrade::Automatic-Reboot <span style="color:#e6db74">&#34;true&#34;</span>;
</code></pre></div><p>但是多数情况下我们更期望指定一个时间让系统重启(如果需要重启，在下面配置中指定的时间重启系统)：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">Unattended-Upgrade::Automatic-Reboot-Time <span style="color:#e6db74">&#34;02:38&#34;</span>;
</code></pre></div><p>在系统更新的过程中发生了错误怎么办？当然是通知管理员啦！下面的配置在发生错误时给管理员发送邮件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">Unattended-Upgrade::Mail <span style="color:#e6db74">&#34;user@example.com&#34;</span>;
Unattended-Upgrade::MailOnlyOnError <span style="color:#e6db74">&#34;true&#34;</span>;
</code></pre></div><p>注意：如果要向外网发送邮件，需要安装 mailx 等工具。</p>
<h4 id="关闭自动更新">关闭自动更新<a hidden class="anchor" aria-hidden="true" href="#关闭自动更新">#</a></h4>
<p>如果你的主机运行在封闭的环境中，并且无法连接到有效的更新源，此时可以选择关闭自动更新功能。首选的方法是停止相关的服务：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo systemctl stop apt-daily.service
$ sudo systemctl stop apt-daily.timer
$ sudo systemctl stop apt-daily-upgrade.service
$ sudo systemctl stop apt-daily-upgrade.timer
$ sudo systemctl disable apt-daily.service
$ sudo systemctl disable apt-daily.timer
$ sudo systemctl disable apt-daily-upgrade.service
$ sudo systemctl disable apt-daily-upgrade.timer
</code></pre></div><p>或者修改自动更新程序的配置文件也可以，同时更新 <code>/etc/apt/apt.conf.d/10periodic</code> 和 <code>/etc/apt/apt.conf.d/20auto-upgrades</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">APT::Periodic::Update-Package-Lists <span style="color:#e6db74">&#34;1&#34;</span>;
APT::Periodic::Unattended-Upgrade <span style="color:#e6db74">&#34;1&#34;</span>;
</code></pre></div><p>改为</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">APT::Periodic::Update-Package-Lists <span style="color:#e6db74">&#34;0&#34;</span>;
APT::Periodic::Unattended-Upgrade <span style="color:#e6db74">&#34;0&#34;</span>;
</code></pre></div><h2 id="文件系统">文件系统<a hidden class="anchor" aria-hidden="true" href="#文件系统">#</a></h2>
<h3 id="fstabhttpswwwcnblogscomfenggeblogp10178824html"><a href="https://www.cnblogs.com/FengGeBlog/p/10178824.html">fstab</a><a hidden class="anchor" aria-hidden="true" href="#fstabhttpswwwcnblogscomfenggeblogp10178824html">#</a></h3>
<p><code>/etc/fstab</code>是用来存放文件系统的静态信息的文件。当系统启动的时候，系统会自动地从这个文件读取信息，并且会自动将此文件中指定的文件系统挂载到指定的目录。</p>
<p>查看<code>/etc/fstab</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># cat /etc/fstab</span>
&lt;file system&gt;        &lt;dir&gt;         &lt;type&gt;    &lt;options&gt;             &lt;dump&gt; &lt;pass&gt;
tmpfs                  /tmp          tmpfs     nodev,nosuid          <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>
/dev/sda1              /             ext4      defaults,noatime      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">1</span>
/dev/sda2              none          swap      defaults,nodelalloc              <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>
/dev/sda3              /home         ext4      defaults,noatime      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">2</span>
</code></pre></div><p>分别解释一下各字段的用处：</p>
<ul>
<li><code>&lt;file system&gt;</code> 要挂载的分区或存储设备</li>
<li><code>&lt;dir&gt;</code>  挂载的目录位置</li>
<li><code>&lt;type&gt;</code> 挂载分区的文件系统类型，比如：ext3、ext4、xfs、swap</li>
<li><code>&lt;options&gt;</code> 挂载使用的参数有哪些。举例如下：
<ul>
<li>auto - 在启动时或键入了 mount -a 命令时自动挂载。</li>
<li>noauto - 只在你的命令下被挂载。</li>
<li>exec - 允许执行此分区的二进制文件。</li>
<li>noexec - 不允许执行此文件系统上的二进制文件。</li>
<li>ro - 以只读模式挂载文件系统。</li>
<li>rw - 以读写模式挂载文件系统。</li>
<li>user - 允许任意用户挂载此文件系统，若无显示定义，隐含启用 noexec, nosuid, nodev 参数。</li>
<li>users - 允许所有 users 组中的用户挂载文件系统.</li>
<li>nouser - 只能被 root 挂载。</li>
<li>owner - 允许设备所有者挂载。</li>
<li>sync - I/O 同步进行。</li>
<li>async - I/O 异步进行。</li>
<li>dev - 解析文件系统上的块特殊设备。</li>
<li>nodev - 不解析文件系统上的块特殊设备。</li>
<li>suid - 允许 suid 操作和设定 sgid 位。这一参数通常用于一些特殊任务，使一般用户运行程序时临时提升权限。</li>
<li>nosuid - 禁止 suid 操作和设定 sgid 位。</li>
<li>noatime - 不更新文件系统上 inode 访问记录，可以提升性能。</li>
<li>nodiratime - 不更新文件系统上的目录 inode 访问记录，可以提升性能(参见 atime 参数)。</li>
<li>relatime - 实时更新 inode access 记录。只有在记录中的访问时间早于当前访问才会被更新。（与</li>
<li>noatime 相似，但不会打断如 mutt 或其它程序探测文件在上次访问后是否被修改的进程。），可以提升性能。</li>
<li>flush - vfat 的选项，更频繁的刷新数据，复制对话框或进度条在全部数据都写入后才消失。</li>
<li>defaults - 使用文件系统的默认挂载参数，例如 ext4 的默认参数为:rw, suid, dev, exec, auto, nouser, async.</li>
</ul>
</li>
<li><code>&lt;dump&gt;</code> dump 工具通过它决定何时作备份。dump 会检查其内容，并用数字来决定是否对这个文件系统进行备份。 允许的数字是 0 和 1 。0 表示忽略， 1 则进行备份。大部分的用户是没有安装 dump 的 ，对他们而言 <code>&lt;dump&gt;</code> 应设为 0。</li>
<li><code>&lt;pass&gt;</code> fsck 读取 <code>&lt;pass&gt;</code> 的数值来决定需要检查的文件系统的检查顺序。允许的数字是0, 1, 和2。 根目录应当获得最高的优先权 1, 其它所有需要被检查的设备设置为 2。 0 表示设备不会被 fsck 所检查。</li>
</ul>
<p>示例：</p>
<pre tabindex="0"><code>/dev/sda1 /mnt/LinuxOSBuckup ext4 defaults 0 2
</code></pre><h4 id="uuid-of-storage-deviceshttpslinuxhintcomuuid_storage_devices_linux"><a href="https://linuxhint.com/uuid_storage_devices_linux/">UUID of Storage Devices</a><a hidden class="anchor" aria-hidden="true" href="#uuid-of-storage-deviceshttpslinuxhintcomuuid_storage_devices_linux">#</a></h4>
<p><strong>Finding UUID with blkid</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo blkid
</code></pre></div><p><strong>Finding UUID with ls</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ls -l /dev/disk/by-uuid
</code></pre></div><p><strong>Finding UUID with lsblk</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo lsblk -f
</code></pre></div><h3 id="lvmhttpswwwcnblogscomsparkdevp10130934html"><a href="https://www.cnblogs.com/sparkdev/p/10130934.html">LVM</a><a hidden class="anchor" aria-hidden="true" href="#lvmhttpswwwcnblogscomsparkdevp10130934html">#</a></h3>
<p>在对磁盘分区的大小进行规划时，往往不能确定这个分区要使用的空间的大小。而使用 fdisk、gdisk 等工具对磁盘分区后，每个分区的大小就固定了。如果分区设置的过大，就白白浪费了磁盘空间；如果分区设置的过小，就会导致空间不够用的情况出现。对于分区过小的问题，可以从新划分磁盘的分区，或者通过软连接的方式将此分区的目录链接到另外一个分区。这样虽然能够临时解决问题，但是给管理带来了麻烦。类似的问题可以通过 LVM 来解决。</p>
<h4 id="lvm-是什么">LVM 是什么<a hidden class="anchor" aria-hidden="true" href="#lvm-是什么">#</a></h4>
<p>LVM 是 Logical Volume Manager 的缩写，中文一般翻译为 &ldquo;逻辑卷管理&rdquo;，它是 Linux 下对磁盘分区进行管理的一种机制。LVM 是建立在磁盘分区和文件系统之间的一个逻辑层，系统管理员可以利用 LVM <strong>在不重新对磁盘分区的情况下动态的调整分区的大小</strong>。如果系统新增了一块硬盘，通过 LVM 就可以将新增的硬盘空间直接扩展到原来的磁盘分区上。</p>
<p>LVM 的优点如下：</p>
<ul>
<li>文件系统可以跨多个磁盘，因此大小不再受物理磁盘的限制。</li>
<li>可以在系统运行状态下动态地扩展文件系统大小。</li>
<li>可以以镜像的方式冗余重要数据到多个物理磁盘上。</li>
<li>可以很方便地导出整个卷组，并导入到另外一台机器上。</li>
</ul>
<p>LVM 也有一些缺点：</p>
<ul>
<li>在从卷组中移除一个磁盘的时候必须使用 reducevg 命令(这个命令要求root权限，并且不允许在快照卷组中使用)。</li>
<li>当卷组中的一个磁盘损坏时，整个卷组都会受影响。</li>
<li>因为增加了一个逻辑层，存储的性能会受影响。</li>
</ul>
<p>LVM 的优点对服务器的管理非常有用，但对于桌面系统的帮助则没有那么显著，所以需要我们根据使用的场景来决定是否应用 LVM。</p>
<h4 id="lvm-中的基本概念">LVM 中的基本概念<a hidden class="anchor" aria-hidden="true" href="#lvm-中的基本概念">#</a></h4>
<p>通过 LVM 技术，可以屏蔽掉磁盘分区的底层差异，在逻辑上给文件系统提供了一个卷的概念，然后在这些卷上建立相应的文件系统。下面是 LVM 中主要涉及的一些概念。</p>
<ul>
<li>**物理存储设备(Physical Media)：**指系统的存储设备文件，比如 /dev/sda、/dev/sdb 等。</li>
<li>**PV(物理卷 Physical Volume)：**指硬盘分区或者从逻辑上看起来和硬盘分区类似的设备(比如 RAID 设备)。</li>
<li>**VG(卷组 Volume Group)：**类似于非 LVM 系统中的物理硬盘，一个 LVM 卷组由一个或者多个 PV(物理卷)组成。</li>
<li>**LV(逻辑卷 Logical Volume)：**类似于非 LVM 系统上的磁盘分区，LV 建立在 VG 上，可以在 LV 上建立文件系统。</li>
<li>**PE(Physical Extent)：**PV(物理卷)中可以分配的最小存储单元称为 PE，PE 的大小是可以指定的。</li>
<li>**LE(Logical Extent)：**LV(逻辑卷)中可以分配的最小存储单元称为 LE，在同一个卷组中，LE 的大小和 PE 的大小是一样的，并且一一对应。</li>
</ul>
<p>可以这么理解，LVM 是把硬盘的分区分成了更小的单位(PE)，再用这些单元拼成更大的看上去像分区的东西(PV)，进而用 PV 拼成看上去像硬盘的东西(VG)，最后在这个新的硬盘上创建分区(LV)。文件系统则建立在 LV 之上，这样就在物理硬盘和文件系统中间添加了一层抽象(LVM)。下图大致描述了这些概念之间的关系：</p>
<p><img loading="lazy" src="/Distributions/LVM.png" alt=""  />
</p>
<p>对上图中的结构做个简单的介绍：</p>
<p>两块物理硬盘 A 和 B 组成了 LVM 的底层结构，这两块硬盘的大小、型号可以不同。PV 可以看做是硬盘上的分区，因此可以说物理硬盘 A 划分了两个分区，物理硬盘 B 划分了三个分区。然后将前三个 PV 组成一个卷组 VG1，后两个 PV 组成一个卷组 VG2。接着在卷组 VG1 上划分了两个逻辑卷 LV1 和 LV2，在卷组 VG2 上划分了一个逻辑卷 LV3。最后，在逻辑卷 LV1、LV2 和 LV3 上创建文件系统，分别挂载在 /usr、/home 和 /var 目录。</p>
<h4 id="lvm-工具">LVM 工具<a hidden class="anchor" aria-hidden="true" href="#lvm-工具">#</a></h4>
<p>在安装 Linux 时，如果选择使用 LVM 创建分区，就会安装 LVM 相关的工具。当前这个软件包的名称为 lvm2，其中包含了大量 LVM 工具。比如单是查看 LVM 相关实体状态的命令就有如下一些：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo pvscan
$ sudo pvs
$ sudo pvdisplay

$ sudo vgscan
$ sudo vgs
$ sudo vgdisplay

$ sudo lvscan
$ sudo lvs
$ sudo lvdisplay
</code></pre></div><p>如果安装系统时没有默认安装 LVM 工具包，可以通过下面的命令安装它们：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt update
$ sudo apt install lvm2
</code></pre></div><p>接下来我们通过例子来演示如何使用 LVM 来一步步的创建出逻辑卷(LV)，然后在 LV 上创建文件系统并挂载到 Linux 系统中。</p>
<h4 id="使用-gdisk-对物理磁盘进行分区">使用 gdisk 对物理磁盘进行分区<a hidden class="anchor" aria-hidden="true" href="#使用-gdisk-对物理磁盘进行分区">#</a></h4>
<p>目前常见的磁盘分区格式有两种，MBR 分区和 GPT 分区。</p>
<p>MBR 分区，MBR 的意思是 &ldquo;主引导记录&rdquo;。MBR 最大支持 2TB 容量，在容量方面存在着极大的瓶颈。</p>
<p>GPT 分区，GPT 意为 GUID 分区表，它支持的磁盘容量比 MBR 大得多。这是一个正逐渐取代 MBR 的新标准，它是由 UEFI 辅住而形成的，将来 UEFI 用于取代老旧的 BIOS，而 GPT 则取代老旧的 MBR。</p>
<p>使用 fdisk 工具创建 MBR 磁盘分区，而 gdisk 是 Linux 系统中 GPT 格式的磁盘分区管理工具。</p>
<p>假设我们的 Linux 系统中增加了一块新的磁盘，系统对应的设备名为 /dev/sdb，下面我们通过 gdisk 命令对这个磁盘进行分区。</p>
<p>在用 gdisk 命令对磁盘分区前，我们先用 parted 命令查看 /dev/sdb 当前的分区情况：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo parted /dev/sdb print
</code></pre></div><p>下面通过 gdisk 命令创建分区：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo gdisk /dev/sdb
</code></pre></div><p>通过 p 命令可以查看磁盘当前的状态：输出中的前几行是磁盘的基本信息，比如总大小，一共有多少个扇区(sector)，每个扇区的大小，当前剩余的空间等等。</p>
<p>然后是已经存在的分区信息：</p>
<ul>
<li><strong>第一列 Number</strong> 显示了分区的编号，比如 1 号指 /dev/sdb1。</li>
<li><strong>第二列 Start</strong> 表示磁盘分区的起始位置。</li>
<li><strong>第三列 End</strong> 表示磁盘分区的结束位置。</li>
<li><strong>第四列 Size</strong> 显示分区的容量。</li>
<li><strong>第五列 Code 和第六列 Name</strong> 显示分区类型的 ID和名称，比如 Linux filesystem 为 8300，Linux swap 为 8200，Linux LVM 为 8e00。</li>
</ul>
<p>通过 n 命令来创建新分区：</p>
<p>分区编号和开始/结束的扇区都直接通过回车选择默认值，这样所有的磁盘空间都划分到了一个分区中，然后输入 8e00 说明我们要创建的分区类型为 Linux LVM。最后输入 w 命令并确认执行分区操作。分区成功后可通过 p 命令查看我们创建的分区的信息。</p>
<h4 id="创建物理卷-pv">创建物理卷 PV<a hidden class="anchor" aria-hidden="true" href="#创建物理卷-pv">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># pvcreate DEVICE</span>
</code></pre></div><p>现在我们可以基于磁盘分区 /dev/sdb1 来创建 LVM 物理卷(LV)，可以通过 pvcreate 命令来完成：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo pvcreate /dev/sdb1
</code></pre></div><p>此时 /dev/sdb1 已经完成了从磁盘分区到 PV 的华丽转身！注意上面的命令，<strong>磁盘分区被直接转换成了 PV</strong>，连名称都没有变化！我们可以通过 pvs 命令查看 /dev/sdb1，目前它还没有被加入到 VG 中。</p>
<h4 id="创建卷组-vg">创建卷组 VG<a hidden class="anchor" aria-hidden="true" href="#创建卷组-vg">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># vgcreate &lt;volume_group&gt; &lt;physical_volume1&gt; &lt;physical_volume2&gt; ...</span>
</code></pre></div><p>基于一个或多个 PV，可以创建 VG。我们使用刚才创建的 PV /dev/sdb1 来创建一个名称为 nickvg 的 VG：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo vgcreate -s 32G nickvg /dev/sdb1
</code></pre></div><p><strong>注意 vgcreate 命令中的 -s 选项，它指定了 PE(Physical Extent) 的大小</strong>。可以通 vgs 命令观察 VG 的信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo vgs nickvg
</code></pre></div><p>如果目标 VG 已经存在，则使用 vgextend 把 PV 加入到 VG 中即可。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># vgextend &lt;卷组名&gt; &lt;物理卷&gt;</span>
</code></pre></div><h4 id="创建逻辑卷-lv">创建逻辑卷 LV<a hidden class="anchor" aria-hidden="true" href="#创建逻辑卷-lv">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># lvcreate -L &lt;卷大小&gt; &lt;卷组名&gt; -n &lt;卷名&gt;</span>
</code></pre></div><p>有了 VG 就可以创建逻辑卷 LV 了，lvcreate 命令用来创建 LV，让我们在前面创建的 nickvg 上创建名称为 nicklv00 的 LV：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo lvcreate -L 15G -n nicklv00 nickvg
</code></pre></div><p><strong>选项 -L 指定新建 LV 的容量</strong>，这里是 15G；选项 -n 则指定新建 LV 的名称，这里为 nicklv00。可以通过 lvs 命令观察 LV 的信息，注意需要同时指出 LV 所在的 VG：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo lvs nickvg/nicklv00
</code></pre></div><p>如果你想让要创建的逻辑卷拥有卷组（VG）的所有未使用空间，请使用以下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># lvcreate -l +100%FREE  &lt;volume_group&gt; -n &lt;logical_volume&gt;</span>
</code></pre></div><h4 id="格式化逻辑卷创建文件系统">格式化逻辑卷(创建文件系统)<a hidden class="anchor" aria-hidden="true" href="#格式化逻辑卷创建文件系统">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># mkfs.&lt;类型&gt; /dev/mapper/&lt;卷组名&gt;-&lt;卷名&gt;</span>
<span style="color:#75715e"># mount /dev/mapper/&lt;卷组名&gt;-&lt;卷名&gt; &lt;挂载点&gt;</span>
</code></pre></div><p>当我们创建 LV nickvg/nicklv00 时，其实是创建了名称为 /dev/nickvg/nicklv00 的设备文件。</p>
<p>现在你的逻辑卷应该已经在<code>/dev/mapper/</code>和<code>/dev/YourVolumeGroupName</code>中了。</p>
<p>现在我们来格式化这个逻辑卷(在该 LV 上创建文件系统)，目标为比较常见的 ext4 格式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo mkfs.ext4 /dev/nickvg/nicklv00
</code></pre></div><p>然后创建个目录，比如 /home/doc，并把新建的文件系统挂载到这个目录上：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo mkdir /home/doc
$ sudo mount /dev/nickvg/nicklv00 /home/doc
</code></pre></div><p>最后可以通过 df 命令查看这个文件系统的使用情况。</p>
<h4 id="开机自动挂载">开机自动挂载<a hidden class="anchor" aria-hidden="true" href="#开机自动挂载">#</a></h4>
<p>编辑 /etc/fstab 文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo vim /etc/fstab
</code></pre></div><p>把下面的行添加的文件末尾并保存文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">/dev/mapper/nickvg-nicklv00 /home/doc       ext4    defaults       <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">2</span>
</code></pre></div><h4 id="调整逻辑卷httpswikiarchlinuxorgtitlelvm_e7ae80e4bd93e4b8ade69687e980bbe8be91e58db7"><a href="https://wiki.archlinux.org/title/LVM_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E9%80%BB%E8%BE%91%E5%8D%B7">调整逻辑卷</a><a hidden class="anchor" aria-hidden="true" href="#调整逻辑卷httpswikiarchlinuxorgtitlelvm_e7ae80e4bd93e4b8ade69687e980bbe8be91e58db7">#</a></h4>
<p><strong>同时缩小逻辑卷和其文件系统</strong></p>
<blockquote>
<p>注意： 只有ext2，ext3，ext4，ReiserFS和 XFS 文件系统支持以下操作。</p>
</blockquote>
<p>将<code>MyVolGroup</code>组中的逻辑卷<code>mediavol</code>扩大10GiB，并同时扩大其文件系统：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># lvresize -L +10G --resizefs MyVolGroup/mediavol</span>
</code></pre></div><p>将<code>MyVolGroup</code>组中的逻辑卷<code>mediavol</code>大小调整为15GiB，并同时调整其文件系统：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># lvresize -L 15G --resizefs MyVolGroup/mediavol</span>
</code></pre></div><p>将卷组中的所有剩余空间分配给<code>mediavol</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># lvresize -l +100%FREE --resizefs MyVolGroup/mediavol</span>
</code></pre></div><h4 id="重命名卷">重命名卷<a hidden class="anchor" aria-hidden="true" href="#重命名卷">#</a></h4>
<p><strong>重命名卷组</strong></p>
<p>要重命名一个卷组，请使用vgrename(8)命令。</p>
<p>可使用下面的任意一条命令将卷组<code>vg02</code>重命名为<code>my_volume_group</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># vgrename /dev/vg02 /dev/my_volume_group</span>
<span style="color:#75715e"># vgrename vg02 my_volume_group</span>
</code></pre></div><p><strong>重命名逻辑卷</strong></p>
<p>要重命名一个逻辑卷，请使用lvrename(8)命令。</p>
<p>可使用下面的任意一条命令将<code>vg02</code>组中的逻辑卷<code>lvold</code>重命名为<code>lvnew</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># lvrename /dev/vg02/lvold /dev/vg02/lvnew</span>
<span style="color:#75715e"># lvrename vg02 lvold lvnew</span>
</code></pre></div><h4 id="移除逻辑卷">移除逻辑卷<a hidden class="anchor" aria-hidden="true" href="#移除逻辑卷">#</a></h4>
<p><strong>警告：</strong> 在移除逻辑卷之前，请先备份好数据以免丢失！</p>
<p>首先，找到你所要移除的逻辑卷的名称。你可以使用以下命令来查看系统的所有逻辑卷：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># lvs</span>
</code></pre></div><p>接下来，找到你所要移除的逻辑卷的挂载点</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ lsblk
</code></pre></div><p>并卸载它：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># umount /&lt;mountpoint&gt;</span>
</code></pre></div><p>最后，使用以下命令来移除逻辑卷：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># lvremove &lt;volume_group&gt;/&lt;logical_volume&gt;</span>
</code></pre></div><p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># lvremove VolGroup00/lvolhome</span>
</code></pre></div><p>请输入<code>y</code>来确定你要执行移除逻辑卷操作。</p>
<p>此外，请不要忘了更新<code>/etc/fstab</code>。</p>
<p>你可以再次使用<code>lvs</code>命令来确认你的逻辑卷已被移除。</p>
<h4 id="lvm-快照httpswwwcnblogscomsparkdevp10232567html"><a href="https://www.cnblogs.com/sparkdev/p/10232567.html">LVM 快照</a><a hidden class="anchor" aria-hidden="true" href="#lvm-快照httpswwwcnblogscomsparkdevp10232567html">#</a></h4>
<p>LVM 机制还提供了对 LV 做快照的功能，也就是说可以<strong>给文件系统做一个备份</strong>，这也是设计 LVM 快照的主要目的。LVM 的快照功能采用写时复制技术(Copy-On-Write，COW)，这比传统的备份技术的效率要高很多。创建快照时不用停止服务，就可以对数据进行备份。说明：LVM 还支持 thin 类型的快照，但是本文中的快照都是指 COW 类型的快照。</p>
<p>LVM 采用的写时复制，是指当 LVM 快照创建的时候，仅创建到实际数据的 inode 的硬链接(hark-link)而已。只要实际的数据没有改变，快照就只包含指向数据的 inode 的指针，而非数据本身。快照会跟踪原始卷中块的改变，一旦你更改了快照对应的文件或目录，这个时候原始卷上将要改变的数据会在改变之前拷贝到快照预留的空间。</p>
<p><strong>LVM 快照的原理</strong></p>
<p>创建快照实际上也是创建了一个逻辑卷，只不过该卷的属性与普通逻辑卷的属性有些不一样。我们可以通过下图来理解快照数据卷(图中的实线框表示快照区域，虚线框表示文件系统)：</p>
<p><img loading="lazy" src="/Distributions/LVMSnapshot.png" alt=""  />
</p>
<p>左图为最初创建的快照数据卷状况，LVM 会预留一个区域 (比如左图的左侧三个 PE 区块) 作为数据存放处。 此时快照数据卷内并没有任何数据，而快照数据卷与源数据卷共享所有的 PE 数据， 因此你会看到快照数据卷的内容与源数据卷中的内容是一模一样的。 等到系统运行一阵子后，假设 A 区域的数据被更新了(上面右图所示)，则更新前系统会将该区域的数据移动到快照数据卷中， 所以在右图的快照数据卷中被占用了一块 PE 成为 A，而其他 B 到 I 的区块则还是与源数据卷共享！</p>
<p>由於快照区与原本的 LV 共享很多 PE 区块，因此快照区与被快照的 LV 必须要在同一个 VG 上头，下面两点非常重要：</p>
<ul>
<li>VG中需要预留存放快照本身的空间，不能全部被占满。</li>
<li>快照所在的 VG 必须与被备份的 LV 的 VG 相同，否则创建快照会失败。</li>
</ul>
<p><strong>创建 LVM 快照</strong></p>
<p>其实快照就是一个特殊类型的数据卷，所以创建快照的命令和创建数据卷的命令相同，也是 lvcreate：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># lvcreate --size 100M --snapshot --name snap01 /dev/vg0/lv</span>
</code></pre></div><p>此时如果把 LV snap01 挂载到系统中，里面的内容和 LV /dev/vg0/lv 中的内容是一样的。</p>
<p>创建的快照的大小可以比源数据卷小，但是当源数据卷中的数据更新过多时会导致快照容量不足而引起的错误并丢失数据。如上你可以修改少于100M的数据，直到该快照逻辑卷空间不足为止。</p>
<p>创建快照后，如果源数据卷中的文件被更新了，快照系统中则保存着其创建快照时的版本。</p>
<p><strong>还原部分数据</strong></p>
<p>如果我们明确的知道需要还原某个文件，可以挂载快照数据卷，直接拷贝其中旧版本的文件即可。</p>
<p><strong>合并快照(merge snapshot)</strong></p>
<p>要将逻辑卷卷&rsquo;lv' 恢复到创建快照&rsquo;snap01&rsquo;时的状态，即还原整个数据卷上的数据，请使用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># lvconvert --merge /dev/vg0/snap01</span>
</code></pre></div><p>如果逻辑卷处于活动状态，则在下次重新启动时将进行合并（merging）(合并（merging）甚至可在LiveCD中进行)。</p>
<p><strong>注意：</strong> 合并后快照将被删除。</p>
<p>可以拍摄多个快照，每个快照都可以任意与对应的逻辑卷合并。</p>
<p>快照可以被挂载，并可用<strong>dd</strong>或者<strong>tar</strong>备份。使用<strong>dd</strong>备份的快照的大小为拍摄快照后对应逻辑卷中变更过文件的大小。 要使用备份，只需创建并挂载一个快照，并将备份写入或解压到其中。再将快照合并到对应逻辑卷即可。</p>
<p>快照主要用于提供一个文件系统的拷贝，以用来备份; 比起直接备份分区，使用快照备份可以提供一个更符合原文件系统的镜像。</p>
<h3 id="zfshttpslinuxcnarticle-10034-1html"><a href="https://linux.cn/article-10034-1.html">ZFS</a><a hidden class="anchor" aria-hidden="true" href="#zfshttpslinuxcnarticle-10034-1html">#</a></h3>
<h4 id="历史">历史<a hidden class="anchor" aria-hidden="true" href="#历史">#</a></h4>
<p>ZFS 是由 Matthew Ahrens 和 Jeff Bonwick 在 2001 年开发的。ZFS 是作为 <a href="http://en.wikipedia.org/wiki/Sun_Microsystems">Sun MicroSystem</a> 公司的 <a href="http://en.wikipedia.org/wiki/Opensolaris">OpenSolaris</a> 的下一代文件系统而设计的。在 2008 年，ZFS 被移植到了 FreeBSD 。同一年，一个移植 <a href="https://zfsonlinux.org/">ZFS on Linux</a> 的项目也启动了。然而，由于 ZFS 是<a href="https://en.wikipedia.org/wiki/Common_Development_and_Distribution_License">CDDL</a> 许可的，它和 <a href="https://en.wikipedia.org/wiki/GNU_General_Public_License">GPL</a> 不兼容，因此不能将它迁移到 Linux 内核中。为了解决这个问题，绝大多数 Linux 发行版提供了一些方法来安装 ZFS　。</p>
<p>在甲骨文公司收购太阳微系统公司之后不久，OpenSolaris 就闭源了，这使得 ZFS 的之后的开发也变成闭源的了。许多 ZFS 开发者对这件事情非常不满。三分之二的 ZFS 核心开发者，包括 Ahrens 和 Bonwick，因为这个决定而离开了甲骨文公司。他们加入了其它公司，并于 2013 年 9 月创立了 <a href="http://www.open-zfs.org/wiki/Main_Page">OpenZFS</a> 这一项目。该项目引领着 ZFS 的开源开发。</p>
<p>让我们回到上面提到的许可证问题上。既然 OpenZFS 项目已经和 Oracle 公司分离开了，有人可能好奇他们为什么不使用和 GPL 兼容的许可证，这样就可以把它加入到 Linux 内核中了。根据 <a href="http://www.open-zfs.org/wiki/FAQ#Do_you_plan_to_release_OpenZFS_under_a_license_other_than_the_CDDL.3F">OpenZFS 官网</a> 的介绍，更改许可证需要联系所有为当前 OpenZFS 实现贡献过代码的人（包括初始的公共 ZFS 代码以及 OpenSolaris 代码），并得到他们的许可才行。这几乎是不可能的（因为一些贡献者可能已经去世了或者很难找到），因此他们决定保留原来的许可证。</p>
<h4 id="特性httpslinuxcnarticle-7422-1html"><a href="https://linux.cn/article-7422-1.html">特性</a><a hidden class="anchor" aria-hidden="true" href="#特性httpslinuxcnarticle-7422-1html">#</a></h4>
<p>正如前面所说过的，ZFS 是一个先进的文件系统。因此，它有一些有趣的特性。</p>
<h5 id="存储池-1">存储池<a hidden class="anchor" aria-hidden="true" href="#存储池-1">#</a></h5>
<p>与大多数文件系统不同，ZFS 结合了文件系统和卷管理器的特性。这意味着，它与其他文件系统不同，ZFS 可以创建跨越一系列硬盘或池的文件系统。不仅如此，你还可以通过添加硬盘来增大池的存储容量。ZFS 可以进行分区和格式化。</p>
<p><img loading="lazy" src="/Distributions/231710te5zjh04sahk0zep.png" alt="ZFS 存储池"  />
</p>
<h5 id="写时拷贝">写时拷贝<a hidden class="anchor" aria-hidden="true" href="#写时拷贝">#</a></h5>
<p>Copy-on-write 是另一个有趣并且很酷的特性。在大多数文件系统上，当数据被重写时，它将永久丢失。而在 ZFS 中，新数据会写到不同的块。写完成之后，更新文件系统元数据信息，使之指向新的数据块（LCTT 译注：更新之后，原数据块成为磁盘上的垃圾，需要有对应的垃圾回收机制）。这确保了如果在写新数据的时候系统崩溃（或者发生其它事，比如突然断电），那么原数据将会保存下来。这也意味着，在系统发生崩溃之后，不需要运行 <a href="https://en.wikipedia.org/wiki/Fsck">fsck</a> 来检查和修复文件系统。</p>
<h5 id="快照">快照<a hidden class="anchor" aria-hidden="true" href="#快照">#</a></h5>
<p>写时拷贝使得 ZFS 有了另一个特性：snapshots。ZFS 使用快照来跟踪文件系统中的更改。快照包含文件系统的原始版本（文件系统的一个只读版本），实时文件系统则包含了自从快照创建之后的任何更改。没有使用额外的空间。因为新数据将会写到实时文件系统新分配的块上。如果一个文件被删除了，那么它在快照中的索引也会被删除。所以，快照主要是用来跟踪文件的更改，而不是文件的增加和创建。</p>
<p>快照可以挂载成只读的，以用来恢复一个文件的过去版本。实时文件系统也可以回滚到之前的快照。回滚之后，自从快照创建之后的所有更改将会丢失。</p>
<h5 id="数据完整性验证和自动修复">数据完整性验证和自动修复<a hidden class="anchor" aria-hidden="true" href="#数据完整性验证和自动修复">#</a></h5>
<p>当向 ZFS 写入新数据时，会创建该数据的校验和。在读取数据的时候，使用校验和进行验证。如果前后校验和不匹配，那么就说明检测到了错误，然后，ZFS 会尝试自动修正错误。</p>
<h5 id="raid-z">RAID-Z<a hidden class="anchor" aria-hidden="true" href="#raid-z">#</a></h5>
<p>ZFS 不需要任何额外软件或硬件就可以处理 RAID（磁盘阵列）。毫不奇怪，因为 ZFS 有自己的 RAID 实现：RAID-Z 。RAID-Z 是 RAID-5 的一个变种，不过它克服了 RAID-5 的写漏洞：意外重启之后，数据和校验信息会变得不同步（LCTT 译注：RAID-5 的条带在正写入数据时，如果这时候电源中断，那么奇偶校验数据将跟该部分数据不同步，因此前边的写无效；RAID-Z 用了 “可变宽的 RAID 条带” 技术，因此所有的写都是全条带写入）。为了使用基本级别的 RAID-Z（RAID-Z1），你需要至少三块磁盘，其中两块用来存储数据，另外一块用来存储奇偶校验信息。而 RAID-Z2 需要至少两块磁盘存储数据以及两块磁盘存储校验信息。RAID-Z3 需要至少两块磁盘存储数据以及三块磁盘存储校验信息。另外，只能向 RAID-Z 池中加入偶数倍的磁盘，而不能是奇数倍的。</p>
<h5 id="巨大的存储潜力">巨大的存储潜力<a hidden class="anchor" aria-hidden="true" href="#巨大的存储潜力">#</a></h5>
<p>创建 ZFS 的时候，它是作为<a href="https://web.archive.org/web/20060428092023/http://www.sun.com/2004-0914/feature/">最后一个文件系统</a>而设计的 。那时候，大多数文件系统都是 64 位的，ZFS 的创建者决定直接跳到 128 位，等到将来再来证明这是对的。这意味着 ZFS 的容量大小是 32 位或 64 位文件系统的 1600 亿亿倍。事实上，Jeff Bonwick（其中一个创建者）说：“完全填满一个 128 位的存储池所需要的<a href="https://blogs.oracle.com/bonwick/128-bit-storage:-are-you-high">能量</a>，从字面上讲，比煮沸海洋需要的还多。”</p>
<h4 id="如何安装-zfs">如何安装 ZFS？<a hidden class="anchor" aria-hidden="true" href="#如何安装-zfs">#</a></h4>
<p>如果你想立刻使用 ZFS（开箱即用），那么你需要安装 FreeBSD 或一个<a href="https://wiki.illumos.org/display/illumos/Distributions">使用 illumos 内核的操作系统</a>。<a href="https://wiki.illumos.org/display/illumos/illumos+Home">illumos</a> 是 OpenSolaris 内核的一个克隆版本。</p>
<p>事实上，支持 ZFS 是一些有经验的 Linux 用户选择 BSD 的主要原因。</p>
<p>如果你想在 Linux 上尝试 ZFS，那么只能在存储文件系统上使用。据我所知，没有任何 Linux 发行版可以在根目录上安装 ZFS，实现开箱即用。如果你对在 Linux 上尝试 ZFS 感兴趣，那么 <a href="https://zfsonlinux.org/">ZFS on Linux 项目</a> 上有大量的教程可以指导你怎么做。</p>
<h4 id="在-ubuntu-上使用-zfshttpslinuxcnarticle-9346-1html"><a href="https://linux.cn/article-9346-1.html">在 Ubuntu 上使用 ZFS</a><a hidden class="anchor" aria-hidden="true" href="#在-ubuntu-上使用-zfshttpslinuxcnarticle-9346-1html">#</a></h4>
<p>如果您正在考虑将 ZFS 用于您的超高速 NVMe SSD，这可能不是一个最佳选择。 它比别的文件系统要慢，不过，这完全没有问题， 它旨在<strong>存储大量的数据并保持安全</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt-get install zfsutils-linux
</code></pre></div><h5 id="创建池">创建池<a hidden class="anchor" aria-hidden="true" href="#创建池">#</a></h5>
<p>在 ZFS 中，池大致相当于 RAID 。 它们很灵活且易于操作。</p>
<p><strong>RAID0</strong></p>
<p>RAID0 只是把你的硬盘集中到一个池子里面，就像一个巨大的驱动器一样。 它可以提高你的驱动器速度，（LCTT 译注：数据条带化后，并行访问，可以提高文件读取速度）但是如果你的驱动器有损坏，你可能会失丢失数据。</p>
<p>在计算机数据存储中，数据条带化是一种对逻辑顺序数据（例如文件）进行分段的技术，以便将连续的段存储在不同的物理存储设备上。</p>
<p>要使用 ZFS 实现 RAID0，只需创建一个普通的池。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo zpool create your-pool /dev/sdc /dev/sdd
</code></pre></div><p><strong>RAID1（镜像）</strong></p>
<p>您可以在 ZFS 中使用 <code>mirror</code> 关键字来实现 RAID1 功能。 RAID1 会创建一个一对一的驱动器副本。 这意味着您的数据一直在备份。 它也提高了性能。 当然，你将一半的存储空间用于了复制。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo zpool create your-pool mirror /dev/sdc /dev/sdd
</code></pre></div><p><strong>RAID5/RAIDZ1</strong></p>
<p>ZFS 将 RAID5 功能实现为 RAIDZ1。 RAID5 要求驱动器至少是 3 个。并允许您通过将备份奇偶校验数据写入驱动器空间的 1/n（n 是驱动器数），留下的是可用的存储空间。 如果一个驱动器发生故障，阵列仍将保持联机状态，但应尽快更换发生故障的驱动器（LCTT 译注：与原文翻译略有不同，原文是驱动器的数目是三的倍数，根据 wiki， RAID5 至少需要 3 块驱动器，也可以从下面的命令中猜测)。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo zpool create your-pool raidz1 /dev/sdc /dev/sdd /dev/sde
</code></pre></div><p><strong>RAID6/RAIDZ2</strong></p>
<p>RAID6 与 RAID5 几乎完全相同，但它至少需要四个驱动器。 它将奇偶校验数据加倍，最多允许两个驱动器损坏，而不会导致阵列关闭（LCTT 译注：这里也与原文略有出入，原文是驱动器的数目是四的倍数，根据 wiki ，RAID6 至少需要四个驱动器)。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo zpool create your-pool raidz2 /dev/sdc /dev/sdd /dev/sde /dev/sdf
</code></pre></div><p><strong>RAID10（条带化镜像）</strong></p>
<p>RAID10 旨在通过数据条带化提高存取速度和数据冗余来成为一个两全其美的解决方案。 你至少需要四个驱动器，但只能使用一半的空间。 您可以通过在同一个池中创建两个镜像来创建 RAID10 中的池（LCTT 译注：这里也与原文略有出入，原文是驱动器的数目是四的倍数，根据 wiki， RAID10 至少需要四个驱动器）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo zpool create your-pool mirror /dev/sdc /dev/sdd mirror /dev/sde /dev/sdf
</code></pre></div><h5 id="池的操作">池的操作<a hidden class="anchor" aria-hidden="true" href="#池的操作">#</a></h5>
<p>还有一些管理工具，一旦你创建了你的池，你就必须使用它们来操作。 首先，检查你的池的状态。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo zpool status
</code></pre></div><p><strong>更新</strong></p>
<p>当你更新 ZFS 时，你也需要更新你的池。 当您检查它们的状态时，您的池会通知您任何更新。 要更新池，请运行以下命令。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo zpool upgrade your-pool
</code></pre></div><p>你也可以更新全部池。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo zpool upgrade -a
</code></pre></div><p><strong>添加驱动器</strong></p>
<p>您也可以随时将驱动器添加到池中。 告诉 <code>zpool</code> 池的名称和驱动器的位置，它会处理好一切。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo zpool add your-pool /dev/sdx
</code></pre></div><h4 id="实例-1">实例<a hidden class="anchor" aria-hidden="true" href="#实例-1">#</a></h4>
<p>使用两块硬盘上的等容量分区建立 raid 1。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ls -l /dev/disk/by-id
usb-JMicron_Generic_DISK00_0123456789ABCDEF-0:0-part1 -&gt; ../../sdb1
usb-JMicron_Generic_DISK01_0123456789ABCDEF-0:1-part2 -&gt; ../../sdc2
$ sudo zpool create -f -o ashift<span style="color:#f92672">=</span><span style="color:#ae81ff">12</span> -o cachefile<span style="color:#f92672">=</span>/etc/zfs/zpool.cache -O compression<span style="color:#f92672">=</span>lz4 -O xattr<span style="color:#f92672">=</span>sa -O relatime<span style="color:#f92672">=</span>on -O acltype<span style="color:#f92672">=</span>posixacl -O dedup<span style="color:#f92672">=</span>off -m none dpool mirror usb-JMicron_Generic_DISK00_0123456789ABCDEF-0:0-part1 usb-JMicron_Generic_DISK01_0123456789ABCDEF-0:1-part2
$ sudo zfs create -o mountpoint<span style="color:#f92672">=</span>none -o canmount<span style="color:#f92672">=</span>off dpool/DATA
$ sudo zfs create -o mountpoint<span style="color:#f92672">=</span>/home/kurome/DataPool dpool/DATA/important
$ sudo zpool export dpool
$ sudo zpool import dpool
</code></pre></div><h3 id="udevhttpswwwjianshucompf9385d5703a7"><a href="https://www.jianshu.com/p/f9385d5703a7">udev</a><a hidden class="anchor" aria-hidden="true" href="#udevhttpswwwjianshucompf9385d5703a7">#</a></h3>
<p>如果你使用Linux比较长时间了，那你就知道，在对待设备文件这块，Linux改变了几次策略。在Linux早期，设备文件仅仅是是一些带有适当的属性集的普通文件，它由mknod命令创建，文件存放在/dev目录下。后来，采用了devfs, 一个基于内核的动态设备文件系统，他首次出现在2.3.46内核中。Mandrake，Gentoo等Linux分发版本采用了这种方式。devfs创建 的设备文件是动态的。但是devfs有一些严重的限制，从2.6.13版本后移走了。目前取代他的便是文本要提到的udev－－一个用户空间程序。</p>
<p>目前很多的Linux分发版本采纳了udev的方式，因为它在Linux设备访问，特别是那些对设备有极端需求的站点(比如需要控制上千个硬盘)和热插拔设备(比如USB摄像头和MP3播放器)上解决了几个问题。下面我我们来看看如何管理udev设备。</p>
<p>实际上，对于那些为磁盘，终端设备等准备的标准配置文件而言，你不需要修改什么。但是，你需要了解udev配置来使用新的或者外来设备，如果不修改配置， 这些设备可能无法访问，或者说Linux可能会采用不恰当的名字，属组或权限来创建这些设备文件。你可能也想知道如何修改RS－232串口，音频设备等文件的属组或者权限。这点在实际的Linux实施中是会遇到的。</p>
<h4 id="为什么使用udev">为什么使用udev<a hidden class="anchor" aria-hidden="true" href="#为什么使用udev">#</a></h4>
<p>在此之前的设备文件管理方法(静态文件和devfs)有几个缺点：</p>
<ol>
<li>不确定的设备映射。特别是那些动态设备，比如USB设备，设备文件到实际设备的映射并不可靠和确定。举一个例子：如果你有两个USB打印机。一个可能称 为/dev/usb/lp0,另外一个便是/dev/usb/lp1。但是到底哪个是哪个并不清楚，lp0,lp1和实际的设备没有一一对应的关系，因为 他可能因为发现设备的顺序，打印机本身关闭等原因而导致这种映射并不确定。理想的方式应该是：两个打印机应该采用基于他们的序列号或者其他标识信息的唯一 设备文件来映射。但是静态文件和devfs都无法做到这点。</li>
<li>没有足够的主/辅设备号。我们知道，每一个设备文件是有两个8位的数字：一个是主设备号 ，另外一个是辅设备号来分配的。这两个8位的数字加上设备类型(块设备或者字符设备)来唯一标识一个设备。不幸的是，关联这些身边的的数字并不足够。</li>
<li>/dev目录下文件太多。一个系统采用静态设备文件关联的方式，那么这个目录下的文件必然是足够多。而同时你又不知道在你的系统上到底有那些设备文件是激活的。</li>
<li>命名不够灵活。尽管devfs解决了以前的一些问题，但是它自身又带来了一些问题。其中一个就是命名不够灵活；你别想非常简单的就能修改设备文件的名字。缺省的devfs命令机制本身也很奇怪，他需要修改大量的配置文件和程序。</li>
<li>内核内存使用，devfs特有的另外一个问题是，作为内核驱动模块，devfs需要消耗大量的内存，特别当系统上有大量的设备时(比如上面我们提到的系统一个上有好几千磁盘时)</li>
</ol>
<p>udev的目标是想解决上面提到的这些问题，他通采用用户空间(user-space)工具来管理/dev/目录树，他和文件系统分开。知道如何改变缺省配置能让你之大如何定制自己的系统，比如创建设备字符连接，改变设备文件属组，权限等。</p>
<h4 id="udev配置文件">udev配置文件<a hidden class="anchor" aria-hidden="true" href="#udev配置文件">#</a></h4>
<p>主要的udev配置文件是/etc/udev/udev.conf。这个文件通常很短，他可能只是包含几行#开头的注释，然后有几行选项：</p>
<pre tabindex="0"><code>udev_root=“/dev/”
udev_rules=“/etc/udev/rules.d/”
udev_log=“err“
</code></pre><p>上面的第二行非常重要，因为他表示udev规则存储的目录，这个目录存储的是以.rules结束的文件。每一个文件处理一系列规则来帮助udev分配名字给设备文件以保证能被内核识别。</p>
<p>你的/etc/udev/rules.d下面可能有好几个udev规则文件，这些文件一部分是udev包安装的，另外一部分则是可能是别的硬件或者软件包 生成的。比如在Fedora Core 5系统上，sane-backends包就会安装60-libsane.rules文件，另外initscripts包会安装60-net.rules文 件。这些规则文件的文件名通常是两个数字开头，它表示系统应用该规则的顺序。</p>
<p>规则文件里的规则有一系列的键/值对组成，键/值对之间用逗号(,)分割。每一个键或者是用户匹配键，或者是一个赋值键。匹配键确定规则是否被应用，而赋 值键表示分配某值给该键。这些值将影响udev创建的设备文件。匹配键和赋值键操作符解释见下表：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>匹配或赋值</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>==</td>
<td>匹配</td>
<td>相等比较</td>
</tr>
<tr>
<td>!=</td>
<td>匹配</td>
<td>不等比较</td>
</tr>
<tr>
<td>=</td>
<td>赋值</td>
<td>分配一个特定的值给该键，他可以覆盖之前的赋值。</td>
</tr>
<tr>
<td>+=</td>
<td>赋值</td>
<td>追加特定的值给已经存在的键</td>
</tr>
<tr>
<td>:=</td>
<td>赋值</td>
<td>分配一个特定的值给该键，后面的规则不可能覆盖它。</td>
</tr>
</tbody>
</table>
<p>这有点类似我们常见的编程语言，比如C语言。只是这里的键一次可以处理多个值。有一些键在udev规则文件里经常出现，这些键的值可以使用通配符(*,?,甚至范围，比如[0-9])，这些常用键列举如下：</p>
<table>
<thead>
<tr>
<th>键</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ACTION</td>
<td>一个时间活动的名字，比如add，当设备增加的时候</td>
</tr>
<tr>
<td>KERNEL</td>
<td>在内核里看到的设备名字，比如sd*表示任意SCSI磁盘设备</td>
</tr>
<tr>
<td>DEVPATH</td>
<td>内核设备路径，比如/devices/*</td>
</tr>
<tr>
<td>SUBSYSTEM</td>
<td>子系统名字，比如sound,net</td>
</tr>
<tr>
<td>BUS</td>
<td>总线的名字，比如IDE,USB</td>
</tr>
<tr>
<td>DRIVER</td>
<td>设备驱动的名字，比如ide-cdromID                       独立于内核名字的设备名字</td>
</tr>
<tr>
<td>SYSFS{ value}</td>
<td>sysfs属性值，他可以表示任意</td>
</tr>
<tr>
<td>ENV{ key}</td>
<td>环境变量，可以表示任意</td>
</tr>
<tr>
<td>PROGRAM</td>
<td>可执行的外部程序，如果程序返回0值，该键则认为为真(true)</td>
</tr>
<tr>
<td>RESULT</td>
<td>上一个PROGRAM调用返回的标准输出。</td>
</tr>
<tr>
<td>NAME</td>
<td>根据这个规则创建的设备文件的文件名。注意：仅仅第一行的NAME描述是有效的，后面的均忽略。 如果你想使用使用两个以上的名字来访问一个设备的话，可以考虑SYMLINK键。</td>
</tr>
<tr>
<td>SYMLINK</td>
<td>根据规则创建的字符连接名</td>
</tr>
<tr>
<td>OWNER</td>
<td>设备文件的属组</td>
</tr>
<tr>
<td>GROUP</td>
<td>设备文件所在的组。</td>
</tr>
<tr>
<td>MODE</td>
<td>设备文件的权限，采用8进制</td>
</tr>
<tr>
<td>RUN</td>
<td>为设备而执行的程序列表</td>
</tr>
<tr>
<td>LABEL</td>
<td>在配置文件里为内部控制而采用的名字标签(下下面的GOTO服务)</td>
</tr>
<tr>
<td>GOTO</td>
<td>跳到匹配的规则（通过LABEL来标识），有点类似程序语言中的GOTO</td>
</tr>
<tr>
<td>IMPORT{ type}</td>
<td>导入一个文件或者一个程序执行后而生成的规则集到当前文件</td>
</tr>
<tr>
<td>WAIT_FOR_SYSFS</td>
<td>等待一个特定的设备文件的创建。主要是用作时序和依赖问题。</td>
</tr>
<tr>
<td>PTIONS</td>
<td>特定的选项： last_rule 对这类设备终端规则执行； ignore_device 忽略当前规则； ignore_remove 忽略接下来的并移走请求。all_partitions 为所有的磁盘分区创建设备文件。</td>
</tr>
</tbody>
</table>
<p>我们给出一个列子来解释如何使用这些键。下面的例子来自Fedora Core 5系统的标准配置文件。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">KERNEL<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;*&#34;</span>, OWNER<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;root&#34;</span> GROUP<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;root&#34;</span>, MODE<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;0600&#34;</span> 
KERNEL<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;tty&#34;</span>, NAME<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;%k&#34;</span>, GROUP<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;tty&#34;</span>, MODE<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;0666&#34;</span>, OPTIONS<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;last_rule&#34;</span>
KERNEL<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;scd[0-9]*&#34;</span>, SYMLINK<span style="color:#f92672">+=</span><span style="color:#e6db74">&#34;cdrom cdrom-%k&#34;</span>
KERNEL<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;hd[a-z]&#34;</span>, BUS<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;ide&#34;</span>, SYSFS<span style="color:#f92672">{</span>removable<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;1&#34;</span>, SYSFS<span style="color:#f92672">{</span>device/media<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;cdrom&#34;</span>, SYMLINK<span style="color:#f92672">+=</span><span style="color:#e6db74">&#34;cdrom cdrom-%k&#34;</span> 
ACTION<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;add&#34;</span>, SUBSYSTEM<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;scsi_device&#34;</span>, RUN<span style="color:#f92672">+=</span><span style="color:#e6db74">&#34;/sbin/modprobe sg&#34;</span>
</code></pre></div><p>上面的例子给出了5个规则，每一个都是KERNEL或者ACTION键开头：</p>
<ul>
<li>第一个规则是缺省的，他匹配任意被内核识别到的设备，然后设定这些设备的属组是root，组是root，访问权限模式是0600(-rw——-)。这也是一个安全的缺省设置保证所有的设备在默认情况下只有root可以读写</li>
<li>第二个规则也是比较典型的规则了。它匹配终端设备(tty)，然后设置新的权限为0600，所在的组是tty。它也设置了一个特别的设备文件名:%K。在这里例子里，%k代表设备的内核名字。那也就意味着内核识别出这些设备是什么名字，就创建什么样的设备文件名。</li>
<li>第三行开始的KERNEL==”scd[0-9]*”,表示 SCSI CD-ROM 驱动. 它创建一对设备符号连接：cdrom和cdrom-%k。</li>
<li>第四行，开始的 KERNEL==”hd[a-z]“, 表示ATA CDROM驱动器。这个规则创建和上面的规则相同的符号连接。ATA CDROM驱动器需要sysfs值以来区别别的ATA设备，因为SCSI CDROM可以被内核唯一识别。.</li>
<li>第五行以 ACTION==”add”开始，它告诉udev增加 /sbin/modprobe sg 到命令列表，当任意SCSI设备增加到系统后，这些命令将执行。其效果就是计算机应该会增加sg内核模块来侦测新的SCSI设备。</li>
</ul>
<p>当然，上面仅仅是一小部分例子，如果你的系统采用了udev方式，那你应该可以看到更多的规则。如果你想修改设备的权限或者创建信的符号连接，那么你需要熟读这些规则，特别是要仔细注意你修改的那些与之相关的设备。</p>
<h4 id="修改你的udev配置">修改你的udev配置<a hidden class="anchor" aria-hidden="true" href="#修改你的udev配置">#</a></h4>
<p>在修改udev配置之前，我们一定要仔细，通常的考虑是：你最好不要修改系统预置的那些规则，特别不要指定影响非常广泛的配置，比如上面例子中的第一行。不正确的配置可能会导致严重的系统问题或者系统根本就无法这个正确的访问设备。</p>
<p>而我们正确的做法应该是在/etc/udev/rules.d/下创建一个新的规则文件。确定你给出的文件的后缀是rules文件名给出的数字序列应该比标准配置文件高。比如，你可以创建一个名为99-my-udev.rules的规则文件。在你的规则文件中，你可以指定任何你想修改的配置，比如，假设你 修改修改floppy设备的所在组，还准备创建一个新的符号连接/dev/floppy，那你可以这么写：</p>
<pre tabindex="0"><code class="language-undefined" data-lang="undefined">KERNEL==”fd[0-9]*“, GROUP=“users“, SYMLINK+=“floppy“
</code></pre><p>有些发行版本，比如Fedora，采用了外部脚本来修改某些特定设备的属组，组关系和权限。因此上面的改动可能并不见得生效。如果你遇到了这个问题，你就需要跟踪和修改这个脚本来达到你的目的。或者你可以修改PROGRAM或RUN键的值来做到这点。</p>
<p>某些规则的修改可能需要更深的挖掘。比如，你可能想在一个设备上使用sysfs信息来唯一标识一个设备。这些信息最好通过udevinfo命令来获取。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ruby" data-lang="ruby"><span style="color:#960050;background-color:#1e0010">$</span> udevinfo <span style="color:#960050;background-color:#1e0010">–</span>a <span style="color:#960050;background-color:#1e0010">–</span>p <span style="color:#960050;background-color:#1e0010">$</span>(udevinfo <span style="color:#960050;background-color:#1e0010">–</span>q path <span style="color:#960050;background-color:#1e0010">–</span>n <span style="color:#e6db74">/dev/</span>hda)
</code></pre></div><p>上面的命令两次使用udevinfo：一次是返回sysfs设备路径(他通常和我们看到的Linux设备文件名所在路径－－/dev/hda－－不同)；第 二次才是查询这个设备路径，结果将是非常常的syfs信息汇总。你可以找到最够的信息来唯一标志你的设备，你可以采用适当的替换udev配置文件中的 SYSFS选项。下面的结果就是上面的命令输出</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@localhost rules.d<span style="color:#f92672">]</span><span style="color:#75715e"># udevinfo -a -p $(udevinfo -q path        -n      /dev/hda1)</span>
Udevinfo starts with the device specified by the devpath and <span style="color:#66d9ef">then</span> walks up the chain of
parent devices. It prints <span style="color:#66d9ef">for</span> every device found,all possible attributes in the udev rules
key format. A rule to match, can be composed by the attributes of the device and the
attributes from one single parent device.

looking at device <span style="color:#e6db74">&#39;/block/hda/hda1&#39;</span>:     
KERNEL<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;hda1&#34;</span>     SUBSYSTEM<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;block&#34;</span>     DRIVER<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;&#34;</span>        
ATTR<span style="color:#f92672">{</span>stat<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;        1133         2268            2            4&#34;</span>         ATTR<span style="color:#f92672">{</span>size<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;208782&#34;</span>
ATTR<span style="color:#f92672">{</span>start<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;63&#34;</span>         ATTR<span style="color:#f92672">{</span>dev<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;3:1&#34;</span>        looking at parent device <span style="color:#e6db74">&#39;/block/hda&#39;</span>:  

KERNELS<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;hda&#34;</span>     SUBSYSTEMS<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;block&#34;</span>     DRIVERS<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;&#34;</span>        
ATTRS<span style="color:#f92672">{</span>stat<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;28905 18814 1234781 302540 34087 133247 849708 981336 0 218340 1283968&#34;</span>
ATTRS<span style="color:#f92672">{</span>size<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;117210240&#34;</span>         ATTRS<span style="color:#f92672">{</span>removable<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;0&#34;</span>        
ATTRS<span style="color:#f92672">{</span>range<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;64&#34;</span>         ATTRS<span style="color:#f92672">{</span>dev<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;3:0&#34;</span>

looking at parent device <span style="color:#e6db74">&#39;/devices/pci0000:00/0000:00:1f.1/ide0/0.0&#39;</span>:    

KERNELS<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;0.0&#34;</span>     SUBSYSTEMS<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;ide&#34;</span>     DRIVERS<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;ide-disk&#34;</span>        
ATTRS<span style="color:#f92672">{</span>modalias<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;ide:m-disk&#34;</span>         ATTRS<span style="color:#f92672">{</span>drivename<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;hda&#34;</span>       
ATTRS<span style="color:#f92672">{</span>media<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;disk&#34;</span>       
looking at parent device <span style="color:#e6db74">&#39;/devices/pci0000:00/0000:00:1f.1/ide0&#39;</span>:    

KERNELS<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;ide0&#34;</span>     SUBSYSTEMS<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;&#34;</span>     DRIVERS<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;&#34;</span>       
looking at parent device <span style="color:#e6db74">&#39;/devices/pci0000:00/0000:00:1f.1&#39;</span>:     
KERNELS<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;0000:00:1f.1&#34;</span>     SUBSYSTEMS<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;pci&#34;</span>     DRIVERS<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;PIIX_IDE&#34;</span>        
ATTRS<span style="color:#f92672">{</span>broken_parity_status<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;0&#34;</span>         ATTRS<span style="color:#f92672">{</span>enable<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;1&#34;</span>        
ATTRS<span style="color:#f92672">{</span>modalias<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;pci:v00008086d000024CAsv0000144Dsd0000C009bc01sc01i8a&#34;</span>
ATTRS<span style="color:#f92672">{</span>local_cpus<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;1&#34;</span>         ATTRS<span style="color:#f92672">{</span>irq<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;11&#34;</span>         ATTRS<span style="color:#f92672">{</span>class<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;0x01018a&#34;</span>
ATTRS<span style="color:#f92672">{</span>subsystem_device<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;0xc009&#34;</span>         ATTRS<span style="color:#f92672">{</span>subsystem_vendor<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;0x144d&#34;</span>
ATTRS<span style="color:#f92672">{</span>device<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;0x24ca&#34;</span>         ATTRS<span style="color:#f92672">{</span>vendor<span style="color:#f92672">}==</span><span style="color:#e6db74">&#34;0x8086&#34;</span>       
looking at parent device <span style="color:#e6db74">&#39;/devices/pci0000:00&#39;</span>:    

KERNELS<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;pci0000:00&#34;</span>     SUBSYSTEMS<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;&#34;</span>     DRIVERS<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;&#34;</span> 
</code></pre></div><p>举一个例子：假设你想修改USB扫描仪的配置。通过一系列的尝试，你已经为这个扫描仪标识了Linux设备文件(每次打开扫描仪时，名字都会变)。你可以使 用上面的命令替换这个正确的Linux设备文件名，然后定位输出的采用SYSFS{idVendor}行和SYSFS{idProduct}行。最后你可 以使用这些信息来为这个扫描仪创建新的选项。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">SYSFS{idVendor}==<span style="color:#e6db74">&#34;0686&#34;</span>, SYSFS{idProduct}==<span style="color:#e6db74">&#34;400e&#34;</span>, SYMLINK+=<span style="color:#e6db74">&#34;scanner&#34;</span>, MODE=<span style="color:#e6db74">&#34;0664&#34;</span>, <span style="color:#66d9ef">group</span>=<span style="color:#e6db74">&#34;scanner&#34;</span>
</code></pre></div><p>上面的例子表示将扫描仪的组设置为scanner，访问权限设置为0664,同时创建一个/dev/scanner的符号连接。</p>
<h4 id="mounting-usb-automatically--having-usbs-label-as-mountpointhttpsunixstackexchangecomquestions119973mounting-usb-automatically-having-usbs-label-as-mountpoint"><a href="https://unix.stackexchange.com/questions/119973/mounting-usb-automatically-having-usbs-label-as-mountpoint">Mounting usb automatically &amp; having usb&rsquo;s label as mountpoint</a><a hidden class="anchor" aria-hidden="true" href="#mounting-usb-automatically--having-usbs-label-as-mountpointhttpsunixstackexchangecomquestions119973mounting-usb-automatically-having-usbs-label-as-mountpoint">#</a></h4>
<p><strong>Note for Ubuntu Server 11.10:</strong> This script fails on Ubuntu Server 11.10 due to the obsolete <code>vol_id</code> command. <code>vol_id</code> has been superseded by <code>blkid</code>. To fix the script, replace &ldquo;vol_id&rdquo; by &ldquo;blkid -o udev&rdquo; in the <code>udev-auto-mount.sh</code> script.</p>
<p>I&rsquo;ve been banging my head around this for a while now, and I think I&rsquo;ve found a working solution. This is developed and tested on a Debian-based system, so it should work on Ubuntu. I&rsquo;ll point out the assumptions it makes so it can be adapted to other systems as well.</p>
<ul>
<li>It will automatically mount USB drives on plugin, and shouldn&rsquo;t take much to adapt for Firewire.</li>
<li>It uses UDEV, so no monkeying with HAL/DeviceKit/GNOME-Anything.</li>
<li>It automagically creates a <code>/media/LABEL</code> directory to mount the device to.</li>
<li>However, it <strong>may</strong> interfere with other automounters; I can&rsquo;t test for that. I expect that, with Gnome-VFS active, both may try to do the mount &hellip; if Gnome-VFS fails the mount, it might not configure a desktop icon. Unmounting from Gnome should be possible, but might require <code>gksudo</code> or similar.</li>
</ul>
<p>I have not tested this on system boot, but the only reason I can see that it might not work is if it tries to mount the USB drive before the system is ready for mounts. If that&rsquo;s the case, you&rsquo;ll probably need one additional tweak to the mount script. (I&rsquo;m <a href="https://serverfault.com/questions/80912/understanding-the-linux-boot-process-subsystem-initialization-udev-rules">checking with ServerFault</a> to see if there&rsquo;s any advice, but not much interest in it over there.)</p>
<p>On to it, then.</p>
<h5 id="udev-references">UDEV references<a hidden class="anchor" aria-hidden="true" href="#udev-references">#</a></h5>
<ul>
<li><a href="http://www.reactivated.net/writing_udev_rules.html">Writing udev Rules</a> (<em>the</em> reference for udev rules)</li>
<li><a href="http://linux.die.net/man/8/udev">man udev</a> (see your system for the latest version)</li>
<li><a href="http://linux.die.net/man/8/udevadm">man udevadm</a> (udev admin tool; again see your system for latest)</li>
<li><a href="http://ninetynine.be/blog/2009/03/ubuntu-backup-to-usb-drive-on-mount/">Backup to USB drive on mount</a> (completely different problem, but helpful for understanding the solution)</li>
</ul>
<h5 id="background-udev-whuzzat">Background (UDEV? Whuzzat?)<a hidden class="anchor" aria-hidden="true" href="#background-udev-whuzzat">#</a></h5>
<p>UDEV is the kernel&rsquo;s hotplug system. It&rsquo;s what automagically configures the proper devices and device symlinks (eg <code>/dev/disk/by-label/&lt;LABEL&gt;</code>), both at boot time and for devices added while the system is running.</p>
<p>D-Bus and HAL are used for sending hardware events to listeners like Desktop Environments. So when you log into GNOME and insert a CD or plug in a USB drive, that event follows this chain:</p>
<pre tabindex="0"><code>kernel -&gt; udev -&gt; dbus -&gt; hal -&gt; gnome-vfs/nautilus (mount)
</code></pre><p>And presto, your drive gets mounted. But in a headless system, we don&rsquo;t want to have to log in to get the benefits of automounting.</p>
<h5 id="udev-rules">Udev Rules<a hidden class="anchor" aria-hidden="true" href="#udev-rules">#</a></h5>
<p>Since UDEV lets us write rules and run programs on device insertion, this is an ideal choice. We&rsquo;re going to take advantage of Debian/Ubuntu&rsquo;s existing rules, let them setup the <code>/dev/disk/by-label/&lt;LABEL&gt;</code> symlink for us, and add another rule that will mount the device for us.</p>
<p>UDEV&rsquo;s rules are kept in <code>/etc/udev/rules.d</code> (and <code>/lib/udev/rules.d</code> on Karmic), and are processed in numerical order. Any file not starting with a number gets processed after the numbered files. On my system, HAL rules are in a file called <code>90-hal.rules</code>, so I put my rules in <code>89-local.rules</code> so they get processed before they get to HAL. Primarily, you need to make sure these rules happen after the <code>60-persistent-storage.rules</code>. <code>local.rules</code> may be good enough.</p>
<p><strong>Put this in your new rules file:</strong></p>
<pre tabindex="0"><code># /etc/udev/rules.d/local.rules 
# /etc/udev/rules.d/89-local.rules
# ADD rule: if we have a valid ID_FS_LABEL_ENC, and it's USB, mkdir and mount
ENV{ID_FS_LABEL_ENC}==&quot;?*&quot;,   ACTION==&quot;add&quot;,      SUBSYSTEMS==&quot;usb&quot;, \
         RUN+=&quot;/usr/local/sbin/udev-automounter.sh %k&quot;
</code></pre><ul>
<li>Make sure there&rsquo;s no spaces after the <code>\</code>, just a <code>newline</code> (<code>\n</code>).</li>
<li>Change <code>SUBSYSTEMS==&quot;usb&quot;</code> to <code>SUBSYSTEMS==&quot;usb|ieee1394&quot;</code> for Firewire support.</li>
<li>If you want the device to always be owned by a particular user, add an <code>OWNER=&quot;username&quot;</code> clause. If you just need the files owned by a particular user, tweak the mount script instead.</li>
</ul>
<p><strong>Reading the Rule</strong></p>
<p>This adds a program to run to the device&rsquo;s list of programs to run. It identifies USB partition devices by <code>&lt;LABEL&gt;</code>, then passes this information to a script that performs the mount. Specifically, this rule is matching:</p>
<ol>
<li>
<p><strong><code>ENV{ID_FS_LABEL_ENC}==&quot;?\*&quot;</code></strong> &ndash; an environment variable set by an earlier system rule. Doesn&rsquo;t exist for non-filesystems, so that&rsquo;s why we check for it. We actually want to use <code>ID_FS_LABEL</code> for the mount point, but I haven&rsquo;t convinced UDEV to escape it for me, so we&rsquo;ll let the mount script handle that.</p>
<p>This and other environment variables are obtained by udev using the <code>vol_id</code> command (<a href="https://administratosphere.wordpress.com/tag/vol_id/">deprecated</a>). It&rsquo;s a handy tool to see nice quick details on a partition:</p>
<pre tabindex="0"><code>$ sudo vol_id /dev/sdc1
ID_FS_TYPE=ext2
ID_FS_UUID=a40d282a-4a24-4593-a0ab-6f2600f920dd
ID_FS_LABEL=Travel Dawgs
ID_FS_LABEL_ENC=Travel\x20Dawgs
ID_FS_LABEL_SAFE=Travel_Dawgs
</code></pre></li>
<li>
<p><strong><code>ACTION==&quot;add&quot;</code></strong> &ndash; only match <code>add</code> events&hellip;</p>
</li>
<li>
<p><strong><code>SUBSYSTEMS==&quot;usb&quot;</code></strong> &ndash; only match devices that are on the USB bus. We use <code>SUBSYSTEMS</code> here because this matches against our device&rsquo;s parents; the device we&rsquo;re interested in will actually be SUBSYSTEM==&ldquo;scsi&rdquo;. Matching against a parent USB device avoids adding our program to the internal drives.</p>
</li>
<li>
<p><strong><code>RUN+=&quot;...&quot;</code></strong> &ndash; not a match, but an action: add this program to the list of programs to run. In the program&rsquo;s arguments, <code>%k</code> gets expanded to the device name (eg <code>sdc1</code>, not <code>/dev/sdc1</code>) and <code>$env{FOO}</code> gets the contents of environment variable FOO.</p>
</li>
</ol>
<p><strong>Testing the Rule</strong></p>
<p>The first reference link (above) is an excellent UDEV tutorial, but it&rsquo;s slightly out of date. The programs it runs for testing your rules (<code>udevtest</code> in particular) have been replaced by the catch-all <code>udevadm</code> utility.</p>
<p>After you&rsquo;ve added the rule, plug in your device. Give it a few seconds, then check to see what device it&rsquo;s been assigned to with:</p>
<pre tabindex="0"><code>$ ls -l /dev/disk/by-label/*
lrwxrwxrwx 1 root root 10 2009-10-25 07:27 label_Foo -&gt; ../../sda1
lrwxrwxrwx 1 root root 10 2009-10-25 07:27 label_Bar -&gt; ../../sdb1
lrwxrwxrwx 1 root root 10 2009-10-25 07:27 label_Baz -&gt; ../../sdc1
</code></pre><p>If your removeable drive contains <code>label_Baz</code>, it&rsquo;s on device <code>sdc1</code>. Run this and look at the output towards the end:</p>
<pre tabindex="0"><code>$ sudo udevadm test /sys/block/sdc/sdc1
parse_file: reading (...)                           (many lines about files it reads)
import_uevent_var: import into environment: (...)   (many lines about env variables)
(...)                                               (many lines tracing rule matches &amp; programs run)
update_link: found 1 devices with name 'disk/by-label/LABEL_BAZ'
update_link: found '/block/sdc/sdc1' for 'disk/by-label/LABEL_BAZ'
update_link: compare (our own) priority of '/block/sdc/sdc1' 0 &gt;= 0
update_link: 'disk/by-label/LABEL_BAZ' with target 'sdc1' has the highest priority 0, create it
udevtest: run: '/usr/local/sbin/udev-automounter.sh sdc1 LABEL_BAZ'
udevtest: run: 'socket:/org/freedesktop/hal/udev_event'
udevtest: run: 'socket:@/org/kernel/udev/monitor'
</code></pre><p>Look for the script name from our <strong><code>RUN+=</code></strong> rule in the last few lines (3rd from the bottom in this example). You can see the arguments that would be used for this device. You can run that command now to check that the arguments are sound; if it works on your commandline, it should work automatically when a device is inserted.</p>
<p>You can also monitor UDEV events in realtime: run <code>sudo udevadm monitor</code> (see <code>man udevadm</code> for details on the switches). Then just plug in a new device and watch events scroll by. (Probably overkill unless you&rsquo;re into really low-level details&hellip;)</p>
<p><strong>Reloading the Rules</strong></p>
<p>Once you&rsquo;ve verified the rule is getting read properly, you need to tell UDEV to reload its rules so the new one takes effect. Use any of these methods (if the first doesn&rsquo;t work, the second should&hellip; but try the first first):</p>
<ul>
<li>run <code>sudo udevadm control --reload-rules</code></li>
<li>run <code>sudo /etc/init.d/udev reload</code></li>
<li>reboot</li>
</ul>
<h5 id="script-actually-2-scripts">Script! Actually, 2 Scripts&hellip;<a hidden class="anchor" aria-hidden="true" href="#script-actually-2-scripts">#</a></h5>
<p><strong>Here&rsquo;s the first script.</strong> Since the program we run needs to complete quickly, this just spins the second script off in the background. Put this in <code>/usr/local/sbin/udev-automounter.sh</code>:</p>
<pre tabindex="0"><code>#!/bin/sh
#
# USAGE: usb-automounter.sh DEVICE 
#   DEVICE   is the actual device node at /dev/DEVICE

/usr/local/sbin/udev-auto-mount.sh ${1} &amp;
</code></pre><p><strong>Here&rsquo;s the second script.</strong> This does a bit more input checking. Put this in <code>/usr/local/sbin/udev-auto-mount.sh</code>. You may want to tweak the mount options below. This script now handles finding the partition LABEL on its own; UDEV only sends the DEVICE name.</p>
<p><strong>If there&rsquo;s a problem mounting drives at boot-time</strong>, you can put a nice long <code>sleep 60</code> in this script, to give the system time to come all the way up before the script attempts to mount the drive.</p>
<p>I&rsquo;ve given a suggestion in the comments for how to check (run <code>ps</code> to see if a webserver is running), but you&rsquo;ll want to tweak that for your system. I think most any network servers you might be using would suffice for this purpose &ndash; nfsd, smbd, apache, etc. The risk, of course, is that the mount script will fail if the service isn&rsquo;t running, so maybe testing a particular file&rsquo;s existence would be a better solution.</p>
<pre tabindex="0"><code>#!/bin/sh
#
# USAGE: udev-auto-mount.sh DEVICE
#   DEVICE   is the actual device node at /dev/DEVICE
# 
# This script takes a device name, looks up the partition label and
# type, creates /media/LABEL and mounts the partition.  Mount options
# are hard-coded below.

DEVICE=$1

# check input
if [ -z &quot;$DEVICE&quot; ]; then
   exit 1
fi

# test that this device isn't already mounted
device_is_mounted=`grep ${DEVICE} /etc/mtab`
if [ -n &quot;$device_is_mounted&quot; ]; then
   echo &quot;error: seems /dev/${DEVICE} is already mounted&quot;
   exit 1
fi

# If there's a problem at boot-time, this is where we'd put
# some test to check that we're booting, and then run
#     sleep 60
# so the system is ready for the mount below.
#
# An example to experiment with:
# Assume the system is &quot;booted enough&quot; if the HTTPD server is running.
# If it isn't, sleep for half a minute before checking again.
#
# The risk: if the server fails for some reason, this mount script
# will just keep waiting for it to show up.  A better solution would
# be to check for some file that exists after the boot process is complete.
#
# HTTPD_UP=`ps -ax | grep httpd | grep -v grep`
# while [ -z &quot;$HTTPD_UP&quot; ]; do
#    sleep 30
#    HTTPD_UP=`ps -ax | grep httpd | grep -v grep`
# done


# pull in useful variables from vol_id, quote everything Just In Case
eval `/sbin/vol_id /dev/${DEVICE} | sed 's/^/export /; s/=/=&quot;/; s/$/&quot;/'`

if [ -z &quot;$ID_FS_LABEL&quot; ] || [ -z &quot;$ID_FS_TYPE&quot; ]; then
   echo &quot;error: ID_FS_LABEL is empty! did vol_id break? tried /dev/${DEVICE}&quot;
   exit 1
fi


# test mountpoint - it shouldn't exist
if [ ! -e &quot;/media/${ID_FS_LABEL}&quot; ]; then

   # make the mountpoint
   mkdir &quot;/media/${ID_FS_LABEL}&quot;

   # mount the device
   # 
   # If expecting thumbdrives, you probably want 
   #      mount -t auto -o sync,noatime [...]
   # 
   # If drive is VFAT/NFTS, this mounts the filesystem such that all files
   # are owned by a std user instead of by root.  Change to your user's UID
   # (listed in /etc/passwd).  You may also want &quot;gid=1000&quot; and/or &quot;umask=022&quot;, eg:
   #      mount -t auto -o uid=1000,gid=1000 [...]
   # 
   # 
   case &quot;$ID_FS_TYPE&quot; in

       vfat)  mount -t vfat -o sync,noatime,uid=1000 /dev/${DEVICE} &quot;/media/${ID_FS_LABEL}&quot;
              ;;

              # I like the locale setting for ntfs
       ntfs)  mount -t auto -o sync,noatime,uid=1000,locale=en_US.UTF-8 /dev/${DEVICE} &quot;/media/${ID_FS_LABEL}&quot;
              ;;

              # ext2/3/4 don't like uid option
       ext*)  mount -t auto -o sync,noatime /dev/${DEVICE} &quot;/media/${ID_FS_LABEL}&quot;
              ;;
   esac

   # all done here, return successful
   exit 0
fi

exit 1
</code></pre><h5 id="super-bonus-cleanup-script">Super Bonus Cleanup Script!<a hidden class="anchor" aria-hidden="true" href="#super-bonus-cleanup-script">#</a></h5>
<p>One more script. All this does is unmount the device and remove the mountpoint directories. It assumes it has privs to do this, so you&rsquo;ll need to run it with <code>sudo</code>. This script now takes the full mountpoint on the commandline, eg:</p>
<pre tabindex="0"><code>$ /usr/local/sbin/udev-unmounter.sh &quot;/media/My Random Disk&quot;
</code></pre><p>Put this in <code>/usr/local/sbin/udev-unmounter.sh</code>:</p>
<pre tabindex="0"><code>#!/bin/sh
#
# USAGE: udev-unmounter.sh MOUNTPT
#   MOUNTPT is a mountpoint we want to unmount and delete.
MOUNTPT=&quot;$1&quot;

if [ -z &quot;$MOUNTPT&quot; ]; then
   exit 1
fi


# test mountpoint - it should exist
if [ -e &quot;${MOUNTPT}&quot; ]; then

   # very naive; just run and pray
   umount -l &quot;${MOUNTPT}&quot; &amp;&amp; rmdir &quot;${MOUNTPT}&quot; &amp;&amp; exit 0

   echo &quot;error: ${MOUNTPT} failed to unmount.&quot;
   exit 1
fi

echo &quot;error: ${MOUNTPT} does not exist&quot;
exit 1
</code></pre><h2 id="systemd">Systemd<a hidden class="anchor" aria-hidden="true" href="#systemd">#</a></h2>
<h3 id="linux-pid-1-和-systemdhttpscoolshellcnarticles17998htmlsysv_init"><a href="https://coolshell.cn/articles/17998.html#SysV_Init">LINUX PID 1 和 SYSTEMD</a><a hidden class="anchor" aria-hidden="true" href="#linux-pid-1-和-systemdhttpscoolshellcnarticles17998htmlsysv_init">#</a></h3>
<p>要说清 Systemd，得先从Linux操作系统的启动说起。Linux 操作系统的启动首先从 BIOS 开始，然后由 Boot Loader 载入内核，并初始化内核。内核初始化的最后一步就是启动 init 进程。这个进程是系统的第一个进程，PID 为 1，又叫超级进程，也叫根进程。它负责产生其他所有用户进程。所有的进程都会被挂在这个进程下，如果这个进程退出了，那么所有的进程都被 kill 。如果一个子进程的父进程退了，那么这个子进程会被挂到 PID 1 下面。（注：PID 0 是内核的一部分，主要用于内进换页，参看：<a href="https://en.wikipedia.org/wiki/Process_identifier">Process identifier</a>）</p>
<h4 id="sysv-init">SysV Init<a hidden class="anchor" aria-hidden="true" href="#sysv-init">#</a></h4>
<p>PID 1 这个进程非常特殊，其主要就任务是把整个操作系统带入可操作的状态。比如：启动 UI – Shell 以便进行人机交互，或者进入 X 图形窗口。传统上，PID 1 和传统的 Unix System V 相兼容的，所以也叫 <code>sysvinit</code>，这是使用得最悠久的 init 实现。Unix System V 于1983年 release。</p>
<p>在 <code>sysvint</code> 下，有好几个运行模式，又叫 <code>runlevel</code>。比如：常见的 3 级别指定启动到多用户的字符命令行界面，5 级别指定启起到图形界面，0 表示关机，6 表示重启。其配置在 <code>/etc/inittab</code> 文件中。</p>
<p>与此配套的还有 <code>/etc/init.d/</code> 和 <code>/etc/rc[X].d</code>，前者存放各种进程的启停脚本（需要按照规范支持 <code>start</code>，<code>stop</code>子命令），后者的 X 表示不同的 runlevel 下相应的后台进程服务，如：<code>/etc/rc3.d</code> 是 runlevel=3 的。 里面的文件主要是 link 到  <code>/etc/init.d/</code> 里的启停脚本。其中也有一定的命名规范：S 或 K 打头的，后面跟一个数字，然后再跟一个自定义的名字，如：<code>S01rsyslog</code>，<code>S02ssh</code>。S 表示启动，K表示停止，数字表示执行的顺序。</p>
<h4 id="upstart">UpStart<a hidden class="anchor" aria-hidden="true" href="#upstart">#</a></h4>
<p>Unix 和 Linux 在 <code>sysvint</code> 运作多年后，大约到了2006年的时候，Linux内核进入2.6时代，Linux有了很多更新。并且，Linux开始进入桌面系统，而桌面系统和服务器系统不一样的是，桌面系统面临频繁重启，而且，用户会非常频繁的使用硬件的热插拔技术。于是，这些新的场景，让 <code>sysvint</code> 受到了很多挑战。</p>
<p>比如，打印机需要CUPS等服务进程，但是如果用户没有打机印，启动这个服务完全是一种浪费，而如果不启动，如果要用打印机了，就无法使用，因为<code>sysvint</code> 没有自动检测的机制，它只能一次性启动所有的服务。另外，还有网络盘挂载的问题。在 <code>/etc/fstab</code> 中，负责硬盘挂载，有时候还有网络硬盘（NFS 或 iSCSI）在其中，但是在桌面机上，有很可能开机的时候是没有网络的， 于是网络硬盘都不可以访问，也无法挂载，这会极大的影响启动速度。<code>sysvinit</code> 采用 <code>netdev</code> 的方式来解决这个问题，也就是说，需要用户自己在 <code>/etc/fstab</code> 中给相应的硬盘配置上 <code>netdev</code> 属性，于是 <code>sysvint</code> 启动时不会挂载它，只有在网络可用后，由专门的 <code>netfs</code> 服务进程来挂载。这种管理方式比较难以管理，也很容易让人掉坑。</p>
<p>所以，Ubuntu 开发人员在评估了当时几个可选的 init 系统后，决定重新设计这个系统，于是，这就是我们后面看到的 <code>upstart</code> 。 <code>upstart</code> 基于事件驱动的机制，把之前的完全串行的同步启动服务的方式改成了由事件驱动的异步的方式。比如：如果有U盘插入，<code>udev</code> 得到通知，<code>upstart</code> 感知到这个事件后触发相应的服务程序，比如挂载文件系统等等。因为使用一个事件驱动的玩法，所以，启动操作系统时，很多不必要的服务可以不用启动，而是等待通知，lazy 启动。而且事件驱动的好处是，可以并行启动服务，他们之间的依赖关系，由相应的事件通知完成。</p>
<p>upstart 有着很不错的设计，其中最重要的两个概念是 Job 和 Event。</p>
<p><strong>Job</strong> 有一般的Job，也有service的Job，并且，<code>upstart</code> 管理了整个 Job 的生命周期，比如：Waiting, Starting, pre-Start, Spawned, post-Start, Running, pre-Stop, Stopping, Killed, post-Stop等等，并维护着这个生命周期的状态机。</p>
<p><strong>Event</strong> 分成三类，<code>signal</code>, <code>method</code> 和 <code>hooks</code>。<code>signal</code> 就是异步消息，<code>method</code> 是同步阻塞的。<code>hooks</code> 也是同步的，但介于前面两者之间，发出hook事件的进程必须等到事件完成，但不检查是否成功。</p>
<p>但是，<code>upstart</code> 的事件非常复杂，也非常纷乱，各种各样的事件（事件没有归好类）导致有点凌乱。不过因为整个事件驱动的设计比之前的 <code>sysvinit</code> 来说好太多，所以，也深得欢迎。</p>
<h4 id="systemd-1">Systemd<a hidden class="anchor" aria-hidden="true" href="#systemd-1">#</a></h4>
<p>直到2010的有一天，一个在 RedHat工作的工程师 <a href="https://en.wikipedia.org/wiki/Lennart_Poettering">Lennart Poettering</a> 和 <a href="https://en.wikipedia.org/wiki/Kay_Sievers">Kay Sievers</a> ，开始引入了一个新的 <code>init</code> 系统—— <code>systemd</code>。这是一个非常非常有野心的项目，这个项目几乎改变了所有的东西，<code>systemd</code> 不但想取代已有的 init 系统，而且还想干更多的东西。</p>
<p>Lennart 同意 <code>upstart</code> 干的不错，代码质量很好，基于事件的设计也很好。但是他觉得 <code>upstart</code> 也有问题，其中最大的问题还是不够快，虽然 <code>upstart</code> 用事件可以达到一定的启动并行度，但是，本质上来说，这些事件还是会让启动过程串行在一起。  如：<code>NetworkManager</code> 在等 <code>D-Bus</code> 的启动事件，而 <code>D-Bus</code> 在等 <code>syslog</code> 的启动事件。</p>
<p>Lennart 认为，实现上来说，<code>upstart</code> 其实是在管理一个逻辑上的服务依赖树，但是这个服务依赖树在表现形式上比较简单，你只需要配置——“启动 B好了就启动A”或是“停止了A后就停止B”这样的规则。但是，Lennart 说，这种简单其实是有害的（this simplification is actually detrimental）。他认为，</p>
<ul>
<li>
<p>从一个系统管理的角度出来，他一开始会设定好整个系统启动的服务依赖树，但是这个系统管理员要人肉的把这个本来就非常干净的服务依整树给翻译成计算机看的懂的 Event/Action 形式，而且 Event/Action 这种配置方式是运行时的，所以，你需要运行起来才知道是什么样的。</p>
</li>
<li>
<p>Event逻辑从头到脚到处都是，这个事件扩大了运维的复杂度，还不如之前的 <code>sysvint</code>。 也就是说，当用户配置了 “启动 <code>D-Bus</code> 后请启动 <code>NetworkManager</code>”， 这个 <code>upstart</code> 可以干，但是反过来，如果，用户启动 <code>NetworkManager</code>，我们应该先去启动他的前置依赖 <code>D-Bus</code>，然而你还要配置相应的反向 Event。本来，我只需要配置一条依赖的，结果现在我要配置很多很多情况下的Event。</p>
</li>
<li>
<p>最后，<code>upstart</code> 里的 Event 的并不标准，很混乱，没有良好的定义。比如：既有，进程启动，运行，停止的事件，也有USB设备插入、可用、拔出的事件，还有文件系统设备being mounted、 mounted 和 umounted 的事件，还有AC电源线连接和断开的事件。你会发现，这进程启停的、USB的、文件系统的、电源线的事件，看上去长得很像， 但是没有被标准化抽像出来掉，因为绝大多数的事件都是三元组：start, condition, stop 。这种概念设计模型并没有在 <code>upstart</code> 中出现。因为 <code>upstart</code> 被设计为单一的事件，而忽略了逻辑依赖。</p>
</li>
</ul>
<p>当然，如果 <code>systemd</code> 只是解决 <code>upstart</code> 的问题，他就改造 <code>upstart</code> 就好了，但是 Lennart 的野心不只是想干个这样的事，他想干的更多。</p>
<p>首先，<code>systemd</code> 清醒的认识到了 init 进程的首要目标是要让用户快速的进入可以操作OS的环境，所以，这个速度一定要快，越快越好，所以，<code>systemd</code> 的设计理念就是两条：</p>
<ul>
<li>To start <strong>less</strong>.</li>
<li>And to start <strong>more</strong> in <em>parallel</em>.</li>
</ul>
<p>也就是说，按需启动，能不启动就不启动，如果要启动，能并行启动就并行启动，包括你们之间有依赖，我也并行启动。按需启动还好理解，那么，有依赖关系的并行启动，它是怎么做到的？这里，<code>systemd</code> 借鉴了 MacOS 的 <code>Launchd</code> 的玩法（在Youtube上有一个分享——<a href="https://www.youtube.com/watch?v=SjrtySM9Dns">Launchd: One Program to Rule them All</a>，在苹果的开源网站上也有相关的设计文档——<a href="https://developer.apple.com/library/content/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/Introduction.html">About Daemons and Services</a>）</p>
<p>要解决这些依赖性，systemd 需要解决好三种底层依赖—— Socket， D-Bus ，文件系统。</p>
<ul>
<li>
<p><strong>Socket依赖</strong>。如果服务C依赖于服务S的socket，那么就要先启动S，然后再启动C，因为如果C启动时找不到S的Socket，那么C就会失败。<code>systemd</code> 可以帮你在S还没有启动好的时候，建立一个socket，用来接收所有的C的请求和数据，并缓存之，一旦S全部启动完成，把systemd替换好的这个缓存的数据和Socket描述符替换过去。</p>
</li>
<li>
<p><strong>D-Bus依赖</strong>。<code>D-Bus</code> 全称 Desktop Bus，是一个用来在进程间通信的服务。除了用于用户态进程和内核态进程通信，也用于用户态的进程之前。现在，很多的现在的服务进程都用 <code>D-Bus</code> 而不是Socket来通信。比如：<code>NetworkManager</code> 就是通过 <code>D-Bus</code> 和其它服务进程通讯的，也就是说，如果一个进程需要知道网络的状态，那么就必需要通过 <code>D-Bus</code> 通信。<code>D-Bus</code> 支持 “Bus Activation”的特性。也就是说，A要通过 <code>D-Bus</code> 服务和B通讯，但是B没有启动，那么 <code>D-Bus</code> 可以把B起来，在B启动的过程中，<code>D-Bus</code> 帮你缓存数据。<code>systemd</code> 可以帮你利用好这个特性来并行启动 A 和 B。</p>
</li>
<li>
<p><strong>文件系统依赖</strong>。系统启动过程中，文件系统相关的活动是最耗时的，比如挂载文件系统，对文件系统进行磁盘检查（fsck），磁盘配额检查等都是非常耗时的操作。在等待这些工作完成的同时，系统处于空闲状态。那些想使用文件系统的服务似乎必须等待文件系统初始化完成才可以启动。<code>systemd</code> 参考了 <code>autofs</code> 的设计思路，使得依赖文件系统的服务和文件系统本身初始化两者可以并发工作。<code>autofs</code> 可以监测到某个文件系统挂载点真正被访问到的时候才触发挂载操作，这是通过内核 <code>automounter</code> 模块的支持而实现的。比如一个 <code>open()</code> 系统调用作用在某个文件系统上的时候，而这个文件系统尚未执行挂载，此时 <code>open()</code> 调用被内核挂起等待，等到挂载完成后，控制权返回给 <code>open()</code> 系统调用，并正常打开文件。这个过程和 <code>autofs</code> 是相似的。</p>
</li>
</ul>
<p>下图来自 Lennart 的演讲里的一页PPT，展示了不同 init 系统的启动。</p>
<p><img loading="lazy" src="/Distributions/boot.png" alt="img"  />
</p>
<p>除此之外，systemd 还在启动时管理好了一些下面的事。</p>
<p>用C语言取代传统的脚本式的启动。前面说过，<code>sysvint</code> 用 <code>/etc/rcX.d</code> 下的各种脚本启动。然而这些脚本中需要使用 <code>awk</code>, <code>sed</code>, <code>grep</code>, <code>find</code>, <code>xargs</code> 等等这些操作系统的命令，这些命令需要生成进程，生成进程的开销很大，关键是生成完这些进程后，这个进程就干了点屁大的事就退了。换句话说就是，我操作系统干了那么多事为你拉个进程起来，结果你就把个字串转成小写就退了，把我操作系统当什么了？</p>
<p>在正常的一个 <code>sysvinit</code> 的脚本里，可能会有成百上千个这样的命令。所以，慢死。因此，<code>systemd</code> 全面用 C 语言全部取代了。一般来说，<code>sysvinit</code> 下，操作系统启动完成后，用 <code>echo $$</code> 可以看到，pid 被分配到了上千的样子，而 <code>systemd</code> 的系统只是上百。</p>
<p>另外，systemd 是真正一个可以管住服务进程的——可以跟踪上服务进程所fork/exec出来的所有进程。</p>
<ul>
<li>
<p>我们知道， 传统 Unix/Linux 的 Daemon 服务进程的最佳实践基本上是这个样子的（具体过程可参看这篇文章“[SysV Daemon](<a href="http://0pointer.de/public/systemd-man/daemon.html#SysV">http://0pointer.de/public/systemd-man/daemon.html#SysV</a> Daemons)”）</p>
<ol>
<li>进程启动时，关闭所有的打开的文件描述符（除了标准描述符0,1,2），然后重置所有的信号处理。</li>
<li>调用 <code>fork()</code> 创建子进程，在子进程中 <code>setsid()</code>，然后父进程退出（为了后台执行）</li>
<li>在子进程中，再调用一次 <code>fork()</code>，创建孙子进程，确定没有交互终端。然后子进程退出。</li>
<li>在孙子进程中，把标准输入标准输出标准错误都连到 <code>/dev/null</code> 上，还要创建 pid 文件，日志文件，处理相关信号 ……</li>
<li>最后才是真正开始提供服务。</li>
</ol>
</li>
<li>
<p>在上面的这个过程中，服务进程除了两次 <code>fork</code> 外还会 <code>fork</code> 出很多很多的子进程（比如说一些Web服务进程，会根据用户的请求链接来 <code>fork</code> 子进程），这个进程树是相当难以管理的，因为，一旦父进程退出来了，子进程就会被挂到 PID 1下，所以，基本上来说，你无法通过服务进程自已给定的一个pid文件来找到所有的相关进程（这个对开发者的要求太高了），所以，在传统的方式下用脚本启停服务是相当相当的 Buggy 的，因为无法做对所有的服务生出来的子子孙孙做到监控。</p>
</li>
<li>
<p>为了解决这个问题，<code>upstart</code> 通过变态的 <code>strace</code> 来跟踪进程中的 <code>fork()</code> 和 <code>exec()</code> 或 <code>exit()</code> 等相关的系统调用。这种方法相当笨拙。 <code>systemd</code> 使用了一个非常有意思的玩法来 tracking 服务进程生出来的所有进程，那就是用 <code>cgroup</code> （我在 <a href="https://coolshell.cn/articles/17049.html">Docker 的基础技术“cgroup篇”</a>中讲过这个东西）。cgroup主要是用来管理进程组资源配额的事，所以，无论服务如何启动新的子进程，所有的这些相关进程都会同属于一个 <code>cgroup</code>，所以，<code>systemd</code> 只需要简单的去遍历一下相应的 <code>cgroup</code> 的那个虚文件系统目录下的文件，就可以正确的找到所有的相关进程，并将他们一一停止。</p>
</li>
</ul>
<p>另外，<code>systemd</code> 简化了整个 daemon 开发的过程：</p>
<ul>
<li>不需要两次 <code>fork()</code>，只需要实现服务本身的主逻辑就可以了。</li>
<li>不需要 <code>setsid()</code>，<code>systemd</code> 会帮你干</li>
<li>不需要维护 <code>pid文件</code>，<code>systemd</code> 会帮处理。</li>
<li>不需要管理日志文件或是使用<code>syslog</code>，或是处理<code>HUP</code>的日志reload信号。把日志打到 <code>stderr</code> 上，<code>systemd</code> 帮你管理。</li>
<li>处理 <code>SIGTERM</code> 信号，这个信号就是正确退出当前服务，不要做其他的事。</li>
<li>……</li>
</ul>
<p>除此之外，<code>systemd</code> 还能——</p>
<ul>
<li>自动检测启动的服务间有没有环形依赖。</li>
<li>内建 autofs 自动挂载管理功能。</li>
<li>日志服务。<code>systemd</code> 改造了传统的 syslog 的问题，采用二进制格式保存日志，日志索引更快。</li>
<li>快照和恢复。对当前的系统运行的服务集合做快照，并可以恢复。</li>
<li>……</li>
</ul>
<p>还有好多好多，他接管很多很多东西，于是就让很多人不爽了，因为他在干了很多本不属于 PID 1 的事。</p>
<h4 id="systemd-争论和八卦">Systemd 争论和八卦<a hidden class="anchor" aria-hidden="true" href="#systemd-争论和八卦">#</a></h4>
<p>于是 <code>systemd</code> 这个东西成了可能是有史以来口水战最多的一个开源软件了。<code>systemd</code> 饱受各种争议，最大的争议就是他破坏了 Unix 的设计哲学（相关的哲学可以读一下《<a href="https://book.douban.com/subject/1467587/">Unix编程艺术</a>》），干了一个大而全而且相当复杂的东西。当然，Lennart 并不同意这样的说法，他后来又写一篇blog “<a href="http://0pointer.de/blog/projects/the-biggest-myths.html">The Biggest Myths</a>”来解释 <code>systemd</code> 并不是这样的，大家可以前往一读。</p>
<p>这个争议大到什么样子呢？2014 年，Debian Linux 因为想准备使用 <code>systemd</code> 来作为标准的 init 守护进程来替换 <code>sysvinit</code> 。而围绕这个事的争论达到了空前的热度，争论中充满着仇恨，<code>systemd</code> 的支持者和反对者都在互相辱骂，导致当时 Debian 阵营开始分裂。还有人给 Lennart 发了死亡威胁的邮件，用比特币雇凶买杀手，扬言要取他的性命，在Youbute上传了侮辱他的歌曲，在IRC和各种社交渠道上给他发下流和侮辱性的消息。这已经不是争议了，而是一种不折不扣的仇恨！</p>
<p>于是，Lennart 在 <a href="https://plus.google.com/+LennartPoetteringTheOneAndOnly/posts/J2TZrTvu7vd">Google Plus 上发了贴子</a>，批评整个 Linux 开源社区和 Linus 本人。他大意说，</p>
<blockquote>
<p>这个社区太病态了，全是 ass holes，你们不停用各种手段在各种地方用不同的语言和方式来侮辱和漫骂我。我还是一个年轻人，我从来没有经历过这样的场面，但是今天我已经对这种场面很熟悉了。我有时候说话可能不准确，但是我不会像他样那样说出那样的话，我也没有被这些事影响，因为我脸皮够厚，所以，为什么我可以在如何大的反对声面前让 <code>systemd</code> 成功，但是，你们 Linux 社区太可怕了。你们里面的有精神病的人太多了。另外，对于Linus Torvalds，你是这个社区的 Role Model，但可惜你是一个 Bad Role Model，你在社区里的刻薄和侮辱性的言行，基本从一定程度上鼓励了其它人跟你一样，当然，并不只是你一个人的问题，而是在你周围聚集了一群和你一样的这样干的人。送你一句话—— A fish rots from the head down ！一条鱼是从头往下腐烂的……</p>
</blockquote>
<p>这篇契文很长，喜欢八卦的同学可以前往一读。感受一下 Lennart 当时的心态（我觉得能算上是非常平稳了）。</p>
<p>Linus也在被一媒体问起 <code>systemd</code> 这个事来（参看“<a href="https://www.itwire.com/business-it-news/open-source/65402-torvalds-says-he-has-no-strong-opinions-on-systemd">Torvalds says he has no strong opinions on systemd</a>”），Linus在采访里说，</p>
<blockquote>
<p>我对 <code>systemd</code> 和 Lennart 的贴子没有什么强烈的想法。虽然，传统的 Unix 设计哲学—— “Do one thing and Do it well”，很不错，而且我们大多数人也实践了这么多年，但是这并不代表所有的真实世界。在历史上，也不只有<code>systemd</code> 这么干过。但是，我个人还是 old-fashioned 的人，至少我喜欢文本式的日志，而不是二进制的日志。但是 <code>systemd</code> 没有必要一定要有这样的品味。哦，我说细节了……</p>
</blockquote>
<p>今天，<code>systemd</code> 占据了几乎所有的主流的 Linux 发行版的默认配置，包括：Arch Linux、CentOS、CoreOS、Debian、Fedora、Megeia、OpenSUSE、RHEL、SUSE企业版和 Ubuntu。而且，对于 CentOS, CoreOS, Fedora, RHEL, SUSE这些发行版来说，不能没有 <code>systemd</code>。（Ubuntu 还有一个不错的wiki – <a href="https://wiki.ubuntu.com/SystemdForUpstartUsers">Systemd for Upstart Users</a> 阐述了如何在两者间切换）</p>
<h4 id="其它">其它<a hidden class="anchor" aria-hidden="true" href="#其它">#</a></h4>
<p>还记得在《<a href="https://coolshell.cn/articles/17416.html">缓存更新的套路</a>》一文中，我说过，<strong>如果你要做好架构，首先你得把计算机体系结构以及很多老古董的基础技术吃透了</strong>。因为里面会有很多可以借鉴和相通的东西。那么，你是否从这篇文章里看到了一些有分布式架构相似的东西？</p>
<p>比如：从 <code>sysvinit</code> 到 <code>upstart</code> 再到 <code>systemd</code>，像不像是服务治理？Linux系统下的这些服务进程，是不是很像分布式架构中的微服务？还有那个D-Bus，是不是很像SOA里的ESB？而 init 系统是不是很像一个控制系统？甚至像一个服务编排（Service Orchestration）系统？</p>
<p>分布式系统中的服务之间也有很多依赖，所以，在启动一个架构的时候，如果我们可以做到像 systemd 那样并行启动的话，那么是不是就像是一个微服务的玩法了？</p>
<p>嗯，你会发现，技术上的很多东西是相通的，也是互相有对方的影子，所以，其实技术并不多。关键是我们学在了表面还是看到了本质。</p>
<h3 id="命令httpswwwruanyifengcomblog201603systemd-tutorial-commandshtml"><a href="https://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html">命令</a><a hidden class="anchor" aria-hidden="true" href="#命令httpswwwruanyifengcomblog201603systemd-tutorial-commandshtml">#</a></h3>
<p>Systemd 是 Linux 系统工具，用来启动守护进程，已成为大多数发行版的标准配置。</p>
<h4 id="系统管理">系统管理<a hidden class="anchor" aria-hidden="true" href="#系统管理">#</a></h4>
<p>Systemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面。</p>
<p><strong>systemctl</strong></p>
<p><code>systemctl</code>是 Systemd 的主命令，用于管理系统。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 重启系统</span>
$ sudo systemctl reboot
<span style="color:#75715e"># 关闭系统，切断电源</span>
$ sudo systemctl poweroff
<span style="color:#75715e"># CPU停止工作</span>
$ sudo systemctl halt
<span style="color:#75715e"># 暂停系统</span>
$ sudo systemctl suspend
<span style="color:#75715e"># 让系统进入冬眠状态</span>
$ sudo systemctl hibernate
<span style="color:#75715e"># 让系统进入交互式休眠状态</span>
$ sudo systemctl hybrid-sleep
<span style="color:#75715e"># 启动进入救援状态（单用户状态）</span>
$ sudo systemctl rescue
</code></pre></div><p><strong>systemd-analyze</strong></p>
<p><code>systemd-analyze</code>命令用于查看启动耗时。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 查看启动耗时</span>
$ systemd-analyze   
<span style="color:#75715e"># 查看每个服务的启动耗时</span>
$ systemd-analyze blame
<span style="color:#75715e"># 显示瀑布状的启动过程流$</span>
$ systemd-analyze critical-chain
<span style="color:#75715e"># 显示指定服务的启动流</span>
$ systemd-analyze critical-chain atd.service
</code></pre></div><p><strong>hostnamectl</strong></p>
<p><code>hostnamectl</code>命令用于查看当前主机的信息。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 显示当前主机的信息</span>
$ hostnamectl
<span style="color:#75715e"># 设置主机名。</span>
$ sudo hostnamectl set-hostname rhel7
</code></pre></div><p><strong>localectl</strong></p>
<p><code>localectl</code>命令用于查看本地化设置。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 查看本地化设置</span>
$ localectl
<span style="color:#75715e"># 设置本地化参数。</span>
$ sudo localectl set-locale LANG<span style="color:#f92672">=</span>en_GB.utf8
$ sudo localectl set-keymap en_GB
</code></pre></div><p><strong>timedatectl</strong></p>
<p><code>timedatectl</code>命令用于查看当前时区设置。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 查看当前时区设置</span>
$ timedatectl
<span style="color:#75715e"># 显示所有可用的时区</span>
$ timedatectl list-timezones                                    
<span style="color:#75715e"># 设置当前时区</span>
$ sudo timedatectl set-timezone America/New_York
$ sudo timedatectl set-time YYYY-MM-DD
$ sudo timedatectl set-time HH:MM:SS
</code></pre></div><p><strong>loginctl</strong></p>
<p><code>loginctl</code>命令用于查看当前登录的用户。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 列出当前session</span>
$ loginctl list-sessions
<span style="color:#75715e"># 列出当前登录用户</span>
$ loginctl list-users
<span style="color:#75715e"># 列出显示指定用户的信息</span>
$ loginctl show-user ruanyf
</code></pre></div><h4 id="unit">Unit<a hidden class="anchor" aria-hidden="true" href="#unit">#</a></h4>
<p><strong>含义</strong></p>
<p>Systemd 可以管理所有系统资源。不同的资源统称为 Unit（单元）。简单说，单元就是 Systemd 的最小功能单位，是单个进程的描述。一个个小的单元互相调用和依赖，组成一个庞大的任务管理系统，这就是 Systemd 的基本思想。</p>
<p>由于 Systemd 要做的事情太多，导致单元有很多不同的种类，大概一共有12种。</p>
<ul>
<li>Service unit：系统服务</li>
<li>Target unit：多个 Unit 构成的一个组</li>
<li>Device Unit：硬件设备</li>
<li>Mount Unit：文件系统的挂载点</li>
<li>Automount Unit：自动挂载点</li>
<li>Path Unit：文件或路径</li>
<li>Scope Unit：不是由 Systemd 启动的外部进程</li>
<li>Slice Unit：进程组，资源分配</li>
<li>Snapshot Unit：Systemd 快照，可以切回某个快照</li>
<li>Socket Unit：进程间通信的 socket</li>
<li>Swap Unit：swap 文件</li>
<li>Timer Unit：定时器</li>
</ul>
<p><code>systemctl list-units</code>命令可以查看当前系统的所有 Unit 。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 列出正在运行的 Unit</span>
$ systemctl list-units
<span style="color:#75715e"># 列出所有Unit，包括没有找到配置文件的或者启动失败的</span>
$ systemctl list-units --all
<span style="color:#75715e"># 列出所有没有运行的 Unit</span>
$ systemctl list-units --all --state<span style="color:#f92672">=</span>inactive
<span style="color:#75715e"># 列出所有加载失败的 Unit</span>
$ systemctl list-units --failed
<span style="color:#75715e"># 列出所有正在运行的、类型为 service 的 Unit</span>
$ systemctl list-units --type<span style="color:#f92672">=</span>service
</code></pre></div><p><strong>Unit 的状态</strong></p>
<p><code>systemctl status</code>命令用于查看系统状态和单个 Unit 的状态。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 显示系统状态</span>
$ systemctl status
<span style="color:#75715e"># 显示单个 Unit 的状态</span>
$ sysystemctl status bluetooth.service
<span style="color:#75715e"># 显示远程主机的某个 Unit 的状态</span>
$ systemctl -H root@rhel7.example.com status httpd.service
</code></pre></div><p>例如查看 httpd 状态</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo systemctl status httpd

httpd.service - The Apache HTTP Server
   Loaded: loaded <span style="color:#f92672">(</span>/usr/lib/systemd/system/httpd.service; enabled<span style="color:#f92672">)</span>
   Active: active <span style="color:#f92672">(</span>running<span style="color:#f92672">)</span> since 金 2014-12-05 12:18:22 JST; 7min ago
 Main PID: <span style="color:#ae81ff">4349</span> <span style="color:#f92672">(</span>httpd<span style="color:#f92672">)</span>
   Status: <span style="color:#e6db74">&#34;Total requests: 1; Current requests/sec: 0; Current traffic:   0 B/sec&#34;</span>
   CGroup: /system.slice/httpd.service
           ├─4349 /usr/sbin/httpd -DFOREGROUND
           ├─4350 /usr/sbin/httpd -DFOREGROUND
           ├─4351 /usr/sbin/httpd -DFOREGROUND
           ├─4352 /usr/sbin/httpd -DFOREGROUND
           ├─4353 /usr/sbin/httpd -DFOREGROUND
           └─4354 /usr/sbin/httpd -DFOREGROUND

12月 <span style="color:#ae81ff">05</span> 12:18:22 localhost.localdomain systemd<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span>: Starting The Apache HTTP Server...
12月 <span style="color:#ae81ff">05</span> 12:18:22 localhost.localdomain systemd<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span>: Started The Apache HTTP Server.
12月 <span style="color:#ae81ff">05</span> 12:22:40 localhost.localdomain systemd<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span>: Started The Apache HTTP Server.
</code></pre></div><p>上面的输出结果含义如下。</p>
<ul>
<li><code>Loaded</code>行：配置文件的位置，是否设为开机启动</li>
<li><code>Active</code>行：表示正在运行</li>
<li><code>Main PID</code>行：主进程ID</li>
<li><code>Status</code>行：由应用本身（这里是 httpd ）提供的软件当前状态</li>
<li><code>CGroup</code>块：应用的所有子进程</li>
<li>日志块：应用的日志</li>
</ul>
<p>除了<code>status</code>命令，<code>systemctl</code>还提供了三个查询状态的简单方法，主要供脚本内部的判断语句使用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 显示某个 Unit 是否正在运行</span>
$ systemctl is-active application.service
<span style="color:#75715e"># 显示某个 Unit 是否处于启动失败状态</span>
$ systemctl is-failed application.service
<span style="color:#75715e"># 显示某个 Unit 服务是否建立了启动链接</span>
$ systemctl is-enabled application.service
</code></pre></div><p><strong>Unit 管理</strong></p>
<p>对于用户来说，最常用的是下面这些命令，用于启动和停止 Unit（主要是 service）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 立即启动一个服务</span>
$ sudo systemctl start apache.service
<span style="color:#75715e"># 立即停止一个服务</span>
$ sudo systemctl stop apache.service
<span style="color:#75715e"># 重启一个服务</span>
$ sudo systemctl restart apache.service
<span style="color:#75715e"># 杀死一个服务的所有子进程</span>
$ sudo systemctl kill apache.service
<span style="color:#75715e"># 重新加载一个服务的配置文件</span>
$ sudo systemctl reload apache.service
<span style="color:#75715e"># 重载所有修改过的配置文件</span>
$ sudo systemctl daemon-reload
<span style="color:#75715e"># 显示某个 Unit 的所有底层参数</span>
$ systemctl show httpd.service
<span style="color:#75715e"># 显示某个 Unit 的指定属性的值</span>
$ systemctl show -p CPUShares httpd.service
<span style="color:#75715e"># 设置某个 Unit 的指定属性</span>
$ sudo systemctl set-property httpd.service CPUShares<span style="color:#f92672">=</span><span style="color:#ae81ff">500</span>
</code></pre></div><p>有时候，该命令可能没有响应，执行<code>systemctl stop</code>服务停不下来。这时候就不得不&quot;杀进程&quot;了，向正在运行的进程发出<code>kill</code>信号，执行<code>systemctl kill</code>。</p>
<p><strong>依赖关系</strong></p>
<p>Unit 之间存在依赖关系：A 依赖于 B，就意味着 Systemd 在启动 A 的时候，同时会去启动 B。</p>
<p><code>systemctl list-dependencies</code>命令列出一个 Unit 的所有依赖。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ systemctl list-dependencies nginx.service
</code></pre></div><p>上面命令的输出结果之中，有些依赖是 Target 类型（详见下文），默认不会展开显示。如果要展开 Target，就需要使用<code>--all</code>参数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ systemctl list-dependencies --all nginx.service
</code></pre></div><h4 id="unit-的配置文件">Unit 的配置文件<a hidden class="anchor" aria-hidden="true" href="#unit-的配置文件">#</a></h4>
<p><strong>概述</strong></p>
<p>每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit 。</p>
<p>除了系统默认的单元文件<code>/lib/systemd/system</code>，Systemd 默认从目录<code>/etc/systemd/system/</code>读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录<code>/usr/lib/systemd/system/</code>。那些支持 Systemd 的软件，安装的时候，也会自动在<code>/usr/lib/systemd/system</code>目录添加一个配置文件。</p>
<p><code>systemctl enable</code>命令用于在<code>/etc/systemd/system/</code>和<code>/usr/lib/systemd/system</code>之间，建立符号链接关系。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo systemctl enable clamd@scan.service
<span style="color:#75715e"># 等同于</span>
$ sudo ln -s <span style="color:#e6db74">&#39;/usr/lib/systemd/system/clamd@scan.service&#39;</span> <span style="color:#e6db74">&#39;/etc/systemd/system/multi-user.target.wants/clamd@scan.service&#39;</span>
</code></pre></div><p>如果配置文件里面设置了开机启动，<code>systemctl enable</code>命令相当于激活开机启动。</p>
<p>与之对应的，<code>systemctl disable</code>命令用于在两个目录之间，撤销符号链接关系，相当于撤销开机启动。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo systemctl disable clamd@scan.service
</code></pre></div><p>配置文件的后缀名，就是该 Unit 的种类，比如<code>sshd.socket</code>。如果省略，Systemd 默认后缀名为<code>.service</code>，所以<code>sshd</code>会被理解成<code>sshd.service</code>。</p>
<p>设置开机启动以后，软件并不会立即启动，必须等到下一次开机。如果想现在就运行该软件，那么要执行<code>systemctl start</code>命令。</p>
<p><strong>配置文件的状态</strong></p>
<p><code>systemctl list-unit-files</code>命令用于列出所有配置文件。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 列出所有配置文件</span>
$ systemctl list-unit-files
<span style="color:#75715e"># 列出指定类型的配置文件</span>
$ systemctl list-unit-files --type<span style="color:#f92672">=</span>service
</code></pre></div><p>这个命令会输出一个列表。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ systemctl list-unit-filesUNIT FILE              STATEchronyd.service        enabledclamd@.service         staticclamd@scan.service     disabled
</code></pre></div><p>这个列表显示每个配置文件的状态，一共有四种。</p>
<ul>
<li>enabled：已建立启动链接</li>
<li>disabled：没建立启动链接</li>
<li>static：该配置文件没有<code>[Install]</code>部分（无法执行），只能作为其他配置文件的依赖</li>
<li>masked：该配置文件被禁止建立启动链接</li>
</ul>
<p>注意，从配置文件的状态无法看出，该 Unit 是否正在运行。这必须执行前面提到的<code>systemctl status</code>命令。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ systemctl status bluetooth.service
</code></pre></div><p>一旦修改配置文件，就要让 Systemd 重新加载配置文件，然后重新启动，否则修改不会生效。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo systemctl daemon-reload
$ sudo systemctl restart httpd.service
</code></pre></div><p><strong>配置文件的格式</strong></p>
<p>配置文件就是普通的文本文件，可以用文本编辑器打开。</p>
<p><code>systemctl cat</code>命令可以查看配置文件的内容。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ systemctl cat sshd.service

<span style="color:#f92672">[</span>Unit<span style="color:#f92672">]</span>
Description<span style="color:#f92672">=</span>OpenSSH server daemon
Documentation<span style="color:#f92672">=</span>man:sshd<span style="color:#f92672">(</span>8<span style="color:#f92672">)</span> man:sshd_config<span style="color:#f92672">(</span>5<span style="color:#f92672">)</span>
After<span style="color:#f92672">=</span>network.target sshd-keygen.service
Wants<span style="color:#f92672">=</span>sshd-keygen.service

<span style="color:#f92672">[</span>Service<span style="color:#f92672">]</span>
EnvironmentFile<span style="color:#f92672">=</span>/etc/sysconfig/sshd
ExecStart<span style="color:#f92672">=</span>/usr/sbin/sshd -D $OPTIONS
ExecReload<span style="color:#f92672">=</span>/bin/kill -HUP $MAINPID
Type<span style="color:#f92672">=</span>simpleKill
Mode<span style="color:#f92672">=</span>process
Restart<span style="color:#f92672">=</span>on-failure
RestartSec<span style="color:#f92672">=</span>42s

<span style="color:#f92672">[</span>Install<span style="color:#f92672">]</span>
WantedBy<span style="color:#f92672">=</span>multi-user.target
</code></pre></div><p>从上面的输出可以看到，配置文件分成几个区块。每个区块的第一行，是用方括号表示的区别名，比如<code>[Unit]</code>。注意，配置文件的区块名和字段名，都是大小写敏感的。</p>
<p>每个区块内部是一些等号连接的键值对。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>Section<span style="color:#f92672">]</span>
Directive1<span style="color:#f92672">=</span>value
Directive2<span style="color:#f92672">=</span>value
. . .
</code></pre></div><p>注意，键值对的等号两侧不能有空格。</p>
<p><strong>配置文件的区块</strong></p>
<p><code>[Unit]</code>区块通常是配置文件的第一个区块，用来定义 Unit 的元数据，以及配置与其他 Unit 的关系。它的主要字段如下。</p>
<ul>
<li>
<p><code>Description</code>：当前服务的简单描述</p>
</li>
<li>
<p><code>Documentation</code>：文档地址</p>
</li>
<li>
<p>启动顺序</p>
<ul>
<li><code>Before</code>：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动</li>
<li><code>After</code>：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之前启动。如<code>network.target</code>或<code>sshd-keygen.service</code>需要启动，那么<code>sshd.service</code>应该在它们之后启动。</li>
</ul>
</li>
<li>
<p>依赖关系：</p>
<p>举例来说，某 Web 应用需要 postgresql 数据库储存数据。在配置文件中，<code>Before</code>、<code>After</code> 只定义要在 postgresql 之后启动，而没有定义依赖 postgresql 。上线后，由于某种原因，postgresql 需要重新启动，在停止服务期间，该 Web 应用就会无法建立数据库连接。</p>
<p>注意，<code>Wants</code>字段与<code>Requires</code>字段只涉及依赖关系，与启动顺序无关，默认情况下是同时启动的。</p>
<ul>
<li><code>Wants</code>：与当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败。如<code>sshd.service</code>与<code>sshd-keygen.service</code>之间存在&quot;弱依赖&quot;关系，即如果&quot;sshd-keygen.service&quot;启动失败或停止运行，不影响<code>sshd.service</code>继续执行。</li>
<li><code>Requires</code>：当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败。<code>Requires</code>字段则表示&quot;强依赖&quot;关系，即如果该服务启动失败或异常退出，那么<code>sshd.service</code>也必须退出。</li>
</ul>
</li>
<li>
<p><code>BindsTo</code>：与<code>Requires</code>类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行</p>
</li>
<li>
<p><code>Conflicts</code>：这里指定的 Unit 不能与当前 Unit 同时运行</p>
</li>
<li>
<p><code>Condition...</code>：当前 Unit 运行必须满足的条件，否则不会运行</p>
</li>
<li>
<p><code>Assert...</code>：当前 Unit 运行必须满足的条件，否则会报启动失败</p>
</li>
<li>
<p><a href="http://www.jinbuguo.com/systemd/systemd.unit.html#StartLimitIntervalSec=interval"><code>StartLimitIntervalSec=interval, StartLimitBurst=burst</code></a>：设置单元的启动频率限制。 也就是该单元在 <em><code>interval</code></em> 时间内最多允许启动 <em><code>burst</code></em> 次。</p>
</li>
</ul>
<hr>
<p><code>[Service]</code>区块用来定义如何启动当前服务，只有 Service 类型的 Unit 才有这个区块。它的主要字段如下。</p>
<ul>
<li>
<p><code>EnvironmentFile</code>字段：指定当前服务的环境参数文件。该文件内部的<code>key=value</code>键值对，可以用<code>$key</code>的形式，在当前配置文件中获取。sshd 的环境参数文件是<code>/etc/sysconfig/sshd</code>。</p>
</li>
<li>
<p><code>ExecStart</code>字段：定义启动进程时执行的命令。是配置文件里面最重要的字段。上面的例子中，启动<code>sshd</code>，执行的命令是<code>/usr/sbin/sshd -D $OPTIONS</code>，其中的变量<code>$OPTIONS</code>就来自<code>EnvironmentFile</code>字段指定的环境参数文件。与之作用相似的，还有如下这些字段。</p>
<ul>
<li><code>ExecReload</code>字段：重启服务时执行的命令</li>
<li><code>ExecStop</code>字段：停止服务时执行的命令</li>
<li><code>ExecStartPre</code>字段：启动服务之前执行的命令</li>
<li><code>ExecStartPost</code>字段：启动服务之后执行的命令</li>
<li><code>ExecStopPost</code>字段：停止服务之后执行的命令</li>
</ul>
</li>
<li>
<p><code>Type</code>：字段定义启动类型。它可以设置的值如下。</p>
<ul>
<li>simple（默认值）：<code>ExecStart</code>字段启动的进程为主进程</li>
<li>forking：<code>ExecStart</code>字段将以<code>fork()</code>方式启动，此时父进程将会退出，子进程将成为主进程</li>
<li>oneshot：类似于<code>simple</code>，但只执行一次，Systemd 会等它执行完，才启动其他服务</li>
<li>dbus：类似于<code>simple</code>，但会等待 D-Bus 信号后启动</li>
<li>notify：类似于<code>simple</code>，启动结束后会发出通知信号，然后 Systemd 再启动其他服务</li>
<li>idle：类似于<code>simple</code>，但是要等到其他任务都执行完，才会启动该服务。一种使用场合是为让该服务的输出，不与其他服务的输出相混合</li>
</ul>
</li>
<li>
<p><code>KillMode</code>字段：定义 Systemd 如何停止服务。</p>
<ul>
<li>control-group（默认值）：当前控制组里面的所有子进程，都会被杀掉</li>
<li>process：只杀主进程。比如sshd的<code>KillMode</code>设为<code>process</code>，子进程打开的 SSH session 仍然保持连接。</li>
<li>mixed：主进程将收到 SIGTERM 信号，子进程收到 SIGKILL 信号</li>
<li>none：没有进程会被杀掉，只是执行服务的 stop 命令。</li>
</ul>
</li>
<li>
<p><code>Restart</code>：<code>Restart</code>字段：定义了服务退出后，Systemd 重启该服务的方式。</p>
<ul>
<li>no（默认值）：退出后不会重启</li>
<li>on-success：只有正常退出时（退出状态码为0），才会重启</li>
<li>on-failure：非正常退出时（退出状态码非0），包括被信号终止和超时，才会重启。比如sshd任何意外的失败，都将重启sshd；如果 sshd 正常停止（比如执行<code>systemctl stop</code>命令），它就不会重启。对于守护进程，推荐设为<code>on-failure</code>。</li>
<li>on-abnormal：只有被信号终止和超时，才会重启。对于那些允许发生错误退出的服务，可以设为<code>on-abnormal</code>。</li>
<li>on-abort：只有在收到没有捕捉到的信号终止时，才会重启</li>
<li>on-watchdog：超时退出，才会重启</li>
<li>always：不管是什么退出原因，总是重启</li>
</ul>
<table>
<thead>
<tr>
<th>退出原因(↓) | Restart= (→)</th>
<th><code>no</code></th>
<th><code>always</code></th>
<th><code>on-success</code></th>
<th><code>on-failure</code></th>
<th><code>on-abnormal</code></th>
<th><code>on-abort</code></th>
<th><code>on-watchdog</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>正常退出</td>
<td></td>
<td>X</td>
<td>X</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>退出码不为&quot;0&quot;</td>
<td></td>
<td>X</td>
<td></td>
<td>X</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>进程被强制杀死</td>
<td></td>
<td>X</td>
<td></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>systemd 操作超时</td>
<td></td>
<td>X</td>
<td></td>
<td>X</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>看门狗超时</td>
<td></td>
<td>X</td>
<td></td>
<td>X</td>
<td>X</td>
<td></td>
<td>X</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><code>RestartSec</code>字段：表示 Systemd 重启服务之前，需要等待的秒数。</p>
</li>
<li>
<p><code>TimeoutSec</code>：定义 Systemd 停止当前服务之前等待的秒数</p>
</li>
</ul>
<p>所有的启动设置之前，都可以加上一个连词号（<code>-</code>），表示&quot;抑制错误&quot;，即发生错误的时候，不影响其他命令的执行。比如，<code>EnvironmentFile=-/etc/sysconfig/sshd</code>（注意等号后面的那个连词号），就表示即使<code>/etc/sysconfig/sshd</code>文件不存在，也不会抛出错误。</p>
<hr>
<p><code>[Install]</code>通常是配置文件的最后一个区块，定义如何安装这个配置文件，即怎样做到开机启动。它的主要字段如下。</p>
<ul>
<li><code>WantedBy</code>字段：表示该服务所在的 Target，它的值是一个或多个 Target。<code>Target</code>的含义是服务组，表示一组服务。<code>WantedBy=multi-user.target</code>指的是，sshd 所在的 Target 是<code>multi-user.target</code>。当前 Unit 激活时（enable）符号链接会放入<code>/etc/systemd/system</code>目录下面 <code>[Target 名].wants</code>子目录中，如<code>multi-user.target.wants</code>子目录。</li>
<li><code>RequiredBy</code>：它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入<code>/etc/systemd/system</code>目录下面以 Target 名 + <code>.required</code>后缀构成的子目录中</li>
<li><code>Alias</code>：当前 Unit 可用于启动的别名</li>
<li><code>Also</code>：当前 Unit 激活（enable）时，会被同时激活的其他 Unit</li>
</ul>
<p>Unit 配置文件的完整字段清单，请参考<a href="https://www.freedesktop.org/software/systemd/man/systemd.unit.html">官方文档</a>。</p>
<h4 id="target">Target<a hidden class="anchor" aria-hidden="true" href="#target">#</a></h4>
<p>启动计算机的时候，需要启动大量的 Unit。如果每一次启动，都要一一写明本次启动需要哪些 Unit，显然非常不方便。Systemd 的解决方案就是 Target。</p>
<p>简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于&quot;状态点&quot;，启动某个 Target 就好比启动到某种状态。</p>
<p>传统的<code>init</code>启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 查看当前系统的所有 Target</span>
$ systemctl list-unit-files --type<span style="color:#f92672">=</span>target
<span style="color:#75715e"># 查看一个 Target 包含的所有 Unit</span>
$ systemctl list-dependencies multi-user.target
<span style="color:#75715e"># 查看启动时的默认 Target，在这个组里的所有服务，都将开机启动。</span>
$ systemctl get-default
<span style="color:#75715e"># 设置启动时的默认 Target</span>
$ sudo systemctl set-default multi-user.target
<span style="color:#75715e"># 切换 Target 时，默认不关闭前一个 Target 启动的进程，</span>
<span style="color:#75715e"># systemctl isolate 命令改变这种行为，</span>
<span style="color:#75715e"># 关闭前一个 Target 里面所有不属于后一个 Target 的进程</span>
$ sudo systemctl isolate multi-user.target
</code></pre></div><p>Target 与 传统 RunLevel 的对应关系如下。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">Traditional runlevel      New target name     Symbolically linked to...

Runlevel <span style="color:#ae81ff">0</span>           |    runlevel0.target -&gt; poweroff.target
Runlevel <span style="color:#ae81ff">1</span>           |    runlevel1.target -&gt; rescue.target
Runlevel <span style="color:#ae81ff">2</span>           |    runlevel2.target -&gt; multi-user.target
Runlevel <span style="color:#ae81ff">3</span>           |    runlevel3.target -&gt; multi-user.target
Runlevel <span style="color:#ae81ff">4</span>           |    runlevel4.target -&gt; multi-user.target
Runlevel <span style="color:#ae81ff">5</span>           |    runlevel5.target -&gt; graphical.target
Runlevel <span style="color:#ae81ff">6</span>           |    runlevel6.target -&gt; reboot.target
</code></pre></div><p>它与<code>init</code>进程的主要差别如下。</p>
<p><strong>（1）默认的 RunLevel</strong>（在<code>/etc/inittab</code>文件设置）现在被默认的 Target 取代，位置是<code>/etc/systemd/system/default.target</code>，通常符号链接到<code>graphical.target</code>（图形界面）或者<code>multi-user.target</code>（多用户命令行）。</p>
<p><strong>（2）启动脚本的位置</strong>，以前是<code>/etc/init.d</code>目录，符号链接到不同的 RunLevel 目录 （比如<code>/etc/rc3.d</code>、<code>/etc/rc5.d</code>等），现在则存放在<code>/lib/systemd/system</code>和<code>/etc/systemd/system</code>目录。</p>
<p><strong>（3）配置文件的位置</strong>，以前<code>init</code>进程的配置文件是<code>/etc/inittab</code>，各种服务的配置文件存放在<code>/etc/sysconfig</code>目录。现在的配置文件主要存放在<code>/lib/systemd</code>目录，在<code>/etc/systemd</code>目录里面的修改可以覆盖原始设置。</p>
<h4 id="日志管理">日志管理<a hidden class="anchor" aria-hidden="true" href="#日志管理">#</a></h4>
<p>Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用<code>journalctl</code>一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是<code>/etc/systemd/journald.conf</code>。</p>
<p><code>journalctl</code>功能强大，用法非常多。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 查看所有日志（默认情况下 ，只保存本次启动的日志）</span>
$ sudo journalctl

<span style="color:#75715e"># 查看内核日志（不显示应用日志）</span>
$ sudo journalctl -k

<span style="color:#75715e"># 查看系统本次启动的日志</span>
$ sudo journalctl -b
$ sudo journalctl -b -0

<span style="color:#75715e"># 查看上一次启动的日志（需更改设置）</span>
$ sudo journalctl -b -1

<span style="color:#75715e"># 查看指定时间的日志</span>
$ sudo journalctl --since<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;2012-10-30 18:17:16&#34;</span>
$ sudo journalctl --since <span style="color:#e6db74">&#34;20 min ago&#34;</span>
$ sudo journalctl --since yesterday
$ sudo journalctl --since <span style="color:#e6db74">&#34;2015-01-10&#34;</span> --until <span style="color:#e6db74">&#34;2015-01-11 03:00&#34;</span>
$ sudo journalctl --since 09:00 --until <span style="color:#e6db74">&#34;1 hour ago&#34;</span>

<span style="color:#75715e"># 显示尾部的最新10行日志</span>
$ sudo journalctl -n

<span style="color:#75715e"># 显示尾部指定行数的日志</span>
$ sudo journalctl -n <span style="color:#ae81ff">20</span>

<span style="color:#75715e"># 实时滚动显示最新日志</span>
$ sudo journalctl -f

<span style="color:#75715e"># 查看指定服务的日志</span>
$ sudo journalctl /usr/lib/systemd/systemd

<span style="color:#75715e"># 查看指定进程的日志</span>
$ sudo journalctl _PID<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>

<span style="color:#75715e"># 查看某个路径的脚本的日志</span>
$ sudo journalctl /bin/bash

<span style="color:#75715e"># 查看指定用户的日志</span>
$ sudo journalctl _UID<span style="color:#f92672">=</span><span style="color:#ae81ff">33</span> --since today

<span style="color:#75715e"># 查看某个 Unit 的日志</span>
$ sudo journalctl -u nginx.service
$ sudo journalctl -u nginx.service --since today

<span style="color:#75715e"># 实时滚动显示某个 Unit 的最新日志</span>
$ sudo journalctl -u nginx.service -f

<span style="color:#75715e"># 合并显示多个 Unit 的日志</span>
$ journalctl -u nginx.service -u php-fpm.service --since today

<span style="color:#75715e"># 查看指定优先级（及其以上级别）的日志，共有8级</span>
<span style="color:#75715e"># 0: emerg</span>
<span style="color:#75715e"># 1: alert</span>
<span style="color:#75715e"># 2: crit</span>
<span style="color:#75715e"># 3: err</span>
<span style="color:#75715e"># 4: warning</span>
<span style="color:#75715e"># 5: notice</span>
<span style="color:#75715e"># 6: info</span>
<span style="color:#75715e"># 7: debug</span>
$ sudo journalctl -p err -b

<span style="color:#75715e"># 日志默认分页输出，--no-pager 改为正常的标准输出</span>
$ sudo journalctl --no-pager

<span style="color:#75715e"># 以 JSON 格式（单行）输出</span>
$ sudo journalctl -b -u nginx.service -o json

<span style="color:#75715e"># 以 JSON 格式（多行）输出，可读性更好</span>
$ sudo journalctl -b -u nginx.serviceqq -o json-pretty

<span style="color:#75715e"># 显示日志占据的硬盘空间</span>
$ sudo journalctl --disk-usage

<span style="color:#75715e"># 指定日志文件占据的最大空间</span>
$ sudo journalctl --vacuum-size<span style="color:#f92672">=</span>1G

<span style="color:#75715e"># 指定日志文件保存多久</span>
$ sudo journalctl --vacuum-time<span style="color:#f92672">=</span>1years
</code></pre></div><h3 id="定时器示例httpwwwruanyifengcomblog201803systemd-timerhtml"><a href="http://www.ruanyifeng.com/blog/2018/03/systemd-timer.html">定时器示例</a><a hidden class="anchor" aria-hidden="true" href="#定时器示例httpwwwruanyifengcomblog201803systemd-timerhtml">#</a></h3>
<h4 id="邮件脚本">邮件脚本<a hidden class="anchor" aria-hidden="true" href="#邮件脚本">#</a></h4>
<p>先写一个发邮件的脚本<code>mail.sh</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">#!/usr/bin/env bash
</span><span style="color:#75715e"></span>echo <span style="color:#e6db74">&#34;This is the body&#34;</span> | /usr/bin/mail -s <span style="color:#e6db74">&#34;Subject&#34;</span> someone@example.com
</code></pre></div><p>上面代码的<code>someone@example.com</code>，请替换成你的邮箱地址。</p>
<p>然后，执行这个脚本。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ bash mail.sh
</code></pre></div><p>执行后，你应该就会收到一封邮件，标题为<code>Subject</code>。</p>
<p>如果你的 Linux 系统不能发邮件，建议安装 <a href="http://tombuntu.com/index.php/2008/10/21/sending-email-from-your-system-with-ssmtp/">ssmtp</a> 或者 <a href="https://wiki.archlinux.org/index.php/msmtp">msmtp</a>。另外，<code>mail</code>命令的用法，可以参考<a href="https://www.binarytides.com/linux-mail-command-examples/">这里</a>。</p>
<h4 id="service-单元">Service 单元<a hidden class="anchor" aria-hidden="true" href="#service-单元">#</a></h4>
<p>Service 单元就是所要执行的任务，比如发送邮件就是一种 Service。</p>
<p>新建 Service 非常简单，就是在<code>/usr/lib/systemd/system</code>目录里面新建一个文件，比如<code>mytimer.service</code>文件，你可以写入下面的内容。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>Unit<span style="color:#f92672">]</span>
Description<span style="color:#f92672">=</span>MyTimer

<span style="color:#f92672">[</span>Service<span style="color:#f92672">]</span>
ExecStart<span style="color:#f92672">=</span>/bin/bash /path/to/mail.sh
</code></pre></div><p>注意，定义的时候，所有路径都要写成绝对路径，比如<code>bash</code>要写成<code>/bin/bash</code>，否则 Systemd 会找不到。</p>
<p>现在，启动这个 Service。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo systemctl start mytimer.service
</code></pre></div><p>如果一切正常，你应该就会收到一封邮件。</p>
<h4 id="timer-单元">Timer 单元<a hidden class="anchor" aria-hidden="true" href="#timer-单元">#</a></h4>
<p>Service 单元只是定义了如何执行任务，要定时执行这个 Service，还必须定义 Timer 单元。</p>
<p><code>/usr/lib/systemd/system</code>目录里面，新建一个<code>mytimer.timer</code>文件，写入下面的内容。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>Unit<span style="color:#f92672">]</span>
Description<span style="color:#f92672">=</span>Runs mytimer every hour

<span style="color:#f92672">[</span>Timer<span style="color:#f92672">]</span>
OnUnitActiveSec<span style="color:#f92672">=</span>1h
Unit<span style="color:#f92672">=</span>mytimer.service

<span style="color:#f92672">[</span>Install<span style="color:#f92672">]</span>
WantedBy<span style="color:#f92672">=</span>multi-user.target
</code></pre></div><p>这个 Timer 单元文件分成几个部分。</p>
<p><code>[Timer]</code>部分定制定时器。Systemd 提供以下一些字段。</p>
<ul>
<li><code>OnActiveSec</code>：定时器生效后，多少时间开始执行任务</li>
<li><code>OnBootSec</code>：系统启动后，多少时间开始执行任务</li>
<li><code>OnStartupSec</code>：Systemd 进程启动后，多少时间开始执行任务</li>
<li><code>OnUnitActiveSec</code>：该单元上次执行后，等多少时间再次执行</li>
<li><code>OnUnitInactiveSec</code>： 定时器上次关闭后多少时间，再次执行</li>
<li><code>OnCalendar</code>：基于绝对时间，而不是相对时间执行</li>
<li><code>AccuracySec</code>：如果因为各种原因，任务必须推迟执行，推迟的最大秒数，默认是60秒</li>
<li><code>Unit</code>：真正要执行的任务，默认是同名的带有<code>.service</code>后缀的单元</li>
<li><code>Persistent</code>：如果设置了该字段，即使定时器到时没有启动，也会自动执行相应的单元</li>
<li><code>WakeSystem</code>：如果系统休眠，是否自动唤醒系统</li>
</ul>
<p>上面的脚本里面，<code>OnUnitActiveSec=1h</code>表示一小时执行一次任务。其他的写法还有<code>OnCalendar=*-*-* 02:00:00</code>表示每天凌晨两点执行，<code>OnCalendar=Mon *-*-* 02:00:00</code>表示每周一凌晨两点执行，具体请参考<a href="http://www.jinbuguo.com/systemd/systemd.time.html">中文手册</a>。</p>
<h3 id="system-timehttpswikiarchlinuxorgtitlesystem_time_e7ae80e4bd93e4b8ade69687"><a href="https://wiki.archlinux.org/title/System_time_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">System time</a><a hidden class="anchor" aria-hidden="true" href="#system-timehttpswikiarchlinuxorgtitlesystem_time_e7ae80e4bd93e4b8ade69687">#</a></h3>
<p>一个操作系统通过如下内容确定时间：时间数值、时间标准、时区和夏令时调节(中国已经废止)。本文分别介绍各个部分的定义及如何设置他们。要维护准确的系统时间，请参考 <a href="https://wiki.archlinux.org/title/Network_Time_Protocol_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">网络时间协议</a> 一文。</p>
<h4 id="硬件时钟和系统时钟">硬件时钟和系统时钟<a hidden class="anchor" aria-hidden="true" href="#硬件时钟和系统时钟">#</a></h4>
<p>系统用两个时钟保存时间：硬件时钟和系统时钟。</p>
<p><strong>硬件时钟</strong>(即实时时钟 RTC 或 CMOS 时钟)仅能保存：年、月、日、时、分、秒这些时间数值，无法保存时间标准(UTC 或 localtime)和是否使用夏令时调节。</p>
<p><strong>系统时钟</strong>(即软件时间) 与硬件时间分别维护，保存了：时间、时区和夏令时设置。Linux 内核保存为自 UTC 时间 1970 年1月1日经过的秒数。初始系统时钟是从硬件时间计算得来，计算时会考虑<code>/etc/adjtime</code>的设置。系统启动之后，系统时钟与硬件时钟独立运行，Linux 通过时钟中断计数维护系统时钟。</p>
<p>如果系统时间是按 32 位整数保存的，最大只能记到 2038 年，所以 32 位 Linux 系统将在 2038 年停止工作。</p>
<p>大部分操作系统的时间管理包括如下方面：</p>
<ul>
<li>启动时根据硬件时钟设置系统时间</li>
<li>运行时通过时间同步联网校正时间</li>
<li>关机时根据系统时间设置硬件时间</li>
</ul>
<h4 id="读取时间">读取时间<a hidden class="anchor" aria-hidden="true" href="#读取时间">#</a></h4>
<p>下面命令可以获得硬件时间和系统时间(硬件时钟按 localtime 显示):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ timedatectl
               Local time: Thu 2022-01-27 10:35:26 CST
           Universal time: Thu 2022-01-27 02:35:26 UTC
                 RTC time: Thu 2022-01-27 02:35:26    
                Time zone: Asia/Shanghai <span style="color:#f92672">(</span>CST, +0800<span style="color:#f92672">)</span> 
System clock synchronized: yes                        
              NTP service: active                     
          RTC in local TZ: no 
</code></pre></div><p><strong>名词解释</strong>：</p>
<ul>
<li>CST：(China Standard Time,UTC+8:00) 中国沿海时间(北京时间)</li>
<li>UTC：(Universal Time Coordinated,UTC) 世界协调时间</li>
<li>GMT：(Greenwich Mean Time ,GMT）格林威治时间</li>
<li>LT：(locale time）本地时间</li>
</ul>
<h4 id="设置时间">设置时间<a hidden class="anchor" aria-hidden="true" href="#设置时间">#</a></h4>
<p>设置系统时间的本地时间：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># timedatectl set-time &#34;yyyy-MM-dd hh:mm:ss&#34;</span>
</code></pre></div><p>例如:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># timedatectl set-time &#34;2014-05-26 11:13:54&#34;</span>
</code></pre></div><p>设置时间为2014年，5月26日，11时13分54秒。</p>
<h4 id="时间标准">时间标准<a hidden class="anchor" aria-hidden="true" href="#时间标准">#</a></h4>
<p>时间表示有两个标准：<strong>localtime</strong> 和 <strong>UTC</strong>(<strong>C</strong>oordinated <strong>U</strong>niversal <strong>T</strong>ime) 。UTC 是与时区无关的全球时间标准。尽管概念上有差别，UTC 和 GMT (格林威治时间) 是一样的。localtime 标准则依赖于当前时区。</p>
<p>时间标准由操作系统设定，Windows 默认使用 localtime，Mac OS 默认使用 UTC，而 UNIX 系列的操作系统两者都有。使用 Linux 时，最好将硬件时钟设置为 UTC 标准，并在所有操作系统中使用。这样 Linux 系统就可以自动调整夏令时设置，而如果使用 localtime 标准那么系统时间不会根据夏令时自动调整。</p>
<p>通过如下命令可以检查当前设置，<strong>systemd</strong> 默认硬件时钟为协调世界时（UTC）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ timedatectl status | grep local
RTC in local TZ: no
</code></pre></div><p>硬件时间可以用 <code>hwclock</code> 命令设置，将硬件时间设置为 localtime：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># timedatectl set-local-rtc 1</span>
</code></pre></div><p>硬件时间设置成 UTC：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># timedatectl set-local-rtc 0</span>
</code></pre></div><p>上述命令会自动生成<code>/etc/adjtime</code>，无需单独设置。</p>
<p><strong>注意：</strong> 如果不存在 <code>/etc/adjtime</code>，systemd 会假定硬件时间按 UTC 设置。</p>
<p>系统启动装入 rtc 驱动时可能会根据系统时钟设置硬件时钟。是否设置依赖于平台、内核版本和内核编译选项。如果进行了设置，此时会假定硬件时钟为 UTC 标准，<code>/sys/class/rtc/rtcN/hctosys</code>(N=0,1,2,..) 会设置成 1。后面 systemd 会根据<code>/etc/adjtime</code>重新设置。</p>
<p>如果设置成本地时间，处理夏令时有些麻烦。如果夏令时调整发生在关机时，下次启动时时间会出现问题（<a href="https://www.cl.cam.ac.uk/~mgk25/mswish/ut-rtc.html">更多信息</a>）。最新的内核直接从实时时钟芯片（RTC）读取时间，不使用 <code>hwclock</code>，内核把从 RTC 读取的时间当作 UTC 处理。所以如果硬件时间是地方时，系统启动一开始识别的时间是错误的，之后很快会进行矫正。这可能导致一些问题（尤其是时间倒退时）。</p>
<h4 id="windows-系统使用-utc">Windows 系统使用 UTC<a hidden class="anchor" aria-hidden="true" href="#windows-系统使用-utc">#</a></h4>
<p>如果同时安装了 Windows 操作系统（<a href="https://devblogs.microsoft.com/oldnewthing/2004/09/02">默认使用地方时</a>），那么一般 RTC 会被设置为地方时。Windows 其实也能处理 UTC，需要<a href="https://wiki.archlinux.org/title/System_time_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#Windows_%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8_UTC">修改注册表</a>。建议让 Windows 使用 UTC，而非让 Linux 使用地方时。Windows 使用 UTC 后，请记得禁用 Windows 的时间同步功能，以防 Windows 错误设置硬件时间。如上文所说，Linux 可以使用<a href="https://wiki.archlinux.org/title/NTP_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">NTP服务</a>来在线同步硬件时钟。</p>
<p>使用 <code>regedit</code>,新建如下 DWORD 值，并将其值设为十六进制的 <code>1</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cmd" data-lang="cmd">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\TimeZoneInformation\RealTimeIsUniversal
</code></pre></div><p>也可以用管理员权限启动命令行来完成：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cmd" data-lang="cmd">reg add <span style="color:#e6db74">&#34;HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\TimeZoneInformation&#34;</span> /v RealTimeIsUniversal /d 1 /t REG_DWORD /f
</code></pre></div><p>如果以上操作不起作用，并且你使用的是 Windows 64位系统，将 <code>DWORD</code> 修改为 <code>QWORD</code>。</p>
<p>如果 Windows 要求根据夏令时更新时钟，可以允许。时钟仍然是 UTC，仅是显示时间会改变。</p>
<p>设置时间标准后需要重新设置硬件时间和系统时间。</p>
<p>如果你有时间偏移问题，再次设置你的时区:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># timedatectl set-timezone Asia/Shanghai</span>
</code></pre></div><h4 id="utc-在ubuntu的设置">UTC 在Ubuntu的设置<a hidden class="anchor" aria-hidden="true" href="#utc-在ubuntu的设置">#</a></h4>
<p>Ubuntu及其衍生发行版会在安装时检测计算机上是否存在Windows，若存在则会默认使用localtime。这是为了让Windows用户能够在不修改注册表的情况下，在Ubuntu内看到正确的时间。</p>
<p>要改变这种行为，请参见上面的内容。</p>
<h4 id="时区">时区<a hidden class="anchor" aria-hidden="true" href="#时区">#</a></h4>
<p>检查当前时区：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ timedatectl status
</code></pre></div><p>显示可用时区：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ timedatectl list-timezones
</code></pre></div><p>修改时区：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># timedatectl set-timezone &lt;Zone&gt;/&lt;SubZone&gt;</span>
</code></pre></div><p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># timedatectl set-timezone Asia/Shanghai</span>
</code></pre></div><p>此命令会创建一个<code>/etc/localtime</code>软链接，指向<code>/usr/share/zoneinfo/</code>中的时区文件，如果手动创建此链接请确保是相对链接而不是绝对链接。</p>
<p><strong>注意：</strong> 如果pre-systemd配置的/etc/timezone仍然存在于你的系统，你可以放心地将其删除，因为它不再使用。</p>
<h4 id="时钟偏移">时钟偏移<a hidden class="anchor" aria-hidden="true" href="#时钟偏移">#</a></h4>
<p>最能代表“真实时间”的是<a href="https://en.wikipedia.org/wiki/International_Atomic_Time">国际原子时钟</a>)，所有的时钟都是有误差的。电子时钟的时间是不准的，但是一般有固定的偏移。这种于基值的差称为“time skew”或“时间偏移”。用 <code>hwclock</code> 设置硬件时间时，会计算每天偏移的秒数。偏移值是原硬件时间与新设置硬件时间的差，并且考虑上次硬件时间设置时的偏移。新的偏移值会在设置时钟时写到文件 <code>/etc/adjtime</code> 。</p>
<p><strong>注意：</strong> 如果硬件时间值与原值的差小于 24 小时，偏移量不会重新计算，因为时间过短，无法精确设置偏移。</p>
<p>如果硬件时钟总是过快或过慢，可能是计算了错误的偏移值。硬件时钟设置错误或者时间标准与其他操作系统不一致导致。删除文件 <code>/etc/adjtime</code> 可以删除偏移值，然后设置正确的硬件时钟和系统时钟，并检查时间标准是不是设置正确。</p>
<p><strong>注意：</strong> 使用 Systemd 时，要使用 <code>/etc/adjtime</code>中的 drift 值(即无法或不想使用 NTP 时); 需要每次调用 <code>hwclock --adjust</code>命令，可以通过 cron 任务实现。</p>
<p>提高系统时间精度的方法有：</p>
<p><a href="https://wiki.archlinux.org/title/NTP">NTP</a> 可以通过网络时间协议同步 Linux 系统的时间。NTP 也会修正中断频率和每秒滴答数以减少时间偏移。并且每隔 11 分钟同步一次硬件时钟。</p>
<h4 id="时钟同步">时钟同步<a hidden class="anchor" aria-hidden="true" href="#时钟同步">#</a></h4>
<p><a href="https://en.wikipedia.org/wiki/Network_Time_Protocol">网络时间协议</a> (NTP) 是一个通过包交换和可变延迟网络来同步计算机系统时间的协议。下列为这个协议的实现：</p>
<ul>
<li><a href="https://wiki.archlinux.org/title/Network_Time_Protocol_daemon">NTP 守护进程</a>是这个协议的<a href="https://en.wikipedia.org/wiki/reference_implementation">参考实现</a>，推荐用于时间服务器。它也可以调节中断频率和每秒滴答次数以减少系统时钟误差，使得硬件时钟每隔11秒重新同步一次。</li>
<li><strong>sntp</strong> 是一个 <a href="https://en.wikipedia.org/wiki/Network_Time_Protocol#SNTP">SNTP</a> 客户端。它取代了 <em>ntpdate</em> ，并被推荐用于非服务器环境。</li>
<li><a href="https://wiki.archlinux.org/title/Systemd-timesyncd">systemd-timesyncd</a> 是一个简单的 <a href="https://en.wikipedia.org/wiki/Network_Time_Protocol#SNTP">SNTP</a> 守护进程。它只实现了客户端，专用于从远程服务器查询时间，更适用于绝大部分安装的情形。</li>
<li><a href="https://wiki.archlinux.org/title/OpenNTPD">OpenNTPD</a> 是 OpenBSD 项目的一部分，同时实现了客户端和服务器。</li>
<li><a href="https://wiki.archlinux.org/title/Chrony">Chrony</a> 是一个客户端和服务器，更适合漫游，是为不能始终保持在线的系统而特别设计。</li>
<li>ntpclient 是简单的命令行 NTP 客户端</li>
</ul>
<h2 id="防火墙httpswwwlinuxprobecombasic-learning-08html"><a href="https://www.linuxprobe.com/basic-learning-08.html">防火墙</a><a hidden class="anchor" aria-hidden="true" href="#防火墙httpswwwlinuxprobecombasic-learning-08html">#</a></h2>
<p>保障数据的安全性是继保障数据的可用性之后最为重要的一项工作。防火墙作为公网与内网之间的保护屏障，在保障数据的安全性方面起着至关重要的作用。</p>
<h3 id="防火墙管理工具">防火墙管理工具<a hidden class="anchor" aria-hidden="true" href="#防火墙管理工具">#</a></h3>
<p>众所周知，相较于企业内网，外部的公网环境更加恶劣，罪恶丛生。在公网与企业内网之间充当保护屏障的防火墙虽然有软件或硬件之分，但主要功能都是依据策略对穿越防火墙自身的流量进行过滤。就像家里安装的防盗门一样，目的是保护亲人和财产安全。防火墙策略可以基于流量的源目地址、端口号、协议、应用等信息来定制，然后防火墙使用预先定制的策略规则监控出入的流量，若流量与某一条策略规则相匹配，则执行相应的处理，反之则丢弃。这样一来，就能够保证仅有合法的流量在企业内网和外部公网之间流动了。</p>
<p><img loading="lazy" src="/Distributions/BAE585ACE7BD91E4B88EE58685E7BD91E4B98BE997B4E79A84E4BF9DE68AA4E5B18FE99A9C-2.jpg" alt=""  />
</p>
<p>从RHEL 7系统开始，firewalld防火墙正式取代了iptables防火墙。对于接触Linux系统比较早或学习过RHEL 5/6系统的读者来说，当他们发现曾经掌握的知识在RHEL 7/8中不再适用，需要全新学习firewalld时，难免会有抵触心理。其实，iptables与firewalld都不是真正的防火墙，它们都只是用来定义防火墙策略的防火墙管理工具而已；或者说，它们只是一种服务。iptables服务会把配置好的防火墙策略交由内核层面的netfilter网络过滤器来处理，而firewalld服务则是把配置好的防火墙策略交由内核层面的nftables包过滤框架来处理。换句话说，当前在Linux系统中其实存在多个防火墙管理工具，旨在方便运维人员管理Linux系统中的防火墙策略，我们只需要配置妥当其中的一个就足够了。</p>
<p>虽然这些工具各有优劣，但它们在防火墙策略的配置思路上是保持一致的。大家甚至可以不用完全掌握本章介绍的内容，只要在这多个防火墙管理工具中任选一款并将其学透，就足以满足日常的工作需求了。</p>
<h3 id="iptables">Iptables<a hidden class="anchor" aria-hidden="true" href="#iptables">#</a></h3>
<p>在早期的Linux系统中，默认使用的是iptables防火墙管理服务来配置防火墙。尽管新型的firewalld防火墙管理服务已经被投入使用多年，但是大量的企业在生产环境中依然出于各种原因而继续使用iptables。</p>
<h4 id="策略与规则链">策略与规则链<a hidden class="anchor" aria-hidden="true" href="#策略与规则链">#</a></h4>
<p>防火墙会按照从上到下的顺序来读取配置的策略规则，在找到匹配项后就立即结束匹配工作并去执行匹配项中定义的行为（即放行或阻止）。如果在读取完所有的策略规则之后没有匹配项，就去执行默认的策略。一般而言，防火墙策略规则的设置有两种：“通”（即放行）和“堵”（即阻止）。当防火墙的默认策略为拒绝时（堵），就要设置允许规则（通），否则谁都进不来；如果防火墙的默认策略为允许，就要设置拒绝规则，否则谁都能进来，防火墙也就失去了防范的作用。</p>
<p>iptables服务把用于处理或过滤流量的策略条目称之为规则，多条规则可以组成一个规则链，而规则链则依据数据包处理位置的不同进行分类，具体如下：</p>
<ul>
<li>在进行路由选择前处理数据包（PREROUTING）；</li>
<li>处理流入的数据包（INPUT）；</li>
<li>处理流出的数据包（OUTPUT）；</li>
<li>处理转发的数据包（FORWARD）；</li>
<li>在进行路由选择后处理数据包（POSTROUTING）。</li>
</ul>
<p>一般来说，从内网向外网发送的流量一般都是可控且良性的，因此使用最多的就是INPUT规则链，该规则链可以增大黑客人员从外网入侵内网的难度。</p>
<p>比如在您居住的社区内，物业管理公司有两条规定：禁止小商小贩进入社区；各种车辆在进入社区时都要登记。显而易见，这两条规定应该是用于社区的正门的（流量必须经过的地方），而不是每家每户的防盗门上。根据前面提到的防火墙策略的匹配顺序，可能会存在多种情况。比如，来访人员是小商小贩，则直接会被物业公司的保安拒之门外，也就无须再对车辆进行登记。如果来访人员乘坐一辆汽车进入社区正门，则“禁止小商小贩进入社区”的第一条规则就没有被匹配到，因此按照顺序匹配第二条策略，即需要对车辆进行登记。如果是社区居民要进入正门，则这两条规定都不会匹配到，因此会执行默认的放行策略。</p>
<p>但是，仅有策略规则还不能保证社区的安全，保安还应该知道采用什么样的动作来处理这些匹配的流量，比如“允许”“拒绝”“登记”“不理它”。这些动作对应到iptables服务的术语中分别是ACCEPT（允许流量通过）、REJECT（拒绝流量通过）、LOG（记录日志信息）、DROP（拒绝流量通过）。“允许流量通过”和“记录日志信息”都比较好理解，这里需要着重讲解的是REJECT和DROP的不同点。就DROP来说，它是直接将流量丢弃而且不响应；REJECT则会在拒绝流量后再回复一条“信息已经收到，但是被扔掉了”信息，从而让流量发送方清晰地看到数据被拒绝的响应信息。</p>
<p>下面举一个例子，让各位读者更直观地理解这两个拒绝动作的不同之处。比如有一天您正在家里看电视，突然听到有人敲门，您透过防盗门的猫眼一看是推销商品的，便会在不需要的情况下开门并拒绝他们（REJECT）。但如果看到的是债主带了十几个小弟来讨债，此时不仅要拒绝开门，还要默不作声，伪装成自己不在家的样子（DROP）。</p>
<p>当把Linux系统中的防火墙策略设置为REJECT动作后，流量发送方会看到端口不可达的响应：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># ping -c 4 192.168.10.10</span>
PING 192.168.10.10 <span style="color:#f92672">(</span>192.168.10.10<span style="color:#f92672">)</span> 56<span style="color:#f92672">(</span>84<span style="color:#f92672">)</span> bytes of data.
From 192.168.10.10 icmp_seq<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> Destination Port Unreachable
From 192.168.10.10 icmp_seq<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span> Destination Port Unreachable
From 192.168.10.10 icmp_seq<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span> Destination Port Unreachable
From 192.168.10.10 icmp_seq<span style="color:#f92672">=</span><span style="color:#ae81ff">4</span> Destination Port Unreachable
--- 192.168.10.10 ping statistics ---
<span style="color:#ae81ff">4</span> packets transmitted, <span style="color:#ae81ff">0</span> received, +4 errors, <span style="color:#ae81ff">100</span> packet loss, time 3002ms
</code></pre></div><p>而把Linux系统中的防火墙策略修改成DROP动作后，流量发送方会看到响应超时的提醒。但是流量发送方无法判断流量是被拒绝，还是接收方主机当前不在线：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># ping -c 4 192.168.10.10</span>
PING 192.168.10.10 <span style="color:#f92672">(</span>192.168.10.10<span style="color:#f92672">)</span> 56<span style="color:#f92672">(</span>84<span style="color:#f92672">)</span> bytes of data.

--- 192.168.10.10 ping statistics ---
<span style="color:#ae81ff">4</span> packets transmitted, <span style="color:#ae81ff">0</span> received, <span style="color:#ae81ff">100</span> packet loss, time 3000ms
</code></pre></div><h4 id="基本的命令参数httpswwwjianshucomp5a604b4ef342"><a href="https://www.jianshu.com/p/5a604b4ef342">基本的命令参数</a><a hidden class="anchor" aria-hidden="true" href="#基本的命令参数httpswwwjianshucomp5a604b4ef342">#</a></h4>
<p>iptables是一款基于<a href="https://www.linuxcool.com/">命令</a>行的防火墙策略管理工具，具有大量的参数，学习难度较大。好在对于日常的防火墙策略配置来讲，大家无须深入了解诸如“四表五链”的理论概念，只需要掌握常用的参数并做到灵活搭配即可，这就足以应对日常工作了。</p>
<p>根据OSI七层模型的定义，iptables属于数据链路层的服务，所以可以根据流量的源地址、目的地址、传输协议、服务类型等信息进行匹配；一旦匹配成功，iptables就会根据策略规则所预设的动作来处理这些流量。另外，再次提醒一下，防火墙策略规则的匹配顺序是从上到下的，因此要把较为严格、优先级较高的策略规则放到前面，以免发生错误。表8-1总结归纳了常用的iptables命令参数。再次强调，无须死记硬背这些参数，只需借助下面的实验来理解掌握即可。</p>
<h5 id="命令格式">命令格式<a hidden class="anchor" aria-hidden="true" href="#命令格式">#</a></h5>
<pre tabindex="0"><code>iptables [-t table] COMMAND chain CRETIRIA -j ACTION
</code></pre><ul>
<li>-t table ：filter/nat/mangle</li>
<li>COMMAND：定义如何对规则进行管理</li>
<li>chain：指定你接下来的规则到底是在哪个链上操作的，当定义策略的时候，是可以省略的</li>
<li>CRETIRIA:指定匹配标准</li>
<li>-j ACTION :指定如何进行处理</li>
</ul>
<h5 id="参数说明">参数说明<a hidden class="anchor" aria-hidden="true" href="#参数说明">#</a></h5>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>-F</td>
<td>清空规则链</td>
<td>iptables -F</td>
</tr>
<tr>
<td>-L</td>
<td>查看规则链</td>
<td>iptables -L</td>
</tr>
<tr>
<td>-A</td>
<td>追加规则</td>
<td>iptables -A INPUT</td>
</tr>
<tr>
<td>-D</td>
<td>删除规则</td>
<td>iptables -D INPUT 1</td>
</tr>
<tr>
<td>-R</td>
<td>修改规则</td>
<td>iptable -R INPUT 1 -s 192.168.120.0 -j DROP</td>
</tr>
<tr>
<td>-I</td>
<td>在头部插入规则</td>
<td>iptables -I INPUT 1 &ndash;dport 80 -j ACCEPT</td>
</tr>
<tr>
<td>-L</td>
<td>查看规则</td>
<td>iptables -L INPUT</td>
</tr>
<tr>
<td>-N</td>
<td>新的规则</td>
<td>iptables -N allowed</td>
</tr>
<tr>
<td>-V</td>
<td>查看iptables版本</td>
<td>iptables -V</td>
</tr>
<tr>
<td>-p</td>
<td>协议（tcp/udp/icmp）</td>
<td>iptables -A INPUT -p tcp</td>
</tr>
<tr>
<td>-s</td>
<td>匹配原地址，加&quot; ! &ldquo;表示除这个IP外</td>
<td>iptables -A INPUT -s 192.168.1.1</td>
</tr>
<tr>
<td>-d</td>
<td>匹配目的地址</td>
<td>iptables -A INPUT -d 192.168.12.1</td>
</tr>
<tr>
<td>&ndash;sport</td>
<td>匹配源端口流入的数据</td>
<td>iptables -A INPUT -p tcp &ndash;sport 22</td>
</tr>
<tr>
<td>&ndash;dport</td>
<td>匹配目的端口流出的数据</td>
<td>iptables -A INPUT -p tcp &ndash;dport 22</td>
</tr>
<tr>
<td>-i</td>
<td>匹配入口网卡流入的数据</td>
<td>iptables -A INPUT -i eth0</td>
</tr>
<tr>
<td>-o</td>
<td>匹配出口网卡流出的数据</td>
<td>iptables -A FORWARD -o eth0</td>
</tr>
<tr>
<td>-j</td>
<td>要进行的处理动作:DROP(丢弃)，REJECT(拒绝)，ACCEPT(接受)，SANT(基于原地址的转换)</td>
<td>iptable -A INPUT 1 -s 192.168.120.0 -j DROP</td>
</tr>
<tr>
<td>&ndash;to-source</td>
<td>指定SANT转换后的地址</td>
<td>iptables -t nat -A POSTROUTING -s 192.168.10.0/24 -j SANT &ndash;to-source 172.16.100.1</td>
</tr>
<tr>
<td>-t</td>
<td>表名(raw、mangle、nat、filter)</td>
<td>iptables -t nat</td>
</tr>
<tr>
<td>-m</td>
<td>使用扩展模块来进行数据包的匹配(multiport/tcp/state/addrtype)</td>
<td>iptables -m multiport</td>
</tr>
</tbody>
</table>
<h5 id="动作说明">动作说明<a hidden class="anchor" aria-hidden="true" href="#动作说明">#</a></h5>
<p>处理动作除了 ACCEPT、REJECT、DROP、REDIRECT 和 MASQUERADE 以外，还多出 LOG、ULOG、DNAT、SNAT、MIRROR、QUEUE、RETURN、TOS、TTL、MARK 等，其中某些处理动作不会中断过滤程序，某些处理动作则会中断同一规则链的过滤，并依照前述流程继续进行下一个规则链的过滤，一直到堆栈中的规则检查完毕为止。透过这种机制所带来的好处是，我们可以进行复杂、多重的封包过滤，简单的说，iptables 可以进行纵横交错式的过滤（tables）而非链状过滤（chains）。</p>
<table>
<thead>
<tr>
<th>动作</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>ACCEPT</td>
<td>将封包放行，进行完此处理动作后，将不再比对其它规则，直接跳往下一个规则链（nat:postrouting）</td>
<td></td>
</tr>
<tr>
<td>REJECT</td>
<td>拦阻该封包，并传送封包通知对方，可以传送的封包有几个选择：ICMP port-unreachable、ICMP echo-reply 或是 tcp-reset（这个封包会要求对方关闭联机），进行完此处理动作后，将不再比对其它规则，直接 中断过滤程序。</td>
<td>iptables -A FORWARD -p TCP &ndash;dport 22 -j REJECT &ndash;reject-with tcp-reset</td>
</tr>
<tr>
<td>DROP</td>
<td>丢弃封包不予处理，进行完此处理动作后，将不再比对其它规则，直接中断过滤程序。</td>
<td></td>
</tr>
<tr>
<td>REDIRECT</td>
<td>将封包重新导向到另一个端口（PNAT），进行完此处理动作后，将 会继续比对其它规则。 这个功能可以用来实作通透式 porxy 或用来保护 web 服务器。</td>
<td>iptables -t nat -A PREROUTING -p tcp &ndash;dport 80 -j REDIRECT &ndash;to-ports 8080</td>
</tr>
<tr>
<td>MASQUERADE</td>
<td>改写封包来源 IP 为防火墙 NIC IP，可以指定 port 对应的范围，进行完此处理动作后，直接跳往下一个规则链（mangle:postrouting）。这个功能与 SNAT 略有不同，当进行 IP 伪装时，不需指定要伪装成哪个 IP，IP 会从网卡直接读取，当使用拨接连线时，IP 通常是由 ISP 公司的 DHCP 服务器指派的，这个时候 MASQUERADE 特别有用。</td>
<td>iptables -t nat -A POSTROUTING -p TCP -j MASQUERADE &ndash;to-ports 1024-31000</td>
</tr>
<tr>
<td>LOG</td>
<td>将封包相关讯息纪录在 /var/log 中，详细位置请查阅 /etc/syslog.conf 组态档，进行完此处理动作后，将会继续比对其它规则。</td>
<td>iptables -A INPUT -p tcp -j LOG &ndash;log-prefix &ldquo;INPUT packets&rdquo;</td>
</tr>
<tr>
<td>SNAT</td>
<td>改写封包来源 IP 为某特定 IP 或 IP 范围，可以指定 port 对应的范围，进行完此处理动作后，将直接跳往下一个规则链（mangle:postrouting）。</td>
<td>iptables -t nat -A POSTROUTING -p tcp-o eth0 -j SNAT &ndash;to-source 194.236.50.155-194.236.50.160:1024-32000</td>
</tr>
<tr>
<td>DNAT</td>
<td>改写封包目的地 IP 为某特定 IP 或 IP 范围，可以指定 port 对应的范围，进行完此处理动作后，将会直接跳往下一个规则链（filter:input 或 filter:forward）。</td>
<td>iptables -t nat -A PREROUTING -p tcp -d 15.45.23.67 &ndash;dport 80 -j DNAT &ndash;to-destination 192.168.1.1-192.168.1.10:80-100</td>
</tr>
<tr>
<td>MIRROR</td>
<td>镜射封包，也就是将来源 IP 与目的地 IP 对调后，将封包送回，进行完此处理动作后，将会中断过滤程序。</td>
<td></td>
</tr>
<tr>
<td>QUEUE</td>
<td>中断过滤程序，将封包放入队列，交给其它程序处理。透过自行开发的处理程序，可以进行其它应用，例如：计算联机费用……等。</td>
<td></td>
</tr>
<tr>
<td>RETURN</td>
<td>结束在目前规则链中的过滤程序，返回主规则链继续过滤，如果把自订规则链看成是一个子程序，那么这个动作，就相当于提早结束子程序并返回到主程序中。</td>
<td></td>
</tr>
<tr>
<td>MARK</td>
<td>将封包标上某个代号，以便提供作为后续过滤的条件判断依据，进行完此处理动作后，将会继续比对其它规则。</td>
<td>iptables -t mangle -A PREROUTING -p tcp &ndash;dport 22 -j MARK &ndash;set-mark 2</td>
</tr>
</tbody>
</table>
<h5 id="例子">例子<a hidden class="anchor" aria-hidden="true" href="#例子">#</a></h5>
<p><strong>1．在iptables命令后添加-L参数查看已有的防火墙规则链。</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># iptables -L</span>
Chain INPUT <span style="color:#f92672">(</span>policy ACCEPT<span style="color:#f92672">)</span>
target     prot opt source               destination         
ACCEPT     udp  --  anywhere             anywhere             udp dpt:domain
ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:domain
ACCEPT     udp  --  anywhere             anywhere             udp dpt:bootps
ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:bootps

Chain FORWARD <span style="color:#f92672">(</span>policy ACCEPT<span style="color:#f92672">)</span>
target     prot opt source               destination         
ACCEPT     all  --  anywhere             192.168.122.0/24     ctstate RELATED,ESTABLISHED
ACCEPT     all  --  192.168.122.0/24     anywhere            
ACCEPT     all  --  anywhere             anywhere            
REJECT     all  --  anywhere             anywhere             reject-with icmp-port-unreachable
REJECT     all  --  anywhere             anywhere             reject-with icmp-port-unreachable

Chain OUTPUT <span style="color:#f92672">(</span>policy ACCEPT<span style="color:#f92672">)</span>
target     prot opt source               destination         
ACCEPT     udp  --  anywhere             anywhere             udp dpt:bootpc
</code></pre></div><p><strong>2．在iptables命令后添加-F参数清空已有的防火墙规则链。</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># iptables -F</span>
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># iptables -L</span>
Chain INPUT <span style="color:#f92672">(</span>policy ACCEPT<span style="color:#f92672">)</span>
target     prot opt source               destination         

Chain FORWARD <span style="color:#f92672">(</span>policy ACCEPT<span style="color:#f92672">)</span>
target     prot opt source               destination         

Chain OUTPUT <span style="color:#f92672">(</span>policy ACCEPT<span style="color:#f92672">)</span>
target     prot opt source               destination
</code></pre></div><p><strong>3．把INPUT规则链的默认策略设置为拒绝。</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># iptables -P INPUT DROP</span>
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># iptables -L</span>
Chain INPUT <span style="color:#f92672">(</span>policy DROP<span style="color:#f92672">)</span>
target     prot opt source               destination         

Chain FORWARD <span style="color:#f92672">(</span>policy ACCEPT<span style="color:#f92672">)</span>
target     prot opt source               destination         

Chain OUTPUT <span style="color:#f92672">(</span>policy ACCEPT<span style="color:#f92672">)</span>
target     prot opt source               destination
</code></pre></div><p>前文提到，防火墙策略规则的设置无非有两种方式：“通”和“堵”。当把INPUT链设置为默认拒绝后，就要往里面写入允许策略了，否则所有流入的数据包都会被默认拒绝掉。同学们需要留意的是，规则链的默认策略拒绝动作只能是DROP，而不能是REJECT。</p>
<p><strong>4．向INPUT链中添加允许ICMP流量进入的策略规则。</strong></p>
<p>在日常运维工作中，经常会使用ping命令来检查对方主机是否在线，而向防火墙的INPUT规则链中添加一条允许ICMP流量进入的策略规则就默认允许了这种ping命令检测行为。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># iptables -I INPUT -p icmp -j ACCEPT</span>
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># ping -c 4 192.168.10.10</span>
PING 192.168.10.10 <span style="color:#f92672">(</span>192.168.10.10<span style="color:#f92672">)</span> 56<span style="color:#f92672">(</span>84<span style="color:#f92672">)</span> bytes of data.
<span style="color:#ae81ff">64</span> bytes from 192.168.10.10: icmp_seq<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> ttl<span style="color:#f92672">=</span><span style="color:#ae81ff">64</span> time<span style="color:#f92672">=</span>0.154 ms
<span style="color:#ae81ff">64</span> bytes from 192.168.10.10: icmp_seq<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span> ttl<span style="color:#f92672">=</span><span style="color:#ae81ff">64</span> time<span style="color:#f92672">=</span>0.041 ms
<span style="color:#ae81ff">64</span> bytes from 192.168.10.10: icmp_seq<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span> ttl<span style="color:#f92672">=</span><span style="color:#ae81ff">64</span> time<span style="color:#f92672">=</span>0.038 ms
<span style="color:#ae81ff">64</span> bytes from 192.168.10.10: icmp_seq<span style="color:#f92672">=</span><span style="color:#ae81ff">4</span> ttl<span style="color:#f92672">=</span><span style="color:#ae81ff">64</span> time<span style="color:#f92672">=</span>0.046 ms

--- 192.168.10.10 ping statistics ---
<span style="color:#ae81ff">4</span> packets transmitted, <span style="color:#ae81ff">4</span> received, <span style="color:#ae81ff">0</span> packet loss, time 104ms
rtt min/avg/max/mdev <span style="color:#f92672">=</span> 0.038/0.069/0.154/0.049 ms
</code></pre></div><p><strong>5．删除INPUT规则链中刚刚加入的那条策略（允许ICMP流量），并把默认策略设置为允许。</strong></p>
<p>使用-F参数会清空已有的所有防火墙策略；使用-D参数可以删除某一条指定的策略，因此更加安全和准确。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># iptables -D INPUT 1</span>
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># iptables -P INPUT ACCEPT</span>
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># iptables -L</span>
Chain INPUT <span style="color:#f92672">(</span>policy ACCEPT<span style="color:#f92672">)</span>
target     prot opt source               destination         

Chain FORWARD <span style="color:#f92672">(</span>policy ACCEPT<span style="color:#f92672">)</span>
target     prot opt source               destination         

Chain OUTPUT <span style="color:#f92672">(</span>policy ACCEPT<span style="color:#f92672">)</span>
target     prot opt source               destination
</code></pre></div><p><strong>6．将INPUT规则链设置为只允许指定网段的主机访问本机的22端口，拒绝来自其他所有主机的流量。</strong></p>
<p>要对某台主机进行匹配，可直接写出它的IP地址；如需对网段进行匹配，则需要写为子网掩码的形式（比如192.168.10.0/24）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># iptables -I INPUT -s 192.168.10.0/24 -p tcp --dport 22 -j ACCEPT</span>
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># iptables -A INPUT -p tcp --dport 22 -j REJECT</span>
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># iptables -L</span>
Chain INPUT <span style="color:#f92672">(</span>policy ACCEPT<span style="color:#f92672">)</span>
target prot opt source destination
 ACCEPT tcp -- 192.168.10.0/24 anywhere tcp dpt:ssh 
 REJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachable
………………省略部分输出信息………………
</code></pre></div><p>再次重申，防火墙策略规则是按照从上到下的顺序匹配的，因此一定要把允许动作放到拒绝动作前面，否则所有的流量就将被拒绝掉，从而导致任何主机都无法访问我们的服务。另外，这里提到的22号端口是ssh服务使用的。</p>
<p>在设置完上述INPUT规则链之后，使用IP地址在192.168.10.0/24网段内的主机访问服务器（即前面提到的设置了INPUT规则链的主机）的22端口，效果如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@Client A ~<span style="color:#f92672">]</span><span style="color:#75715e"># ssh 192.168.10.10</span>
The authenticity of host <span style="color:#e6db74">&#39;192.168.10.10 (192.168.10.10)&#39;</span> can<span style="color:#e6db74">&#39;t be established.
</span><span style="color:#e6db74">ECDSA key fingerprint is SHA256:5d52kZi1la/FJK4v4jibLBZhLqzGqbJAskZiME6ZXpQ.
</span><span style="color:#e6db74">Are you sure you want to continue connecting (yes/no)? yes
</span><span style="color:#e6db74">Warning: Permanently added &#39;</span>192.168.10.10<span style="color:#e6db74">&#39; (ECDSA) to the list of known hosts.
</span><span style="color:#e6db74">root@192.168.10.10&#39;</span>s password: 此处输入服务器密码
Activate the web console with: systemctl enable --now cockpit.socket

Last login: Wed Jan <span style="color:#ae81ff">20</span> 16:30:28 <span style="color:#ae81ff">2021</span> from 192.168.10.1
</code></pre></div><p>然后，再使用IP地址在192.168.20.0/24网段内的主机访问服务器的22端口（虽网段不同，但已确认可以相互通信），效果如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@Client B ~<span style="color:#f92672">]</span><span style="color:#75715e"># ssh 192.168.10.10</span>
Connecting to 192.168.10.10:22...
Could not connect to <span style="color:#e6db74">&#39;192.168.10.10&#39;</span> <span style="color:#f92672">(</span>port 22<span style="color:#f92672">)</span>: Connection failed.
</code></pre></div><p>由上可以看到，提示连接请求被拒绝了（Connection failed）。</p>
<p><strong>7．向INPUT规则链中添加拒绝所有人访问本机12345端口的策略规则。</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># iptables -I INPUT -p tcp --dport 12345 -j REJECT</span>
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># iptables -I INPUT -p udp --dport 12345 -j REJECT</span>
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># iptables -L</span>
Chain INPUT <span style="color:#f92672">(</span>policy ACCEPT<span style="color:#f92672">)</span>
target prot opt source destination 
 REJECT udp -- anywhere anywhere udp dpt:italk reject-with icmp-port-unreachable
 REJECT tcp -- anywhere anywhere tcp dpt:italk reject-with icmp-port-unreachable
 ACCEPT tcp -- 192.168.10.0/24 anywhere tcp dpt:ssh
 REJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachable
………………省略部分输出信息………………
</code></pre></div><p><strong>8．向INPUT规则链中添加拒绝192.168.10.5主机访问本机80端口（Web服务）的策略规则。</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># iptables -I INPUT -p tcp -s 192.168.10.5 --dport 80 -j REJECT</span>
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># iptables -L</span>
Chain INPUT <span style="color:#f92672">(</span>policy ACCEPT<span style="color:#f92672">)</span>
target prot opt source destination 
 REJECT tcp -- 192.168.10.5 anywhere tcp dpt:http reject-with icmp-port-unreachable
 REJECT udp -- anywhere anywhere udp dpt:italk reject-with icmp-port-unreachable
 REJECT tcp -- anywhere anywhere tcp dpt:italk reject-with icmp-port-unreachable
 ACCEPT tcp -- 192.168.10.0/24 anywhere tcp dpt:ssh
 REJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachable
………………省略部分输出信息………………
</code></pre></div><p><strong>9．向INPUT规则链中添加拒绝所有主机访问本机1000～1024端口的策略规则。</strong></p>
<p>前面在添加防火墙策略时，使用的是-I参数，它默认会把规则添加到最上面的位置，因此优先级是最高的。如果工作中需要添加一条最后“兜底”的规则，那就用-A参数吧。这两个参数的效果差别还是很大的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># iptables -A INPUT -p tcp --dport 1000:1024 -j REJECT</span>
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># iptables -A INPUT -p udp --dport 1000:1024 -j REJECT</span>
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># iptables -L</span>
Chain INPUT <span style="color:#f92672">(</span>policy ACCEPT<span style="color:#f92672">)</span>
target prot opt source destination 
 REJECT tcp -- 192.168.10.5 anywhere tcp dpt:http reject-with icmp-port-unreachable
 REJECT udp -- anywhere anywhere udp dpt:italk reject-with icmp-port-unreachable
 REJECT tcp -- anywhere anywhere tcp dpt:italk reject-with icmp-port-unreachable
 ACCEPT tcp -- 192.168.10.0/24 anywhere tcp dpt:ssh
 REJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachable
 REJECT tcp -- anywhere anywhere tcp dpts:cadlock2:1024 reject-with icmp-port-unreachable
 REJECT udp -- anywhere anywhere udp dpts:cadlock2:1024 reject-with icmp-port-unreachable
………………省略部分输出信息………………
</code></pre></div><p>有关iptables命令的知识讲解到此就结束了，大家是不是意犹未尽？考虑到Linux防火墙的发展趋势，大家只要能把上面的实例吸收消化，就可以完全搞定日常的iptables配置工作了。但是请特别注意，使用iptables命令配置的防火墙规则默认会在系统下一次重启时失效，如果想让配置的防火墙策略永久生效，还要执行保存命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># iptables-save </span>
<span style="color:#75715e"># Generated by xtables-save v1.8.2 on Wed Jan 20 16:56:27 2021</span>
………………省略部分输出信息………………
</code></pre></div><p>对了，如果公司服务器是5/6/7版本的话，对应的保存命令应该是：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># service iptables save</span>
iptables: Saving firewall rules to /etc/sysconfig/iptables: <span style="color:#f92672">[</span> OK <span style="color:#f92672">]</span>
</code></pre></div><h4 id="基本概念httpswikiarchlinuxorgtitleiptables_e7ae80e4bd93e4b8ade69687e59fbae69cace6a682e5bfb5"><a href="https://wiki.archlinux.org/title/iptables_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">基本概念</a><a hidden class="anchor" aria-hidden="true" href="#基本概念httpswikiarchlinuxorgtitleiptables_e7ae80e4bd93e4b8ade69687e59fbae69cace6a682e5bfb5">#</a></h4>
<p><em>iptables</em> 是一个配置 Linux 内核 防火墙 的命令行工具，是 <a href="https://en.wikipedia.org/wiki/Netfilter">Netfilter</a> 项目的一部分。术语 <em>iptables</em> 也经常代指该内核级防火墙。iptables 可以直接配置，也可以通过许多 控制台 和 图形化 前端配置。iptables 用于 <a href="https://en.wikipedia.org/wiki/Ipv4">ipv4</a>，<em>ip6tables</em> 用于 <a href="https://wiki.archlinux.org/title/IPv6">IPv6</a>。<em>iptables</em>和<em>ip6tables</em> 拥有相同的语法，但是有些特别的选项，对 IPv4 和 IPv6 有些不同的。</p>
<p>iptables 可以检测、修改、转发、重定向和丢弃 IPv4 数据包。过滤 IPv4 数据包的代码已经内置于内核中，并且按照不同的目的被组织成 <strong>表</strong> 的集合。表 由一组预先定义的 <strong>链</strong> 组成，链 包含遍历顺序<strong>规则</strong>。每一条规则包含一个谓词的潜在匹配和相应的动作（称为 <strong>目标</strong>），如果谓词为真，该动作会被执行。也就是说条件匹配。iptables 是用户工具，允许用户使用 链 和 规则。很多新手面对复杂的 linux IP 路由时总是感到气馁，但是，实际上最常用的一些应用案例（NAT 或者基本的网络防火墙）并不是很复杂。</p>
<p><img loading="lazy" src="/Distributions/tables_traverse.jpg" alt=""  />
</p>
<p>理解 iptables 如何工作的关键是上面这张图。图中在上面的小写字母代表 <strong>表</strong>，在下面的大写字母代表 <strong>链</strong>。<strong>从任何网络端口</strong> 进来的每一个 IP 数据包都要从上到下的穿过这张图。一种常见的错误认知是认为 iptables 对从内部端口进入的数据包和从面向互联网端口进入的数据包采取不同的处理方式，相反，iptabales 对从任何端口进入的数据包都会采取相同的处理方式。可以定义规则使 iptables 采取不同的方式对待从不同端口进入的数据包。当然一些数据包是用于本地进程的，因此在图中表现为从顶端进入，到 <code>&lt;Local Process&gt;</code> 停止，而另一些数据包是由本地进程生成的，因此在图中表现为从 <code>&lt;Local Process&gt;</code> 发出，一直向下穿过该流程图。一份关于该流程图如何工作的详细解释请参考<a href="https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html#TRAVERSINGOFTABLES">这里</a>。</p>
<p>在大多数使用情况下都不会用到 <strong>raw</strong>，<strong>mangle</strong> 和 <strong>security</strong> 表。</p>
<h5 id="表tables">表(Tables)<a hidden class="anchor" aria-hidden="true" href="#表tables">#</a></h5>
<p>ptables 包含 5 张表（tables）:</p>
<ol>
<li><code>raw</code> 用于配置数据包，<code>raw</code> 中的数据包不会被系统跟踪。</li>
<li><code>filter</code> 是用于存放所有与防火墙相关操作的默认表。</li>
<li><code>nat</code> 用于 <a href="https://en.wikipedia.org/wiki/Network_address_translation">网络地址转换</a>（例如：端口转发）。</li>
<li><code>mangle</code> 用于对特定数据包的修改（参考 <a href="https://en.wikipedia.org/wiki/Mangled_packet">损坏数据包</a>）。</li>
<li><code>security</code> 用于 <a href="https://wiki.archlinux.org/title/Security#Mandatory_access_control">强制访问控制</a> 网络规则（例如： SELinux &ndash; 详细信息参考 <a href="https://lwn.net/Articles/267140/">该文章</a>）。</li>
</ol>
<p>大部分情况仅需要使用 <strong>filter</strong> 和 <strong>nat</strong>。其他表用于更复杂的情况——包括多路由和路由判定——已经超出了本文介绍的范围。</p>
<h5 id="链chains">链(Chains)<a hidden class="anchor" aria-hidden="true" href="#链chains">#</a></h5>
<p>表由链组成，链是一些按顺序排列的规则的列表。默认的 <code>filter</code> 表包含 <code>INPUT</code>， <code>OUTPUT</code> 和 <code>FORWARD</code> 3条内建的链，这3条链作用于数据包过滤过程中的不同时间点，如该上面流程图所示。<code>nat</code> 表包含<code>PREROUTING</code>， <code>POSTROUTING</code> 和 <code>OUTPUT</code> 链。</p>
<p>使用 <a href="https://man.archlinux.org/man/iptables.8">iptables(8)</a> 查看其他表中内建链的描述。</p>
<p>默认情况下，任何链中都没有规则。可以向链中添加自己想用的规则。链的默认规则通常设置为 <code>ACCEPT</code>，如果想确保任何包都不能通过规则集，那么可以重置为 <code>DROP</code>。默认的规则总是在一条链的最后生效，所以在默认规则生效前数据包需要通过所有存在的规则。</p>
<p>用户可以加入自己定义的链，从而使规则集更有效并且易于修改。如何使用自定义链请参考 <a href="https://wiki.archlinux.org/title/Simple_stateful_firewall">Simple stateful firewall</a>。</p>
<h5 id="规则-rules">规则 (Rules)<a hidden class="anchor" aria-hidden="true" href="#规则-rules">#</a></h5>
<p>数据包的过滤基于 <strong>规则</strong>。<strong>规则</strong>由一个<em>目标</em>（数据包包匹配所有条件后的动作）和很多<em>匹配</em>（导致该规则可以应用的数据包所满足的条件）指定。一个规则的典型匹配事项是数据包进入的端口（例如：eth0 或者 eth1）、数据包的类型（ICMP, TCP, 或者 UDP）和数据包的目的端口。</p>
<p>目标使用 <code>-j</code> 或者 <code>--jump</code> 选项指定。目标可以是用户定义的链（例如，如果条件匹配，跳转到之后的用户定义的链，继续处理）、一个内置的特定目标或者是一个目标扩展。内置目标是 <code>ACCEPT</code>， <code>DROP</code>， <code>QUEUE</code> 和 <code>RETURN</code>，目标扩展是 <code>REJECT</code> 和 <code>LOG</code>。如果目标是内置目标，数据包的命运会立刻被决定并且在当前表的数据包的处理过程会停止。如果目标是用户定义的链，并且数据包成功穿过第二条链，目标将移动到原始链中的下一个规则。目标扩展可以被<em>终止</em>（像内置目标一样）或者<em>不终止</em>（像用户定义链一样）。详细信息参阅 <a href="https://man.archlinux.org/man/iptables-extensions.8">iptables-extensions(8)</a>。</p>
<h5 id="遍历链traversing-chains">遍历链(Traversing Chains)<a hidden class="anchor" aria-hidden="true" href="#遍历链traversing-chains">#</a></h5>
<p>该流程图描述链了在任何接口上收到的网络数据包是按照怎样的顺序穿过表的交通管制链。第一个路由策略包括决定数据包的目的地是本地主机（这种情况下，数据包穿过 <code>INPUT</code> 链），还是其他主机（数据包穿过 <code>FORWARD</code> 链）；中间的路由策略包括决定给传出的数据包使用那个源地址、分配哪个接口；最后一个路由策略存在是因为先前的 mangle 与 nat 链可能会改变数据包的路由信息。数据包通过路径上的每一条链时，链中的每一条规则按顺序匹配；无论何时匹配了一条规则，相应的 target/jump 动作将会执行。最常用的3个 target 是 <code>ACCEPT</code>, <code>DROP</code> ,或者 jump 到用户自定义的链。内置的链有默认的策略，但是用户自定义的链没有默认的策略。在 jump 到的链中，若每一条规则都不能提供完全匹配，那么数据包像下面这张图片描述的一样返回到调用链。在任何时候，若 <code>DROP</code> target 的规则实现完全匹配，那么被匹配的数据包会被丢弃，不会进行进一步处理。如果一个数据包在链中被 <code>ACCEPT</code>，那么它也会被所有的父链 <code>ACCEPT</code>，并且不再遍历其他父链。然而，要注意的是，数据包还会以正常的方式继续遍历其他表中的其他链。</p>
<p><img loading="lazy" src="/Distributions/table_subtraverse.jpg" alt=""  />
</p>
<h5 id="模块modules">模块(Modules)<a hidden class="anchor" aria-hidden="true" href="#模块modules">#</a></h5>
<p>有许多模块可以用来扩展 iptables，例如 connlimit, conntrack, limit 和 recent。这些模块增添了功能，可以进行更复杂的过滤。</p>
<h3 id="firewalld">Firewalld<a hidden class="anchor" aria-hidden="true" href="#firewalld">#</a></h3>
<p>RHEL 8系统中集成了多款防火墙管理工具，其中firewalld（Dynamic Firewall Manager of Linux systems，Linux系统的动态防火墙管理器）服务是默认的防火墙配置管理工具，它拥有基于CLI（命令行界面）和基于GUI（图形用户界面）的两种管理方式。</p>
<p>相较于传统的防火墙管理配置工具，firewalld支持动态更新技术并加入了区域（zone）的概念。简单来说，区域就是firewalld预先准备了几套防火墙策略集合（策略模板），用户可以根据生产场景的不同而选择合适的策略集合，从而实现防火墙策略之间的快速切换。例如，我们有一台笔记本电脑，每天都要在办公室、咖啡厅和家里使用。按常理来讲，这三者的安全性按照由高到低的顺序来排列，应该是家庭、公司办公室、咖啡厅。当前，我们希望为这台笔记本电脑制定如下防火墙策略规则：在家中允许访问所有服务；在办公室内仅允许访问文件共享服务；在咖啡厅仅允许上网浏览。在以往，我们需要频繁地手动设置防火墙策略规则，而现在只需要预设好区域集合，然后轻点鼠标就可以自动切换了，从而极大地提升了防火墙策略的应用效率。firewalld中常见的区域名称（默认为public）以及相应的策略规则如表所示。</p>
<table>
<thead>
<tr>
<th>区域</th>
<th>默认规则策略</th>
</tr>
</thead>
<tbody>
<tr>
<td>trusted</td>
<td>允许所有的数据包</td>
</tr>
<tr>
<td>home</td>
<td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、mdns、ipp-client、amba-client与dhcpv6-client服务相关，则允许流量</td>
</tr>
<tr>
<td>internal</td>
<td>等同于home区域</td>
</tr>
<tr>
<td>work</td>
<td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、ipp-client与dhcpv6-client服务相关，则允许流量</td>
</tr>
<tr>
<td>public</td>
<td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、dhcpv6-client服务相关，则允许流量</td>
</tr>
<tr>
<td>external</td>
<td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量</td>
</tr>
<tr>
<td>dmz</td>
<td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量</td>
</tr>
<tr>
<td>block</td>
<td>拒绝流入的流量，除非与流出的流量相关</td>
</tr>
<tr>
<td>drop</td>
<td>拒绝流入的流量，除非与流出的流量相关</td>
</tr>
</tbody>
</table>
<h4 id="终端管理工具">终端管理工具<a hidden class="anchor" aria-hidden="true" href="#终端管理工具">#</a></h4>
<p>命令行终端是一种极富效率的工作方式，firewall-cmd是firewalld防火墙配置管理工具的CLI（命令行界面）版本。它的参数一般都是以“长格式”来提供的。大家不要一听到长格式就头大，因为RHEL 8系统支持部分命令的参数补齐，其中就包含这条命令（很酷吧）。也就是说，现在除了能用Tab键自动补齐命令或文件名等内容之外，还可以用Tab键来补齐表所示的长格式参数。这太棒了！</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>&ndash;get-default-zone</td>
<td>查询默认的区域名称</td>
</tr>
<tr>
<td>&ndash;set-default-zone=&lt;区域名称&gt;</td>
<td>设置默认的区域，使其永久生效</td>
</tr>
<tr>
<td>&ndash;get-zones</td>
<td>显示可用的区域</td>
</tr>
<tr>
<td>&ndash;get-services</td>
<td>显示预先定义的服务</td>
</tr>
<tr>
<td>&ndash;get-active-zones</td>
<td>显示当前正在使用的区域与网卡名称</td>
</tr>
<tr>
<td>&ndash;add-source=</td>
<td>将源自此IP或子网的流量导向指定的区域</td>
</tr>
<tr>
<td>&ndash;remove-source=</td>
<td>不再将源自此IP或子网的流量导向某个指定区域</td>
</tr>
<tr>
<td>&ndash;add-interface=&lt;网卡名称&gt;</td>
<td>将源自该网卡的所有流量都导向某个指定区域</td>
</tr>
<tr>
<td>&ndash;change-interface=&lt;网卡名称&gt;</td>
<td>将某个网卡与区域进行关联</td>
</tr>
<tr>
<td>&ndash;list-all</td>
<td>显示当前区域的网卡配置参数、资源、端口以及服务等信息</td>
</tr>
<tr>
<td>&ndash;list-all-zones</td>
<td>显示所有区域的网卡配置参数、资源、端口以及服务等信息</td>
</tr>
<tr>
<td>&ndash;add-service=&lt;服务名&gt;</td>
<td>设置默认区域允许该服务的流量</td>
</tr>
<tr>
<td>&ndash;add-port=&lt;端口号/协议&gt;</td>
<td>设置默认区域允许该端口的流量</td>
</tr>
<tr>
<td>&ndash;remove-service=&lt;服务名&gt;</td>
<td>设置默认区域不再允许该服务的流量</td>
</tr>
<tr>
<td>&ndash;remove-port=&lt;端口号/协议&gt;</td>
<td>设置默认区域不再允许该端口的流量</td>
</tr>
<tr>
<td>&ndash;reload</td>
<td>让“永久生效”的配置规则立即生效，并覆盖当前的配置规则</td>
</tr>
<tr>
<td>&ndash;panic-on</td>
<td>开启应急状况模式</td>
</tr>
<tr>
<td>&ndash;panic-off</td>
<td>关闭应急状况模式</td>
</tr>
</tbody>
</table>
<p>与Linux系统中其他的防火墙策略配置工具一样，使用firewalld配置的防火墙策略默认为运行时（Runtime）模式，又称为当前生效模式，而且会随着系统的重启而失效。如果想让配置策略一直存在，就需要使用永久（Permanent）模式了，方法就是在用firewall-cmd命令正常设置防火墙策略时添加&ndash;permanent参数，这样配置的防火墙策略就可以永久生效了。但是，永久生效模式有一个“不近人情”的特点，就是使用它设置的策略只有在系统重启之后才能自动生效。如果想让配置的策略立即生效，需要手动执行firewall-cmd &ndash;reload命令。</p>
<p>接下来的实验都很简单，但是提醒大家一定要仔细查看使用的是Runtime模式还是Permanent模式。如果不关注这个细节，就算正确配置了防火墙策略，也可能无法达到预期的效果。</p>
<p><strong>1．查看firewalld服务当前所使用的区域。</strong></p>
<p>这是一步非常重要的操作。在配置防火墙策略前，必须查看当前生效的是哪个区域，否则配置的防火墙策略将不会立即生效。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --get-default-zone</span>
public
</code></pre></div><p><strong>2．查询指定网卡在firewalld服务中绑定的区域。</strong></p>
<p>在生产环境中，服务器大多不止有一块网卡。一般来说，充当网关的服务器有两块网卡，一块对公网，另外一块对内网，那么这两块网卡在审查流量时所用的策略肯定也是不一致的。因此，可以根据网卡针对的流量来源，为网卡绑定不同的区域，实现对防火墙策略的灵活管控。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --get-zone-of-interface=ens160</span>
public
</code></pre></div><p><strong>3．把网卡默认区域修改为external，并在系统重启后生效。</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --permanent --zone=external --change-interface=ens160</span>
The interface is under control of NetworkManager, setting zone to <span style="color:#e6db74">&#39;external&#39;</span>.
success
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --permanent --get-zone-of-interface=ens160</span>
external
</code></pre></div><p><strong>4．把firewalld服务的默认区域设置为public。</strong></p>
<p>默认区域也叫全局配置，指的是对所有网卡都生效的配置，优先级较低。在下面的代码中可以看到，当前默认区域为public，而ens160网卡的区域为external。此时便是以网卡的区域名称为准。</p>
<p>通俗来说，默认区域就是一种通用的政策。例如，食堂为所有人准备了一次性餐具，而环保主义者则会自己携带碗筷。如果您自带了碗筷，就可以用自己的；反之就用食堂统一提供的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --set-default-zone=public</span>
Warning: ZONE_ALREADY_SET: public
success
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --get-default-zone </span>
public
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --get-zone-of-interface=ens160</span>
external
</code></pre></div><p><strong>5．启动和关闭firewalld防火墙服务的应急状况模式。</strong></p>
<p>如果想在1s的时间内阻断一切网络连接，有什么好办法呢？大家下意识地会说：“拔掉网线！”这是一个物理级别的高招。但是，如果人在北京，服务器在异地呢？panic紧急模式在这个时候就派上用场了。使用&ndash;panic-on参数会立即切断一切网络连接，而使用&ndash;panic-off则会恢复网络连接。切记，紧急模式会切断一切网络连接，因此在远程管理服务器时，在按下回车键前一定要三思。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --panic-on</span>
success
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --panic-off</span>
success
</code></pre></div><p><strong>6．查询SSH和HTTPS协议的流量是否允许放行。</strong></p>
<p>在工作中可以不使用&ndash;zone参数指定区域名称，firewall-cmd命令会自动依据默认区域进行查询，从而减少用户输入量。但是，如果默认区域与网卡所绑定的不一致时，就会发生冲突，因此规范写法的zone参数是一定要加的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --zone=public --query-service=ssh</span>
yes
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --zone=public --query-service=https</span>
no
</code></pre></div><p><strong>7．把HTTPS协议的流量设置为永久允许放行，并立即生效。</strong></p>
<p>默认情况下进行的修改都属于Runtime模式，即当前生效而重启后失效，因此在工作和考试中尽量避免使用。而在使用&ndash;permanent参数时，则是当前不会立即看到效果，而在重启或重新加载后方可生效。于是，在添加了允许放行HTTPS流量的策略后，查询当前模式策略，发现依然是不允许放行HTTPS协议的流量：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --permanent --zone=public --add-service=https</span>
success
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --zone=public --query-service=https</span>
no
</code></pre></div><p>不想重启服务器的话，就用&ndash;reload参数吧：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --reload</span>
success
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --zone=public --query-service=https</span>
yes
</code></pre></div><p><strong>8．把HTTP协议的流量设置为永久拒绝，并立即生效。</strong></p>
<p>由于在默认情况下HTTP协议的流量就没有被允许，所以会有“Warning: NOT_ENABLED: http”这样的提示信息，因此对实际操作没有影响。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --permanent --zone=public --remove-service=http</span>
Warning: NOT_ENABLED: http
success
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --reload </span>
success
</code></pre></div><p><strong>9．把访问8080和8081端口的流量策略设置为允许，但仅限当前生效。</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --zone=public --add-port=8080-8081/tcp</span>
success
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --zone=public --list-ports</span>
8080-8081/tcp
</code></pre></div><p><strong>10．把原本访问本机888端口的流量转发到22端口，要且求当前和长期均有效。</strong></p>
<p>SSH远程控制协议是基于TCP/22端口传输控制指令的，如果想让用户通过其他端口号也能访问ssh服务，就可以试试端口转发技术了。通过这项技术，新的端口号在收到用户请求后会自动转发到原本服务的端口上，使得用户能够通过新的端口访问到原本的服务。</p>
<p>来举个例子帮助大家理解。假设小强是电子厂的工人，他喜欢上了三号流水线上的工人小花，但不好意思表白，于是写了一封情书并交给门卫张大爷，希望由张大爷转交给小花。这样一来，情书（信息）的传输由从小强到小花，变成了小强到张大爷再到小花，情书（信息）依然能顺利送达。</p>
<p>使用firewall-cmd命令实现端口转发的格式有点长，这里为大家总结好了：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">firewall-cmd --permanent --zone<span style="color:#f92672">=</span>&lt;区域&gt; --add-forward-port<span style="color:#f92672">=</span>port<span style="color:#f92672">=</span>&lt;源端口号&gt;:proto<span style="color:#f92672">=</span>&lt;协议&gt;:toport<span style="color:#f92672">=</span>&lt;目标端口号&gt;:toaddr<span style="color:#f92672">=</span>&lt;目标IP地址&gt;
</code></pre></div><p>上述命令中的目标IP地址一般是服务器本机的IP地址：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --permanent --zone=public --add-forward-port=port=888:proto=tcp:toport=22:toaddr=192.168.10.10</span>
success
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --reload</span>
success
</code></pre></div><p>在客户端使用ssh命令尝试访问192.168.10.10主机的888端口，访问成功：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@client A ~<span style="color:#f92672">]</span><span style="color:#75715e"># ssh -p 888 192.168.10.10</span>
The authenticity of host <span style="color:#e6db74">&#39;[192.168.10.10]:888 ([192.168.10.10]:888)&#39;</span> can<span style="color:#e6db74">&#39;t be established.
</span><span style="color:#e6db74">ECDSA key fingerprint is b8:25:88:89:5c:05:b6:dd:ef:76:63:ff:1a:54:02:1a.
</span><span style="color:#e6db74">Are you sure you want to continue connecting (yes/no)? yes
</span><span style="color:#e6db74">Warning: Permanently added &#39;</span><span style="color:#f92672">[</span>192.168.10.10<span style="color:#f92672">]</span>:888<span style="color:#e6db74">&#39; (ECDSA) to the list of known hosts.
</span><span style="color:#e6db74">root@192.168.10.10&#39;</span>s password:此处输入远程root管理员的密码
Last login: Sun Jul <span style="color:#ae81ff">19</span> 21:43:48 <span style="color:#ae81ff">2021</span> from 192.168.10.10
</code></pre></div><p><strong>11．富规则的设置。</strong></p>
<p>富规则也叫复规则，表示更细致、更详细的防火墙策略配置，它可以针对系统服务、端口号、源地址和目标地址等诸多信息进行更有针对性的策略配置。它的优先级在所有的防火墙策略中也是最高的。比如，我们可以在firewalld服务中配置一条富规则，使其拒绝192.168.10.0/24网段的所有用户访问本机的ssh服务（22端口）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --permanent --zone=public --add-rich-rule=&#34;rule family=&#34;ipv4&#34; source address=&#34;192.168.10.0/24&#34; service name=&#34;ssh&#34; reject&#34;</span>
success
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># firewall-cmd --reload</span>
success
</code></pre></div><p>在客户端使用ssh命令尝试访问192.168.10.10主机的ssh服务（22端口）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@client A ~<span style="color:#f92672">]</span><span style="color:#75715e"># ssh 192.168.10.10</span>
Connecting to 192.168.10.10:22...
Could not connect to <span style="color:#e6db74">&#39;192.168.10.10&#39;</span> <span style="color:#f92672">(</span>port 22<span style="color:#f92672">)</span>: Connection failed.
</code></pre></div><h4 id="图形管理工具">图形管理工具<a hidden class="anchor" aria-hidden="true" href="#图形管理工具">#</a></h4>
<p>在各种版本的Linux系统中，几乎没有能让刘遄老师欣慰并推荐的图形化工具，但是firewall-config做到了。它是firewalld防火墙配置管理工具的GUI（图形用户界面）版本，几乎可以实现所有以命令行来执行的操作。毫不夸张地说，即使读者没有扎实的Linux命令基础，也完全可以通过它来妥善配置RHEL 8中的防火墙策略。</p>
<p>成功 firewall-config 安装后，其工具的界面如图所示：</p>
<p><img loading="lazy" src="/Distributions/firewall-configE79A84E59BBEE5BDA2E7958CE99DA2-1.jpg" alt=""  />
</p>
<p>其功能具体如下。</p>
<p>1：选择运行时（Runtime）或永久（Permanent）模式的配置。</p>
<p>2：可选的策略集合区域列表。</p>
<p>3：常用的系统服务列表。</p>
<p>4：主机地址的黑白名单。</p>
<p>5：当前正在使用的区域。</p>
<p>6：管理当前被选中区域中的服务。</p>
<p>7：管理当前被选中区域中的端口。</p>
<p>8：设置允许被访问的协议。</p>
<p>9：设置允许被访问的端口。</p>
<p>10：开启或关闭SNAT（源网络地址转换）技术。</p>
<p>11：设置端口转发策略。</p>
<p>12：控制请求icmp服务的流量。</p>
<p>13：管理防火墙的富规则。</p>
<p>14：被选中区域的服务，若勾选了相应服务前面的复选框，则表示允许与之相关的流量。</p>
<p>15：firewall-config工具的运行状态。</p>
<p>除了图中列出的功能，还有用于将网卡与区域绑定的Interfaces选项，以及用于将IP地址与区域绑定的Sources选项。另外再啰唆一句。在使用firewall-config工具配置完防火墙策略之后，无须进行二次确认，因为只要有修改内容，它就自动进行保存。</p>
<p><strong>下面进行动手实践环节。</strong></p>
<p>先将当前区域中请求http服务的流量设置为允许放行，但仅限当前生效。具体配置如图所示：</p>
<p><img loading="lazy" src="/Distributions/E694BEE8A18CE8AFB7E6B182httpE69C8DE58AA1E79A84E6B581E9878F.png" alt=""  />
</p>
<p>尝试添加一条防火墙策略规则，使其放行访问8080～8088端口（TCP协议）的流量，并将其设置为永久生效，以达到系统重启后防火墙策略依然生效的目的。在按照下图所示的界面配置完毕之后，还需要在Options菜单中单击Reload Firewalld命令，让配置的防火墙策略立即生效。这与在命令行中使用&ndash;reload参数的效果一样。</p>
<p>放行访问8080～8088端口的流量：</p>
<p><img loading="lazy" src="/Distributions/E694BEE8A18CE8AEBFE997AE8080EFBD9E8088E7ABAFE58FA3E79A84E6B581E9878F.png" alt=""  />
</p>
<p>让配置的防火墙策略规则立即生效：</p>
<p><img loading="lazy" src="/Distributions/E8AEA9E9858DE7BDAEE79A84E998B2E781ABE5A299E7AD96E795A5E8A784E58899E7AB8BE58DB3E7949FE69588.png" alt=""  />
</p>
<p>前面在讲解firewall-config工具的功能时，曾经提到了SNAT（Source Network Address Translation，源网络地址转换）技术。SNAT是一种为了解决IP地址匮乏而设计的技术，它可以使得多个内网中的用户通过同一个外网IP接入Internet。该技术的应用非常广泛，甚至可以说我们每天都在使用，只不过没有察觉到罢了。比如，当通过家中的网关设备（无线路由器）访问本书配套站点<a href="https://www.linuxprobe.com/">www.linuxprobe.com</a>时，就用到了SNAT技术。</p>
<p>大家可以看一下在网络中不使用SNAT技术和使用SNAT技术时的情况。在没有使用SNAT技术的局域网中有多台PC，如果网关服务器没有应用SNAT技术，则互联网中的网站服务器在收到PC的请求数据包，并回送响应数据包时，将无法在网络中找到这个私有网络的IP地址，所以PC也就收不到响应数据包了。在使用SNAT技术处理过的局域网中，由于网关服务器应用了SNAT技术，所以互联网中的网站服务器会将响应数据包发给网关服务器，再由后者转发给局域网中的PC。</p>
<p>没有使用SNAT技术的网络：</p>
<p><img loading="lazy" src="/Distributions/E69CAAE794A8SNAT1.png" alt=""  />
</p>
<p>使用SNAT技术处理过的网络：</p>
<p><img loading="lazy" src="/Distributions/E4BDBFE794A8SNAT1.png" alt=""  />
</p>
<p>使用iptables命令实现SNAT技术是一件很麻烦的事情，但是在firewall-config中却是小菜一碟了。用户只需按照下图进行配置，并选中Masquerade zone复选框，就自动开启了SNAT技术。</p>
<p><img loading="lazy" src="/Distributions/E5BC80E590AFE998B2E781ABE5A299E79A84SNATE68A80E69CAF.png" alt=""  />
</p>
<p>为了让大家直观查看不同工具在实现相同功能时的区别，针对前面使用firewall-cmd配置的防火墙策略规则，这里使用firewall-config工具进行了重新演示：将本机888端口的流量转发到22端口，且要求当前和长期均有效，具体如下图所示：</p>
<p>配置本地的端口转发：</p>
<p><img loading="lazy" src="/Distributions/E9858DE7BDAEE69CACE59CB0E79A84E7ABAFE58FA3E8BDACE58F91.png" alt=""  />
</p>
<p>让防火墙效策略规则立即生效：</p>
<p><img loading="lazy" src="/Distributions/E8AEA9E998B2E781ABE5A299E69588E7AD96E795A5E8A784E58899E7AB8BE58DB3E7949FE69588.png" alt=""  />
</p>
<p>用命令配置富规则可真辛苦，幸好我们现在有了图形用户界面的工具。让192.168.10.20主机访问本机的1234端口号，如下图所示。其中Element选项能够根据服务名称、端口号、协议等信息进行匹配；Source与Destination选项后的inverted复选框代表反选功能，将其选中则代表对已填写信息进行反选，即选中填写信息以外的主机地址；Log复选框在选中后，日志不仅会被记录到日志文件中，而且还可以在设置日志的级别（Level）后，再将日志记录到日志文件中，以方便后续的筛查。</p>
<p><img loading="lazy" src="/Distributions/E9858DE7BDAEE998B2E781ABE5A299E5AF8CE8A784E58899E7AD96E795A5-1.png" alt=""  />
</p>
<p>如果生产环境中的服务器有多块网卡在同时提供服务（这种情况很常见），则对内网和对外网提供服务的网卡要选择的防火墙策略区域也是不一样的。也就是说，可以把网卡与防火墙策略区域进行绑定，这样就可以使用不同的防火墙区域策略，对源自不同网卡的流量进行有针对性的监控，效果会更好。</p>
<p>把网卡与防火墙策略区域进行绑定：</p>
<p><img loading="lazy" src="/Distributions/E68A8AE7BD91E58DA1E4B88EE998B2E781ABE5A299E7AD96E795A5E58CBAE59F9FE8BF9BE8A18CE7BB91E5AE9A.png" alt=""  />
</p>
<p>网卡与策略区域绑定完成：</p>
<p><img loading="lazy" src="/Distributions/E7BD91E58DA1E4B88EE7AD96E795A5E58CBAE59F9FE7BB91E5AE9AE5AE8CE68890.png" alt=""  />
</p>
<p>最后再提一句，firewall-config工具真的非常实用，很多原本复杂的长命令被图形化按钮替代，设置规则也简单明了，足以应对日常工作。所以再次向大家强调配置防火墙策略的原则—只要能实现所需的功能，用什么工具请随君便。</p>
<h3 id="服务的访问控制列表">服务的访问控制列表<a hidden class="anchor" aria-hidden="true" href="#服务的访问控制列表">#</a></h3>
<p>TCP Wrapper是RHEL 6/7系统中默认启用的一款流量监控程序，它能够根据来访主机的地址与本机的目标服务程序做出允许或拒绝的操作。在RHEL 8版本中，它已经被firewalld正式替代。换句话说，Linux系统中其实有两个层面的防火墙，第一种是前面讲到的基于TCP/IP协议的流量过滤工具，而TCP Wrapper服务则是能允许或禁止Linux系统提供服务的防火墙，从而在更高层面保护了Linux系统的安全运行。</p>
<p>TCP Wrapper服务的防火墙策略由两个控制列表文件所控制，用户可以编辑允许控制列表文件来放行对服务的请求流量，也可以编辑拒绝控制列表文件来阻止对服务的请求流量。控制列表文件修改后会立即生效，系统将会先检查允许控制列表文件（/etc/hosts.allow），如果匹配到相应的允许策略则放行流量；如果没有匹配，则会进一步匹配拒绝控制列表文件（/etc/hosts.deny），若找到匹配项则拒绝该流量。如果这两个文件都没有匹配到，则默认放行流量。</p>
<p>由于RHEL 8版本已经不再支持TCP Wrapper服务程序，因此我们接下来选择在一台老版本的服务器上进行实验。TCP Wrapper服务的控制列表文件配置起来并不复杂，常用的参数如表所示。</p>
<table>
<thead>
<tr>
<th>客户端类型</th>
<th>示例</th>
<th>满足示例的客户端列表</th>
</tr>
</thead>
<tbody>
<tr>
<td>单一主机</td>
<td>192.168.10.10</td>
<td>IP地址为192.168.10.10的主机</td>
</tr>
<tr>
<td>指定网段</td>
<td>192.168.10.</td>
<td>IP段为192.168.10.0/24的主机</td>
</tr>
<tr>
<td>指定网段</td>
<td>192.168.10.0/255.255.255.0</td>
<td>IP段为192.168.10.0/24的主机</td>
</tr>
<tr>
<td>指定DNS后缀</td>
<td>.linuxprobe.com</td>
<td>所有DNS后缀为.linuxprobe.com的主机</td>
</tr>
<tr>
<td>指定主机名称</td>
<td><a href="http://www.linuxprobe.com">www.linuxprobe.com</a></td>
<td>主机名称为www.linuxprobe.com的主机</td>
</tr>
<tr>
<td>指定所有客户端</td>
<td>ALL</td>
<td>所有主机全部包括在内</td>
</tr>
</tbody>
</table>
<p>在配置TCP Wrapper服务时需要遵循两个原则：</p>
<ul>
<li>编写拒绝策略规则时，填写的是服务名称，而非协议名称；</li>
<li>建议先编写拒绝策略规则，再编写允许策略规则，以便直观地看到相应的效果。</li>
</ul>
<p>下面编写拒绝策略规则文件，禁止访问本机sshd服务的所有流量（无须修改/etc/hosts.deny文件中原有的注释信息）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># vim /etc/hosts.deny</span>
<span style="color:#75715e">#</span>
<span style="color:#75715e"># hosts.deny This file contains access rules which are used to</span>
<span style="color:#75715e"># deny connections to network services that either use</span>
<span style="color:#75715e"># the tcp_wrappers library or that have been</span>
<span style="color:#75715e"># started through a tcp_wrappers-enabled xinetd.</span>
<span style="color:#75715e">#</span>
<span style="color:#75715e"># The rules in this file can also be set up in</span>
<span style="color:#75715e"># /etc/hosts.allow with a &#39;deny&#39; option instead.</span>
<span style="color:#75715e">#</span>
<span style="color:#75715e"># See &#39;man 5 hosts_options&#39; and &#39;man 5 hosts_access&#39;</span>
<span style="color:#75715e"># for information on rule syntax.</span>
<span style="color:#75715e"># See &#39;man tcpd&#39; for information on tcp_wrappers</span>
sshd:*
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># ssh 192.168.10.10</span>
ssh_exchange_identification: read: Connection reset by peer
</code></pre></div><p>接下来，在允许策略规则文件中添加一条规则，使其放行源自192.168.10.0/24网段，且访问本机sshd服务的所有流量。可以看到，服务器立刻就放行了访问sshd服务的流量，效果非常直观：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># vim /etc/hosts.allow</span>
<span style="color:#75715e">#</span>
<span style="color:#75715e"># hosts.allow This file contains access rules which are used to</span>
<span style="color:#75715e"># allow or deny connections to network services that</span>
<span style="color:#75715e"># either use the tcp_wrappers library or that have been</span>
<span style="color:#75715e"># started through a tcp_wrappers-enabled xinetd.</span>
<span style="color:#75715e">#</span>
<span style="color:#75715e"># See &#39;man 5 hosts_options&#39; and &#39;man 5 hosts_access&#39;</span>
<span style="color:#75715e"># for information on rule syntax.</span>
<span style="color:#75715e"># See &#39;man tcpd&#39; for information on tcp_wrappers</span>
sshd:192.168.10.

<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># ssh 192.168.10.10</span>
The authenticity of host <span style="color:#e6db74">&#39;192.168.10.10 (192.168.10.10)&#39;</span> can<span style="color:#e6db74">&#39;t be established.
</span><span style="color:#e6db74">ECDSA key fingerprint is 70:3b:5d:37:96:7b:2e:a5:28:0d:7e:dc:47:6a:fe:5c.
</span><span style="color:#e6db74">Are you sure you want to continue connecting (yes/no)? yes
</span><span style="color:#e6db74">Warning: Permanently added &#39;</span>192.168.10.10<span style="color:#e6db74">&#39; (ECDSA) to the list of known hosts.
</span><span style="color:#e6db74">root@192.168.10.10&#39;</span>s password: 
Last login: Wed May <span style="color:#ae81ff">4</span> 07:56:29 <span style="color:#ae81ff">2021</span>
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># </span>
</code></pre></div><h3 id="cockpit-驾驶舱管理工具">Cockpit 驾驶舱管理工具<a hidden class="anchor" aria-hidden="true" href="#cockpit-驾驶舱管理工具">#</a></h3>
<p>首先，Cockpit是一个英文单词，即“（飞机、船或赛车的）驾驶舱、驾驶座”，它用名字传达出了功能丰富的特性。其次，Cockpit是一个基于Web的图形化服务管理工具，对用户相当友好，即便是新手也可以轻松上手。而且它天然具备很好的跨平台性，因此被广泛应用于服务器、容器、虚拟机等多种管理场景。最后，红帽公司对Cockpit也十分看重，直接将它默认安装到了RHEL 8系统中，由此衍生的CentOS和Fedora也都标配有Cockpit。</p>
<p>Cockpit在默认情况下就已经被安装到系统中。下面执行dnf命令对此进行确认：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># dnf install cockpit</span>
Updating Subscription Management repositories.
Unable to read consumer identity
This system is not registered to Red Hat Subscription Management. You can use subscription-manager to register.
AppStream                                       3.1 MB/s | 3.2 kB     00:00    
BaseOS                                          2.7 MB/s | 2.7 kB     00:00    
Package cockpit-185-2.el8.x86_64 is already installed.
Dependencies resolved.
Nothing to <span style="color:#66d9ef">do</span>.
Complete!
</code></pre></div><p>但是，Cockpit服务程序在RHEL 8版本中没有自动运行，下面将它开启并加入到开机启动项中：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># systemctl start cockpit</span>
<span style="color:#f92672">[</span>root@linuxprobe ~<span style="color:#f92672">]</span><span style="color:#75715e"># systemctl enable cockpit.socket</span>
Created symlink /etc/systemd/system/sockets.target.wants/cockpit.socket → /usr/lib/systemd/system/cockpit.socket.
</code></pre></div><p>在Cockpit服务启动后，打开系统自带的浏览器，在地址栏中输入“本机地址:9090”即可访问。由于访问Cockpit的流量会使用HTTPS进行加密，而证书又是在本地签发的，因此还需要进行添加并信任本地证书的操作。</p>
<p>添加额外允许的证书：</p>
<p><img loading="lazy" src="/Distributions/1-58.png" alt=""  />
</p>
<p>确认信任本地证书：</p>
<p><img loading="lazy" src="/Distributions/2-37.png" alt=""  />
</p>
<p>进入Cockpit的登录界面后，输入root管理员的账号与系统密码，单击Log In按钮后即可进入：</p>
<p><img loading="lazy" src="/Distributions/3-14.png" alt=""  />
</p>
<p>进入Cockpit的Web界面，发现里面可谓“别有洞天”。Cockpit总共分为13个功能模块：系统状态（System）、日志信息（Logs）、硬盘存储（Storage）、网卡网络（Networking）、账户安全（Accounts）、服务程序（Services）、软件仓库（Applications）、报告分析（Diagnostic Reports）、内核排错（Kernel Dump）、SElinux、更新软件（Software Updates）、订阅服务（Subscriptions）、终端界面（Terminal）。下面逐一进行讲解。</p>
<p><strong>1．System</strong></p>
<p>进入Cockpit界面后默认显示的便是System（系统）界面，在该界面中能够看到系统架构、版本、主机名与时间等信息，还能够动态地展现出CPU、硬盘、内存和网络的复杂情况，这有点类似于Web版的“Winodws系统任务管理器”，属实好用。</p>
<p>系统状态界面：</p>
<p><img loading="lazy" src="/Distributions/1-59.png" alt=""  />
</p>
<p><strong>2．Logs</strong></p>
<p>这个模块能够提供系统的全部日志，但是同学们可能会好奇，“为什么下图中的内容这么有限呢”？原因出在图中的两个选项中：时间和日志级别。通过这两个选项可以让用户更快地找到所需信息，而不是像/var/log/message文件那样一股脑儿地都抛给用户。</p>
<p>日志信息界面：</p>
<p><img loading="lazy" src="/Distributions/2-38.png" alt=""  />
</p>
<p><strong>3．Storage</strong></p>
<p>这个功能模块是同学们最喜欢的一个模块，原因不是这个模块显示了硬盘的I/O读写负载情况，而是可以让用户通过该界面，用鼠标创建出RAID、LVM、VDO和iSCSI等存储设备。是的，您没有看错，RAID和LVM都可以用鼠标进行创建了，是不是很开心呢？</p>
<p>硬盘存储界面：</p>
<p><img loading="lazy" src="/Distributions/3-15.png" alt=""  />
</p>
<p><strong>4．Networking</strong></p>
<p>既然名为Networking模块，那么动态看网卡的输出和接收值肯定是这个模块的标配功能了。我们不仅可以在这里进行网卡的绑定（Bonding）和聚合（Team），还可以创建桥接网卡及添加VLAN。最下方会单独列出与网卡相关的日志信息。</p>
<p>网卡网络界面：</p>
<p><img loading="lazy" src="/Distributions/4-9.png" alt=""  />
</p>
<p>**5．**Accounts</p>
<p>大家千万别小看Accounts模块，虽然它的账户安全界面有些简陋，只有一个用于创建账户的按钮，但只要点击进入某个用户的管理界面中，马上会发现“别有洞天”——账户管理界面，这个界面中的功能非常丰富，我们在这里可以对用户进行重命名，设置用户的权限，还可以锁定、修改密码以及创建SSH密钥信息。</p>
<p>账户安全界面：</p>
<p><img loading="lazy" src="/Distributions/5-9.png" alt=""  />
</p>
<p>账户管理界面：</p>
<p><img loading="lazy" src="/Distributions/5B.png" alt=""  />
</p>
<p><strong>6．Services</strong></p>
<p>在Services功能模块的界面中，可以查看系统中已有的服务列表和运行状态。单击某一服务，进入该服务的管理界面后，可以对具体的服务进行开启、关闭操作。在Services功能模块中设置了服务并将其加入到开机启动项后，在系统重启后也依然会为用户提供服务。</p>
<p>服务程序界面：</p>
<p><img loading="lazy" src="/Distributions/6-3.png" alt=""  />
</p>
<p>服务管理界面：</p>
<p><img loading="lazy" src="/Distributions/6B.png" alt=""  />
</p>
<p><strong>7．Applications</strong></p>
<p>后期采用Cockpit或红帽订阅服务安装的软件都会显示在这个功能模块中。</p>
<p>软件仓库界面：</p>
<p><img loading="lazy" src="/Distributions/7-3.png" alt=""  />
</p>
<p><strong>8．Diagnostic Report</strong></p>
<p>Diagnostic Report模块的功能是帮助用户收集及分析系统的信息，找到系统出现问题的原因。单击Create Report按钮后大约两分钟左右，会出现报告生成完毕的弹窗。好吧，摊牌了，这个功能其实很鸡肋，就是将sosreport命令做成了一个网页按钮。</p>
<p>报告分析界面：</p>
<p><img loading="lazy" src="/Distributions/8.png" alt=""  />
</p>
<p>报告生成完毕：</p>
<p><img loading="lazy" src="/Distributions/8B.png" alt=""  />
</p>
<p><strong>9．Kernel Dump</strong></p>
<p>Kernel Dump（Kdump）是一个在系统崩溃、死锁或死机时用来收集内核参数的一个服务。举例来说，如果有一天系统崩溃了，这时Kdump服务就会开始工作，将系统的运行状态和内核数据收集到一个名为dump core的文件中，以便后续让运维人员分析并找出问题所在。由于我们在安装系统时没有启动该服务，所以可以等到后续使用时再开启该功能界面。</p>
<p>内核排错界面：</p>
<p><img loading="lazy" src="/Distributions/9-2.png" alt=""  />
</p>
<p><strong>10．SElinux</strong></p>
<p>下图所示为SELinux服务的控制按钮和警告信息界面。</p>
<p>SElinux管理界面：</p>
<p><img loading="lazy" src="/Distributions/10.png" alt=""  />
</p>
<p><strong>11．Software Updates</strong></p>
<p>这里提到的Software Updates并不是我们用来更新其他常规软件的一个界面，而是用来对红帽客户订阅的服务进行更新的界面。用户只有在购买了红帽第三方服务后才能使用这里面的功能。在购买了红帽订阅服务后，用户便可以在这里下载到相应服务程序的最新版本和稳定版本。</p>
<p>更新软件界面：</p>
<p><img loading="lazy" src="/Distributions/11-5.png" alt=""  />
</p>
<p><strong>12．Subscriptions</strong></p>
<p>这里依然是一则红帽公司的“小广告”—如果想成为尊贵的红帽服务用户，要付费购买订阅服务。个人用户无须购买，而且这对我们的后续实验没有任何影响。</p>
<p>订阅服务界面：</p>
<p><img loading="lazy" src="/Distributions/12-3.png" alt=""  />
</p>
<p><strong>12．Terminal</strong></p>
<p>压轴的总是在最后。Cockpit服务提供了Shell终端的在线控制平台，可方便用户通过网页上的终端功能管理服务器。这个功能深受运维人员喜爱。</p>
<p>终端管理界面</p>
<p><img loading="lazy" src="/Distributions/13-2.png" alt=""  />
</p>
<p>至此，相信各位读者已经充分掌握了防火墙的管理能力。防火墙管理工具有很多种，我们任选其一即可。在配置后续的服务前，大家要记得检查网络和防火墙的状态，以避免出现服务明明配置正确，但无法从外部访问的情况，最终影响实验效果。</p>
<h3 id="在-ubuntu-上使用-ufwgufwhttpswwwmyfreaxcomhow-to-setup-a-firewall-with-ufw-on-ubuntu-20-04"><a href="https://www.myfreax.com/how-to-setup-a-firewall-with-ufw-on-ubuntu-20-04/">在 Ubuntu 上使用 UFW&amp;GUFW</a><a hidden class="anchor" aria-hidden="true" href="#在-ubuntu-上使用-ufwgufwhttpswwwmyfreaxcomhow-to-setup-a-firewall-with-ufw-on-ubuntu-20-04">#</a></h3>
<p>Ubuntu 20.04 随附了一个称为UFW（非复杂防火墙）的防火墙配置工具。 它是用于管理iptables防火墙规则的用户友好型前端。 它的主要目标是使防火墙的管理变得更容易，或者顾名思义，变得简单。而GUFW是UFW的图形介面。</p>
<h4 id="检查ufw状态">检查UFW状态<a hidden class="anchor" aria-hidden="true" href="#检查ufw状态">#</a></h4>
<p>UFW默认情况下处于禁用状态。 您可以使用以下命令检查UFW服务的状态：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw status verbose
</code></pre></div><p>输出将显示防火墙状态为非活动：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">Status: inactive
</code></pre></div><p>如果UFW已激活，则输出将类似于以下内容：</p>
<pre tabindex="0"><code>Status: active
</code></pre><h4 id="ufw默认策略">UFW默认策略<a hidden class="anchor" aria-hidden="true" href="#ufw默认策略">#</a></h4>
<p>UFW防火墙的默认行为是阻止所有传入和转发流量，并允许所有出站流量。 这意味着除非您专门打开端口，否则任何尝试访问您的服务器的人都将无法连接。 服务器上运行的应用程序和服务将可以访问外界。</p>
<p>默认策略在<code>/etc/default/ufw</code>文件中定义，可以通过手动修改文件或使用<code>sudo ufw default &lt;policy&gt; &lt;chain&gt;</code>命令来更改。</p>
<p>防火墙策略是建立更复杂和用户定义的规则的基础。 通常，最初的UFW默认策略是一个很好的起点。</p>
<h4 id="应用配置文件">应用配置文件<a hidden class="anchor" aria-hidden="true" href="#应用配置文件">#</a></h4>
<p>应用程序配置文件是INI格式的文本文件，描述了服务并包含该服务的防火墙规则。 在安装软件包期间，会在<code>/etc/ufw/applications.d</code>目录中创建应用程序配置文件。</p>
<p>您可以通过键入以下内容列出服务器上所有可用的应用程序配置文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw app list
Available applications:
  Nginx Full
  Nginx HTTP
  Nginx HTTPS
  OpenSSH
</code></pre></div><p>要查找有关特定配置文件和包含的规则的更多信息，请使用以下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw app info <span style="color:#e6db74">&#39;Nginx Full&#39;</span>
Profile: Nginx Full
Title: Web Server <span style="color:#f92672">(</span>Nginx, HTTP + HTTPS<span style="color:#f92672">)</span>
Description: Small, but very powerful and efficient web server

Ports:
  80,443/tcp
</code></pre></div><p>输出显示“ Nginx Full”配置文件打开了端口<code>80</code>和<code>443</code>。</p>
<p>您也可以为应用创建自定义配置文件。</p>
<h4 id="启用ufw">启用UFW<a hidden class="anchor" aria-hidden="true" href="#启用ufw">#</a></h4>
<p>如果要从远程位置连接到Ubuntu，则在启用UFW防火墙之前，必须明确允许传入的SSH连接。 否则，您将无法连接到计算机。</p>
<p>要将您的UFW防火墙配置为允许传入的SSH连接，请键入以下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw allow ssh
Rules updated
Rules updated <span style="color:#f92672">(</span>v6<span style="color:#f92672">)</span>
</code></pre></div><p>如果SSH在<a href="https://www.myfreax.com/how-to-change-ssh-port-in-linux/">非标准端口</a>上运行，则需要打开该端口。</p>
<p>例如，如果您的ssh守护程序侦听端口<code>7722</code>，请输入以下命令以允许该端口上的连接：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw allow 7722/tcp
</code></pre></div><p>现在已将防火墙配置为允许传入的SSH连接，您可以通过键入以下内容来启用它：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw enable
Command may disrupt existing ssh connections. Proceed with operation <span style="color:#f92672">(</span>y|n<span style="color:#f92672">)</span>? y
Firewall is active and enabled on system startup
</code></pre></div><p>将警告您启用防火墙可能会破坏现有的ssh连接，只需键入<code>y</code>并单击<code>Enter</code>。</p>
<h4 id="打开端口">打开端口<a hidden class="anchor" aria-hidden="true" href="#打开端口">#</a></h4>
<p>根据系统上运行的应用程序，您可能还需要打开其他端口。 打开端口的一般语法如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ufw allow port_number/protocol
</code></pre></div><p>以下是有关如何允许HTTP连接的几种方法。</p>
<p>第一种选择是使用服务名称。 UFW检查<code>/etc/services</code>文件中指定服务的端口和协议：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw allow http
</code></pre></div><p>您还可以指定端口号和协议：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw allow 80/tcp
</code></pre></div><p>如果未给出协议，则UFW会同时为<code>tcp</code>和<code>udp</code>创建规则。</p>
<p>另一个选择是使用应用程序配置文件； 在这种情况下，“ Nginx HTTP”：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw allow <span style="color:#e6db74">&#39;Nginx HTTP&#39;</span>
</code></pre></div><p>UFW还支持使用<code>proto</code>关键字指定协议的另一种语法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw allow proto tcp to any port <span style="color:#ae81ff">80</span>
</code></pre></div><p><strong>端口范围</strong></p>
<p>UFW还允许您打开端口范围。 起始端口和结束端口用冒号（<code>:</code>）分隔，并且您必须指定协议<code>tcp</code>或<code>udp</code>。</p>
<p>例如，如果要同时在<code>tcp</code>和<code>udp</code>上允许端口从<code>7100</code>到<code>7200</code>，则可以运行以下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw allow 7100:7200/tcp
</code></pre></div><p><strong>特定的IP地址和端口</strong></p>
<p>要允许来自给定源IP的所有端口上的连接，请使用<code>from</code>关键字，后跟源地址。</p>
<p>以下是将IP地址列入白名单的示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw allow from 64.63.62.61
</code></pre></div><p>如果要仅允许给定IP地址访问特定端口，请使用<code>to any port</code>关键字，后跟端口号。</p>
<p>例如，要允许IP地址为<code>64.63.62.61</code>的计算机访问端口<code>22</code>，请输入：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw allow from 64.63.62.61 to any port <span style="color:#ae81ff">22</span>
</code></pre></div><p><strong>子网</strong></p>
<p>允许连接到IP地址子网的语法与使用单个IP地址时的语法相同。 唯一的区别是您需要指定子网掩码。</p>
<p>下面是一个示例，显示了如何允许访问从<code>192.168.1.1</code>到<code>192.168.1.254</code>的IP地址到端口<code>3360</code>（<a href="https://www.myfreax.com/how-to-install-mysql-on-ubuntu-20-04/"> MySQL </a>）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw allow from 192.168.1.0/24 to any port <span style="color:#ae81ff">3306</span>
</code></pre></div><p><strong>特定网络接口</strong></p>
<p>要允许在特定的网络接口上进行连接，请使用<code>in on</code>关键字，后跟网络接口(网卡)的名称：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw allow in on eth2 to any port <span style="color:#ae81ff">3306</span>
</code></pre></div><h4 id="拒绝连接">拒绝连接<a hidden class="anchor" aria-hidden="true" href="#拒绝连接">#</a></h4>
<p>所有传入连接的默认策略均设置为<code>deny</code>，如果您未更改默认策略，除非您专门打开连接，否则UFW会阻止所有传入连接。</p>
<p>撰写拒绝规则与撰写允许规则相同； 您只需要使用<code>deny</code>关键字而不是<code>allow</code>。</p>
<p>假设您打开了端口<code>80</code>和<code>443</code>，并且服务器受到<code>23.24.25.0/24</code>网络的攻击。 要拒绝来自<code>23.24.25.0/24</code>的所有连接，您可以运行以下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw deny from 23.24.25.0/24
</code></pre></div><p>以下是拒绝访问<code>23.24.25.0/24</code>中的端口<code>80</code>和<code>443</code>的示例，您可以使用以下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw deny proto tcp from 23.24.25.0/24 to any port 80,443
</code></pre></div><h4 id="删除ufw规则">删除UFW规则<a hidden class="anchor" aria-hidden="true" href="#删除ufw规则">#</a></h4>
<p>有两种方法可以通过规则编号和指定实际规则来删除UFW规则。</p>
<p>按规则号删除规则比较容易，尤其是当您不熟悉UFW时。 要首先通过规则编号删除规则，您需要找到要删除的规则的编号。 要获取编号规则的列表，请使用<code>ufw status numbered</code>命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw status numbered
Status: active

     To                         Action      From
     --                         ------      ----
<span style="color:#f92672">[</span> 1<span style="color:#f92672">]</span> 22/tcp                     ALLOW IN    Anywhere
<span style="color:#f92672">[</span> 2<span style="color:#f92672">]</span> 80/tcp                     ALLOW IN    Anywhere
<span style="color:#f92672">[</span> 3<span style="color:#f92672">]</span> 8080/tcp                   ALLOW IN    Anywhere
</code></pre></div><p>要删除规则号<code>3</code>，该规则号允许连接到端口<code>8080</code>，请输入：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw delete <span style="color:#ae81ff">3</span>
</code></pre></div><p>第二种方法是通过指定实际规则来删除规则。 例如，如果您添加了打开端口<code>8069</code>的规则，则可以使用以下命令将其删除：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw delete allow <span style="color:#ae81ff">8069</span>
</code></pre></div><h4 id="禁用ufw">禁用UFW<a hidden class="anchor" aria-hidden="true" href="#禁用ufw">#</a></h4>
<p>如果出于任何原因要停止UFW并停用所有规则，则可以使用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw disable
</code></pre></div><p>以后，如果您想重新启用UTF并激活所有规则，只需键入：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw enable
</code></pre></div><h4 id="重设ufw">重设UFW<a hidden class="anchor" aria-hidden="true" href="#重设ufw">#</a></h4>
<p>重置UFW将禁用UFW，并删除所有活动规则。 如果您想还原所有更改并重新开始，这将很有帮助。</p>
<p>要重置UFW，请输入以下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw reset
</code></pre></div><h4 id="ip伪装">IP伪装<a hidden class="anchor" aria-hidden="true" href="#ip伪装">#</a></h4>
<p>IP伪装是Linux内核中NAT（网络地址转换）的一种变体，它通过重写源IP地址和目标IP地址和端口来转换网络流量。 借助IP伪装，您可以使用一台充当网关的Linux计算机，允许专用网络中的一台或多台计算机与Internet通信。</p>
<p>使用UFW配置IP伪装涉及几个步骤。</p>
<p>首先，您需要启用IP转发。 为此，请打开<code>/etc/ufw/sysctl.conf</code>文件，查找并取消注释以下行：<code>net.ipv4.ip_forward = 1</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo nano /etc/ufw/sysctl.conf
net/ipv4/ip_forward<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</code></pre></div><p>接下来，您需要配置UFW以允许转发数据包。 打开UFW配置文件，找到<code>DEFAULT_FORWARD_POLICY</code>键，然后将值从<code>DROP</code>更改为<code>ACCEPT</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo nano /etc/default/ufw
DEFAULT_FORWARD_POLICY<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;ACCEPT&#34;</span>
</code></pre></div><p>现在，您需要在<code>nat</code>表中设置<code>POSTROUTING</code>链的默认策略和伪装规则。 为此，请打开<code>/etc/ufw/before.rules</code>文件，附加以下几行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo nano /etc/ufw/before.rules
<span style="color:#75715e">#NAT table rules</span>
*nat
:POSTROUTING ACCEPT <span style="color:#f92672">[</span>0:0<span style="color:#f92672">]</span>

<span style="color:#75715e"># Forward traffic through eth0 - Change to public network interface</span>
-A POSTROUTING -s 10.8.0.0/16 -o eth0 -j MASQUERADE

<span style="color:#75715e"># don&#39;t delete the &#39;COMMIT&#39; line or these rules won&#39;t be processed</span>
COMMIT
</code></pre></div><p>别忘了在<code>-A POSTROUTING</code>行中替换<code>eth0</code>以匹配公共网络接口的名称：</p>
<p>完成后，保存并关闭文件。</p>
<p>最后，通过禁用和重新启用UFW重新加载UFW规则：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ufw disable
$ sudo ufw e
</code></pre></div><h2 id="linux-kernel">Linux Kernel<a hidden class="anchor" aria-hidden="true" href="#linux-kernel">#</a></h2>
<p>来自 <a href="https://en.wikipedia.org/wiki/Kernel_(computing)">Wikipedia</a>:</p>
<blockquote>
<p><em>内核是计算机操作系统的核心组件，对系统有完全的控制。开机时最先启动，然后负责后续的启动工作。它负责处理其它软件的请求，将这些请求转化为中央处理器的数据处理请求。内核还负责管理内存，管理系统和其它打印机、扬声器等外围设备的通讯，是操作系统最基础的部分。</em></p>
</blockquote>
<p>内核包安装在<code>/boot/</code>下的文件系统上。为了能够引导到内核，必须适当配置<a href="https://wiki.archlinux.org/title/%E5%90%AF%E5%8A%A8%E5%8A%A0%E8%BD%BD%E5%99%A8">启动加载器</a>。</p>
<h3 id="kernel-modulehttpswikiarchlinuxorgtitlekernel_module_e7ae80e4bd93e4b8ade69687"><a href="https://wiki.archlinux.org/title/Kernel_module_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Kernel module</a><a hidden class="anchor" aria-hidden="true" href="#kernel-modulehttpswikiarchlinuxorgtitlekernel_module_e7ae80e4bd93e4b8ade69687">#</a></h3>
<p><a href="https://en.wikipedia.org/wiki/Loadable_kernel_module">内核模块</a>是可以按需加载或卸载的内核代码，可以不重启系统就扩充内核的功能。</p>
<p>要创建内核模块，请阅读<a href="https://tldp.org/LDP/lkmpg/2.6/html/index.html">此指南</a>。模块可以设置成内置或者动态加载，要编译成可动态加载，需要在内核配置时将模块配置为 <code>M</code> (模块)。</p>
<h4 id="获取信息">获取信息<a hidden class="anchor" aria-hidden="true" href="#获取信息">#</a></h4>
<p>模块保存在 <code>/lib/modules/kernel_release</code> (使用 <code>uname -r</code> 命令显示当前内核版本)。</p>
<p><strong>注意：</strong> 模块名通常使用 (<code>_</code>) 或 <code>-</code> 连接，但是这些符号在 <code>modprobe</code> 命令和 <code>/etc/modprobe.d/</code> 配置文件中都是可以相互替换的。</p>
<p>显示当前装入的内核模块：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ lsmod
</code></pre></div><p>在上面的输出中：</p>
<ul>
<li><code>Module</code> 显示每个模块的名称</li>
<li><code>Size</code> 显示每个模块的大小（并不是它们占的内存大小）</li>
<li><code>Used by</code> 显示每个模块被使用的次数和使用它们的模块</li>
</ul>
<p>显然，这里有很多模块。加载的模块数量取决于你的系统和版本以及正在运行的内容。我们可以这样计数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ lsmod | wc -l
<span style="color:#ae81ff">67</span>
</code></pre></div><p><code>modules.builtin</code> 文件中列出了所有构建在内核中的模块</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ more /lib/modules/<span style="color:#66d9ef">$(</span>uname -r<span style="color:#66d9ef">)</span>/modules.builtin | head -10
kernel/arch/x86/crypto/crc32c-intel.ko
kernel/arch/x86/events/intel/intel-uncore.ko
kernel/arch/x86/platform/intel/iosf_mbi.ko
kernel/mm/zpool.ko
kernel/mm/zbud.ko
kernel/mm/zsmalloc.ko
kernel/fs/binfmt_script.ko
kernel/fs/mbcache.ko
kernel/fs/configfs/configfs.ko
kernel/fs/crypto/fscrypto.ko
</code></pre></div><p>显示模块信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ modinfo module_name
</code></pre></div><p>显示所有模块的配置信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ modprobe -c | less
</code></pre></div><p>显示某个模块的配置信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ modprobe -c | grep module_name
</code></pre></div><p>显示一个装入模块使用的选项：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ systool -v -m module_name
</code></pre></div><p>显示模块的依赖关系：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ modprobe --show-depends module_name
</code></pre></div><h4 id="使用systemd自动加载模块">使用systemd自动加载模块<a hidden class="anchor" aria-hidden="true" href="#使用systemd自动加载模块">#</a></h4>
<p>目前，所有必要模块的加载均由 <a href="https://wiki.archlinux.org/title/Udev">udev</a> 自动完成。所以，如果不需要使用任何额外的模块，就没有必要在任何配置文件中添加启动时加载的模块。但是，有些情况下可能需要在系统启动时加载某个额外的模块，或者将某个模块列入黑名单以便使系统正常运行。</p>
<p>内核模块可以在<code>/etc/modules-load.d/</code> 下的文件中明确列出，以便systemd在引导过程中加载它们。 每个配置文件都以 <code>/etc/modules-load.d/&lt;program&gt;.conf</code>的样式命名。 配置文件仅包含要加载的内核模块名称列表，以换行符分隔。 空行和第一个非空白字符为<code>#</code>或<code>;</code>的行被忽略。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat /etc/modules-load.d/virtio-net.conf
<span style="color:#75715e"># Load virtio_net.ko at boot</span>
virtio_net
</code></pre></div><p>另见<a href="https://man.archlinux.org/man/modules-load.d.5">modules-load.d(5)</a>。</p>
<h4 id="手动加载卸载">手动加载卸载<a hidden class="anchor" aria-hidden="true" href="#手动加载卸载">#</a></h4>
<p>控制内核模块载入/移除的命令是kmod 软件包提供的, 要手动装入模块的话，执行:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># modprobe module_name</span>
</code></pre></div><p>按文件名加载模块:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># insmod filename [args]</span>
</code></pre></div><p><strong>注意：</strong> 如果升级了内核但是没有重启，路径 <code>/usr/lib/modules/$(uname -r)/</code> 已经不存在。<em>modprobe</em> 会返回错误 1，没有额外的错误信息。如果出现 modprobe 加载失败，请检查模块路径以确认是否是这个问题导致。</p>
<p>如果要移除一个模块：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># modprobe -r module_name</span>
</code></pre></div><p>或者:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># rmmod module_name</span>
</code></pre></div><h4 id="配置模块参数">配置模块参数<a hidden class="anchor" aria-hidden="true" href="#配置模块参数">#</a></h4>
<h5 id="手动加载时设置">手动加载时设置<a hidden class="anchor" aria-hidden="true" href="#手动加载时设置">#</a></h5>
<p>传递参数的基本方式是使用 modprobe 选项，格式是 <code>key=value</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># modprobe module_name parameter_name=parameter_value</span>
</code></pre></div><h5 id="使用-etcmodprobed中的文件">使用 /etc/modprobe.d/中的文件<a hidden class="anchor" aria-hidden="true" href="#使用-etcmodprobed中的文件">#</a></h5>
<p>要通过配置文件传递参数，在 <code>/etc/modprobe.d/</code> 中放入任意名称 <code>.conf</code> 文件，加入:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo gedit /etc/modprobe.d/myfilename.conf
options modname parametername<span style="color:#f92672">=</span>parametercontents
</code></pre></div><p>例如</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo gedit /etc/modprobe.d/thinkfan.conf
<span style="color:#75715e"># On thinkpads, this lets the thinkfan daemon control fan speed</span>
options thinkpad_acpi fan_control<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</code></pre></div><p><strong>注意：</strong> 如果要在启动时就修改内核参数(从 init ramdisk 开始)，需要将相应的<code>.conf</code>-文件加入 <a href="https://wiki.archlinux.org/title/Mkinitcpio.conf">mkinitcpio.conf</a> 的 FILES 参数中。</p>
<h5 id="使用内核命令行">使用内核命令行<a hidden class="anchor" aria-hidden="true" href="#使用内核命令行">#</a></h5>
<p>如果模块直接编译进内核，也可以通过启动管理器(<a href="https://wiki.archlinux.org/title/GRUB">GRUB</a>, <a href="https://wiki.archlinux.org/title/LILO">LILO</a> 或 <a href="https://wiki.archlinux.org/title/Syslinux">Syslinux</a>)的内核行加入参数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">modname.parametername<span style="color:#f92672">=</span>parametercontents
</code></pre></div><p>例如:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">thinkpad_acpi.fan_control<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</code></pre></div><h4 id="别名">别名<a hidden class="anchor" aria-hidden="true" href="#别名">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat /etc/modprobe.d/myalias.conf
<span style="color:#75715e"># Lets you use &#39;mymod&#39; in MODULES, instead of &#39;really_long_module_name&#39;</span>
alias mymod really_long_module_name
</code></pre></div><p>有些模块具有别名，以方便其它程序自动装入模块。禁用这些别名可以阻止自动装入，但是仍然可以手动装入。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat /etc/modprobe.d/modprobe.conf
<span style="color:#75715e"># Prevent autoload of bluetooth</span>
alias net-pf-31 off

<span style="color:#75715e"># Prevent autoload of ipv6</span>
alias net-pf-10 off
</code></pre></div><h4 id="黑名单">黑名单<a hidden class="anchor" aria-hidden="true" href="#黑名单">#</a></h4>
<h5 id="禁用内核模块">禁用内核模块<a hidden class="anchor" aria-hidden="true" href="#禁用内核模块">#</a></h5>
<p>对内核模块来说，黑名单是指禁止某个模块装入的机制。当对应的硬件不存在或者装入某个模块会导致问题时很有用。</p>
<p>有些模块作为 <a href="https://wiki.archlinux.org/title/Initramfs">initramfs</a> 的一部分装入。</p>
<p><code>mkinitcpio -M</code> 会显示所有自动检测到到模块：要阻止 initramfs 装入某些模块，可以在 <code>/etc/modprobe.d</code>中将它们加入黑名单。并应在映像生成过程中通过<code>modconf</code>挂钩将其添加。</p>
<p>运行 <code>mkinitcpio -v</code> 会显示各种钩子(例如 filesystem 钩子, SCSI 钩子等)装入的模块。如果您的<code>HOOKS</code> 数组中没有 <code>modconf</code> 钩子（例如，和默认配置不同）则请将该&rdquo;.conf&quot;文件添加到<code>/etc/mkinitcpio.conf</code>中的FILES数组中。一旦您将其列入黑名单，请重新生成 <a href="https://wiki.archlinux.org/title/Initramfs">initramfs</a>，然后重新启动。</p>
<h5 id="使用-etcmodprobed-中的文件">使用 /etc/modprobe.d/ 中的文件<a hidden class="anchor" aria-hidden="true" href="#使用-etcmodprobed-中的文件">#</a></h5>
<p>在 <code>/etc/modprobe.d/</code> 中创建 <code>.conf</code> 文件，使用 <code>blacklist</code> 关键字屏蔽不需要的模块，例如如果不想装入 <code>pcspkr</code> 模块：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo gedit /etc/modprobe.d/nobeep.conf
<span style="color:#75715e"># Do not load the pcspkr module on boot</span>
blacklist pcspkr
</code></pre></div><p><strong>注意：</strong> <code>blacklist</code> 命令将屏蔽一个模板，所以不会自动装入，但是如果其它非屏蔽模块需要这个模块，系统依然会装入它。</p>
<p>要避免这个行为，可以让 modprobe 使用自定义的 <code>install</code> 命令，而不是像往常一样将模块插入内核，因此您可以通过以下方式强制模块始终无法加载：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo gedit /etc/modprobe.d/blacklist.conf
...
install MODULE /bin/true
...
</code></pre></div><p>这样就可以 &ldquo;屏蔽&rdquo; 模块及所有依赖它的模块。</p>
<h5 id="使用内核命令行-1">使用内核命令行<a hidden class="anchor" aria-hidden="true" href="#使用内核命令行-1">#</a></h5>
<p><strong>提示：</strong> 如果模块损坏导致无法引导系统，这将非常有用。</p>
<p>您也可以从引导加载程序中将模块列入黑名单。</p>
<p>如<a href="https://wiki.archlinux.org/title/Kernel_parameters_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Kernel参数</a>.中所述，只需将<code>module_blacklist=modname1,modname2,modname3</code> 添加到引导加载程序的内核行中即可。</p>
<p><strong>注意：</strong> 将多个模块列入黑名单时，请注意，它们之间仅用逗号分隔。 空格或其他内容可能会破坏语法。</p>
<h3 id="kernel-parameters">Kernel parameters<a hidden class="anchor" aria-hidden="true" href="#kernel-parameters">#</a></h3>
<p>一共有三种办法，可以给内核传递参数，用于控制其行为方式：</p>
<ol>
<li>在编译内核时（这个最根本，会决定后面两种方法）</li>
<li>内核启动时(通常是在一个启动管理器里设置).</li>
<li>在运行时 (通过修改在 <code>/proc</code> 和 <code>/sys</code>中的文件).</li>
</ol>
<p>本页面主要是讲第二种方法。</p>
<h4 id="配置-2">配置<a hidden class="anchor" aria-hidden="true" href="#配置-2">#</a></h4>
<p>内核参数可以在启动时临时修改，也可以永久性写到启动管理器的配置文件中，永远起作用。</p>
<p>下面示例把参数<code>quiet</code> 和 <code>splash</code> 加到启动管理器。</p>
<h5 id="systemd-boot">systemd-boot<a hidden class="anchor" aria-hidden="true" href="#systemd-boot">#</a></h5>
<ul>
<li>
<p>当启动菜单出现时 按 <code>e</code>进入编辑界面:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">initrd<span style="color:#f92672">=</span><span style="color:#ae81ff">\i</span>nitramfs-linux.img root<span style="color:#f92672">=</span>/dev/sda2 quiet splash
</code></pre></div></li>
<li>
<p>如果想永久加入参数，编辑 <code>/boot/loader/entries/arch.conf</code> (假设你已经设置好了 <a href="https://wiki.archlinux.org/title/EFI_system_partition_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">EFI system partition</a>) 的<code>options</code> 行:</p>
</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>如果没有设置显示启动菜单, 你需要按住<code>Space</code>启动电脑来进入启动菜单 。</li>
<li>如果不能够从启动菜单上进行编辑，修改 <code>/boot/loader/loader.conf</code> 加入 <code>editor 1</code> 来开启编辑功能。</li>
</ul>
<p>更多信息请参见 <a href="https://wiki.archlinux.org/title/Systemd-boot">systemd-boot</a> .</p>
<h5 id="grub">GRUB<a hidden class="anchor" aria-hidden="true" href="#grub">#</a></h5>
<ul>
<li>
<p>在菜单出现后按 <code>e</code> 然后将它们添加至 <code>linux</code> 行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">linux /boot/vmlinuz-linux root<span style="color:#f92672">=</span>UUID<span style="color:#f92672">=</span>978e3e81-8048-4ae1-8a06-aa727458e8ff ro quiet splash
</code></pre></div><p>按 b 以便用这些参数启动。</p>
</li>
<li>
<p>要使改变在重启后仍生效，您<em>可以</em>手动编辑 <code>/boot/grub/grub.cfg</code> 中的如上内容。对于初学者，建议编辑 <code>/etc/default/grub</code> 并将您的内核选项添加至 <code>GRUB_CMDLINE_LINUX_DEFAULT</code> 行：</p>
<pre tabindex="0"><code>GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash&quot;
</code></pre><p>然后重新生成 <code>grub.cfg</code> 文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># grub-mkconfig -o /boot/grub/grub.cfg</span>
</code></pre></div></li>
</ul>
<p>有关配置GRUB的更多信息，请参阅 <a href="https://wiki.archlinux.org/title/GRUB">GRUB</a> 。</p>
<h3 id="发布时间表httpslinuxcnarticle-13963-1html"><a href="https://linux.cn/article-13963-1.html">发布时间表</a><a hidden class="anchor" aria-hidden="true" href="#发布时间表httpslinuxcnarticle-13963-1html">#</a></h3>
<h4 id="内核发布时间表有吗">内核发布时间表：有吗？<a hidden class="anchor" aria-hidden="true" href="#内核发布时间表有吗">#</a></h4>
<p>短的回答是，每两到三个月就有一个新的内核版本发布。长的回答是，这不是一个硬性规定。</p>
<p>这个意思是，你经常会看到每两到三个月就有一个新的内核版本发布。这是内核维护者团队的目标，但并没有规定新版本必须在前一个版本的 8 周后准时发布的期限。</p>
<p>新的内核版本（通常）是由 Linus Torvalds 在它准备好的时候发布的。通常是每 2 到 3 个月发布一次。该版本被宣布为“稳定”，一般以 X.Y 的格式编号。</p>
<p>但这并不是 X.Y 开发的结束。稳定版会有更多的小版本以进行错误的修复。这些小版本在稳定版的内核上又增加了一个点，就像是 X.Y.Z。</p>
<p>虽然 X.Y（通常）是由 Linux 创造者 Linus Torvalds 发布的，但是维护稳定的 X.Y 内核、合并错误修复和发布 X.Y.Z 版本的责任是由另外的内核开发者负责的。</p>
<h4 id="一个内核版本支持多长时间">一个内核版本支持多长时间？<a hidden class="anchor" aria-hidden="true" href="#一个内核版本支持多长时间">#</a></h4>
<p>和发布一样，一个内核版本支持多长时间也没有固定的日期和时间表。</p>
<p>一个普通的稳定内核版本通常会被支持两个半月到三个月，这取决于下一个稳定内核版本的发布时间。</p>
<p>例如，稳定版内核 5.14 会在稳定版内核 5.15 发布后的几周内达到生命末期。结束支持是由该稳定内核版本的维护者在 Linux 内核邮件列表中宣布的。用户和贡献者会被要求切换到新发布的稳定版本。</p>
<p>但这只适用于正常的稳定内核版本，还有 LTS（长期支持）内核版本，它们的支持期要比 3 个月长得多。</p>
<h4 id="lts-内核它支持多长时间">LTS 内核：它支持多长时间？<a hidden class="anchor" aria-hidden="true" href="#lts-内核它支持多长时间">#</a></h4>
<p>LTS 内核也没有固定的发布时间表。通常，每年都有一个 LTS 内核版本，一般是当年的最后一个版本，它至少会被支持两年。但同样，这里也没有固定的规则。</p>
<p>LTS 内核的维护者可以同意某个 LTS 内核的维护时间超过通常的两年。这个协议是根据必要性和参与的人员来达成的。</p>
<p>这种情况经常发生在 Android 项目中。由于两年的时间不足以让制造商结束对他们的硬件和软件功能的支持，你经常会发现一些 LTS 内核会被支持六年之久。</p>
<p><img loading="lazy" src="/Distributions/104702q7swhiybninishib.png" alt=""  />
</p>
<p>你可以 <a href="https://www.kernel.org/category/releases.html">在 Linux 内核网站上</a> 找到这个信息。</p>
<h4 id="你的发行版可能没有跟随通常的-linux-内核版本">你的发行版可能没有跟随通常的 Linux 内核版本<a hidden class="anchor" aria-hidden="true" href="#你的发行版可能没有跟随通常的-linux-内核版本">#</a></h4>
<p>如果你检查你的 Linux 内核版本，你可能会发现 <a href="https://itsfoss.com/why-distros-use-old-kernel/">你的发行版使用了一个旧的内核</a>。也有可能该发行版提供的内核已经在内核网站上被标记为到达了生命末期。</p>
<p>不要惊慌。你的发行版会负责修补内核的错误和漏洞。除非你真的在使用一个不知名的 Linux 发行版，否则你可以相信你的发行版会保持它的安全和健全。</p>
<p>如果你有足够的理由，比如为了支持更新的硬件，你可以自由地在你使用的任何发行版或 <a href="https://itsfoss.com/upgrade-linux-kernel-ubuntu/">Ubuntu 中安装最新的 Linux 内核</a> 。</p>
<p>如果你想了解更多细节，我已经 <a href="https://itsfoss.com/why-distros-use-old-kernel/">在这里解释了为什么你的发行版使用过时的 Linux 内核</a>。</p>
<h3 id="安装内核httpslinuxcnarticle-12125-1html"><a href="https://linux.cn/article-12125-1.html">安装内核</a><a hidden class="anchor" aria-hidden="true" href="#安装内核httpslinuxcnarticle-12125-1html">#</a></h3>
<p><strong>dpkg</strong></p>
<p>从 <a href="http://kernel.ubuntu.com/~kernel-ppa/mainline/">kernel.ubuntu.com</a> 网站手动下载可用的最新 Linux 内核：</p>
<ul>
<li>linux-image-X.Y.Z-generic-.deb</li>
<li>linux-modules-X.Y.Z-generic-.deb</li>
</ul>
<p>手动安装内核：</p>
<pre tabindex="0"><code>$ sudo dpkg --install *.deb
</code></pre><p>重启系统，使用新内核：</p>
<pre tabindex="0"><code>$ sudo reboot
</code></pre><p>检查是否如你所愿：</p>
<pre tabindex="0"><code>$ uname -r
</code></pre><p><strong>apt-get</strong></p>
<p>不同于上一个方法，这种方法会从 Ubuntu 官方仓库下载、安装内核版本：</p>
<p>运行：</p>
<pre tabindex="0"><code>$ sudo apt-get upgrade linux-image-generic
</code></pre><h4 id="xanmod-kernelhttpsplumzmearchives12014"><a href="https://plumz.me/archives/12014/">XanMod Kernel</a><a hidden class="anchor" aria-hidden="true" href="#xanmod-kernelhttpsplumzmearchives12014">#</a></h4>
<p>最新内核集成的一些新特性的确是可以提升性能的。xanmod 内核的安装可以去它们的<a href="https://xanmod.org/">官方网站</a>来查询，xanmod 内核的特性很多地方都有，官方也写的有很多，不过大多数还是以下几点：</p>
<ul>
<li>改善了 CPU 调度能力</li>
<li>改善了 I/O 的调度能力</li>
<li>增加了一些和性能有关的第三方补丁</li>
<li>使用了最新的 GCC 进行编译</li>
<li>使用了最新的 MicroCode</li>
</ul>
<p>安装的方式也比较简单，添加源并且更新安装就行了：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ echo <span style="color:#e6db74">&#39;deb http://deb.xanmod.org releases main&#39;</span> | sudo tee /etc/apt/sources.list.d/xanmod-kernel.list <span style="color:#f92672">&amp;&amp;</span> wget -qO - https://dl.xanmod.org/gpg.key | sudo apt-key add -
</code></pre></div><p>然后安装，我个人安装的是最新的 5.8.1 的 edge：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt update <span style="color:#f92672">&amp;&amp;</span> sudo apt install linux-xanmod-edge
</code></pre></div><p>安装完毕后还可以安装最新的微码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt update <span style="color:#f92672">&amp;&amp;</span> sudo apt install linux-xanmod
</code></pre></div><p>重启以应用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo reboot
</code></pre></div><h4 id="zenhttpswikiubuntucomzenkernelliquorix-kernelhttpsliquorixnet"><a href="https://wiki.ubuntu.com/ZenKernel">Zen</a>/<a href="https://liquorix.net/">Liquorix Kernel</a><a hidden class="anchor" aria-hidden="true" href="#zenhttpswikiubuntucomzenkernelliquorix-kernelhttpsliquorixnet">#</a></h4>
<ul>
<li>一些内核黑客合作的结果，是适合日常使用的优秀内核</li>
<li>以吞吐量和功耗为代价来换取性能</li>
<li>相对 linux 内核加入了 Fsync 功能。Fsync 是维尔福公司发布的一个可以帮助提升大量多线程应用运行帧率的特殊内核补丁，这对改善游戏性能有很大帮助。在一些采用 .Net 的 wine 游戏中会有 <a href="https://github.com/ValveSoftware/Proton/issues/3706#issuecomment-611595369">明显的性能提升</a></li>
<li>如果你使用英伟达显卡，记得更换驱动为相应的 dkms 版本。一般来说较新的显卡安装 nvidia-dkms 即可。DKMS，即 <strong>D</strong>ynamic <strong>K</strong>ernel <strong>M</strong>odule <strong>S</strong>ystem。可以使内核变更（如升级）后自动编译模块，适配新内核。</li>
</ul>
<p><a href="https://www.reddit.com/r/linuxquestions/comments/j7krma/questions_about_zen_kernel/">Questions about</a>: I&rsquo;m not a kernel expert, but my understanding is that there are different ways for the kernel to prioritize tasks to be processed by the CPU. Priority on a server or workstation is different from a gaming PC. The Zen (and Liquorix) kernel alters the way this is done to optimise for gaming and multimedia. From what I can tell, the difference between the Zen and Liquorix kernels is the scheduler used, but are otherwise the same. There&rsquo;s more info <a href="https://liquorix.net/">here</a>.</p>
<p><strong>Ubuntu Prerequisites:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo add-apt-repository ppa:damentz/liquorix <span style="color:#f92672">&amp;&amp;</span> sudo apt-get update
</code></pre></div><p>The Liquorix kernel can be installed by way of meta-packages. This will guarantee that the latest kernel is installed on every upgrade.</p>
<p><strong>64-bit:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt-get install linux-image-liquorix-amd64 linux-headers-liquorix-amd64
</code></pre></div><h4 id="可选内核httpswikiarchlinuxorgtitlekernel"><a href="https://wiki.archlinux.org/title/kernel">可选内核</a><a hidden class="anchor" aria-hidden="true" href="#可选内核httpswikiarchlinuxorgtitlekernel">#</a></h4>
<h3 id="切換内核httpsmeetrixioblogawschanging-default-ubuntu-kernelhtml"><a href="https://meetrix.io/blog/aws/changing-default-ubuntu-kernel.html">切換内核</a><a hidden class="anchor" aria-hidden="true" href="#切換内核httpsmeetrixioblogawschanging-default-ubuntu-kernelhtml">#</a></h3>
<p>可以通过修改 <code>/etc/default/grub</code> 中的 <code>GRUB_DEFAULT</code> 值来改变默认启动项。</p>
<p>查看 grub menu 目前的選項 ：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ grep -A100 submenu  /boot/grub/grub.cfg |grep menuentry
submenu <span style="color:#e6db74">&#39;Advanced options for Ubuntu&#39;</span> $menuentry_id_option <span style="color:#e6db74">&#39;gnulinux-advanced-4a67ec61-9cd5-4a26-b00f-9391a34c8a29&#39;</span> <span style="color:#f92672">{</span>
    menuentry <span style="color:#e6db74">&#39;Ubuntu, with Linux 4.4.0-1062-aws&#39;</span> --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option <span style="color:#e6db74">&#39;gnulinux-4.4.0-1062-aws-advanced-4a67ec61-9cd5-4a26-b00f-9391a34c8a29&#39;</span> <span style="color:#f92672">{</span>
    menuentry <span style="color:#e6db74">&#39;Ubuntu, with Linux 4.4.0-1062-aws (recovery mode)&#39;</span> --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option <span style="color:#e6db74">&#39;gnulinux-4.4.0-1062-aws-recovery-4a67ec61-9cd5-4a26-b00f-9391a34c8a29&#39;</span> <span style="color:#f92672">{</span>
    menuentry <span style="color:#e6db74">&#39;Ubuntu, with Linux 4.4.0-1061-aws&#39;</span> --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option <span style="color:#e6db74">&#39;gnulinux-4.4.0-1061-aws-advanced-4a67ec61-9cd5-4a26-b00f-9391a34c8a29&#39;</span> <span style="color:#f92672">{</span>
    menuentry <span style="color:#e6db74">&#39;Ubuntu, with Linux 4.4.0-1061-aws (recovery mode)&#39;</span> --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option <span style="color:#e6db74">&#39;gnulinux-4.4.0-1061-aws-recovery-4a67ec61-9cd5-4a26-b00f-9391a34c8a29&#39;</span> <span style="color:#f92672">{</span>
</code></pre></div><p>接下來修改 grub config 檔案：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo nano /etc/default/grup 
</code></pre></div><p>找到 GRUB_DEFAULT=0 ，將數字 0 改成想用來開機的 kernel，以這個例子來說：</p>
<ul>
<li>0 = &lsquo;Ubuntu, with Linux 4.4.0-1062-aws&rsquo; = &lsquo;gnulinux-4.4.0-1062-aws-advanced-4a67ec61-9cd5-4a26-b00f-9391a34c8a29&rsquo;</li>
<li>1 = &lsquo;Ubuntu, with Linux 4.4.0-1062-aws (recovery mode)&rsquo; = &lsquo;gnulinux-4.4.0-1062-aws-recovery-4a67ec61-9cd5-4a26-b00f-9391a34c8a29&rsquo;</li>
<li>2 = &lsquo;Ubuntu, with Linux 4.4.0-1061-aws&rsquo; = &lsquo;gnulinux-4.4.0-1061-aws-advanced-4a67ec61-9cd5-4a26-b00f-9391a34c8a29&rsquo;</li>
<li>3 = &lsquo;Ubuntu, with Linux 4.4.0-1061-aws (recovery mode)&rsquo; = &lsquo;gnulinux-4.4.0-1061-aws-recovery-4a67ec61-9cd5-4a26-b00f-9391a34c8a29&rsquo;</li>
</ul>
<p>GRUB 启动项序号从 <code>0</code> 开始计数，<code>0</code> 代表第一个启动项，也是上述选项的默认值，<code>1</code> 表示第二个启动项，以此类推。主菜单和子菜单项之间用 <code>&gt;</code> 隔开。</p>
<p>下面的例子启动的是主菜单项 &lsquo;Advanced options for Arch Linux&rsquo; 下子菜单的第三项：</p>
<ul>
<li>
<p>使用数字编号：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">GRUB_DEFAULT<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>
<span style="color:#75715e"># or</span>
GRUB_DEFAULT<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;1&gt;2&#34;</span>
</code></pre></div></li>
<li>
<p>使用<a href="https://wiki.archlinux.org/title/GRUB_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)/Tips_and_tricks_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E8%8F%9C%E5%8D%95%E6%9D%A1%E7%9B%AE">菜单标题</a>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">GRUB_DEFAULT<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Advanced options for Ubuntu&gt;Ubuntu, with Linux 4.4.0-1061-aws&#34;</span>
</code></pre></div></li>
<li>
<p>还可以这样：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-basic" data-lang="basic">GRUB_DEFAULT<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;gnulinux-advanced-4a67ec61-9cd5-4a26-b00f-9391a34c8a29&gt;gnulinux-4.4.0-1061-aws-advanced-4a67ec61-9cd5-4a26-b00f-9391a34c8a29&#34;</span>
</code></pre></div></li>
<li>
<p>更新 grup 設定：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo update-grub
$ sudo reboot
</code></pre></div></li>
</ul>
<h3 id="删除旧内核httpslinuxcnarticle-6245-1html"><a href="https://linux.cn/article-6245-1.html">删除旧内核</a><a hidden class="anchor" aria-hidden="true" href="#删除旧内核httpslinuxcnarticle-6245-1html">#</a></h3>
<p>随着时间的流逝，持续的内核更新会在系统中积聚大量的不再使用的内核，浪费你的磁盘空间。每个内核镜像和其相关联的模块/头文件会占用200-400MB的磁盘空间，因此由不再使用的内核而浪费的磁盘空间会快速地增加。</p>
<p>GRUB管理器为每个旧内核都维护了一个GRUB入口，以备你想要使用它们。</p>
<p>作为磁盘清理的一部分，如果你不再使用这些，你可以考虑清理掉这些镜像。</p>
<p>在删除旧内核之前，记住最好留有2个最近的内核（最新的和上一个版本），以防主要的版本出错。</p>
<p>在Ubuntu内核镜像包含了以下的包。</p>
<ul>
<li><strong>linux-image-</strong>: 内核镜像</li>
<li><strong>linux-image-extra-</strong>: 额外的内核模块</li>
<li><strong>linux-headers-</strong>: 内核头文件</li>
</ul>
<p>首先检查系统中安装的内核镜像。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ dpkg --list | grep linux-image
$ dpkg --list | grep linux-headers
</code></pre></div><p>在列出的内核镜像中，你可以移除一个特定的版本。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt-get purge linux-image-3.19.0-15
$ sudo apt-get purge linux-headers-3.19.0-15
</code></pre></div><p>上面的命令会删除内核镜像和它相关联的内核模块和头文件。</p>
<p>注意如果你还没有升级内核那么删除旧内核会自动触发安装新内核。这样在删除旧内核之后，GRUB配置会自动升级来移除GRUB菜单中相关GRUB入口。</p>
<p>如果你有很多没用的内核，你可以用shell表达式来一次性地删除多个内核。注意这个括号表达式只在bash或者兼容的shell中才有效。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt-get purge linux-image-3.19.0-<span style="color:#f92672">{</span>18,20,21,25<span style="color:#f92672">}</span>
$ sudo apt-get purge linux-headers-3.19.0-<span style="color:#f92672">{</span>18,20,21,25<span style="color:#f92672">}</span>
</code></pre></div><p>上面的命令会删除4个内核镜像：3.19.0-18、3.19.0-20、3.19.0-21 和 3.19.0-25。</p>
<p>如果GRUB配置由于任何原因在删除旧内核后没有正确升级，你可以尝试手动用update-grub2命令来更新配置。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo update-grub2
</code></pre></div><p>现在就重启来验证GRUB菜单是否已经正确清理了。</p>
<h3 id="编写第一个内核模块httpslinuxcnarticle-3251-1html"><a href="https://linux.cn/article-3251-1.html">编写第一个内核模块</a><a hidden class="anchor" aria-hidden="true" href="#编写第一个内核模块httpslinuxcnarticle-3251-1html">#</a></h3>
<h2 id="容器">容器<a hidden class="anchor" aria-hidden="true" href="#容器">#</a></h2>
<h3 id="namespacehttpswwwcnblogscomsparkdevp9365405html"><a href="https://www.cnblogs.com/sparkdev/p/9365405.html">Namespace</a><a hidden class="anchor" aria-hidden="true" href="#namespacehttpswwwcnblogscomsparkdevp9365405html">#</a></h3>
<h4 id="概念">概念<a hidden class="anchor" aria-hidden="true" href="#概念">#</a></h4>
<p>**namespace 是 Linux 内核用来隔离内核资源的方式。**通过 namespace 可以让一些进程只能看到与自己相关的一部分资源，而另外一些进程也只能看到与它们自己相关的资源，这两拨进程根本就感觉不到对方的存在。具体的实现方式是把一个或多个进程的相关资源指定在同一个 namespace 中。</p>
<p>Linux namespaces 是对全局系统资源的一种封装隔离，使得处于不同 namespace 的进程拥有独立的全局系统资源，改变一个 namespace 中的系统资源只会影响当前 namespace 里的进程，对其他 namespace 中的进程没有影响。</p>
<h4 id="用途">用途<a hidden class="anchor" aria-hidden="true" href="#用途">#</a></h4>
<p>实际上，Linux 内核实现 namespace 的一个主要目的就是实现轻量级虚拟化(容器)服务。在同一个 namespace 下的进程可以感知彼此的变化，而对外界的进程一无所知。这样就可以让容器中的进程产生错觉，认为自己置身于一个独立的系统中，从而达到隔离的目的。也就是说 linux 内核提供的 namespace 技术为 docker 等容器技术的出现和发展提供了基础条件。</p>
<p>我们可以从 docker 实现者的角度考虑该如何实现一个资源隔离的容器。比如是不是可以通过 chroot 命令切换根目录的挂载点，从而隔离文件系统。为了在分布式的环境下进行通信和定位，容器必须要有独立的 IP、端口和路由等，这就需要对网络进行隔离。同时容器还需要一个独立的主机名以便在网络中标识自己。接下来还需要进程间的通信、用户权限等的隔离。最后，运行在容器中的应用需要有进程号(PID)，自然也需要与宿主机中的 PID 进行隔离。也就是说这六种隔离能力是实现一个容器的基础，让我们看看 linux 内核的 namespace 特性为我们提供了什么样的隔离能力：</p>
<p><img loading="lazy" src="/Distributions/952033-20180725130447798-998138444.png" alt=""  />
</p>
<p>上表中的前六种 namespace 正是实现容器必须的隔离技术，至于新近提供的 Cgroup namespace 目前还没有被 docker 采用。相信在不久的将来各种容器也会添加对 Cgroup namespace 的支持。</p>
<h4 id="发展历史">发展历史<a hidden class="anchor" aria-hidden="true" href="#发展历史">#</a></h4>
<p>Linux 在很早的版本中就实现了部分的 namespace，比如内核 2.4 就实现了 mount namespace。大多数的 namespace 支持是在内核 2.6 中完成的，比如 IPC、Network、PID、和 UTS。还有个别的 namespace 比较特殊，比如 User，从内核 2.6 就开始实现了，但在内核 3.8 中才宣布完成。同时，随着 Linux 自身的发展以及容器技术持续发展带来的需求，也会有新的 namespace 被支持，比如在内核 4.6 中就添加了 Cgroup namespace。</p>
<p>Linux 提供了多个 API 用来操作 namespace，它们是 clone()、setns() 和 unshare() 函数，为了确定隔离的到底是哪项 namespace，在使用这些 API 时，通常需要指定一些调用参数：CLONE_NEWIPC、CLONE_NEWNET、CLONE_NEWNS、CLONE_NEWPID、CLONE_NEWUSER、CLONE_NEWUTS 和 CLONE_NEWCGROUP。如果要同时隔离多个 namespace，可以使用 | (按位或)组合这些参数。同时我们还可以通过 /proc 下面的一些文件来操作 namespace。</p>
<p><strong>查看进程所属的 namespace</strong></p>
<p>从版本号为 3.8 的内核开始，<code>/proc/[pid]/ns</code> 目录下会包含进程所属的 namespace 信息，使用下面的命令可以查看当前进程所属的 namespace 信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ll /proc/$$/ns
total <span style="color:#ae81ff">0</span>
lrwxrwxrwx <span style="color:#ae81ff">1</span> kurome kurome <span style="color:#ae81ff">0</span> Mar  <span style="color:#ae81ff">3</span> 11:33 cgroup -&gt; <span style="color:#e6db74">&#39;cgroup:[4026531835]&#39;</span>
lrwxrwxrwx <span style="color:#ae81ff">1</span> kurome kurome <span style="color:#ae81ff">0</span> Mar  <span style="color:#ae81ff">3</span> 11:33 ipc -&gt; <span style="color:#e6db74">&#39;ipc:[4026531839]&#39;</span>
lrwxrwxrwx <span style="color:#ae81ff">1</span> kurome kurome <span style="color:#ae81ff">0</span> Mar  <span style="color:#ae81ff">3</span> 11:33 mnt -&gt; <span style="color:#e6db74">&#39;mnt:[4026531840]&#39;</span>
lrwxrwxrwx <span style="color:#ae81ff">1</span> kurome kurome <span style="color:#ae81ff">0</span> Mar  <span style="color:#ae81ff">3</span> 11:33 net -&gt; <span style="color:#e6db74">&#39;net:[4026532008]&#39;</span>
lrwxrwxrwx <span style="color:#ae81ff">1</span> kurome kurome <span style="color:#ae81ff">0</span> Mar  <span style="color:#ae81ff">3</span> 11:33 pid -&gt; <span style="color:#e6db74">&#39;pid:[4026531836]&#39;</span>
lrwxrwxrwx <span style="color:#ae81ff">1</span> kurome kurome <span style="color:#ae81ff">0</span> Mar  <span style="color:#ae81ff">3</span> 11:33 pid_for_children -&gt; <span style="color:#e6db74">&#39;pid:[4026531836]&#39;</span>
lrwxrwxrwx <span style="color:#ae81ff">1</span> kurome kurome <span style="color:#ae81ff">0</span> Mar  <span style="color:#ae81ff">3</span> 11:33 time -&gt; <span style="color:#e6db74">&#39;time:[4026531834]&#39;</span>
lrwxrwxrwx <span style="color:#ae81ff">1</span> kurome kurome <span style="color:#ae81ff">0</span> Mar  <span style="color:#ae81ff">3</span> 11:33 time_for_children -&gt; <span style="color:#e6db74">&#39;time:[4026531834]&#39;</span>
lrwxrwxrwx <span style="color:#ae81ff">1</span> kurome kurome <span style="color:#ae81ff">0</span> Mar  <span style="color:#ae81ff">3</span> 11:33 user -&gt; <span style="color:#e6db74">&#39;user:[4026531837]&#39;</span>
lrwxrwxrwx <span style="color:#ae81ff">1</span> kurome kurome <span style="color:#ae81ff">0</span> Mar  <span style="color:#ae81ff">3</span> 11:33 uts -&gt; <span style="color:#e6db74">&#39;uts:[4026531838]&#39;</span>
</code></pre></div><p>首先，这些 namespace 文件都是链接文件。链接文件的内容的格式为 xxx:[inode number]。其中的 xxx 为 namespace 的类型，inode number 则用来标识一个 namespace，我们也可以把它理解为 namespace 的 ID。如果两个进程的某个 namespace 文件指向同一个链接文件，说明其相关资源在同一个 namespace 中。</p>
<p>其次，在 <code>/proc/[pid]/ns</code> 里放置这些链接文件的另外一个作用是，一旦这些链接文件被打开，只要打开的文件描述符(fd)存在，那么就算该 namespace 下的所有进程都已结束，这个 namespace 也会一直存在，后续的进程还可以再加入进来。</p>
<p>除了打开文件的方式，我们还可以通过文件挂载的方式阻止 namespace 被删除。比如我们可以把当前进程中的 uts 挂载到 <code>~/uts</code> 文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ touch ~/uts
$ sudo mount --bind /proc/$$/ns/uts ~/uts
</code></pre></div><p>使用 stat 命令检查下结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ stat ~/uts
</code></pre></div><p>很神奇吧，~/uts 的 inode 和链接文件中的 inode number 是一样的，它们是同一个文件。</p>
<h4 id="clone-函数">clone() 函数<a hidden class="anchor" aria-hidden="true" href="#clone-函数">#</a></h4>
<p>我们可以通过 clone() 在创建新进程的同时创建 namespace。clone() 在 C 语言库中的声明如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/* Prototype for the glibc wrapper function */</span>
<span style="color:#75715e">#define _GNU_SOURCE
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sched.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">clone</span>(<span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>fn)(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>), <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>child_stack, <span style="color:#66d9ef">int</span> flags, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg);
</code></pre></div><p>实际上，clone() 是在 C 语言库中定义的一个封装(wrapper)函数，它负责建立新进程的堆栈并且调用对编程者隐藏的 clone() 系统调用。Clone() 其实是 linux 系统调用 fork() 的一种更通用的实现方式，它可以通过 flags 来控制使用多少功能。一共有 20 多种 CLONE_ 开头的 falg(标志位) 参数用来控制 clone 进程的方方面面(比如是否与父进程共享虚拟内存等)，下面我们只介绍与 namespace 相关的 4 个参数：</p>
<ul>
<li>fn：指定一个由新进程执行的函数。当这个函数返回时，子进程终止。该函数返回一个整数，表示子进程的退出代码。</li>
<li>child_stack：传入子进程使用的栈空间，也就是把用户态堆栈指针赋给子进程的 esp 寄存器。调用进程(指调用 clone() 的进程)应该总是为子进程分配新的堆栈。</li>
<li>flags：表示使用哪些 CLONE_ 开头的标志位，与 namespace 相关的有CLONE_NEWIPC、CLONE_NEWNET、CLONE_NEWNS、CLONE_NEWPID、CLONE_NEWUSER、CLONE_NEWUTS 和 CLONE_NEWCGROUP。</li>
<li>arg：指向传递给 fn() 函数的参数。</li>
</ul>
<h4 id="setns-函数">setns() 函数<a hidden class="anchor" aria-hidden="true" href="#setns-函数">#</a></h4>
<p>通过 setns() 函数可以将当前进程加入到已有的 namespace 中。setns() 在 C 语言库中的声明如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#define _GNU_SOURCE
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sched.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">setns</span>(<span style="color:#66d9ef">int</span> fd, <span style="color:#66d9ef">int</span> nstype);
</code></pre></div><p>和 clone() 函数一样，C 语言库中的 setns() 函数也是对 setns() 系统调用的封装：</p>
<ul>
<li>fd：表示要加入 namespace 的文件描述符。它是一个指向 /proc/[pid]/ns 目录中文件的文件描述符，可以通过直接打开该目录下的链接文件或者打开一个挂载了该目录下链接文件的文件得到。</li>
<li>nstype：参数 nstype 让调用者可以检查 fd 指向的 namespace 类型是否符合实际要求。若把该参数设置为 0 表示不检查。</li>
</ul>
<p>前面我们提到：可以通过挂载的方式把 namespace 保留下来。保留 namespace 的目的是为以后把进程加入这个 namespace 做准备。在 docker 中，使用 docker exec 命令在已经运行着的容器中执行新的命令就需要用到 setns() 函数。为了把新加入的 namespace 利用起来，还需要引入 <a href="http://www.cnblogs.com/sparkdev/p/8214455.html">execve() 系列的函数</a>，该函数可以执行用户的命令，比较常见的用法是调用 /bin/bash 并接受参数运行起一个 shell。</p>
<h4 id="unshare-函数">unshare() 函数<a hidden class="anchor" aria-hidden="true" href="#unshare-函数">#</a></h4>
<p>通过 unshare 函数可以在原进程上进行 namespace 隔离。也就是创建并加入新的 namespace 。unshare() 在 C 语言库中的声明如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#define _GNU_SOURCE
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sched.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">unshare</span>(<span style="color:#66d9ef">int</span> flags);
</code></pre></div><p>和前面两个函数一样，C 语言库中的 unshare() 函数也是对 unshare() 系统调用的封装。调用 unshare() 的主要作用就是：不启动新的进程就可以起到资源隔离的效果，相当于跳出原先的 namespace 进行操作。</p>
<p>系统还默认提供了一个叫 unshare 的命令，其实就是在调用 unshare() 系统调用。下面的 demo 使用 unshare 命令把当前进程的 user namespace 设置成了 root：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ whoami
nick
$ unshare --map-root-user --user sh -c whoami
root
</code></pre></div><h3 id="cgroupshttpdockoneioarticle8433"><a href="http://dockone.io/article/8433">cgroups</a><a hidden class="anchor" aria-hidden="true" href="#cgroupshttpdockoneioarticle8433">#</a></h3>
<h4 id="简介-1">简介<a hidden class="anchor" aria-hidden="true" href="#简介-1">#</a></h4>
<p>说实话，一些未知的软件应用可能需要被控制或限制——至少是为了稳定性或者某种程度上的安全性。很多时候，一个bug或者仅仅只是烂代码就有可能破坏掉整个机器甚至可能削弱整个生态。幸运的是，有一种方式可以控制应用程序，Linux控制组（cgroups）是一个内核功能，用于限制、记录和隔离一个或多个进程对CPU、内存、磁盘I/O 以及网络的访问及使用。</p>
<p>即，cgroups(Control Groups) 是 linux 内核提供的一种机制，<strong>这种机制可以根据需求把一系列系统任务及其子任务整合(或分隔)到按资源划分等级的不同组内，从而为系统资源管理提供一个统一的框架</strong>。简单说，cgroups 可以限制、记录任务组所使用的物理资源。本质上来说，cgroups 是内核附加在程序上的一系列钩子(hook)，通过程序运行时对资源的调度触发相应的钩子以达到资源追踪和限制的目的。</p>
<p>控制组技术最初是由谷歌开发的，最终在2.6.24版本（2008年1月）中并入Linux内核主线。这项技术被部分重新设计，添加了kernfs（用于分割一些sysfs逻辑），这些改变被合并到3.15和3.16版本的内核中。</p>
<p>实现 cgroups 的主要目的是为不同用户层面的资源管理提供一个统一化的接口。从单个任务的资源控制到操作系统层面的虚拟化（Linux 容器或者LXC），cgroups 提供了四大功能：</p>
<ul>
<li><strong>资源限制</strong>：一个控制组可以配置成不能超过指定的内存限制或是不能使用超过一定数量的处理器或限制使用特定的外围设备。</li>
<li><strong>优先级</strong>：一个或者多个控制组可以配置成使用更少或者更多的CPU 时间片数量或者磁盘 IO 带宽，实际上就等同于控制了任务运行的优先级。</li>
<li><strong>记录</strong>：一个控制组的资源使用情况会被监督以及测量。</li>
<li><strong>控制</strong>：进程组可以被冻结，暂停或者重启。</li>
</ul>
<h4 id="概念httpswwwcnblogscomsparkdevp8296063html"><a href="https://www.cnblogs.com/sparkdev/p/8296063.html">概念</a><a hidden class="anchor" aria-hidden="true" href="#概念httpswwwcnblogscomsparkdevp8296063html">#</a></h4>
<p><strong>Task(任务)</strong> 在 linux 系统中，内核本身的调度和管理并不对进程和线程进行区分，只是根据 clone 时传入的参数的不同来从概念上区分进程和线程。这里使用 task 来表示系统的一个进程或线程。</p>
<p><strong>Cgroup(控制组)</strong> cgroups 中的资源控制以 cgroup 为单位实现。Cgroup 表示按某种资源控制标准划分而成的任务组，包含一个或多个子系统。一个任务可以加入某个 cgroup，也可以从某个 cgroup 迁移到另一个 cgroup。</p>
<p><strong>Subsystem(子系统)</strong> cgroups 中的子系统就是一个资源调度控制器(又叫 controllers)。比如 CPU 子系统可以控制 CPU 的时间分配，内存子系统可以限制内存的使用量。内核版本 4.10.0，支持的 subsystem 如下( <code>cat /proc/cgroups)</code>：</p>
<ul>
<li><strong>blkio</strong>     对块设备的 IO 进行限制。</li>
<li><strong>cpu</strong>      限制 CPU 时间片的分配，与 cpuacct 挂载在同一目录。</li>
<li><strong>cpuacct</strong>   生成 cgroup 中的任务占用 CPU 资源的报告，与 cpu 挂载在同一目录。</li>
<li><strong>cpuset</strong>    给 cgroup 中的任务分配独立的 CPU(多处理器系统) 和内存节点。</li>
<li><strong>devices</strong>   允许或禁止 cgroup 中的任务访问设备。</li>
<li><strong>freezer</strong>   暂停/恢复 cgroup 中的任务。</li>
<li><strong>hugetlb</strong>   限制使用的内存页数量。</li>
<li><strong>memory</strong>  对 cgroup 中的任务的可用内存进行限制，并自动生成资源占用报告。</li>
<li><strong>net_cls</strong>   使用等级识别符（classid）标记网络数据包，这让 Linux 流量控制器（tc 指令）可以识别来自特定 cgroup 任务的数据包，并进行网络限制。</li>
<li><strong>net_prio</strong>  允许基于 cgroup 设置网络流量(netowork traffic)的优先级。</li>
<li><strong>perf_event</strong> 允许使用 perf 工具来监控 cgroup。</li>
<li><strong>pids</strong>     限制任务的数量。</li>
</ul>
<p><strong>Hierarchy(层级)</strong> 层级有一系列 cgroup 以一个树状结构排列而成，每个层级通过绑定对应的子系统进行资源控制。层级中的 cgroup 节点可以包含零个或多个子节点，子节点继承父节点挂载的子系统。一个操作系统中可以有多个层级。</p>
<h4 id="接口">接口<a hidden class="anchor" aria-hidden="true" href="#接口">#</a></h4>
<p>（以下为 Ubuntu 20.04，内核 5.13.0-30-generic）</p>
<p>cgroups 以文件的方式提供应用接口，我们可以通过 mount 命令来查看 cgroups 默认的挂载点：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ mount | grep cgroup
tmpfs on /sys/fs/cgroup type tmpfs <span style="color:#f92672">(</span>ro,nosuid,nodev,noexec,mode<span style="color:#f92672">=</span>755,inode64<span style="color:#f92672">)</span>
cgroup on /sys/fs/cgroup/systemd type cgroup <span style="color:#f92672">(</span>rw,nosuid,nodev,noexec,relatime,xattr,name<span style="color:#f92672">=</span>systemd<span style="color:#f92672">)</span>
...
cgroup on /sys/fs/cgroup/cpuset type cgroup <span style="color:#f92672">(</span>rw,nosuid,nodev,noexec,relatime,cpuset<span style="color:#f92672">)</span>
</code></pre></div><p>第一行的 tmpfs 说明 <code>/sys/fs/cgroup</code> 目录下的文件都是存在于内存中的临时文件。</p>
<p>第二行的挂载点 <code>/sys/fs/cgroup/systemd</code> 用于 systemd 系统对 cgroups 的支持。</p>
<p>其余的挂载点则是内核支持的各个子系统的根级层级结构。</p>
<p>需要注意的是，在使用 systemd 系统的操作系统中，<code>/sys/fs/cgroup</code> 目录都是由 systemd 在系统启动的过程中挂载的，并且挂载为只读的类型。换句话说，系统是不建议我们在 <code>/sys/fs/cgroup</code> 目录下创建新的目录并挂载其它子系统的。这一点与之前的操作系统不太一样。</p>
<p>下面让我们来探索一下 <code>/sys/fs/cgroup</code> 目录及其子目录下都是些什么：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ls /sys/fs/cgroup 
blkio    cpu,cpuacct  freezer  misc              net_prio    rdma
cpu      cpuset       hugetlb  net_cls           perf_event  systemd
cpuacct  devices      memory   net_cls,net_prio  pids        unified
</code></pre></div><p><code>/sys/fs/cgroup</code> 目录下是各个子系统的根目录。我们以 memory 子系统为例，看看 memory 目录下都有什么？</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ls /sys/fs/cgroup/memory
cgroup.clone_children               memory.memsw.limit_in_bytes
cgroup.event_control                memory.memsw.max_usage_in_bytes
cgroup.procs                        memory.memsw.usage_in_bytes
cgroup.sane_behavior                memory.move_charge_at_immigrate
memory.failcnt                      memory.numa_stat
memory.force_empty                  memory.oom_control
memory.kmem.failcnt                 memory.pressure_level
memory.kmem.limit_in_bytes          memory.soft_limit_in_bytes
memory.kmem.max_usage_in_bytes      memory.stat
memory.kmem.slabinfo                memory.swappiness
memory.kmem.tcp.failcnt             memory.usage_in_bytes
memory.kmem.tcp.limit_in_bytes      memory.use_hierarchy
memory.kmem.tcp.max_usage_in_bytes  notify_on_release
memory.kmem.tcp.usage_in_bytes      release_agent
memory.kmem.usage_in_bytes          system.slice
memory.limit_in_bytes               tasks
memory.max_usage_in_bytes           user.slice
memory.memsw.failcnt
</code></pre></div><p>这些文件就是 cgroups 的 memory 子系统中的根级设置。比如 memory.limit_in_bytes 中的数字用来限制进程的最大可用内存，memory.swappiness 中保存着使用 swap 的权重等等。</p>
<h4 id="手动方法">手动方法<a hidden class="anchor" aria-hidden="true" href="#手动方法">#</a></h4>
<p>你可以直接或者间接（通过LXC、libvirt或者Docker）访问及管理控制组，这里我首先介绍使用sysfs以及<code>libgroups</code>库。接下来的示例需要你预先安装一个必须的包。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt-get install libcgroup1 cgroup-tools
</code></pre></div><p>我将使用一个简单的shell脚本文件test.sh作为示例应用程序，它将会在无限<code>while</code>循环中运行以下两个命令。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat test.sh
!/bin/shwhile <span style="color:#f92672">[</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">do</span>
    echo <span style="color:#e6db74">&#34;hello world&#34;</span>
    sleep <span style="color:#ae81ff">60</span>
<span style="color:#66d9ef">done</span>
</code></pre></div><p>安装必要的包后，你可以直接通过sysfs的目录结构来配置你的控制组，例如，要在内存子系统中创建一个叫做<code>foo</code>的控制组，只需要在<code>/sys/fs/cgroup/memory</code>底下新建一个叫做<code>foo</code>的目录：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo mkdir /sys/fs/cgroup/memory/foo
</code></pre></div><p>在我们使用 cgroups 时，最好不要直接在各个子系统的根目录下直接修改其配置文件。推荐的方式是为不同的需求在子系统树中定义不同的节点。</p>
<p>cgroups 的文件系统会在创建文件目录的时候自动创建配置文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ls /sys/fs/cgroup/memory/foo 
cgroup.clone_children               memory.memsw.failcnt
cgroup.event_control                memory.memsw.limit_in_bytes
cgroup.procs                        memory.memsw.max_usage_in_bytes
memory.failcnt                      memory.memsw.usage_in_bytes
memory.force_empty                  memory.move_charge_at_immigrate
memory.kmem.failcnt                 memory.numa_stat
memory.kmem.limit_in_bytes          memory.oom_control
memory.kmem.max_usage_in_bytes      memory.pressure_level
memory.kmem.slabinfo                memory.soft_limit_in_bytes
memory.kmem.tcp.failcnt             memory.stat
memory.kmem.tcp.limit_in_bytes      memory.swappiness
memory.kmem.tcp.max_usage_in_bytes  memory.usage_in_bytes
memory.kmem.tcp.usage_in_bytes      memory.use_hierarchy
memory.kmem.usage_in_bytes          notify_on_release
memory.limit_in_bytes               tasks
memory.max_usage_in_bytes
</code></pre></div><p>默认情况下，每个新建的控制组将会继承对系统整个内存池的访问权限。但对于某些应用程序，这些程序拒绝释放已分配的内存并继续分配更多内存，这种默认继承方式显然不是个好主意。要使程序的内存限制变得更为合理，你需要更新文件<code>memory.limit_in_bytes</code>。</p>
<p>限制控制组<code>foo</code>下运行的任何应用的内存上限为50MB：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ echo <span style="color:#ae81ff">50000000</span> | sudo tee /sys/fs/cgroup/memory/foo/memory.limit_in_bytes
</code></pre></div><p>验证设置：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo cat memory.limit_in_bytes
<span style="color:#ae81ff">49999872</span>
</code></pre></div><p>请注意，回读的值始终是内核页面大小的倍数（即4096字节或4KB）。这个值是<strong>内存的最小可分配大小</strong>。</p>
<p>启动应用程序test.sh：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sh ~/test.sh 
</code></pre></div><p>使用进程ID（PID），将应用程序移动到<code>内存</code>控制器底下的控制组<code>foo</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ echo <span style="color:#ae81ff">2152</span> | sudo tee /sys/fs/cgroup/memory/foo/cgroup.procs
</code></pre></div><p>使用相同的PID，列出正在运行的进程并验证它是否在正确的控制组下运行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ps -o cgroup <span style="color:#ae81ff">2152</span>
CGROUP
5:devices:/user.slice,4:pids:/user.slice/user-1000.slice/user@1000.service,3:m...
</code></pre></div><p>或者通过 <code>/proc/[pid]/cgroup</code> 来查看指定进程属于哪些 cgroup：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat /proc/2152/cgroup
13:cpuset:/
12:blkio:/
11:misc:/
10:rdma:/
9:freezer:/
8:cpu,cpuacct:/
7:perf_event:/
6:hugetlb:/
5:devices:/user.slice
4:pids:/user.slice/user-1000.slice/user@1000.service
3:memory:/foo <span style="color:#75715e">#here</span>
2:net_cls,net_prio:/
1:name<span style="color:#f92672">=</span>systemd:/user.slice/user-1000.slice/user@1000.service/gnome<span style="color:#ae81ff">\x</span>2dsession<span style="color:#ae81ff">\x</span>2dmanager.slice/gnome-session-manager@ubuntu.service
0::/user.slice/user-1000.slice/user@1000.service/gnome<span style="color:#ae81ff">\x</span>2dsession<span style="color:#ae81ff">\x</span>2dmanager.slice/gnome-session-manager@ubuntu.service
</code></pre></div><p>每一行包含用冒号隔开的三列，他们的含义分别是：</p>
<ul>
<li>cgroup 树的 ID， 和 /proc/cgroups 文件中的 ID 一一对应。</li>
<li>和 cgroup 树绑定的所有 subsystem，多个 subsystem 之间用逗号隔开。这里 name=systemd 表示没有和任何 subsystem 绑定，只是给他起了个名字叫 systemd。</li>
<li>进程在 cgroup 树中的路径，即进程所属的 cgroup，这个路径是相对于挂载点的相对路径。</li>
</ul>
<p>你还可以通过读取文件来监控控制组正在使用的资源。在这种情况下，你可以查看你的进程（以及生成的子进程）被分配的内存大小。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat /sys/fs/cgroup/memory/foo/memory.usage_in_bytes
<span style="color:#ae81ff">188416</span>
</code></pre></div><h4 id="当进程迷路时">当进程“迷路”时<a hidden class="anchor" aria-hidden="true" href="#当进程迷路时">#</a></h4>
<p>现在让我们重新创建相同的场景，但这次我们将控制组<code>foo</code>的内存限制从50MB改为500 bytes：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ echo <span style="color:#ae81ff">500</span> | sudo tee /sys/fs/cgroup/memory/foo/memory.limit_in_bytes
</code></pre></div><p><em>注意：如果任务超出其定义的限制，内核将进行干预，并在某些情况下终止该任务</em>。</p>
<p>同样，当您重新读取值时，它将始终是内核页面大小的倍数。因此，虽然您将其设置为500字节，但它实际上被设置为4 KB：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat /sys/fs/cgroup/memory/foo/memory.limit_in_bytes
<span style="color:#ae81ff">4096</span>
</code></pre></div><p>启动应用程序test.sh，将其移动到控制组下并监视系统日志：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo tail -f /var/log/messages
...
</code></pre></div><p>请注意，内核的Out-Of-Mempry Killer（也叫做oom-killer 内存不足杀手）在应用程序达到4KB限制时就会介入。它会杀死应用程序，应用程序将不再运行，你可以通过输入以下命令进行验证：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ps -o cgroup <span style="color:#ae81ff">2152</span>
</code></pre></div><h4 id="使用libcgroup">使用libcgroup<a hidden class="anchor" aria-hidden="true" href="#使用libcgroup">#</a></h4>
<p>之前描述的许多早期步骤都可以通过<code>libcgroup</code>包中提供的管理工具进行简化。例如，使用<code>cgcreate</code>二进制文件的单个命令即可创建sysfs条目和文件。</p>
<p>输入以下命令即可在<code>内存</code>子系统下创建一个叫做<code>foo</code>的控制组：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo cgcreate -g memory:foo
</code></pre></div><p><em>注意：libcgroup提供了一种管理控制组中任务的机制。</em></p>
<p>使用与之前相同的方法，你就可以开始设置内存阈值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ echo <span style="color:#ae81ff">50000000</span> | sudo tee /sys/fs/cgroup/memory/foo/memory.limit_in_bytes
</code></pre></div><p>验证新配置的设置：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo cat memory.limit_in_bytes
<span style="color:#ae81ff">50003968</span>
</code></pre></div><p>使用<code>cgexec</code>二进制文件在控制组<code>foo</code>中运行应用程序：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo cgexec -g memory:foo ~/test.sh
</code></pre></div><p>使用它的进程ID - PID来验证应用程序是否在控制组和子系统（<code>内存</code>）下运行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$  ps -o cgroup <span style="color:#ae81ff">2945</span>
CGROUP
6:memory:/foo,1:name<span style="color:#f92672">=</span>systemd:/user.slice/user-0.slice/session-1.scope
</code></pre></div><p>如果您的应用程序不再运行，并且您想要清理并删除控制组，则可以使用二进制文件<code>cgdelete</code>来执行此操作。要从<code>内存</code>控制器下删除控制组<code>foo</code>，请输入：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo cgdelete memory:foo
</code></pre></div><h4 id="持久组">持久组<a hidden class="anchor" aria-hidden="true" href="#持久组">#</a></h4>
<p>您也可以通过一个简单的配置文件和服务的启动来完成上述所有操作。您可以在<code>/etc/cgconfig.conf</code>文件中定义所有控制组名称和属性。以下为<code>foo</code>组添加了一些属性：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat /etc/cgconfig.conf
group foo <span style="color:#f92672">{</span>
    cpu <span style="color:#f92672">{</span>
        cpu.shares <span style="color:#f92672">=</span> 100;
    <span style="color:#f92672">}</span>
    memory <span style="color:#f92672">{</span>
        memory.limit_in_bytes <span style="color:#f92672">=</span> 5000000;
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span> 
</code></pre></div><p><code>cpu.shares</code>选项定义了该组的CPU优先级。默认情况下，所有组都继承1024 shares（CPU share指的是控制组中的任务被分配到的CPU的 time的优先级，即值越大，分配到的CPU time越多，这个值需大于等于2），即100%的CPU time（CPU time是CPU用于处理一个程序所花费的时间）。通过将<code>cpu.shares</code>的值降低到更保守的值（如100），这个组将会被限制只能使用大概10%的CPU time。</p>
<p>就如之前讨论的，在控制组中运行的进程也可以被限制它能访问的CPUs（内核）的数量。将以下部分添加到同一个配置文件<code>cgconfig.conf</code>中组名底下。</p>
<pre tabindex="0"><code>cpuset {
    cpuset.cpus=&quot;0-5&quot;;
} 
</code></pre><p>有了这个限制，这个控制组会将应用程序绑定到到0核到5核——也就是说，它只能访问系统上的前6个CPU核。</p>
<p>接下来，您需要使用<code>cgconfig</code>服务加载此配置。首先，启用cgconfig以在系统启动时能够加载上述配置：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo systemctl enable cgconfig
Create symlink from /etc/systemd/system/sysinit.target.wants/cgconfig.service
to /usr/lib/systemd/system/cgconfig.service.
</code></pre></div><p>现在，启动<code>cgconfig</code>服务并手动加载相同的配置文件（或者您可以跳过此步骤直接重启系统）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo systemctl start cgconfig
</code></pre></div><p>在控制组<code>foo</code>下启动该应用程序并将其绑定到您设置的内存和CPU限制：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo cgexec -g memory,cpu,cpuset:foo ~/test.sh &amp;
</code></pre></div><p>除了将应用程序启动到预定义的控制组之外，其余所有内容都将在系统重新启动后持续存在。但是，您可以通过定义依赖于<code>cgconfig</code>服务的启动初始脚本来启动该应用程序，自动执行该过程。</p>
<h4 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h4>
<p>通常来说，限制一个机器上一个或者多个任务的权限是必要的。控制组提供了这项功能，通过使用它，您可以对一些特别重要或无法控制的应用程序实施严格的硬件和软件限制。如果一个应用程序没有设置上限阈值或限制它可以在系统上消耗的内存量，cgroups可以解决这个问题。如果另一个应用程序没有CPU上的限制，那么cgroups可以再一次解决您的问题。您可以通过cgroup完成这么多工作，只需花一点时间，您就可以使用你的操作系统环境恢复稳定性，安全性和健全性。</p>
<h4 id="使用-systemdhttpswwwcnblogscomsparkdevp9523194html"><a href="https://www.cnblogs.com/sparkdev/p/9523194.html">使用 Systemd</a><a hidden class="anchor" aria-hidden="true" href="#使用-systemdhttpswwwcnblogscomsparkdevp9523194html">#</a></h4>
<p>当 Linux 的 init 系统发展到 systemd 之后，systemd 与 cgroups 发生了融合(或者说 systemd 提供了 cgroups 的使用和管理接口)。</p>
<p><strong>Systemd 依赖 cgroups</strong></p>
<p>要理解 systemd 与 cgroups 的关系，我们需要先区分 cgroups 的两个方面：<em>层级结构(A)和资源控制(B)</em>。首先 cgroups 是以层级结构组织并标识进程的一种方式，同时它也是在该层级结构上执行资源限制的一种方式。我们简单的把 cgroups 的层级结构称为 A，把 cgrpups 的资源控制能力称为 B。</p>
<p>对于 systemd 来说，A 是必须的，如果没有 A，systemd 将不能很好的工作。而 B 则是可选的，如果你不需要对资源进行控制，那么在编译 Linux 内核时完全可以去掉 B 相关的编译选项。</p>
<p><strong>Systemd 默认挂载的 cgroups 系统</strong></p>
<p>在系统的开机阶段，systemd 会把支持的 controllers (subsystem 子系统)挂载到默认的 <code>/sys/fs/cgroup/</code> 目录下面，除了 systemd 目录外，其它目录都是对应的 subsystem。</p>
<p><code>/sys/fs/cgroup/systemd</code> 目录是 systemd 维护的自己使用的非 subsystem 的 cgroups 层级结构。换句话说就是，并不允许其它的程序动这个目录下的内容。其实 <code>/sys/fs/cgroup/systemd</code> 目录对应的 cgroups 层级结构就是 systemd 用来使用 cgoups 中 feature A 的。</p>
<p><strong>Cgroup 的默认层级</strong></p>
<p><em>过将 cgroup 层级系统与 systemd unit 树绑定，systemd 可以把资源管理的设置从进程级别移至应用程序级别。因此，我们可以使用 systemctl 指令，或者通过修改 systemd unit 的配置文件来管理 unit 相关的资源。</em></p>
<p>默认情况下，systemd 会自动创建 <strong>slice、scope 和 service</strong> unit 的层级来为 cgroup 树提供统一的层级结构。</p>
<p>系统中运行的所有进程，都是 systemd init 进程的子进程。在资源管控方面，systemd 提供了三种 unit 类型：</p>
<ul>
<li><strong>service</strong>： 一个或一组进程，由 systemd 依据 unit 配置文件启动。service 对指定进程进行封装，这样进程可以作为一个整体被启动或终止。</li>
<li><strong>scope</strong>：一组外部创建的进程。由进程通过 fork() 函数启动和终止、之后被 systemd 在运行时注册的进程，scope 会将其封装。例如：用户会话、 容器和虚拟机被认为是 scope。</li>
<li><strong>slice</strong>： 一组按层级排列的 unit。slice 并不包含进程，但会组建一个层级，并将 scope 和 service 都放置其中。真正的进程包含在 scope 或 service 中。在这一被划分层级的树中，每一个 slice 单位的名字对应通向层级中一个位置的路径。</li>
</ul>
<p>以通过 systemd-cgls 命令来查看 cgroups 的层级结构</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">Control group /:
-.slice
├─419 bpfilter_umh
├─user.slice 
│ ├─user-125.slice 
│ │ ├─session-c1.scope 
│ │ │ ├─1101 gdm-session-worker <span style="color:#f92672">[</span>pam/gdm-launch-environment<span style="color:#f92672">]</span>
│ │ │ ├─1158 /usr/lib/gdm3/gdm-x-session dbus-run-session -- gnome-session -&gt;
│ │ │ ├─1160 /usr/lib/xorg/Xorg vt1 -displayfd <span style="color:#ae81ff">3</span> -auth /run/user/125/gdm/Xau&gt;
│ │ │ ├─1347 dbus-run-session -- gnome-session --autostart /usr/share/gdm/gr&gt;
│ │ │ ├─1348 dbus-daemon --nofork --print-address <span style="color:#ae81ff">4</span> --session
│ │ │ ├─1349 /usr/libexec/gnome-session-binary --systemd --autostart /usr/sh&gt;
│ │ │ ├─1352 /usr/libexec/at-spi-bus-launcher
│ │ │ ├─1357 /usr/bin/dbus-daemon --config-file<span style="color:#f92672">=</span>/usr/share/defaults/at-spi2/&gt;
│ │ │ ├─1378 /usr/bin/gnome-shell
│ │ │ ├─1432 ibus-daemon --panel disable --xim
│ │ │ ├─1435 /usr/libexec/ibus-dconf
│ │ │ ├─1438 /usr/libexec/ibus-x11 --kill-daemon
│ │ │ ├─1440 /usr/libexec/ibus-portal
│ │ │ ├─1451 /usr/libexec/at-spi2-registryd --use-gnome-session
</code></pre></div><p>service、scope 和 slice unit 被直接映射到 cgroup 树中的对象。当这些 unit 被激活时，它们会直接一一映射到由 unit 名建立的 cgroup 路径中。例如，cron.service 属于 system.slice，会直接映射到 cgroup system.slice/cron.service/ 中。
注意，所有的用户会话、虚拟机和容器进程会被自动放置在一个单独的 scope 单元中。</p>
<p>默认情况下，系统会创建四种 slice：</p>
<ul>
<li><strong>-.slice</strong>：根 slice</li>
<li><strong>system.slice</strong>：所有系统 service 的默认位置</li>
<li><strong>user.slice</strong>：所有用户会话的默认位置</li>
<li><strong>machine.slice</strong>：所有虚拟机和 Linux 容器的默认位置</li>
</ul>
<p><strong>创建临时的 cgroup</strong></p>
<p>对资源管理的设置可以是 transient(临时的)，也可以是 persistent (永久的)。我们先来介绍如何创建临时的 cgroup。</p>
<p>需要使用 <strong>systemd-run</strong> 命令创建临时的 cgroup，它可以创建并启动临时的 service 或 scope unit，并在此 unit 中运行程序。systemd-run 命令默认创建 service 类型的 unit，比如我们创建名称为 toptest 的 service 运行 top 命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo systemd-run --unit<span style="color:#f92672">=</span>toptest --slice<span style="color:#f92672">=</span>test top -b
</code></pre></div><p>然后查看一下 test.slice 的状态：</p>
<pre tabindex="0"><code>$ sudo systemctl status test.slice
</code></pre><p>创建了一个 test.slice/toptest.service cgroup 层级关系。再看看 toptest.service 的状态：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo systemctl status toptest.service
</code></pre></div><p>top 命令被包装成一个 service 运行在后台了！</p>
<p>接下来我们就可以通过 systemctl 命令来限制 toptest.service 的资源了。在限制前让我们先来看一看 top 进程的 cgroup 信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat /proc/2850/cgroup
</code></pre></div><p>比如我们限制 toptest.service 的 CPUShares 为 600，可用内存的上限为 550M：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo systemctl set-property toptest.service CPUShares<span style="color:#f92672">=</span><span style="color:#ae81ff">600</span> MemoryLimit<span style="color:#f92672">=</span>500M
</code></pre></div><p>再次检查 top 进程的 cgroup 信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat /proc/2850/cgroup
</code></pre></div><p>在 CPU 和 memory 子系统中都出现了 toptest.service 的名字。同时去查看 <code>/sys/fs/cgroup/memory/test.slice</code> 和 <code>/sys/fs/cgroup/cpu/test.slice</code> 目录，这两个目录下都多出了一个 toptest.service 目录。我们设置的 CPUShares=600 MemoryLimit=500M 被分别写入了这些目录下的对应文件中。</p>
<p><em>临时 cgroup 的特征是，所包含的进程一旦结束，临时 cgroup 就会被自动释放</em>。比如我们 kill 掉 top 进程，然后再查看 /sys/fs/cgroup/memory/test.slice 和 /sys/fs/cgroup/cpu/test.slice 目录，刚才的 toptest.service 目录已经不见了。</p>
<p><strong>通过配置文件修改 cgroup</strong></p>
<p>所有被 systemd 监管的 persistent cgroup(持久的 cgroup)都在 <code>/usr/lib/systemd/system/</code> 目录中有一个 unit 配置文件。比如我们常见的 service 类型 unit 的配置文件。我们可以通过设置 unit 配置文件来控制应用程序的资源，persistent cgroup 的特点是即便系统重启，相关配置也会被保留。需要注意的是，scope unit 不能以此方式创建。下面让我们为 cron.service 添加 CPU 和内存相关的一些限制，编辑 <code>/lib/systemd/system/cron.service</code> 文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo vim /lib/systemd/system/cron.service
<span style="color:#f92672">[</span>Service<span style="color:#f92672">]</span>
CPUShares<span style="color:#f92672">=</span><span style="color:#ae81ff">600</span>
MemoryLimit<span style="color:#f92672">=</span>500M
EnviromentFile<span style="color:#f92672">=</span>-/etc/default/cron
ExecStart<span style="color:#f92672">=</span>/usr/sbin/cron -f $EXTRA_OPTS
IgnoreSIGPIPE<span style="color:#f92672">=</span>false
KillMode<span style="color:#f92672">=</span>process
</code></pre></div><p>然后重新加载配置文件并重启 cron.service：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo systemctl daemon-reload
$ sudo systemctl restart cron.service
</code></pre></div><p>现在去查看 <code>/sys/fs/cgroup/memory/system.slice/cron.service/memory.limit_in_bytes</code> 和 <code>/sys/fs/cgroup/cpu/system.slice/cron.service/cpu.shares</code> 文件，是不是已经包含我们配置的内容了！</p>
<p><strong>通过 systemctl 命令修改 cgroup</strong></p>
<p>除了编辑 unit 的配置文件，还可以通过 systemctl set-property 命令来修改 cgroup，这种方式修该的配置也会在重启系统时保存下来。现在我们把 cron.service 的 CPUShares 改为 700：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo systemctl set-property cron.service CPUShares<span style="color:#f92672">=</span><span style="color:#ae81ff">700</span>
</code></pre></div><p>查看 <code>/sys/fs/cgroup/cpu/system.slice/cron.service/cpu.shares</code> 文件的内容应该是 700，重启系统后该文件的内容还是 700。</p>
<p><strong>Systemd-cgtop 命令</strong></p>
<p>类似于 top 命令，systemd-cgtop 命令显示 cgoups 的实时资源消耗情况。</p>
<p>通过它我们就可以分析应用使用资源的情况。</p>
<h3 id="lxchttpdockoneioarticle8631"><a href="http://dockone.io/article/8631">LXC</a><a hidden class="anchor" aria-hidden="true" href="#lxchttpdockoneioarticle8631">#</a></h3>
<p>LXC（Linux容器，Linux Container）相当于你运行了一个接近于裸机的虚拟机。这项技术始于2008年，LXC的大部分功能来自于Solaris容器（又叫做Solaries Zones）以及之前的FreeBSD jails技术。 LXC并不是创建一个成熟的虚拟机，而是创建了一个拥有自己进程程和网络空间的虚拟环境，使用命名空间来强制进程隔离并利用内核的控制组（cgroups）功能，该功能可以限制，计算和隔离一个或多个进程的CPU，内存，磁盘I / O和网络使用情况。 您可以将这种用户空间框架想像成是<code>chroot</code>的高级形式。</p>
<blockquote>
<p><code>chroot</code> 是一个改变当前运行进程以及其子进程的根目录的操作。一个运行在这种环境的程序无法访问根目录外的文件和命令。</p>
</blockquote>
<p>注意：LXC使用命名空间来强制进程隔离，同时利用内核的控制组来计算以及限制一个或多个进程的CPU，内存，磁盘I / O和网络使用。</p>
<p>但容器究竟是什么？简短的答案是容器将软件应用程序与操作系统分离，为用户提供干净且最小的Linux环境，与此同时在一个或多个隔离的“容器”中运行其他所有内容。容器的目的是启动一组有限数量的应用程序或服务（通常称为微服务），并使它们在独立的沙盒环境中运行。</p>
<p><img loading="lazy" src="../../../Distributions/4db26d0e1162aa7a8f61fd387d465f26.png" alt=""  />
</p>
<p>这种隔离可防止在给定容器内运行的进程监视或影响在另一个容器中运行的进程。此外，这些集装箱化服务不会影响或干扰主机。能够将分散在多个物理服务器上的许多服务合并为一个的想法是数据中心选择采用该技术的众多原因之一。</p>
<p>容器有以下几个特点：</p>
<ul>
<li>安全性：容器里可以运行网络服务，这可以限制安全漏洞或违规行为造成的损害。那些成功利用那个容器的一个或多个应用的安全漏洞的入侵者将会被限制在只能在那个容器中做一些操作。</li>
<li>隔离性：容器允许在同一物理机器上部署一个或多个应用程序，即使这些应用程序必须在不同的域下运行，每个域都需要独占访问其各自的资源。例如，通过将每个容器关联的不同IP地址，在不同容器中运行的多个应用程序可以绑定到同一物理网络接口。</li>
<li>虚拟化和透明性：容器为系统提供虚拟化环境，这个环境可以隐藏或限制系统底层的物理设备或系统配置的可见性。容器背后的一般原则是避免更改运行应用程序的环境，但解决安全性或隔离问题除外。</li>
</ul>
<h4 id="使用lxc的工具">使用LXC的工具<a hidden class="anchor" aria-hidden="true" href="#使用lxc的工具">#</a></h4>
<p>对于大多数现代Linux发行版，内核都启用了控制组，但您很可能仍需要安装LXC工具。</p>
<p>对于Ubuntu或Debian，只需键入：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo apt-get install lxc
</code></pre></div><p>现在，在开始使用这些工具之前，您需要配置您的环境。在此之前，您需要验证当前用户是否同时在<code>/etc/subuid</code>和<code>/etc/subgid</code>中定义了uid和gid：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat /etc/subuid
petros:100000:65536
$ cat /etc/subgid
petros:100000:65536
</code></pre></div><p>如果<code>~/.config/lxc</code>不存在，则创建该目录，并且把配置文件<code>/etc/lxc/default.conf</code>复制到<code>~/.config/lxc/default.conf.</code>，将以下两行添加到文件末尾：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">lxc.id_map <span style="color:#f92672">=</span> u <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">100000</span> <span style="color:#ae81ff">65536</span>
lxc.id_map <span style="color:#f92672">=</span> g <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">100000</span> <span style="color:#ae81ff">65536</span>
</code></pre></div><p>结果如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat ~/.config/lxc/default.conf
lxc.network.type <span style="color:#f92672">=</span> veth
lxc.network.link <span style="color:#f92672">=</span> lxcbr0
lxc.network.flags <span style="color:#f92672">=</span> up
lxc.network.hwaddr <span style="color:#f92672">=</span> 00:16:3e:xx:xx:xx
lxc.id_map <span style="color:#f92672">=</span> u <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">100000</span> <span style="color:#ae81ff">65536</span>
lxc.id_map <span style="color:#f92672">=</span> g <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">100000</span> <span style="color:#ae81ff">65536</span>
</code></pre></div><p>将以下命令添加到<code>/etc/lxc/lxc-usernet</code>文件末尾（把第一列换成你的username）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">petros veth lxcbr0 <span style="color:#ae81ff">10</span>
</code></pre></div><p>最快使这些配置生效的方法是重启或者将用户登出再登入。</p>
<p>重新登录后，请验证当前是否已加载veth网络驱动程序：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ lsmod | grep veth
veth                   <span style="color:#ae81ff">16384</span>  <span style="color:#ae81ff">0</span>
</code></pre></div><p>如果没有，请输入：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo modprobe veth
</code></pre></div><p>现在您可以使用LXC工具集来下载，运行，管理Linux容器。</p>
<p>接下来，下载容器镜像并将其命名为“example-container”。当您键入以下命令时，您将看到一长串许多Linux发行版和版本支持的容器：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo lxc-create -t download -n example-container
</code></pre></div><p>将会有三个弹出框让您分别选择发行版名称（distribution），版本号（release）以及架构（architecture）。请选择以下三个选项：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">Distribution: ubuntu
Release: xenial
Architecture: amd64
</code></pre></div><p>选择后点击<code>Enter</code>，rootfs将在本地下载并配置。出于安全原因，每个容器不附带OpenSSH服务器或用户帐户。同时也不会提供默认的root密码。要更改root密码并登录，必须在容器目录路径中运行lxc-attach或chroot（在启动之后）。</p>
<p>启动容器：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo lxc-start -n example-container -d
</code></pre></div><p><code>-d</code>选项表示隐藏容器，它会在后台运行。如果您想要观察boot的过程，只需要将<code>-d</code>换成<code>-F</code>。那么它将在前台运行，登录框出现时结束。</p>
<p>你可能会遇到如下错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo lxc-start -n example-container -d
lxc-start: tools/lxc_start.c: main: <span style="color:#ae81ff">366</span> The container
failed to start.
lxc-start: tools/lxc_start.c: main: <span style="color:#ae81ff">368</span> To get more details,
run the container in foreground mode.
lxc-start: tools/lxc_start.c: main: <span style="color:#ae81ff">370</span> Additional information
can be obtained by setting the --logfile and --logpriority
options.
</code></pre></div><p>如果你遇到了，您需要通过在前台运行lxc-start服务来调试它：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo lxc-start -n example-container -F
lxc-start: conf.c: instantiate_veth: <span style="color:#ae81ff">2685</span> failed to create veth
pair <span style="color:#f92672">(</span>vethQ4NS0B and vethJMHON2<span style="color:#f92672">)</span>: Operation not supported
lxc-start: conf.c: lxc_create_network: <span style="color:#ae81ff">3029</span> failed to
create netdev
lxc-start: start.c: lxc_spawn: <span style="color:#ae81ff">1103</span> Failed to create
the network.
lxc-start: start.c: __lxc_start: <span style="color:#ae81ff">1358</span> Failed to spawn
container <span style="color:#e6db74">&#34;example-container&#34;</span>.
lxc-start: tools/lxc_start.c: main: <span style="color:#ae81ff">366</span> The container failed
to start.
lxc-start: tools/lxc_start.c: main: <span style="color:#ae81ff">370</span> Additional information
can be obtained by setting the --logfile and --logpriority
options.
</code></pre></div><p>从以上示例，你可以看到模块<code>veth</code>没有被引入，在引入之后，将会解决这个问题。</p>
<p>之后，打开第二个terminal窗口，验证容器的状态。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo lxc-info -n example-container
Name:           example-container
State:          RUNNING
PID:            <span style="color:#ae81ff">1356</span>
IP:             10.0.3.28
CPU use:        0.29 seconds
BlkIO use:      16.80 MiB
Memory use:     29.02 MiB
KMem use:       <span style="color:#ae81ff">0</span> bytes
Link:           vethPRK7YU
TX bytes:      1.34 KiB
RX bytes:      2.09 KiB
Total bytes:   3.43 KiB
</code></pre></div><p>也可以通过另一种方式来查看所有安装的容器，运行命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo lxc-ls -f
NAME         STATE   AUTOSTART GROUPS IPV4      IPV6
example-container RUNNING <span style="color:#ae81ff">0</span>         -      10.0.3.28 -
</code></pre></div><p>但是问题是你仍然不能登录进去，你只需要直接attach到正在运行的容器，创建你的用户，使用<code>passwd</code>命令改变相关的密码。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo lxc-attach -n example-container
root@example-container:/#
root@example-container:/# useradd petros
root@example-container:/# passwd petros
Enter new UNIX password:
Retype new UNIX password:
passwd: password updated successfully
</code></pre></div><p>更改密码后，您将能够从控制台直接登录到容器，而无需使用<code>lxc-attach</code>命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo lxc-console -n example-container
</code></pre></div><p>如果要通过网络连接到此运行容器，请安装OpenSSH服务器：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># apt-get install openssh-server</span>
</code></pre></div><p>抓取容器的本地IP地址：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># ip addr show eth0|grep inet</span>
inet 10.0.3.25/24 brd 10.0.3.255 scope global eth0
inet6 fe80::216:3eff:fed8:53b4/64 scope link
</code></pre></div><p>然后在主机的新的控制台窗口中键入：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ssh 10.0.3.25
</code></pre></div><p>瞧！您现在可以SSH到正在运行的容器并键入您的用户名和密码。</p>
<p>在主机系统上，而不是在容器内，可以观察在启动容器后启动和运行的LXC进程：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ps aux | grep lxc | grep -v grep
...
</code></pre></div><p>要停止容器，请键入（在主机）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo lxc-stop -n example-container
</code></pre></div><p>停止后，验证容器的状态：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo lxc-ls -f
NAME         STATE   AUTOSTART GROUPS IPV4 IPV6
example-container STOPPED <span style="color:#ae81ff">0</span>         -      -    -

$ sudo lxc-info -n example-container
Name:           example-container
State:          STOPPED
</code></pre></div><p>要彻底销毁容器 - 即从主机system—type清除它：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo lxc-destroy -n example-container
Destroyed container example-container
</code></pre></div><p>销毁后，可以验证是否已将其删除：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo lxc-info -n example-container
example-container doesn<span style="color:#960050;background-color:#1e0010">&#39;</span>t exist
$ sudo lxc-ls -f
</code></pre></div><p>注意：如果您尝试销毁正在运行的容器，该命令将失败并告知您容器仍在运行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo lxc-destroy -n example-container
example-container is running
</code></pre></div><p>在销毁容器前必须先停止它。</p>
<h4 id="高级配置">高级配置<a hidden class="anchor" aria-hidden="true" href="#高级配置">#</a></h4>
<p>有时，可能需要配置一个或多个容器来完成一个或多个任务。 LXC通过让管理员修改位于<code>/var/lib/lxc</code>中的容器配置文件来简化这一过程：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo su
<span style="color:#75715e"># cd /var/lib/lxc</span>
<span style="color:#75715e"># ls</span>
example-container
</code></pre></div><p>容器的父目录将包含至少两个文件：1）容器配置文件和 2）容器的整个rootfs：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># cd example-container/</span>
<span style="color:#75715e"># ls</span>
config  rootfs
</code></pre></div><p>假设您想要在主机系统启动时自动启动名称为<code>example-container</code>的容器。那么您需要将以下行添加到容器的配置文件<code>/var/lib/lxc/example-container/config</code>的尾部：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># Enable autostart</span>
lxc.start.auto <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</code></pre></div><p>重新启动容器或重新启动主机系统后，您应该看到如下内容：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo lxc-ls -f
NAME              STATE   AUTOSTART GROUPS IPV4      IPV6
example-container RUNNING <span style="color:#ae81ff">1</span>         -      10.0.3.25 -
</code></pre></div><p>注意 <code>AUTOSTART</code> 字段现在被设置为“1”。</p>
<p>如果在容器启动时，您希望容器绑定装载主机上的目录路径，请将以下行添加到同一文件的尾部：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 将挂载系统路径绑定到本地路径</span>
lxc.mount.entry <span style="color:#f92672">=</span> /mnt mnt none bind <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span>
</code></pre></div><p>通过上面的示例，当容器重新启动时，您将看到容器本地的 / mnt目录可访问的主机/ mnt目录的内容。</p>
<h4 id="特权与非特权容器">特权与非特权容器<a hidden class="anchor" aria-hidden="true" href="#特权与非特权容器">#</a></h4>
<p>您经常会发现在与LXC相关的内容中讨论特权容器和非特权容器的概念。但它们究竟是什么呢？这个概念非常简单，并且LXC容器可以在任一配置下运行。</p>
<p>根据设计，无特权容器被认为比特权容器更安全，更保密。无特权容器运行时，容器的root UID映射到主机系统上的非root UID。这使得攻击者即使破解了容器，也难以获得对底层主机的root权限。简而言之，如果攻击者设法通过已知的软件漏洞破坏了您的容器，他们会立即发现自己无法获取任何主机权限。</p>
<p>特权容器可能使系统暴露于此类攻击。这就是为什么我们最好在特权模式下运行尽量少的容器。确定需要特权访问的容器，并确保付出额外的努力来定期更新并以其他方式锁定它们。</p>
<h4 id="然而docker又是什么呢">然而，Docker又是什么呢？<a hidden class="anchor" aria-hidden="true" href="#然而docker又是什么呢">#</a></h4>
<p>我花了相当多的时间谈论Linux容器，但是Docker呢？它是生产中部署最多的容器解决方案。自首次推出以来，Docker已经风靡Linux计算世界。 Docker是一种Apache许可的开源容器化技术，旨在自动化在容器内创建和部署微服务这类重复性任务。 Docker将容器视为非常轻量级和模块化的虚拟机。最初，Docker是在LXC之上构建的，但它已经远离了这种依赖，从而带来了更好的开发人员和用户体验。与LXC非常相似，Docker继续使用内核<code>cgroup</code>子系统。该技术不仅仅是运行容器，还简化了创建容器，构建映像，共享构建的映像以及对其进行版本控制的过程。</p>
<p>Docker主要关注于：</p>
<ul>
<li>可移植性：Docker提供基于镜像的部署模型。这种类型的可移植性允许更简单的方式在多个环境中共享应用程序或服务集合（以及它们的所有依赖）。</li>
<li>版本控制：单个Docker镜像由一系列组合层组成。每当镜像被更改时，都会创建一个新层。例如，每次用户指定命令（例如运行或复制）时，都会创建一个新层。 Docker将重用这些层用于新的容器构建。分层到Docker是它自己的版本控制方法。</li>
<li>回滚：再次，每个Docker镜像都有很多层。如果您不想使用当前运行的层，则可以回滚到以前的版本。这种敏捷性使软件开发人员可以更轻松地持续集成和部署他们的软件技术。</li>
<li>快速部署：配置新硬件通常需要数天时间。并且，安装和配置它的工作量和开销是非常繁重的。使用Docker，您可以在几秒钟将镜像启动并运行，相比于之前，节省了大量的时间。当你使用完一个容器时，你可以轻松地销毁它。</li>
</ul>
<p>从本质上说，Docker和LXC都非常相似。它们都是用户空间和轻量级虚拟化平台，它们利用cgroup和命名空间来管理资源隔离。但是，两者之间也存在许多明显的差异。</p>
<h5 id="进程管理">进程管理<a hidden class="anchor" aria-hidden="true" href="#进程管理">#</a></h5>
<p>Docker将容器限制为单个进程运行。如果您的应用程序包含X个并发进程，Docker将要求您运行X个容器，每个容器都有自己单独的进程。 LXC不是这样，LXC运行具有传统init进程的容器，反过来，可以在同一容器内托管多个进程。例如，如果要托管LAMP（Linux + Apache + MySQL + PHP）服务器，每个应用程序的每个进程都需要跨越多个Docker容器。</p>
<h5 id="状态管理">状态管理<a hidden class="anchor" aria-hidden="true" href="#状态管理">#</a></h5>
<p>Docker被设计为无状态，意味着它不支持持久存储。有很多方法可以解决这个问题，但同样，只有在进程需要时才需要它。创建Docker镜像时，它将包含只读层。这不会改变。在运行时，如果容器的进程对其内部状态进行任何更改，则将保持内部状态和镜像的当前状态之间的差异，直到对Docker镜像进行提交（创建新层）或直到容器被删除，差异也会消失。</p>
<h5 id="可移植性">可移植性<a hidden class="anchor" aria-hidden="true" href="#可移植性">#</a></h5>
<p>在讨论Docker时，这个词往往被过度使用——因为它是Docker相对于LXC的最重要的优势。 Docker从应用程序中抽象出网络，存储和操作系统细节方面做得更好。这样就形成了一个真正独立于配置的应用程序，保证应用程序的环境始终保持不变，无论启用它的机器配置环境如何。</p>
<p>Docker旨在使开发人员和系统管理员都受益。它已成为许多DevOps（开发人员+维护人员）工具链中不可或缺的一部分。开发人员可以专注于编写代码，而无需担心最终托管它的系统是什么。使用Docker，无需安装和配置复杂数据库，也无需担心在不兼容的语言工具链版本之间切换。 Docker为维护人员提供了更多的灵活性，通常可以减少托管一些较小和更基本的应用程序所需的物理系统数量。 Docker简化了软件交付。新功能和错误/安全修复程序可以快速到达客户，无需任何麻烦，意外或停机。</p>
<h4 id="总结-1">总结<a hidden class="anchor" aria-hidden="true" href="#总结-1">#</a></h4>
<p>为了基础设施安全性和系统稳定性而隔离进程并不像听起来那么痛苦。 Linux内核提供了所有必要的工具，使简单易用的用户空间应用程序【如LXC（甚至Docker）】能够在隔离的沙盒环境中管理操作系统的微实例及其本地服务。</p>
<h3 id="沙箱httpshyperjnet20162016-11-23-linux-sandbox"><a href="https://hyperj.net/2016/2016-11-23-linux-sandbox/">沙箱</a><a hidden class="anchor" aria-hidden="true" href="#沙箱httpshyperjnet20162016-11-23-linux-sandbox">#</a></h3>
<p>在计算机安全领域，沙箱(Sandbox)是一种程序的隔离运行机制，其目的是限制不可信进程的权限。沙箱技术经常被用于执行未经测试的或不可信的客户程序。为了避免不可信程序可能破坏其它程序的运行，沙箱技术通过为不可信客户程序提供虚拟化的磁盘、内存以及网络资源，而这种虚拟化手段对客户程序来说是透明的。由于沙箱里的资源被虚拟化（或被间接化），所以沙箱里的不可信程序的恶意行为往往会被限制在沙箱中。</p>
<p>沙箱技术一直是系统安全领域的挑战，不存在说哪一种方案是足够安全的。沙箱技术方案通常是需要结合多种系统安全技术来实现，采用防御纵深(Defence in Depth)的设计原则，筑建多道防御屏障，尽可能地将安全风险将为最低。下面我们主要讨论如何利用Linux kernel所提供的安全功能来建立有效的沙箱技术。</p>
<p>在讨论之前，我们简单回顾一下Linux安全模型相关的内容（假设读者已经非常熟悉）：</p>
<p>(1) 每个进程都有自己的地址空间；</p>
<p>(2) MMU硬件机制来保证地址空间的隔离；</p>
<p>(3) Kernel是系统的TCB(Trusted Computing Base)，是安全策略的制定者和执行者；</p>
<p>(4) 进程是最小的权限边界；</p>
<p>(5) root具有最高权限，它能控制一切；</p>
<p>(6) 其它用户受DAC(Discretionary Access Control)限制，如文件系统的UGO权限控制。</p>
<p>进程是最小的权限边界，其根本原因是MMU能保证进程地址空间的隔离。</p>
<p>Linux Kernel还提供了与进程降权(drop privilege)相关的一些功能：</p>
<ol>
<li>setuid</li>
<li>POSIX.1e capability</li>
<li>chroot jail</li>
<li>Quota control (eg, cgroup, namespace)</li>
<li>Linux Container</li>
<li>Linux Security Module (LSM)</li>
</ol>
<p>下面我们会介绍如何在实践中利用这些诀窍来构建一个有效的sandbox.</p>
<h2 id="权限">权限<a hidden class="anchor" aria-hidden="true" href="#权限">#</a></h2>
<h3 id="ugohttpswwwcnblogscomsparkdevp9573355html"><a href="https://www.cnblogs.com/sparkdev/p/9573355.html">ugo</a><a hidden class="anchor" aria-hidden="true" href="#ugohttpswwwcnblogscomsparkdevp9573355html">#</a></h3>
<p>Linux 系统中文件的 ugo 权限是 Linux 进行权限管理的基本方式。</p>
<h4 id="所有者和组">所有者和组<a hidden class="anchor" aria-hidden="true" href="#所有者和组">#</a></h4>
<p>Linux 文件的 ugo 权限把对文件的访问者划分为三个类别：文件的所有者、组和其他人。所谓的 ugo 就是指 user(也称为 owner)、group 和 other 三个单词的首字母组合。</p>
<p>用户和组的信息分别记录在 <code>/etc/passwd</code>、<code>/etc/group</code> 文件中，这两个文件的内容是任何人都有权查看的，可以直接以读取文本文件的方式查看其内容，其中的每一行代表一个用户。</p>
<p><strong>文件的所有者</strong></p>
<p>文件的所有者一般是创建该文件的用户，对该文件具有完全的权限。在一台允许多个用户访问的 Linux 主机上，可以通过文件的所有者来区分一个文件属于某个用户。当然，一个用户也无权查看或更改其它用户的文件。</p>
<p><strong>文件所属的组</strong></p>
<p>假如有几个用户合作开发同一个项目，如果每个用户只能查看和修改自己创建的文件就太不方便了，也就谈不上什么合作了。所以需要一个机制允许一个用户查看和修改其它用户的文件，此时就用到组的概念的。我们可以创建一个组，然后把需要合作的用户都添加都这个组中。在设置文件的访问权限时，允许这个组中的用户对该文件进行读取和修改。</p>
<p><strong>其他人</strong></p>
<p>如果我想把一个文件共享给系统中的所有用户该怎么办？通过组的方式显然是不合适的，因为需要把系统中的所有用户都添加到一个组中。并且系统中添加了新用户该怎么办，每添加一个新用户就把他添加到这个组中吗？这个问题可以通过其他人的概念解决。在设置文件的访问权限时，允许其他人户对该文件进行读取和修改。</p>
<h4 id="文件属性">文件属性<a hidden class="anchor" aria-hidden="true" href="#文件属性">#</a></h4>
<p>使用 ll 命令可以查看文件的属性信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ll Desktop
drwxr-xr-x <span style="color:#ae81ff">2</span> nick nick 4.0K Mar  <span style="color:#ae81ff">2</span> 15:06 Desktop
</code></pre></div><ul>
<li>drwxr-xr-x 指明文件的类型和 ugo 权限信息。</li>
<li>2 是对文件的引用计数。</li>
<li>nick 是文件的所有者，文件的所有者一般是创建该文件的用户，对该文件具有完全的权限。</li>
<li>nick 是文件所属的组，我们通过 adduser 命令创建用户时一般会创建一个同名的组，该用户就属于与他同名的组(比如笔者机器上的用户 nick 就属于 nick 组)。当我们创建文件和目录时，其默认所属的组就是所有者所在的组。</li>
</ul>
<p>其它的信息我们暂时忽略。</p>
<p><strong>文件类型</strong></p>
<p>drwxr-xr-x 的第一个字符描述文件的类型，常见的类型有如下几种：</p>
<ul>
<li>d 表示目录</li>
<li>- 表示普通文件</li>
<li>l 表示链接文件</li>
<li>b 表示块设备文件</li>
<li>c 表示字符设备文件</li>
<li>s 表示 socket 文件</li>
</ul>
<p><strong>ugo 权限信息</strong></p>
<p>10 个字符，除去第一个表示文件类型的字符，其它 9 个字符表示文件的 ugo 权限信息</p>
<p><img loading="lazy" src="/Distributions/952033-20180902120612711-514991426.png" alt=""  />
</p>
<p>这 9 个字符以三个为一组，都是 rwx 或 - 的组合。其中，<em>r 代表可读(read)、 w 代表可写(write)、 x 代表可执行(execute)</em>。 这三个权限的位置不会改变，如果没有对应的权限，就会以 -(减号)代替。</p>
<p>*第一组为文件所有者的权限，第二组为文件所属组的权限，第三组为其他人的权限。*其表示的具体含义为：文件所有者具有对文件的读写权限，文件所属组的用户具有对文件读写的权限，而其他人只有读取文件的权限。</p>
<p>下面详细的解释一下文件读写执行的权限：</p>
<ul>
<li>r (read)：可以读取文件的实际内容，比如读取文本文件内的文字等。</li>
<li>w (write)：可以编辑、增加、删除文件的内容(但不含删除该文件)。</li>
<li>x (execute)：该文件具有可以被系统执行的权限。</li>
</ul>
<p>可以看出，对于文件来说，rwx 主要针对的是文件的内容。</p>
<p>对目录而言，目录中存储的主要是目录下文件名称的列表，这与普通文件是有些不同的：</p>
<ul>
<li>r (read contents in directory) 表示具有读取目录下文件名称的权限，也就是说你可以通过 ls 命令把目录下的文件列表查询出来。</li>
<li>w (modify contents of directory) 具有 w 权限表明你可以在该目录下执行如下的操作：
<ul>
<li>创建新的文件和目录</li>
<li>删除已经存在的文件与目录(不论该文件的权限为何!)</li>
<li>重命名已存在的文件或目录</li>
<li>移动该目录内文件、目录的位置</li>
</ul>
</li>
<li>x (access directory) 目录虽然不能被执行，但是却具有可以执行的权限。目录的 x 权限表示用户是否可以<em>进入该目标并成为当前的工作目录</em>。注意，如果用户对目录没有 x 权限，则无<em>法查看该目录下的文件的内容(注意与 r 权限的区别)</em>。</li>
</ul>
<p>综上，<em>如果要允许目录被其他人浏览时，至少要给予 r 和 x 的权限</em>。</p>
<h4 id="改变权限">改变权限<a hidden class="anchor" aria-hidden="true" href="#改变权限">#</a></h4>
<p>在新建文件时会根据创建者的身份和其它的一些设置为文件生成默认的权限。</p>
<p>接下来我们介绍如何通过命令修改文件权限相关的信息。</p>
<p><strong>改变文件所有者</strong></p>
<p>通过 chown 命令可以改变文件的所有者：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo chown tester testfile
</code></pre></div><p><strong>改变文件所属的组</strong></p>
<p>通过 chgrp 命令可以改变文件所属的组：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo chgrp tester testfile
</code></pre></div><p><strong>改变文件的权限</strong></p>
<p>通过 chmod 命令可以改变文件的权限。对于文件的 rwx 权限，有两种表示方法，数字表示法和字符表示法。</p>
<p>以数字表示权限的方式如下：</p>
<ul>
<li>r: 4</li>
<li>w: 2</li>
<li>x: 1</li>
</ul>
<p>如果是 rwx 权限就是 4 + 2 + 1 = 7 ，r-x 就是 4 + 1 = 5 ，&mdash; 则为 0。所以 rw-rw-r&ndash; 就可以用 664 来表示。如果我们想把文件的权限修改为 rwxrwxrwx，可以使用下面的命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ chmod <span style="color:#ae81ff">777</span> testfile
</code></pre></div><p>以字符表示权限的方式如下：用字符 u, g, o 分别代表文件所有者(user)、文件所属的组(group)和其他人(other)，这就是 ugo 权限叫法的由来。只不过还有一个 a 可以表示全部的身份(all)。具体更改权限的语法如下：</p>
<pre tabindex="0"><code>chmod [ugoa][+-=][rwx] 文件/目录
</code></pre><p>比如我们可以通过下面的命令把 testfile 的权限设为 rw-rw-r&ndash;：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ chmod ug<span style="color:#f92672">=</span>rw,o<span style="color:#f92672">=</span>r testfile
</code></pre></div><p>如果想去掉组的 w 权限并给其他人添加 x 权限可以执行下面的命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ chmod g-w,o+x testfile
</code></pre></div><p>我们还可通过 a 为全部身份设置权限，比如 rwx：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ chmod a<span style="color:#f92672">=</span>rwx testfile
</code></pre></div><h3 id="特殊权限suidsgidsbit"><a href="SUID/SGID/SBIT">特殊权限</a><a hidden class="anchor" aria-hidden="true" href="#特殊权限suidsgidsbit">#</a></h3>
<p>setuid 和 setgid 分别是 set uid ID upon execution 和 set group ID upon execution 的缩写。我们一般会再次把它们缩写为 suid 和 sgid。它们是控制文件访问的权限标志(flag)，它们分别允许用户以可执行文件的 owner 或 owner group 的权限运行可执行文件。</p>
<h4 id="suid">SUID<a hidden class="anchor" aria-hidden="true" href="#suid">#</a></h4>
<p>在 Linux 中，所有账号的密码记录在 <code>/etc/shadow</code> 这个文件中，并且只有 root 可以读写入这个文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ll /etc/shadow
-rw-r----- <span style="color:#ae81ff">1</span> root shadow 1.5K Feb <span style="color:#ae81ff">25</span> 12:46 /etc/shadow
</code></pre></div><p>如果另一个普通账号 tester 需要修改自己的密码，就要访问 <code>/etc/shadow</code> 这个文件。但是明明只有 root 才能访问 <code>/etc/shadow</code> 这个文件，这究竟是如何做到的呢？事实上，tester 用户是可以修改 <code>/etc/shadow</code> 这个文件内的密码的，就是通过 SUID 的功能。让我们看看 passwd 程序文件的权限信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ll /usr/bin/passwd 
-rwsr-xr-x <span style="color:#ae81ff">1</span> root root 67K Jul <span style="color:#ae81ff">15</span>  <span style="color:#ae81ff">2021</span> /usr/bin/passwd
</code></pre></div><p>上图红框中的权限信息有些奇怪，owner 的信息为 rws 而不是 rwx。当 s 出现在文件拥有者的 x 权限上时，就被称为 SETUID BITS 或 SETUID ，其特点如下：</p>
<ul>
<li>SUID 权限仅对二进制可执行文件有效</li>
<li>如果执行者对于该二进制可执行文件具有 x 的权限，执行者将具有该文件的所有者的权限</li>
<li>本权限仅在执行该二进制可执行文件的过程中有效</li>
</ul>
<p>下面我们来看 tester 用户是如何利用 SUID 权限完成密码修改的：</p>
<ol>
<li>tester 用户对于 /usr/bin/passwd 这个程序具有执行权限，因此可以执行 passwd 程序</li>
<li>passwd 程序的所有者为 root</li>
<li>tester 用户执行 passwd 程序的过程中会暂时获得 root 权限</li>
<li>因此 tester 用户在执行 passwd 程序的过程中可以修改 /etc/shadow 文件</li>
</ol>
<p>但是如果由 tester 用户执行 cat 命令去读取 <code>/etc/shadow</code> 文件确是不行的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ll /bin/cat
-rwxr-xr-x <span style="color:#ae81ff">1</span> root root 43K Sep  <span style="color:#ae81ff">5</span>  <span style="color:#ae81ff">2019</span> /bin/cat
</code></pre></div><p>原因很清楚，tester 用户没有读 /etc/shadow 文件的权限，同时 cat 程序也没有被设置 SUID。我们可以通过下图来理解这两种情况：</p>
<p><img loading="lazy" src="/Distributions/952033-20180915174007691-528388363.png" alt=""  />
</p>
<h4 id="sgid">SGID<a hidden class="anchor" aria-hidden="true" href="#sgid">#</a></h4>
<p>当 s 标志出现在用户组的 x 权限时称为 SGID。SGID 的特点与 SUID 相同，我们通过 <code>/usr/bin/mlocate</code> 程序来演示其用法。mlocate 程序通过查询数据库文件 <code>/var/lib/mlocate/mlocate.db</code> 实现快速的文件查找。 mlocate 程序的权限如下图所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ll /usr/bin/mlocate
-rwxr-sr-x <span style="color:#ae81ff">1</span> root mlocate <span style="color:#ae81ff">39520</span> Nov <span style="color:#ae81ff">18</span> <span style="color:#ae81ff">2014</span> /usr/bin/mlocate*
</code></pre></div><p>很明显，它被设置了 SGID 权限。下面是数据库文件 <code>/var/lib/mlocate/mlocate.db</code> 的权限信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ll /var/lib/mlocate/mlocate.db
-rw-r----- <span style="color:#ae81ff">1</span> root mlocate <span style="color:#ae81ff">12101109</span> Aug <span style="color:#ae81ff">13</span> 07:35 /var/lib/mlocate/mlocate.db
</code></pre></div><p>普通用户 tester 执行 mlocate 命令时，tester 就会获得用户组 mlocate 的执行权限，又由于用户组 mlocate 对 mlocate.db 具有读权限，所以 tester 就可以读取 mlocate.db 了。程序的执行过程如下图所示：</p>
<p><img loading="lazy" src="/Distributions/952033-20180915174309311-990901650.png" alt=""  />
</p>
<p>除二进制程序外，SGID 也可以用在目录上。当一个目录设置了 SGID 权限后，它具有如下功能：</p>
<ol>
<li>用户若对此目录具有 r 和 x 权限，该用户能够进入该目录</li>
<li>用户在此目录下的有效用户组将变成该目录的用户组</li>
<li>若用户在此目录下拥有 w 权限，则用户所创建的新文件的用户组与该目录的用户组相同</li>
</ol>
<h4 id="sbit">SBIT<a hidden class="anchor" aria-hidden="true" href="#sbit">#</a></h4>
<p>其实 SBIT 与 SUID 和 SGID 的关系并不大。SBIT 是 the restricted deletion flag or sticky bit 的简称。</p>
<p>SBIT 目前只对目录有效，用来阻止非文件的所有者删除文件。比较常见的例子就是 <code>/tmp</code> 目录：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ls -ld /tmp 
drwxrwxrwt <span style="color:#ae81ff">22</span> root root <span style="color:#ae81ff">4096</span> Mar  <span style="color:#ae81ff">2</span> 20:57 /tmp
</code></pre></div><p>权限信息中最后一位 t 表明该目录被设置了 SBIT 权限。SBIT 对目录的作用是：当用户在该目录下创建新文件或目录时，仅有自己和 root 才有权力删除。</p>
<h4 id="设置权限">设置权限<a hidden class="anchor" aria-hidden="true" href="#设置权限">#</a></h4>
<p><strong>以数字的方式设置权限</strong></p>
<p>SUID、SGID、SBIT 权限对应的数字如下：</p>
<pre tabindex="0"><code>SUID-&gt;4
SGID-&gt;2
SBIT-&gt;1
</code></pre><p>所以如果要为一个文件权限为 &ldquo;-rwxr-xr-x&rdquo; 的文件设置 SUID 权限，需要在原先的 755 前面加上 4，也就是 4755：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ chmod <span style="color:#ae81ff">4755</span> filename
</code></pre></div><p>同样，可以用 2 和 1 来设置 SGID 和 SBIT 权限。设置完成后分别会用 s, s, t 代替文件权限中的 x。</p>
<p>其实，还可能出现 S 和 T 的情况。s 和 t 是替代 x 这个权限的，但是，如果它本身没有 x 这个权限，添加 SUID、SGID、SBIT 权限后就会显示为大写 S 或大写 T。比如我们为一个权限为 666 的文件添加 SUID、SGID、SBIT 权限：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ chmod <span style="color:#ae81ff">666</span> nickfile
$ ll nickfile 
-rw-rw-rw- <span style="color:#ae81ff">1</span> nick nick <span style="color:#ae81ff">0</span> Mar  <span style="color:#ae81ff">2</span> 21:03 nickfile
$ chmod <span style="color:#ae81ff">7666</span> nickfile
$ ll nickfile 
-rwSrwSrwT <span style="color:#ae81ff">1</span> nick nick <span style="color:#ae81ff">0</span> Mar  <span style="color:#ae81ff">2</span> 21:03 nickfile
</code></pre></div><p><strong>通过符号类型改变权限</strong></p>
<p>除了使用数字来修改权限，还可以使用符号：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ chmod u+s testfile <span style="color:#75715e"># 为 testfile 文件加上 SUID 权限。</span>
$ chmod g+s testdir  <span style="color:#75715e"># 为 testdir 目录加上 SGID 权限。</span>
$ chmod o+t testdir  <span style="color:#75715e"># 为 testdir 目录加上 SBIT 权限。</span>
</code></pre></div><h3 id="umaskhttpswwwcnblogscomsparkdevp9651890html"><a href="https://www.cnblogs.com/sparkdev/p/9651890.html">umask</a><a hidden class="anchor" aria-hidden="true" href="#umaskhttpswwwcnblogscomsparkdevp9651890html">#</a></h3>
<h4 id="默认权限">默认权限<a hidden class="anchor" aria-hidden="true" href="#默认权限">#</a></h4>
<p>为了查看用户创建的文件和目录的默认权限，我们用一个普通的用户创建文件 myfile 和目录 mydir 并查看它们的默认权限：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ touch myfile
$ mkdir mydir
$ ll
total 4.0K
drwxrwxr-x <span style="color:#ae81ff">2</span> nick nick 4.0K Mar  <span style="color:#ae81ff">2</span> 21:09 mydir
-rw-rw-r-- <span style="color:#ae81ff">1</span> nick nick    <span style="color:#ae81ff">0</span> Mar  <span style="color:#ae81ff">2</span> 21:09 myfile
</code></pre></div><p>目录的权限为 775，文件的权限为 664。默认情况下对于目录来说最大的权限是 777，对于文件来说最大的权限一般为 666(只有可以执行的文件才添加可执行权限)。所以我们创建的文件和目录的共同特点是从最大权限中减其他用户的写权限。而这个被减去的值就是我们常说的 umask。umask 还是 bash 的一个内置命令，默认输出当前用户的 umask 值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ umask
<span style="color:#ae81ff">002</span>
</code></pre></div><p>注意，umask 显示的值为从默认的最大权限中减去的值。</p>
<h4 id="默认策略">默认策略<a hidden class="anchor" aria-hidden="true" href="#默认策略">#</a></h4>
<p>系统在用户登录时通过 login 程序调用 pam_umask 模块设置用户默认的 umask。从 login 程序的配置文件 <code>/etc/login.defs</code> 中我们可以找到 umask 相关的配置：</p>
<pre tabindex="0"><code>...
UMASK          022
...
USERGROUPS_ENAB yes
...
</code></pre><p>用户的默认 umask 应该是 022，但当 USERGROUPS_ENAB 被设置为 yes 时(默认值)，对于 uid 和 gid 相同且用户名和主组名相同的用户，系统会把其 umask 改为 002。</p>
<p>于 root 用户的特殊性，它默认的 umask 与其它用户是不同的，其值为 022：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># umask</span>
<span style="color:#ae81ff">0022</span>
</code></pre></div><p>第一个 0 表示 8 进制，这里我们可以暂时忽略它。</p>
<h4 id="命令">命令<a hidden class="anchor" aria-hidden="true" href="#命令">#</a></h4>
<p>umask 是 bash 的一个内置命令，用来显示或设置新建文件/目录的权限掩码(umask)。前面我们以数字的方式输出了用户默认的 umask 值，这次我们以符号的方式进行输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ umask -S
u<span style="color:#f92672">=</span>rwx,g<span style="color:#f92672">=</span>rwx,o<span style="color:#f92672">=</span>rx
</code></pre></div><p>以符号输出的就是用户创建目录时的默认权限，也就是 775。</p>
<p>为了改变用户创建的文件/目录的默认值，我们可以改变 umask 的默认值。</p>
<p><strong>设置 umask 值</strong></p>
<p>最简单的方式就是为 umask 命令指定一个数字：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ umask <span style="color:#ae81ff">026</span>
</code></pre></div><p>026 的含义为：去掉 group 中的写权限，去掉 other 中的读写权限。</p>
<p>这时创建的文件权限为 640，目录权限为 751。注意，修改 umask 后只有新建的文件和目录受影响，已经存在的文件和目录的权限不会被影响。</p>
<p><strong>以符号的方式设置 umask 值</strong></p>
<p>比如下面的命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ umask u<span style="color:#f92672">=</span>,g<span style="color:#f92672">=</span>w,o<span style="color:#f92672">=</span>rwx
</code></pre></div><p>上面的命令表示从 group 中去掉写权限，从 other 中去掉读写执行的权限。</p>
<p>注意：&quot;=&quot; 号在 umask 命令和 chmod 命令中的作用恰恰相反。在 chmod 命令中，利用它来设置指定的权限，而其余权限则被删除。但是在 umask 命令中，将在原有权限的基础上删除指定的权限。</p>
<p><strong>在 ~/.bashrc 文件中为用户设置默认的 umask</strong></p>
<p>如果让用户每次登陆后都执行 umask 命令修改默认的 umask 值是不科学的，我们可以在用户的 ~/.bashrc 文件中执行 umask 命令，这样用户登录后 umask 的值自动就变成了设置的值。把下面的命令添加到 ~/.bashrc 文件的最后一行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">umask <span style="color:#ae81ff">026</span>
</code></pre></div><h4 id="与-acl">与 ACL<a hidden class="anchor" aria-hidden="true" href="#与-acl">#</a></h4>
<p>如果一个目录没有被设置 default ACL，那么将由 umask 决定新文件的 ACL 权限。这种情况其实就是我们常见的没有 ACL 权限时的情况。比如我们设置 umask 为 026，那么创建的文件和目录的权限就是由它决定的。</p>
<p>如果一个目录被设置了 default ACL，那么将会由文件创建函数的 mode 参数和目录的 default ACL 共通决定新文件的 ACL 权限，此时 umask 被忽略。还以 umask 026 为例，我们创建一个目录 dir2 并设置 default ACL 权限：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ setfacl -m d:u:tester:rwx dir2
$ getfacl dir2 
<span style="color:#75715e"># file: dir2</span>
<span style="color:#75715e"># owner: nick</span>
<span style="color:#75715e"># group: nick</span>
user::rwx
group::r-x
other::--x
default:user::rwx
default:user:tester:rwx
default:group::rwx
default😷:rwx
default:other::r-x
</code></pre></div><p>然后在 dir2 目录中创建文件 testfile：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ dir2 touch testfile
$ dir2 ll testfile 
-rw-rw-r--+ <span style="color:#ae81ff">1</span> nick nick <span style="color:#ae81ff">0</span> Mar  <span style="color:#ae81ff">2</span> 21:26 testfile
</code></pre></div><p>这次 testfile 的权限已经不受 umask 的影响了！</p>
<h3 id="aclhttpswwwcnblogscomsparkdevp5536868html"><a href="https://www.cnblogs.com/sparkdev/p/5536868.html">ACL</a><a hidden class="anchor" aria-hidden="true" href="#aclhttpswwwcnblogscomsparkdevp5536868html">#</a></h3>
<p>ACL的全称是 Access Control List (访问控制列表) ，一个针对文件/目录的访问控制列表。它在UGO权限管理的基础上为文件系统提供一个额外的、更灵活的权限管理机制。它被设计为UNIX文件权限管理的一个补充。<strong>ACL允许你给任何特定的用户或用户组设置任何文件/目录的访问权限</strong>。</p>
<p>ACL需要Linux内核和文件系统的配合才能工作，大多数Linux发行版本默认都是支持的。但最好还是能够先检查一下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo tune2fs -l /dev/sda1 | grep <span style="color:#e6db74">&#34;Default mount options:&#34;</span>
Default mount options:    user_xattr acl
</code></pre></div><h4 id="设置权限-1">设置权限<a hidden class="anchor" aria-hidden="true" href="#设置权限-1">#</a></h4>
<p>可以使用setfacl和getfacl命令来设置或观察文件/目录的acl权限。</p>
<p>当前用户是 nick，再创建两个用户 tester 和 tester1 用来进行测试：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo adduser tester
</code></pre></div><p>创建文件 aclfile，检查其默认的权限信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ touch aclfile
$ ll aclfile 
-rw-rw-r-- <span style="color:#ae81ff">1</span> nick nick <span style="color:#ae81ff">0</span> Mar  <span style="color:#ae81ff">2</span> 21:40 aclfile
$ getfacl aclfile
<span style="color:#75715e"># file: aclfile</span>
<span style="color:#75715e"># owner: nick</span>
<span style="color:#75715e"># group: nick</span>
user::rw-
group::rw-
other::r--
</code></pre></div><p>把用户切换为 tester，发现没有写文件的权限：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ echo <span style="color:#e6db74">&#34;hello&#34;</span> &gt;&gt; aclfile
bash: aclfile: Permission denied
</code></pre></div><p>这是因为 other 没有写 aclfile 文件的权限。</p>
<p>下面我们为 tester 用户赋予读写 aclfile 文件的权限：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ setfacl -m u:tester:rw aclfile
</code></pre></div><p>修改成功后再次以 tester 用户的身份向 aclfile 文件写入数据，这次已经可以正常写入了。查看 aclfile 文件的权限：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ getfacl aclfile
<span style="color:#75715e"># file: aclfile</span>
<span style="color:#75715e"># owner: nick</span>
<span style="color:#75715e"># group: nick</span>
user::rw-
user:tester:rw-
group::rw-
mask::rw-
other::r--
</code></pre></div><p>多出了一些信息，其中比较重要的是 user:tester:rw-，就是它让用户 tester 具有了读写 aclfile 的权限。</p>
<p>针对用户组来设置权限和针对用户的设置几乎一样，只是把小写的 u 换成小写的 g 就行了。</p>
<h4 id="继承权限">继承权限<a hidden class="anchor" aria-hidden="true" href="#继承权限">#</a></h4>
<p>acl 能让创建的子文件或者子文件夹继承父文件夹的权限设置！</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ mkdir mydir
$ ll -d mydir
drwxrwxr-x <span style="color:#ae81ff">2</span> nick nick 4.0K Mar  <span style="color:#ae81ff">2</span> 21:09 mydir
$ setfacl -m d:u:tester:rwx mydir
$ getfacl mydir
<span style="color:#75715e"># file: mydir</span>
<span style="color:#75715e"># owner: nick</span>
<span style="color:#75715e"># group: nick</span>
user::rwx
group::rwx
other::r-x
default:user::rwx
default:user:tester:rwx
default:group::rwx
default😷:rwx
default:other::r-x
</code></pre></div><p>这次多出了一些以 default 开头的行，这些 default 权限信息只能在目录上设置，然后会被目录中创建的文件和目录继承。下面分别在 mydir 目录下创建文件 testfile 和目录 testdir，并查看它们的 acl 权限：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ touch testfile
$ mkdir testdir
$ getfacl testfile
<span style="color:#75715e"># file: testfile</span>
<span style="color:#75715e"># owner: nick</span>
<span style="color:#75715e"># group: nick</span>
user::rw-
user:tester:rwx
group::rwx
mask::rw-
other::r--
</code></pre></div><p>从上面可以看到文件 testfile 继承了父目录的 acl 权限，因此用户 tester 对它有读写权限。下面再看看 testdir 目录：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ getfacl testdir
<span style="color:#75715e"># file: testdir</span>
<span style="color:#75715e"># owner: nick</span>
<span style="color:#75715e"># group: nick</span>
user::rwx
user:nick:rwx
group::rwx
mask::rwx
other::r-x
default:user::rwx
default:user:tester:rwx
default:group::rwx
default😷:rwx
default:other::r-x
</code></pre></div><p>从图中可以看出，testdir 目录不仅继承了 tester 的访问权限，还继承了父目录上的 default 权限。也就是说我们通过这种方式设置在目录上的权限可以被子目录递归的继承下去。</p>
<h4 id="操作权限">操作权限<a hidden class="anchor" aria-hidden="true" href="#操作权限">#</a></h4>
<h5 id="更改">更改<a hidden class="anchor" aria-hidden="true" href="#更改">#</a></h5>
<p><strong>-m 选项其实是在更改文件和目录的 ACL 权限</strong></p>
<ul>
<li>当一个用户或组的 ACL 权限不存在时，-m 选项执行的是添加操作，</li>
<li>如果一个用户或组的 ACL 权限已经存在时，-m 选项执行的是更新操作。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ setfacl -m u:tester:rwx aclfile
$ setfacl -m u:tester:rw aclfile
</code></pre></div><p><strong>-set 选项会先清除掉原有的 ACL 权限，然后添加新的权限</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ setfacl --set u::rw,u:tester:rwx,g::r,o::- aclfile
$ getfacl aclfile
<span style="color:#75715e"># file: aclfile</span>
<span style="color:#75715e"># owner: nick</span>
<span style="color:#75715e"># group: nick</span>
user::rw-
user:tester:rwx
group::r--
mask::rwx
other::---
</code></pre></div><p>需要注意的是一定要包含 UGO 权限的设置，不能象 -m 一样只包含 ACL 权限。o::- 是另一个需要注意的地方，其完整的写法是 other::-，就像 u::rw 的完整写法是 user::rw- 一样。通常我们可以把 &ldquo;-&rdquo; 省略，但是当权限位只包含 &ldquo;-&rdquo; 时，就至少要保留一个。如果写成了o::，就会报错。</p>
<h5 id="删除">删除<a hidden class="anchor" aria-hidden="true" href="#删除">#</a></h5>
<p>通过 setfacl 命令的 -x 选项来删除指定用户或组的 ACL 权限，还可以通过 -b 选项来清除文件和目录上所有的 ACL 权限。</p>
<p>下面通过 -x 选项删除 user tester 的 ACL 权限，注意命令中只指定了用户的名称而没有指定权限信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ getfacl aclfile 
<span style="color:#75715e"># file: aclfile</span>
<span style="color:#75715e"># owner: nick</span>
<span style="color:#75715e"># group: nick</span>
user::rw-
user:tester:rwx
group::rw-
mask::rwx
other::r--
$ setfacl -x u:tester aclfile
$ getfacl aclfile            
<span style="color:#75715e"># file: aclfile</span>
<span style="color:#75715e"># owner: nick</span>
<span style="color:#75715e"># group: nick</span>
user::rw-
group::rw-
mask::rw-
other::r--
</code></pre></div><p>下面通过 -b 选项一次性删除 aclfile 上所有的 ACL 权限：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ setfacl -b aclfile
getfacl aclfile   
<span style="color:#75715e"># file: aclfile</span>
<span style="color:#75715e"># owner: nick</span>
<span style="color:#75715e"># group: nick</span>
user::rw-
group::rw-
other::r--
</code></pre></div><h5 id="备份和恢复">备份和恢复<a hidden class="anchor" aria-hidden="true" href="#备份和恢复">#</a></h5>
<p>常见的文件操作命令 cp 和 mv 等都支持 ACL 权限，只是 cp 命令需要加上 -p 参数。但是 tar 等常见的备份工具不会保留目录和文件的 ACL 权限信息。如果希望备份和恢复带有 ACL 权限的文件和目录，可以先把 ACL 权限信息备份到一个文件里，然后再用 -restore 选项来恢复这些信息。</p>
<p>使用下面的命令导出 acldir 目录的 ACL 权限信息并保存到文件 acldir.acl 文件中：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ getfacl -R acldir &gt; acldir.acl
</code></pre></div><p>通过下面的命令把它们的 ACL 权限都恢复回来：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ setfacl --restore acldir.acl
</code></pre></div><h4 id="实现原理httpswwwcnblogscomsparkdevp9694015html"><a href="https://www.cnblogs.com/sparkdev/p/9694015.html">实现原理</a><a hidden class="anchor" aria-hidden="true" href="#实现原理httpswwwcnblogscomsparkdevp9694015html">#</a></h4>
<p><strong>ACL 条目</strong></p>
<p><img loading="lazy" src="/Disributions/952033-20180923221833345-608906567.png" alt=""  />
</p>
<h3 id="进程权限httpswwwcnblogscomsparkdevp9694103html"><a href="https://www.cnblogs.com/sparkdev/p/9694103.html">进程权限</a><a hidden class="anchor" aria-hidden="true" href="#进程权限httpswwwcnblogscomsparkdevp9694103html">#</a></h3>
<p>ugo 权限信息是文件的属性，它指明了用户与文件之间的关系。但是真正操作文件的却是进程，也就是说用户所拥有的文件访问权限是通过进程来体现的。</p>
<p>概念：</p>
<ul>
<li>
<p><strong>用户</strong> 对于支持多任务的 Linux 系统来说，用户就是获取资源的凭证。</p>
</li>
<li>
<p><strong>权限</strong> 权限用来控制用户对计算机资源(CPU、内存、文件等)的访问，一般会分为认证和授权两步。比如用户先经过认证机制(authentication)登录系统，然后由授权系统(authorization)对用户的操作进行授权。</p>
</li>
<li>
<p><strong>进程</strong> 进程是任何支持多道程序设计的操作系统中的基本概念。通常把进程定义为<code>程序执行时的一个实例</code>。因此，如果有 10 个用户同时运行 vi，就会有 10 个独立的进程(尽管它们共享同一份可执行代码)。</p>
<p>实际上，是进程在帮助我们完成各种任务。进程就是用户访问计算机资源的代理，用户执行的操作其实是带有用户身份信息的进程执行的操作。</p>
</li>
<li>
<p><strong>进程权限</strong> 既然是进程在为用户执行具体的操作，那么当用户要访问系统的资源时就必须给进程赋予权限。也就是说<em>进程必须携带发起这个进程的用户的身份信息才能够进行合法的操作。</em></p>
</li>
</ul>
<h4 id="登陆过程">登陆过程<a hidden class="anchor" aria-hidden="true" href="#登陆过程">#</a></h4>
<p>在 Linux 系统启动后，init 系统会 fork 出子进程执行 <code>/sbin/getty</code> 程序等待用户登录。当用户进行登录操作时，该子进程通过 exec 函数开始执行 <code>/bin/login</code> 程序(此时该进程已经变成了 login 进程)。由 login 进程验证我们的用户名和密码并查询 <code>/etc/passwd</code> 和 <code>/etc/shadow</code> 确定其合法性。如果是合法的用户，该进程再次通过 exec 函数执行用户的默认 shell 程序，此时的 login 进程就变成了 shell 进程(笔者机器上是 bash 进程)。并且**该 shell 进程的有效身份被设置成为该用户的身份，之后 fork 此 shell 进程的子进程都会继承该有效身份。**我们可以通过下图来理解用户从 tty 登录系统的过程：</p>
<p><img loading="lazy" src="/Distributions/952033-20180923224826617-131415814.png" alt=""  />
</p>
<p>简单点说就是：<strong>用户登录后， shell 进程的有效用户就是该用户。</strong></p>
<h4 id="user-id">user id<a hidden class="anchor" aria-hidden="true" href="#user-id">#</a></h4>
<p>通过 <code>cat /proc/&lt;PID&gt;/status</code> 命令，我们可以查看到进程所属的用户和组相关的信息：</p>
<pre tabindex="0"><code>Uid:    1000    1000    1000    1000
Gid:    1000    1000    1000    1000
</code></pre><p>通过 man proc 可以查询到第一行的四个数字分别是 real user id, effective user id, saved set user id 和 filesystem UID，第二行则是对应的组 ID。</p>
<p><strong>real user id</strong></p>
<p>real user id 是执行进程者的 user id，一般情况下就是用户登录时的 user id。子进程的 real user id 从父进继承。通常这个是不更改的，也不需要更改。比如我以用户 nick 登录 Linux 系统，我接下来运行的所有命令的进程的 real user id 都是 nick 的 user id。</p>
<p><strong>effective user id</strong></p>
<p><em>如果要判断一个进程是否对某个文件有操作权限，验证的是进程的 effective user id，而不是 real user id。</em></p>
<p>通常不建议直接使用 root 用户进行操作的，但是在很多情况下，程序可能需要特殊的权限。比如 passwd 程序需要 root 权限才能够为普通用户修改密码，一些 services 程序的操作也经常需要特殊的权限。为此，Linux 中设计了一些特殊的权限（SUID/SGID/SBIT）。这里我们以 passwd 程序为例，为二进制可执行文件 <code>/usr/bin/passwd</code> <em>设置 set-user-id bit=ON，这个可执行文件被用 exec 启动之后的进程的 effective user id 就是这个可执行文件的 owner id，而并非父进程的 real user id</em>。如果 set-user-id bit=OFF 的时候，这个被 exec 起来的进程的 effective user id 应该是等于进程的 user id 的。</p>
<p>其实我们通过 ps aux 查看的结果中，第一列显示的就是进程的 effective user。</p>
<p><strong>saved set user id</strong></p>
<p>saved set user id 相当于是一个 buffer，在 exec 函数启动之后，它会拷贝 effective user id 位的信息覆盖自己。</p>
<p>对于非 root 用户来说，可以在未来使用 setuid() 函数将 effective user id 设置成为 real user id 或 saved set user id 中的任何一个。但是不允许非 root 用户用 setuid() 函数把 effective user id 设置成为任何第三个 user id。</p>
<p>对于 root 用户来说，调用 setuid() 的时候，将会设置所有的这三个 user id。</p>
<h4 id="外部命令">外部命令<a hidden class="anchor" aria-hidden="true" href="#外部命令">#</a></h4>
<p>在 shell 中执行的命令分为内部命令和外部命令两种。</p>
<ul>
<li>内部命令：内建的，相当于 shell 的子函数</li>
<li>外部命令：在文件系统的某个路径下的一个可执行文件</li>
</ul>
<p>外部命令的执行过程如下：</p>
<ol>
<li>Shell 通过 fork() 函数建立一个新的子进程，新的子进程为当前 shell 进程的一个副本。</li>
<li>在新的进程里，从 PATH 变量所列出的目录中寻找指定的命令程序。当命令名称包含有斜杠(/)符号时，将略过路径查找步骤。</li>
<li>在新的进程里，通过 exec 系列函数，以所找到的新程序替换 shell 程序并执行。</li>
<li>子进程退出后，最初的 shell 会接着从终端读取并执行下一条命令。</li>
</ol>
<p>我们通过下面的例子来理解在 shell 中执行外部命令的过程，例子很简单就是通过 cat 命令查看一个文本文件 test.log：</p>
<pre tabindex="0"><code>$ cat test.log
</code></pre><p>我们先来检查一下当前用户以及相关文件的权限：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ uid<span style="color:#f92672">=</span>1000<span style="color:#f92672">(</span>nick<span style="color:#f92672">)</span> gid<span style="color:#f92672">=</span>1000<span style="color:#f92672">(</span>nick<span style="color:#f92672">)</span> groups<span style="color:#f92672">=</span>1000<span style="color:#f92672">(</span>nick<span style="color:#f92672">)</span>,4<span style="color:#f92672">(</span>adm<span style="color:#f92672">)</span>,24<span style="color:#f92672">(</span>cdrom<span style="color:#f92672">)</span>,27<span style="color:#f92672">(</span>sudo<span style="color:#f92672">)</span>,30<span style="color:#f92672">(</span>dip<span style="color:#f92672">)</span>,46<span style="color:#f92672">(</span>plugdev<span style="color:#f92672">)</span>,120<span style="color:#f92672">(</span>lpadmin<span style="color:#f92672">)</span>,132<span style="color:#f92672">(</span>lxd<span style="color:#f92672">)</span>,133<span style="color:#f92672">(</span>sambashare<span style="color:#f92672">)</span>
$ ll /bin/cat
-rwxr-xr-x <span style="color:#ae81ff">1</span> root root 43K Sep  <span style="color:#ae81ff">5</span>  <span style="color:#ae81ff">2019</span> /bin/cat
$ ll test.log 
-rw-rw-r-- <span style="color:#ae81ff">1</span> nick nick <span style="color:#ae81ff">0</span> Mar  <span style="color:#ae81ff">2</span> 23:25 test.log
</code></pre></div><p>当前用户 nick 的 real user id 为 1000，<code>/bin/cat</code> 文件的所有者为 root，但是所有人都有执行权限，test.log 文件的所有者为 nick。我们结合下图来介绍 cat test.log 命令的执行过程：</p>
<p><img loading="lazy" src="/Distributions/952033-20180923225453228-1326852315.png" alt=""  />
</p>
<p>当我们在 shell 中执行一个外部程序的时候，默认情况下进程的 effective user ID 等于 real user ID，进程的 effective group ID 等于 real group ID(接下来的介绍中省略 group ID)。当我们以用户 nick 登录系统，并在 bash 中键入 cat test.log 命令并回车后。Bash 先通过 fork() 建立一个新的子进程，这个新的子进程是当前 bash 进程的一个副本。新的进程在 PATH 变量指定的路径中搜索 cat 程序，找到 /bin/cat 程序后检查其权限。/bin/cat 程序的所有者为 root，但是其他人具有读和执行的权限，所以新进程可以通过 exec 函数用 cat 程序的代码段替换当前进程中的代码段(把 /bin/cat 程序加载到了内存中，此时的进程已经变成了 cat 进程，cat 进程会从 _start 函数开始执行)。由于 cat 进程是由用户 nick 启动的，所以 cat 进程的 effective user ID 是 1000(nick)。同时 cat 进程的 effective user ID 和 test.log 文件的 owner ID 相同(都是 1000)，所以 cat 进程拥有对此文件的 rw- 权限，那么顺理成章地就可以读写 test.log 文件的内容了。</p>
<h4 id="脚本">脚本<a hidden class="anchor" aria-hidden="true" href="#脚本">#</a></h4>
<p>在 shell 中执行脚本的方式和执行外部命令的方式差不多，比如我们要执行下面的脚本：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ /bin/bash ./test.sh
</code></pre></div><p>这时同样会 fork 出一个子进程。只不过脚本与程序相比没有代码段，也没有 _start 函数，此时 exec 函数就会执行另外一套机制。比如我们在 test.sh 文件的第一行通过 #!/bin/bash 指定了一个解释器，那么解释器程序的代码段会用来替换当前进程的代码段，并且从解释器的 _start 函数开始执行，而这个文本文件被当作命令行参数传给解释器。所以上面的命令执行过程为：Bash 进程 fork/exec 一个子 bash 进程用于执行脚本，子 bash 进程继承父进程的环境变量、用户信息等内容，父进程等待子 bash 进程终止。</p>
<ul>
<li>权限</li>
<li>cgroub</li>
<li>sudo</li>
<li>fdisk</li>
<li>自动更新</li>
<li>LVM</li>
<li>进程</li>
</ul>
<h3 id="capabilitieshttpswwwcnblogscomsparkdevp11417781html"><a href="https://www.cnblogs.com/sparkdev/p/11417781.html">Capabilities</a><a hidden class="anchor" aria-hidden="true" href="#capabilitieshttpswwwcnblogscomsparkdevp11417781html">#</a></h3>
<p>为了执行权限检查，Linux 区分两类进程：特权进程(其有效用户标识为 0，也就是超级用户 root)和非特权进程(其有效用户标识为非零)。 特权进程绕过所有内核权限检查，而非特权进程则根据进程凭证(通常为有效 UID，有效 GID 和补充组列表)进行完全权限检查。</p>
<p>以常用的 passwd 命令为例，修改用户密码需要具有 root 权限，而普通用户是没有这个权限的。但是实际上普通用户又可以修改自己的密码，这是怎么回事？在 Linux 的权限控制机制中，有一类比较特殊的权限设置，比如 SUID(Set User ID on execution)。因为程序文件 /bin/passwd 被设置了 SUID 标识，所以普通用户在执行 passwd 命令时，进程是以 passwd 的所有者，也就是 root 用户的身份运行，从而修改密码。</p>
<p>SUID 虽然可以解决问题，却带来了安全隐患。当运行设置了 SUID 的命令时，通常只是需要很小一部分的特权，但是 SUID 给了它 root 具有的全部权限。因此一旦 被设置了 SUID 的命令出现漏洞，就很容易被利用。也就是说 SUID 机制在增大了系统的安全攻击面。</p>
<p>Linux 引入了 capabilities 机制对 root 权限进行细粒度的控制，实现按需授权，从而减小系统的安全攻击面。</p>
<h4 id="简介-2">简介<a hidden class="anchor" aria-hidden="true" href="#简介-2">#</a></h4>
<p>从内核 2.2 开始，Linux 将传统上与超级用户 root 关联的特权划分为不同的单元，称为 capabilites。Capabilites 作为线程(Linux 并不真正区分进程和线程)的属性存在，每个单元可以独立启用和禁用。如此一来，权限检查的过程就变成了：在执行特权操作时，如果进程的有效身份不是 root，就去检查是否具有该特权操作所对应的 capabilites，并以此决定是否可以进行该特权操作。比如要向进程发送信号(kill())，就得具有 capability <strong>CAP_KILL</strong>；如果设置系统时间，就得具有 capability <strong>CAP_SYS_TIME</strong>。</p>
<p>下面是从 <a href="http://man7.org/linux/man-pages/man7/capabilities.7.html">capabilities man page</a> 中摘取的 capabilites 列表：</p>
<table>
<thead>
<tr>
<th>capability 名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CAP_AUDIT_CONTROL</td>
<td>启用和禁用内核审计；改变审计过滤规则；检索审计状态和过滤规则</td>
</tr>
<tr>
<td>CAP_AUDIT_READ</td>
<td>允许通过 multicast netlink 套接字读取审计日志</td>
</tr>
<tr>
<td>CAP_AUDIT_WRITE</td>
<td>将记录写入内核审计日志</td>
</tr>
<tr>
<td>CAP_BLOCK_SUSPEND</td>
<td>使用可以阻止系统挂起的特性</td>
</tr>
<tr>
<td>CAP_CHOWN</td>
<td>修改文件所有者的权限</td>
</tr>
<tr>
<td>CAP_DAC_OVERRIDE</td>
<td>忽略文件的 DAC 访问限制</td>
</tr>
<tr>
<td>CAP_DAC_READ_SEARCH</td>
<td>忽略文件读及目录搜索的 DAC 访问限制</td>
</tr>
<tr>
<td>CAP_FOWNER</td>
<td>忽略文件属主 ID 必须和进程用户 ID 相匹配的限制</td>
</tr>
<tr>
<td>CAP_FSETID</td>
<td>允许设置文件的 setuid 位</td>
</tr>
<tr>
<td>CAP_IPC_LOCK</td>
<td>允许锁定共享内存片段</td>
</tr>
<tr>
<td>CAP_IPC_OWNER</td>
<td>忽略 IPC 所有权检查</td>
</tr>
<tr>
<td>CAP_KILL</td>
<td>允许对不属于自己的进程发送信号</td>
</tr>
<tr>
<td>CAP_LEASE</td>
<td>允许修改文件锁的 FL_LEASE 标志</td>
</tr>
<tr>
<td>CAP_LINUX_IMMUTABLE</td>
<td>允许修改文件的 IMMUTABLE 和 APPEND 属性标志</td>
</tr>
<tr>
<td>CAP_MAC_ADMIN</td>
<td>允许 MAC 配置或状态更改</td>
</tr>
<tr>
<td>CAP_MAC_OVERRIDE</td>
<td>覆盖 MAC(Mandatory Access Control)</td>
</tr>
<tr>
<td>CAP_MKNOD</td>
<td>允许使用 mknod() 系统调用</td>
</tr>
<tr>
<td>CAP_NET_ADMIN</td>
<td>允许执行网络管理任务</td>
</tr>
<tr>
<td>CAP_NET_BIND_SERVICE</td>
<td>允许绑定到小于 1024 的端口</td>
</tr>
<tr>
<td>CAP_NET_BROADCAST</td>
<td>允许网络广播和多播访问</td>
</tr>
<tr>
<td>CAP_NET_RAW</td>
<td>允许使用原始套接字</td>
</tr>
<tr>
<td>CAP_SETGID</td>
<td>允许改变进程的 GID</td>
</tr>
<tr>
<td>CAP_SETFCAP</td>
<td>允许为文件设置任意的 capabilities</td>
</tr>
<tr>
<td>CAP_SETPCAP</td>
<td>参考 <a href="http://man7.org/linux/man-pages/man7/capabilities.7.html">capabilities man page</a></td>
</tr>
<tr>
<td>CAP_SETUID</td>
<td>允许改变进程的 UID</td>
</tr>
<tr>
<td>CAP_SYS_ADMIN</td>
<td>允许执行系统管理任务，如加载或卸载文件系统、设置磁盘配额等</td>
</tr>
<tr>
<td>CAP_SYS_BOOT</td>
<td>允许重新启动系统</td>
</tr>
<tr>
<td>CAP_SYS_CHROOT</td>
<td>允许使用 chroot() 系统调用</td>
</tr>
<tr>
<td>CAP_SYS_MODULE</td>
<td>允许插入和删除内核模块</td>
</tr>
<tr>
<td>CAP_SYS_NICE</td>
<td>允许提升优先级及设置其他进程的优先级</td>
</tr>
<tr>
<td>CAP_SYS_PACCT</td>
<td>允许执行进程的 BSD 式审计</td>
</tr>
<tr>
<td>CAP_SYS_PTRACE</td>
<td>允许跟踪任何进程</td>
</tr>
<tr>
<td>CAP_SYS_RAWIO</td>
<td>允许直接访问 /devport、/dev/mem、/dev/kmem 及原始块设备</td>
</tr>
<tr>
<td>CAP_SYS_RESOURCE</td>
<td>忽略资源限制</td>
</tr>
<tr>
<td>CAP_SYS_TIME</td>
<td>允许改变系统时钟</td>
</tr>
<tr>
<td>CAP_SYS_TTY_CONFIG</td>
<td>允许配置 TTY 设备</td>
</tr>
<tr>
<td>CAP_SYSLOG</td>
<td>允许使用 syslog() 系统调用</td>
</tr>
<tr>
<td>CAP_WAKE_ALARM</td>
<td>允许触发一些能唤醒系统的东西(比如 CLOCK_BOOTTIME_ALARM 计时器)</td>
</tr>
</tbody>
</table>
<p><strong>程序文件的 capabilities</strong></p>
<p>在可执行文件的属性中有三个集合来保存三类 capabilities，它们分别是：</p>
<ul>
<li>Permitted</li>
<li>Inheritable</li>
<li>Effective</li>
</ul>
<p>在进程执行时，Permitted 集合中的 capabilites 自动被加入到进程的 Permitted 集合中。</p>
<p>Inheritable 集合中的 capabilites 会与进程的 Inheritable 集合执行逻辑与操作，以确定进程在执行 execve 函数后哪些 capabilites 被继承。</p>
<p>Effective 只是一个 bit。如果设置为开启，那么在执行 execve 函数后，Permitted 集合中新增的 capabilities 会自动出现在进程的 Effective 集合中。</p>
<p><strong>进程的 capabilities</strong></p>
<p>进程中有五种 capabilities 集合类型，分别是：</p>
<ul>
<li>Permitted</li>
<li>Inheritable</li>
<li>Effective</li>
<li>Bounding</li>
<li>Ambient</li>
</ul>
<p>相比文件的 capabilites，进程的 capabilities 多了两个集合，分别是 Bounding 和 Ambient。</p>
<p><code>/proc/[pid]/status</code> 文件中包含了进程的五个 capabilities 集合的信息，我们可以通过下面的命名查看当前进程的 capabilities 信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat /proc/$$/status | grep <span style="color:#e6db74">&#39;Cap&#39;</span>
CapInh:    <span style="color:#ae81ff">0000000000000000</span>
CapPrm:    <span style="color:#ae81ff">0000000000000000</span>
CapEff:    <span style="color:#ae81ff">0000000000000000</span>
CapBnd:    000003ffffffffff
CapAmb:    <span style="color:#ae81ff">0000000000000000</span>
</code></pre></div><p>但是这中方式获得的信息无法阅读，我们需要使用 capsh 命令把它们转义为可读的格式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ capsh --decode<span style="color:#f92672">=</span>0000003fffffffff
</code></pre></div><h4 id="使用">使用<a hidden class="anchor" aria-hidden="true" href="#使用">#</a></h4>
<p><strong>getcap</strong> 命令和 <strong>setcap</strong> 命令分别用来查看和设置程序文件的 capabilities 属性。下面我们演示如何使用 capabilities 代替 ping 命令的 SUID。</p>
<p>因为 ping 命令在执行时需要访问网络，这就需要获得 root 权限，常规的做法是通过 SUID 实现的(和 passwd 命令相同)：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ll /bin/ping
-rwsr-xr-x <span style="color:#ae81ff">1</span> root root 72K Jan <span style="color:#ae81ff">31</span>  <span style="color:#ae81ff">2020</span> /bin/ping
$ ll /usr/bin/passwd 
-rwsr-xr-x <span style="color:#ae81ff">1</span> root root 67K Jul <span style="color:#ae81ff">15</span>  <span style="color:#ae81ff">2021</span> /usr/bin/passwd
</code></pre></div><p>红框中的 s 说明应用程序文件被设置了 SUID，这样普通用户就可以执行这些命令了。</p>
<p>移除 ping 命令文件上的 SUID 权限：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo chmod <span style="color:#ae81ff">755</span> /bin/ping
$ ping baidu.com
ping: socket: Operation not permitted
</code></pre></div><p>在移除 SUID 权限后，普通用户在执行 ping 命令时碰到了 &ldquo;ping: socket: Operation not permitted&rdquo; 错误。</p>
<p><strong>为 ping 命令文件添加 capabilities</strong></p>
<p>执行 ping 命令所需的 capabilities 为 cap_net_admin 和 cap_net_raw，通过 setcap 命令可以添加它们：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo setcap cap_net_admin,cap_net_raw+ep /bin/ping
$ getcap /bin/ping 
/bin/ping <span style="color:#f92672">=</span> cap_net_admin,cap_net_raw+ep
$ ping baidu.com
PING baidu.com <span style="color:#f92672">(</span>220.181.38.148<span style="color:#f92672">)</span> 56<span style="color:#f92672">(</span>84<span style="color:#f92672">)</span> bytes of data.
<span style="color:#ae81ff">64</span> bytes from 220.181.38.148 <span style="color:#f92672">(</span>220.181.38.148<span style="color:#f92672">)</span>: icmp_seq<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> ttl<span style="color:#f92672">=</span><span style="color:#ae81ff">46</span> time<span style="color:#f92672">=</span>33.3 ms
<span style="color:#ae81ff">64</span> bytes from 220.181.38.148 <span style="color:#f92672">(</span>220.181.38.148<span style="color:#f92672">)</span>: icmp_seq<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span> ttl<span style="color:#f92672">=</span><span style="color:#ae81ff">46</span> time<span style="color:#f92672">=</span>40.9 ms
</code></pre></div><p>被赋予合适的 capabilities 后，ping 命令又可以正常工作了，相比 SUID 它只具有必要的特权，在最大程度上减小了系统的安全攻击面。</p>
<p>如果要移除刚才添加的 capabilities，执行下面的命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo setcap cap_net_admin,cap_net_raw-ep /bin/ping
$ getcap /bin/ping 
/bin/ping <span style="color:#f92672">=</span>
</code></pre></div><p>命令中的 ep 分别表示 Effective 和 Permitted 集合，+ 号表示把指定的 capabilities 添加到这些集合中，- 号表示从集合中移除(对于 Effective 来说是设置或者清除位)。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://sakamotokurome.github.io/tags/unix/">Unix</a></li>
      <li><a href="https://sakamotokurome.github.io/tags/linux/">Linux</a></li>
      <li><a href="https://sakamotokurome.github.io/tags/ubuntu/">Ubuntu</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://sakamotokurome.github.io/posts/ubuntutips/">
    <span class="title">« Prev Page</span>
    <br>
    <span>Ubuntu Tips</span>
  </a>
  <a class="next" href="https://sakamotokurome.github.io/posts/ubuntudesktop/">
    <span class="title">Next Page »</span>
    <br>
    <span>Ubuntu Desktop</span>
  </a>
</nav>

  </footer>
</article>

<div class="disqus-container">
  <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    this.page.identifier = 'e7e225';
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "sakamotokurome" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://sakamotokurome.github.io/">Sakamoto Kurome</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
</body>

</html>
